{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/background.jpg","path":"images/background.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/headicon2.jpg","path":"images/headicon2.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1526914436000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1526914436000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1526914436000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1526914436000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1526914436000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1526914436000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1526914436000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1526914436000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1526914436000},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1583035845000},{"_id":"themes/next/README.md","hash":"d3035c6961280c1b4afb3a07661f5a635ce1eaff","modified":1583035845000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1583035845000},{"_id":"themes/next/_config.yml","hash":"78e661af237db2d5d4486654e946e30ee57cba18","modified":1585994036698},{"_id":"themes/next/gulpfile.js","hash":"72e6d5a6e32d5f95d82e4c4d0c963d39555bb760","modified":1583035845000},{"_id":"themes/next/package.json","hash":"2941b27b2f62b5fe4821556de8cb90b570fbfb1d","modified":1583035845000},{"_id":"source/_posts/DS-linklist.md","hash":"560a34d0ca3485bd70122a54c95d02d0a9bf417f","modified":1584775855161},{"_id":"source/_posts/DS-string.md","hash":"5e9d4f45d1f50533f335ab6de4e04120a2431a14","modified":1584775855165},{"_id":"source/_posts/android-AndroidManifest.md","hash":"253f8b552c8640b0f6e1cb9f55fade558701a39d","modified":1584775855165},{"_id":"source/_posts/android-adb.md","hash":"ac24893ce96033303d866a3b5b3ee953fbcfb1ca","modified":1584775855165},{"_id":"source/_posts/android-howto-makeapk-cmd.md","hash":"1dee0bca9ef9a69b6271c2ce7749394305ed5fb4","modified":1584775855165},{"_id":"source/_posts/android-jni.md","hash":"1e5e3ff923760b36726bd4471d90df47f448d36f","modified":1584775855165},{"_id":"source/_posts/android-makefirst-app.md","hash":"540c4fc8a25e3849eb25be32268a87ae05533183","modified":1584775855165},{"_id":"source/_posts/android-will-write.md","hash":"ed5d9168d985afa717ed4f1337e43c77542baf4f","modified":1584775855165},{"_id":"source/_posts/code-efficandreadable.md","hash":"cb4eb885ef506ea7255b378e0ddc81ff8e20dcdc","modified":1584775855165},{"_id":"source/_posts/cpp-class-memory.md","hash":"4ed50612f3ae705e27d63e824945f5f172639cb5","modified":1584775855165},{"_id":"source/_posts/cpp-conanddest-semantics.md","hash":"76616d9a9a9e7ade4cc467961d0fd65b4ba78969","modified":1584775855165},{"_id":"source/_posts/cpp-conandde.md","hash":"c6b3c0800a69c27798519ac258636d4a5c541180","modified":1584775855165},{"_id":"source/_posts/cpp-const.md","hash":"18d1e31449dfeca1ab303ab4e42989b7074ce23e","modified":1584775855165},{"_id":"source/_posts/cpp-debug-layout-dynamic.md","hash":"738679b2efa4889c5a2b64eb221cbd7bdf6757f2","modified":1584775855165},{"_id":"source/_posts/cpp-datamember-memory.md","hash":"cfa44c11beee42efefb54bec15b95075e166bf9d","modified":1584775855165},{"_id":"source/_posts/cpp-inheritance.md","hash":"7da187a6b5ab931334bf0d3b354d5317a2969422","modified":1584775855165},{"_id":"source/_posts/cpp-debug-layout-static.md","hash":"285a3787327ac8bcfc81cd80a31ef9c7e2178c12","modified":1584775855165},{"_id":"source/_posts/cpp-runtime-semantis.md","hash":"6f9876c236a1d72c2734b3096b969db06907dc69","modified":1584778824432},{"_id":"source/_posts/cpp-funcmember-memory.md","hash":"daf8c557d245496b4a4e0f2f831154c75e7158d8","modified":1584775855165},{"_id":"source/_posts/cpp-polymorphism.md","hash":"1625eddc66584c43198daba8157a88dcdd7c7fbe","modified":1584775855165},{"_id":"source/_posts/cpp-static.md","hash":"7b470a7101957cd445321805478e1b4ca783608d","modified":1584775855165},{"_id":"source/_posts/cpp-this.md","hash":"0ac44157afff38ea61cdc747964c67844da4141e","modified":1584775855165},{"_id":"source/_posts/gdb基本使用.md","hash":"cdb03b4c4808b97041bc2a5b7252cb1b6eeb6273","modified":1594453516137},{"_id":"source/_posts/leetcode-linklist1.md","hash":"5212bcf4eae78ce4119b50fa90bc5a532d3814de","modified":1584775855165},{"_id":"source/_posts/leetcode-linklist3.md","hash":"a5bc88a5d9e786da0ecb97fb22499f856e95a50c","modified":1584775855165},{"_id":"source/_posts/leetcode-string.md","hash":"c5690eff8612214c3c7468ba0a5dd4c5fb9d6728","modified":1584775855165},{"_id":"source/_posts/tcpip-IP.md","hash":"d10ffc4e9a1671a349f609e849e87cb51c7fdd2c","modified":1584775855165},{"_id":"source/_posts/tcpip-MAC.md","hash":"97476df982e25560676f77cd85fe89a70ca98093","modified":1584775855165},{"_id":"source/_posts/tcpip-ARP.md","hash":"3724a39a51379982c6ffcad14c39636d3e64bdaa","modified":1584775855165},{"_id":"source/_posts/tcpip-PF-PACKET.md","hash":"98b75437c9b454fd24b7feb7c30a0fb2f1971edb","modified":1584775855165},{"_id":"source/_posts/tcpip-mtu.md","hash":"266608f5b4b8cfcb862bd25b3463ca60f7f8240d","modified":1584775855165},{"_id":"source/_posts/tcpip-pingtraceroute.md","hash":"ebd9969a48e709a674cedaa399f097e4dc9e8db3","modified":1584775855165},{"_id":"source/_posts/tcpip-routeicmp.md","hash":"b13d6a2ee6a7cc7b2aa246f444a742a91570ab87","modified":1584775855165},{"_id":"source/_posts/leetcode-linklist2.md","hash":"f1151d45fc42be3868930c7150b0f3de3a223944","modified":1584775855165},{"_id":"source/_posts/test-article-picture.md","hash":"731e66290f4b39884029a58b10240e11d6d6966e","modified":1584775855165},{"_id":"source/mentality/index.md","hash":"3932d86762b97a5221ce27c36c11850753accb1c","modified":1584800998938},{"_id":"source/read/index.md","hash":"f0a6c18f9ff24474b6c6b098292b30b098be7cfe","modified":1584800943423},{"_id":"source/_posts/我理解的心理模型.md","hash":"4c2f5a7ace8503658bd58a94dd9663d6223352c7","modified":1591506482035},{"_id":"source/about/index.md","hash":"db016946b1b65505a284f2d84e7aba23f2cd0b43","modified":1584775855169},{"_id":"source/movies/index.md","hash":"7e0f08ab7a2d4081f4d2fe7e856ed93ab7685ebd","modified":1586003654205},{"_id":"source/categories/index.md","hash":"dd3d5d6f7366a53deb0878667c845f3c458b01de","modified":1584775855169},{"_id":"source/tags/index.md","hash":"22a0e0b79bbfd13e3c66bd6fbd2ef264a6c87154","modified":1584775855169},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1526914436000},{"_id":"themes/next/.git/config","hash":"91b6a53b2a7f929b698734717a38d4ac169f0c1f","modified":1526914436000},{"_id":"themes/next/.git/index","hash":"125a45dcd047f2f18c370eb269f7ff33d7b1e803","modified":1584774413690},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1526914306000},{"_id":"themes/next/.git/packed-refs","hash":"8e36811256ee380c2c65692f1b8f8e77c5bc33c9","modified":1526914436000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1526914436000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1526914436000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1526914436000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1526914436000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1583035845000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1583035845000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1583035845000},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1583035845000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"40a8089076005e0d26ef7c0db58a2b5b464cda6c","modified":1583035845000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"08cda41b4bcf687facfda19ab39718ec7a05ae54","modified":1583035845000},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1583035845000},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1583035845000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"682937d48bf5d243842a76190921322e26c75247","modified":1583035845000},{"_id":"themes/next/layout/_layout.swig","hash":"29ee038b0d5ffdb45327598733ea968588367769","modified":1583035845000},{"_id":"themes/next/layout/category.swig","hash":"c55debb2588e4746b02d31ec249bf0a84fdea260","modified":1583035845000},{"_id":"themes/next/layout/archive.swig","hash":"26526c09a4334099e2141456697696fcd1f9783f","modified":1583035845000},{"_id":"themes/next/layout/index.swig","hash":"3bc6fb1e9707d74b96e1346d3f03fe6584f764f4","modified":1583035845000},{"_id":"themes/next/layout/post.swig","hash":"382d9f9a9b35e1f369585f7f9f9b5dd6fa58d2f0","modified":1583035845000},{"_id":"themes/next/layout/page.swig","hash":"ae6c8549242c1fb2483fd68ce9ae1c083785e2ff","modified":1583035845000},{"_id":"themes/next/layout/tag.swig","hash":"7ff6e34d557a3da1c6a29ecd97842bf73ff213dc","modified":1583035845000},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1583035845000},{"_id":"themes/next/languages/de.yml","hash":"109943f7adcd5cdbe4c6c95c9d279603f07edacb","modified":1583035845000},{"_id":"themes/next/languages/default.yml","hash":"20f951dc4df8602ffdd05a1d5899c5a9bc1759cc","modified":1583035845000},{"_id":"themes/next/languages/en.yml","hash":"20f951dc4df8602ffdd05a1d5899c5a9bc1759cc","modified":1583035845000},{"_id":"themes/next/languages/fr.yml","hash":"578a30a51b9ecbbcb4c200362ad9a37ffd3272db","modified":1583035845000},{"_id":"themes/next/languages/es.yml","hash":"53ef4a621fd628748b8ed711fe86080e9c9c91c8","modified":1583035845000},{"_id":"themes/next/languages/hu.yml","hash":"074d069af9aed5ad34fa809bd058a3b9e2d01051","modified":1583035845000},{"_id":"themes/next/languages/fa.yml","hash":"a24e0cf28e9f137d0d2219498778693c3c3960b2","modified":1583035845000},{"_id":"themes/next/languages/it.yml","hash":"ba2c8f51f2f719dabe71b6053c6fe6866161ec66","modified":1583035845000},{"_id":"themes/next/languages/ja.yml","hash":"5e13b521201944815665bd077b65d7ce69622b81","modified":1583035845000},{"_id":"themes/next/languages/nl.yml","hash":"e27b29c60d88ef4c30de291b595cf8cad639c5d1","modified":1583035845000},{"_id":"themes/next/languages/pt.yml","hash":"f7516b9d86b52c80bf63d3efc7ee6fd985205001","modified":1583035845000},{"_id":"themes/next/languages/pt-BR.yml","hash":"0660471e067d01ec80962d5721ae282aafff274d","modified":1583035845000},{"_id":"themes/next/languages/ko.yml","hash":"4aa8f3bf06e02879863b19901476cb23ecd2d709","modified":1583035845000},{"_id":"themes/next/languages/ru.yml","hash":"7dcb2aab65a4b202476856f3e004862334229bcb","modified":1583035845000},{"_id":"themes/next/languages/id.yml","hash":"6037450ecd02796e08ca2e98037845b7c30c2807","modified":1583035845000},{"_id":"themes/next/languages/tr.yml","hash":"145d28f6f051129dc6393affe8f68cd7ba925078","modified":1583035845000},{"_id":"themes/next/languages/zh-CN.yml","hash":"038c3a650d2e3a288be9ba6580564172c50b4289","modified":1583035845000},{"_id":"themes/next/languages/vi.yml","hash":"ffc144f606e171fdd8cdb41808ac36e406015a54","modified":1583035845000},{"_id":"themes/next/languages/uk.yml","hash":"21a573cdf8e26d87d5e32c5555bc645983268abe","modified":1583035845000},{"_id":"themes/next/languages/zh-HK.yml","hash":"2620632caa3c94022d9513ab1971d15512e737e7","modified":1583035845000},{"_id":"themes/next/languages/zh-TW.yml","hash":"0964e90406bbd495e901d6b9d5f10124c8cad950","modified":1583035845000},{"_id":"source/_posts/DS-linklist/delete.png","hash":"a5fe25e468fdcf5dcdcf2f5dfe38bc111c1c6de3","modified":1584775855161},{"_id":"source/_posts/DS-linklist/buildlinklist.png","hash":"2d6ec6bb79c8498e9f32e9b901f4a1447f2d02ae","modified":1584775855161},{"_id":"source/_posts/DS-linklist/insert.png","hash":"fd8ca5f5983bd23ff63243b870d95d101465637e","modified":1584775855161},{"_id":"source/_posts/DS-linklist/headbuild.png","hash":"2d6ec6bb79c8498e9f32e9b901f4a1447f2d02ae","modified":1584775855161},{"_id":"source/_posts/DS-linklist/sigrecyclelink.png","hash":"3ac39284b6b307ca4bdffa0c1ffeefb2105b0ae6","modified":1584775855165},{"_id":"source/_posts/DS-linklist/mergerecycle.png","hash":"5f3e6feb4e0287a2d7fd888d7f53f5b9fe49125b","modified":1584775855165},{"_id":"source/_posts/DS-linklist/linklist.png","hash":"4a828bf8974535b3985d4fea98fc03af0677104f","modified":1584775855165},{"_id":"source/_posts/DS-linklist/tailbuile.png","hash":"b69750dc6ceac67aafe907e74112e21381f484ac","modified":1584775855165},{"_id":"source/_posts/DS-linklist/headnode.png","hash":"70f01646899b7c758a033d6fd19261bd65bb59e1","modified":1584775855161},{"_id":"source/_posts/test-article-picture/example.jpg","hash":"f80a55b114352278e8505206068fa6327b93e38d","modified":1584775855169},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1526914306000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1526914306000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1526914306000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1526914306000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1526914306000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1526914306000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1526914306000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1526914306000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1526914306000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1526914306000},{"_id":"themes/next/.git/logs/HEAD","hash":"c6ea9b0e74455fd32f68796d4ca55fe52297d1e2","modified":1526914436000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1583035845000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1583035845000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"fe3f5cda1975114884d84bef384a562920d70335","modified":1583035845000},{"_id":"themes/next/docs/ru/README.md","hash":"2b3988e79d96b66640d6a98f0c0e6de9099805e6","modified":1583035845000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1583035845000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1583035845000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1583035845000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1583035845000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1583035845000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"e5f6668c3a79e4a364931b9b4e5fa92f8c771ec8","modified":1583035845000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"0b0b9ec6ec4a89e701a3b91f8d7d95752d3e241b","modified":1583035845000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"7f37327bbcae7ed7d04d187fd5e9bc6bbf14926a","modified":1583035845000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1583035845000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"0c4914a5fd08f15beec71940218c814ad9a89f3f","modified":1583035845000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"1ee6335c12773dc43f8b92136770cb10d460c25c","modified":1583035845000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1583035845000},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1583035845000},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"a3462c37ab6d7642b1e95860ea5c4cfbac78efab","modified":1583035845000},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1583035845000},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1583035845000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1583035845000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1583035845000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"815676d904f92748ddf4f529bed2baf066997bc6","modified":1583035845000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1583035845000},{"_id":"themes/next/layout/_macro/post.swig","hash":"ee01368d65fbb8d387f0956398daf62ae9ba1645","modified":1583035845000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1583035845000},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1583035845000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"1574848233f1bb2f45313ca08fef2dd33856a80b","modified":1583035845000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1583035845000},{"_id":"themes/next/scripts/events/index.js","hash":"9047d8ae2670e43429b16a7919a08a0a0a81afe0","modified":1583035845000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1583035845000},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1583035845000},{"_id":"themes/next/scripts/filters/locals.js","hash":"5bbfdc1c373542159660b7a68ed0b57ca18ad10b","modified":1583035845000},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1583035845000},{"_id":"themes/next/scripts/filters/post.js","hash":"f2f566f2577c554377fd704442399acdd14a8118","modified":1583035845000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"cb211b6b50913454b1737782e9e2af96cfa40448","modified":1583035845000},{"_id":"themes/next/scripts/helpers/font.js","hash":"32268fb4c59c5b37c1eb1c9582ab630e09e5cc7d","modified":1583035845000},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1583035845000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"58347687b02f7ab5e64bef07525c8efa97c9e8fb","modified":1583035845000},{"_id":"themes/next/scripts/tags/button.js","hash":"946dd7beede408d1f090d5e9774d74763828b97c","modified":1583035845000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1583035845000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"0f133f27b61e8351cfd0959ba8a1b8551a9a8cc6","modified":1583035845000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1583035845000},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1583035845000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1583035845000},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1583035845000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1583035845000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1583035845000},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1583035845000},{"_id":"themes/next/source/css/_colors.styl","hash":"7d07d83cb5c9a5f23751bb46019e853eb4d0cd0a","modified":1583035845000},{"_id":"themes/next/source/css/_mixins.styl","hash":"b79ff3debd5709397b122292fc7e551ae9d40782","modified":1583035845000},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1583035845000},{"_id":"themes/next/source/js/next-boot.js","hash":"f7045763e277e685c271bd4b4c37e531d699ac63","modified":1583035845000},{"_id":"themes/next/source/js/algolia-search.js","hash":"77cd98b1c790df12dd6cd8119bb3d99f72866635","modified":1583035845000},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1583035845000},{"_id":"themes/next/source/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1583035845000},{"_id":"themes/next/source/js/local-search.js","hash":"3f7606d2007dbf3b1bdf08b37bff4312c1c3d7a1","modified":1583035845000},{"_id":"themes/next/source/js/utils.js","hash":"8a5d36d029c182f6d299a922e37c9e745f3b141a","modified":1583035845000},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1583035845000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1583035845000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1583035845000},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1583035845000},{"_id":"themes/next/source/images/background.jpg","hash":"5111a28dbdaf7299749b2fed69610261570ccde5","modified":1584789332003},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1583035845000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1583035845000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1583035845000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1583035845000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1583035845000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1583035845000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1583035845000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1583035845000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1583035845000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1583035845000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1583035845000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1583035845000},{"_id":"themes/next/source/images/headicon2.jpg","hash":"85afe54a74f04609a894920605f80581234fa239","modified":1527001592000},{"_id":"source/_posts/tcpip-PF-PACKET/pf_packet.jpg","hash":"966238d1fae622b408a900febb6b5f6117280831","modified":1584775855165},{"_id":"themes/next/.git/refs/heads/master","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1526914436000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"1ea12d4b9490d9065ebf1b8739b90ce5defd6398","modified":1583035845000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"5ff544013e2905138ffeb07bf9a57062faed75b2","modified":1583035845000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"d3a16f0f343ea70b59e33e4b9cdecae3c8df91cd","modified":1583035845000},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"f609146c43e11e9285d56d10ceb7ccc4a4d017db","modified":1583035845000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"bbf0c8e42491fac70f4f8165224f1d7d92a040d7","modified":1583035845000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"30528a8da30994b1ef9355a72b09b2cd85a7c0e9","modified":1583035845000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1583035845000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"54ba9508a901c295a02c8e34e9cece7c7dcad518","modified":1583035845000},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"14c33bd544903e74388739599fffe3ecb66ed4b0","modified":1583035845000},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"94d54b0c65d504f772af1e62424952e092b6c21d","modified":1583035845000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"a56e4f6ad95c106f361d354f828d1ef4810b1d76","modified":1583035845000},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1583035845000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1583035845000},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1583035845000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1583035845000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"d6fa9e4432b87004c5678dfe2d4b2c1f4a702b93","modified":1583035845000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"716b78cd90addc4216413719554721cb362b0c18","modified":1583035845000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"2791a8dc20a276704fc8b03f9822f76578a9152d","modified":1583035845000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1583035845000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1583035845000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1583035845000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1583035845000},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"a2bb0bec243685e670b60a3d54142950adc03af0","modified":1583035845000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1583035845000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1583035845000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1583035845000},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1583035845000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1583035845000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1583035845000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1583035845000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1583035845000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1583035845000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1583035845000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1583035845000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1583035845000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1583035845000},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1583035845000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1583035845000},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1583035845000},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1583035845000},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1583035845000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1583035845000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"afeeed84b395797429d5a852b70e12fd79f7410b","modified":1583035845000},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1583035845000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1583035845000},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1583035845000},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1583035845000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1583035845000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"1f20213af8da3127701e6bb9da995e5c91be2051","modified":1583035845000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1583035845000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1583035845000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"19cbd24880d0fbbd4d5698cd54da598f03b942da","modified":1583035845000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1583035845000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1583035845000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1583035845000},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6a72b5928cdab9526a288177991e4b2aedd028cf","modified":1583035845000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"b205d72a56b1827681f0a260c266e0c02065fd08","modified":1583035845000},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1583035845000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1583035845000},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5adab7380491e9df5c9ada4f4feb204b866ec14b","modified":1583035845000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"38597817ede20418e73ae4afc50047ea5088c73e","modified":1583035845000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1583035845000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"9840998e1a1fbcd419c52a1e38fa54a003eac963","modified":1583035845000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"85c46ac85689e7c5f5398fc8b6b40b7a8e94bafb","modified":1583035845000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1583035845000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1583035845000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1583035845000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1583035845000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"f068b46f8c305c7436c2767492a6bed42dcd764c","modified":1583035845000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1583035845000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1583035845000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1583035845000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1583035845000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"c6ea9b0e74455fd32f68796d4ca55fe52297d1e2","modified":1526914436000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1526914436000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"e2355c213fc25d635f1179fe317b826e0b9dad17","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"bc87cea0b534f2d75db60f300b069456f6516d1b","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"170c4598cbbe49cd1527f94158d97d2320a6b906","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"990bd301ce2de0a6b936781c58318f3945d81bc2","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"44fe82eadbdbb2f66adda37ac83ebd0f85876bfc","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"38f632dce42481da83a5ffab382c281269885e9c","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"3fee8cbe5704a04107ff0816db1221edb40dbb9b","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"62209da61b4ac49e3a7ff8174e28e075060835ec","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"b3bea92eef0e1fe2e7e294dac2184d16b5b8d666","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"4794bd45d5e32ea005c805bcbc65b871e9927d02","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"41e5a7c567735e780ef9bfdacd4af1ff4b5e1d2a","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"a30db9fffd34d522d378aeaeaa400d1a84505b38","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"ccb71d732b12acd02ac26ed6bbda4861d027857d","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e4f958677a75de87ee1caf7e22ba46a0602f22dd","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"21003fd0b43dc3b3592e916d585f7f78478cbeb3","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"82025c3ad7af12e532e2e81be98deb0a74ff23ac","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"bb392700f04d956bb5f606efb052453efeade53d","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1583035845000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1583035845000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1583035845000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1583035845000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1583035845000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"c6ea9b0e74455fd32f68796d4ca55fe52297d1e2","modified":1526914436000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"c1daeb60c23945f745703ac2c3f4bf99d0ea3d95","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"705759bdd1649e9aa1caedb82f6432a991ae3e71","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"f5821481440a0624c8aec5fc85f093de1527095f","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"0ec7bafed7eec36504df7781207ccd1ce4448536","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"555762730f1f31451113e8fdc84ec438ea738d90","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"c0944ea35dc2bd3b2da9b64f5d05e7e78b6660f1","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"e3ade812b5541eca5b863ad3ff234ea95925bf31","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"5d5c022aa3b2f89c2f2a178212338bb64804dd75","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"887aa8de61ae060150a6312d5cb00d4da065db77","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"eca4d80dd0df1c3b1bc06bd39e6a4bd6c56198df","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"796eb941ba0ca03fd5ca6d15a1f6a56afd9aa174","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1583035845000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"c7939407797acbd1ae0d8bae8e13b2bf045f870e","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"796415ae7490e17857e64ffef7e470b65c655a6b","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"8136f9efe1f018ebe4b4a2d8bd3683bb393ff456","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"a237c290e8934d1a8cbbf22b3f30503d9663021d","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1583035845000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"1a14c1b92d8a4dd8aabb5949333ac0ac79094c6c","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"5ac97054b302fe3ce47822a03a3b56aa3d582005","modified":1583035845000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1583035845000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1583035845000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1583035845000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1583035845000},{"_id":"themes/next/.git/objects/pack/pack-0df40285cfd6ba61cd77b9db468522fa4a3564d9.idx","hash":"9bd7aefeb87914ecfb289a7b609bfefc37dd28e3","modified":1526914436000},{"_id":"themes/next/.git/objects/pack/pack-0df40285cfd6ba61cd77b9db468522fa4a3564d9.pack","hash":"b7b9af2417976ae7eab57dc0584d64df5654085a","modified":1526914436000}],"Category":[{"name":"数据结构和算法","_id":"ckjqsu7mt00022ujxgw01gnkr"},{"name":"android","_id":"ckjqsu7n9000c2ujxdwunp0wq"},{"name":"代码整洁","_id":"ckjqsu7o100172ujxdve060dy"},{"name":"c&cpp","_id":"ckjqsu7o6001e2ujxzkumnebd"},{"name":"linux","_id":"ckjqsu7p2002s2ujxi5bwelsc"},{"name":"leetcode","_id":"ckjqsu7p4002x2ujxxxkp7qv5"},{"name":"tcpip","_id":"ckjqsu7rc003l2ujxztm5c34i"},{"name":"心理","_id":"ckjqsu7t3004g2ujxra9cdjun"}],"Data":[],"Page":[{"title":"mentality","date":"2020-03-20T23:29:25.000Z","type":"mentality","_content":"\n# will show later\n","source":"mentality/index.md","raw":"---\ntitle: mentality\ndate: 2020-03-21 07:29:25\ntype: mentality\n---\n\n# will show later\n","updated":"2020-03-21T14:29:58.938Z","path":"mentality/index.html","comments":1,"layout":"page","_id":"ckjqsu7r6003i2ujx28rrbh49","content":"<h1 id=\"will-show-later\"><a href=\"#will-show-later\" class=\"headerlink\" title=\"will show later\"></a>will show later</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"will-show-later\"><a href=\"#will-show-later\" class=\"headerlink\" title=\"will show later\"></a>will show later</h1>"},{"title":"read","date":"2020-03-20T23:28:06.000Z","type":"read","_content":"","source":"read/index.md","raw":"---\ntitle: read\ndate: 2020-03-21 07:28:06\ntype: read\n---\n","updated":"2020-03-21T14:29:03.423Z","path":"read/index.html","comments":1,"layout":"page","_id":"ckjqsu7ra003k2ujxtotycq7c","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","date":"2018-05-23T15:42:30.000Z","_content":"\n###  个人简介：  \n西北搞基大学出生，带着浓浓的土味，崇尚自由，又需要养家糊口，崇尚技术，曾跨过\n山海，看过青海，曾踏过长城，上过华山；看惯各种技术，力求能架构稳定高质量的软\n件产品，且正在努力。\n\n\n###  会什么:  \n   熟悉多门语言：c,c++,python,java,balala的拼写，用的多的还是c/c++\n     \n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2018-05-23 23:42:30\n---\n\n###  个人简介：  \n西北搞基大学出生，带着浓浓的土味，崇尚自由，又需要养家糊口，崇尚技术，曾跨过\n山海，看过青海，曾踏过长城，上过华山；看惯各种技术，力求能架构稳定高质量的软\n件产品，且正在努力。\n\n\n###  会什么:  \n   熟悉多门语言：c,c++,python,java,balala的拼写，用的多的还是c/c++\n     \n","updated":"2020-03-21T07:30:55.169Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckjqsu7rd003o2ujxidmjkn4v","content":"<h3 id=\"个人简介：\"><a href=\"#个人简介：\" class=\"headerlink\" title=\"个人简介：\"></a>个人简介：</h3><p>西北搞基大学出生，带着浓浓的土味，崇尚自由，又需要养家糊口，崇尚技术，曾跨过<br>山海，看过青海，曾踏过长城，上过华山；看惯各种技术，力求能架构稳定高质量的软<br>件产品，且正在努力。</p>\n<h3 id=\"会什么\"><a href=\"#会什么\" class=\"headerlink\" title=\"会什么:\"></a>会什么:</h3><p>   熟悉多门语言：c,c++,python,java,balala的拼写，用的多的还是c/c++</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"个人简介：\"><a href=\"#个人简介：\" class=\"headerlink\" title=\"个人简介：\"></a>个人简介：</h3><p>西北搞基大学出生，带着浓浓的土味，崇尚自由，又需要养家糊口，崇尚技术，曾跨过<br>山海，看过青海，曾踏过长城，上过华山；看惯各种技术，力求能架构稳定高质量的软<br>件产品，且正在努力。</p>\n<h3 id=\"会什么\"><a href=\"#会什么\" class=\"headerlink\" title=\"会什么:\"></a>会什么:</h3><p>   熟悉多门语言：c,c++,python,java,balala的拼写，用的多的还是c/c++</p>\n"},{"title":"movies","date":"2020-03-20T23:21:47.000Z","type":"movies","_content":"\n博主观看和推荐的电影：\n\n<script src=\"/js/youtube-autoresizer.js\"></script>\n<iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/HfElOZSEqn4\" frameborder=\"0\" allowfullscreen></iframe>\n\n","source":"movies/index.md","raw":"---\ntitle: movies\ndate: 2020-03-21 07:21:47\ntype: movies\n\n---\n\n博主观看和推荐的电影：\n\n<script src=\"/js/youtube-autoresizer.js\"></script>\n<iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/HfElOZSEqn4\" frameborder=\"0\" allowfullscreen></iframe>\n\n","updated":"2020-04-04T12:34:14.205Z","path":"movies/index.html","comments":1,"layout":"page","_id":"ckjqsu7rh003q2ujxpbrsfzbc","content":"<p>博主观看和推荐的电影：</p>\n<p><script src=\"/js/youtube-autoresizer.js\"></script></p>\n<iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/HfElOZSEqn4\" frameborder=\"0\" allowfullscreen></iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<p>博主观看和推荐的电影：</p>\n<p><script src=\"/js/youtube-autoresizer.js\"></script></p>\n<iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/HfElOZSEqn4\" frameborder=\"0\" allowfullscreen></iframe>\n\n"},{"title":"categories","date":"2018-05-23T16:44:28.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-05-24 00:44:28\ntype: \"categories\"\n---\n","updated":"2020-03-21T07:30:55.169Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckjqsu7rl003u2ujxrsk7fe6h","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-05-23T16:38:08.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-05-24 00:38:08\ntype: \"tags\"\n---\n","updated":"2020-03-21T07:30:55.169Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckjqsu7ro003x2ujx7a3jd62t","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"DS_linklist","date":"2018-05-26T13:18:09.000Z","_content":"## 数据结构之线性表：\n### 有序表：数组：\n### 单链表：\n链表定义  <!-- more -->\n{  \n * 数据成员:常见的基本类型或者对象类型均可  \n * 数据关系:在链表中的块的成员在连续的内存中，块与块之间内存位置不连续  \n * 指向块的指针：单链表只有一个next,双链表加上pre  \n\n}  \n基本运算：  \n{\n+ InitList(&L);:初始化链表，在c/c++中需要做分配内存，初始化链表头和其值的操作；  \n+ DestroyList(&L); 在销毁时需要free内存  \n+ Length(L);链表的长度是块的个数\n+ GetElem(L,i,&e); 在链表中取元素需要一个一个遍历直到下标值，若为双链表会快些。所以这里取索引值对应的值和取链表的值，效率几乎一样；  \n+ LocateElem(L,e,compare()); 和链表中的元素做对比\n+ InsertElem(&L,i,e); 在链表中插入元素，复杂度O(1),在提供位置的时候，若不提供位置，还需要加搜索的时间\n+ DeleteElem(&L,i,&e); 在链表中删除元素，复杂度O(1)\n……  \n\n}  \neg:  \n```c\ntypedef struct LNode { \n       ElemType data；//数据域\n       struct LNode  *next； //指针域\n} LNode,  *LinkList;\nLNode  *L;\nLinkList  L;\nL =  (LinkList) malloc( sizeof (LNode) );\n或 L = new LNode;\nL->data;\nLNode  L;\nL.date\n```\n{% asset_img linklist.png 链表示意图 %}    \n### 链表的两种头部：\n1. 没有头的链表：第一个块就开始存储数据  \n2. 任何时候都有头的链表：  第一个块不存储数据，作为头节点，第二个块开始存数据  \n3. 应用：在leetcode中的ReverseLinklist中，当反转的是从1开始的时候，若使用的是没有头的，则需要额外判断处理，否则可以统一处理；  \n\n{% asset_img headnode.png 头节点示意图 %}  \n\n###  链表的几个常见操作：　\n+ 取第i个元素：  \n```c\nStatus GetElem_L(LinkList L, int i, ElemType &e)\n{//查找操作\n    p = L->next;  \n    j = 1;\n    while( p && j < i){\n          p = p->next; \n          ++j;\n    }\n    if (!p || j>i) return ERROR;\n    e = p->data;\n    return OK;\n}\n```\n+ 插入元素：在第i个位置上插入    \n{% asset_img insert.png 插入示意图 %}    \n```c\nStatus ListInsert_L(LinkList &L, int i, ElemType e)\n{\n  p = L; j = 0;\n     while (p && j < i-1) { p = p->next; ++j }\n     if (!p || j>i-1)  return ERROR;\n  s =  (LinkList) malloc( sizeof (LNode) );\n     s->data = e;  \n  s->next = p->next;  \n  p->next = s;  \n     return OK;\n     }\n ```\n+ 删除元素:删除第i个元素:  \n{% asset_img delete.png 删除示意图 %}  \n```c\n Status ListDelete_L(LinkList &L, int i, ElemType &e)\n{\n p = L; j = 0;\n     while (p->next && j < i-1) { p = p->next; ++j }\n     if (!(p->next) || j>i-1)  return ERROR;\n q = p->next;\n     e = q->data;  \n p->next = p->next->next;  //(p->next = q->next;)\n free(q);  \n  return OK;\n}\n```\n\n### 链表的建立：   \n+ 头插法：  \n{% asset_img headbuild.png 头插法示意图 %}  \n```c\nCreateList_L(LinkList &L, int n)\n{\n     L = (LinkList) malloc( sizeof (LNode) );\n     L->next = NULL;\n     for( i=n; i>0; --i){\n         s = (LinkList) malloc( sizeof (LNode) );\n         scanf( &s->data);\n         s->next = L->next; ①\n         L->next = s; ②\n     }\n}```\n+ 尾插法：  \n{% asset_img tailbuile.png 尾插法示意图 %}  \n```c\nCreateList_L(LinkList &L, int n)\n{\n     tail = L = (LinkList) malloc( sizeof (LNode) );\n     L->next = NULL;\n     for( i=n; i>0; --i){\n         s = (LinkList) malloc( sizeof (LNode) );\n         scanf( &s->data);\n         tail->next = s; ①\n         tail = s; ②\n     }      }\n```\n\n###  链表的常见复杂操作：\n+ 两个有序链表的合并：\n```c\nvoid MergeList_L(LinkList &La, LinkList &Lb, LinkList &Lc)\n{\n    pa = La->next; pb = Lb->next;\n    Lc = pc = La;\n    while( pa && pb ){\n        if(pa->data <= pb->data){\n             pc->next = pa; pc = pa; pa = pa->next;\n       }\n       else{\n             pc->next = pb; pc = pb; pb= pb->next;\n       }\n    }\n    pc->next = pa ? pa : pb;\n    free( Lb );\n} \n```\n\n### 一些特殊的链表：\n+ 单向循环链表：\n+ 图示：  \n{% asset_img sigrecyclelink.png 单向循环链表 %}\n{% asset_img mergerecycle.png 合并 %}\n+ 多重循环链表：\n+ 双向链表：\n```c\ntypedef struct DuLNode{\n     ElemType               data;\n     struct DuLNode    *prior;\n     struct DuLNode    *next;\n}DuLNode,  *DuLinkList;\n```\n双向循环链表：\n\n### 探讨：\n+ 链表作为最基础的数据结构，是对其他数据结构：如栈，树等的支撑，其他这些大部分是在链表的基础上建立的；  \n+ 从较底层的层面：即深入到内存，链表实现了对零散内存的有效使用，内存在为链表分配空间的时候不用大段的连续空间；\n+ 从较高层，即抽象的层面看，链表仅仅是一批数据的拓扑结构之一，就常见的栈，队列，树，图等等，你还可以想出其他可能有用没用的，如，立体的结构，方块，金字塔形(emm这个像堆），还有随意的，感觉想到了矩阵里面的压缩。   \n \n### 应用： \n+ 链表的应用：如\n+ 在文件中，对大文件的存储，采用类似链表的结构，\n+ 大数相加，像两个100位的整数相加，使用链表，每个块为一位，就可以解决这个问题，数组也行\n+ 倒排索引结构，在操作系统中用到，我的github上放着一个本科毕业设计做的简单搜索引擎，几乎全是自己搞的（解析网页那块自己c写了状态机，觉得效果不如beatifulsoup好，后面用它了),不过想想那会还不会很有意识的去想如果让它运行在大量用户下，各种使用条件（如输入条件下，会怎么样，年轻啊~)\n+ 其他，当然是其他数据结构基于链表做的，多了去了\n \n","source":"_posts/DS-linklist.md","raw":"---\ntitle: DS_linklist\ndate: 2018-05-26 21:18:09\ntags: 数据结构\ncategories: 数据结构和算法\n---\n## 数据结构之线性表：\n### 有序表：数组：\n### 单链表：\n链表定义  <!-- more -->\n{  \n * 数据成员:常见的基本类型或者对象类型均可  \n * 数据关系:在链表中的块的成员在连续的内存中，块与块之间内存位置不连续  \n * 指向块的指针：单链表只有一个next,双链表加上pre  \n\n}  \n基本运算：  \n{\n+ InitList(&L);:初始化链表，在c/c++中需要做分配内存，初始化链表头和其值的操作；  \n+ DestroyList(&L); 在销毁时需要free内存  \n+ Length(L);链表的长度是块的个数\n+ GetElem(L,i,&e); 在链表中取元素需要一个一个遍历直到下标值，若为双链表会快些。所以这里取索引值对应的值和取链表的值，效率几乎一样；  \n+ LocateElem(L,e,compare()); 和链表中的元素做对比\n+ InsertElem(&L,i,e); 在链表中插入元素，复杂度O(1),在提供位置的时候，若不提供位置，还需要加搜索的时间\n+ DeleteElem(&L,i,&e); 在链表中删除元素，复杂度O(1)\n……  \n\n}  \neg:  \n```c\ntypedef struct LNode { \n       ElemType data；//数据域\n       struct LNode  *next； //指针域\n} LNode,  *LinkList;\nLNode  *L;\nLinkList  L;\nL =  (LinkList) malloc( sizeof (LNode) );\n或 L = new LNode;\nL->data;\nLNode  L;\nL.date\n```\n{% asset_img linklist.png 链表示意图 %}    \n### 链表的两种头部：\n1. 没有头的链表：第一个块就开始存储数据  \n2. 任何时候都有头的链表：  第一个块不存储数据，作为头节点，第二个块开始存数据  \n3. 应用：在leetcode中的ReverseLinklist中，当反转的是从1开始的时候，若使用的是没有头的，则需要额外判断处理，否则可以统一处理；  \n\n{% asset_img headnode.png 头节点示意图 %}  \n\n###  链表的几个常见操作：　\n+ 取第i个元素：  \n```c\nStatus GetElem_L(LinkList L, int i, ElemType &e)\n{//查找操作\n    p = L->next;  \n    j = 1;\n    while( p && j < i){\n          p = p->next; \n          ++j;\n    }\n    if (!p || j>i) return ERROR;\n    e = p->data;\n    return OK;\n}\n```\n+ 插入元素：在第i个位置上插入    \n{% asset_img insert.png 插入示意图 %}    \n```c\nStatus ListInsert_L(LinkList &L, int i, ElemType e)\n{\n  p = L; j = 0;\n     while (p && j < i-1) { p = p->next; ++j }\n     if (!p || j>i-1)  return ERROR;\n  s =  (LinkList) malloc( sizeof (LNode) );\n     s->data = e;  \n  s->next = p->next;  \n  p->next = s;  \n     return OK;\n     }\n ```\n+ 删除元素:删除第i个元素:  \n{% asset_img delete.png 删除示意图 %}  \n```c\n Status ListDelete_L(LinkList &L, int i, ElemType &e)\n{\n p = L; j = 0;\n     while (p->next && j < i-1) { p = p->next; ++j }\n     if (!(p->next) || j>i-1)  return ERROR;\n q = p->next;\n     e = q->data;  \n p->next = p->next->next;  //(p->next = q->next;)\n free(q);  \n  return OK;\n}\n```\n\n### 链表的建立：   \n+ 头插法：  \n{% asset_img headbuild.png 头插法示意图 %}  \n```c\nCreateList_L(LinkList &L, int n)\n{\n     L = (LinkList) malloc( sizeof (LNode) );\n     L->next = NULL;\n     for( i=n; i>0; --i){\n         s = (LinkList) malloc( sizeof (LNode) );\n         scanf( &s->data);\n         s->next = L->next; ①\n         L->next = s; ②\n     }\n}```\n+ 尾插法：  \n{% asset_img tailbuile.png 尾插法示意图 %}  \n```c\nCreateList_L(LinkList &L, int n)\n{\n     tail = L = (LinkList) malloc( sizeof (LNode) );\n     L->next = NULL;\n     for( i=n; i>0; --i){\n         s = (LinkList) malloc( sizeof (LNode) );\n         scanf( &s->data);\n         tail->next = s; ①\n         tail = s; ②\n     }      }\n```\n\n###  链表的常见复杂操作：\n+ 两个有序链表的合并：\n```c\nvoid MergeList_L(LinkList &La, LinkList &Lb, LinkList &Lc)\n{\n    pa = La->next; pb = Lb->next;\n    Lc = pc = La;\n    while( pa && pb ){\n        if(pa->data <= pb->data){\n             pc->next = pa; pc = pa; pa = pa->next;\n       }\n       else{\n             pc->next = pb; pc = pb; pb= pb->next;\n       }\n    }\n    pc->next = pa ? pa : pb;\n    free( Lb );\n} \n```\n\n### 一些特殊的链表：\n+ 单向循环链表：\n+ 图示：  \n{% asset_img sigrecyclelink.png 单向循环链表 %}\n{% asset_img mergerecycle.png 合并 %}\n+ 多重循环链表：\n+ 双向链表：\n```c\ntypedef struct DuLNode{\n     ElemType               data;\n     struct DuLNode    *prior;\n     struct DuLNode    *next;\n}DuLNode,  *DuLinkList;\n```\n双向循环链表：\n\n### 探讨：\n+ 链表作为最基础的数据结构，是对其他数据结构：如栈，树等的支撑，其他这些大部分是在链表的基础上建立的；  \n+ 从较底层的层面：即深入到内存，链表实现了对零散内存的有效使用，内存在为链表分配空间的时候不用大段的连续空间；\n+ 从较高层，即抽象的层面看，链表仅仅是一批数据的拓扑结构之一，就常见的栈，队列，树，图等等，你还可以想出其他可能有用没用的，如，立体的结构，方块，金字塔形(emm这个像堆），还有随意的，感觉想到了矩阵里面的压缩。   \n \n### 应用： \n+ 链表的应用：如\n+ 在文件中，对大文件的存储，采用类似链表的结构，\n+ 大数相加，像两个100位的整数相加，使用链表，每个块为一位，就可以解决这个问题，数组也行\n+ 倒排索引结构，在操作系统中用到，我的github上放着一个本科毕业设计做的简单搜索引擎，几乎全是自己搞的（解析网页那块自己c写了状态机，觉得效果不如beatifulsoup好，后面用它了),不过想想那会还不会很有意识的去想如果让它运行在大量用户下，各种使用条件（如输入条件下，会怎么样，年轻啊~)\n+ 其他，当然是其他数据结构基于链表做的，多了去了\n \n","slug":"DS-linklist","published":1,"updated":"2020-03-21T07:30:55.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7mk00002ujxp2palg0o","content":"<h2 id=\"数据结构之线性表：\"><a href=\"#数据结构之线性表：\" class=\"headerlink\" title=\"数据结构之线性表：\"></a>数据结构之线性表：</h2><h3 id=\"有序表：数组：\"><a href=\"#有序表：数组：\" class=\"headerlink\" title=\"有序表：数组：\"></a>有序表：数组：</h3><h3 id=\"单链表：\"><a href=\"#单链表：\" class=\"headerlink\" title=\"单链表：\"></a>单链表：</h3><p>链表定义  <a id=\"more\"></a><br>{  </p>\n<ul>\n<li>数据成员:常见的基本类型或者对象类型均可  </li>\n<li>数据关系:在链表中的块的成员在连续的内存中，块与块之间内存位置不连续  </li>\n<li>指向块的指针：单链表只有一个next,双链表加上pre  </li>\n</ul>\n<p>}<br>基本运算：<br>{</p>\n<ul>\n<li>InitList(&amp;L);:初始化链表，在c/c++中需要做分配内存，初始化链表头和其值的操作；  </li>\n<li>DestroyList(&amp;L); 在销毁时需要free内存  </li>\n<li>Length(L);链表的长度是块的个数</li>\n<li>GetElem(L,i,&amp;e); 在链表中取元素需要一个一个遍历直到下标值，若为双链表会快些。所以这里取索引值对应的值和取链表的值，效率几乎一样；  </li>\n<li>LocateElem(L,e,compare()); 和链表中的元素做对比</li>\n<li>InsertElem(&amp;L,i,e); 在链表中插入元素，复杂度O(1),在提供位置的时候，若不提供位置，还需要加搜索的时间</li>\n<li>DeleteElem(&amp;L,i,&amp;e); 在链表中删除元素，复杂度O(1)<br>……  </li>\n</ul>\n<p>}<br>eg:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span> </span><br><span class=\"line\">       ElemType data；<span class=\"comment\">//数据域</span></span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>  *<span class=\"title\">next</span>； //指针域</span></span><br><span class=\"line\"><span class=\"class\">&#125; <span class=\"title\">LNode</span>,  *<span class=\"title\">LinkList</span>;</span></span><br><span class=\"line\">LNode  *L;</span><br><span class=\"line\">LinkList  L;</span><br><span class=\"line\">L =  (LinkList) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span> (LNode) );</span><br><span class=\"line\">或 L = <span class=\"keyword\">new</span> LNode;</span><br><span class=\"line\">L-&gt;data;</span><br><span class=\"line\">LNode  L;</span><br><span class=\"line\">L.date</span><br></pre></td></tr></table></figure></p>\n<img src=\"/2018/05/26/DS-linklist/linklist.png\" title=\"链表示意图\">    \n<h3 id=\"链表的两种头部：\"><a href=\"#链表的两种头部：\" class=\"headerlink\" title=\"链表的两种头部：\"></a>链表的两种头部：</h3><ol>\n<li>没有头的链表：第一个块就开始存储数据  </li>\n<li>任何时候都有头的链表：  第一个块不存储数据，作为头节点，第二个块开始存数据  </li>\n<li>应用：在leetcode中的ReverseLinklist中，当反转的是从1开始的时候，若使用的是没有头的，则需要额外判断处理，否则可以统一处理；  </li>\n</ol>\n<img src=\"/2018/05/26/DS-linklist/headnode.png\" title=\"头节点示意图\">  \n<h3 id=\"链表的几个常见操作：\"><a href=\"#链表的几个常见操作：\" class=\"headerlink\" title=\"链表的几个常见操作：　\"></a>链表的几个常见操作：　</h3><ul>\n<li><p>取第i个元素：  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">GetElem_L</span><span class=\"params\">(LinkList L, <span class=\"keyword\">int</span> i, ElemType &amp;e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;<span class=\"comment\">//查找操作</span></span><br><span class=\"line\">    p = L-&gt;next;  </span><br><span class=\"line\">    j = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( p &amp;&amp; j &lt; i)&#123;</span><br><span class=\"line\">          p = p-&gt;next; </span><br><span class=\"line\">          ++j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!p || j&gt;i) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    e = p-&gt;data;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>插入元素：在第i个位置上插入    </p>\n<img src=\"/2018/05/26/DS-linklist/insert.png\" title=\"插入示意图\">    \n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListInsert_L</span><span class=\"params\">(LinkList &amp;L, <span class=\"keyword\">int</span> i, ElemType e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  p = L; j = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">while</span> (p &amp;&amp; j &lt; i<span class=\"number\">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!p || j&gt;i<span class=\"number\">-1</span>)  <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">  s =  (LinkList) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span> (LNode) );</span><br><span class=\"line\">     s-&gt;data = e;  </span><br><span class=\"line\">  s-&gt;next = p-&gt;next;  </span><br><span class=\"line\">  p-&gt;next = s;  </span><br><span class=\"line\">     <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除元素:删除第i个元素:  </p>\n<img src=\"/2018/05/26/DS-linklist/delete.png\" title=\"删除示意图\">  \n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\">Status <span class=\"title\">ListDelete_L</span><span class=\"params\">(LinkList &amp;L, <span class=\"keyword\">int</span> i, ElemType &amp;e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> p = L; j = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">while</span> (p-&gt;next &amp;&amp; j &lt; i<span class=\"number\">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!(p-&gt;next) || j&gt;i<span class=\"number\">-1</span>)  <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\"> q = p-&gt;next;</span><br><span class=\"line\">     e = q-&gt;data;  </span><br><span class=\"line\"> p-&gt;next = p-&gt;next-&gt;next;  <span class=\"comment\">//(p-&gt;next = q-&gt;next;)</span></span><br><span class=\"line\"> <span class=\"built_in\">free</span>(q);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"链表的建立：\"><a href=\"#链表的建立：\" class=\"headerlink\" title=\"链表的建立：\"></a>链表的建立：</h3><ul>\n<li><p>头插法：  </p>\n<img src=\"/2018/05/26/DS-linklist/headbuild.png\" title=\"头插法示意图\">  \n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CreateList_L(LinkList &amp;L, <span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     L = (LinkList) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span> (LNode) );</span><br><span class=\"line\">     L-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">     <span class=\"keyword\">for</span>( i=n; i&gt;<span class=\"number\">0</span>; --i)&#123;</span><br><span class=\"line\">         s = (LinkList) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span> (LNode) );</span><br><span class=\"line\">         <span class=\"built_in\">scanf</span>( &amp;s-&gt;data);</span><br><span class=\"line\">         s-&gt;next = L-&gt;next; ①</span><br><span class=\"line\">         L-&gt;next = s; ②</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>尾插法：  </p>\n<img src=\"/2018/05/26/DS-linklist/tailbuile.png\" title=\"尾插法示意图\">  \n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CreateList_L(LinkList &amp;L, <span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     tail = L = (LinkList) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span> (LNode) );</span><br><span class=\"line\">     L-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">     <span class=\"keyword\">for</span>( i=n; i&gt;<span class=\"number\">0</span>; --i)&#123;</span><br><span class=\"line\">         s = (LinkList) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span> (LNode) );</span><br><span class=\"line\">         <span class=\"built_in\">scanf</span>( &amp;s-&gt;data);</span><br><span class=\"line\">         tail-&gt;next = s; ①</span><br><span class=\"line\">         tail = s; ②</span><br><span class=\"line\">     &#125;      &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"链表的常见复杂操作：\"><a href=\"#链表的常见复杂操作：\" class=\"headerlink\" title=\"链表的常见复杂操作：\"></a>链表的常见复杂操作：</h3><ul>\n<li>两个有序链表的合并：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeList_L</span><span class=\"params\">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pa = La-&gt;next; pb = Lb-&gt;next;</span><br><span class=\"line\">    Lc = pc = La;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( pa &amp;&amp; pb )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class=\"line\">             pc-&gt;next = pa; pc = pa; pa = pa-&gt;next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">             pc-&gt;next = pb; pc = pb; pb= pb-&gt;next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pc-&gt;next = pa ? pa : pb;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>( Lb );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"一些特殊的链表：\"><a href=\"#一些特殊的链表：\" class=\"headerlink\" title=\"一些特殊的链表：\"></a>一些特殊的链表：</h3><ul>\n<li>单向循环链表：</li>\n<li>图示：  <img src=\"/2018/05/26/DS-linklist/sigrecyclelink.png\" title=\"单向循环链表\">\n<img src=\"/2018/05/26/DS-linklist/mergerecycle.png\" title=\"合并\"></li>\n<li>多重循环链表：</li>\n<li>双向链表：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DuLNode</span>&#123;</span></span><br><span class=\"line\">     ElemType               data;</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DuLNode</span>    *<span class=\"title\">prior</span>;</span></span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DuLNode</span>    *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;DuLNode,  *DuLinkList;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>双向循环链表：</p>\n<h3 id=\"探讨：\"><a href=\"#探讨：\" class=\"headerlink\" title=\"探讨：\"></a>探讨：</h3><ul>\n<li>链表作为最基础的数据结构，是对其他数据结构：如栈，树等的支撑，其他这些大部分是在链表的基础上建立的；  </li>\n<li>从较底层的层面：即深入到内存，链表实现了对零散内存的有效使用，内存在为链表分配空间的时候不用大段的连续空间；</li>\n<li>从较高层，即抽象的层面看，链表仅仅是一批数据的拓扑结构之一，就常见的栈，队列，树，图等等，你还可以想出其他可能有用没用的，如，立体的结构，方块，金字塔形(emm这个像堆），还有随意的，感觉想到了矩阵里面的压缩。   </li>\n</ul>\n<h3 id=\"应用：\"><a href=\"#应用：\" class=\"headerlink\" title=\"应用：\"></a>应用：</h3><ul>\n<li>链表的应用：如</li>\n<li>在文件中，对大文件的存储，采用类似链表的结构，</li>\n<li>大数相加，像两个100位的整数相加，使用链表，每个块为一位，就可以解决这个问题，数组也行</li>\n<li>倒排索引结构，在操作系统中用到，我的github上放着一个本科毕业设计做的简单搜索引擎，几乎全是自己搞的（解析网页那块自己c写了状态机，觉得效果不如beatifulsoup好，后面用它了),不过想想那会还不会很有意识的去想如果让它运行在大量用户下，各种使用条件（如输入条件下，会怎么样，年轻啊~)</li>\n<li>其他，当然是其他数据结构基于链表做的，多了去了</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"数据结构之线性表：\"><a href=\"#数据结构之线性表：\" class=\"headerlink\" title=\"数据结构之线性表：\"></a>数据结构之线性表：</h2><h3 id=\"有序表：数组：\"><a href=\"#有序表：数组：\" class=\"headerlink\" title=\"有序表：数组：\"></a>有序表：数组：</h3><h3 id=\"单链表：\"><a href=\"#单链表：\" class=\"headerlink\" title=\"单链表：\"></a>单链表：</h3><p>链表定义","more":"<br>{  </p>\n<ul>\n<li>数据成员:常见的基本类型或者对象类型均可  </li>\n<li>数据关系:在链表中的块的成员在连续的内存中，块与块之间内存位置不连续  </li>\n<li>指向块的指针：单链表只有一个next,双链表加上pre  </li>\n</ul>\n<p>}<br>基本运算：<br>{</p>\n<ul>\n<li>InitList(&amp;L);:初始化链表，在c/c++中需要做分配内存，初始化链表头和其值的操作；  </li>\n<li>DestroyList(&amp;L); 在销毁时需要free内存  </li>\n<li>Length(L);链表的长度是块的个数</li>\n<li>GetElem(L,i,&amp;e); 在链表中取元素需要一个一个遍历直到下标值，若为双链表会快些。所以这里取索引值对应的值和取链表的值，效率几乎一样；  </li>\n<li>LocateElem(L,e,compare()); 和链表中的元素做对比</li>\n<li>InsertElem(&amp;L,i,e); 在链表中插入元素，复杂度O(1),在提供位置的时候，若不提供位置，还需要加搜索的时间</li>\n<li>DeleteElem(&amp;L,i,&amp;e); 在链表中删除元素，复杂度O(1)<br>……  </li>\n</ul>\n<p>}<br>eg:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span> </span><br><span class=\"line\">       ElemType data；<span class=\"comment\">//数据域</span></span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span>  *<span class=\"title\">next</span>； //指针域</span></span><br><span class=\"line\"><span class=\"class\">&#125; <span class=\"title\">LNode</span>,  *<span class=\"title\">LinkList</span>;</span></span><br><span class=\"line\">LNode  *L;</span><br><span class=\"line\">LinkList  L;</span><br><span class=\"line\">L =  (LinkList) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span> (LNode) );</span><br><span class=\"line\">或 L = <span class=\"keyword\">new</span> LNode;</span><br><span class=\"line\">L-&gt;data;</span><br><span class=\"line\">LNode  L;</span><br><span class=\"line\">L.date</span><br></pre></td></tr></table></figure></p>\n<img src=\"/2018/05/26/DS-linklist/linklist.png\" title=\"链表示意图\">    \n<h3 id=\"链表的两种头部：\"><a href=\"#链表的两种头部：\" class=\"headerlink\" title=\"链表的两种头部：\"></a>链表的两种头部：</h3><ol>\n<li>没有头的链表：第一个块就开始存储数据  </li>\n<li>任何时候都有头的链表：  第一个块不存储数据，作为头节点，第二个块开始存数据  </li>\n<li>应用：在leetcode中的ReverseLinklist中，当反转的是从1开始的时候，若使用的是没有头的，则需要额外判断处理，否则可以统一处理；  </li>\n</ol>\n<img src=\"/2018/05/26/DS-linklist/headnode.png\" title=\"头节点示意图\">  \n<h3 id=\"链表的几个常见操作：\"><a href=\"#链表的几个常见操作：\" class=\"headerlink\" title=\"链表的几个常见操作：　\"></a>链表的几个常见操作：　</h3><ul>\n<li><p>取第i个元素：  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">GetElem_L</span><span class=\"params\">(LinkList L, <span class=\"keyword\">int</span> i, ElemType &amp;e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;<span class=\"comment\">//查找操作</span></span><br><span class=\"line\">    p = L-&gt;next;  </span><br><span class=\"line\">    j = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( p &amp;&amp; j &lt; i)&#123;</span><br><span class=\"line\">          p = p-&gt;next; </span><br><span class=\"line\">          ++j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!p || j&gt;i) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    e = p-&gt;data;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>插入元素：在第i个位置上插入    </p>\n<img src=\"/2018/05/26/DS-linklist/insert.png\" title=\"插入示意图\">    \n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListInsert_L</span><span class=\"params\">(LinkList &amp;L, <span class=\"keyword\">int</span> i, ElemType e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  p = L; j = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">while</span> (p &amp;&amp; j &lt; i<span class=\"number\">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!p || j&gt;i<span class=\"number\">-1</span>)  <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">  s =  (LinkList) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span> (LNode) );</span><br><span class=\"line\">     s-&gt;data = e;  </span><br><span class=\"line\">  s-&gt;next = p-&gt;next;  </span><br><span class=\"line\">  p-&gt;next = s;  </span><br><span class=\"line\">     <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除元素:删除第i个元素:  </p>\n<img src=\"/2018/05/26/DS-linklist/delete.png\" title=\"删除示意图\">  \n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\">Status <span class=\"title\">ListDelete_L</span><span class=\"params\">(LinkList &amp;L, <span class=\"keyword\">int</span> i, ElemType &amp;e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> p = L; j = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">while</span> (p-&gt;next &amp;&amp; j &lt; i<span class=\"number\">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!(p-&gt;next) || j&gt;i<span class=\"number\">-1</span>)  <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\"> q = p-&gt;next;</span><br><span class=\"line\">     e = q-&gt;data;  </span><br><span class=\"line\"> p-&gt;next = p-&gt;next-&gt;next;  <span class=\"comment\">//(p-&gt;next = q-&gt;next;)</span></span><br><span class=\"line\"> <span class=\"built_in\">free</span>(q);  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"链表的建立：\"><a href=\"#链表的建立：\" class=\"headerlink\" title=\"链表的建立：\"></a>链表的建立：</h3><ul>\n<li><p>头插法：  </p>\n<img src=\"/2018/05/26/DS-linklist/headbuild.png\" title=\"头插法示意图\">  \n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CreateList_L(LinkList &amp;L, <span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     L = (LinkList) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span> (LNode) );</span><br><span class=\"line\">     L-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">     <span class=\"keyword\">for</span>( i=n; i&gt;<span class=\"number\">0</span>; --i)&#123;</span><br><span class=\"line\">         s = (LinkList) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span> (LNode) );</span><br><span class=\"line\">         <span class=\"built_in\">scanf</span>( &amp;s-&gt;data);</span><br><span class=\"line\">         s-&gt;next = L-&gt;next; ①</span><br><span class=\"line\">         L-&gt;next = s; ②</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>尾插法：  </p>\n<img src=\"/2018/05/26/DS-linklist/tailbuile.png\" title=\"尾插法示意图\">  \n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CreateList_L(LinkList &amp;L, <span class=\"keyword\">int</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     tail = L = (LinkList) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span> (LNode) );</span><br><span class=\"line\">     L-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">     <span class=\"keyword\">for</span>( i=n; i&gt;<span class=\"number\">0</span>; --i)&#123;</span><br><span class=\"line\">         s = (LinkList) <span class=\"built_in\">malloc</span>( <span class=\"keyword\">sizeof</span> (LNode) );</span><br><span class=\"line\">         <span class=\"built_in\">scanf</span>( &amp;s-&gt;data);</span><br><span class=\"line\">         tail-&gt;next = s; ①</span><br><span class=\"line\">         tail = s; ②</span><br><span class=\"line\">     &#125;      &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"链表的常见复杂操作：\"><a href=\"#链表的常见复杂操作：\" class=\"headerlink\" title=\"链表的常见复杂操作：\"></a>链表的常见复杂操作：</h3><ul>\n<li>两个有序链表的合并：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeList_L</span><span class=\"params\">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pa = La-&gt;next; pb = Lb-&gt;next;</span><br><span class=\"line\">    Lc = pc = La;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( pa &amp;&amp; pb )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class=\"line\">             pc-&gt;next = pa; pc = pa; pa = pa-&gt;next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">             pc-&gt;next = pb; pc = pb; pb= pb-&gt;next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pc-&gt;next = pa ? pa : pb;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>( Lb );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"一些特殊的链表：\"><a href=\"#一些特殊的链表：\" class=\"headerlink\" title=\"一些特殊的链表：\"></a>一些特殊的链表：</h3><ul>\n<li>单向循环链表：</li>\n<li>图示：  <img src=\"/2018/05/26/DS-linklist/sigrecyclelink.png\" title=\"单向循环链表\">\n<img src=\"/2018/05/26/DS-linklist/mergerecycle.png\" title=\"合并\"></li>\n<li>多重循环链表：</li>\n<li>双向链表：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DuLNode</span>&#123;</span></span><br><span class=\"line\">     ElemType               data;</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DuLNode</span>    *<span class=\"title\">prior</span>;</span></span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DuLNode</span>    *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;DuLNode,  *DuLinkList;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>双向循环链表：</p>\n<h3 id=\"探讨：\"><a href=\"#探讨：\" class=\"headerlink\" title=\"探讨：\"></a>探讨：</h3><ul>\n<li>链表作为最基础的数据结构，是对其他数据结构：如栈，树等的支撑，其他这些大部分是在链表的基础上建立的；  </li>\n<li>从较底层的层面：即深入到内存，链表实现了对零散内存的有效使用，内存在为链表分配空间的时候不用大段的连续空间；</li>\n<li>从较高层，即抽象的层面看，链表仅仅是一批数据的拓扑结构之一，就常见的栈，队列，树，图等等，你还可以想出其他可能有用没用的，如，立体的结构，方块，金字塔形(emm这个像堆），还有随意的，感觉想到了矩阵里面的压缩。   </li>\n</ul>\n<h3 id=\"应用：\"><a href=\"#应用：\" class=\"headerlink\" title=\"应用：\"></a>应用：</h3><ul>\n<li>链表的应用：如</li>\n<li>在文件中，对大文件的存储，采用类似链表的结构，</li>\n<li>大数相加，像两个100位的整数相加，使用链表，每个块为一位，就可以解决这个问题，数组也行</li>\n<li>倒排索引结构，在操作系统中用到，我的github上放着一个本科毕业设计做的简单搜索引擎，几乎全是自己搞的（解析网页那块自己c写了状态机，觉得效果不如beatifulsoup好，后面用它了),不过想想那会还不会很有意识的去想如果让它运行在大量用户下，各种使用条件（如输入条件下，会怎么样，年轻啊~)</li>\n<li>其他，当然是其他数据结构基于链表做的，多了去了</li>\n</ul>"},{"title":"DS_string","date":"2018-06-24T08:01:32.000Z","_content":"### 数据结构之串\n欢迎来到简单而又复杂的串世界,博主许久没有去研究串，还停留在以前学习和使用串的水平，再来一波学习和归纳，发现串的基本用法其实简单，也好理解，但是衍生出来的和应用相关，而且复杂，下面道来；<!--more-->\n#### 串的基本\n##### 串的定义\n+ \"a1a2.....an\",其中包含字母，广义上可以是任意字符\n+ 在c/c++中结尾带'\\0'，python则不带，长度均不包含'\\0'\n+ 串长度-不同编码不同，根据具体需要如字节，实际字符等\n+ 空串和空白串，空白又可能是tab,回车，空格等等“\n+ 串的子串:子串个数：n(n+1)/2--等差数列，\n##### 串常用的数据结构\n+ 串常量--存在从汇编去看－数据段(data)\n```c\n    .file\t\"test.c\"\n\t.section\t.rodata\n.LC0:\n\t.string\t\"kesance\"\n.LC1:\n\t.string\t\"%d\\n\"\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\n```\n+ 串数组:\n将字符串存在顺序数组中\n+ 堆分配存在链表中\n##### 字符串常用函数\n+ 子串个数：\n+ 串赋值\n+ 串比较\n+ 求串长\n+ 串拼接\n+ 求子串\n+ 替换子串\n+ 定位子串的位置\n#### 字符编码和字符串匹配\n##### 字符串的编码\n+ 所谓字符编码，就是将字符用二进制唯一表示。在计算机的世界里不是1就是0，无论什么字符最后存入的还是二进制数，只是从内存中读出来时解析不同而已，即如让计算机将读出来的00111000解析成数字8,如文本显示程序，当设定为某种编码时，将字节流解析成对应的字符～现在看到的许多字体库也是这样的，将一串二进制串和某个字体对应起来，解析程序负责处理匹配和显示等\n+ https://en.wikipedia.org/wiki/Unicode　unicode编码了解一下\n\n##### 传统模式匹配算法\n模式匹配，就是在字符串里面匹配另一个串相似或者相同的子串，传统的想法也和一般人想到的一样，扫描并一个一个字符对比，若第二串失配，则第二串重新匹配第一串的第二个，接着往下。。\n\n##### KMP算法\nkmp作为完全匹配算法中的高效算法，基本原理如下：ps:大学学这个算法只学了它是什么原理，还没去想为什么这么做等）\n+ **基本思想**：从上面看传统的匹配算法：  \n  ```\n   a b c a e f g \n   a b d a e f```\n   像上面的字符串匹配，第一次失配的地方是在c,则按照传统的方式，则应该重新：\n   ```\n   a b c a e f g\n     a b d a e f ```\n  但是其实如果是我们人去做匹配时，则会直接从：  \n  ```\n     a b c a e f g\n           a b d a e f ```\n  开始匹配，而kmp的基本思想也是这样；\n 例子：\n ```\n a b c d a b c f g e \n a b c e a b c t\n 第一次失配在d,那下一次应该在  \n a b c d a b c f g e \n         a b c e a b c t```\n    \n+ 所以它分为两部分，１是模式串在移动时候遵循的基本原理，２是当失配时，模式串的哪个位置的字符和源串的当前位置进行重新匹配；\n+  1基本原理，重复：当模式串中存在大量的重复时，效果尤为明显\n```\na b c d a b c e f g \na b c d a b c t ```\n上述例子一样，可以看到 以d 为中点，前后有相同的串，abc,则显然next函数也能隐士检测到这个，所以当显然因为模式串的前后abc相等，而后abc又和源串的后abc相等，所以源串的后abc和模式串的前abc想等，自然失配时候就可以从模式串的d开始匹配起\n+ **2重点在next的计算，它决定当发生失配时，模式串如何移动**：  \n  + 假设模式串为P,j是当前模式串正在匹配的位置，源串为S,i是源串的当前位置，k是当P[j]!=S[i]时，P应该和S[i]比较的位置，以next[j]=k表示，故关键是求出next数组，显然k<j\n  + next如何计算得到:其实要利用前面的基本原理，  \n   P[0-k-1]==P[j-k~j-1]==S[i-k到i-1] (即next[j]=k)  \n   所以要求next[j+1]=?  \n   -若P[k]==P[j]  \n   P[0-k-1]+P[k]==P[j-k~j-1]+P[j]  \n   即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1  \n   -若P[k]!=P[j]\n  我们已经知道（0，k-1）串和（j-k,j-1）串是相等的，所以可以把（0，k-1）串当做一个新的模式串，发现在新模式串中\n（0，next[k]-1）串与（k-next[k],k-1）串相等，所以（j-k,j-1）中存在与（0，next[k]-1）相等的串，所以可以把j移动到next[k],继续比较和移动。\n\n+ 具体程序：\n```c\n//显然，next[0]=-1,此时无法向左边移动了源串模式串都要移动\nnext[1]=0,此时只能向左移动到0.\nint getnext(char *P,int next[]){\n    j=1,next[j]=0,k=0;\n    while(j<sizeof(P){\n      if(k==0||P[j++]==P[k++])\n            next[j]==k;//next[j]=next[j]+1\n      else\n           k=next[k];\n           }\n           }```\n           \n##### 串和哈夫曼编码\n+ 霍夫曼编码是和编码相关的一个算法，是将一个串编码为二进制整数，如类似AABXBDHADFBFJD编码为1010011100011101001,而霍夫曼编码则作为转换算法，Huffman编码使得每一个字符的编码都与另一个字符编码的前一部分不同，不会出现像’A’：00，  ’B’：001，这样的情况，解码也不会出现冲突。\n\n#### 论文查重对比的几个算法(文本相似度）\n+ 杰卡德（Jaccard）相似系数\n这种相似度计算方式相对简单，原理也易于理解，就是计算单词集合之间的交集和并集大小的比例，该值越大，表示两个文本越相似。在涉及到大规模并行计算时，该方法效率上有一定的优势。\n+ 余弦（Cosine）相似度\n  余弦相似度是利用计算两个向量之间的夹角，夹角越小相似度越高，其公式为：\n假定A和B是两个n维向量，A是[A1,A2,...,An],B是[B1,B2,B3,...,Bn],则A与B的夹角余弦等于\n+ 等等,用时再看：\n https://www.cnblogs.com/huilixieqi/p/6493089.html\n+ linux下的diff命令\n还有win上的beyondcompare软件，这两个是用于比较文本的差异的，在代码移植时经常用到\n\n#### 串匹配－正则表达式\n+ 正则表达式用于匹配文本字符串，但是并不一定是完全匹配，且是匹配的串出现有随意性\n\n##### 正则表达式的理论基础\n+ 最早接触到正则表达式，是在大三学习编译原理的时候，解析词法语法的时候会用到正则表达式，用来过滤关键词，像c语言的很多关键词，以及判断它是不是合法的表达式，等等，常用的是lex和yacc,最原始的是自己的实现对词法和语法的解析，而不借助的lex；\n+ 正则表达，语法树，常用有限状态机来来实现，功能强大的如图灵机；\n\n##### 正则表达式和编译原理\n##### 正则表达式的基本实现\n+ 用c实现正则表达实现词法分析：\n+ \n##### 常用的正则表达式\n+ 语言支持\n+ 脚本语言支持情况\n+ sed,awk\n\n#### 串和流\n+ 流，所有的文本流\n+ 流分为二进制流和文本流","source":"_posts/DS-string.md","raw":"---\ntitle: DS_string\ndate: 2018-06-24 16:01:32\ntags: 数据结构\ncategories: 数据结构和算法\n---\n### 数据结构之串\n欢迎来到简单而又复杂的串世界,博主许久没有去研究串，还停留在以前学习和使用串的水平，再来一波学习和归纳，发现串的基本用法其实简单，也好理解，但是衍生出来的和应用相关，而且复杂，下面道来；<!--more-->\n#### 串的基本\n##### 串的定义\n+ \"a1a2.....an\",其中包含字母，广义上可以是任意字符\n+ 在c/c++中结尾带'\\0'，python则不带，长度均不包含'\\0'\n+ 串长度-不同编码不同，根据具体需要如字节，实际字符等\n+ 空串和空白串，空白又可能是tab,回车，空格等等“\n+ 串的子串:子串个数：n(n+1)/2--等差数列，\n##### 串常用的数据结构\n+ 串常量--存在从汇编去看－数据段(data)\n```c\n    .file\t\"test.c\"\n\t.section\t.rodata\n.LC0:\n\t.string\t\"kesance\"\n.LC1:\n\t.string\t\"%d\\n\"\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\n```\n+ 串数组:\n将字符串存在顺序数组中\n+ 堆分配存在链表中\n##### 字符串常用函数\n+ 子串个数：\n+ 串赋值\n+ 串比较\n+ 求串长\n+ 串拼接\n+ 求子串\n+ 替换子串\n+ 定位子串的位置\n#### 字符编码和字符串匹配\n##### 字符串的编码\n+ 所谓字符编码，就是将字符用二进制唯一表示。在计算机的世界里不是1就是0，无论什么字符最后存入的还是二进制数，只是从内存中读出来时解析不同而已，即如让计算机将读出来的00111000解析成数字8,如文本显示程序，当设定为某种编码时，将字节流解析成对应的字符～现在看到的许多字体库也是这样的，将一串二进制串和某个字体对应起来，解析程序负责处理匹配和显示等\n+ https://en.wikipedia.org/wiki/Unicode　unicode编码了解一下\n\n##### 传统模式匹配算法\n模式匹配，就是在字符串里面匹配另一个串相似或者相同的子串，传统的想法也和一般人想到的一样，扫描并一个一个字符对比，若第二串失配，则第二串重新匹配第一串的第二个，接着往下。。\n\n##### KMP算法\nkmp作为完全匹配算法中的高效算法，基本原理如下：ps:大学学这个算法只学了它是什么原理，还没去想为什么这么做等）\n+ **基本思想**：从上面看传统的匹配算法：  \n  ```\n   a b c a e f g \n   a b d a e f```\n   像上面的字符串匹配，第一次失配的地方是在c,则按照传统的方式，则应该重新：\n   ```\n   a b c a e f g\n     a b d a e f ```\n  但是其实如果是我们人去做匹配时，则会直接从：  \n  ```\n     a b c a e f g\n           a b d a e f ```\n  开始匹配，而kmp的基本思想也是这样；\n 例子：\n ```\n a b c d a b c f g e \n a b c e a b c t\n 第一次失配在d,那下一次应该在  \n a b c d a b c f g e \n         a b c e a b c t```\n    \n+ 所以它分为两部分，１是模式串在移动时候遵循的基本原理，２是当失配时，模式串的哪个位置的字符和源串的当前位置进行重新匹配；\n+  1基本原理，重复：当模式串中存在大量的重复时，效果尤为明显\n```\na b c d a b c e f g \na b c d a b c t ```\n上述例子一样，可以看到 以d 为中点，前后有相同的串，abc,则显然next函数也能隐士检测到这个，所以当显然因为模式串的前后abc相等，而后abc又和源串的后abc相等，所以源串的后abc和模式串的前abc想等，自然失配时候就可以从模式串的d开始匹配起\n+ **2重点在next的计算，它决定当发生失配时，模式串如何移动**：  \n  + 假设模式串为P,j是当前模式串正在匹配的位置，源串为S,i是源串的当前位置，k是当P[j]!=S[i]时，P应该和S[i]比较的位置，以next[j]=k表示，故关键是求出next数组，显然k<j\n  + next如何计算得到:其实要利用前面的基本原理，  \n   P[0-k-1]==P[j-k~j-1]==S[i-k到i-1] (即next[j]=k)  \n   所以要求next[j+1]=?  \n   -若P[k]==P[j]  \n   P[0-k-1]+P[k]==P[j-k~j-1]+P[j]  \n   即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1  \n   -若P[k]!=P[j]\n  我们已经知道（0，k-1）串和（j-k,j-1）串是相等的，所以可以把（0，k-1）串当做一个新的模式串，发现在新模式串中\n（0，next[k]-1）串与（k-next[k],k-1）串相等，所以（j-k,j-1）中存在与（0，next[k]-1）相等的串，所以可以把j移动到next[k],继续比较和移动。\n\n+ 具体程序：\n```c\n//显然，next[0]=-1,此时无法向左边移动了源串模式串都要移动\nnext[1]=0,此时只能向左移动到0.\nint getnext(char *P,int next[]){\n    j=1,next[j]=0,k=0;\n    while(j<sizeof(P){\n      if(k==0||P[j++]==P[k++])\n            next[j]==k;//next[j]=next[j]+1\n      else\n           k=next[k];\n           }\n           }```\n           \n##### 串和哈夫曼编码\n+ 霍夫曼编码是和编码相关的一个算法，是将一个串编码为二进制整数，如类似AABXBDHADFBFJD编码为1010011100011101001,而霍夫曼编码则作为转换算法，Huffman编码使得每一个字符的编码都与另一个字符编码的前一部分不同，不会出现像’A’：00，  ’B’：001，这样的情况，解码也不会出现冲突。\n\n#### 论文查重对比的几个算法(文本相似度）\n+ 杰卡德（Jaccard）相似系数\n这种相似度计算方式相对简单，原理也易于理解，就是计算单词集合之间的交集和并集大小的比例，该值越大，表示两个文本越相似。在涉及到大规模并行计算时，该方法效率上有一定的优势。\n+ 余弦（Cosine）相似度\n  余弦相似度是利用计算两个向量之间的夹角，夹角越小相似度越高，其公式为：\n假定A和B是两个n维向量，A是[A1,A2,...,An],B是[B1,B2,B3,...,Bn],则A与B的夹角余弦等于\n+ 等等,用时再看：\n https://www.cnblogs.com/huilixieqi/p/6493089.html\n+ linux下的diff命令\n还有win上的beyondcompare软件，这两个是用于比较文本的差异的，在代码移植时经常用到\n\n#### 串匹配－正则表达式\n+ 正则表达式用于匹配文本字符串，但是并不一定是完全匹配，且是匹配的串出现有随意性\n\n##### 正则表达式的理论基础\n+ 最早接触到正则表达式，是在大三学习编译原理的时候，解析词法语法的时候会用到正则表达式，用来过滤关键词，像c语言的很多关键词，以及判断它是不是合法的表达式，等等，常用的是lex和yacc,最原始的是自己的实现对词法和语法的解析，而不借助的lex；\n+ 正则表达，语法树，常用有限状态机来来实现，功能强大的如图灵机；\n\n##### 正则表达式和编译原理\n##### 正则表达式的基本实现\n+ 用c实现正则表达实现词法分析：\n+ \n##### 常用的正则表达式\n+ 语言支持\n+ 脚本语言支持情况\n+ sed,awk\n\n#### 串和流\n+ 流，所有的文本流\n+ 流分为二进制流和文本流","slug":"DS-string","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7mq00012ujxe5b46m9o","content":"<h3 id=\"数据结构之串\"><a href=\"#数据结构之串\" class=\"headerlink\" title=\"数据结构之串\"></a>数据结构之串</h3><p>欢迎来到简单而又复杂的串世界,博主许久没有去研究串，还停留在以前学习和使用串的水平，再来一波学习和归纳，发现串的基本用法其实简单，也好理解，但是衍生出来的和应用相关，而且复杂，下面道来；<a id=\"more\"></a></p>\n<h4 id=\"串的基本\"><a href=\"#串的基本\" class=\"headerlink\" title=\"串的基本\"></a>串的基本</h4><h5 id=\"串的定义\"><a href=\"#串的定义\" class=\"headerlink\" title=\"串的定义\"></a>串的定义</h5><ul>\n<li>“a1a2…..an”,其中包含字母，广义上可以是任意字符</li>\n<li>在c/c++中结尾带’\\0’，python则不带，长度均不包含’\\0’</li>\n<li>串长度-不同编码不同，根据具体需要如字节，实际字符等</li>\n<li>空串和空白串，空白又可能是tab,回车，空格等等“</li>\n<li>串的子串:子串个数：n(n+1)/2–等差数列，<h5 id=\"串常用的数据结构\"><a href=\"#串常用的数据结构\" class=\"headerlink\" title=\"串常用的数据结构\"></a>串常用的数据结构</h5></li>\n<li><p>串常量–存在从汇编去看－数据段(data)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .file\t<span class=\"string\">\"test.c\"</span></span><br><span class=\"line\">\t.section\t.rodata</span><br><span class=\"line\">.LC0:</span><br><span class=\"line\">\t.<span class=\"built_in\">string</span>\t<span class=\"string\">\"kesance\"</span></span><br><span class=\"line\">.LC1:</span><br><span class=\"line\">\t.<span class=\"built_in\">string</span>\t<span class=\"string\">\"%d\\n\"</span></span><br><span class=\"line\">\t.text</span><br><span class=\"line\">\t.globl\tmain</span><br><span class=\"line\">\t.type\tmain, @function</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>串数组:<br>将字符串存在顺序数组中</p>\n</li>\n<li>堆分配存在链表中<h5 id=\"字符串常用函数\"><a href=\"#字符串常用函数\" class=\"headerlink\" title=\"字符串常用函数\"></a>字符串常用函数</h5></li>\n<li>子串个数：</li>\n<li>串赋值</li>\n<li>串比较</li>\n<li>求串长</li>\n<li>串拼接</li>\n<li>求子串</li>\n<li>替换子串</li>\n<li>定位子串的位置<h4 id=\"字符编码和字符串匹配\"><a href=\"#字符编码和字符串匹配\" class=\"headerlink\" title=\"字符编码和字符串匹配\"></a>字符编码和字符串匹配</h4><h5 id=\"字符串的编码\"><a href=\"#字符串的编码\" class=\"headerlink\" title=\"字符串的编码\"></a>字符串的编码</h5></li>\n<li>所谓字符编码，就是将字符用二进制唯一表示。在计算机的世界里不是1就是0，无论什么字符最后存入的还是二进制数，只是从内存中读出来时解析不同而已，即如让计算机将读出来的00111000解析成数字8,如文本显示程序，当设定为某种编码时，将字节流解析成对应的字符～现在看到的许多字体库也是这样的，将一串二进制串和某个字体对应起来，解析程序负责处理匹配和显示等</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Unicode\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Unicode</a>　unicode编码了解一下</li>\n</ul>\n<h5 id=\"传统模式匹配算法\"><a href=\"#传统模式匹配算法\" class=\"headerlink\" title=\"传统模式匹配算法\"></a>传统模式匹配算法</h5><p>模式匹配，就是在字符串里面匹配另一个串相似或者相同的子串，传统的想法也和一般人想到的一样，扫描并一个一个字符对比，若第二串失配，则第二串重新匹配第一串的第二个，接着往下。。</p>\n<h5 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h5><p>kmp作为完全匹配算法中的高效算法，基本原理如下：ps:大学学这个算法只学了它是什么原理，还没去想为什么这么做等）</p>\n<ul>\n<li><p><strong>基本思想</strong>：从上面看传统的匹配算法：  </p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c <span class=\"selector-tag\">a</span> e f g </span><br><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> d <span class=\"selector-tag\">a</span> e f</span><br></pre></td></tr></table></figure>\n<p> 像上面的字符串匹配，第一次失配的地方是在c,则按照传统的方式，则应该重新：</p>\n <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c <span class=\"selector-tag\">a</span> e f g</span><br><span class=\"line\">  <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> d <span class=\"selector-tag\">a</span> e f</span><br></pre></td></tr></table></figure>\n<p>但是其实如果是我们人去做匹配时，则会直接从：  </p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c <span class=\"selector-tag\">a</span> e f g</span><br><span class=\"line\">      <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> d <span class=\"selector-tag\">a</span> e f</span><br></pre></td></tr></table></figure>\n<p>开始匹配，而kmp的基本思想也是这样；<br>例子：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c d <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c f g e </span><br><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c e <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c t</span><br><span class=\"line\">第一次失配在d,那下一次应该在  </span><br><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c d <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c f g e </span><br><span class=\"line\">        <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c e <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c t</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>所以它分为两部分，１是模式串在移动时候遵循的基本原理，２是当失配时，模式串的哪个位置的字符和源串的当前位置进行重新匹配；</li>\n<li>1基本原理，重复：当模式串中存在大量的重复时，效果尤为明显<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c d <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c e f g </span><br><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c d <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c t</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上述例子一样，可以看到 以d 为中点，前后有相同的串，abc,则显然next函数也能隐士检测到这个，所以当显然因为模式串的前后abc相等，而后abc又和源串的后abc相等，所以源串的后abc和模式串的前abc想等，自然失配时候就可以从模式串的d开始匹配起</p>\n<ul>\n<li><p><strong>2重点在next的计算，它决定当发生失配时，模式串如何移动</strong>：  </p>\n<ul>\n<li>假设模式串为P,j是当前模式串正在匹配的位置，源串为S,i是源串的当前位置，k是当P[j]!=S[i]时，P应该和S[i]比较的位置，以next[j]=k表示，故关键是求出next数组，显然k&lt;j</li>\n<li>next如何计算得到:其实要利用前面的基本原理，<br>P[0-k-1]==P[j-k~j-1]==S[i-k到i-1] (即next[j]=k)<br>所以要求next[j+1]=?<br>-若P[k]==P[j]<br>P[0-k-1]+P[k]==P[j-k~j-1]+P[j]<br>即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1<br>-若P[k]!=P[j]<br>我们已经知道（0，k-1）串和（j-k,j-1）串是相等的，所以可以把（0，k-1）串当做一个新的模式串，发现在新模式串中<br>（0，next[k]-1）串与（k-next[k],k-1）串相等，所以（j-k,j-1）中存在与（0，next[k]-1）相等的串，所以可以把j移动到next[k],继续比较和移动。</li>\n</ul>\n</li>\n<li><p>具体程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//显然，next[0]=-1,此时无法向左边移动了源串模式串都要移动</span></span><br><span class=\"line\">next[<span class=\"number\">1</span>]=<span class=\"number\">0</span>,此时只能向左移动到<span class=\"number\">0.</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> getnext(<span class=\"keyword\">char</span> *P,<span class=\"keyword\">int</span> next[])&#123;</span><br><span class=\"line\">    j=<span class=\"number\">1</span>,next[j]=<span class=\"number\">0</span>,k=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j&lt;<span class=\"keyword\">sizeof</span>(P)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(k==<span class=\"number\">0</span>||P[j++]==P[k++])</span><br><span class=\"line\">            next[j]==k;<span class=\"comment\">//next[j]=next[j]+1</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">           k=next[k];</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"串和哈夫曼编码\"><a href=\"#串和哈夫曼编码\" class=\"headerlink\" title=\"串和哈夫曼编码\"></a>串和哈夫曼编码</h5><ul>\n<li>霍夫曼编码是和编码相关的一个算法，是将一个串编码为二进制整数，如类似AABXBDHADFBFJD编码为1010011100011101001,而霍夫曼编码则作为转换算法，Huffman编码使得每一个字符的编码都与另一个字符编码的前一部分不同，不会出现像’A’：00，  ’B’：001，这样的情况，解码也不会出现冲突。</li>\n</ul>\n<h4 id=\"论文查重对比的几个算法-文本相似度）\"><a href=\"#论文查重对比的几个算法-文本相似度）\" class=\"headerlink\" title=\"论文查重对比的几个算法(文本相似度）\"></a>论文查重对比的几个算法(文本相似度）</h4><ul>\n<li>杰卡德（Jaccard）相似系数<br>这种相似度计算方式相对简单，原理也易于理解，就是计算单词集合之间的交集和并集大小的比例，该值越大，表示两个文本越相似。在涉及到大规模并行计算时，该方法效率上有一定的优势。</li>\n<li>余弦（Cosine）相似度<br>余弦相似度是利用计算两个向量之间的夹角，夹角越小相似度越高，其公式为：<br>假定A和B是两个n维向量，A是[A1,A2,…,An],B是[B1,B2,B3,…,Bn],则A与B的夹角余弦等于</li>\n<li>等等,用时再看：<br><a href=\"https://www.cnblogs.com/huilixieqi/p/6493089.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/huilixieqi/p/6493089.html</a></li>\n<li>linux下的diff命令<br>还有win上的beyondcompare软件，这两个是用于比较文本的差异的，在代码移植时经常用到</li>\n</ul>\n<h4 id=\"串匹配－正则表达式\"><a href=\"#串匹配－正则表达式\" class=\"headerlink\" title=\"串匹配－正则表达式\"></a>串匹配－正则表达式</h4><ul>\n<li>正则表达式用于匹配文本字符串，但是并不一定是完全匹配，且是匹配的串出现有随意性</li>\n</ul>\n<h5 id=\"正则表达式的理论基础\"><a href=\"#正则表达式的理论基础\" class=\"headerlink\" title=\"正则表达式的理论基础\"></a>正则表达式的理论基础</h5><ul>\n<li>最早接触到正则表达式，是在大三学习编译原理的时候，解析词法语法的时候会用到正则表达式，用来过滤关键词，像c语言的很多关键词，以及判断它是不是合法的表达式，等等，常用的是lex和yacc,最原始的是自己的实现对词法和语法的解析，而不借助的lex；</li>\n<li>正则表达，语法树，常用有限状态机来来实现，功能强大的如图灵机；</li>\n</ul>\n<h5 id=\"正则表达式和编译原理\"><a href=\"#正则表达式和编译原理\" class=\"headerlink\" title=\"正则表达式和编译原理\"></a>正则表达式和编译原理</h5><h5 id=\"正则表达式的基本实现\"><a href=\"#正则表达式的基本实现\" class=\"headerlink\" title=\"正则表达式的基本实现\"></a>正则表达式的基本实现</h5><ul>\n<li>用c实现正则表达实现词法分析：</li>\n<li><h5 id=\"常用的正则表达式\"><a href=\"#常用的正则表达式\" class=\"headerlink\" title=\"常用的正则表达式\"></a>常用的正则表达式</h5></li>\n<li>语言支持</li>\n<li>脚本语言支持情况</li>\n<li>sed,awk</li>\n</ul>\n<h4 id=\"串和流\"><a href=\"#串和流\" class=\"headerlink\" title=\"串和流\"></a>串和流</h4><ul>\n<li>流，所有的文本流</li>\n<li>流分为二进制流和文本流</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"数据结构之串\"><a href=\"#数据结构之串\" class=\"headerlink\" title=\"数据结构之串\"></a>数据结构之串</h3><p>欢迎来到简单而又复杂的串世界,博主许久没有去研究串，还停留在以前学习和使用串的水平，再来一波学习和归纳，发现串的基本用法其实简单，也好理解，但是衍生出来的和应用相关，而且复杂，下面道来；","more":"</p>\n<h4 id=\"串的基本\"><a href=\"#串的基本\" class=\"headerlink\" title=\"串的基本\"></a>串的基本</h4><h5 id=\"串的定义\"><a href=\"#串的定义\" class=\"headerlink\" title=\"串的定义\"></a>串的定义</h5><ul>\n<li>“a1a2…..an”,其中包含字母，广义上可以是任意字符</li>\n<li>在c/c++中结尾带’\\0’，python则不带，长度均不包含’\\0’</li>\n<li>串长度-不同编码不同，根据具体需要如字节，实际字符等</li>\n<li>空串和空白串，空白又可能是tab,回车，空格等等“</li>\n<li>串的子串:子串个数：n(n+1)/2–等差数列，<h5 id=\"串常用的数据结构\"><a href=\"#串常用的数据结构\" class=\"headerlink\" title=\"串常用的数据结构\"></a>串常用的数据结构</h5></li>\n<li><p>串常量–存在从汇编去看－数据段(data)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .file\t<span class=\"string\">\"test.c\"</span></span><br><span class=\"line\">\t.section\t.rodata</span><br><span class=\"line\">.LC0:</span><br><span class=\"line\">\t.<span class=\"built_in\">string</span>\t<span class=\"string\">\"kesance\"</span></span><br><span class=\"line\">.LC1:</span><br><span class=\"line\">\t.<span class=\"built_in\">string</span>\t<span class=\"string\">\"%d\\n\"</span></span><br><span class=\"line\">\t.text</span><br><span class=\"line\">\t.globl\tmain</span><br><span class=\"line\">\t.type\tmain, @function</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>串数组:<br>将字符串存在顺序数组中</p>\n</li>\n<li>堆分配存在链表中<h5 id=\"字符串常用函数\"><a href=\"#字符串常用函数\" class=\"headerlink\" title=\"字符串常用函数\"></a>字符串常用函数</h5></li>\n<li>子串个数：</li>\n<li>串赋值</li>\n<li>串比较</li>\n<li>求串长</li>\n<li>串拼接</li>\n<li>求子串</li>\n<li>替换子串</li>\n<li>定位子串的位置<h4 id=\"字符编码和字符串匹配\"><a href=\"#字符编码和字符串匹配\" class=\"headerlink\" title=\"字符编码和字符串匹配\"></a>字符编码和字符串匹配</h4><h5 id=\"字符串的编码\"><a href=\"#字符串的编码\" class=\"headerlink\" title=\"字符串的编码\"></a>字符串的编码</h5></li>\n<li>所谓字符编码，就是将字符用二进制唯一表示。在计算机的世界里不是1就是0，无论什么字符最后存入的还是二进制数，只是从内存中读出来时解析不同而已，即如让计算机将读出来的00111000解析成数字8,如文本显示程序，当设定为某种编码时，将字节流解析成对应的字符～现在看到的许多字体库也是这样的，将一串二进制串和某个字体对应起来，解析程序负责处理匹配和显示等</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Unicode\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Unicode</a>　unicode编码了解一下</li>\n</ul>\n<h5 id=\"传统模式匹配算法\"><a href=\"#传统模式匹配算法\" class=\"headerlink\" title=\"传统模式匹配算法\"></a>传统模式匹配算法</h5><p>模式匹配，就是在字符串里面匹配另一个串相似或者相同的子串，传统的想法也和一般人想到的一样，扫描并一个一个字符对比，若第二串失配，则第二串重新匹配第一串的第二个，接着往下。。</p>\n<h5 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h5><p>kmp作为完全匹配算法中的高效算法，基本原理如下：ps:大学学这个算法只学了它是什么原理，还没去想为什么这么做等）</p>\n<ul>\n<li><p><strong>基本思想</strong>：从上面看传统的匹配算法：  </p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c <span class=\"selector-tag\">a</span> e f g </span><br><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> d <span class=\"selector-tag\">a</span> e f</span><br></pre></td></tr></table></figure>\n<p> 像上面的字符串匹配，第一次失配的地方是在c,则按照传统的方式，则应该重新：</p>\n <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c <span class=\"selector-tag\">a</span> e f g</span><br><span class=\"line\">  <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> d <span class=\"selector-tag\">a</span> e f</span><br></pre></td></tr></table></figure>\n<p>但是其实如果是我们人去做匹配时，则会直接从：  </p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c <span class=\"selector-tag\">a</span> e f g</span><br><span class=\"line\">      <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> d <span class=\"selector-tag\">a</span> e f</span><br></pre></td></tr></table></figure>\n<p>开始匹配，而kmp的基本思想也是这样；<br>例子：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c d <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c f g e </span><br><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c e <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c t</span><br><span class=\"line\">第一次失配在d,那下一次应该在  </span><br><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c d <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c f g e </span><br><span class=\"line\">        <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c e <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c t</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>所以它分为两部分，１是模式串在移动时候遵循的基本原理，２是当失配时，模式串的哪个位置的字符和源串的当前位置进行重新匹配；</li>\n<li>1基本原理，重复：当模式串中存在大量的重复时，效果尤为明显<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c d <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c e f g </span><br><span class=\"line\"><span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c d <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c t</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上述例子一样，可以看到 以d 为中点，前后有相同的串，abc,则显然next函数也能隐士检测到这个，所以当显然因为模式串的前后abc相等，而后abc又和源串的后abc相等，所以源串的后abc和模式串的前abc想等，自然失配时候就可以从模式串的d开始匹配起</p>\n<ul>\n<li><p><strong>2重点在next的计算，它决定当发生失配时，模式串如何移动</strong>：  </p>\n<ul>\n<li>假设模式串为P,j是当前模式串正在匹配的位置，源串为S,i是源串的当前位置，k是当P[j]!=S[i]时，P应该和S[i]比较的位置，以next[j]=k表示，故关键是求出next数组，显然k&lt;j</li>\n<li>next如何计算得到:其实要利用前面的基本原理，<br>P[0-k-1]==P[j-k~j-1]==S[i-k到i-1] (即next[j]=k)<br>所以要求next[j+1]=?<br>-若P[k]==P[j]<br>P[0-k-1]+P[k]==P[j-k~j-1]+P[j]<br>即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1<br>-若P[k]!=P[j]<br>我们已经知道（0，k-1）串和（j-k,j-1）串是相等的，所以可以把（0，k-1）串当做一个新的模式串，发现在新模式串中<br>（0，next[k]-1）串与（k-next[k],k-1）串相等，所以（j-k,j-1）中存在与（0，next[k]-1）相等的串，所以可以把j移动到next[k],继续比较和移动。</li>\n</ul>\n</li>\n<li><p>具体程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//显然，next[0]=-1,此时无法向左边移动了源串模式串都要移动</span></span><br><span class=\"line\">next[<span class=\"number\">1</span>]=<span class=\"number\">0</span>,此时只能向左移动到<span class=\"number\">0.</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> getnext(<span class=\"keyword\">char</span> *P,<span class=\"keyword\">int</span> next[])&#123;</span><br><span class=\"line\">    j=<span class=\"number\">1</span>,next[j]=<span class=\"number\">0</span>,k=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j&lt;<span class=\"keyword\">sizeof</span>(P)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(k==<span class=\"number\">0</span>||P[j++]==P[k++])</span><br><span class=\"line\">            next[j]==k;<span class=\"comment\">//next[j]=next[j]+1</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">           k=next[k];</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"串和哈夫曼编码\"><a href=\"#串和哈夫曼编码\" class=\"headerlink\" title=\"串和哈夫曼编码\"></a>串和哈夫曼编码</h5><ul>\n<li>霍夫曼编码是和编码相关的一个算法，是将一个串编码为二进制整数，如类似AABXBDHADFBFJD编码为1010011100011101001,而霍夫曼编码则作为转换算法，Huffman编码使得每一个字符的编码都与另一个字符编码的前一部分不同，不会出现像’A’：00，  ’B’：001，这样的情况，解码也不会出现冲突。</li>\n</ul>\n<h4 id=\"论文查重对比的几个算法-文本相似度）\"><a href=\"#论文查重对比的几个算法-文本相似度）\" class=\"headerlink\" title=\"论文查重对比的几个算法(文本相似度）\"></a>论文查重对比的几个算法(文本相似度）</h4><ul>\n<li>杰卡德（Jaccard）相似系数<br>这种相似度计算方式相对简单，原理也易于理解，就是计算单词集合之间的交集和并集大小的比例，该值越大，表示两个文本越相似。在涉及到大规模并行计算时，该方法效率上有一定的优势。</li>\n<li>余弦（Cosine）相似度<br>余弦相似度是利用计算两个向量之间的夹角，夹角越小相似度越高，其公式为：<br>假定A和B是两个n维向量，A是[A1,A2,…,An],B是[B1,B2,B3,…,Bn],则A与B的夹角余弦等于</li>\n<li>等等,用时再看：<br><a href=\"https://www.cnblogs.com/huilixieqi/p/6493089.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/huilixieqi/p/6493089.html</a></li>\n<li>linux下的diff命令<br>还有win上的beyondcompare软件，这两个是用于比较文本的差异的，在代码移植时经常用到</li>\n</ul>\n<h4 id=\"串匹配－正则表达式\"><a href=\"#串匹配－正则表达式\" class=\"headerlink\" title=\"串匹配－正则表达式\"></a>串匹配－正则表达式</h4><ul>\n<li>正则表达式用于匹配文本字符串，但是并不一定是完全匹配，且是匹配的串出现有随意性</li>\n</ul>\n<h5 id=\"正则表达式的理论基础\"><a href=\"#正则表达式的理论基础\" class=\"headerlink\" title=\"正则表达式的理论基础\"></a>正则表达式的理论基础</h5><ul>\n<li>最早接触到正则表达式，是在大三学习编译原理的时候，解析词法语法的时候会用到正则表达式，用来过滤关键词，像c语言的很多关键词，以及判断它是不是合法的表达式，等等，常用的是lex和yacc,最原始的是自己的实现对词法和语法的解析，而不借助的lex；</li>\n<li>正则表达，语法树，常用有限状态机来来实现，功能强大的如图灵机；</li>\n</ul>\n<h5 id=\"正则表达式和编译原理\"><a href=\"#正则表达式和编译原理\" class=\"headerlink\" title=\"正则表达式和编译原理\"></a>正则表达式和编译原理</h5><h5 id=\"正则表达式的基本实现\"><a href=\"#正则表达式的基本实现\" class=\"headerlink\" title=\"正则表达式的基本实现\"></a>正则表达式的基本实现</h5><ul>\n<li>用c实现正则表达实现词法分析：</li>\n<li><h5 id=\"常用的正则表达式\"><a href=\"#常用的正则表达式\" class=\"headerlink\" title=\"常用的正则表达式\"></a>常用的正则表达式</h5></li>\n<li>语言支持</li>\n<li>脚本语言支持情况</li>\n<li>sed,awk</li>\n</ul>\n<h4 id=\"串和流\"><a href=\"#串和流\" class=\"headerlink\" title=\"串和流\"></a>串和流</h4><ul>\n<li>流，所有的文本流</li>\n<li>流分为二进制流和文本流</li>\n</ul>"},{"title":"android_AndroidManifest","date":"2018-05-20T09:46:34.000Z","_content":"#### 一个典型的androidmanifest文件：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    package=\"com.example.ksx.helloworld\">\n\t<!-- more -->\n\t    <application\n\t        android:allowBackup=\"true\"\n\t        android:icon=\"@mipmap/ic_launcher\"\n\t\t\tandroid:label=\"hallo\"//app的名字和显示在bar上的文字\n\t        android:roundIcon=\"@mipmap/ic_launcher_round\"\n\t        android:supportsRtl=\"true\"\n\t        android:theme=\"@style/AppTheme\">\n\t        <activity android:name=\".MainActivity\">//活动的注册\n\t\t\t<android:label=\"this is hallo\">//会覆盖上面的\n\t            <intent-filter>\n\t                <action android:name=\"android.intent.action.MAIN\" />//声明为主活动\n\t\n\t                <category android:name=\"android.intent.category.LAUNCHER\" />\n\t            </intent-filter>\n\t        </activity>\n\t    </application>\n\t\n\t</manifest>","source":"_posts/android-AndroidManifest.md","raw":"---\ntitle: android_AndroidManifest\ndate: 2018-05-20 17:46:34\ntags: android_coding\ncategories: android\n---\n#### 一个典型的androidmanifest文件：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    package=\"com.example.ksx.helloworld\">\n\t<!-- more -->\n\t    <application\n\t        android:allowBackup=\"true\"\n\t        android:icon=\"@mipmap/ic_launcher\"\n\t\t\tandroid:label=\"hallo\"//app的名字和显示在bar上的文字\n\t        android:roundIcon=\"@mipmap/ic_launcher_round\"\n\t        android:supportsRtl=\"true\"\n\t        android:theme=\"@style/AppTheme\">\n\t        <activity android:name=\".MainActivity\">//活动的注册\n\t\t\t<android:label=\"this is hallo\">//会覆盖上面的\n\t            <intent-filter>\n\t                <action android:name=\"android.intent.action.MAIN\" />//声明为主活动\n\t\n\t                <category android:name=\"android.intent.category.LAUNCHER\" />\n\t            </intent-filter>\n\t        </activity>\n\t    </application>\n\t\n\t</manifest>","slug":"android-AndroidManifest","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7mv00042ujx67o5221o","content":"<h4 id=\"一个典型的androidmanifest文件：\"><a href=\"#一个典型的androidmanifest文件：\" class=\"headerlink\" title=\"一个典型的androidmanifest文件：\"></a>一个典型的androidmanifest文件：</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    package=&quot;com.example.ksx.helloworld&quot;&gt;\n&lt;!-- more --&gt;\n    &lt;application\n        android:allowBackup=&quot;true&quot;\n        android:icon=&quot;@mipmap/ic_launcher&quot;\n        android:label=&quot;hallo&quot;//app的名字和显示在bar上的文字\n        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;\n        android:supportsRtl=&quot;true&quot;\n        android:theme=&quot;@style/AppTheme&quot;&gt;\n        &lt;activity android:name=&quot;.MainActivity&quot;&gt;//活动的注册\n        &lt;android:label=&quot;this is hallo&quot;&gt;//会覆盖上面的\n            &lt;intent-filter&gt;\n                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;//声明为主活动\n\n                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n\n&lt;/manifest&gt;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一个典型的androidmanifest文件：\"><a href=\"#一个典型的androidmanifest文件：\" class=\"headerlink\" title=\"一个典型的androidmanifest文件：\"></a>一个典型的androidmanifest文件：</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    package=&quot;com.example.ksx.helloworld&quot;&gt;\n&lt;!-- more --&gt;\n    &lt;application\n        android:allowBackup=&quot;true&quot;\n        android:icon=&quot;@mipmap/ic_launcher&quot;\n        android:label=&quot;hallo&quot;//app的名字和显示在bar上的文字\n        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;\n        android:supportsRtl=&quot;true&quot;\n        android:theme=&quot;@style/AppTheme&quot;&gt;\n        &lt;activity android:name=&quot;.MainActivity&quot;&gt;//活动的注册\n        &lt;android:label=&quot;this is hallo&quot;&gt;//会覆盖上面的\n            &lt;intent-filter&gt;\n                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;//声明为主活动\n\n                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n\n&lt;/manifest&gt;\n</code></pre>"},{"title":"android_adb","date":"2018-05-20T09:50:14.000Z","_content":"#### android adb command\n从android群英传中学习到额外的几个adb指令，是之前没接触到的：\nadb list targets\nadb install -r　xx.apk -r为覆盖\nadb shell df\n<!-- more -->\nadb shell pm list packages -f\nadb shell input keyevent 3　　－－模拟按键输入，这里为点击home建\nadb shell touchscreen ..模拟滑动\nadb shell dumpsys 监听Activity运行状态\nadb shell screenrecord /sdcard/demo.mp4  录制　屏幕\nadb shell am start -n 包名/包名＋类名\n\n更多，见google　develop中android studio的部分\n另在源码目录中/system/core/toolbox  和/frameworks/base/cmds为所有ADB命令和shell命令来源\n","source":"_posts/android-adb.md","raw":"---\ntitle: android_adb\ndate: 2018-05-20 17:50:14\ntags: android_make\ncategories: android\n---\n#### android adb command\n从android群英传中学习到额外的几个adb指令，是之前没接触到的：\nadb list targets\nadb install -r　xx.apk -r为覆盖\nadb shell df\n<!-- more -->\nadb shell pm list packages -f\nadb shell input keyevent 3　　－－模拟按键输入，这里为点击home建\nadb shell touchscreen ..模拟滑动\nadb shell dumpsys 监听Activity运行状态\nadb shell screenrecord /sdcard/demo.mp4  录制　屏幕\nadb shell am start -n 包名/包名＋类名\n\n更多，见google　develop中android studio的部分\n另在源码目录中/system/core/toolbox  和/frameworks/base/cmds为所有ADB命令和shell命令来源\n","slug":"android-adb","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7mz00052ujxstil4pvd","content":"<h4 id=\"android-adb-command\"><a href=\"#android-adb-command\" class=\"headerlink\" title=\"android adb command\"></a>android adb command</h4><p>从android群英传中学习到额外的几个adb指令，是之前没接触到的：<br>adb list targets<br>adb install -r　xx.apk -r为覆盖<br>adb shell df<br><a id=\"more\"></a><br>adb shell pm list packages -f<br>adb shell input keyevent 3　　－－模拟按键输入，这里为点击home建<br>adb shell touchscreen ..模拟滑动<br>adb shell dumpsys 监听Activity运行状态<br>adb shell screenrecord /sdcard/demo.mp4  录制　屏幕<br>adb shell am start -n 包名/包名＋类名</p>\n<p>更多，见google　develop中android studio的部分<br>另在源码目录中/system/core/toolbox  和/frameworks/base/cmds为所有ADB命令和shell命令来源</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"android-adb-command\"><a href=\"#android-adb-command\" class=\"headerlink\" title=\"android adb command\"></a>android adb command</h4><p>从android群英传中学习到额外的几个adb指令，是之前没接触到的：<br>adb list targets<br>adb install -r　xx.apk -r为覆盖<br>adb shell df<br>","more":"<br>adb shell pm list packages -f<br>adb shell input keyevent 3　　－－模拟按键输入，这里为点击home建<br>adb shell touchscreen ..模拟滑动<br>adb shell dumpsys 监听Activity运行状态<br>adb shell screenrecord /sdcard/demo.mp4  录制　屏幕<br>adb shell am start -n 包名/包名＋类名</p>\n<p>更多，见google　develop中android studio的部分<br>另在源码目录中/system/core/toolbox  和/frameworks/base/cmds为所有ADB命令和shell命令来源</p>"},{"title":"android_howto_makeapk_cmd","date":"2018-05-20T09:08:46.000Z","_content":"### how to make a android by cmd :\n     在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni\n<!-- more -->\n\n### way 1:方法１\n#### prepare\n     android studio 创建了一个工程，然后手动在命令行打包，进入工程里的.  或者direct use andrid create project创建\n\ncd ~/Desktop/FirstTest/app/src/main\nmkdir gen\nmkdir build\nmkdir out\n\n在android工程目录下建立Makefile文件，添加如下代码：\n\tSDK=~/Android/Sdk　　　　\n\tBUILD_TOOLS=$(SDK)/build-tools/25.0.3\n\tPLATFORMS=$(SDK)/platforms/android-25\n\taapt=$(BUILD_TOOLS)/aapt \n\tdx=$(BUILD_TOOLS)/dx\n\taidl=$(BUILD_TOOLS)/aidl\n\tapkbuilder=$(SDK)/tools/apkbuilder2 //后面不支持apkbuilder所以\n\tadb=$(SDK)/platform-tools/adb\n\n\n#### 资源编译，生成 R.java\n\n\taapt_task:\n\t    $(aapt) package \\\n\t    -f \\ #如果编译出来的文件已经存在，强制覆盖\n\t    -M  AndroidManifest.xml  \\ # Mainifest.xml 的路径\n\t    -I  $(PLATFORMS)/android.jar \\ # 某个版本平台的 android.jar 的路径　#依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...\n\t    -S  res/ \\ # res 文件夹路径\n\t    -J gen/ \\ # 生成 R.java 的输出目录\n\t    -m  #使得生成的包的目录放在 -J 参数指定的目录\n\n#### 代码编译，生成 .class\n\n\tjavac_task:\n\t    javac -source 1.7 -target 1.7 \\ # 使用 jdk1.8 编译 1.7 的 .class 文件\n\t    -encoding UTF-8 \\ \n\t    -bootclasspath  $(PLATFORMS)/android.jar \\ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...\n\t    -d build/ \\ #指定放置生成的类文件的位置\n\t    java/thereisnospon/dextest/*.java \\\n\t    gen/thereisnospon/dextest/*.java \\\n    \n    \n#### 生成 .dex\n\n\tdx_task:\n\t\t$(dx) --dex --output=build/classes.dex \\\n\t\tbuild  \n\t\n#### 资源文件初始包\n\n\tresapk_task:\n\t\t$(aapt) package -f \\\n\t    -M  AndroidManifest.xml  \\\n\t    -I  $(PLATFORMS)/android.jar \\\n\t    -S  res/ \\\n\t    -F  out/resources\n\n\n#### 将.dex 文件加入到资源文件初始包中\n　　\n注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行\n\n\tapk_task:\t\n\t\tjava -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \\\n\t\t  com.android.sdklib.build.ApkBuilderMain \\\n\t\t  Demo.apk -v -u -z src/main/out/resources\\\n\t\t  -f src/main/build/classes.dex -rf src\n\t\n#### 签名，使用debug的签名\n\n\tsigner:\n\t\tjarsigner -verbose \\\n\t    -keystore ~/.android/debug.keystore \\\n\t    -storepass android \\\n\t    -keypass android \\\n\t    Demo.apk  androiddebugkey\n\t\n#### 一次性打包\n\n\tpkg: \n\t\tmake apk_task\n\t\tmake signer \n\t\n\n#### 卸载apk\n\tuninstall:\n\t\t$(adb) uninstall  thereisnospon.dextest\n\t\n\n#### 安装apk\n\n\tinstall: \n\t\t$(adb) install out/app.apk\n\n#### 运行\n\nrun:\n\tmake pkg \n\tmake uninstall\n\tmake install\n\t\n\n\t\t$(adb) shell am start -n thereisnospon.dextest/        thereisnospon.dextest.MainActivity  \n\n### 方法２，用gradle,\n\n首先用AS 建立工程，之后在工程文件下，之星执行，gradle clean\ngradle build\n即生成apk文件\n   \n\n  ","source":"_posts/android-howto-makeapk-cmd.md","raw":"---\ntitle: android_howto_makeapk_cmd\ndate: 2018-05-20 17:08:46\ntags: android_make\ncategories: android\n---\n### how to make a android by cmd :\n     在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni\n<!-- more -->\n\n### way 1:方法１\n#### prepare\n     android studio 创建了一个工程，然后手动在命令行打包，进入工程里的.  或者direct use andrid create project创建\n\ncd ~/Desktop/FirstTest/app/src/main\nmkdir gen\nmkdir build\nmkdir out\n\n在android工程目录下建立Makefile文件，添加如下代码：\n\tSDK=~/Android/Sdk　　　　\n\tBUILD_TOOLS=$(SDK)/build-tools/25.0.3\n\tPLATFORMS=$(SDK)/platforms/android-25\n\taapt=$(BUILD_TOOLS)/aapt \n\tdx=$(BUILD_TOOLS)/dx\n\taidl=$(BUILD_TOOLS)/aidl\n\tapkbuilder=$(SDK)/tools/apkbuilder2 //后面不支持apkbuilder所以\n\tadb=$(SDK)/platform-tools/adb\n\n\n#### 资源编译，生成 R.java\n\n\taapt_task:\n\t    $(aapt) package \\\n\t    -f \\ #如果编译出来的文件已经存在，强制覆盖\n\t    -M  AndroidManifest.xml  \\ # Mainifest.xml 的路径\n\t    -I  $(PLATFORMS)/android.jar \\ # 某个版本平台的 android.jar 的路径　#依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...\n\t    -S  res/ \\ # res 文件夹路径\n\t    -J gen/ \\ # 生成 R.java 的输出目录\n\t    -m  #使得生成的包的目录放在 -J 参数指定的目录\n\n#### 代码编译，生成 .class\n\n\tjavac_task:\n\t    javac -source 1.7 -target 1.7 \\ # 使用 jdk1.8 编译 1.7 的 .class 文件\n\t    -encoding UTF-8 \\ \n\t    -bootclasspath  $(PLATFORMS)/android.jar \\ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...\n\t    -d build/ \\ #指定放置生成的类文件的位置\n\t    java/thereisnospon/dextest/*.java \\\n\t    gen/thereisnospon/dextest/*.java \\\n    \n    \n#### 生成 .dex\n\n\tdx_task:\n\t\t$(dx) --dex --output=build/classes.dex \\\n\t\tbuild  \n\t\n#### 资源文件初始包\n\n\tresapk_task:\n\t\t$(aapt) package -f \\\n\t    -M  AndroidManifest.xml  \\\n\t    -I  $(PLATFORMS)/android.jar \\\n\t    -S  res/ \\\n\t    -F  out/resources\n\n\n#### 将.dex 文件加入到资源文件初始包中\n　　\n注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行\n\n\tapk_task:\t\n\t\tjava -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \\\n\t\t  com.android.sdklib.build.ApkBuilderMain \\\n\t\t  Demo.apk -v -u -z src/main/out/resources\\\n\t\t  -f src/main/build/classes.dex -rf src\n\t\n#### 签名，使用debug的签名\n\n\tsigner:\n\t\tjarsigner -verbose \\\n\t    -keystore ~/.android/debug.keystore \\\n\t    -storepass android \\\n\t    -keypass android \\\n\t    Demo.apk  androiddebugkey\n\t\n#### 一次性打包\n\n\tpkg: \n\t\tmake apk_task\n\t\tmake signer \n\t\n\n#### 卸载apk\n\tuninstall:\n\t\t$(adb) uninstall  thereisnospon.dextest\n\t\n\n#### 安装apk\n\n\tinstall: \n\t\t$(adb) install out/app.apk\n\n#### 运行\n\nrun:\n\tmake pkg \n\tmake uninstall\n\tmake install\n\t\n\n\t\t$(adb) shell am start -n thereisnospon.dextest/        thereisnospon.dextest.MainActivity  \n\n### 方法２，用gradle,\n\n首先用AS 建立工程，之后在工程文件下，之星执行，gradle clean\ngradle build\n即生成apk文件\n   \n\n  ","slug":"android-howto-makeapk-cmd","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7n100062ujxrfd5w6tx","content":"<h3 id=\"how-to-make-a-android-by-cmd\"><a href=\"#how-to-make-a-android-by-cmd\" class=\"headerlink\" title=\"how to make a android by cmd :\"></a>how to make a android by cmd :</h3><pre><code>在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni\n</code></pre><a id=\"more\"></a>\n<h3 id=\"way-1-方法１\"><a href=\"#way-1-方法１\" class=\"headerlink\" title=\"way 1:方法１\"></a>way 1:方法１</h3><h4 id=\"prepare\"><a href=\"#prepare\" class=\"headerlink\" title=\"prepare\"></a>prepare</h4><pre><code>android studio 创建了一个工程，然后手动在命令行打包，进入工程里的.  或者direct use andrid create project创建\n</code></pre><p>cd ~/Desktop/FirstTest/app/src/main<br>mkdir gen<br>mkdir build<br>mkdir out</p>\n<p>在android工程目录下建立Makefile文件，添加如下代码：<br>    SDK=~/Android/Sdk　　　　<br>    BUILD_TOOLS=$(SDK)/build-tools/25.0.3<br>    PLATFORMS=$(SDK)/platforms/android-25<br>    aapt=$(BUILD_TOOLS)/aapt<br>    dx=$(BUILD_TOOLS)/dx<br>    aidl=$(BUILD_TOOLS)/aidl<br>    apkbuilder=$(SDK)/tools/apkbuilder2 //后面不支持apkbuilder所以<br>    adb=$(SDK)/platform-tools/adb</p>\n<h4 id=\"资源编译，生成-R-java\"><a href=\"#资源编译，生成-R-java\" class=\"headerlink\" title=\"资源编译，生成 R.java\"></a>资源编译，生成 R.java</h4><pre><code>aapt_task:\n    $(aapt) package \\\n    -f \\ #如果编译出来的文件已经存在，强制覆盖\n    -M  AndroidManifest.xml  \\ # Mainifest.xml 的路径\n    -I  $(PLATFORMS)/android.jar \\ # 某个版本平台的 android.jar 的路径　#依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...\n    -S  res/ \\ # res 文件夹路径\n    -J gen/ \\ # 生成 R.java 的输出目录\n    -m  #使得生成的包的目录放在 -J 参数指定的目录\n</code></pre><h4 id=\"代码编译，生成-class\"><a href=\"#代码编译，生成-class\" class=\"headerlink\" title=\"代码编译，生成 .class\"></a>代码编译，生成 .class</h4><pre><code>javac_task:\n    javac -source 1.7 -target 1.7 \\ # 使用 jdk1.8 编译 1.7 的 .class 文件\n    -encoding UTF-8 \\ \n    -bootclasspath  $(PLATFORMS)/android.jar \\ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...\n    -d build/ \\ #指定放置生成的类文件的位置\n    java/thereisnospon/dextest/*.java \\\n    gen/thereisnospon/dextest/*.java \\\n</code></pre><h4 id=\"生成-dex\"><a href=\"#生成-dex\" class=\"headerlink\" title=\"生成 .dex\"></a>生成 .dex</h4><pre><code>dx_task:\n    $(dx) --dex --output=build/classes.dex \\\n    build  \n</code></pre><h4 id=\"资源文件初始包\"><a href=\"#资源文件初始包\" class=\"headerlink\" title=\"资源文件初始包\"></a>资源文件初始包</h4><pre><code>resapk_task:\n    $(aapt) package -f \\\n    -M  AndroidManifest.xml  \\\n    -I  $(PLATFORMS)/android.jar \\\n    -S  res/ \\\n    -F  out/resources\n</code></pre><h4 id=\"将-dex-文件加入到资源文件初始包中\"><a href=\"#将-dex-文件加入到资源文件初始包中\" class=\"headerlink\" title=\"将.dex 文件加入到资源文件初始包中\"></a>将.dex 文件加入到资源文件初始包中</h4><p>　　<br>注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行</p>\n<pre><code>apk_task:    \n    java -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \\\n      com.android.sdklib.build.ApkBuilderMain \\\n      Demo.apk -v -u -z src/main/out/resources\\\n      -f src/main/build/classes.dex -rf src\n</code></pre><h4 id=\"签名，使用debug的签名\"><a href=\"#签名，使用debug的签名\" class=\"headerlink\" title=\"签名，使用debug的签名\"></a>签名，使用debug的签名</h4><pre><code>signer:\n    jarsigner -verbose \\\n    -keystore ~/.android/debug.keystore \\\n    -storepass android \\\n    -keypass android \\\n    Demo.apk  androiddebugkey\n</code></pre><h4 id=\"一次性打包\"><a href=\"#一次性打包\" class=\"headerlink\" title=\"一次性打包\"></a>一次性打包</h4><pre><code>pkg: \n    make apk_task\n    make signer \n</code></pre><h4 id=\"卸载apk\"><a href=\"#卸载apk\" class=\"headerlink\" title=\"卸载apk\"></a>卸载apk</h4><pre><code>uninstall:\n    $(adb) uninstall  thereisnospon.dextest\n</code></pre><h4 id=\"安装apk\"><a href=\"#安装apk\" class=\"headerlink\" title=\"安装apk\"></a>安装apk</h4><pre><code>install: \n    $(adb) install out/app.apk\n</code></pre><h4 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h4><p>run:<br>    make pkg<br>    make uninstall<br>    make install</p>\n<pre><code>$(adb) shell am start -n thereisnospon.dextest/        thereisnospon.dextest.MainActivity  \n</code></pre><h3 id=\"方法２，用gradle\"><a href=\"#方法２，用gradle\" class=\"headerlink\" title=\"方法２，用gradle,\"></a>方法２，用gradle,</h3><p>首先用AS 建立工程，之后在工程文件下，之星执行，gradle clean<br>gradle build<br>即生成apk文件</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"how-to-make-a-android-by-cmd\"><a href=\"#how-to-make-a-android-by-cmd\" class=\"headerlink\" title=\"how to make a android by cmd :\"></a>how to make a android by cmd :</h3><pre><code>在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni\n</code></pre>","more":"<h3 id=\"way-1-方法１\"><a href=\"#way-1-方法１\" class=\"headerlink\" title=\"way 1:方法１\"></a>way 1:方法１</h3><h4 id=\"prepare\"><a href=\"#prepare\" class=\"headerlink\" title=\"prepare\"></a>prepare</h4><pre><code>android studio 创建了一个工程，然后手动在命令行打包，进入工程里的.  或者direct use andrid create project创建\n</code></pre><p>cd ~/Desktop/FirstTest/app/src/main<br>mkdir gen<br>mkdir build<br>mkdir out</p>\n<p>在android工程目录下建立Makefile文件，添加如下代码：<br>    SDK=~/Android/Sdk　　　　<br>    BUILD_TOOLS=$(SDK)/build-tools/25.0.3<br>    PLATFORMS=$(SDK)/platforms/android-25<br>    aapt=$(BUILD_TOOLS)/aapt<br>    dx=$(BUILD_TOOLS)/dx<br>    aidl=$(BUILD_TOOLS)/aidl<br>    apkbuilder=$(SDK)/tools/apkbuilder2 //后面不支持apkbuilder所以<br>    adb=$(SDK)/platform-tools/adb</p>\n<h4 id=\"资源编译，生成-R-java\"><a href=\"#资源编译，生成-R-java\" class=\"headerlink\" title=\"资源编译，生成 R.java\"></a>资源编译，生成 R.java</h4><pre><code>aapt_task:\n    $(aapt) package \\\n    -f \\ #如果编译出来的文件已经存在，强制覆盖\n    -M  AndroidManifest.xml  \\ # Mainifest.xml 的路径\n    -I  $(PLATFORMS)/android.jar \\ # 某个版本平台的 android.jar 的路径　#依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...\n    -S  res/ \\ # res 文件夹路径\n    -J gen/ \\ # 生成 R.java 的输出目录\n    -m  #使得生成的包的目录放在 -J 参数指定的目录\n</code></pre><h4 id=\"代码编译，生成-class\"><a href=\"#代码编译，生成-class\" class=\"headerlink\" title=\"代码编译，生成 .class\"></a>代码编译，生成 .class</h4><pre><code>javac_task:\n    javac -source 1.7 -target 1.7 \\ # 使用 jdk1.8 编译 1.7 的 .class 文件\n    -encoding UTF-8 \\ \n    -bootclasspath  $(PLATFORMS)/android.jar \\ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...\n    -d build/ \\ #指定放置生成的类文件的位置\n    java/thereisnospon/dextest/*.java \\\n    gen/thereisnospon/dextest/*.java \\\n</code></pre><h4 id=\"生成-dex\"><a href=\"#生成-dex\" class=\"headerlink\" title=\"生成 .dex\"></a>生成 .dex</h4><pre><code>dx_task:\n    $(dx) --dex --output=build/classes.dex \\\n    build  \n</code></pre><h4 id=\"资源文件初始包\"><a href=\"#资源文件初始包\" class=\"headerlink\" title=\"资源文件初始包\"></a>资源文件初始包</h4><pre><code>resapk_task:\n    $(aapt) package -f \\\n    -M  AndroidManifest.xml  \\\n    -I  $(PLATFORMS)/android.jar \\\n    -S  res/ \\\n    -F  out/resources\n</code></pre><h4 id=\"将-dex-文件加入到资源文件初始包中\"><a href=\"#将-dex-文件加入到资源文件初始包中\" class=\"headerlink\" title=\"将.dex 文件加入到资源文件初始包中\"></a>将.dex 文件加入到资源文件初始包中</h4><p>　　<br>注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行</p>\n<pre><code>apk_task:    \n    java -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \\\n      com.android.sdklib.build.ApkBuilderMain \\\n      Demo.apk -v -u -z src/main/out/resources\\\n      -f src/main/build/classes.dex -rf src\n</code></pre><h4 id=\"签名，使用debug的签名\"><a href=\"#签名，使用debug的签名\" class=\"headerlink\" title=\"签名，使用debug的签名\"></a>签名，使用debug的签名</h4><pre><code>signer:\n    jarsigner -verbose \\\n    -keystore ~/.android/debug.keystore \\\n    -storepass android \\\n    -keypass android \\\n    Demo.apk  androiddebugkey\n</code></pre><h4 id=\"一次性打包\"><a href=\"#一次性打包\" class=\"headerlink\" title=\"一次性打包\"></a>一次性打包</h4><pre><code>pkg: \n    make apk_task\n    make signer \n</code></pre><h4 id=\"卸载apk\"><a href=\"#卸载apk\" class=\"headerlink\" title=\"卸载apk\"></a>卸载apk</h4><pre><code>uninstall:\n    $(adb) uninstall  thereisnospon.dextest\n</code></pre><h4 id=\"安装apk\"><a href=\"#安装apk\" class=\"headerlink\" title=\"安装apk\"></a>安装apk</h4><pre><code>install: \n    $(adb) install out/app.apk\n</code></pre><h4 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h4><p>run:<br>    make pkg<br>    make uninstall<br>    make install</p>\n<pre><code>$(adb) shell am start -n thereisnospon.dextest/        thereisnospon.dextest.MainActivity  \n</code></pre><h3 id=\"方法２，用gradle\"><a href=\"#方法２，用gradle\" class=\"headerlink\" title=\"方法２，用gradle,\"></a>方法２，用gradle,</h3><p>首先用AS 建立工程，之后在工程文件下，之星执行，gradle clean<br>gradle build<br>即生成apk文件</p>"},{"title":"android_jni","date":"2018-05-20T09:53:27.000Z","_content":"\n\n### a example of JNI static way:\n\n#### first step: write a middle java file:\nmkdir jni\ncd jni/<!-- more -->\nvim TestJni.java\n\n\timport java.util.*;\n\tpublic class TestJni\n\t{\n\t\tpublic native void xprint(String content);\n\t\tstatic\n\t\t{\n\t\t\tSystem.loadLibrary(\"TestJni\");\n\t\t}\n\t}\n\n  javac TestJni.java  and make a class\n  \nthen \n  javah -jni TestJni  to make a .h file:\n  \n\t  /* DO NOT EDIT THIS FILE - it is machine generated */\n\t#include <jni.h>\n\t/* Header for class TestJni */\n\t\n\t#ifndef _Included_TestJni\n\t#define _Included_TestJni\n\t#ifdef __cplusplus\n\textern \"C\" {\n\t#endif\n\t/*\n\t * Class:     TestJni\n\t * Method:    xprint\n\t * Signature: (Ljava/lang/String;)V\n\t */\n\tJNIEXPORT void JNICALL Java_TestJni_xprint\n\t  (JNIEnv *, jobject, jstring);\n\t\n\t#ifdef __cplusplus\n\t}\n\t#endif\n\t#endif\n\t\n#### step two write jni file.c:\n\nTestJni.c:\n\n\t#include<jni.h>\n\t#include<stdio.h>\n\t#include \"TestJni.h\"\n\t\n\tJNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content)\n\t{\n\t\tconst jbyte *str=(const jbyte*)(*env)->GetStringUTFChars(env,content,JNI_FALSE);\n\t\tprintf(\"hello--wo%s \\n\",str);\n\t\t(*env)->ReleaseStringUTFChars(env,content,(const char*)str);\n\t\treturn;\n\t}\n\t\n#### three build .so lib\n\tcc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c\n\t\n#### four write a test:hellow.java\n\timport java.util.*;\n\tpublic class hellow\n\t{\n\t\tpublic static void main(String argc[])\n\t    { \n\t\t    new hellow();\n\t    }\n\t    public hellow()\n\t    { \n\t       new TestJni().xprint(\"hi my name is keee\");\n\t    }\n\t}\n\t\n#### question:\n如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径：\n\njava -Djava.library.path='.' HelloWorld\n或者输入命令：\nexport LD_LIBRARY_PATH=“HelloWorld路径”:$LD_LIBRARY_PATH   设置环境变量\n\n然后再 java HelloWorld 一样OK\n\t\t\n#### reference\nhttp://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html\nhttp://www.cnblogs.com/wzben/p/5733571.html\n\n\n\n### a example of JNI dynamic way:\n\n#### step 1:\nwrite a TestJni.java\n\t\n\tpublic class SimpleJni{\n\t\tstatic {\n\t\t\tSystem.out.println(\"[java] static code block,start load shared library...\");\n\t\t\tSystem.loadLibrary(\"SimpleJni\");\n\t\t\tSystem.out.println(\"[java]load library end...\");\n\t\t}\n\t\tstatic native int add(int a,int b);\n\t\tpublic static void main(String args[])\n\t\t{\n\t\t\tSystem.out.println(\"[java] in main...\");\n\t\t\tSystem.out.println(\"[java] 3+4=\"+SimpleJni.add(3,4));\n\t\t\tSystem.out.println(\"end...\");\n\t\t}\n\t}\n\t\n\n#### step 2:\nwrite a Jni file:\n\t#include <jni.h>\n\t#include<stdio.h>\n\tconst char *classPathName=\"com/bt/jni/SimpleJni\";\n\t\n\tjint myadd(JNIEnv *env,jobject thiz,jint a,jint b)\n\t{\n\t\treturn a+b;\n\t}\n\tstatic JNINativeMethod methods[]={\n\t\t{\"add\",\"(II)I\",(void*)myadd},};\n\tint registerNatives(JNIEnv *env)\n\t{\n\t\tjclass clazz;\n\t\n\t\tclazz=(*env)->FindClass(env,classPathName);\n\t\tif(NULL==clazz){\n\t\t   printf(\"[C] FindClass fail\\n\");\n\t\t   goto failed;\n\t\t}\n\t\t if (0>(*env)->RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0]))){\n\t\t\t printf(\"RegisterNatives fail.\\n\");\n\t\t\t goto failed;\n\t\t }\n\t\t return JNI_TRUE;\n\tfailed:\n\t\t return JNI_FALSE;\n\t}\n\t\n\t\n\tjint JNI_OnLoad(JavaVM *vm,void *reserved)\n\t{\n\t\tJNIEnv *env=NULL;\n\t\tjint result=-1;\n\t\tvoid **env_p=NULL;\n\t\n\t\tprintf(\"start register native func\\n\");\n\t\tenv_p=(void**)&env;\n\t\n\t\tif(JNI_OK!=(*vm)->GetEnv(vm,env_p,0x00010006)){\n\t\t\tprintf(\"get env failed..\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif(JNI_TRUE!=registerNatives(env)){\n\t\t\tprintf(\"register fail...exit....\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tresult=0x00010006;\n\terr:\n\t\treturn result;\n\t}\n\t\n\n#### step use:\n1.首先编写SimpleJni.java和simpel_jni.c\n    2.编译java和c文件\n$ java -d .  SimpleJni.java\n$gcc -fPIC -I$JAVA_HOME/include/ -I$JAVA_HOME/include/linux/ -o libsimpleJni.so simple_jni.c\n\n    3.执行\n    $java -Djava.library.path=. com.bt.jni.SimpleJni\n\n\n\n\n#### other example:\n\njava file:\n\timport java.util.*;\n\tpublic class TestJni\n\t{\n\t\tpublic native void xprint(String content);\n\t\tstatic\n\t\t{\n\t\t\tSystem.loadLibrary(\"TestJni\");\n\t\t}\n\t\tpublic native static String native_hello();\n\t}\n\t\n\t\n\nJNI file:\n\t\n\t#include<jni.h>\n\t#include<stdio.h>\n\t//#include \"TestJni.h\"\n\t#include<iostream>\n\tusing namespace std;\n\t void xprint(JNIEnv *env,jobject obj,jstring content)\n\t{  \n\t//\tconst jbyte *str=(const jbyte*)(env->GetStringUTFChars(env,content,JNI_FALSE));\n\t\t//printf(\"hello--wo%s \\n\",str);\n\t//\tenv->ReleaseStringUTFChars(env,content,(const char*)str);\n\t        cout<<\"here:\"<<content<<endl;\n\t\treturn;\n\t}\n\tstatic jstring  native_hello(JNIEnv *env,jobject object)\n\t{ \n\t\n\t\t\n\t\treturn (env)->NewStringUTF(\"keshixi\");\n\t}\n\t\n\tstatic JNINativeMethod method_table[]={\n\t\t{ \"xprint\",\"(Ljava/lang/String;)V\",(void*)xprint},\n\t\t{\"native_hello\",\"()Ljava/lang/String;\",(void*)native_hello}\n\t//    {,,(void*)xprint},{,,(void*)native_hello}\n\t};\n\t\n\t jint JNI_OnLoad(JavaVM *jvm,void *reserved){\n\t\tJNIEnv *env;\n\t\tif(jvm->GetEnv((void**)&env,JNI_VERSION_1_6)!=JNI_OK){\n\t\t\treturn -1;\n\t\t}\n\t\tjclass clz=env->FindClass(\"TestJni\");\n\t\tif(clz==NULL)\n\t\t{\n\t\t\treturn JNI_FALSE;\n\t\t}\n\t\tif(env->RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK){\n\t\t\treturn JNI_VERSION_1_6;\n\t\t}\n\t  }\n\t\n\t\n####reference:\njni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行\n\n动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子\n\n另外可以作为ndk在android中使用及在android　stdio也可以直接生成so\n\n一些链接：android_jni_ndk:http://www.cnblogs.com/wzben/p/5733571.html\n动态注册无运行实例：http://www.linuxidc.com/Linux/2017-02/140130.htm\n静态注册：http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html\n动态注册：有实例http://www.linuxidc.com/Linux/2017-02/140129.htm\n\nwww.fer.unizg.hr/_download/repository/jni.pdf文档\t\n\t\n\t\n\n","source":"_posts/android-jni.md","raw":"---\ntitle: android_jni\ndate: 2018-05-20 17:53:27\ntags: android_coding\ncategories: android\n---\n\n\n### a example of JNI static way:\n\n#### first step: write a middle java file:\nmkdir jni\ncd jni/<!-- more -->\nvim TestJni.java\n\n\timport java.util.*;\n\tpublic class TestJni\n\t{\n\t\tpublic native void xprint(String content);\n\t\tstatic\n\t\t{\n\t\t\tSystem.loadLibrary(\"TestJni\");\n\t\t}\n\t}\n\n  javac TestJni.java  and make a class\n  \nthen \n  javah -jni TestJni  to make a .h file:\n  \n\t  /* DO NOT EDIT THIS FILE - it is machine generated */\n\t#include <jni.h>\n\t/* Header for class TestJni */\n\t\n\t#ifndef _Included_TestJni\n\t#define _Included_TestJni\n\t#ifdef __cplusplus\n\textern \"C\" {\n\t#endif\n\t/*\n\t * Class:     TestJni\n\t * Method:    xprint\n\t * Signature: (Ljava/lang/String;)V\n\t */\n\tJNIEXPORT void JNICALL Java_TestJni_xprint\n\t  (JNIEnv *, jobject, jstring);\n\t\n\t#ifdef __cplusplus\n\t}\n\t#endif\n\t#endif\n\t\n#### step two write jni file.c:\n\nTestJni.c:\n\n\t#include<jni.h>\n\t#include<stdio.h>\n\t#include \"TestJni.h\"\n\t\n\tJNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content)\n\t{\n\t\tconst jbyte *str=(const jbyte*)(*env)->GetStringUTFChars(env,content,JNI_FALSE);\n\t\tprintf(\"hello--wo%s \\n\",str);\n\t\t(*env)->ReleaseStringUTFChars(env,content,(const char*)str);\n\t\treturn;\n\t}\n\t\n#### three build .so lib\n\tcc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c\n\t\n#### four write a test:hellow.java\n\timport java.util.*;\n\tpublic class hellow\n\t{\n\t\tpublic static void main(String argc[])\n\t    { \n\t\t    new hellow();\n\t    }\n\t    public hellow()\n\t    { \n\t       new TestJni().xprint(\"hi my name is keee\");\n\t    }\n\t}\n\t\n#### question:\n如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径：\n\njava -Djava.library.path='.' HelloWorld\n或者输入命令：\nexport LD_LIBRARY_PATH=“HelloWorld路径”:$LD_LIBRARY_PATH   设置环境变量\n\n然后再 java HelloWorld 一样OK\n\t\t\n#### reference\nhttp://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html\nhttp://www.cnblogs.com/wzben/p/5733571.html\n\n\n\n### a example of JNI dynamic way:\n\n#### step 1:\nwrite a TestJni.java\n\t\n\tpublic class SimpleJni{\n\t\tstatic {\n\t\t\tSystem.out.println(\"[java] static code block,start load shared library...\");\n\t\t\tSystem.loadLibrary(\"SimpleJni\");\n\t\t\tSystem.out.println(\"[java]load library end...\");\n\t\t}\n\t\tstatic native int add(int a,int b);\n\t\tpublic static void main(String args[])\n\t\t{\n\t\t\tSystem.out.println(\"[java] in main...\");\n\t\t\tSystem.out.println(\"[java] 3+4=\"+SimpleJni.add(3,4));\n\t\t\tSystem.out.println(\"end...\");\n\t\t}\n\t}\n\t\n\n#### step 2:\nwrite a Jni file:\n\t#include <jni.h>\n\t#include<stdio.h>\n\tconst char *classPathName=\"com/bt/jni/SimpleJni\";\n\t\n\tjint myadd(JNIEnv *env,jobject thiz,jint a,jint b)\n\t{\n\t\treturn a+b;\n\t}\n\tstatic JNINativeMethod methods[]={\n\t\t{\"add\",\"(II)I\",(void*)myadd},};\n\tint registerNatives(JNIEnv *env)\n\t{\n\t\tjclass clazz;\n\t\n\t\tclazz=(*env)->FindClass(env,classPathName);\n\t\tif(NULL==clazz){\n\t\t   printf(\"[C] FindClass fail\\n\");\n\t\t   goto failed;\n\t\t}\n\t\t if (0>(*env)->RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0]))){\n\t\t\t printf(\"RegisterNatives fail.\\n\");\n\t\t\t goto failed;\n\t\t }\n\t\t return JNI_TRUE;\n\tfailed:\n\t\t return JNI_FALSE;\n\t}\n\t\n\t\n\tjint JNI_OnLoad(JavaVM *vm,void *reserved)\n\t{\n\t\tJNIEnv *env=NULL;\n\t\tjint result=-1;\n\t\tvoid **env_p=NULL;\n\t\n\t\tprintf(\"start register native func\\n\");\n\t\tenv_p=(void**)&env;\n\t\n\t\tif(JNI_OK!=(*vm)->GetEnv(vm,env_p,0x00010006)){\n\t\t\tprintf(\"get env failed..\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif(JNI_TRUE!=registerNatives(env)){\n\t\t\tprintf(\"register fail...exit....\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tresult=0x00010006;\n\terr:\n\t\treturn result;\n\t}\n\t\n\n#### step use:\n1.首先编写SimpleJni.java和simpel_jni.c\n    2.编译java和c文件\n$ java -d .  SimpleJni.java\n$gcc -fPIC -I$JAVA_HOME/include/ -I$JAVA_HOME/include/linux/ -o libsimpleJni.so simple_jni.c\n\n    3.执行\n    $java -Djava.library.path=. com.bt.jni.SimpleJni\n\n\n\n\n#### other example:\n\njava file:\n\timport java.util.*;\n\tpublic class TestJni\n\t{\n\t\tpublic native void xprint(String content);\n\t\tstatic\n\t\t{\n\t\t\tSystem.loadLibrary(\"TestJni\");\n\t\t}\n\t\tpublic native static String native_hello();\n\t}\n\t\n\t\n\nJNI file:\n\t\n\t#include<jni.h>\n\t#include<stdio.h>\n\t//#include \"TestJni.h\"\n\t#include<iostream>\n\tusing namespace std;\n\t void xprint(JNIEnv *env,jobject obj,jstring content)\n\t{  \n\t//\tconst jbyte *str=(const jbyte*)(env->GetStringUTFChars(env,content,JNI_FALSE));\n\t\t//printf(\"hello--wo%s \\n\",str);\n\t//\tenv->ReleaseStringUTFChars(env,content,(const char*)str);\n\t        cout<<\"here:\"<<content<<endl;\n\t\treturn;\n\t}\n\tstatic jstring  native_hello(JNIEnv *env,jobject object)\n\t{ \n\t\n\t\t\n\t\treturn (env)->NewStringUTF(\"keshixi\");\n\t}\n\t\n\tstatic JNINativeMethod method_table[]={\n\t\t{ \"xprint\",\"(Ljava/lang/String;)V\",(void*)xprint},\n\t\t{\"native_hello\",\"()Ljava/lang/String;\",(void*)native_hello}\n\t//    {,,(void*)xprint},{,,(void*)native_hello}\n\t};\n\t\n\t jint JNI_OnLoad(JavaVM *jvm,void *reserved){\n\t\tJNIEnv *env;\n\t\tif(jvm->GetEnv((void**)&env,JNI_VERSION_1_6)!=JNI_OK){\n\t\t\treturn -1;\n\t\t}\n\t\tjclass clz=env->FindClass(\"TestJni\");\n\t\tif(clz==NULL)\n\t\t{\n\t\t\treturn JNI_FALSE;\n\t\t}\n\t\tif(env->RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK){\n\t\t\treturn JNI_VERSION_1_6;\n\t\t}\n\t  }\n\t\n\t\n####reference:\njni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行\n\n动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子\n\n另外可以作为ndk在android中使用及在android　stdio也可以直接生成so\n\n一些链接：android_jni_ndk:http://www.cnblogs.com/wzben/p/5733571.html\n动态注册无运行实例：http://www.linuxidc.com/Linux/2017-02/140130.htm\n静态注册：http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html\n动态注册：有实例http://www.linuxidc.com/Linux/2017-02/140129.htm\n\nwww.fer.unizg.hr/_download/repository/jni.pdf文档\t\n\t\n\t\n\n","slug":"android-jni","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7n5000a2ujx3ofc89c1","content":"<h3 id=\"a-example-of-JNI-static-way\"><a href=\"#a-example-of-JNI-static-way\" class=\"headerlink\" title=\"a example of JNI static way:\"></a>a example of JNI static way:</h3><h4 id=\"first-step-write-a-middle-java-file\"><a href=\"#first-step-write-a-middle-java-file\" class=\"headerlink\" title=\"first step: write a middle java file:\"></a>first step: write a middle java file:</h4><p>mkdir jni<br>cd jni/<a id=\"more\"></a><br>vim TestJni.java</p>\n<pre><code>import java.util.*;\npublic class TestJni\n{\n    public native void xprint(String content);\n    static\n    {\n        System.loadLibrary(&quot;TestJni&quot;);\n    }\n}\n</code></pre><p>  javac TestJni.java  and make a class</p>\n<p>then<br>  javah -jni TestJni  to make a .h file:</p>\n<pre><code>  /* DO NOT EDIT THIS FILE - it is machine generated */\n#include &lt;jni.h&gt;\n/* Header for class TestJni */\n\n#ifndef _Included_TestJni\n#define _Included_TestJni\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n/*\n * Class:     TestJni\n * Method:    xprint\n * Signature: (Ljava/lang/String;)V\n */\nJNIEXPORT void JNICALL Java_TestJni_xprint\n  (JNIEnv *, jobject, jstring);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n</code></pre><h4 id=\"step-two-write-jni-file-c\"><a href=\"#step-two-write-jni-file-c\" class=\"headerlink\" title=\"step two write jni file.c:\"></a>step two write jni file.c:</h4><p>TestJni.c:</p>\n<pre><code>#include&lt;jni.h&gt;\n#include&lt;stdio.h&gt;\n#include &quot;TestJni.h&quot;\n\nJNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content)\n{\n    const jbyte *str=(const jbyte*)(*env)-&gt;GetStringUTFChars(env,content,JNI_FALSE);\n    printf(&quot;hello--wo%s \\n&quot;,str);\n    (*env)-&gt;ReleaseStringUTFChars(env,content,(const char*)str);\n    return;\n}\n</code></pre><h4 id=\"three-build-so-lib\"><a href=\"#three-build-so-lib\" class=\"headerlink\" title=\"three build .so lib\"></a>three build .so lib</h4><pre><code>cc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c\n</code></pre><h4 id=\"four-write-a-test-hellow-java\"><a href=\"#four-write-a-test-hellow-java\" class=\"headerlink\" title=\"four write a test:hellow.java\"></a>four write a test:hellow.java</h4><pre><code>import java.util.*;\npublic class hellow\n{\n    public static void main(String argc[])\n    { \n        new hellow();\n    }\n    public hellow()\n    { \n       new TestJni().xprint(&quot;hi my name is keee&quot;);\n    }\n}\n</code></pre><h4 id=\"question\"><a href=\"#question\" class=\"headerlink\" title=\"question:\"></a>question:</h4><p>如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径：</p>\n<p>java -Djava.library.path=’.’ HelloWorld<br>或者输入命令：<br>export LD_LIBRARY_PATH=“HelloWorld路径”:$LD_LIBRARY_PATH   设置环境变量</p>\n<p>然后再 java HelloWorld 一样OK</p>\n<h4 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h4><p><a href=\"http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br><a href=\"http://www.cnblogs.com/wzben/p/5733571.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/wzben/p/5733571.html</a></p>\n<h3 id=\"a-example-of-JNI-dynamic-way\"><a href=\"#a-example-of-JNI-dynamic-way\" class=\"headerlink\" title=\"a example of JNI dynamic way:\"></a>a example of JNI dynamic way:</h3><h4 id=\"step-1\"><a href=\"#step-1\" class=\"headerlink\" title=\"step 1:\"></a>step 1:</h4><p>write a TestJni.java</p>\n<pre><code>public class SimpleJni{\n    static {\n        System.out.println(&quot;[java] static code block,start load shared library...&quot;);\n        System.loadLibrary(&quot;SimpleJni&quot;);\n        System.out.println(&quot;[java]load library end...&quot;);\n    }\n    static native int add(int a,int b);\n    public static void main(String args[])\n    {\n        System.out.println(&quot;[java] in main...&quot;);\n        System.out.println(&quot;[java] 3+4=&quot;+SimpleJni.add(3,4));\n        System.out.println(&quot;end...&quot;);\n    }\n}\n</code></pre><h4 id=\"step-2\"><a href=\"#step-2\" class=\"headerlink\" title=\"step 2:\"></a>step 2:</h4><p>write a Jni file:</p>\n<pre><code>#include &lt;jni.h&gt;\n#include&lt;stdio.h&gt;\nconst char *classPathName=&quot;com/bt/jni/SimpleJni&quot;;\n\njint myadd(JNIEnv *env,jobject thiz,jint a,jint b)\n{\n    return a+b;\n}\nstatic JNINativeMethod methods[]={\n    {&quot;add&quot;,&quot;(II)I&quot;,(void*)myadd},};\nint registerNatives(JNIEnv *env)\n{\n    jclass clazz;\n\n    clazz=(*env)-&gt;FindClass(env,classPathName);\n    if(NULL==clazz){\n       printf(&quot;[C] FindClass fail\\n&quot;);\n       goto failed;\n    }\n     if (0&gt;(*env)-&gt;RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0]))){\n         printf(&quot;RegisterNatives fail.\\n&quot;);\n         goto failed;\n     }\n     return JNI_TRUE;\nfailed:\n     return JNI_FALSE;\n}\n\n\njint JNI_OnLoad(JavaVM *vm,void *reserved)\n{\n    JNIEnv *env=NULL;\n    jint result=-1;\n    void **env_p=NULL;\n\n    printf(&quot;start register native func\\n&quot;);\n    env_p=(void**)&amp;env;\n\n    if(JNI_OK!=(*vm)-&gt;GetEnv(vm,env_p,0x00010006)){\n        printf(&quot;get env failed..\\n&quot;);\n        goto err;\n    }\n    if(JNI_TRUE!=registerNatives(env)){\n        printf(&quot;register fail...exit....\\n&quot;);\n        goto err;\n    }\n    result=0x00010006;\nerr:\n    return result;\n}\n</code></pre><h4 id=\"step-use\"><a href=\"#step-use\" class=\"headerlink\" title=\"step use:\"></a>step use:</h4><p>1.首先编写SimpleJni.java和simpel_jni.c<br>    2.编译java和c文件<br>$ java -d .  SimpleJni.java<br>$gcc -fPIC -I$JAVA_HOME/include/ -I$JAVA_HOME/include/linux/ -o libsimpleJni.so simple_jni.c</p>\n<pre><code>3.执行\n$java -Djava.library.path=. com.bt.jni.SimpleJni\n</code></pre><h4 id=\"other-example\"><a href=\"#other-example\" class=\"headerlink\" title=\"other example:\"></a>other example:</h4><p>java file:<br>    import java.util.*;<br>    public class TestJni<br>    {<br>        public native void xprint(String content);<br>        static<br>        {<br>            System.loadLibrary(“TestJni”);<br>        }<br>        public native static String native_hello();<br>    }</p>\n<p>JNI file:</p>\n<pre><code>#include&lt;jni.h&gt;\n#include&lt;stdio.h&gt;\n//#include &quot;TestJni.h&quot;\n#include&lt;iostream&gt;\nusing namespace std;\n void xprint(JNIEnv *env,jobject obj,jstring content)\n{  \n//    const jbyte *str=(const jbyte*)(env-&gt;GetStringUTFChars(env,content,JNI_FALSE));\n    //printf(&quot;hello--wo%s \\n&quot;,str);\n//    env-&gt;ReleaseStringUTFChars(env,content,(const char*)str);\n        cout&lt;&lt;&quot;here:&quot;&lt;&lt;content&lt;&lt;endl;\n    return;\n}\nstatic jstring  native_hello(JNIEnv *env,jobject object)\n{ \n\n\n    return (env)-&gt;NewStringUTF(&quot;keshixi&quot;);\n}\n\nstatic JNINativeMethod method_table[]={\n    { &quot;xprint&quot;,&quot;(Ljava/lang/String;)V&quot;,(void*)xprint},\n    {&quot;native_hello&quot;,&quot;()Ljava/lang/String;&quot;,(void*)native_hello}\n//    {,,(void*)xprint},{,,(void*)native_hello}\n};\n\n jint JNI_OnLoad(JavaVM *jvm,void *reserved){\n    JNIEnv *env;\n    if(jvm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6)!=JNI_OK){\n        return -1;\n    }\n    jclass clz=env-&gt;FindClass(&quot;TestJni&quot;);\n    if(clz==NULL)\n    {\n        return JNI_FALSE;\n    }\n    if(env-&gt;RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK){\n        return JNI_VERSION_1_6;\n    }\n  }\n</code></pre><p>####reference:<br>jni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行</p>\n<p>动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子</p>\n<p>另外可以作为ndk在android中使用及在android　stdio也可以直接生成so</p>\n<p>一些链接：android_jni_ndk:<a href=\"http://www.cnblogs.com/wzben/p/5733571.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/wzben/p/5733571.html</a><br>动态注册无运行实例：<a href=\"http://www.linuxidc.com/Linux/2017-02/140130.htm\" target=\"_blank\" rel=\"noopener\">http://www.linuxidc.com/Linux/2017-02/140130.htm</a><br>静态注册：<a href=\"http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br>动态注册：有实例<a href=\"http://www.linuxidc.com/Linux/2017-02/140129.htm\" target=\"_blank\" rel=\"noopener\">http://www.linuxidc.com/Linux/2017-02/140129.htm</a></p>\n<p><a href=\"http://www.fer.unizg.hr/_download/repository/jni.pdf文档\" target=\"_blank\" rel=\"noopener\">www.fer.unizg.hr/_download/repository/jni.pdf文档</a>    </p>\n","site":{"data":{}},"excerpt":"<h3 id=\"a-example-of-JNI-static-way\"><a href=\"#a-example-of-JNI-static-way\" class=\"headerlink\" title=\"a example of JNI static way:\"></a>a example of JNI static way:</h3><h4 id=\"first-step-write-a-middle-java-file\"><a href=\"#first-step-write-a-middle-java-file\" class=\"headerlink\" title=\"first step: write a middle java file:\"></a>first step: write a middle java file:</h4><p>mkdir jni<br>cd jni/","more":"<br>vim TestJni.java</p>\n<pre><code>import java.util.*;\npublic class TestJni\n{\n    public native void xprint(String content);\n    static\n    {\n        System.loadLibrary(&quot;TestJni&quot;);\n    }\n}\n</code></pre><p>  javac TestJni.java  and make a class</p>\n<p>then<br>  javah -jni TestJni  to make a .h file:</p>\n<pre><code>  /* DO NOT EDIT THIS FILE - it is machine generated */\n#include &lt;jni.h&gt;\n/* Header for class TestJni */\n\n#ifndef _Included_TestJni\n#define _Included_TestJni\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n/*\n * Class:     TestJni\n * Method:    xprint\n * Signature: (Ljava/lang/String;)V\n */\nJNIEXPORT void JNICALL Java_TestJni_xprint\n  (JNIEnv *, jobject, jstring);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n</code></pre><h4 id=\"step-two-write-jni-file-c\"><a href=\"#step-two-write-jni-file-c\" class=\"headerlink\" title=\"step two write jni file.c:\"></a>step two write jni file.c:</h4><p>TestJni.c:</p>\n<pre><code>#include&lt;jni.h&gt;\n#include&lt;stdio.h&gt;\n#include &quot;TestJni.h&quot;\n\nJNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content)\n{\n    const jbyte *str=(const jbyte*)(*env)-&gt;GetStringUTFChars(env,content,JNI_FALSE);\n    printf(&quot;hello--wo%s \\n&quot;,str);\n    (*env)-&gt;ReleaseStringUTFChars(env,content,(const char*)str);\n    return;\n}\n</code></pre><h4 id=\"three-build-so-lib\"><a href=\"#three-build-so-lib\" class=\"headerlink\" title=\"three build .so lib\"></a>three build .so lib</h4><pre><code>cc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c\n</code></pre><h4 id=\"four-write-a-test-hellow-java\"><a href=\"#four-write-a-test-hellow-java\" class=\"headerlink\" title=\"four write a test:hellow.java\"></a>four write a test:hellow.java</h4><pre><code>import java.util.*;\npublic class hellow\n{\n    public static void main(String argc[])\n    { \n        new hellow();\n    }\n    public hellow()\n    { \n       new TestJni().xprint(&quot;hi my name is keee&quot;);\n    }\n}\n</code></pre><h4 id=\"question\"><a href=\"#question\" class=\"headerlink\" title=\"question:\"></a>question:</h4><p>如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径：</p>\n<p>java -Djava.library.path=’.’ HelloWorld<br>或者输入命令：<br>export LD_LIBRARY_PATH=“HelloWorld路径”:$LD_LIBRARY_PATH   设置环境变量</p>\n<p>然后再 java HelloWorld 一样OK</p>\n<h4 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h4><p><a href=\"http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br><a href=\"http://www.cnblogs.com/wzben/p/5733571.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/wzben/p/5733571.html</a></p>\n<h3 id=\"a-example-of-JNI-dynamic-way\"><a href=\"#a-example-of-JNI-dynamic-way\" class=\"headerlink\" title=\"a example of JNI dynamic way:\"></a>a example of JNI dynamic way:</h3><h4 id=\"step-1\"><a href=\"#step-1\" class=\"headerlink\" title=\"step 1:\"></a>step 1:</h4><p>write a TestJni.java</p>\n<pre><code>public class SimpleJni{\n    static {\n        System.out.println(&quot;[java] static code block,start load shared library...&quot;);\n        System.loadLibrary(&quot;SimpleJni&quot;);\n        System.out.println(&quot;[java]load library end...&quot;);\n    }\n    static native int add(int a,int b);\n    public static void main(String args[])\n    {\n        System.out.println(&quot;[java] in main...&quot;);\n        System.out.println(&quot;[java] 3+4=&quot;+SimpleJni.add(3,4));\n        System.out.println(&quot;end...&quot;);\n    }\n}\n</code></pre><h4 id=\"step-2\"><a href=\"#step-2\" class=\"headerlink\" title=\"step 2:\"></a>step 2:</h4><p>write a Jni file:</p>\n<pre><code>#include &lt;jni.h&gt;\n#include&lt;stdio.h&gt;\nconst char *classPathName=&quot;com/bt/jni/SimpleJni&quot;;\n\njint myadd(JNIEnv *env,jobject thiz,jint a,jint b)\n{\n    return a+b;\n}\nstatic JNINativeMethod methods[]={\n    {&quot;add&quot;,&quot;(II)I&quot;,(void*)myadd},};\nint registerNatives(JNIEnv *env)\n{\n    jclass clazz;\n\n    clazz=(*env)-&gt;FindClass(env,classPathName);\n    if(NULL==clazz){\n       printf(&quot;[C] FindClass fail\\n&quot;);\n       goto failed;\n    }\n     if (0&gt;(*env)-&gt;RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0]))){\n         printf(&quot;RegisterNatives fail.\\n&quot;);\n         goto failed;\n     }\n     return JNI_TRUE;\nfailed:\n     return JNI_FALSE;\n}\n\n\njint JNI_OnLoad(JavaVM *vm,void *reserved)\n{\n    JNIEnv *env=NULL;\n    jint result=-1;\n    void **env_p=NULL;\n\n    printf(&quot;start register native func\\n&quot;);\n    env_p=(void**)&amp;env;\n\n    if(JNI_OK!=(*vm)-&gt;GetEnv(vm,env_p,0x00010006)){\n        printf(&quot;get env failed..\\n&quot;);\n        goto err;\n    }\n    if(JNI_TRUE!=registerNatives(env)){\n        printf(&quot;register fail...exit....\\n&quot;);\n        goto err;\n    }\n    result=0x00010006;\nerr:\n    return result;\n}\n</code></pre><h4 id=\"step-use\"><a href=\"#step-use\" class=\"headerlink\" title=\"step use:\"></a>step use:</h4><p>1.首先编写SimpleJni.java和simpel_jni.c<br>    2.编译java和c文件<br>$ java -d .  SimpleJni.java<br>$gcc -fPIC -I$JAVA_HOME/include/ -I$JAVA_HOME/include/linux/ -o libsimpleJni.so simple_jni.c</p>\n<pre><code>3.执行\n$java -Djava.library.path=. com.bt.jni.SimpleJni\n</code></pre><h4 id=\"other-example\"><a href=\"#other-example\" class=\"headerlink\" title=\"other example:\"></a>other example:</h4><p>java file:<br>    import java.util.*;<br>    public class TestJni<br>    {<br>        public native void xprint(String content);<br>        static<br>        {<br>            System.loadLibrary(“TestJni”);<br>        }<br>        public native static String native_hello();<br>    }</p>\n<p>JNI file:</p>\n<pre><code>#include&lt;jni.h&gt;\n#include&lt;stdio.h&gt;\n//#include &quot;TestJni.h&quot;\n#include&lt;iostream&gt;\nusing namespace std;\n void xprint(JNIEnv *env,jobject obj,jstring content)\n{  \n//    const jbyte *str=(const jbyte*)(env-&gt;GetStringUTFChars(env,content,JNI_FALSE));\n    //printf(&quot;hello--wo%s \\n&quot;,str);\n//    env-&gt;ReleaseStringUTFChars(env,content,(const char*)str);\n        cout&lt;&lt;&quot;here:&quot;&lt;&lt;content&lt;&lt;endl;\n    return;\n}\nstatic jstring  native_hello(JNIEnv *env,jobject object)\n{ \n\n\n    return (env)-&gt;NewStringUTF(&quot;keshixi&quot;);\n}\n\nstatic JNINativeMethod method_table[]={\n    { &quot;xprint&quot;,&quot;(Ljava/lang/String;)V&quot;,(void*)xprint},\n    {&quot;native_hello&quot;,&quot;()Ljava/lang/String;&quot;,(void*)native_hello}\n//    {,,(void*)xprint},{,,(void*)native_hello}\n};\n\n jint JNI_OnLoad(JavaVM *jvm,void *reserved){\n    JNIEnv *env;\n    if(jvm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6)!=JNI_OK){\n        return -1;\n    }\n    jclass clz=env-&gt;FindClass(&quot;TestJni&quot;);\n    if(clz==NULL)\n    {\n        return JNI_FALSE;\n    }\n    if(env-&gt;RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK){\n        return JNI_VERSION_1_6;\n    }\n  }\n</code></pre><p>####reference:<br>jni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行</p>\n<p>动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子</p>\n<p>另外可以作为ndk在android中使用及在android　stdio也可以直接生成so</p>\n<p>一些链接：android_jni_ndk:<a href=\"http://www.cnblogs.com/wzben/p/5733571.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/wzben/p/5733571.html</a><br>动态注册无运行实例：<a href=\"http://www.linuxidc.com/Linux/2017-02/140130.htm\" target=\"_blank\" rel=\"noopener\">http://www.linuxidc.com/Linux/2017-02/140130.htm</a><br>静态注册：<a href=\"http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br>动态注册：有实例<a href=\"http://www.linuxidc.com/Linux/2017-02/140129.htm\" target=\"_blank\" rel=\"noopener\">http://www.linuxidc.com/Linux/2017-02/140129.htm</a></p>\n<p><a href=\"http://www.fer.unizg.hr/_download/repository/jni.pdf文档\" target=\"_blank\" rel=\"noopener\">www.fer.unizg.hr/_download/repository/jni.pdf文档</a>    </p>"},{"title":"android_makefirst_app","date":"2018-05-20T09:38:24.000Z","_content":"###  install and make first app\n20170608\n今天主要是安装了android-studio环境并成功开发第一个helloworld   app 在模拟器和手机上运行，下面是整个教程：在ubuntu下\n#### 1 安装java-jdk:<!-- more -->\na  先下载java-jdk:Java SE Development Kit 8 Downloads\nhttp://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n下载对应系统的版本\n\nb  下载到某个目录，解压到要安装的目录：如：/usr/jdk-8/\n\nc   设置全局环境变量：如上述的安装目录，则将\nexport JAVA_HOME=/usr/jdk-8\nexport JRE_HOME=$JAVA_HOME/jre\nexport CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib\nexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\n添加到/etc/profile文件中，在末尾另起一行添加\n\nd 使用source /etc/profile命令使刚才配置的信息生效\n\ne 测试是否成功：java -version\n测试,编写java文件：\npublic class test{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"hello world\");\n\t}\n}\n保存为test.java，\n生成字节码：javac test.java\n运行:java test\n\n\n### 2 安装android-studio:\na 下载：在官网或者其他网站下载后\nb 按照installion说明进行：一般是先选择要安装的目录：如/usr/android-studio\nc　直接在终端,进入bin目录后:./studio.sh\nd 还有其他配置．比如在任意目录都能打开软件．\ne 其他见说明文件等\n\n\n3 第一个app helloworld\n在模拟器上运行\n打开软件－－>选择新建一个工程，适当选择之后->选择build->make project->点击run--\n-->会提示选择安装下载模拟器-->选择合适的，最好不要是带锁的\n－－－>之后会提示成功．再选择建立一个模拟器，之后就可以了\n\n注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm\n如果不能运行x86的，可能需要安装kvm:\n也可以使用genymotion模拟器\n#### 4 安装kvm可选\n要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？\n那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。\n首先要确定你的cpu满足要求，下面有几个命令可以参考：\n\n$ egrep -c '(vmx|svm)' /proc/cpuinfo\n4\n\n打印的值不为0即可。\n\n下面安装kvm：\n\n$ sudo apt-get install qemu-kvm\n$ sudo adduser linc kvm\n$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils\n$ sudo adduser linc libvirtd\n\n(linc为用户名，适当改）\n检验安装是否成功：\n\n$ sudo virsh -c qemu:///system list\n Id    Name                           State\n----------------------------------------------------\n\n运行，在有模拟器的目录中：\n如/home/ksx/Android/Sdk/emulator/emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm\n\n使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。\n\n\n如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。\n\n\n\n#### 5在手机上运行app\n首先连接手机，打开usb调试\n还是一样，但是选择app那里不是app,而是选择Edit Configurations\n之后选择usb　device，ok，就可以了，接着运行\n\n\n####  关于项目结构模式：\n默认为android\n设置为project可以看到整个完整的目录结构：\n　　　　　.gradle和.idea 为自动生成\n　　　　　app\n　　　　　build   编译时自动生成的文件，不用太关心\n　　　　　gradle   包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle\n     .gitignore\n     build.gradle\n     gradle.properties  全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本\n     gradlew　和gradlew.bat在命令行中执行gradle命令\n     local.properties　　指定本机android sdk路径\n     setting.gradle指定项目中引入的模块\n     \n     \n     app目录下\n     build　　为自动生成，同上\n     lib   项目使用的第三方库\n     test 测试用例\n     proguard-rules.pro  代码混淆规则\n\n#### build gradle intruduce\n\n\ngradle  Groovy 领域语言　　DSL    摒弃了Ant 和Maven \n\n在app 外有一个 build.gradle。在app中有一个build.gradle\n  \n在外面的　gradle 也可以构建c++等项目，\nbuildscript {\n    repositories {\n        jcenter()　　　//代码托管仓库　利用它可以轻松引用jcenter开源项目\n        \n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.3.2'　　//声明构建的是android\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n\napp中\napply plugin: 'com.android.application'　//表明为android 应用程序模块，为com.android.library表示库模块\n\nandroid {　　　//安卓闭包\n    compileSdkVersion 25　　　　//项目的编译版本，25为API 25,对应android 7.1\n    buildToolsVersion \"25.0.3\"   //项目构建工具版本\n    defaultConfig {\n        applicationId \"org.example.myactivity1\"　　　项目包名\n        minSdkVersion 25　　　　　//项目最低兼容的android系统版本\n        targetSdkVersion 25　　//表明如22表示只在22测试充分，如不启动运行时权限，android６　的运行时权限就不会加，表明只在5上做充分测试\n        versionCode 1　　　项目版本编号\n        versionName \"1.0\"　　　项目版本名\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {//分debug和release版本\n        release {\n            minifyEnabled false　//是否混淆代码\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件\n        }\n    }\n}\n\ndependencies {//分本地依赖，库依赖和远程依赖\n    compile fileTree(dir: 'libs', include: ['*.jar'])　　//本地依赖声明\n    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {\n        exclude group: 'com.android.support', module: 'support-annotations'\n    })\n    compile 'com.android.support:appcompat-v7:25.3.1'　　//　依赖库\n    compile 'com.android.support.constraint:constraint-layout:1.0.2'\n    testCompile 'junit:junit:4.12'　　//测试用例库\n}\n\n其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容\n\n","source":"_posts/android-makefirst-app.md","raw":"---\ntitle: android_makefirst_app\ndate: 2018-05-20 17:38:24\ntags: android_make \ncategories: android\n---\n###  install and make first app\n20170608\n今天主要是安装了android-studio环境并成功开发第一个helloworld   app 在模拟器和手机上运行，下面是整个教程：在ubuntu下\n#### 1 安装java-jdk:<!-- more -->\na  先下载java-jdk:Java SE Development Kit 8 Downloads\nhttp://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n下载对应系统的版本\n\nb  下载到某个目录，解压到要安装的目录：如：/usr/jdk-8/\n\nc   设置全局环境变量：如上述的安装目录，则将\nexport JAVA_HOME=/usr/jdk-8\nexport JRE_HOME=$JAVA_HOME/jre\nexport CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib\nexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\n添加到/etc/profile文件中，在末尾另起一行添加\n\nd 使用source /etc/profile命令使刚才配置的信息生效\n\ne 测试是否成功：java -version\n测试,编写java文件：\npublic class test{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"hello world\");\n\t}\n}\n保存为test.java，\n生成字节码：javac test.java\n运行:java test\n\n\n### 2 安装android-studio:\na 下载：在官网或者其他网站下载后\nb 按照installion说明进行：一般是先选择要安装的目录：如/usr/android-studio\nc　直接在终端,进入bin目录后:./studio.sh\nd 还有其他配置．比如在任意目录都能打开软件．\ne 其他见说明文件等\n\n\n3 第一个app helloworld\n在模拟器上运行\n打开软件－－>选择新建一个工程，适当选择之后->选择build->make project->点击run--\n-->会提示选择安装下载模拟器-->选择合适的，最好不要是带锁的\n－－－>之后会提示成功．再选择建立一个模拟器，之后就可以了\n\n注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm\n如果不能运行x86的，可能需要安装kvm:\n也可以使用genymotion模拟器\n#### 4 安装kvm可选\n要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？\n那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。\n首先要确定你的cpu满足要求，下面有几个命令可以参考：\n\n$ egrep -c '(vmx|svm)' /proc/cpuinfo\n4\n\n打印的值不为0即可。\n\n下面安装kvm：\n\n$ sudo apt-get install qemu-kvm\n$ sudo adduser linc kvm\n$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils\n$ sudo adduser linc libvirtd\n\n(linc为用户名，适当改）\n检验安装是否成功：\n\n$ sudo virsh -c qemu:///system list\n Id    Name                           State\n----------------------------------------------------\n\n运行，在有模拟器的目录中：\n如/home/ksx/Android/Sdk/emulator/emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm\n\n使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。\n\n\n如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。\n\n\n\n#### 5在手机上运行app\n首先连接手机，打开usb调试\n还是一样，但是选择app那里不是app,而是选择Edit Configurations\n之后选择usb　device，ok，就可以了，接着运行\n\n\n####  关于项目结构模式：\n默认为android\n设置为project可以看到整个完整的目录结构：\n　　　　　.gradle和.idea 为自动生成\n　　　　　app\n　　　　　build   编译时自动生成的文件，不用太关心\n　　　　　gradle   包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle\n     .gitignore\n     build.gradle\n     gradle.properties  全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本\n     gradlew　和gradlew.bat在命令行中执行gradle命令\n     local.properties　　指定本机android sdk路径\n     setting.gradle指定项目中引入的模块\n     \n     \n     app目录下\n     build　　为自动生成，同上\n     lib   项目使用的第三方库\n     test 测试用例\n     proguard-rules.pro  代码混淆规则\n\n#### build gradle intruduce\n\n\ngradle  Groovy 领域语言　　DSL    摒弃了Ant 和Maven \n\n在app 外有一个 build.gradle。在app中有一个build.gradle\n  \n在外面的　gradle 也可以构建c++等项目，\nbuildscript {\n    repositories {\n        jcenter()　　　//代码托管仓库　利用它可以轻松引用jcenter开源项目\n        \n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.3.2'　　//声明构建的是android\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n\napp中\napply plugin: 'com.android.application'　//表明为android 应用程序模块，为com.android.library表示库模块\n\nandroid {　　　//安卓闭包\n    compileSdkVersion 25　　　　//项目的编译版本，25为API 25,对应android 7.1\n    buildToolsVersion \"25.0.3\"   //项目构建工具版本\n    defaultConfig {\n        applicationId \"org.example.myactivity1\"　　　项目包名\n        minSdkVersion 25　　　　　//项目最低兼容的android系统版本\n        targetSdkVersion 25　　//表明如22表示只在22测试充分，如不启动运行时权限，android６　的运行时权限就不会加，表明只在5上做充分测试\n        versionCode 1　　　项目版本编号\n        versionName \"1.0\"　　　项目版本名\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {//分debug和release版本\n        release {\n            minifyEnabled false　//是否混淆代码\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件\n        }\n    }\n}\n\ndependencies {//分本地依赖，库依赖和远程依赖\n    compile fileTree(dir: 'libs', include: ['*.jar'])　　//本地依赖声明\n    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {\n        exclude group: 'com.android.support', module: 'support-annotations'\n    })\n    compile 'com.android.support:appcompat-v7:25.3.1'　　//　依赖库\n    compile 'com.android.support.constraint:constraint-layout:1.0.2'\n    testCompile 'junit:junit:4.12'　　//测试用例库\n}\n\n其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容\n\n","slug":"android-makefirst-app","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7n7000b2ujxhmoo426r","content":"<h3 id=\"install-and-make-first-app\"><a href=\"#install-and-make-first-app\" class=\"headerlink\" title=\"install and make first app\"></a>install and make first app</h3><p>20170608<br>今天主要是安装了android-studio环境并成功开发第一个helloworld   app 在模拟器和手机上运行，下面是整个教程：在ubuntu下</p>\n<h4 id=\"1-安装java-jdk\"><a href=\"#1-安装java-jdk\" class=\"headerlink\" title=\"1 安装java-jdk:\"></a>1 安装java-jdk:<a id=\"more\"></a></h4><p>a  先下载java-jdk:Java SE Development Kit 8 Downloads<br><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>下载对应系统的版本</p>\n<p>b  下载到某个目录，解压到要安装的目录：如：/usr/jdk-8/</p>\n<p>c   设置全局环境变量：如上述的安装目录，则将<br>export JAVA_HOME=/usr/jdk-8<br>export JRE_HOME=$JAVA_HOME/jre<br>export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib<br>export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin<br>添加到/etc/profile文件中，在末尾另起一行添加</p>\n<p>d 使用source /etc/profile命令使刚才配置的信息生效</p>\n<p>e 测试是否成功：java -version<br>测试,编写java文件：<br>public class test{<br>    public static void main(String[] args){<br>        System.out.println(“hello world”);<br>    }<br>}<br>保存为test.java，<br>生成字节码：javac test.java<br>运行:java test</p>\n<h3 id=\"2-安装android-studio\"><a href=\"#2-安装android-studio\" class=\"headerlink\" title=\"2 安装android-studio:\"></a>2 安装android-studio:</h3><p>a 下载：在官网或者其他网站下载后<br>b 按照installion说明进行：一般是先选择要安装的目录：如/usr/android-studio<br>c　直接在终端,进入bin目录后:./studio.sh<br>d 还有其他配置．比如在任意目录都能打开软件．<br>e 其他见说明文件等</p>\n<p>3 第一个app helloworld<br>在模拟器上运行<br>打开软件－－&gt;选择新建一个工程，适当选择之后-&gt;选择build-&gt;make project-&gt;点击run–<br>–&gt;会提示选择安装下载模拟器–&gt;选择合适的，最好不要是带锁的<br>－－－&gt;之后会提示成功．再选择建立一个模拟器，之后就可以了</p>\n<p>注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm<br>如果不能运行x86的，可能需要安装kvm:<br>也可以使用genymotion模拟器</p>\n<h4 id=\"4-安装kvm可选\"><a href=\"#4-安装kvm可选\" class=\"headerlink\" title=\"4 安装kvm可选\"></a>4 安装kvm可选</h4><p>要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？<br>那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。<br>首先要确定你的cpu满足要求，下面有几个命令可以参考：</p>\n<p>$ egrep -c ‘(vmx|svm)’ /proc/cpuinfo<br>4</p>\n<p>打印的值不为0即可。</p>\n<p>下面安装kvm：</p>\n<p>$ sudo apt-get install qemu-kvm<br>$ sudo adduser linc kvm<br>$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils<br>$ sudo adduser linc libvirtd</p>\n<p>(linc为用户名，适当改）<br>检验安装是否成功：</p>\n<p>$ sudo virsh -c qemu:///system list</p>\n<h2 id=\"Id-Name-State\"><a href=\"#Id-Name-State\" class=\"headerlink\" title=\" Id    Name                           State\"></a> Id    Name                           State</h2><p>运行，在有模拟器的目录中：<br>如/home/ksx/Android/Sdk/emulator/emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm</p>\n<p>使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。</p>\n<p>如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。</p>\n<h4 id=\"5在手机上运行app\"><a href=\"#5在手机上运行app\" class=\"headerlink\" title=\"5在手机上运行app\"></a>5在手机上运行app</h4><p>首先连接手机，打开usb调试<br>还是一样，但是选择app那里不是app,而是选择Edit Configurations<br>之后选择usb　device，ok，就可以了，接着运行</p>\n<h4 id=\"关于项目结构模式：\"><a href=\"#关于项目结构模式：\" class=\"headerlink\" title=\"关于项目结构模式：\"></a>关于项目结构模式：</h4><p>默认为android<br>设置为project可以看到整个完整的目录结构：<br>　　　　　.gradle和.idea 为自动生成<br>　　　　　app<br>　　　　　build   编译时自动生成的文件，不用太关心<br>　　　　　gradle   包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle<br>     .gitignore<br>     build.gradle<br>     gradle.properties  全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本<br>     gradlew　和gradlew.bat在命令行中执行gradle命令<br>     local.properties　　指定本机android sdk路径<br>     setting.gradle指定项目中引入的模块</p>\n<pre><code>app目录下\nbuild　　为自动生成，同上\nlib   项目使用的第三方库\ntest 测试用例\nproguard-rules.pro  代码混淆规则\n</code></pre><h4 id=\"build-gradle-intruduce\"><a href=\"#build-gradle-intruduce\" class=\"headerlink\" title=\"build gradle intruduce\"></a>build gradle intruduce</h4><p>gradle  Groovy 领域语言　　DSL    摒弃了Ant 和Maven </p>\n<p>在app 外有一个 build.gradle。在app中有一个build.gradle</p>\n<p>在外面的　gradle 也可以构建c++等项目，<br>buildscript {<br>    repositories {<br>        jcenter()　　　//代码托管仓库　利用它可以轻松引用jcenter开源项目</p>\n<pre><code>}\ndependencies {\n    classpath &apos;com.android.tools.build:gradle:2.3.2&apos;　　//声明构建的是android\n\n    // NOTE: Do not place your application dependencies here; they belong\n    // in the individual module build.gradle files\n}\n</code></pre><p>}</p>\n<p>allprojects {<br>    repositories {<br>        jcenter()<br>    }<br>}</p>\n<p>task clean(type: Delete) {<br>    delete rootProject.buildDir<br>}</p>\n<p>app中<br>apply plugin: ‘com.android.application’　//表明为android 应用程序模块，为com.android.library表示库模块</p>\n<p>android {　　　//安卓闭包<br>    compileSdkVersion 25　　　　//项目的编译版本，25为API 25,对应android 7.1<br>    buildToolsVersion “25.0.3”   //项目构建工具版本<br>    defaultConfig {<br>        applicationId “org.example.myactivity1”　　　项目包名<br>        minSdkVersion 25　　　　　//项目最低兼容的android系统版本<br>        targetSdkVersion 25　　//表明如22表示只在22测试充分，如不启动运行时权限，android６　的运行时权限就不会加，表明只在5上做充分测试<br>        versionCode 1　　　项目版本编号<br>        versionName “1.0”　　　项目版本名<br>        testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner”<br>    }<br>    buildTypes {//分debug和release版本<br>        release {<br>            minifyEnabled false　//是否混淆代码<br>            proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’//混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件<br>        }<br>    }<br>}</p>\n<p>dependencies {//分本地依赖，库依赖和远程依赖<br>    compile fileTree(dir: ‘libs’, include: [‘*.jar’])　　//本地依赖声明<br>    androidTestCompile(‘com.android.support.test.espresso:espresso-core:2.2.2’, {<br>        exclude group: ‘com.android.support’, module: ‘support-annotations’<br>    })<br>    compile ‘com.android.support:appcompat-v7:25.3.1’　　//　依赖库<br>    compile ‘com.android.support.constraint:constraint-layout:1.0.2’<br>    testCompile ‘junit:junit:4.12’　　//测试用例库<br>}</p>\n<p>其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"install-and-make-first-app\"><a href=\"#install-and-make-first-app\" class=\"headerlink\" title=\"install and make first app\"></a>install and make first app</h3><p>20170608<br>今天主要是安装了android-studio环境并成功开发第一个helloworld   app 在模拟器和手机上运行，下面是整个教程：在ubuntu下</p>\n<h4 id=\"1-安装java-jdk\"><a href=\"#1-安装java-jdk\" class=\"headerlink\" title=\"1 安装java-jdk:\"></a>1 安装java-jdk:","more":"</h4><p>a  先下载java-jdk:Java SE Development Kit 8 Downloads<br><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>下载对应系统的版本</p>\n<p>b  下载到某个目录，解压到要安装的目录：如：/usr/jdk-8/</p>\n<p>c   设置全局环境变量：如上述的安装目录，则将<br>export JAVA_HOME=/usr/jdk-8<br>export JRE_HOME=$JAVA_HOME/jre<br>export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib<br>export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin<br>添加到/etc/profile文件中，在末尾另起一行添加</p>\n<p>d 使用source /etc/profile命令使刚才配置的信息生效</p>\n<p>e 测试是否成功：java -version<br>测试,编写java文件：<br>public class test{<br>    public static void main(String[] args){<br>        System.out.println(“hello world”);<br>    }<br>}<br>保存为test.java，<br>生成字节码：javac test.java<br>运行:java test</p>\n<h3 id=\"2-安装android-studio\"><a href=\"#2-安装android-studio\" class=\"headerlink\" title=\"2 安装android-studio:\"></a>2 安装android-studio:</h3><p>a 下载：在官网或者其他网站下载后<br>b 按照installion说明进行：一般是先选择要安装的目录：如/usr/android-studio<br>c　直接在终端,进入bin目录后:./studio.sh<br>d 还有其他配置．比如在任意目录都能打开软件．<br>e 其他见说明文件等</p>\n<p>3 第一个app helloworld<br>在模拟器上运行<br>打开软件－－&gt;选择新建一个工程，适当选择之后-&gt;选择build-&gt;make project-&gt;点击run–<br>–&gt;会提示选择安装下载模拟器–&gt;选择合适的，最好不要是带锁的<br>－－－&gt;之后会提示成功．再选择建立一个模拟器，之后就可以了</p>\n<p>注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm<br>如果不能运行x86的，可能需要安装kvm:<br>也可以使用genymotion模拟器</p>\n<h4 id=\"4-安装kvm可选\"><a href=\"#4-安装kvm可选\" class=\"headerlink\" title=\"4 安装kvm可选\"></a>4 安装kvm可选</h4><p>要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？<br>那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。<br>首先要确定你的cpu满足要求，下面有几个命令可以参考：</p>\n<p>$ egrep -c ‘(vmx|svm)’ /proc/cpuinfo<br>4</p>\n<p>打印的值不为0即可。</p>\n<p>下面安装kvm：</p>\n<p>$ sudo apt-get install qemu-kvm<br>$ sudo adduser linc kvm<br>$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils<br>$ sudo adduser linc libvirtd</p>\n<p>(linc为用户名，适当改）<br>检验安装是否成功：</p>\n<p>$ sudo virsh -c qemu:///system list</p>\n<h2 id=\"Id-Name-State\"><a href=\"#Id-Name-State\" class=\"headerlink\" title=\" Id    Name                           State\"></a> Id    Name                           State</h2><p>运行，在有模拟器的目录中：<br>如/home/ksx/Android/Sdk/emulator/emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm</p>\n<p>使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。</p>\n<p>如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。</p>\n<h4 id=\"5在手机上运行app\"><a href=\"#5在手机上运行app\" class=\"headerlink\" title=\"5在手机上运行app\"></a>5在手机上运行app</h4><p>首先连接手机，打开usb调试<br>还是一样，但是选择app那里不是app,而是选择Edit Configurations<br>之后选择usb　device，ok，就可以了，接着运行</p>\n<h4 id=\"关于项目结构模式：\"><a href=\"#关于项目结构模式：\" class=\"headerlink\" title=\"关于项目结构模式：\"></a>关于项目结构模式：</h4><p>默认为android<br>设置为project可以看到整个完整的目录结构：<br>　　　　　.gradle和.idea 为自动生成<br>　　　　　app<br>　　　　　build   编译时自动生成的文件，不用太关心<br>　　　　　gradle   包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle<br>     .gitignore<br>     build.gradle<br>     gradle.properties  全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本<br>     gradlew　和gradlew.bat在命令行中执行gradle命令<br>     local.properties　　指定本机android sdk路径<br>     setting.gradle指定项目中引入的模块</p>\n<pre><code>app目录下\nbuild　　为自动生成，同上\nlib   项目使用的第三方库\ntest 测试用例\nproguard-rules.pro  代码混淆规则\n</code></pre><h4 id=\"build-gradle-intruduce\"><a href=\"#build-gradle-intruduce\" class=\"headerlink\" title=\"build gradle intruduce\"></a>build gradle intruduce</h4><p>gradle  Groovy 领域语言　　DSL    摒弃了Ant 和Maven </p>\n<p>在app 外有一个 build.gradle。在app中有一个build.gradle</p>\n<p>在外面的　gradle 也可以构建c++等项目，<br>buildscript {<br>    repositories {<br>        jcenter()　　　//代码托管仓库　利用它可以轻松引用jcenter开源项目</p>\n<pre><code>}\ndependencies {\n    classpath &apos;com.android.tools.build:gradle:2.3.2&apos;　　//声明构建的是android\n\n    // NOTE: Do not place your application dependencies here; they belong\n    // in the individual module build.gradle files\n}\n</code></pre><p>}</p>\n<p>allprojects {<br>    repositories {<br>        jcenter()<br>    }<br>}</p>\n<p>task clean(type: Delete) {<br>    delete rootProject.buildDir<br>}</p>\n<p>app中<br>apply plugin: ‘com.android.application’　//表明为android 应用程序模块，为com.android.library表示库模块</p>\n<p>android {　　　//安卓闭包<br>    compileSdkVersion 25　　　　//项目的编译版本，25为API 25,对应android 7.1<br>    buildToolsVersion “25.0.3”   //项目构建工具版本<br>    defaultConfig {<br>        applicationId “org.example.myactivity1”　　　项目包名<br>        minSdkVersion 25　　　　　//项目最低兼容的android系统版本<br>        targetSdkVersion 25　　//表明如22表示只在22测试充分，如不启动运行时权限，android６　的运行时权限就不会加，表明只在5上做充分测试<br>        versionCode 1　　　项目版本编号<br>        versionName “1.0”　　　项目版本名<br>        testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner”<br>    }<br>    buildTypes {//分debug和release版本<br>        release {<br>            minifyEnabled false　//是否混淆代码<br>            proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’//混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件<br>        }<br>    }<br>}</p>\n<p>dependencies {//分本地依赖，库依赖和远程依赖<br>    compile fileTree(dir: ‘libs’, include: [‘*.jar’])　　//本地依赖声明<br>    androidTestCompile(‘com.android.support.test.espresso:espresso-core:2.2.2’, {<br>        exclude group: ‘com.android.support’, module: ‘support-annotations’<br>    })<br>    compile ‘com.android.support:appcompat-v7:25.3.1’　　//　依赖库<br>    compile ‘com.android.support.constraint:constraint-layout:1.0.2’<br>    testCompile ‘junit:junit:4.12’　　//测试用例库<br>}</p>\n<p>其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容</p>"},{"title":"android_will_write","date":"2018-05-20T08:58:26.000Z","_content":"#test categories\nthis is the android categories to test ","source":"_posts/android-will-write.md","raw":"---\ntitle: android_will_write\ndate: 2018-05-20 16:58:26\ntags: android_activity\ncategories: android\n---\n#test categories\nthis is the android categories to test ","slug":"android-will-write","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7nb000g2ujxl1nal3kz","content":"<p>#test categories<br>this is the android categories to test </p>\n","site":{"data":{}},"excerpt":"","more":"<p>#test categories<br>this is the android categories to test </p>\n"},{"title":"code_efficandreadable","date":"2018-05-26T04:44:19.000Z","_content":"##  论代码的效率和可读性的权衡\n#### 高效代码可读性差：  \n有一些代码，占用额外内存小，即run in place，且执行的速度快，即复杂度O()低，但是可读性差，即使注释了，修改起来也容易出错，如：  \n对链表的操作：举一个leetcode的例子：(这个例子不是很典型，能说明问题即可）  \n    reverse a linklist from m to n;   \n    1->3->4->5->null and m,n(ex:2,4);  \n    return 1->5->4->2->null;\n   上面例子一开始可以想到，头插法，或者将范围内的那一段用新的处理过的链表替换掉，即只需要处理该片段的头和尾部，当然可能还有其他方法，这里先不考虑；  \n   于是，头插法不是很复杂，但是在这里不用额外的内存时，需要频繁的改变next指针和对pre元素做临时保存，使得代码可读性差，所以可以考虑以下方案：\n   在替换的内存小时，可以采用后者，让代码可读性高些，方便维护和（被替代~更容易被炒鱿鱼的风险哈哈)\n   在内存小时，采用前者，爱怎么指怎么指，看不懂不管哈哈哈\n\n","source":"_posts/code-efficandreadable.md","raw":"---\ntitle: code_efficandreadable\ndate: 2018-05-26 12:44:19\ntags: 代码可读性\ncategories: 代码整洁\n---\n##  论代码的效率和可读性的权衡\n#### 高效代码可读性差：  \n有一些代码，占用额外内存小，即run in place，且执行的速度快，即复杂度O()低，但是可读性差，即使注释了，修改起来也容易出错，如：  \n对链表的操作：举一个leetcode的例子：(这个例子不是很典型，能说明问题即可）  \n    reverse a linklist from m to n;   \n    1->3->4->5->null and m,n(ex:2,4);  \n    return 1->5->4->2->null;\n   上面例子一开始可以想到，头插法，或者将范围内的那一段用新的处理过的链表替换掉，即只需要处理该片段的头和尾部，当然可能还有其他方法，这里先不考虑；  \n   于是，头插法不是很复杂，但是在这里不用额外的内存时，需要频繁的改变next指针和对pre元素做临时保存，使得代码可读性差，所以可以考虑以下方案：\n   在替换的内存小时，可以采用后者，让代码可读性高些，方便维护和（被替代~更容易被炒鱿鱼的风险哈哈)\n   在内存小时，采用前者，爱怎么指怎么指，看不懂不管哈哈哈\n\n","slug":"code-efficandreadable","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7ne000h2ujxwhlz3vpj","content":"<h2 id=\"论代码的效率和可读性的权衡\"><a href=\"#论代码的效率和可读性的权衡\" class=\"headerlink\" title=\"论代码的效率和可读性的权衡\"></a>论代码的效率和可读性的权衡</h2><h4 id=\"高效代码可读性差：\"><a href=\"#高效代码可读性差：\" class=\"headerlink\" title=\"高效代码可读性差：\"></a>高效代码可读性差：</h4><p>有一些代码，占用额外内存小，即run in place，且执行的速度快，即复杂度O()低，但是可读性差，即使注释了，修改起来也容易出错，如：<br>对链表的操作：举一个leetcode的例子：(这个例子不是很典型，能说明问题即可）<br>    reverse a linklist from m to n;<br>    1-&gt;3-&gt;4-&gt;5-&gt;null and m,n(ex:2,4);<br>    return 1-&gt;5-&gt;4-&gt;2-&gt;null;<br>   上面例子一开始可以想到，头插法，或者将范围内的那一段用新的处理过的链表替换掉，即只需要处理该片段的头和尾部，当然可能还有其他方法，这里先不考虑；<br>   于是，头插法不是很复杂，但是在这里不用额外的内存时，需要频繁的改变next指针和对pre元素做临时保存，使得代码可读性差，所以可以考虑以下方案：<br>   在替换的内存小时，可以采用后者，让代码可读性高些，方便维护和（被替代~更容易被炒鱿鱼的风险哈哈)<br>   在内存小时，采用前者，爱怎么指怎么指，看不懂不管哈哈哈</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"论代码的效率和可读性的权衡\"><a href=\"#论代码的效率和可读性的权衡\" class=\"headerlink\" title=\"论代码的效率和可读性的权衡\"></a>论代码的效率和可读性的权衡</h2><h4 id=\"高效代码可读性差：\"><a href=\"#高效代码可读性差：\" class=\"headerlink\" title=\"高效代码可读性差：\"></a>高效代码可读性差：</h4><p>有一些代码，占用额外内存小，即run in place，且执行的速度快，即复杂度O()低，但是可读性差，即使注释了，修改起来也容易出错，如：<br>对链表的操作：举一个leetcode的例子：(这个例子不是很典型，能说明问题即可）<br>    reverse a linklist from m to n;<br>    1-&gt;3-&gt;4-&gt;5-&gt;null and m,n(ex:2,4);<br>    return 1-&gt;5-&gt;4-&gt;2-&gt;null;<br>   上面例子一开始可以想到，头插法，或者将范围内的那一段用新的处理过的链表替换掉，即只需要处理该片段的头和尾部，当然可能还有其他方法，这里先不考虑；<br>   于是，头插法不是很复杂，但是在这里不用额外的内存时，需要频繁的改变next指针和对pre元素做临时保存，使得代码可读性差，所以可以考虑以下方案：<br>   在替换的内存小时，可以采用后者，让代码可读性高些，方便维护和（被替代~更容易被炒鱿鱼的风险哈哈)<br>   在内存小时，采用前者，爱怎么指怎么指，看不懂不管哈哈哈</p>\n"},{"title":"cpp_class_memory","date":"2018-06-09T02:44:41.000Z","_content":"### c++类内存布局：\n#### 静态\n下编译后的“内存布局”，此时还未分配内存，不能算是内存，只能说是文件布局<!--more-->\n+ two question:  \n 多少内存能表现一个ob:?  \n 多少内存能表现一个class?--编译期，如　int 大小为４ \n+ 静态下，编译后同C一样分为代码段等；而类的特性有些类似于struct,定义类的文件中包含了成员变量，成员函数。\n+ 类：\n        非静态成员变量：存于对象中\n        vptr指针：存于对象中\n        vt表:vptr指向这个表，这个表在构造函数中默认隐士初始化，将对应的虚拟函数地址赋给表中的各个值（表本身with\"类\"）\n        obj:         class:\n        _vptr --->   table: ptr1 -->virtual func1\n                            ptr2 -->virtual func2\n        静态变量: 存入数据段中\n        成员函数:代码段,通过this和成员变量建立联系\n        静态函数：　存于代码段中\n        全局函数\n        main函数\n        全局变量和静态变量\n        局部变量：栈\n        something extra depend on compiler~\n+ some rules\n   + 每个类产生一堆指向virtual func的指针，放在表格中，表称为：vtbl;   \n   + 每个obj被添加了一个指针，指向相关的tirtual table ,为vptr;\n   +   vptr的设定和重置由constructor，destructor,copy assignment运算服自动完成）　\n   + 注意每一个class所关联的type info object(用于支持runtime type identification  )也经由virtual table指出，放在vptr[0]处）\n   +  虚函数有可能被转换为：(*px->vtbl[1])(px)\n          具体见深入c++模型书\n              \n#### 多少内存能表现一个ob:?\n+ non static data members\n+ padding\n+ virtual---vptr\n#### 多少内存能表现一个class? \n见datamember_memory  \n```cpp\n最小是１　  size  \nclass T{ };   ---1 一个char 表示这个类型  \nclass X :public virtual T{};　　--指针大小，指针指向T    virtual base class subobject  \nclass Y :public virtual T{};  --指针大小\nclass A:public X,public Y {};　--两个指针大小　　```\nmore seee datamember_memory\n\n\n#### 运行时\n的内存布局，即作为进程运行时，其内存是如何的；\n\n+ 运行时，涉及类的对象模型，对象的内存部分只包含非静态成员变量和虚拟函数指针表；\n+ 可以通过gdb 或kgdb进行查看类对象的地址或者类函数的地址：\n ```cpp\n\tCircle c12;\n\t\tCircle c1(1.2,\"red\");\nprintf(\"getRadius:%x\\n\",&Circle::getRadius);\nprintf(\"%x, %x\\n\",&c12,c12);\n void *cc;\n        cc=(Circle*)(&c12);\n\t\tcout<<*((double*)cc)<<endl;\n```\t\t\n    \t\t\n所以c++的对象带来的开销在于操作多态时的vptr等效率低）\t\t\n\n一个例子\n```cpp\n#include<iostream>\nusing namespace std;\nclass A\n{\n\t\tpublic:\n\t\t\t\t    virtual const char* getName() { return \"A\"; }\n\t\t\t\t\tvirtual int getage(){ return 3;}\n};\n \nclass B: public A\n{\n\t\tpublic:\n\t\t\t\t    virtual const char* getName() { return \"B\"; }\n\t\t\t\t\tvirtual int getage(){return 5;}\n};\n \nclass C: public B\n{\n\t\tpublic:\n\t\t\t\t    const char* getName() { return \"C\"; }\n\t\t\t\t\tint getage(){return 6;}\n};\n \nclass D: public C\n{\n\t\tpublic:\n\t\t\t\t    virtual const char* getName() { return \"D\"; }\n0x400ae8 push   %rbp\n0x400ae9 mov    %rsp,%rbp\n0x400aec mov    %rdi,-0x8(%rbp)\n\t\t\t\t\tint getage() {return 8;}\n0x400af8 push   %rbp\n0x400af9 mov    %rsp,%rbp\n0x400afc mov    %rdi,-0x8(%rbp)\n};\n \nint main()\n{ \n\t\t    A aa;\n\t\t\taa.getName();\n\t\t    D d;\n\t\t\td.getName();\n\t\t\tA &rBase = d;\n\t\t\trBase.getName();\n0x400986 mov    -0x28(%rbp),%rax\n0x40098a mov    (%rax),%rax\n0x40098d mov    (%rax),%rax\n0x400990 mov    -0x28(%rbp),%rdx\n0x400994 mov    %rdx,%rdi\n0x400997 callq  *%rax\n            rBase.getage();\n0x400999 mov    -0x28(%rbp),%rax\n0x40099d mov    (%rax),%rax\n0x4009a0 add    $0x8,%rax\n0x4009a4 mov    (%rax),%rax\n0x4009a7 mov    -0x28(%rbp),%rdx\n0x4009ab mov    %rdx,%rdi\n0x4009ae callq  *%rax\n\t\t    std::cout << \"rBase is a \" << rBase.getName() << '\\n';\n\t\t\t\t\t \n\t\t\tD d2;\n            A &rBase2 =d2;\n0x4009f9 lea    -0x30(%rbp),%rax\n0x4009fd mov    %rax,-0x20(%rbp)\n\t\t   rBase2.getName();\t\n0x400a01 mov    -0x20(%rbp),%rax\n0x400a05 mov    (%rax),%rax\n0x400a08 mov    (%rax),%rax\n0x400a0b mov    -0x20(%rbp),%rdx\n0x400a0f mov    %rdx,%rdi\n0x400a12 callq  *%rax\n\n\n\t\t    return 0;\n}\t\t\n```\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\nsomething else:  \n+ 成员函数也是只有一份被存于代码区中，而对象并没有指向成员函数的指针，对象只存成员和虚拟表　；那在对象.成员函数使用时，\n+ 是如何确定该函数中使用的成员是该对象的成员?\n这里是this指针的作用\n从汇编看，是否是成员函数在取的成员变量时，会做一些动作，这时的成员变量是在栈区；；\n或者从调用成员函数时，是否有传入或控制函数的一些动作，让它知道从哪里取得对应的成员返回；\n+ 成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁\n\n","source":"_posts/cpp-class-memory.md","raw":"---\ntitle: cpp_class_memory\ndate: 2018-06-09 10:44:41\ntags: cpp_memory\ncategories: c&cpp\n---\n### c++类内存布局：\n#### 静态\n下编译后的“内存布局”，此时还未分配内存，不能算是内存，只能说是文件布局<!--more-->\n+ two question:  \n 多少内存能表现一个ob:?  \n 多少内存能表现一个class?--编译期，如　int 大小为４ \n+ 静态下，编译后同C一样分为代码段等；而类的特性有些类似于struct,定义类的文件中包含了成员变量，成员函数。\n+ 类：\n        非静态成员变量：存于对象中\n        vptr指针：存于对象中\n        vt表:vptr指向这个表，这个表在构造函数中默认隐士初始化，将对应的虚拟函数地址赋给表中的各个值（表本身with\"类\"）\n        obj:         class:\n        _vptr --->   table: ptr1 -->virtual func1\n                            ptr2 -->virtual func2\n        静态变量: 存入数据段中\n        成员函数:代码段,通过this和成员变量建立联系\n        静态函数：　存于代码段中\n        全局函数\n        main函数\n        全局变量和静态变量\n        局部变量：栈\n        something extra depend on compiler~\n+ some rules\n   + 每个类产生一堆指向virtual func的指针，放在表格中，表称为：vtbl;   \n   + 每个obj被添加了一个指针，指向相关的tirtual table ,为vptr;\n   +   vptr的设定和重置由constructor，destructor,copy assignment运算服自动完成）　\n   + 注意每一个class所关联的type info object(用于支持runtime type identification  )也经由virtual table指出，放在vptr[0]处）\n   +  虚函数有可能被转换为：(*px->vtbl[1])(px)\n          具体见深入c++模型书\n              \n#### 多少内存能表现一个ob:?\n+ non static data members\n+ padding\n+ virtual---vptr\n#### 多少内存能表现一个class? \n见datamember_memory  \n```cpp\n最小是１　  size  \nclass T{ };   ---1 一个char 表示这个类型  \nclass X :public virtual T{};　　--指针大小，指针指向T    virtual base class subobject  \nclass Y :public virtual T{};  --指针大小\nclass A:public X,public Y {};　--两个指针大小　　```\nmore seee datamember_memory\n\n\n#### 运行时\n的内存布局，即作为进程运行时，其内存是如何的；\n\n+ 运行时，涉及类的对象模型，对象的内存部分只包含非静态成员变量和虚拟函数指针表；\n+ 可以通过gdb 或kgdb进行查看类对象的地址或者类函数的地址：\n ```cpp\n\tCircle c12;\n\t\tCircle c1(1.2,\"red\");\nprintf(\"getRadius:%x\\n\",&Circle::getRadius);\nprintf(\"%x, %x\\n\",&c12,c12);\n void *cc;\n        cc=(Circle*)(&c12);\n\t\tcout<<*((double*)cc)<<endl;\n```\t\t\n    \t\t\n所以c++的对象带来的开销在于操作多态时的vptr等效率低）\t\t\n\n一个例子\n```cpp\n#include<iostream>\nusing namespace std;\nclass A\n{\n\t\tpublic:\n\t\t\t\t    virtual const char* getName() { return \"A\"; }\n\t\t\t\t\tvirtual int getage(){ return 3;}\n};\n \nclass B: public A\n{\n\t\tpublic:\n\t\t\t\t    virtual const char* getName() { return \"B\"; }\n\t\t\t\t\tvirtual int getage(){return 5;}\n};\n \nclass C: public B\n{\n\t\tpublic:\n\t\t\t\t    const char* getName() { return \"C\"; }\n\t\t\t\t\tint getage(){return 6;}\n};\n \nclass D: public C\n{\n\t\tpublic:\n\t\t\t\t    virtual const char* getName() { return \"D\"; }\n0x400ae8 push   %rbp\n0x400ae9 mov    %rsp,%rbp\n0x400aec mov    %rdi,-0x8(%rbp)\n\t\t\t\t\tint getage() {return 8;}\n0x400af8 push   %rbp\n0x400af9 mov    %rsp,%rbp\n0x400afc mov    %rdi,-0x8(%rbp)\n};\n \nint main()\n{ \n\t\t    A aa;\n\t\t\taa.getName();\n\t\t    D d;\n\t\t\td.getName();\n\t\t\tA &rBase = d;\n\t\t\trBase.getName();\n0x400986 mov    -0x28(%rbp),%rax\n0x40098a mov    (%rax),%rax\n0x40098d mov    (%rax),%rax\n0x400990 mov    -0x28(%rbp),%rdx\n0x400994 mov    %rdx,%rdi\n0x400997 callq  *%rax\n            rBase.getage();\n0x400999 mov    -0x28(%rbp),%rax\n0x40099d mov    (%rax),%rax\n0x4009a0 add    $0x8,%rax\n0x4009a4 mov    (%rax),%rax\n0x4009a7 mov    -0x28(%rbp),%rdx\n0x4009ab mov    %rdx,%rdi\n0x4009ae callq  *%rax\n\t\t    std::cout << \"rBase is a \" << rBase.getName() << '\\n';\n\t\t\t\t\t \n\t\t\tD d2;\n            A &rBase2 =d2;\n0x4009f9 lea    -0x30(%rbp),%rax\n0x4009fd mov    %rax,-0x20(%rbp)\n\t\t   rBase2.getName();\t\n0x400a01 mov    -0x20(%rbp),%rax\n0x400a05 mov    (%rax),%rax\n0x400a08 mov    (%rax),%rax\n0x400a0b mov    -0x20(%rbp),%rdx\n0x400a0f mov    %rdx,%rdi\n0x400a12 callq  *%rax\n\n\n\t\t    return 0;\n}\t\t\n```\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\nsomething else:  \n+ 成员函数也是只有一份被存于代码区中，而对象并没有指向成员函数的指针，对象只存成员和虚拟表　；那在对象.成员函数使用时，\n+ 是如何确定该函数中使用的成员是该对象的成员?\n这里是this指针的作用\n从汇编看，是否是成员函数在取的成员变量时，会做一些动作，这时的成员变量是在栈区；；\n或者从调用成员函数时，是否有传入或控制函数的一些动作，让它知道从哪里取得对应的成员返回；\n+ 成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁\n\n","slug":"cpp-class-memory","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7ni000l2ujxoyoqrh80","content":"<h3 id=\"c-类内存布局：\"><a href=\"#c-类内存布局：\" class=\"headerlink\" title=\"c++类内存布局：\"></a>c++类内存布局：</h3><h4 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h4><p>下编译后的“内存布局”，此时还未分配内存，不能算是内存，只能说是文件布局<a id=\"more\"></a></p>\n<ul>\n<li>two question:<br>多少内存能表现一个ob:?<br>多少内存能表现一个class?–编译期，如　int 大小为４ </li>\n<li>静态下，编译后同C一样分为代码段等；而类的特性有些类似于struct,定义类的文件中包含了成员变量，成员函数。</li>\n<li>类：<pre><code>非静态成员变量：存于对象中\nvptr指针：存于对象中\nvt表:vptr指向这个表，这个表在构造函数中默认隐士初始化，将对应的虚拟函数地址赋给表中的各个值（表本身with&quot;类&quot;）\nobj:         class:\n_vptr ---&gt;   table: ptr1 --&gt;virtual func1\n                    ptr2 --&gt;virtual func2\n静态变量: 存入数据段中\n成员函数:代码段,通过this和成员变量建立联系\n静态函数：　存于代码段中\n全局函数\nmain函数\n全局变量和静态变量\n局部变量：栈\nsomething extra depend on compiler~\n</code></pre></li>\n<li>some rules<ul>\n<li>每个类产生一堆指向virtual func的指针，放在表格中，表称为：vtbl;   </li>\n<li>每个obj被添加了一个指针，指向相关的tirtual table ,为vptr;</li>\n<li>vptr的设定和重置由constructor，destructor,copy assignment运算服自动完成）　</li>\n<li>注意每一个class所关联的type info object(用于支持runtime type identification  )也经由virtual table指出，放在vptr[0]处）</li>\n<li>虚函数有可能被转换为：(*px-&gt;vtbl[1])(px)<pre><code>具体见深入c++模型书\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"多少内存能表现一个ob\"><a href=\"#多少内存能表现一个ob\" class=\"headerlink\" title=\"多少内存能表现一个ob:?\"></a>多少内存能表现一个ob:?</h4><ul>\n<li>non static data members</li>\n<li>padding</li>\n<li>virtual—vptr<h4 id=\"多少内存能表现一个class\"><a href=\"#多少内存能表现一个class\" class=\"headerlink\" title=\"多少内存能表现一个class?\"></a>多少内存能表现一个class?</h4>见datamember_memory  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最小是１　  size  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&#123;</span> &#125;;   --<span class=\"number\">-1</span> 一个<span class=\"keyword\">char</span> 表示这个类型  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> :</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> T&#123;&#125;;　　--指针大小，指针指向T    <span class=\"keyword\">virtual</span> base <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">subobject</span>  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Y</span> :</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> T&#123;&#125;;  --指针大小</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span><span class=\"keyword\">public</span> X,<span class=\"keyword\">public</span> Y &#123;&#125;;　--两个指针大小</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>more seee datamember_memory</p>\n<h4 id=\"运行时\"><a href=\"#运行时\" class=\"headerlink\" title=\"运行时\"></a>运行时</h4><p>的内存布局，即作为进程运行时，其内存是如何的；</p>\n<ul>\n<li>运行时，涉及类的对象模型，对象的内存部分只包含非静态成员变量和虚拟函数指针表；</li>\n<li>可以通过gdb 或kgdb进行查看类对象的地址或者类函数的地址：<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tCircle c12;</span><br><span class=\"line\">\t\t<span class=\"function\">Circle <span class=\"title\">c1</span><span class=\"params\">(<span class=\"number\">1.2</span>,<span class=\"string\">\"red\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"getRadius:%x\\n\"</span>,&amp;Circle::getRadius);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%x, %x\\n\"</span>,&amp;c12,c12);</span><br><span class=\"line\"> <span class=\"keyword\">void</span> *cc;</span><br><span class=\"line\">        cc=(Circle*)(&amp;c12);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;*((<span class=\"keyword\">double</span>*)cc)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">```\t\t</span><br><span class=\"line\">    \t\t</span><br><span class=\"line\">所以c++的对象带来的开销在于操作多态时的vptr等效率低）\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">一个例子</span><br><span class=\"line\">```cpp</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">getage</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">3</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">getage</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">5</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>:</span> <span class=\"keyword\">public</span> B</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>; &#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getage</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">6</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span> <span class=\"keyword\">public</span> C</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"D\"</span>; &#125;</span><br><span class=\"line\"><span class=\"number\">0x400ae8</span> push   %rbp</span><br><span class=\"line\"><span class=\"number\">0x400ae9</span> mov    %rsp,%rbp</span><br><span class=\"line\"><span class=\"number\">0x400aec</span> mov    %rdi,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getage</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">8</span>;&#125;</span><br><span class=\"line\"><span class=\"number\">0x400af8</span> push   %rbp</span><br><span class=\"line\"><span class=\"number\">0x400af9</span> mov    %rsp,%rbp</span><br><span class=\"line\"><span class=\"number\">0x400afc</span> mov    %rdi,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">\t\t    A aa;</span><br><span class=\"line\">\t\t\taa.getName();</span><br><span class=\"line\">\t\t    D d;</span><br><span class=\"line\">\t\t\td.getName();</span><br><span class=\"line\">\t\t\tA &amp;rBase = d;</span><br><span class=\"line\">\t\t\trBase.getName();</span><br><span class=\"line\"><span class=\"number\">0x400986</span> mov    <span class=\"number\">-0x28</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x40098a</span> mov    (%rax),%rax</span><br><span class=\"line\"><span class=\"number\">0x40098d</span> mov    (%rax),%rax</span><br><span class=\"line\"><span class=\"number\">0x400990</span> mov    <span class=\"number\">-0x28</span>(%rbp),%rdx</span><br><span class=\"line\"><span class=\"number\">0x400994</span> mov    %rdx,%rdi</span><br><span class=\"line\"><span class=\"number\">0x400997</span> callq  *%rax</span><br><span class=\"line\">            rBase.getage();</span><br><span class=\"line\"><span class=\"number\">0x400999</span> mov    <span class=\"number\">-0x28</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x40099d</span> mov    (%rax),%rax</span><br><span class=\"line\"><span class=\"number\">0x4009a0</span> add    $<span class=\"number\">0x8</span>,%rax</span><br><span class=\"line\"><span class=\"number\">0x4009a4</span> mov    (%rax),%rax</span><br><span class=\"line\"><span class=\"number\">0x4009a7</span> mov    <span class=\"number\">-0x28</span>(%rbp),%rdx</span><br><span class=\"line\"><span class=\"number\">0x4009ab</span> mov    %rdx,%rdi</span><br><span class=\"line\"><span class=\"number\">0x4009ae</span> callq  *%rax</span><br><span class=\"line\">\t\t    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"rBase is a \"</span> &lt;&lt; rBase.getName() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">\t\t\t\t\t </span><br><span class=\"line\">\t\t\tD d2;</span><br><span class=\"line\">            A &amp;rBase2 =d2;</span><br><span class=\"line\"><span class=\"number\">0x4009f9</span> lea    <span class=\"number\">-0x30</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x4009fd</span> mov    %rax,<span class=\"number\">-0x20</span>(%rbp)</span><br><span class=\"line\">\t\t   rBase2.getName();\t</span><br><span class=\"line\"><span class=\"number\">0x400a01</span> mov    <span class=\"number\">-0x20</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x400a05</span> mov    (%rax),%rax</span><br><span class=\"line\"><span class=\"number\">0x400a08</span> mov    (%rax),%rax</span><br><span class=\"line\"><span class=\"number\">0x400a0b</span> mov    <span class=\"number\">-0x20</span>(%rbp),%rdx</span><br><span class=\"line\"><span class=\"number\">0x400a0f</span> mov    %rdx,%rdi</span><br><span class=\"line\"><span class=\"number\">0x400a12</span> callq  *%rax</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>something else:  </p>\n<ul>\n<li>成员函数也是只有一份被存于代码区中，而对象并没有指向成员函数的指针，对象只存成员和虚拟表　；那在对象.成员函数使用时，</li>\n<li>是如何确定该函数中使用的成员是该对象的成员?<br>这里是this指针的作用<br>从汇编看，是否是成员函数在取的成员变量时，会做一些动作，这时的成员变量是在栈区；；<br>或者从调用成员函数时，是否有传入或控制函数的一些动作，让它知道从哪里取得对应的成员返回；</li>\n<li>成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"c-类内存布局：\"><a href=\"#c-类内存布局：\" class=\"headerlink\" title=\"c++类内存布局：\"></a>c++类内存布局：</h3><h4 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h4><p>下编译后的“内存布局”，此时还未分配内存，不能算是内存，只能说是文件布局","more":"</p>\n<ul>\n<li>two question:<br>多少内存能表现一个ob:?<br>多少内存能表现一个class?–编译期，如　int 大小为４ </li>\n<li>静态下，编译后同C一样分为代码段等；而类的特性有些类似于struct,定义类的文件中包含了成员变量，成员函数。</li>\n<li>类：<pre><code>非静态成员变量：存于对象中\nvptr指针：存于对象中\nvt表:vptr指向这个表，这个表在构造函数中默认隐士初始化，将对应的虚拟函数地址赋给表中的各个值（表本身with&quot;类&quot;）\nobj:         class:\n_vptr ---&gt;   table: ptr1 --&gt;virtual func1\n                    ptr2 --&gt;virtual func2\n静态变量: 存入数据段中\n成员函数:代码段,通过this和成员变量建立联系\n静态函数：　存于代码段中\n全局函数\nmain函数\n全局变量和静态变量\n局部变量：栈\nsomething extra depend on compiler~\n</code></pre></li>\n<li>some rules<ul>\n<li>每个类产生一堆指向virtual func的指针，放在表格中，表称为：vtbl;   </li>\n<li>每个obj被添加了一个指针，指向相关的tirtual table ,为vptr;</li>\n<li>vptr的设定和重置由constructor，destructor,copy assignment运算服自动完成）　</li>\n<li>注意每一个class所关联的type info object(用于支持runtime type identification  )也经由virtual table指出，放在vptr[0]处）</li>\n<li>虚函数有可能被转换为：(*px-&gt;vtbl[1])(px)<pre><code>具体见深入c++模型书\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"多少内存能表现一个ob\"><a href=\"#多少内存能表现一个ob\" class=\"headerlink\" title=\"多少内存能表现一个ob:?\"></a>多少内存能表现一个ob:?</h4><ul>\n<li>non static data members</li>\n<li>padding</li>\n<li>virtual—vptr<h4 id=\"多少内存能表现一个class\"><a href=\"#多少内存能表现一个class\" class=\"headerlink\" title=\"多少内存能表现一个class?\"></a>多少内存能表现一个class?</h4>见datamember_memory  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最小是１　  size  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&#123;</span> &#125;;   --<span class=\"number\">-1</span> 一个<span class=\"keyword\">char</span> 表示这个类型  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> :</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> T&#123;&#125;;　　--指针大小，指针指向T    <span class=\"keyword\">virtual</span> base <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">subobject</span>  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Y</span> :</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> T&#123;&#125;;  --指针大小</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span><span class=\"keyword\">public</span> X,<span class=\"keyword\">public</span> Y &#123;&#125;;　--两个指针大小</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>more seee datamember_memory</p>\n<h4 id=\"运行时\"><a href=\"#运行时\" class=\"headerlink\" title=\"运行时\"></a>运行时</h4><p>的内存布局，即作为进程运行时，其内存是如何的；</p>\n<ul>\n<li>运行时，涉及类的对象模型，对象的内存部分只包含非静态成员变量和虚拟函数指针表；</li>\n<li>可以通过gdb 或kgdb进行查看类对象的地址或者类函数的地址：<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tCircle c12;</span><br><span class=\"line\">\t\t<span class=\"function\">Circle <span class=\"title\">c1</span><span class=\"params\">(<span class=\"number\">1.2</span>,<span class=\"string\">\"red\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"getRadius:%x\\n\"</span>,&amp;Circle::getRadius);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%x, %x\\n\"</span>,&amp;c12,c12);</span><br><span class=\"line\"> <span class=\"keyword\">void</span> *cc;</span><br><span class=\"line\">        cc=(Circle*)(&amp;c12);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;*((<span class=\"keyword\">double</span>*)cc)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">```\t\t</span><br><span class=\"line\">    \t\t</span><br><span class=\"line\">所以c++的对象带来的开销在于操作多态时的vptr等效率低）\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">一个例子</span><br><span class=\"line\">```cpp</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">getage</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">3</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">getage</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">5</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>:</span> <span class=\"keyword\">public</span> B</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>; &#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getage</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">6</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span> <span class=\"keyword\">public</span> C</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"D\"</span>; &#125;</span><br><span class=\"line\"><span class=\"number\">0x400ae8</span> push   %rbp</span><br><span class=\"line\"><span class=\"number\">0x400ae9</span> mov    %rsp,%rbp</span><br><span class=\"line\"><span class=\"number\">0x400aec</span> mov    %rdi,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getage</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">8</span>;&#125;</span><br><span class=\"line\"><span class=\"number\">0x400af8</span> push   %rbp</span><br><span class=\"line\"><span class=\"number\">0x400af9</span> mov    %rsp,%rbp</span><br><span class=\"line\"><span class=\"number\">0x400afc</span> mov    %rdi,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">\t\t    A aa;</span><br><span class=\"line\">\t\t\taa.getName();</span><br><span class=\"line\">\t\t    D d;</span><br><span class=\"line\">\t\t\td.getName();</span><br><span class=\"line\">\t\t\tA &amp;rBase = d;</span><br><span class=\"line\">\t\t\trBase.getName();</span><br><span class=\"line\"><span class=\"number\">0x400986</span> mov    <span class=\"number\">-0x28</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x40098a</span> mov    (%rax),%rax</span><br><span class=\"line\"><span class=\"number\">0x40098d</span> mov    (%rax),%rax</span><br><span class=\"line\"><span class=\"number\">0x400990</span> mov    <span class=\"number\">-0x28</span>(%rbp),%rdx</span><br><span class=\"line\"><span class=\"number\">0x400994</span> mov    %rdx,%rdi</span><br><span class=\"line\"><span class=\"number\">0x400997</span> callq  *%rax</span><br><span class=\"line\">            rBase.getage();</span><br><span class=\"line\"><span class=\"number\">0x400999</span> mov    <span class=\"number\">-0x28</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x40099d</span> mov    (%rax),%rax</span><br><span class=\"line\"><span class=\"number\">0x4009a0</span> add    $<span class=\"number\">0x8</span>,%rax</span><br><span class=\"line\"><span class=\"number\">0x4009a4</span> mov    (%rax),%rax</span><br><span class=\"line\"><span class=\"number\">0x4009a7</span> mov    <span class=\"number\">-0x28</span>(%rbp),%rdx</span><br><span class=\"line\"><span class=\"number\">0x4009ab</span> mov    %rdx,%rdi</span><br><span class=\"line\"><span class=\"number\">0x4009ae</span> callq  *%rax</span><br><span class=\"line\">\t\t    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"rBase is a \"</span> &lt;&lt; rBase.getName() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">\t\t\t\t\t </span><br><span class=\"line\">\t\t\tD d2;</span><br><span class=\"line\">            A &amp;rBase2 =d2;</span><br><span class=\"line\"><span class=\"number\">0x4009f9</span> lea    <span class=\"number\">-0x30</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x4009fd</span> mov    %rax,<span class=\"number\">-0x20</span>(%rbp)</span><br><span class=\"line\">\t\t   rBase2.getName();\t</span><br><span class=\"line\"><span class=\"number\">0x400a01</span> mov    <span class=\"number\">-0x20</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x400a05</span> mov    (%rax),%rax</span><br><span class=\"line\"><span class=\"number\">0x400a08</span> mov    (%rax),%rax</span><br><span class=\"line\"><span class=\"number\">0x400a0b</span> mov    <span class=\"number\">-0x20</span>(%rbp),%rdx</span><br><span class=\"line\"><span class=\"number\">0x400a0f</span> mov    %rdx,%rdi</span><br><span class=\"line\"><span class=\"number\">0x400a12</span> callq  *%rax</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>something else:  </p>\n<ul>\n<li>成员函数也是只有一份被存于代码区中，而对象并没有指向成员函数的指针，对象只存成员和虚拟表　；那在对象.成员函数使用时，</li>\n<li>是如何确定该函数中使用的成员是该对象的成员?<br>这里是this指针的作用<br>从汇编看，是否是成员函数在取的成员变量时，会做一些动作，这时的成员变量是在栈区；；<br>或者从调用成员函数时，是否有传入或控制函数的一些动作，让它知道从哪里取得对应的成员返回；</li>\n<li>成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁</li>\n</ul>"},{"title":"cpp_conanddest_semantics","date":"2018-06-09T14:03:32.000Z","_content":"\n### 构造和析构函数语义学  \n#### 1. \n即使是abstract base class也可能需要手动写constructor,de...,关键是看它有没有non satic data member  <!--more-->\n例如:  \n```cpp\n  class Abstract_class {\n      public:\n         virtual ~Abstract_base() = 0;\n         virtual void interface() const=0;\n         virtual const char * mumble() const {\n             return _mumble;\n         }\n      protected:\n         char *_mumble;\n    };```\n  上述例子，该抽象类本身不能被实例化，但是可以被继承，被继承时在构造时必须初始化 “mumble”,此时就需要用它的默认构造函数，所以必须为这个抽象类写一个构造函数；   \n  \n#### 2. 纯虚函数的存在： \n```cpp\n#include<iostream>\nusing namespace std;\nclass Abstra_class {\n\tpublic :\n\t   // virtual ~Abstra_class() =0;\n\t\tvirtual ~Abstra_class() { delete _mumble;cout<<\"use ~abstra_class\";}\n\t\t//virtual void interface() const=0;\n\t\tvirtual void interface() const { cout<<\"use interface Abstra_class:\";}\n\t\tvirtual const char* mumble() const{\n\t\t\t\treturn _mumble;\n\t\t}\n\t\tAbstra_class(){_mumble=new char[4];cout<<\"construct:Abs..\";}\n\tprotected:\n\t\tchar* _mumble;\n};\nclass dev : public Abstra_class {\n\t\tpublic:\n\t\t\t\t~dev() {dd=0;}\n\t\t\t\tdev(){dd=3;}\n\t\t\t\tvoid useA (){\n               Abstra_class::interface();//即使可以这样，但是链接失败，即因该函数的定义=0,重新加上定义使之不为pure就ok了\n\t\t\t\t}\n\t\t\t\tvirtual void interface() const {if(dd==4)cout<<\"re\";}\n\t\tprotected:\n\t\t\t\tint dd;\n};\nint main ()\n{\n\t  dev ddd;\n\t\tddd.useA();\n\t\tddd.interface();\n\t  //  Abstra_class::interface();\n\t\treturn 0;\n}\n```\n输出：construct:Abs..use interface Abstra_class:use ~Abstra_class: \n\n　\"可以定义和调用pure virtual func ,但是只能被静态的调用，而不能通过虚拟机制 \"这个在g++上实验了下，发现：\n```cpp\n#include<iostream>\nusing namespace std;\nclass Abstra_class {\n\tpublic :\n\t   // virtual ~Abstra_class() =0;\n\t\tvirtual ~Abstra_class() { delete _mumble;cout<<\"use ~Abstra_class:\";}\n\t\tvirtual void interface() const=0;\n\t\t//virtual void interface() const { cout<<\"use interface Abstra_class:\";}\n\t\tvirtual const char* mumble() const{\n\t\t\t\treturn _mumble;\n\t\t}\n\t\tvirtual void  ii() const=0;//ensure is a abstra class\n\t\tAbstra_class(){_mumble=new char[4];cout<<\"construct:Abs..\";}\n\tprotected:\n\t\tchar* _mumble;\n};\ninline void Abstra_class::interface() const {\n}\nclass dev : public Abstra_class {\n\t\tpublic:\n\t\t\t\t~dev() {dd=0;}\n\t\t\t\tdev(){dd=3;}\n\t\t\t\tvoid useA (){\n                Abstra_class::interface();//即使可以这样，但是链接失败，即因该函数的引用为0\n\t\t           dd=4;\n\t\t\t\t}\n\t\t\t\tvirtual void interface() const {\n\t\t\t\t\t\tif(dd==4)cout<<\"\\nre\\n\";\n\t\t\t\t\t\t//Abstra_class::interface();\n\t\t\t\t}\n\t\t\t\tvirtual void ii() const {cout<<\"is implenment\";}\n\t\tprotected:\n\t\t\t\tint dd;\n};\nint main ()\n{\n\t  dev ddd;\n\t\tddd.useA();\n\t\tddd.interface();\n\tAbstra_class *pt=&ddd;\n\tpt->interface();\n\t  //  Abstra_class::interface();\n\t\treturn 0;\n}\n```\n  输出了两次re,说明可以通过虚拟机制调用它；interface在这里被内联的定义了空的函数，它不算pure了，所以上述说法感觉存在问题。。。  \n　注意，因为在每一个derived class　destructor会被扩展，以静态方式调用每一个virtual base class 和上一层的desturctor,\n     所以只要缺少任何一个 base destructor定义则链接失败　，所以需要定义pure virtual destructor\n      一个比较好的替代方式就是不要把vitual dect~定义为pure\n      考虑到成本，不要把所有的函数都定以为virtual\n      \n3)虚拟规格的存在：\n　　　　在virtual func要不要为const ,主要看要不要对date member做修改\n所以不要随便定义为pure,virtual const,毕竟效率\n\n#### 考虑几种情况下的构造情况：\n##### 一、无继承情况下对象构造几种方式：  \n```cpp\nPoint global;　//周期：程序的生命周期，exit前\n \nPoint foobar(){\n   Point local;　//此函数的周期，调用默认构造函数但是不会初始化成员\n   Point *heap=new Point;//delete 前，调用默认构造函数，但不会初始化成员\n   *heap=local;//local若未调用用户初始化的构造函数，则warning,调用拷贝赋值函数，maybe 位搬移\n   delete heap;//默认析构函数\n   return local;//maybe拷贝构造或者位搬移\n   }\n ```\n+ 考虑这几个对象的声明周期\n+ 在c中，global会被放入bss中，未初始化，但是c++中所有的全局对象被当做“初始化过的数据”，会调用constructor函数　可以测试一下\n+ 一般情况下，c++默认为类生成：default constructor,destructor,copy constructor,copy assignment operator\n```cpp\n#include<iostream>\nusing namespace std;\nclass Point {\n\tpublic:\n\t\t\tPoint (){cout<<\"in constructor \"<<endl;}\n\t\t\t~Point() {cout<<\"in destructor\"<<endl;}\n};\nPoint glo;\nint main ()\n{\n\t\treturn 0;\n}```\n显然在定义Point glo的时候构造函数是会调用的\n\n１、抽象数据类型：\n　　根据需要决定是否写constructor destructor或者默认的就足够了\n　　　global类型的对象直到程序激活才调用构造函数\n　　　显性的初始化列表比将构造函数扩展为inline效率更高，后者需要赋值等，看下面例子：\n```cpp\n#include<iostream>  \nusing namespace std;  \n  \nclass Point{  \npublic:  \n    Point(double x = 0.0, double y = 0.0, double z = 0.0) :_x(x), _y(y), _z(z){}  \n    void print(){ cout << _x << endl << _y << endl << _z << endl; };  \nprivate:  \n    double _x, _y, _z;  \n};  \n  \nint main(){  \n    Point local1 = { 1.1, 1.2, 1.3 };//用g++ --std=c++11可以，若为double a=1.5; ..={a,...}变量形式则不行（c++11可以） \n    local1.print();  \n  \n    system(\"pause\");  \n    return 0;  \n} ``` \n而在显性初始化列表（explicit initialization list)->xxx={yyy};使用时较快是如下原因：  \n函数的activation record 被放进程序的堆栈时，initializatioin list 中的常量就可以被放进local1的内存中了;  \n但是explicit initialization list带来三个缺点：\n+ 只有当class member 都是public时才生效，这点实验private时也可以  \n+ 只能在{ }中指定常量，因为在编译期间进行评估求值\n+ 由于编译器为自动施行，所以失败的可能性更高  \n看一下汇编代码：\n```cpp\nclass Point{  \npublic:  \n    Point(int x = 0, int  y = 0, int z = 0) :_x(x), _y(y), _z(z){}  \n ```\n ```\n0x400938 push   %rbp\n0x400939 mov    %rsp,%rbp\n0x40093c mov    %rdi,-0x8(%rbp)\n0x400940 mov    %esi,-0xc(%rbp)\n0x400943 mov    %edx,-0x10(%rbp)\n0x400946 mov    %ecx,-0x14(%rbp)\n```\n\n```cpp\n    void print(){ cout << _x << endl << _y << endl << _z << endl; };  \nprivate:  \n    int _x, _y, _z;  \n};   \n  \nint main(){ \n\tint  a=1;\t\n    Point local1 = { a, 4, 5};```\n    \n```\n0x4008a4 mov    -0x24(%rbp),%esi\n0x4008a7 lea    -0x20(%rbp),%rax\n0x4008ab mov    $0x5,%ecx\n0x4008b0 mov    $0x4,%edx\n0x4008b5 mov    %rax,%rdi\n0x4008b8 callq  0x400938 <Point::Point(int, int, int)>\n```\n上述讲的activation record是：  \n+ Locals to the callee\n+ Return address to the caller\n+ Parameters of the callee  \n从上述的汇编代码可以看到，在做显示初始化列表时将常量值赋给ecx等两个寄存器，接着调用构造函数，构造函数将寄存器的内容赋给成员，而其实采用Point local2;这种直接调用构造函数的发式也是如此，且和在构造函数中赋值给成员时转换的汇编相同，所以不是很理解这块的区别，在g++ c++11是如此表现的    \n##### ２、为继承做准备：  \n继承可能用到多态，此时需要使用virtual ,那就会带来constructor等函数中加入对vptr的初始化（copy constructor等）\nc++标准会要求编译器尽量延迟对nontrivial members的实际合成 操作，直到真正遇到其使用场合：这里trivial意思是无意义，这个trivial和non-trivial是对类的四种函数来说的：\n\n    构造函数(ctor)  \n    复制构造函数(copy)  \n    赋值函数(assignment)  \n    析构函数(dtor)  \n\n如果至少满足下面3条里的一条：\n\n    显式(explict)定义了这四种函数。\n    类里有非静态非POD的数据成员。\n    有基类。\n\n那么上面的四种函数是non-trivial函数，比如叫non-trivial ctor、non-trivial copy…，也就是说有意义的函数，里面有一下必要的操作，比如类成员的初始化，释放内存等。   \n\n##### 二、继承体系下的对象构造：  \nconstructor函数中的隐藏代码，  \n1. 初始化列表  \n2. member的默认构造函数,若该member未出现在初始化列表中\n3. vptr，在1,2之前，指向vtable   \n4. base class constructor  1,2,3之前，以声明顺序为顺序，若在member initialization list中，则应传递参数，否则在1,2,3前加入其默认构造函数。多继承时可能this指针调\n5. virtual base class constructor，从左到右，从最深到最浅 ，同4，若在list中有则用，否则。。  \n\n例子：\n```cpp\n class Point{\n   public:\n    Point (float x=0.0,float y=0.0);  \n    Point(const Point&);\n    Point& operator=(const Point&);\n    virtual ~Point();\n    virtual float z() {return 0.0;}\n   protected:\n   float _x,_y;\n   };\n   class line {\n    Point _begin,_end;\n    public:\n      Line(....);\n      Line(...);\n      };```\nline的默认析构函数会被合成，但是无意义，当然它的member的默认析构函数会被加入。。。其他类似\n\n##### 三、虚拟继承：\n+ 考虑下面的例子：\n```cpp\nclass Point3d:public virtual Point{\n    public:\n       Point3d(float x=0.0,float y=0.0,float z=0.0):Point(x,y),_z(z){}\n       Point3d(const Point3d& rhs):point(rhs),_z(rhs._z){}\n       ~Point3d();\n       Point3d& operator=...\n       //..\n      proteced:\n      float _z;\n      }```\n  传统的如上面的扩充构造函数：\n  ```cpp\n  this->Point(:Point(x,y);\n  this->_vptr_Point3d = vtbl_Point3d;\n  this->_vptr_point3d_point=_vtbl_point3d_point;\n  this->_z=rhs_z;\n  return this```\n  但是在这里，虚拟继承这显然不够准确：　　\n  考虑当出现菱形继承：　　\n  ```cpp\n  class Vertex:virtual public Point;\n  class Vertex3d:public Point3d,public Vertex{;};\n  class Pvertex:public Vertex3d{;};'```\n  \n  那作为被共享的Point subobject应该由最底层的如Vertex3d来初始化：\n  而最底层显然也会初始化Point3d和vertex,并调用他们的构造函数；如果他们的构造函数不加限制，就会又调用Point的构造，导致错误；　　\n  所以应该做限制，如下：  \n  ```cpp\n  Vertex3d::Vertex3d(Vertex3d *this,bool __most_derived,float x,float y,float z){\n  if(__most_derived!=false)//判断是否为最底层\n     this->Point::Point(x,y);//是则构造最上层的\n     //调用上一层的base classes\n     //设定__most_derived为false\n  this->Point3d::Ponint3d(..);\n  ...\n  ```\n而在   \n```cpp\nPoint3d::Point3d(Point3d* this,...)\n{\n   if(___most_derived!=false)\n      this->Point::Point(x,y);\n      ....\n      }```\n所以最底层的构造函数等会限制中间层对最上层的构造\n+ 思考：\n+ 当obj只是某个完整的obj的子obj时，则不用调用virtual base class constructor:,如上，那就产生了一种提高效率的方式：\n+ 将构造函数分割为obj和subobj,，前者为完整版本的obj，自然要调用所有，包括基类的构造，后者不用，这种分裂可以提高效率\n\n#### vptr初始化语意\n+ 题外，这本书总喜欢讨论特殊的情况，哭笑，下面也是，在构造函数中调用虚函数222\n+ 主要讨论vptr什么时候初始化合适，以及为什么\n+ constructor调用顺序：考虑：\n  ```cpp\n  class Vertex:virtual public Point;\n  class Vertex3d:public Point3d,public Vertex{;};\n  class Pvertex:public Vertex3d{;};'```\n  当一个PVertex对象被构造时，构造函数顺序为：　　  \n  Point    \n  Point3d  \n  Vertex  \n  Vertex3d  \n  Pvertex  \n+ 假设这个继承体系中的每一个类都定义了一个virtual func size()，该函数负责传回class的大小；如果我们写：  \n  Pvertex pv;  \n  Point3d p3d;  \n  Point  *pt=&pv;  \n  那么这个调用pt->size()传回PVertex的大小，而  \n  pt=&p3d; pt->size()则传回p3d的大小；\n+ 更进一步，特殊情况：\n当在构造函数中调用这个操作时，如在point3d构造函数中调用时，是选择哪个class的size,毕竟现在正在构造point3d,答案是point3d的\n + 考虑如何使得上述生效?\n + 静态调用Point3d::size()或者bnalalla\n + 最后，利用vptr虚拟机制，即要在调用size之前初始化好其class对应的vptr\n + 总结：在这种情况下，vptr在base class constructor 调用之后，在程序员代码之前（如size),或是初始化列表所列的member初始化操作前\n + 更好的，分割constructor为完整obj和subobj\n \n ### 对象复制语意学\n #### 复制函数什么时候会被合成和使用\n+ 前言，当你设计一个类，并以一个对象复制给另一个对象时，有三种选择：  \n + 什么也不做，实行默认行为  \n + 提供一个显性拷贝函数\n + 拒绝，只需要把复制函数声明为private就可以 \n+ 考虑默认的行为：\n + bitwise copy行为，当不出现一下情况时，甚至不会调用复制函数，而是做bitwise copy\n + 而当出现以下行为时，调用默认的copy assignment operator函数，并合成相关操作：　　\n\t1. 当class中有mem obj，这个obj有一个copy ass operaator\n\t2. 当类的基类有copy assi opera..\n\t3. 类带virtual func\n\t4. 继承自一个virtual base class  \n+ 写一个显性的复制函数：  \n  + 在发生上述情况时，编译器也会像合成构造函数一样在显性的复制函数中加东西\n  + 而继上面的，Point共享基类，编译器如何能在Point3d和Vertex的copy assignment operator中压抑point的copy assignment operator呢?\n  + 书中的后面有些难以理解，等后面再探索吧，哎时间有限。。\n### 对象的功能\n测试对象构造和拷贝的成本，在从简单形式，单一继承，到多重继承，虚拟继承等情况下的时间复杂度\n### 解构语意学\n+ 析构函数并不会总是被合成出来，更别提调用；\n+ 只有在类内带的member object或者自己的base class带有destructor，编译器才会合成一个析构函数，否则被视为不需要或者不用合成调用\n+ 析构函数没必要和构造函数对称\n+ 析构函数一般有以下顺序：\n  + 先调用最底层子类析构函数，接着往上，直到基类\n  + 析构函数本身在被执行时，vprt会在程序员代码前被执行\n  + 若class拥有member class object ,而后者拥有destructor,则他们会以其声明顺序相反顺序被调用\n  + 如果object内带一个vptr,则首先重设相关的virtual table\n  + 若有任何直接的非虚基类拥有析构函数，则同上\n  + 若有虚基类，则按照构造顺序相反顺序调用\n+ 类似于构造函数，可以分裂","source":"_posts/cpp-conanddest-semantics.md","raw":"---\ntitle: cpp_conanddest_semantics\ndate: 2018-06-09 22:03:32\ntags: cpp_class\ncategories: c&cpp\n---\n\n### 构造和析构函数语义学  \n#### 1. \n即使是abstract base class也可能需要手动写constructor,de...,关键是看它有没有non satic data member  <!--more-->\n例如:  \n```cpp\n  class Abstract_class {\n      public:\n         virtual ~Abstract_base() = 0;\n         virtual void interface() const=0;\n         virtual const char * mumble() const {\n             return _mumble;\n         }\n      protected:\n         char *_mumble;\n    };```\n  上述例子，该抽象类本身不能被实例化，但是可以被继承，被继承时在构造时必须初始化 “mumble”,此时就需要用它的默认构造函数，所以必须为这个抽象类写一个构造函数；   \n  \n#### 2. 纯虚函数的存在： \n```cpp\n#include<iostream>\nusing namespace std;\nclass Abstra_class {\n\tpublic :\n\t   // virtual ~Abstra_class() =0;\n\t\tvirtual ~Abstra_class() { delete _mumble;cout<<\"use ~abstra_class\";}\n\t\t//virtual void interface() const=0;\n\t\tvirtual void interface() const { cout<<\"use interface Abstra_class:\";}\n\t\tvirtual const char* mumble() const{\n\t\t\t\treturn _mumble;\n\t\t}\n\t\tAbstra_class(){_mumble=new char[4];cout<<\"construct:Abs..\";}\n\tprotected:\n\t\tchar* _mumble;\n};\nclass dev : public Abstra_class {\n\t\tpublic:\n\t\t\t\t~dev() {dd=0;}\n\t\t\t\tdev(){dd=3;}\n\t\t\t\tvoid useA (){\n               Abstra_class::interface();//即使可以这样，但是链接失败，即因该函数的定义=0,重新加上定义使之不为pure就ok了\n\t\t\t\t}\n\t\t\t\tvirtual void interface() const {if(dd==4)cout<<\"re\";}\n\t\tprotected:\n\t\t\t\tint dd;\n};\nint main ()\n{\n\t  dev ddd;\n\t\tddd.useA();\n\t\tddd.interface();\n\t  //  Abstra_class::interface();\n\t\treturn 0;\n}\n```\n输出：construct:Abs..use interface Abstra_class:use ~Abstra_class: \n\n　\"可以定义和调用pure virtual func ,但是只能被静态的调用，而不能通过虚拟机制 \"这个在g++上实验了下，发现：\n```cpp\n#include<iostream>\nusing namespace std;\nclass Abstra_class {\n\tpublic :\n\t   // virtual ~Abstra_class() =0;\n\t\tvirtual ~Abstra_class() { delete _mumble;cout<<\"use ~Abstra_class:\";}\n\t\tvirtual void interface() const=0;\n\t\t//virtual void interface() const { cout<<\"use interface Abstra_class:\";}\n\t\tvirtual const char* mumble() const{\n\t\t\t\treturn _mumble;\n\t\t}\n\t\tvirtual void  ii() const=0;//ensure is a abstra class\n\t\tAbstra_class(){_mumble=new char[4];cout<<\"construct:Abs..\";}\n\tprotected:\n\t\tchar* _mumble;\n};\ninline void Abstra_class::interface() const {\n}\nclass dev : public Abstra_class {\n\t\tpublic:\n\t\t\t\t~dev() {dd=0;}\n\t\t\t\tdev(){dd=3;}\n\t\t\t\tvoid useA (){\n                Abstra_class::interface();//即使可以这样，但是链接失败，即因该函数的引用为0\n\t\t           dd=4;\n\t\t\t\t}\n\t\t\t\tvirtual void interface() const {\n\t\t\t\t\t\tif(dd==4)cout<<\"\\nre\\n\";\n\t\t\t\t\t\t//Abstra_class::interface();\n\t\t\t\t}\n\t\t\t\tvirtual void ii() const {cout<<\"is implenment\";}\n\t\tprotected:\n\t\t\t\tint dd;\n};\nint main ()\n{\n\t  dev ddd;\n\t\tddd.useA();\n\t\tddd.interface();\n\tAbstra_class *pt=&ddd;\n\tpt->interface();\n\t  //  Abstra_class::interface();\n\t\treturn 0;\n}\n```\n  输出了两次re,说明可以通过虚拟机制调用它；interface在这里被内联的定义了空的函数，它不算pure了，所以上述说法感觉存在问题。。。  \n　注意，因为在每一个derived class　destructor会被扩展，以静态方式调用每一个virtual base class 和上一层的desturctor,\n     所以只要缺少任何一个 base destructor定义则链接失败　，所以需要定义pure virtual destructor\n      一个比较好的替代方式就是不要把vitual dect~定义为pure\n      考虑到成本，不要把所有的函数都定以为virtual\n      \n3)虚拟规格的存在：\n　　　　在virtual func要不要为const ,主要看要不要对date member做修改\n所以不要随便定义为pure,virtual const,毕竟效率\n\n#### 考虑几种情况下的构造情况：\n##### 一、无继承情况下对象构造几种方式：  \n```cpp\nPoint global;　//周期：程序的生命周期，exit前\n \nPoint foobar(){\n   Point local;　//此函数的周期，调用默认构造函数但是不会初始化成员\n   Point *heap=new Point;//delete 前，调用默认构造函数，但不会初始化成员\n   *heap=local;//local若未调用用户初始化的构造函数，则warning,调用拷贝赋值函数，maybe 位搬移\n   delete heap;//默认析构函数\n   return local;//maybe拷贝构造或者位搬移\n   }\n ```\n+ 考虑这几个对象的声明周期\n+ 在c中，global会被放入bss中，未初始化，但是c++中所有的全局对象被当做“初始化过的数据”，会调用constructor函数　可以测试一下\n+ 一般情况下，c++默认为类生成：default constructor,destructor,copy constructor,copy assignment operator\n```cpp\n#include<iostream>\nusing namespace std;\nclass Point {\n\tpublic:\n\t\t\tPoint (){cout<<\"in constructor \"<<endl;}\n\t\t\t~Point() {cout<<\"in destructor\"<<endl;}\n};\nPoint glo;\nint main ()\n{\n\t\treturn 0;\n}```\n显然在定义Point glo的时候构造函数是会调用的\n\n１、抽象数据类型：\n　　根据需要决定是否写constructor destructor或者默认的就足够了\n　　　global类型的对象直到程序激活才调用构造函数\n　　　显性的初始化列表比将构造函数扩展为inline效率更高，后者需要赋值等，看下面例子：\n```cpp\n#include<iostream>  \nusing namespace std;  \n  \nclass Point{  \npublic:  \n    Point(double x = 0.0, double y = 0.0, double z = 0.0) :_x(x), _y(y), _z(z){}  \n    void print(){ cout << _x << endl << _y << endl << _z << endl; };  \nprivate:  \n    double _x, _y, _z;  \n};  \n  \nint main(){  \n    Point local1 = { 1.1, 1.2, 1.3 };//用g++ --std=c++11可以，若为double a=1.5; ..={a,...}变量形式则不行（c++11可以） \n    local1.print();  \n  \n    system(\"pause\");  \n    return 0;  \n} ``` \n而在显性初始化列表（explicit initialization list)->xxx={yyy};使用时较快是如下原因：  \n函数的activation record 被放进程序的堆栈时，initializatioin list 中的常量就可以被放进local1的内存中了;  \n但是explicit initialization list带来三个缺点：\n+ 只有当class member 都是public时才生效，这点实验private时也可以  \n+ 只能在{ }中指定常量，因为在编译期间进行评估求值\n+ 由于编译器为自动施行，所以失败的可能性更高  \n看一下汇编代码：\n```cpp\nclass Point{  \npublic:  \n    Point(int x = 0, int  y = 0, int z = 0) :_x(x), _y(y), _z(z){}  \n ```\n ```\n0x400938 push   %rbp\n0x400939 mov    %rsp,%rbp\n0x40093c mov    %rdi,-0x8(%rbp)\n0x400940 mov    %esi,-0xc(%rbp)\n0x400943 mov    %edx,-0x10(%rbp)\n0x400946 mov    %ecx,-0x14(%rbp)\n```\n\n```cpp\n    void print(){ cout << _x << endl << _y << endl << _z << endl; };  \nprivate:  \n    int _x, _y, _z;  \n};   \n  \nint main(){ \n\tint  a=1;\t\n    Point local1 = { a, 4, 5};```\n    \n```\n0x4008a4 mov    -0x24(%rbp),%esi\n0x4008a7 lea    -0x20(%rbp),%rax\n0x4008ab mov    $0x5,%ecx\n0x4008b0 mov    $0x4,%edx\n0x4008b5 mov    %rax,%rdi\n0x4008b8 callq  0x400938 <Point::Point(int, int, int)>\n```\n上述讲的activation record是：  \n+ Locals to the callee\n+ Return address to the caller\n+ Parameters of the callee  \n从上述的汇编代码可以看到，在做显示初始化列表时将常量值赋给ecx等两个寄存器，接着调用构造函数，构造函数将寄存器的内容赋给成员，而其实采用Point local2;这种直接调用构造函数的发式也是如此，且和在构造函数中赋值给成员时转换的汇编相同，所以不是很理解这块的区别，在g++ c++11是如此表现的    \n##### ２、为继承做准备：  \n继承可能用到多态，此时需要使用virtual ,那就会带来constructor等函数中加入对vptr的初始化（copy constructor等）\nc++标准会要求编译器尽量延迟对nontrivial members的实际合成 操作，直到真正遇到其使用场合：这里trivial意思是无意义，这个trivial和non-trivial是对类的四种函数来说的：\n\n    构造函数(ctor)  \n    复制构造函数(copy)  \n    赋值函数(assignment)  \n    析构函数(dtor)  \n\n如果至少满足下面3条里的一条：\n\n    显式(explict)定义了这四种函数。\n    类里有非静态非POD的数据成员。\n    有基类。\n\n那么上面的四种函数是non-trivial函数，比如叫non-trivial ctor、non-trivial copy…，也就是说有意义的函数，里面有一下必要的操作，比如类成员的初始化，释放内存等。   \n\n##### 二、继承体系下的对象构造：  \nconstructor函数中的隐藏代码，  \n1. 初始化列表  \n2. member的默认构造函数,若该member未出现在初始化列表中\n3. vptr，在1,2之前，指向vtable   \n4. base class constructor  1,2,3之前，以声明顺序为顺序，若在member initialization list中，则应传递参数，否则在1,2,3前加入其默认构造函数。多继承时可能this指针调\n5. virtual base class constructor，从左到右，从最深到最浅 ，同4，若在list中有则用，否则。。  \n\n例子：\n```cpp\n class Point{\n   public:\n    Point (float x=0.0,float y=0.0);  \n    Point(const Point&);\n    Point& operator=(const Point&);\n    virtual ~Point();\n    virtual float z() {return 0.0;}\n   protected:\n   float _x,_y;\n   };\n   class line {\n    Point _begin,_end;\n    public:\n      Line(....);\n      Line(...);\n      };```\nline的默认析构函数会被合成，但是无意义，当然它的member的默认析构函数会被加入。。。其他类似\n\n##### 三、虚拟继承：\n+ 考虑下面的例子：\n```cpp\nclass Point3d:public virtual Point{\n    public:\n       Point3d(float x=0.0,float y=0.0,float z=0.0):Point(x,y),_z(z){}\n       Point3d(const Point3d& rhs):point(rhs),_z(rhs._z){}\n       ~Point3d();\n       Point3d& operator=...\n       //..\n      proteced:\n      float _z;\n      }```\n  传统的如上面的扩充构造函数：\n  ```cpp\n  this->Point(:Point(x,y);\n  this->_vptr_Point3d = vtbl_Point3d;\n  this->_vptr_point3d_point=_vtbl_point3d_point;\n  this->_z=rhs_z;\n  return this```\n  但是在这里，虚拟继承这显然不够准确：　　\n  考虑当出现菱形继承：　　\n  ```cpp\n  class Vertex:virtual public Point;\n  class Vertex3d:public Point3d,public Vertex{;};\n  class Pvertex:public Vertex3d{;};'```\n  \n  那作为被共享的Point subobject应该由最底层的如Vertex3d来初始化：\n  而最底层显然也会初始化Point3d和vertex,并调用他们的构造函数；如果他们的构造函数不加限制，就会又调用Point的构造，导致错误；　　\n  所以应该做限制，如下：  \n  ```cpp\n  Vertex3d::Vertex3d(Vertex3d *this,bool __most_derived,float x,float y,float z){\n  if(__most_derived!=false)//判断是否为最底层\n     this->Point::Point(x,y);//是则构造最上层的\n     //调用上一层的base classes\n     //设定__most_derived为false\n  this->Point3d::Ponint3d(..);\n  ...\n  ```\n而在   \n```cpp\nPoint3d::Point3d(Point3d* this,...)\n{\n   if(___most_derived!=false)\n      this->Point::Point(x,y);\n      ....\n      }```\n所以最底层的构造函数等会限制中间层对最上层的构造\n+ 思考：\n+ 当obj只是某个完整的obj的子obj时，则不用调用virtual base class constructor:,如上，那就产生了一种提高效率的方式：\n+ 将构造函数分割为obj和subobj,，前者为完整版本的obj，自然要调用所有，包括基类的构造，后者不用，这种分裂可以提高效率\n\n#### vptr初始化语意\n+ 题外，这本书总喜欢讨论特殊的情况，哭笑，下面也是，在构造函数中调用虚函数222\n+ 主要讨论vptr什么时候初始化合适，以及为什么\n+ constructor调用顺序：考虑：\n  ```cpp\n  class Vertex:virtual public Point;\n  class Vertex3d:public Point3d,public Vertex{;};\n  class Pvertex:public Vertex3d{;};'```\n  当一个PVertex对象被构造时，构造函数顺序为：　　  \n  Point    \n  Point3d  \n  Vertex  \n  Vertex3d  \n  Pvertex  \n+ 假设这个继承体系中的每一个类都定义了一个virtual func size()，该函数负责传回class的大小；如果我们写：  \n  Pvertex pv;  \n  Point3d p3d;  \n  Point  *pt=&pv;  \n  那么这个调用pt->size()传回PVertex的大小，而  \n  pt=&p3d; pt->size()则传回p3d的大小；\n+ 更进一步，特殊情况：\n当在构造函数中调用这个操作时，如在point3d构造函数中调用时，是选择哪个class的size,毕竟现在正在构造point3d,答案是point3d的\n + 考虑如何使得上述生效?\n + 静态调用Point3d::size()或者bnalalla\n + 最后，利用vptr虚拟机制，即要在调用size之前初始化好其class对应的vptr\n + 总结：在这种情况下，vptr在base class constructor 调用之后，在程序员代码之前（如size),或是初始化列表所列的member初始化操作前\n + 更好的，分割constructor为完整obj和subobj\n \n ### 对象复制语意学\n #### 复制函数什么时候会被合成和使用\n+ 前言，当你设计一个类，并以一个对象复制给另一个对象时，有三种选择：  \n + 什么也不做，实行默认行为  \n + 提供一个显性拷贝函数\n + 拒绝，只需要把复制函数声明为private就可以 \n+ 考虑默认的行为：\n + bitwise copy行为，当不出现一下情况时，甚至不会调用复制函数，而是做bitwise copy\n + 而当出现以下行为时，调用默认的copy assignment operator函数，并合成相关操作：　　\n\t1. 当class中有mem obj，这个obj有一个copy ass operaator\n\t2. 当类的基类有copy assi opera..\n\t3. 类带virtual func\n\t4. 继承自一个virtual base class  \n+ 写一个显性的复制函数：  \n  + 在发生上述情况时，编译器也会像合成构造函数一样在显性的复制函数中加东西\n  + 而继上面的，Point共享基类，编译器如何能在Point3d和Vertex的copy assignment operator中压抑point的copy assignment operator呢?\n  + 书中的后面有些难以理解，等后面再探索吧，哎时间有限。。\n### 对象的功能\n测试对象构造和拷贝的成本，在从简单形式，单一继承，到多重继承，虚拟继承等情况下的时间复杂度\n### 解构语意学\n+ 析构函数并不会总是被合成出来，更别提调用；\n+ 只有在类内带的member object或者自己的base class带有destructor，编译器才会合成一个析构函数，否则被视为不需要或者不用合成调用\n+ 析构函数没必要和构造函数对称\n+ 析构函数一般有以下顺序：\n  + 先调用最底层子类析构函数，接着往上，直到基类\n  + 析构函数本身在被执行时，vprt会在程序员代码前被执行\n  + 若class拥有member class object ,而后者拥有destructor,则他们会以其声明顺序相反顺序被调用\n  + 如果object内带一个vptr,则首先重设相关的virtual table\n  + 若有任何直接的非虚基类拥有析构函数，则同上\n  + 若有虚基类，则按照构造顺序相反顺序调用\n+ 类似于构造函数，可以分裂","slug":"cpp-conanddest-semantics","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7nk000n2ujxh9sn7cxj","content":"<h3 id=\"构造和析构函数语义学\"><a href=\"#构造和析构函数语义学\" class=\"headerlink\" title=\"构造和析构函数语义学\"></a>构造和析构函数语义学</h3><h4 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h4><p>即使是abstract base class也可能需要手动写constructor,de…,关键是看它有没有non satic data member  <a id=\"more\"></a><br>例如:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Abstract_class</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">       <span class=\"keyword\">virtual</span> ~Abstract_base() = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">interface</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * <span class=\"title\">mumble</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> _mumble;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">       <span class=\"keyword\">char</span> *_mumble;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>  上述例子，该抽象类本身不能被实例化，但是可以被继承，被继承时在构造时必须初始化 “mumble”,此时就需要用它的默认构造函数，所以必须为这个抽象类写一个构造函数；   </p>\n<h4 id=\"2-纯虚函数的存在：\"><a href=\"#2-纯虚函数的存在：\" class=\"headerlink\" title=\"2. 纯虚函数的存在：\"></a>2. 纯虚函数的存在：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Abstra_class</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> :</span><br><span class=\"line\">\t   <span class=\"comment\">// virtual ~Abstra_class() =0;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">virtual</span> ~Abstra_class() &#123; <span class=\"keyword\">delete</span> _mumble;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"use ~abstra_class\"</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//virtual void interface() const=0;</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">interface</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"use interface Abstra_class:\"</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">mumble</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> _mumble;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tAbstra_class()&#123;_mumble=<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">4</span>];<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"construct:Abs..\"</span>;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>* _mumble;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">dev</span> :</span> <span class=\"keyword\">public</span> Abstra_class &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t~dev() &#123;dd=<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">\t\t\t\tdev()&#123;dd=<span class=\"number\">3</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">useA</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">               Abstra_class::interface();<span class=\"comment\">//即使可以这样，但是链接失败，即因该函数的定义=0,重新加上定义使之不为pure就ok了</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">interface</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">if</span>(dd==<span class=\"number\">4</span>)<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"re\"</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> dd;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t  dev ddd;</span><br><span class=\"line\">\t\tddd.useA();</span><br><span class=\"line\">\t\tddd.interface();</span><br><span class=\"line\">\t  <span class=\"comment\">//  Abstra_class::interface();</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：construct:Abs..use interface Abstra_class:use ~Abstra_class: </p>\n<p>　“可以定义和调用pure virtual func ,但是只能被静态的调用，而不能通过虚拟机制 “这个在g++上实验了下，发现：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Abstra_class</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> :</span><br><span class=\"line\">\t   <span class=\"comment\">// virtual ~Abstra_class() =0;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">virtual</span> ~Abstra_class() &#123; <span class=\"keyword\">delete</span> _mumble;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"use ~Abstra_class:\"</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">interface</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//virtual void interface() const &#123; cout&lt;&lt;\"use interface Abstra_class:\";&#125;</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">mumble</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> _mumble;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span>  <span class=\"title\">ii</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>=<span class=\"number\">0</span>;<span class=\"comment\">//ensure is a abstra class</span></span><br><span class=\"line\">\t\tAbstra_class()&#123;_mumble=<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">4</span>];<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"construct:Abs..\"</span>;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>* _mumble;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> Abstra_class::interface() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">dev</span> :</span> <span class=\"keyword\">public</span> Abstra_class &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t~dev() &#123;dd=<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">\t\t\t\tdev()&#123;dd=<span class=\"number\">3</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">useA</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">                Abstra_class::interface();<span class=\"comment\">//即使可以这样，但是链接失败，即因该函数的引用为0</span></span><br><span class=\"line\">\t\t           dd=<span class=\"number\">4</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">interface</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(dd==<span class=\"number\">4</span>)<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"\\nre\\n\"</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//Abstra_class::interface();</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">ii</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"is implenment\"</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> dd;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t  dev ddd;</span><br><span class=\"line\">\t\tddd.useA();</span><br><span class=\"line\">\t\tddd.interface();</span><br><span class=\"line\">\tAbstra_class *pt=&amp;ddd;</span><br><span class=\"line\">\tpt-&gt;interface();</span><br><span class=\"line\">\t  <span class=\"comment\">//  Abstra_class::interface();</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  输出了两次re,说明可以通过虚拟机制调用它；interface在这里被内联的定义了空的函数，它不算pure了，所以上述说法感觉存在问题。。。<br>　注意，因为在每一个derived class　destructor会被扩展，以静态方式调用每一个virtual base class 和上一层的desturctor,<br>     所以只要缺少任何一个 base destructor定义则链接失败　，所以需要定义pure virtual destructor<br>      一个比较好的替代方式就是不要把vitual dect~定义为pure<br>      考虑到成本，不要把所有的函数都定以为virtual</p>\n<p>3)虚拟规格的存在：<br>　　　　在virtual func要不要为const ,主要看要不要对date member做修改<br>所以不要随便定义为pure,virtual const,毕竟效率</p>\n<h4 id=\"考虑几种情况下的构造情况：\"><a href=\"#考虑几种情况下的构造情况：\" class=\"headerlink\" title=\"考虑几种情况下的构造情况：\"></a>考虑几种情况下的构造情况：</h4><h5 id=\"一、无继承情况下对象构造几种方式：\"><a href=\"#一、无继承情况下对象构造几种方式：\" class=\"headerlink\" title=\"一、无继承情况下对象构造几种方式：\"></a>一、无继承情况下对象构造几种方式：</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point global;　<span class=\"comment\">//周期：程序的生命周期，exit前</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\">Point <span class=\"title\">foobar</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   Point local;　<span class=\"comment\">//此函数的周期，调用默认构造函数但是不会初始化成员</span></span><br><span class=\"line\">   Point *heap=<span class=\"keyword\">new</span> Point;<span class=\"comment\">//delete 前，调用默认构造函数，但不会初始化成员</span></span><br><span class=\"line\">   *heap=local;<span class=\"comment\">//local若未调用用户初始化的构造函数，则warning,调用拷贝赋值函数，maybe 位搬移</span></span><br><span class=\"line\">   <span class=\"keyword\">delete</span> heap;<span class=\"comment\">//默认析构函数</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> local;<span class=\"comment\">//maybe拷贝构造或者位搬移</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>考虑这几个对象的声明周期</li>\n<li>在c中，global会被放入bss中，未初始化，但是c++中所有的全局对象被当做“初始化过的数据”，会调用constructor函数　可以测试一下</li>\n<li>一般情况下，c++默认为类生成：default constructor,destructor,copy constructor,copy assignment operator<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\tPoint ()&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"in constructor \"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">\t\t\t~Point() &#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"in destructor\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Point glo;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>显然在定义Point glo的时候构造函数是会调用的</p>\n<p>１、抽象数据类型：<br>　　根据需要决定是否写constructor destructor或者默认的就足够了<br>　　　global类型的对象直到程序激活才调用构造函数<br>　　　显性的初始化列表比将构造函数扩展为inline效率更高，后者需要赋值等，看下面例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span>:  </span><br><span class=\"line\">    Point(<span class=\"keyword\">double</span> x = <span class=\"number\">0.0</span>, <span class=\"keyword\">double</span> y = <span class=\"number\">0.0</span>, <span class=\"keyword\">double</span> z = <span class=\"number\">0.0</span>) :_x(x), _y(y), _z(z)&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; _x &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; _y &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; _z &lt;&lt; <span class=\"built_in\">endl</span>; &#125;;  </span><br><span class=\"line\"><span class=\"keyword\">private</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">double</span> _x, _y, _z;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">    Point local1 = &#123; <span class=\"number\">1.1</span>, <span class=\"number\">1.2</span>, <span class=\"number\">1.3</span> &#125;;<span class=\"comment\">//用g++ --std=c++11可以，若为double a=1.5; ..=&#123;a,...&#125;变量形式则不行（c++11可以） </span></span><br><span class=\"line\">    local1.print();  </span><br><span class=\"line\">  </span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125; ``` </span><br><span class=\"line\">而在显性初始化列表（<span class=\"keyword\">explicit</span> initialization <span class=\"built_in\">list</span>)-&gt;xxx=&#123;yyy&#125;;使用时较快是如下原因：  </span><br><span class=\"line\">函数的activation record 被放进程序的堆栈时，initializatioin <span class=\"built_in\">list</span> 中的常量就可以被放进local1的内存中了;  </span><br><span class=\"line\">但是<span class=\"keyword\">explicit</span> initialization <span class=\"built_in\">list</span>带来三个缺点：</span><br><span class=\"line\">+ 只有当<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">member</span> 都是<span class=\"title\">public</span>时才生效，这点实验<span class=\"title\">private</span>时也可以  </span></span><br><span class=\"line\"><span class=\"class\">+ 只能在&#123;</span> &#125;中指定常量，因为在编译期间进行评估求值</span><br><span class=\"line\">+ 由于编译器为自动施行，所以失败的可能性更高  </span><br><span class=\"line\">看一下汇编代码：</span><br><span class=\"line\">```cpp</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span>:  </span><br><span class=\"line\">    Point(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>, <span class=\"keyword\">int</span>  y = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> z = <span class=\"number\">0</span>) :_x(x), _y(y), _z(z)&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n <figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x400938</span> push   <span class=\"symbol\">%rbp</span></span><br><span class=\"line\"><span class=\"number\">0x400939</span> mov    <span class=\"symbol\">%rsp</span>,<span class=\"symbol\">%rbp</span></span><br><span class=\"line\"><span class=\"number\">0x40093c</span> mov    <span class=\"symbol\">%rdi</span>,<span class=\"number\">-0</span><span class=\"keyword\">x</span><span class=\"number\">8</span>(<span class=\"symbol\">%rbp</span>)</span><br><span class=\"line\"><span class=\"number\">0x400940</span> mov    <span class=\"symbol\">%esi</span>,<span class=\"number\">-0</span>xc(<span class=\"symbol\">%rbp</span>)</span><br><span class=\"line\"><span class=\"number\">0x400943</span> mov    <span class=\"symbol\">%edx</span>,<span class=\"number\">-0</span><span class=\"keyword\">x</span><span class=\"number\">10</span>(<span class=\"symbol\">%rbp</span>)</span><br><span class=\"line\"><span class=\"number\">0x400946</span> mov    <span class=\"symbol\">%ecx</span>,<span class=\"number\">-0</span><span class=\"keyword\">x</span><span class=\"number\">14</span>(<span class=\"symbol\">%rbp</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; _x &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; _y &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; _z &lt;&lt; <span class=\"built_in\">endl</span>; &#125;;  </span><br><span class=\"line\"><span class=\"keyword\">private</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> _x, _y, _z;  </span><br><span class=\"line\">&#125;;   </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">int</span>  a=<span class=\"number\">1</span>;\t</span><br><span class=\"line\">    Point local1 = &#123; a, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x4008a4</span> <span class=\"keyword\">mov</span>    -<span class=\"number\">0x24</span>(%rbp),%esi</span><br><span class=\"line\"><span class=\"number\">0x4008a7</span> <span class=\"keyword\">lea</span>    -<span class=\"number\">0x20</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x4008ab</span> <span class=\"keyword\">mov</span>    <span class=\"number\">$0</span>x5,%ecx</span><br><span class=\"line\"><span class=\"number\">0x4008b0</span> <span class=\"keyword\">mov</span>    <span class=\"number\">$0</span>x4,%edx</span><br><span class=\"line\"><span class=\"number\">0x4008b5</span> <span class=\"keyword\">mov</span>    %rax,%rdi</span><br><span class=\"line\"><span class=\"number\">0x4008b8</span> callq  <span class=\"number\">0x400938</span> &lt;Point::Point(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)&gt;</span><br></pre></td></tr></table></figure>\n<p>上述讲的activation record是：  </p>\n<ul>\n<li>Locals to the callee</li>\n<li>Return address to the caller</li>\n<li><p>Parameters of the callee<br>从上述的汇编代码可以看到，在做显示初始化列表时将常量值赋给ecx等两个寄存器，接着调用构造函数，构造函数将寄存器的内容赋给成员，而其实采用Point local2;这种直接调用构造函数的发式也是如此，且和在构造函数中赋值给成员时转换的汇编相同，所以不是很理解这块的区别，在g++ c++11是如此表现的    </p>\n<h5 id=\"２、为继承做准备：\"><a href=\"#２、为继承做准备：\" class=\"headerlink\" title=\"２、为继承做准备：\"></a>２、为继承做准备：</h5><p>继承可能用到多态，此时需要使用virtual ,那就会带来constructor等函数中加入对vptr的初始化（copy constructor等）<br>c++标准会要求编译器尽量延迟对nontrivial members的实际合成 操作，直到真正遇到其使用场合：这里trivial意思是无意义，这个trivial和non-trivial是对类的四种函数来说的：</p>\n<p>  构造函数(ctor)<br>  复制构造函数(copy)<br>  赋值函数(assignment)<br>  析构函数(dtor)  </p>\n</li>\n</ul>\n<p>如果至少满足下面3条里的一条：</p>\n<pre><code>显式(explict)定义了这四种函数。\n类里有非静态非POD的数据成员。\n有基类。\n</code></pre><p>那么上面的四种函数是non-trivial函数，比如叫non-trivial ctor、non-trivial copy…，也就是说有意义的函数，里面有一下必要的操作，比如类成员的初始化，释放内存等。   </p>\n<h5 id=\"二、继承体系下的对象构造：\"><a href=\"#二、继承体系下的对象构造：\" class=\"headerlink\" title=\"二、继承体系下的对象构造：\"></a>二、继承体系下的对象构造：</h5><p>constructor函数中的隐藏代码，  </p>\n<ol>\n<li>初始化列表  </li>\n<li>member的默认构造函数,若该member未出现在初始化列表中</li>\n<li>vptr，在1,2之前，指向vtable   </li>\n<li>base class constructor  1,2,3之前，以声明顺序为顺序，若在member initialization list中，则应传递参数，否则在1,2,3前加入其默认构造函数。多继承时可能this指针调</li>\n<li>virtual base class constructor，从左到右，从最深到最浅 ，同4，若在list中有则用，否则。。  </li>\n</ol>\n<p>例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">   Point (<span class=\"keyword\">float</span> x=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> y=<span class=\"number\">0.0</span>);  </span><br><span class=\"line\">   Point(<span class=\"keyword\">const</span> Point&amp;);</span><br><span class=\"line\">   Point&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Point&amp;);</span><br><span class=\"line\">   <span class=\"keyword\">virtual</span> ~Point();</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">z</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">0.0</span>;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"keyword\">float</span> _x,_y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">line</span> &#123;</span></span><br><span class=\"line\">   Point _begin,_end;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">     Line(....);</span><br><span class=\"line\">     Line(...);</span><br><span class=\"line\">     &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>line的默认析构函数会被合成，但是无意义，当然它的member的默认析构函数会被加入。。。其他类似</p>\n<h5 id=\"三、虚拟继承：\"><a href=\"#三、虚拟继承：\" class=\"headerlink\" title=\"三、虚拟继承：\"></a>三、虚拟继承：</h5><ul>\n<li><p>考虑下面的例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> Point&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">       Point3d(<span class=\"keyword\">float</span> x=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> y=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> z=<span class=\"number\">0.0</span>):Point(x,y),_z(z)&#123;&#125;</span><br><span class=\"line\">       Point3d(<span class=\"keyword\">const</span> Point3d&amp; rhs):point(rhs),_z(rhs._z)&#123;&#125;</span><br><span class=\"line\">       ~Point3d();</span><br><span class=\"line\">       Point3d&amp; <span class=\"keyword\">operator</span>=...</span><br><span class=\"line\">       <span class=\"comment\">//..</span></span><br><span class=\"line\">      proteced:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _z;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>传统的如上面的扩充构造函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>-&gt;Point(:Point(x,y);</span><br><span class=\"line\"><span class=\"keyword\">this</span>-&gt;_vptr_Point3d = vtbl_Point3d;</span><br><span class=\"line\"><span class=\"keyword\">this</span>-&gt;_vptr_point3d_point=_vtbl_point3d_point;</span><br><span class=\"line\"><span class=\"keyword\">this</span>-&gt;_z=rhs_z;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br></pre></td></tr></table></figure>\n<p>但是在这里，虚拟继承这显然不够准确：　　<br>考虑当出现菱形继承：　　</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex</span>:</span><span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Point;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex3d</span>:</span><span class=\"keyword\">public</span> Point3d,<span class=\"keyword\">public</span> Vertex&#123;;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pvertex</span>:</span><span class=\"keyword\">public</span> Vertex3d&#123;;&#125;;'</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  那作为被共享的Point subobject应该由最底层的如Vertex3d来初始化：<br>  而最底层显然也会初始化Point3d和vertex,并调用他们的构造函数；如果他们的构造函数不加限制，就会又调用Point的构造，导致错误；　　<br>  所以应该做限制，如下：<br>  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vertex3d::Vertex3d(Vertex3d *<span class=\"keyword\">this</span>,<span class=\"keyword\">bool</span> __most_derived,<span class=\"keyword\">float</span> x,<span class=\"keyword\">float</span> y,<span class=\"keyword\">float</span> z)&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(__most_derived!=<span class=\"literal\">false</span>)<span class=\"comment\">//判断是否为最底层</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>-&gt;Point::Point(x,y);<span class=\"comment\">//是则构造最上层的</span></span><br><span class=\"line\">   <span class=\"comment\">//调用上一层的base classes</span></span><br><span class=\"line\">   <span class=\"comment\">//设定__most_derived为false</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>-&gt;Point3d::Ponint3d(..);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>而在<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point3d::Point3d(Point3d* <span class=\"keyword\">this</span>,...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(___most_derived!=<span class=\"literal\">false</span>)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>-&gt;Point::Point(x,y);</span><br><span class=\"line\">      ....</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以最底层的构造函数等会限制中间层对最上层的构造</p>\n<ul>\n<li>思考：</li>\n<li>当obj只是某个完整的obj的子obj时，则不用调用virtual base class constructor:,如上，那就产生了一种提高效率的方式：</li>\n<li>将构造函数分割为obj和subobj,，前者为完整版本的obj，自然要调用所有，包括基类的构造，后者不用，这种分裂可以提高效率</li>\n</ul>\n<h4 id=\"vptr初始化语意\"><a href=\"#vptr初始化语意\" class=\"headerlink\" title=\"vptr初始化语意\"></a>vptr初始化语意</h4><ul>\n<li>题外，这本书总喜欢讨论特殊的情况，哭笑，下面也是，在构造函数中调用虚函数222</li>\n<li>主要讨论vptr什么时候初始化合适，以及为什么</li>\n<li><p>constructor调用顺序：考虑：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex</span>:</span><span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Point;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex3d</span>:</span><span class=\"keyword\">public</span> Point3d,<span class=\"keyword\">public</span> Vertex&#123;;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pvertex</span>:</span><span class=\"keyword\">public</span> Vertex3d&#123;;&#125;;'</span><br></pre></td></tr></table></figure>\n<p>当一个PVertex对象被构造时，构造函数顺序为：　　<br>Point<br>Point3d<br>Vertex<br>Vertex3d<br>Pvertex  </p>\n</li>\n<li>假设这个继承体系中的每一个类都定义了一个virtual func size()，该函数负责传回class的大小；如果我们写：<br>Pvertex pv;<br>Point3d p3d;<br>Point  *pt=&pv;<br>那么这个调用pt-&gt;size()传回PVertex的大小，而<br>pt=&p3d; pt-&gt;size()则传回p3d的大小；</li>\n<li><p>更进一步，特殊情况：<br>当在构造函数中调用这个操作时，如在point3d构造函数中调用时，是选择哪个class的size,毕竟现在正在构造point3d,答案是point3d的</p>\n<ul>\n<li>考虑如何使得上述生效?</li>\n<li>静态调用Point3d::size()或者bnalalla</li>\n<li>最后，利用vptr虚拟机制，即要在调用size之前初始化好其class对应的vptr</li>\n<li>总结：在这种情况下，vptr在base class constructor 调用之后，在程序员代码之前（如size),或是初始化列表所列的member初始化操作前</li>\n<li>更好的，分割constructor为完整obj和subobj</li>\n</ul>\n<h3 id=\"对象复制语意学\"><a href=\"#对象复制语意学\" class=\"headerlink\" title=\"对象复制语意学\"></a>对象复制语意学</h3><h4 id=\"复制函数什么时候会被合成和使用\"><a href=\"#复制函数什么时候会被合成和使用\" class=\"headerlink\" title=\"复制函数什么时候会被合成和使用\"></a>复制函数什么时候会被合成和使用</h4></li>\n<li>前言，当你设计一个类，并以一个对象复制给另一个对象时，有三种选择：  <ul>\n<li>什么也不做，实行默认行为  </li>\n<li>提供一个显性拷贝函数</li>\n<li>拒绝，只需要把复制函数声明为private就可以 </li>\n</ul>\n</li>\n<li>考虑默认的行为：<ul>\n<li>bitwise copy行为，当不出现一下情况时，甚至不会调用复制函数，而是做bitwise copy</li>\n<li>而当出现以下行为时，调用默认的copy assignment operator函数，并合成相关操作：　　<ol>\n<li>当class中有mem obj，这个obj有一个copy ass operaator</li>\n<li>当类的基类有copy assi opera..</li>\n<li>类带virtual func</li>\n<li>继承自一个virtual base class  </li>\n</ol>\n</li>\n</ul>\n</li>\n<li>写一个显性的复制函数：  <ul>\n<li>在发生上述情况时，编译器也会像合成构造函数一样在显性的复制函数中加东西</li>\n<li>而继上面的，Point共享基类，编译器如何能在Point3d和Vertex的copy assignment operator中压抑point的copy assignment operator呢?</li>\n<li>书中的后面有些难以理解，等后面再探索吧，哎时间有限。。<h3 id=\"对象的功能\"><a href=\"#对象的功能\" class=\"headerlink\" title=\"对象的功能\"></a>对象的功能</h3>测试对象构造和拷贝的成本，在从简单形式，单一继承，到多重继承，虚拟继承等情况下的时间复杂度<h3 id=\"解构语意学\"><a href=\"#解构语意学\" class=\"headerlink\" title=\"解构语意学\"></a>解构语意学</h3></li>\n</ul>\n</li>\n<li>析构函数并不会总是被合成出来，更别提调用；</li>\n<li>只有在类内带的member object或者自己的base class带有destructor，编译器才会合成一个析构函数，否则被视为不需要或者不用合成调用</li>\n<li>析构函数没必要和构造函数对称</li>\n<li>析构函数一般有以下顺序：<ul>\n<li>先调用最底层子类析构函数，接着往上，直到基类</li>\n<li>析构函数本身在被执行时，vprt会在程序员代码前被执行</li>\n<li>若class拥有member class object ,而后者拥有destructor,则他们会以其声明顺序相反顺序被调用</li>\n<li>如果object内带一个vptr,则首先重设相关的virtual table</li>\n<li>若有任何直接的非虚基类拥有析构函数，则同上</li>\n<li>若有虚基类，则按照构造顺序相反顺序调用</li>\n</ul>\n</li>\n<li>类似于构造函数，可以分裂</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"构造和析构函数语义学\"><a href=\"#构造和析构函数语义学\" class=\"headerlink\" title=\"构造和析构函数语义学\"></a>构造和析构函数语义学</h3><h4 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h4><p>即使是abstract base class也可能需要手动写constructor,de…,关键是看它有没有non satic data member","more":"<br>例如:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Abstract_class</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">       <span class=\"keyword\">virtual</span> ~Abstract_base() = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">interface</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * <span class=\"title\">mumble</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> _mumble;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">       <span class=\"keyword\">char</span> *_mumble;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>  上述例子，该抽象类本身不能被实例化，但是可以被继承，被继承时在构造时必须初始化 “mumble”,此时就需要用它的默认构造函数，所以必须为这个抽象类写一个构造函数；   </p>\n<h4 id=\"2-纯虚函数的存在：\"><a href=\"#2-纯虚函数的存在：\" class=\"headerlink\" title=\"2. 纯虚函数的存在：\"></a>2. 纯虚函数的存在：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Abstra_class</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> :</span><br><span class=\"line\">\t   <span class=\"comment\">// virtual ~Abstra_class() =0;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">virtual</span> ~Abstra_class() &#123; <span class=\"keyword\">delete</span> _mumble;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"use ~abstra_class\"</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//virtual void interface() const=0;</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">interface</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"use interface Abstra_class:\"</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">mumble</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> _mumble;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tAbstra_class()&#123;_mumble=<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">4</span>];<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"construct:Abs..\"</span>;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>* _mumble;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">dev</span> :</span> <span class=\"keyword\">public</span> Abstra_class &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t~dev() &#123;dd=<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">\t\t\t\tdev()&#123;dd=<span class=\"number\">3</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">useA</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">               Abstra_class::interface();<span class=\"comment\">//即使可以这样，但是链接失败，即因该函数的定义=0,重新加上定义使之不为pure就ok了</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">interface</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">if</span>(dd==<span class=\"number\">4</span>)<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"re\"</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> dd;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t  dev ddd;</span><br><span class=\"line\">\t\tddd.useA();</span><br><span class=\"line\">\t\tddd.interface();</span><br><span class=\"line\">\t  <span class=\"comment\">//  Abstra_class::interface();</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：construct:Abs..use interface Abstra_class:use ~Abstra_class: </p>\n<p>　“可以定义和调用pure virtual func ,但是只能被静态的调用，而不能通过虚拟机制 “这个在g++上实验了下，发现：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Abstra_class</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> :</span><br><span class=\"line\">\t   <span class=\"comment\">// virtual ~Abstra_class() =0;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">virtual</span> ~Abstra_class() &#123; <span class=\"keyword\">delete</span> _mumble;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"use ~Abstra_class:\"</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">interface</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//virtual void interface() const &#123; cout&lt;&lt;\"use interface Abstra_class:\";&#125;</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">mumble</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> _mumble;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span>  <span class=\"title\">ii</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>=<span class=\"number\">0</span>;<span class=\"comment\">//ensure is a abstra class</span></span><br><span class=\"line\">\t\tAbstra_class()&#123;_mumble=<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">4</span>];<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"construct:Abs..\"</span>;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span>* _mumble;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> Abstra_class::interface() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">dev</span> :</span> <span class=\"keyword\">public</span> Abstra_class &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t~dev() &#123;dd=<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">\t\t\t\tdev()&#123;dd=<span class=\"number\">3</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">useA</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">                Abstra_class::interface();<span class=\"comment\">//即使可以这样，但是链接失败，即因该函数的引用为0</span></span><br><span class=\"line\">\t\t           dd=<span class=\"number\">4</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">interface</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(dd==<span class=\"number\">4</span>)<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"\\nre\\n\"</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//Abstra_class::interface();</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">ii</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"is implenment\"</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> dd;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t  dev ddd;</span><br><span class=\"line\">\t\tddd.useA();</span><br><span class=\"line\">\t\tddd.interface();</span><br><span class=\"line\">\tAbstra_class *pt=&amp;ddd;</span><br><span class=\"line\">\tpt-&gt;interface();</span><br><span class=\"line\">\t  <span class=\"comment\">//  Abstra_class::interface();</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  输出了两次re,说明可以通过虚拟机制调用它；interface在这里被内联的定义了空的函数，它不算pure了，所以上述说法感觉存在问题。。。<br>　注意，因为在每一个derived class　destructor会被扩展，以静态方式调用每一个virtual base class 和上一层的desturctor,<br>     所以只要缺少任何一个 base destructor定义则链接失败　，所以需要定义pure virtual destructor<br>      一个比较好的替代方式就是不要把vitual dect~定义为pure<br>      考虑到成本，不要把所有的函数都定以为virtual</p>\n<p>3)虚拟规格的存在：<br>　　　　在virtual func要不要为const ,主要看要不要对date member做修改<br>所以不要随便定义为pure,virtual const,毕竟效率</p>\n<h4 id=\"考虑几种情况下的构造情况：\"><a href=\"#考虑几种情况下的构造情况：\" class=\"headerlink\" title=\"考虑几种情况下的构造情况：\"></a>考虑几种情况下的构造情况：</h4><h5 id=\"一、无继承情况下对象构造几种方式：\"><a href=\"#一、无继承情况下对象构造几种方式：\" class=\"headerlink\" title=\"一、无继承情况下对象构造几种方式：\"></a>一、无继承情况下对象构造几种方式：</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point global;　<span class=\"comment\">//周期：程序的生命周期，exit前</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\">Point <span class=\"title\">foobar</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   Point local;　<span class=\"comment\">//此函数的周期，调用默认构造函数但是不会初始化成员</span></span><br><span class=\"line\">   Point *heap=<span class=\"keyword\">new</span> Point;<span class=\"comment\">//delete 前，调用默认构造函数，但不会初始化成员</span></span><br><span class=\"line\">   *heap=local;<span class=\"comment\">//local若未调用用户初始化的构造函数，则warning,调用拷贝赋值函数，maybe 位搬移</span></span><br><span class=\"line\">   <span class=\"keyword\">delete</span> heap;<span class=\"comment\">//默认析构函数</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> local;<span class=\"comment\">//maybe拷贝构造或者位搬移</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>考虑这几个对象的声明周期</li>\n<li>在c中，global会被放入bss中，未初始化，但是c++中所有的全局对象被当做“初始化过的数据”，会调用constructor函数　可以测试一下</li>\n<li>一般情况下，c++默认为类生成：default constructor,destructor,copy constructor,copy assignment operator<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\tPoint ()&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"in constructor \"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">\t\t\t~Point() &#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"in destructor\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Point glo;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>显然在定义Point glo的时候构造函数是会调用的</p>\n<p>１、抽象数据类型：<br>　　根据需要决定是否写constructor destructor或者默认的就足够了<br>　　　global类型的对象直到程序激活才调用构造函数<br>　　　显性的初始化列表比将构造函数扩展为inline效率更高，后者需要赋值等，看下面例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span>:  </span><br><span class=\"line\">    Point(<span class=\"keyword\">double</span> x = <span class=\"number\">0.0</span>, <span class=\"keyword\">double</span> y = <span class=\"number\">0.0</span>, <span class=\"keyword\">double</span> z = <span class=\"number\">0.0</span>) :_x(x), _y(y), _z(z)&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; _x &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; _y &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; _z &lt;&lt; <span class=\"built_in\">endl</span>; &#125;;  </span><br><span class=\"line\"><span class=\"keyword\">private</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">double</span> _x, _y, _z;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">    Point local1 = &#123; <span class=\"number\">1.1</span>, <span class=\"number\">1.2</span>, <span class=\"number\">1.3</span> &#125;;<span class=\"comment\">//用g++ --std=c++11可以，若为double a=1.5; ..=&#123;a,...&#125;变量形式则不行（c++11可以） </span></span><br><span class=\"line\">    local1.print();  </span><br><span class=\"line\">  </span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125; ``` </span><br><span class=\"line\">而在显性初始化列表（<span class=\"keyword\">explicit</span> initialization <span class=\"built_in\">list</span>)-&gt;xxx=&#123;yyy&#125;;使用时较快是如下原因：  </span><br><span class=\"line\">函数的activation record 被放进程序的堆栈时，initializatioin <span class=\"built_in\">list</span> 中的常量就可以被放进local1的内存中了;  </span><br><span class=\"line\">但是<span class=\"keyword\">explicit</span> initialization <span class=\"built_in\">list</span>带来三个缺点：</span><br><span class=\"line\">+ 只有当<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">member</span> 都是<span class=\"title\">public</span>时才生效，这点实验<span class=\"title\">private</span>时也可以  </span></span><br><span class=\"line\"><span class=\"class\">+ 只能在&#123;</span> &#125;中指定常量，因为在编译期间进行评估求值</span><br><span class=\"line\">+ 由于编译器为自动施行，所以失败的可能性更高  </span><br><span class=\"line\">看一下汇编代码：</span><br><span class=\"line\">```cpp</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span>:  </span><br><span class=\"line\">    Point(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>, <span class=\"keyword\">int</span>  y = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> z = <span class=\"number\">0</span>) :_x(x), _y(y), _z(z)&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n <figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x400938</span> push   <span class=\"symbol\">%rbp</span></span><br><span class=\"line\"><span class=\"number\">0x400939</span> mov    <span class=\"symbol\">%rsp</span>,<span class=\"symbol\">%rbp</span></span><br><span class=\"line\"><span class=\"number\">0x40093c</span> mov    <span class=\"symbol\">%rdi</span>,<span class=\"number\">-0</span><span class=\"keyword\">x</span><span class=\"number\">8</span>(<span class=\"symbol\">%rbp</span>)</span><br><span class=\"line\"><span class=\"number\">0x400940</span> mov    <span class=\"symbol\">%esi</span>,<span class=\"number\">-0</span>xc(<span class=\"symbol\">%rbp</span>)</span><br><span class=\"line\"><span class=\"number\">0x400943</span> mov    <span class=\"symbol\">%edx</span>,<span class=\"number\">-0</span><span class=\"keyword\">x</span><span class=\"number\">10</span>(<span class=\"symbol\">%rbp</span>)</span><br><span class=\"line\"><span class=\"number\">0x400946</span> mov    <span class=\"symbol\">%ecx</span>,<span class=\"number\">-0</span><span class=\"keyword\">x</span><span class=\"number\">14</span>(<span class=\"symbol\">%rbp</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; _x &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; _y &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; _z &lt;&lt; <span class=\"built_in\">endl</span>; &#125;;  </span><br><span class=\"line\"><span class=\"keyword\">private</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> _x, _y, _z;  </span><br><span class=\"line\">&#125;;   </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">int</span>  a=<span class=\"number\">1</span>;\t</span><br><span class=\"line\">    Point local1 = &#123; a, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x4008a4</span> <span class=\"keyword\">mov</span>    -<span class=\"number\">0x24</span>(%rbp),%esi</span><br><span class=\"line\"><span class=\"number\">0x4008a7</span> <span class=\"keyword\">lea</span>    -<span class=\"number\">0x20</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x4008ab</span> <span class=\"keyword\">mov</span>    <span class=\"number\">$0</span>x5,%ecx</span><br><span class=\"line\"><span class=\"number\">0x4008b0</span> <span class=\"keyword\">mov</span>    <span class=\"number\">$0</span>x4,%edx</span><br><span class=\"line\"><span class=\"number\">0x4008b5</span> <span class=\"keyword\">mov</span>    %rax,%rdi</span><br><span class=\"line\"><span class=\"number\">0x4008b8</span> callq  <span class=\"number\">0x400938</span> &lt;Point::Point(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)&gt;</span><br></pre></td></tr></table></figure>\n<p>上述讲的activation record是：  </p>\n<ul>\n<li>Locals to the callee</li>\n<li>Return address to the caller</li>\n<li><p>Parameters of the callee<br>从上述的汇编代码可以看到，在做显示初始化列表时将常量值赋给ecx等两个寄存器，接着调用构造函数，构造函数将寄存器的内容赋给成员，而其实采用Point local2;这种直接调用构造函数的发式也是如此，且和在构造函数中赋值给成员时转换的汇编相同，所以不是很理解这块的区别，在g++ c++11是如此表现的    </p>\n<h5 id=\"２、为继承做准备：\"><a href=\"#２、为继承做准备：\" class=\"headerlink\" title=\"２、为继承做准备：\"></a>２、为继承做准备：</h5><p>继承可能用到多态，此时需要使用virtual ,那就会带来constructor等函数中加入对vptr的初始化（copy constructor等）<br>c++标准会要求编译器尽量延迟对nontrivial members的实际合成 操作，直到真正遇到其使用场合：这里trivial意思是无意义，这个trivial和non-trivial是对类的四种函数来说的：</p>\n<p>  构造函数(ctor)<br>  复制构造函数(copy)<br>  赋值函数(assignment)<br>  析构函数(dtor)  </p>\n</li>\n</ul>\n<p>如果至少满足下面3条里的一条：</p>\n<pre><code>显式(explict)定义了这四种函数。\n类里有非静态非POD的数据成员。\n有基类。\n</code></pre><p>那么上面的四种函数是non-trivial函数，比如叫non-trivial ctor、non-trivial copy…，也就是说有意义的函数，里面有一下必要的操作，比如类成员的初始化，释放内存等。   </p>\n<h5 id=\"二、继承体系下的对象构造：\"><a href=\"#二、继承体系下的对象构造：\" class=\"headerlink\" title=\"二、继承体系下的对象构造：\"></a>二、继承体系下的对象构造：</h5><p>constructor函数中的隐藏代码，  </p>\n<ol>\n<li>初始化列表  </li>\n<li>member的默认构造函数,若该member未出现在初始化列表中</li>\n<li>vptr，在1,2之前，指向vtable   </li>\n<li>base class constructor  1,2,3之前，以声明顺序为顺序，若在member initialization list中，则应传递参数，否则在1,2,3前加入其默认构造函数。多继承时可能this指针调</li>\n<li>virtual base class constructor，从左到右，从最深到最浅 ，同4，若在list中有则用，否则。。  </li>\n</ol>\n<p>例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">   Point (<span class=\"keyword\">float</span> x=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> y=<span class=\"number\">0.0</span>);  </span><br><span class=\"line\">   Point(<span class=\"keyword\">const</span> Point&amp;);</span><br><span class=\"line\">   Point&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Point&amp;);</span><br><span class=\"line\">   <span class=\"keyword\">virtual</span> ~Point();</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">z</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">0.0</span>;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"keyword\">float</span> _x,_y;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">line</span> &#123;</span></span><br><span class=\"line\">   Point _begin,_end;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">     Line(....);</span><br><span class=\"line\">     Line(...);</span><br><span class=\"line\">     &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>line的默认析构函数会被合成，但是无意义，当然它的member的默认析构函数会被加入。。。其他类似</p>\n<h5 id=\"三、虚拟继承：\"><a href=\"#三、虚拟继承：\" class=\"headerlink\" title=\"三、虚拟继承：\"></a>三、虚拟继承：</h5><ul>\n<li><p>考虑下面的例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> Point&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">       Point3d(<span class=\"keyword\">float</span> x=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> y=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> z=<span class=\"number\">0.0</span>):Point(x,y),_z(z)&#123;&#125;</span><br><span class=\"line\">       Point3d(<span class=\"keyword\">const</span> Point3d&amp; rhs):point(rhs),_z(rhs._z)&#123;&#125;</span><br><span class=\"line\">       ~Point3d();</span><br><span class=\"line\">       Point3d&amp; <span class=\"keyword\">operator</span>=...</span><br><span class=\"line\">       <span class=\"comment\">//..</span></span><br><span class=\"line\">      proteced:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _z;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>传统的如上面的扩充构造函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>-&gt;Point(:Point(x,y);</span><br><span class=\"line\"><span class=\"keyword\">this</span>-&gt;_vptr_Point3d = vtbl_Point3d;</span><br><span class=\"line\"><span class=\"keyword\">this</span>-&gt;_vptr_point3d_point=_vtbl_point3d_point;</span><br><span class=\"line\"><span class=\"keyword\">this</span>-&gt;_z=rhs_z;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br></pre></td></tr></table></figure>\n<p>但是在这里，虚拟继承这显然不够准确：　　<br>考虑当出现菱形继承：　　</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex</span>:</span><span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Point;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex3d</span>:</span><span class=\"keyword\">public</span> Point3d,<span class=\"keyword\">public</span> Vertex&#123;;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pvertex</span>:</span><span class=\"keyword\">public</span> Vertex3d&#123;;&#125;;'</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  那作为被共享的Point subobject应该由最底层的如Vertex3d来初始化：<br>  而最底层显然也会初始化Point3d和vertex,并调用他们的构造函数；如果他们的构造函数不加限制，就会又调用Point的构造，导致错误；　　<br>  所以应该做限制，如下：<br>  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vertex3d::Vertex3d(Vertex3d *<span class=\"keyword\">this</span>,<span class=\"keyword\">bool</span> __most_derived,<span class=\"keyword\">float</span> x,<span class=\"keyword\">float</span> y,<span class=\"keyword\">float</span> z)&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(__most_derived!=<span class=\"literal\">false</span>)<span class=\"comment\">//判断是否为最底层</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>-&gt;Point::Point(x,y);<span class=\"comment\">//是则构造最上层的</span></span><br><span class=\"line\">   <span class=\"comment\">//调用上一层的base classes</span></span><br><span class=\"line\">   <span class=\"comment\">//设定__most_derived为false</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>-&gt;Point3d::Ponint3d(..);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>而在<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point3d::Point3d(Point3d* <span class=\"keyword\">this</span>,...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(___most_derived!=<span class=\"literal\">false</span>)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>-&gt;Point::Point(x,y);</span><br><span class=\"line\">      ....</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以最底层的构造函数等会限制中间层对最上层的构造</p>\n<ul>\n<li>思考：</li>\n<li>当obj只是某个完整的obj的子obj时，则不用调用virtual base class constructor:,如上，那就产生了一种提高效率的方式：</li>\n<li>将构造函数分割为obj和subobj,，前者为完整版本的obj，自然要调用所有，包括基类的构造，后者不用，这种分裂可以提高效率</li>\n</ul>\n<h4 id=\"vptr初始化语意\"><a href=\"#vptr初始化语意\" class=\"headerlink\" title=\"vptr初始化语意\"></a>vptr初始化语意</h4><ul>\n<li>题外，这本书总喜欢讨论特殊的情况，哭笑，下面也是，在构造函数中调用虚函数222</li>\n<li>主要讨论vptr什么时候初始化合适，以及为什么</li>\n<li><p>constructor调用顺序：考虑：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex</span>:</span><span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Point;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex3d</span>:</span><span class=\"keyword\">public</span> Point3d,<span class=\"keyword\">public</span> Vertex&#123;;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pvertex</span>:</span><span class=\"keyword\">public</span> Vertex3d&#123;;&#125;;'</span><br></pre></td></tr></table></figure>\n<p>当一个PVertex对象被构造时，构造函数顺序为：　　<br>Point<br>Point3d<br>Vertex<br>Vertex3d<br>Pvertex  </p>\n</li>\n<li>假设这个继承体系中的每一个类都定义了一个virtual func size()，该函数负责传回class的大小；如果我们写：<br>Pvertex pv;<br>Point3d p3d;<br>Point  *pt=&pv;<br>那么这个调用pt-&gt;size()传回PVertex的大小，而<br>pt=&p3d; pt-&gt;size()则传回p3d的大小；</li>\n<li><p>更进一步，特殊情况：<br>当在构造函数中调用这个操作时，如在point3d构造函数中调用时，是选择哪个class的size,毕竟现在正在构造point3d,答案是point3d的</p>\n<ul>\n<li>考虑如何使得上述生效?</li>\n<li>静态调用Point3d::size()或者bnalalla</li>\n<li>最后，利用vptr虚拟机制，即要在调用size之前初始化好其class对应的vptr</li>\n<li>总结：在这种情况下，vptr在base class constructor 调用之后，在程序员代码之前（如size),或是初始化列表所列的member初始化操作前</li>\n<li>更好的，分割constructor为完整obj和subobj</li>\n</ul>\n<h3 id=\"对象复制语意学\"><a href=\"#对象复制语意学\" class=\"headerlink\" title=\"对象复制语意学\"></a>对象复制语意学</h3><h4 id=\"复制函数什么时候会被合成和使用\"><a href=\"#复制函数什么时候会被合成和使用\" class=\"headerlink\" title=\"复制函数什么时候会被合成和使用\"></a>复制函数什么时候会被合成和使用</h4></li>\n<li>前言，当你设计一个类，并以一个对象复制给另一个对象时，有三种选择：  <ul>\n<li>什么也不做，实行默认行为  </li>\n<li>提供一个显性拷贝函数</li>\n<li>拒绝，只需要把复制函数声明为private就可以 </li>\n</ul>\n</li>\n<li>考虑默认的行为：<ul>\n<li>bitwise copy行为，当不出现一下情况时，甚至不会调用复制函数，而是做bitwise copy</li>\n<li>而当出现以下行为时，调用默认的copy assignment operator函数，并合成相关操作：　　<ol>\n<li>当class中有mem obj，这个obj有一个copy ass operaator</li>\n<li>当类的基类有copy assi opera..</li>\n<li>类带virtual func</li>\n<li>继承自一个virtual base class  </li>\n</ol>\n</li>\n</ul>\n</li>\n<li>写一个显性的复制函数：  <ul>\n<li>在发生上述情况时，编译器也会像合成构造函数一样在显性的复制函数中加东西</li>\n<li>而继上面的，Point共享基类，编译器如何能在Point3d和Vertex的copy assignment operator中压抑point的copy assignment operator呢?</li>\n<li>书中的后面有些难以理解，等后面再探索吧，哎时间有限。。<h3 id=\"对象的功能\"><a href=\"#对象的功能\" class=\"headerlink\" title=\"对象的功能\"></a>对象的功能</h3>测试对象构造和拷贝的成本，在从简单形式，单一继承，到多重继承，虚拟继承等情况下的时间复杂度<h3 id=\"解构语意学\"><a href=\"#解构语意学\" class=\"headerlink\" title=\"解构语意学\"></a>解构语意学</h3></li>\n</ul>\n</li>\n<li>析构函数并不会总是被合成出来，更别提调用；</li>\n<li>只有在类内带的member object或者自己的base class带有destructor，编译器才会合成一个析构函数，否则被视为不需要或者不用合成调用</li>\n<li>析构函数没必要和构造函数对称</li>\n<li>析构函数一般有以下顺序：<ul>\n<li>先调用最底层子类析构函数，接着往上，直到基类</li>\n<li>析构函数本身在被执行时，vprt会在程序员代码前被执行</li>\n<li>若class拥有member class object ,而后者拥有destructor,则他们会以其声明顺序相反顺序被调用</li>\n<li>如果object内带一个vptr,则首先重设相关的virtual table</li>\n<li>若有任何直接的非虚基类拥有析构函数，则同上</li>\n<li>若有虚基类，则按照构造顺序相反顺序调用</li>\n</ul>\n</li>\n<li>类似于构造函数，可以分裂</li>\n</ul>"},{"title":"cpp_const","date":"2018-06-08T14:07:46.000Z","_content":"### c++关键词之const\n#### const介绍，用法，原理，注意点等\n##### const 介绍：\nconst是用于标示不可修改的变量，对象或函数的。  \n在其前面添加const就无法在之后做修改  \n##### 用法 <!--more-->\nconst总结起来有以下用法：\n+ const 修饰基本类型的变量  \n + const int xx=4; const double xd=3.3;   \n + const int array[3]={3,4,5};\n + const　修饰指针和引用\n+ const 指针： \n + const int *p=&value;   \n  //无法改变指针指向的值，但是可以改变指针,  \n  value可以是int value;/const int value;\n\n```cpp\n          int va=4;\n    6         const int *p=&va ;\n    7         va=5;\n>>  8         *p=6;//error\n    9         cout<<*p<<endl;//5\n   10         return 0;\n```\n\n  + int *const p=&value; //无法改变指针的值，但是可以改变指针指向的值\n  + const int *const p=&value;//指针的值和指针指向的值　都不可以改变\n+ const 引用：\n + const int &ref=value;\n\n##### const  c&cpp差异\n+ 不同于CPP，c将const存入的内存中设为只读，还是在栈中，而取其值时需要从内存中获取，所以从这个点看其效率比cpp差\nwhy?see follow \n```c\n    c code:\n    const int cc=8;\n0x4004da movl   $0x8,-0x8(%rbp)\n\t\tint ccc=cc;\n0x4004e1 mov    -0x8(%rbp),%eax\n0x4004e4 mov    %eax,-0x4(%rbp)\n```\n##### const和类\n+ const 对象 const对象不能调用非const成员函数，也不能改变成员\n```cpp　　　　　　　　\n       class constobj{\n          public:\n            int ax;\n            int bx;\n            constonj(int a,int b):ax(a),bx(b){};\n            int getax() const {return ax;}\n            int getbx() const {return bx;}\n            void setax(int a){ax=a;}\n        }\n        int main ()\n        {\n            constobj cobj;\n            const constobj ccobj;\n            ccobj.setax(3);//error\n            return 0;\n            }```\n+ const 成员函数（只有成员函数能被声明为const )，它不能改变成员\n+ 不能在const成员函数中修改成员变量，但是可以修改其他变量。\n+ 非const对象可以调用const成员函数\n+ 一个灵活使用const成员函数的例子：\n\n```cpp\nclass Something\n{\nprivate:\n    std::string m_value;\npublic:\n    Something(const std::string &value=\"\") { m_value= value; }\n    const std::string& getValue() const { return m_value; } // getValue() for const objects\n    std::string& getValue() { return m_value; } // getValue() for non-const objects\n};\nint main()\n{\n\tSomething something;\n\tsomething.getValue() = \"Hi\"; // calls non-const getValue();\n \n\tconst Something something2;\n\tsomething2.getValue(); // calls const getValue();\n \n\treturn 0;\n}\n```\n\n##### c++11中的添加的新内容\n+ constexp，cv限定  \n##### c++ const内存和原理\n+ 基本变量  \nconst变量是在栈中分配内存的，但是仅限于定义的时候，之后其他地方使用这个const变量都直接是使用该值\n从汇编中可以看到\n\n```\n    const int  co1=3;\n0x4008ed movl   $0x3,-0x14(%rbp)\n\t\t int  nor=co1;\n0x4008f4 movl   $0x3,-0x10(%rbp)```\n\n所以无法当进行co1=4;的赋值操作时会被编译器拦截，想想，编译后会变成3=4;是不对的； \n* 这也解释了为什么一开始就要给const的变量赋值 *\n\n\n+ 数组:save in stack\n\n```c \n   const int a[3]={2,3,5};\n0x4008fb movl   $0x2,-0x20(%rbp)\n0x400902 movl   $0x3,-0x1c(%rbp)\n0x400909 movl   $0x5,-0x18(%rbp)```\n\n\n+ 指针：  \nconst指针结合，其并不像基本类型那样贴出值，而是每次还是得去内存中取值，它的限定改变值，由编译器控制报错  \n\n指针并不是像前面那样，如\n```c\n    const int *p=&value;\n    int xx=*p;//被替换成值?不是的，而是去内存中先取出指针的值，再以此为地址去取值；\n     int pv=4;\n0x400a12 movl   $0x4,-0x58(%rbp)\n      const int *p=&pv;\n0x400a19 lea    -0x58(%rbp),%rax\n0x400a1d mov    %rax,-0x40(%rbp)\n\n\t  int px=*p;\n0x400a69 mov    -0x40(%rbp),%rax\n0x400a6d mov    (%rax),%eax\n0x400a6f mov    %eax,-0x48(%rbp)\n```\n\n```c\n　　　   int pv=4;\n0x400a12 movl   $0x4,-0x70(%rbp)//put 4 in mem(statck)\n\t\t const int *p=&pv;\n0x400a19 lea    -0x70(%rbp),%rax//get its addr\n0x400a1d mov    %rax,-0x58(%rbp)//addr to p\n         int *const pp=&pv; \n0x400a21 lea    -0x70(%rbp),%rax\n0x400a25 mov    %rax,-0x50(%rbp)//adddr to pp\n         int  *ppp=pp;\n0x400a29 mov    -0x50(%rbp),%rax//get pp num\n0x400a2d mov    %rax,-0x48(%rbp)//to ppp\n```\n\n+ 引用：\n引用同指针，是会去内存中取值的,same to pointer\n```c       \nfollow above\nconst int &ref=pv;\n0x400aba lea    -0x7c(%rbp),%rax//get pv\n0x400abe mov    %rax,-0x38(%rbp)//to ref\n\t\t int cs=ref;\n0x400ac2 mov    -0x38(%rbp),%rax//get ref\n0x400ac6 mov    (%rax),%eax//get *ref\n0x400ac8 mov    %eax,-0x64(%rbp)//to cs\n```\n\n\n+ const类对象：  \n + const对象为什么不能更改成员：  \n   成员是存在对象中的，如int,char等成员，存在栈中\n   const对象的成员也是放在栈中的，它们之所以不能赋值，是在编译期间确定，更具体的细节未知；  　\n+ const对象为什么不能调用非const成员函数：\n + 一个成员函数如何被调用：   　　\n + 其实成员函数也是全局函数，所以它能被调用，  \n　eg:   \n     ```c\n     obj.show();--->实际上被转换为：\n     show(&obj)  --传递给this指针：\n    所以当：const OB obj();\n   obj.show();时，翻译为　const OB *this;\n   在传递给OB *this时会出现不能将this指针\n   从const OB转换为OB &的错误```\n\n可以做个实验试试\n+ conclude:   \nif it can use non const func ,it will change member by non const this pointer;\n\n+ 为什么可以调用const函数：  \nconst函数：void show() const转换为：show(const OB *this);所以匹配上了，就可以调用了\n\n注意：有最小权限原则，非const对象可以调用const成员函数，就像可以赋值一样。非const变量可以用const赋值\n","source":"_posts/cpp-const.md","raw":"---\ntitle: cpp_const\ndate: 2018-06-08 22:07:46\ntags: cpp_keyword\ncategories: c&cpp\n---\n### c++关键词之const\n#### const介绍，用法，原理，注意点等\n##### const 介绍：\nconst是用于标示不可修改的变量，对象或函数的。  \n在其前面添加const就无法在之后做修改  \n##### 用法 <!--more-->\nconst总结起来有以下用法：\n+ const 修饰基本类型的变量  \n + const int xx=4; const double xd=3.3;   \n + const int array[3]={3,4,5};\n + const　修饰指针和引用\n+ const 指针： \n + const int *p=&value;   \n  //无法改变指针指向的值，但是可以改变指针,  \n  value可以是int value;/const int value;\n\n```cpp\n          int va=4;\n    6         const int *p=&va ;\n    7         va=5;\n>>  8         *p=6;//error\n    9         cout<<*p<<endl;//5\n   10         return 0;\n```\n\n  + int *const p=&value; //无法改变指针的值，但是可以改变指针指向的值\n  + const int *const p=&value;//指针的值和指针指向的值　都不可以改变\n+ const 引用：\n + const int &ref=value;\n\n##### const  c&cpp差异\n+ 不同于CPP，c将const存入的内存中设为只读，还是在栈中，而取其值时需要从内存中获取，所以从这个点看其效率比cpp差\nwhy?see follow \n```c\n    c code:\n    const int cc=8;\n0x4004da movl   $0x8,-0x8(%rbp)\n\t\tint ccc=cc;\n0x4004e1 mov    -0x8(%rbp),%eax\n0x4004e4 mov    %eax,-0x4(%rbp)\n```\n##### const和类\n+ const 对象 const对象不能调用非const成员函数，也不能改变成员\n```cpp　　　　　　　　\n       class constobj{\n          public:\n            int ax;\n            int bx;\n            constonj(int a,int b):ax(a),bx(b){};\n            int getax() const {return ax;}\n            int getbx() const {return bx;}\n            void setax(int a){ax=a;}\n        }\n        int main ()\n        {\n            constobj cobj;\n            const constobj ccobj;\n            ccobj.setax(3);//error\n            return 0;\n            }```\n+ const 成员函数（只有成员函数能被声明为const )，它不能改变成员\n+ 不能在const成员函数中修改成员变量，但是可以修改其他变量。\n+ 非const对象可以调用const成员函数\n+ 一个灵活使用const成员函数的例子：\n\n```cpp\nclass Something\n{\nprivate:\n    std::string m_value;\npublic:\n    Something(const std::string &value=\"\") { m_value= value; }\n    const std::string& getValue() const { return m_value; } // getValue() for const objects\n    std::string& getValue() { return m_value; } // getValue() for non-const objects\n};\nint main()\n{\n\tSomething something;\n\tsomething.getValue() = \"Hi\"; // calls non-const getValue();\n \n\tconst Something something2;\n\tsomething2.getValue(); // calls const getValue();\n \n\treturn 0;\n}\n```\n\n##### c++11中的添加的新内容\n+ constexp，cv限定  \n##### c++ const内存和原理\n+ 基本变量  \nconst变量是在栈中分配内存的，但是仅限于定义的时候，之后其他地方使用这个const变量都直接是使用该值\n从汇编中可以看到\n\n```\n    const int  co1=3;\n0x4008ed movl   $0x3,-0x14(%rbp)\n\t\t int  nor=co1;\n0x4008f4 movl   $0x3,-0x10(%rbp)```\n\n所以无法当进行co1=4;的赋值操作时会被编译器拦截，想想，编译后会变成3=4;是不对的； \n* 这也解释了为什么一开始就要给const的变量赋值 *\n\n\n+ 数组:save in stack\n\n```c \n   const int a[3]={2,3,5};\n0x4008fb movl   $0x2,-0x20(%rbp)\n0x400902 movl   $0x3,-0x1c(%rbp)\n0x400909 movl   $0x5,-0x18(%rbp)```\n\n\n+ 指针：  \nconst指针结合，其并不像基本类型那样贴出值，而是每次还是得去内存中取值，它的限定改变值，由编译器控制报错  \n\n指针并不是像前面那样，如\n```c\n    const int *p=&value;\n    int xx=*p;//被替换成值?不是的，而是去内存中先取出指针的值，再以此为地址去取值；\n     int pv=4;\n0x400a12 movl   $0x4,-0x58(%rbp)\n      const int *p=&pv;\n0x400a19 lea    -0x58(%rbp),%rax\n0x400a1d mov    %rax,-0x40(%rbp)\n\n\t  int px=*p;\n0x400a69 mov    -0x40(%rbp),%rax\n0x400a6d mov    (%rax),%eax\n0x400a6f mov    %eax,-0x48(%rbp)\n```\n\n```c\n　　　   int pv=4;\n0x400a12 movl   $0x4,-0x70(%rbp)//put 4 in mem(statck)\n\t\t const int *p=&pv;\n0x400a19 lea    -0x70(%rbp),%rax//get its addr\n0x400a1d mov    %rax,-0x58(%rbp)//addr to p\n         int *const pp=&pv; \n0x400a21 lea    -0x70(%rbp),%rax\n0x400a25 mov    %rax,-0x50(%rbp)//adddr to pp\n         int  *ppp=pp;\n0x400a29 mov    -0x50(%rbp),%rax//get pp num\n0x400a2d mov    %rax,-0x48(%rbp)//to ppp\n```\n\n+ 引用：\n引用同指针，是会去内存中取值的,same to pointer\n```c       \nfollow above\nconst int &ref=pv;\n0x400aba lea    -0x7c(%rbp),%rax//get pv\n0x400abe mov    %rax,-0x38(%rbp)//to ref\n\t\t int cs=ref;\n0x400ac2 mov    -0x38(%rbp),%rax//get ref\n0x400ac6 mov    (%rax),%eax//get *ref\n0x400ac8 mov    %eax,-0x64(%rbp)//to cs\n```\n\n\n+ const类对象：  \n + const对象为什么不能更改成员：  \n   成员是存在对象中的，如int,char等成员，存在栈中\n   const对象的成员也是放在栈中的，它们之所以不能赋值，是在编译期间确定，更具体的细节未知；  　\n+ const对象为什么不能调用非const成员函数：\n + 一个成员函数如何被调用：   　　\n + 其实成员函数也是全局函数，所以它能被调用，  \n　eg:   \n     ```c\n     obj.show();--->实际上被转换为：\n     show(&obj)  --传递给this指针：\n    所以当：const OB obj();\n   obj.show();时，翻译为　const OB *this;\n   在传递给OB *this时会出现不能将this指针\n   从const OB转换为OB &的错误```\n\n可以做个实验试试\n+ conclude:   \nif it can use non const func ,it will change member by non const this pointer;\n\n+ 为什么可以调用const函数：  \nconst函数：void show() const转换为：show(const OB *this);所以匹配上了，就可以调用了\n\n注意：有最小权限原则，非const对象可以调用const成员函数，就像可以赋值一样。非const变量可以用const赋值\n","slug":"cpp-const","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7no000r2ujxzuouctk6","content":"<h3 id=\"c-关键词之const\"><a href=\"#c-关键词之const\" class=\"headerlink\" title=\"c++关键词之const\"></a>c++关键词之const</h3><h4 id=\"const介绍，用法，原理，注意点等\"><a href=\"#const介绍，用法，原理，注意点等\" class=\"headerlink\" title=\"const介绍，用法，原理，注意点等\"></a>const介绍，用法，原理，注意点等</h4><h5 id=\"const-介绍：\"><a href=\"#const-介绍：\" class=\"headerlink\" title=\"const 介绍：\"></a>const 介绍：</h5><p>const是用于标示不可修改的变量，对象或函数的。<br>在其前面添加const就无法在之后做修改  </p>\n<h5 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法 \"></a>用法 <a id=\"more\"></a></h5><p>const总结起来有以下用法：</p>\n<ul>\n<li>const 修饰基本类型的变量  <ul>\n<li>const int xx=4; const double xd=3.3;   </li>\n<li>const int array[3]={3,4,5};</li>\n<li>const　修饰指针和引用</li>\n</ul>\n</li>\n<li>const 指针： <ul>\n<li>const int *p=&value;<br>//无法改变指针指向的值，但是可以改变指针,<br>value可以是int value;/const int value;</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">          <span class=\"keyword\">int</span> va=<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"number\">6</span>         <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p=&amp;va ;</span><br><span class=\"line\">    <span class=\"number\">7</span>         va=<span class=\"number\">5</span>;</span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">8</span>         *p=<span class=\"number\">6</span>;<span class=\"comment\">//error</span></span><br><span class=\"line\">    <span class=\"number\">9</span>         <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//5</span></span><br><span class=\"line\">   <span class=\"number\">10</span>         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>int *const p=&value; //无法改变指针的值，但是可以改变指针指向的值</li>\n<li>const int *const p=&value;//指针的值和指针指向的值　都不可以改变<ul>\n<li>const 引用：</li>\n<li>const int &amp;ref=value;</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"const-c-amp-cpp差异\"><a href=\"#const-c-amp-cpp差异\" class=\"headerlink\" title=\"const  c&amp;cpp差异\"></a>const  c&amp;cpp差异</h5><ul>\n<li>不同于CPP，c将const存入的内存中设为只读，还是在栈中，而取其值时需要从内存中获取，所以从这个点看其效率比cpp差<br>why?see follow <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    c code:</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cc=<span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"number\">0x4004da</span> movl   $<span class=\"number\">0x8</span>,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ccc=cc;</span><br><span class=\"line\"><span class=\"number\">0x4004e1</span> mov    <span class=\"number\">-0x8</span>(%rbp),%eax</span><br><span class=\"line\"><span class=\"number\">0x4004e4</span> mov    %eax,<span class=\"number\">-0x4</span>(%rbp)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"const和类\"><a href=\"#const和类\" class=\"headerlink\" title=\"const和类\"></a>const和类</h5><ul>\n<li><p>const 对象 const对象不能调用非const成员函数，也不能改变成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">constobj</span>&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">     <span class=\"keyword\">int</span> ax;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> bx;</span><br><span class=\"line\">     constonj(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b):ax(a),bx(b)&#123;&#125;;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getax</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> ax;&#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getbx</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> bx;&#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setax</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;ax=a;&#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">     constobj cobj;</span><br><span class=\"line\">     <span class=\"keyword\">const</span> constobj ccobj;</span><br><span class=\"line\">     ccobj.setax(<span class=\"number\">3</span>);<span class=\"comment\">//error</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>const 成员函数（只有成员函数能被声明为const )，它不能改变成员</p>\n</li>\n<li>不能在const成员函数中修改成员变量，但是可以修改其他变量。</li>\n<li>非const对象可以调用const成员函数</li>\n<li>一个灵活使用const成员函数的例子：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Something</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> m_value;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Something(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;value=<span class=\"string\">\"\"</span>) &#123; m_value= value; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">getValue</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> m_value; &#125; <span class=\"comment\">// getValue() for const objects</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_value; &#125; <span class=\"comment\">// getValue() for non-const objects</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tSomething something;</span><br><span class=\"line\">\tsomething.getValue() = <span class=\"string\">\"Hi\"</span>; <span class=\"comment\">// calls non-const getValue();</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">const</span> Something something2;</span><br><span class=\"line\">\tsomething2.getValue(); <span class=\"comment\">// calls const getValue();</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"c-11中的添加的新内容\"><a href=\"#c-11中的添加的新内容\" class=\"headerlink\" title=\"c++11中的添加的新内容\"></a>c++11中的添加的新内容</h5><ul>\n<li>constexp，cv限定  <h5 id=\"c-const内存和原理\"><a href=\"#c-const内存和原理\" class=\"headerlink\" title=\"c++ const内存和原理\"></a>c++ const内存和原理</h5></li>\n<li>基本变量<br>const变量是在栈中分配内存的，但是仅限于定义的时候，之后其他地方使用这个const变量都直接是使用该值<br>从汇编中可以看到</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    const int  co1=<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"number\">0x4008ed</span> movl   $<span class=\"number\">0x3</span>,<span class=\"number\">-0x14</span>(%rbp)</span><br><span class=\"line\">\t\t int  nor=co1;</span><br><span class=\"line\"><span class=\"number\">0x4008f4</span> movl   $<span class=\"number\">0x3</span>,<span class=\"number\">-0x10</span>(%rbp)</span><br></pre></td></tr></table></figure>\n<p>所以无法当进行co1=4;的赋值操作时会被编译器拦截，想想，编译后会变成3=4;是不对的； </p>\n<ul>\n<li>这也解释了为什么一开始就要给const的变量赋值 *</li>\n</ul>\n<ul>\n<li>数组:save in stack</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a[<span class=\"number\">3</span>]=&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"number\">0x4008fb</span> movl   $<span class=\"number\">0x2</span>,<span class=\"number\">-0x20</span>(%rbp)</span><br><span class=\"line\"><span class=\"number\">0x400902</span> movl   $<span class=\"number\">0x3</span>,<span class=\"number\">-0x1c</span>(%rbp)</span><br><span class=\"line\"><span class=\"number\">0x400909</span> movl   $<span class=\"number\">0x5</span>,<span class=\"number\">-0x18</span>(%rbp)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>指针：<br>const指针结合，其并不像基本类型那样贴出值，而是每次还是得去内存中取值，它的限定改变值，由编译器控制报错  </li>\n</ul>\n<p>指针并不是像前面那样，如<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p=&amp;value;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> xx=*p;<span class=\"comment\">//被替换成值?不是的，而是去内存中先取出指针的值，再以此为地址去取值；</span></span><br><span class=\"line\">     <span class=\"keyword\">int</span> pv=<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"number\">0x400a12</span> movl   $<span class=\"number\">0x4</span>,<span class=\"number\">-0x58</span>(%rbp)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p=&amp;pv;</span><br><span class=\"line\"><span class=\"number\">0x400a19</span> lea    <span class=\"number\">-0x58</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x400a1d</span> mov    %rax,<span class=\"number\">-0x40</span>(%rbp)</span><br><span class=\"line\"></span><br><span class=\"line\">\t  <span class=\"keyword\">int</span> px=*p;</span><br><span class=\"line\"><span class=\"number\">0x400a69</span> mov    <span class=\"number\">-0x40</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x400a6d</span> mov    (%rax),%eax</span><br><span class=\"line\"><span class=\"number\">0x400a6f</span> mov    %eax,<span class=\"number\">-0x48</span>(%rbp)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　   <span class=\"keyword\">int</span> pv=<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"number\">0x400a12</span> movl   $<span class=\"number\">0x4</span>,<span class=\"number\">-0x70</span>(%rbp)<span class=\"comment\">//put 4 in mem(statck)</span></span><br><span class=\"line\">\t\t <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p=&amp;pv;</span><br><span class=\"line\"><span class=\"number\">0x400a19</span> lea    <span class=\"number\">-0x70</span>(%rbp),%rax<span class=\"comment\">//get its addr</span></span><br><span class=\"line\"><span class=\"number\">0x400a1d</span> mov    %rax,<span class=\"number\">-0x58</span>(%rbp)<span class=\"comment\">//addr to p</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> pp=&amp;pv; </span><br><span class=\"line\"><span class=\"number\">0x400a21</span> lea    <span class=\"number\">-0x70</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x400a25</span> mov    %rax,<span class=\"number\">-0x50</span>(%rbp)<span class=\"comment\">//adddr to pp</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span>  *ppp=pp;</span><br><span class=\"line\"><span class=\"number\">0x400a29</span> mov    <span class=\"number\">-0x50</span>(%rbp),%rax<span class=\"comment\">//get pp num</span></span><br><span class=\"line\"><span class=\"number\">0x400a2d</span> mov    %rax,<span class=\"number\">-0x48</span>(%rbp)<span class=\"comment\">//to ppp</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>引用：<br>引用同指针，是会去内存中取值的,same to pointer</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">follow above</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ref=pv;</span><br><span class=\"line\"><span class=\"number\">0x400aba</span> lea    <span class=\"number\">-0x7c</span>(%rbp),%rax<span class=\"comment\">//get pv</span></span><br><span class=\"line\"><span class=\"number\">0x400abe</span> mov    %rax,<span class=\"number\">-0x38</span>(%rbp)<span class=\"comment\">//to ref</span></span><br><span class=\"line\">\t\t <span class=\"keyword\">int</span> cs=ref;</span><br><span class=\"line\"><span class=\"number\">0x400ac2</span> mov    <span class=\"number\">-0x38</span>(%rbp),%rax<span class=\"comment\">//get ref</span></span><br><span class=\"line\"><span class=\"number\">0x400ac6</span> mov    (%rax),%eax<span class=\"comment\">//get *ref</span></span><br><span class=\"line\"><span class=\"number\">0x400ac8</span> mov    %eax,<span class=\"number\">-0x64</span>(%rbp)<span class=\"comment\">//to cs</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>const类对象：  </p>\n<ul>\n<li>const对象为什么不能更改成员：<br>成员是存在对象中的，如int,char等成员，存在栈中<br>const对象的成员也是放在栈中的，它们之所以不能赋值，是在编译期间确定，更具体的细节未知；  　</li>\n</ul>\n</li>\n<li>const对象为什么不能调用非const成员函数：<ul>\n<li>一个成员函数如何被调用：   　　</li>\n<li>其实成员函数也是全局函数，所以它能被调用，<br>　eg:    <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  obj.show();---&gt;实际上被转换为：</span><br><span class=\"line\">  show(&amp;obj)  --传递给<span class=\"keyword\">this</span>指针：</span><br><span class=\"line\"> 所以当：<span class=\"function\"><span class=\"keyword\">const</span> OB <span class=\"title\">obj</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">obj.show();时，翻译为　<span class=\"keyword\">const</span> OB *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">在传递给OB *<span class=\"keyword\">this</span>时会出现不能将<span class=\"keyword\">this</span>指针</span><br><span class=\"line\">从<span class=\"keyword\">const</span> OB转换为OB &amp;的错误</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>可以做个实验试试</p>\n<ul>\n<li><p>conclude:<br>if it can use non const func ,it will change member by non const this pointer;</p>\n</li>\n<li><p>为什么可以调用const函数：<br>const函数：void show() const转换为：show(const OB *this);所以匹配上了，就可以调用了</p>\n</li>\n</ul>\n<p>注意：有最小权限原则，非const对象可以调用const成员函数，就像可以赋值一样。非const变量可以用const赋值</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"c-关键词之const\"><a href=\"#c-关键词之const\" class=\"headerlink\" title=\"c++关键词之const\"></a>c++关键词之const</h3><h4 id=\"const介绍，用法，原理，注意点等\"><a href=\"#const介绍，用法，原理，注意点等\" class=\"headerlink\" title=\"const介绍，用法，原理，注意点等\"></a>const介绍，用法，原理，注意点等</h4><h5 id=\"const-介绍：\"><a href=\"#const-介绍：\" class=\"headerlink\" title=\"const 介绍：\"></a>const 介绍：</h5><p>const是用于标示不可修改的变量，对象或函数的。<br>在其前面添加const就无法在之后做修改  </p>\n<h5 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法 \"></a>用法","more":"</h5><p>const总结起来有以下用法：</p>\n<ul>\n<li>const 修饰基本类型的变量  <ul>\n<li>const int xx=4; const double xd=3.3;   </li>\n<li>const int array[3]={3,4,5};</li>\n<li>const　修饰指针和引用</li>\n</ul>\n</li>\n<li>const 指针： <ul>\n<li>const int *p=&value;<br>//无法改变指针指向的值，但是可以改变指针,<br>value可以是int value;/const int value;</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">          <span class=\"keyword\">int</span> va=<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"number\">6</span>         <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p=&amp;va ;</span><br><span class=\"line\">    <span class=\"number\">7</span>         va=<span class=\"number\">5</span>;</span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">8</span>         *p=<span class=\"number\">6</span>;<span class=\"comment\">//error</span></span><br><span class=\"line\">    <span class=\"number\">9</span>         <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//5</span></span><br><span class=\"line\">   <span class=\"number\">10</span>         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>int *const p=&value; //无法改变指针的值，但是可以改变指针指向的值</li>\n<li>const int *const p=&value;//指针的值和指针指向的值　都不可以改变<ul>\n<li>const 引用：</li>\n<li>const int &amp;ref=value;</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"const-c-amp-cpp差异\"><a href=\"#const-c-amp-cpp差异\" class=\"headerlink\" title=\"const  c&amp;cpp差异\"></a>const  c&amp;cpp差异</h5><ul>\n<li>不同于CPP，c将const存入的内存中设为只读，还是在栈中，而取其值时需要从内存中获取，所以从这个点看其效率比cpp差<br>why?see follow <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    c code:</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cc=<span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"number\">0x4004da</span> movl   $<span class=\"number\">0x8</span>,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ccc=cc;</span><br><span class=\"line\"><span class=\"number\">0x4004e1</span> mov    <span class=\"number\">-0x8</span>(%rbp),%eax</span><br><span class=\"line\"><span class=\"number\">0x4004e4</span> mov    %eax,<span class=\"number\">-0x4</span>(%rbp)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"const和类\"><a href=\"#const和类\" class=\"headerlink\" title=\"const和类\"></a>const和类</h5><ul>\n<li><p>const 对象 const对象不能调用非const成员函数，也不能改变成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">constobj</span>&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">     <span class=\"keyword\">int</span> ax;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> bx;</span><br><span class=\"line\">     constonj(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b):ax(a),bx(b)&#123;&#125;;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getax</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> ax;&#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getbx</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> bx;&#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setax</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;ax=a;&#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">     constobj cobj;</span><br><span class=\"line\">     <span class=\"keyword\">const</span> constobj ccobj;</span><br><span class=\"line\">     ccobj.setax(<span class=\"number\">3</span>);<span class=\"comment\">//error</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>const 成员函数（只有成员函数能被声明为const )，它不能改变成员</p>\n</li>\n<li>不能在const成员函数中修改成员变量，但是可以修改其他变量。</li>\n<li>非const对象可以调用const成员函数</li>\n<li>一个灵活使用const成员函数的例子：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Something</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> m_value;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Something(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;value=<span class=\"string\">\"\"</span>) &#123; m_value= value; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">getValue</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> m_value; &#125; <span class=\"comment\">// getValue() for const objects</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_value; &#125; <span class=\"comment\">// getValue() for non-const objects</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tSomething something;</span><br><span class=\"line\">\tsomething.getValue() = <span class=\"string\">\"Hi\"</span>; <span class=\"comment\">// calls non-const getValue();</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">const</span> Something something2;</span><br><span class=\"line\">\tsomething2.getValue(); <span class=\"comment\">// calls const getValue();</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"c-11中的添加的新内容\"><a href=\"#c-11中的添加的新内容\" class=\"headerlink\" title=\"c++11中的添加的新内容\"></a>c++11中的添加的新内容</h5><ul>\n<li>constexp，cv限定  <h5 id=\"c-const内存和原理\"><a href=\"#c-const内存和原理\" class=\"headerlink\" title=\"c++ const内存和原理\"></a>c++ const内存和原理</h5></li>\n<li>基本变量<br>const变量是在栈中分配内存的，但是仅限于定义的时候，之后其他地方使用这个const变量都直接是使用该值<br>从汇编中可以看到</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    const int  co1=<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"number\">0x4008ed</span> movl   $<span class=\"number\">0x3</span>,<span class=\"number\">-0x14</span>(%rbp)</span><br><span class=\"line\">\t\t int  nor=co1;</span><br><span class=\"line\"><span class=\"number\">0x4008f4</span> movl   $<span class=\"number\">0x3</span>,<span class=\"number\">-0x10</span>(%rbp)</span><br></pre></td></tr></table></figure>\n<p>所以无法当进行co1=4;的赋值操作时会被编译器拦截，想想，编译后会变成3=4;是不对的； </p>\n<ul>\n<li>这也解释了为什么一开始就要给const的变量赋值 *</li>\n</ul>\n<ul>\n<li>数组:save in stack</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a[<span class=\"number\">3</span>]=&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"number\">0x4008fb</span> movl   $<span class=\"number\">0x2</span>,<span class=\"number\">-0x20</span>(%rbp)</span><br><span class=\"line\"><span class=\"number\">0x400902</span> movl   $<span class=\"number\">0x3</span>,<span class=\"number\">-0x1c</span>(%rbp)</span><br><span class=\"line\"><span class=\"number\">0x400909</span> movl   $<span class=\"number\">0x5</span>,<span class=\"number\">-0x18</span>(%rbp)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>指针：<br>const指针结合，其并不像基本类型那样贴出值，而是每次还是得去内存中取值，它的限定改变值，由编译器控制报错  </li>\n</ul>\n<p>指针并不是像前面那样，如<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p=&amp;value;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> xx=*p;<span class=\"comment\">//被替换成值?不是的，而是去内存中先取出指针的值，再以此为地址去取值；</span></span><br><span class=\"line\">     <span class=\"keyword\">int</span> pv=<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"number\">0x400a12</span> movl   $<span class=\"number\">0x4</span>,<span class=\"number\">-0x58</span>(%rbp)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p=&amp;pv;</span><br><span class=\"line\"><span class=\"number\">0x400a19</span> lea    <span class=\"number\">-0x58</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x400a1d</span> mov    %rax,<span class=\"number\">-0x40</span>(%rbp)</span><br><span class=\"line\"></span><br><span class=\"line\">\t  <span class=\"keyword\">int</span> px=*p;</span><br><span class=\"line\"><span class=\"number\">0x400a69</span> mov    <span class=\"number\">-0x40</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x400a6d</span> mov    (%rax),%eax</span><br><span class=\"line\"><span class=\"number\">0x400a6f</span> mov    %eax,<span class=\"number\">-0x48</span>(%rbp)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　   <span class=\"keyword\">int</span> pv=<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"number\">0x400a12</span> movl   $<span class=\"number\">0x4</span>,<span class=\"number\">-0x70</span>(%rbp)<span class=\"comment\">//put 4 in mem(statck)</span></span><br><span class=\"line\">\t\t <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p=&amp;pv;</span><br><span class=\"line\"><span class=\"number\">0x400a19</span> lea    <span class=\"number\">-0x70</span>(%rbp),%rax<span class=\"comment\">//get its addr</span></span><br><span class=\"line\"><span class=\"number\">0x400a1d</span> mov    %rax,<span class=\"number\">-0x58</span>(%rbp)<span class=\"comment\">//addr to p</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> pp=&amp;pv; </span><br><span class=\"line\"><span class=\"number\">0x400a21</span> lea    <span class=\"number\">-0x70</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x400a25</span> mov    %rax,<span class=\"number\">-0x50</span>(%rbp)<span class=\"comment\">//adddr to pp</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span>  *ppp=pp;</span><br><span class=\"line\"><span class=\"number\">0x400a29</span> mov    <span class=\"number\">-0x50</span>(%rbp),%rax<span class=\"comment\">//get pp num</span></span><br><span class=\"line\"><span class=\"number\">0x400a2d</span> mov    %rax,<span class=\"number\">-0x48</span>(%rbp)<span class=\"comment\">//to ppp</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>引用：<br>引用同指针，是会去内存中取值的,same to pointer</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">follow above</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ref=pv;</span><br><span class=\"line\"><span class=\"number\">0x400aba</span> lea    <span class=\"number\">-0x7c</span>(%rbp),%rax<span class=\"comment\">//get pv</span></span><br><span class=\"line\"><span class=\"number\">0x400abe</span> mov    %rax,<span class=\"number\">-0x38</span>(%rbp)<span class=\"comment\">//to ref</span></span><br><span class=\"line\">\t\t <span class=\"keyword\">int</span> cs=ref;</span><br><span class=\"line\"><span class=\"number\">0x400ac2</span> mov    <span class=\"number\">-0x38</span>(%rbp),%rax<span class=\"comment\">//get ref</span></span><br><span class=\"line\"><span class=\"number\">0x400ac6</span> mov    (%rax),%eax<span class=\"comment\">//get *ref</span></span><br><span class=\"line\"><span class=\"number\">0x400ac8</span> mov    %eax,<span class=\"number\">-0x64</span>(%rbp)<span class=\"comment\">//to cs</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>const类对象：  </p>\n<ul>\n<li>const对象为什么不能更改成员：<br>成员是存在对象中的，如int,char等成员，存在栈中<br>const对象的成员也是放在栈中的，它们之所以不能赋值，是在编译期间确定，更具体的细节未知；  　</li>\n</ul>\n</li>\n<li>const对象为什么不能调用非const成员函数：<ul>\n<li>一个成员函数如何被调用：   　　</li>\n<li>其实成员函数也是全局函数，所以它能被调用，<br>　eg:    <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  obj.show();---&gt;实际上被转换为：</span><br><span class=\"line\">  show(&amp;obj)  --传递给<span class=\"keyword\">this</span>指针：</span><br><span class=\"line\"> 所以当：<span class=\"function\"><span class=\"keyword\">const</span> OB <span class=\"title\">obj</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">obj.show();时，翻译为　<span class=\"keyword\">const</span> OB *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">在传递给OB *<span class=\"keyword\">this</span>时会出现不能将<span class=\"keyword\">this</span>指针</span><br><span class=\"line\">从<span class=\"keyword\">const</span> OB转换为OB &amp;的错误</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>可以做个实验试试</p>\n<ul>\n<li><p>conclude:<br>if it can use non const func ,it will change member by non const this pointer;</p>\n</li>\n<li><p>为什么可以调用const函数：<br>const函数：void show() const转换为：show(const OB *this);所以匹配上了，就可以调用了</p>\n</li>\n</ul>\n<p>注意：有最小权限原则，非const对象可以调用const成员函数，就像可以赋值一样。非const变量可以用const赋值</p>"},{"title":"cpp_debug_layout_dynamic","date":"2018-05-20T10:33:09.000Z","_content":"\n### c执行期内存布局和调试：\n\n在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等\n１、将目标文件装入: <!-- more -->\n*１）重定位－－－　放在内存哪里\n 2)  等待调度执行*\n这里可以使用gdb进行调试查看\n\n\n一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).\n一个进程主要包括：\n   在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等\n\n>栈区　　高地址到低地址\n>堆区　　低地址到高地址\n>bss\n>数据\n>代码\n     \n     \n     \n 以下将从两个维度进行对一个程序被执行成进程时，内存的情况：\n １、各种段区的内存分布\n ２、gdb 调试程序执行时的过程。－－可能涉及到汇编\n －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n#### 1、gdb　常用的命令和用法：\n1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令\n 2)设置断点：　\nb 行号\nb 函数名\nb 行号　if 条件\neg:\nbreak main  /  b main\n  删除断点:delete 行号\n\n3)列出代码\nl /list\n\n4)运行，start\n  跳转到断点:c/continue   r/run\n  until  行号　　　运行直到该行 \n5)观察变量b和地址\nwatch b  若变量值发生变化，则程序停止\n\n\n　p/print  b  看变量值\n　p/print &b　看变量地址\n i  locals\n  \n  \n info registers 显示所有寄存器的值\n 查看特定内存位置的值如：\n print/x $eax   显示为16进制 \n print/t  2进制，　\n print/d 十进制,\nx/nyz  : n表示字段数，y为输出格式，z是字段长度\n \n６）单步调试\n n/next   /   s/step　\n \n 7) 保存断点：\n info b  查看断点信息\n save breakpoint fig.dp 保存断点\n 读取断点文件：　gdb hello -x fig.dp\n \n 退出quit\n \n http://bbs.chinaunix.net/thread-150524-1-1.html\n \n#### 2 使用kdbg \n 界面版本gdb  在gcc ... -g后，用kdbg打开即可、\n 查看程序运行时各个地址：\n\t```\n\t#include<stdio.h>\n\t#include<string.h>\n\t#include<sys/types.h>\n\t#include<stdlib.h>\n\t#include<unistd.h>\n\t#define SHW_ADR(ID,I) printf(\"the id %s \\t is at adr:%8X\\n\",ID,&I);\n\textern etext,edata,end;\n\tchar *cptr=\"Hello World\\n\";\n\tchar buffer1[25];\n\tint main(void)\n\t{\n\t\tvoid showit(char *);\n\t\tint i=0;\n\t   \tprintf(\"Adr etext:%8x\\tAdr edata:%8x \\t Adr end :%8x \\n\\n\",&etext,&edata,&end);\n\t\tSHW_ADR(\"main\",main);\n\t\tSHW_ADR(\"showit\",showit);\n\t\tSHW_ADR(\"cptr\",cptr);\n\t\tSHW_ADR(\"buffer1\",buffer1);\n\t\tSHW_ADR(\"i\",i);\n\t\tstrcpy(buffer1,\"A demonstration\\n\");\n\t\twrite(1,buffer1,strlen(buffer1)+1);\n\t\tfor(;i<1;++i)\n\t\t\tshowit(cptr);\n\t\treturn 0;\n\t}\n\t\n\tvoid showit(char *p)\n\t{\n\t\tchar *buffer2;\n\t\tSHW_ADR(\"buffer2\",buffer2);\n\t\tif((buffer2=(char *)malloc((unsigned)(strlen(p)+1)))!=NULL)\n\t\t{\n\t\t\tstrcpy(buffer2,p);\n\t\t\tprintf(\"%s\",buffer2);\n\t\t\tfree(buffer2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Allocation error.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\t\n\t```\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n\t```cpp\n\t#include <stdio.h>\n\t#include <malloc.h>\n\t#include <unistd.h>\n\t#include <alloca.h>\n\t\n\textern void afunc(void);\n\textern etext,edata,end;\n\t\n\tint bss_var;\t\t\t\t//no init globel data must be in bss\n\t\n\tint data_var=42;\t\t\t//init globel data must be in data\n\t\n\t#define SHW_ADR(ID,I) printf(\"the %8s\\t is at adr:%8x\\n\",ID,&I);\t\t//the macro to printf the addr\n\t\n\tint main(int argc,char *argv[])\n\t{\n\t\tchar *p,*b,*nb;\n\t\n\t\tprintf(\"Adr etext:%8x\\t Adr edata %8x\\t Adr end %8x\\t\\n\",&etext,&edata,&end);\n\t\t\n\t\tprintf(\"\\ntext Location:\\n\");\n\t\tSHW_ADR(\"main\",main);\t\t\t//text section function\n\t\tSHW_ADR(\"afunc\",afunc);\t\t\t//text section function\n\t\n\t\tprintf(\"\\nbss Location:\\n\");\n\t\tSHW_ADR(\"bss_var\",bss_var);\t\t//bss section var\n\t\n\t\tprintf(\"\\ndata location:\\n\");\n\t\tSHW_ADR(\"data_var\",data_var);\t//data section var\n\t\t\n\t\t\n\t\tprintf(\"\\nStack Locations:\\n\");\n\t\tafunc();\n\t\t\n\t\tp=(char *)alloca(32);\t\t\t//alloc memory from statck\n\t\tif(p!=NULL)\n\t\t{\n\t\t\tSHW_ADR(\"start\",p);\n\t\t\tSHW_ADR(\"end\",p+31);\n\t\t}\n\t\t\n\t\tb=(char *)malloc(32*sizeof(char));\t//malloc memory from heap\n\t\tnb=(char *)malloc(16*sizeof(char));\n\t\t\n\t\tprintf(\"\\nHeap Locations:\\n\");\t\n\t\tprintf(\"the Heap start: %p\\n\",b);\n\t\tprintf(\"the Heap end:%p\\n\",(nb+16*sizeof(char)));\n\t\tprintf(\"\\nb and nb in Stack\\n\");\n\t\tSHW_ADR(\"b\",b);\n\t\tSHW_ADR(\"nb\",nb);\n\t\tfree(b);\n\t\tfree(nb);\n\t}\n\t\n\t\n\tvoid afunc(void)\n\t{\n\t\tstatic int long level=0;\t//data section static var\n\t\tint\t stack_var;\t\t\t\t//temp var ,in stack section\n\t\tif(++level==5)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSHW_ADR(\"stack_var in stack section\",stack_var);\n\t\tSHW_ADR(\"Level in data section\",level);\n\t\tafunc();\n\t}\n\t```\n \n \n \n \n \n","source":"_posts/cpp-debug-layout-dynamic.md","raw":"---\ntitle: cpp_debug_layout_dynamic\ndate: 2018-05-20 18:33:09\ntags: cpp_memory\ncategories: c&cpp\n---\n\n### c执行期内存布局和调试：\n\n在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等\n１、将目标文件装入: <!-- more -->\n*１）重定位－－－　放在内存哪里\n 2)  等待调度执行*\n这里可以使用gdb进行调试查看\n\n\n一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).\n一个进程主要包括：\n   在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等\n\n>栈区　　高地址到低地址\n>堆区　　低地址到高地址\n>bss\n>数据\n>代码\n     \n     \n     \n 以下将从两个维度进行对一个程序被执行成进程时，内存的情况：\n １、各种段区的内存分布\n ２、gdb 调试程序执行时的过程。－－可能涉及到汇编\n －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n#### 1、gdb　常用的命令和用法：\n1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令\n 2)设置断点：　\nb 行号\nb 函数名\nb 行号　if 条件\neg:\nbreak main  /  b main\n  删除断点:delete 行号\n\n3)列出代码\nl /list\n\n4)运行，start\n  跳转到断点:c/continue   r/run\n  until  行号　　　运行直到该行 \n5)观察变量b和地址\nwatch b  若变量值发生变化，则程序停止\n\n\n　p/print  b  看变量值\n　p/print &b　看变量地址\n i  locals\n  \n  \n info registers 显示所有寄存器的值\n 查看特定内存位置的值如：\n print/x $eax   显示为16进制 \n print/t  2进制，　\n print/d 十进制,\nx/nyz  : n表示字段数，y为输出格式，z是字段长度\n \n６）单步调试\n n/next   /   s/step　\n \n 7) 保存断点：\n info b  查看断点信息\n save breakpoint fig.dp 保存断点\n 读取断点文件：　gdb hello -x fig.dp\n \n 退出quit\n \n http://bbs.chinaunix.net/thread-150524-1-1.html\n \n#### 2 使用kdbg \n 界面版本gdb  在gcc ... -g后，用kdbg打开即可、\n 查看程序运行时各个地址：\n\t```\n\t#include<stdio.h>\n\t#include<string.h>\n\t#include<sys/types.h>\n\t#include<stdlib.h>\n\t#include<unistd.h>\n\t#define SHW_ADR(ID,I) printf(\"the id %s \\t is at adr:%8X\\n\",ID,&I);\n\textern etext,edata,end;\n\tchar *cptr=\"Hello World\\n\";\n\tchar buffer1[25];\n\tint main(void)\n\t{\n\t\tvoid showit(char *);\n\t\tint i=0;\n\t   \tprintf(\"Adr etext:%8x\\tAdr edata:%8x \\t Adr end :%8x \\n\\n\",&etext,&edata,&end);\n\t\tSHW_ADR(\"main\",main);\n\t\tSHW_ADR(\"showit\",showit);\n\t\tSHW_ADR(\"cptr\",cptr);\n\t\tSHW_ADR(\"buffer1\",buffer1);\n\t\tSHW_ADR(\"i\",i);\n\t\tstrcpy(buffer1,\"A demonstration\\n\");\n\t\twrite(1,buffer1,strlen(buffer1)+1);\n\t\tfor(;i<1;++i)\n\t\t\tshowit(cptr);\n\t\treturn 0;\n\t}\n\t\n\tvoid showit(char *p)\n\t{\n\t\tchar *buffer2;\n\t\tSHW_ADR(\"buffer2\",buffer2);\n\t\tif((buffer2=(char *)malloc((unsigned)(strlen(p)+1)))!=NULL)\n\t\t{\n\t\t\tstrcpy(buffer2,p);\n\t\t\tprintf(\"%s\",buffer2);\n\t\t\tfree(buffer2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Allocation error.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\t\n\t```\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n\t```cpp\n\t#include <stdio.h>\n\t#include <malloc.h>\n\t#include <unistd.h>\n\t#include <alloca.h>\n\t\n\textern void afunc(void);\n\textern etext,edata,end;\n\t\n\tint bss_var;\t\t\t\t//no init globel data must be in bss\n\t\n\tint data_var=42;\t\t\t//init globel data must be in data\n\t\n\t#define SHW_ADR(ID,I) printf(\"the %8s\\t is at adr:%8x\\n\",ID,&I);\t\t//the macro to printf the addr\n\t\n\tint main(int argc,char *argv[])\n\t{\n\t\tchar *p,*b,*nb;\n\t\n\t\tprintf(\"Adr etext:%8x\\t Adr edata %8x\\t Adr end %8x\\t\\n\",&etext,&edata,&end);\n\t\t\n\t\tprintf(\"\\ntext Location:\\n\");\n\t\tSHW_ADR(\"main\",main);\t\t\t//text section function\n\t\tSHW_ADR(\"afunc\",afunc);\t\t\t//text section function\n\t\n\t\tprintf(\"\\nbss Location:\\n\");\n\t\tSHW_ADR(\"bss_var\",bss_var);\t\t//bss section var\n\t\n\t\tprintf(\"\\ndata location:\\n\");\n\t\tSHW_ADR(\"data_var\",data_var);\t//data section var\n\t\t\n\t\t\n\t\tprintf(\"\\nStack Locations:\\n\");\n\t\tafunc();\n\t\t\n\t\tp=(char *)alloca(32);\t\t\t//alloc memory from statck\n\t\tif(p!=NULL)\n\t\t{\n\t\t\tSHW_ADR(\"start\",p);\n\t\t\tSHW_ADR(\"end\",p+31);\n\t\t}\n\t\t\n\t\tb=(char *)malloc(32*sizeof(char));\t//malloc memory from heap\n\t\tnb=(char *)malloc(16*sizeof(char));\n\t\t\n\t\tprintf(\"\\nHeap Locations:\\n\");\t\n\t\tprintf(\"the Heap start: %p\\n\",b);\n\t\tprintf(\"the Heap end:%p\\n\",(nb+16*sizeof(char)));\n\t\tprintf(\"\\nb and nb in Stack\\n\");\n\t\tSHW_ADR(\"b\",b);\n\t\tSHW_ADR(\"nb\",nb);\n\t\tfree(b);\n\t\tfree(nb);\n\t}\n\t\n\t\n\tvoid afunc(void)\n\t{\n\t\tstatic int long level=0;\t//data section static var\n\t\tint\t stack_var;\t\t\t\t//temp var ,in stack section\n\t\tif(++level==5)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSHW_ADR(\"stack_var in stack section\",stack_var);\n\t\tSHW_ADR(\"Level in data section\",level);\n\t\tafunc();\n\t}\n\t```\n \n \n \n \n \n","slug":"cpp-debug-layout-dynamic","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7np000u2ujxdd05ovx5","content":"<h3 id=\"c执行期内存布局和调试：\"><a href=\"#c执行期内存布局和调试：\" class=\"headerlink\" title=\"c执行期内存布局和调试：\"></a>c执行期内存布局和调试：</h3><p>在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等<br>１、将目标文件装入: <a id=\"more\"></a><br><em>１）重定位－－－　放在内存哪里<br> 2)  等待调度执行</em><br>这里可以使用gdb进行调试查看</p>\n<p>一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).<br>一个进程主要包括：<br>   在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等</p>\n<blockquote>\n<p>栈区　　高地址到低地址<br>堆区　　低地址到高地址<br>bss<br>数据<br>代码</p>\n</blockquote>\n<p> 以下将从两个维度进行对一个程序被执行成进程时，内存的情况：<br> １、各种段区的内存分布<br> ２、gdb 调试程序执行时的过程。－－可能涉及到汇编<br> －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>\n<h4 id=\"1、gdb-常用的命令和用法：\"><a href=\"#1、gdb-常用的命令和用法：\" class=\"headerlink\" title=\"1、gdb　常用的命令和用法：\"></a>1、gdb　常用的命令和用法：</h4><p>1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令<br> 2)设置断点：　<br>b 行号<br>b 函数名<br>b 行号　if 条件<br>eg:<br>break main  /  b main<br>  删除断点:delete 行号</p>\n<p>3)列出代码<br>l /list</p>\n<p>4)运行，start<br>  跳转到断点:c/continue   r/run<br>  until  行号　　　运行直到该行<br>5)观察变量b和地址<br>watch b  若变量值发生变化，则程序停止</p>\n<p>　p/print  b  看变量值<br>　p/print &amp;b　看变量地址<br> i  locals</p>\n<p> info registers 显示所有寄存器的值<br> 查看特定内存位置的值如：<br> print/x $eax   显示为16进制<br> print/t  2进制，　<br> print/d 十进制,<br>x/nyz  : n表示字段数，y为输出格式，z是字段长度</p>\n<p>６）单步调试<br> n/next   /   s/step　</p>\n<p> 7) 保存断点：<br> info b  查看断点信息<br> save breakpoint fig.dp 保存断点<br> 读取断点文件：　gdb hello -x fig.dp</p>\n<p> 退出quit</p>\n<p> <a href=\"http://bbs.chinaunix.net/thread-150524-1-1.html\" target=\"_blank\" rel=\"noopener\">http://bbs.chinaunix.net/thread-150524-1-1.html</a></p>\n<h4 id=\"2-使用kdbg\"><a href=\"#2-使用kdbg\" class=\"headerlink\" title=\"2 使用kdbg\"></a>2 使用kdbg</h4><p> 界面版本gdb  在gcc … -g后，用kdbg打开即可、<br> 查看程序运行时各个地址：<br>    <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SHW_ADR(ID,I) printf(<span class=\"meta-string\">\"the id %s \\t is at adr:%8X\\n\"</span>,ID,&amp;I);</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> etext,edata,end;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *cptr=<span class=\"string\">\"Hello World\\n\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buffer1[<span class=\"number\">25</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showit</span><span class=\"params\">(<span class=\"keyword\">char</span> *)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">   \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Adr etext:%8x\\tAdr edata:%8x \\t Adr end :%8x \\n\\n\"</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"main\"</span>,main);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"showit\"</span>,showit);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"cptr\"</span>,cptr);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"buffer1\"</span>,buffer1);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"i\"</span>,i);</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(buffer1,<span class=\"string\">\"A demonstration\\n\"</span>);</span><br><span class=\"line\">\twrite(<span class=\"number\">1</span>,buffer1,<span class=\"built_in\">strlen</span>(buffer1)+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;i&lt;<span class=\"number\">1</span>;++i)</span><br><span class=\"line\">\t\tshowit(cptr);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showit</span><span class=\"params\">(<span class=\"keyword\">char</span> *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *buffer2;</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"buffer2\"</span>,buffer2);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>((buffer2=(<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>((<span class=\"keyword\">unsigned</span>)(<span class=\"built_in\">strlen</span>(p)+<span class=\"number\">1</span>)))!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(buffer2,p);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,buffer2);</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(buffer2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Allocation error.\\n\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>    <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;malloc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;alloca.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">afunc</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> etext,edata,end;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> bss_var;\t\t\t\t<span class=\"comment\">//no init globel data must be in bss</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> data_var=<span class=\"number\">42</span>;\t\t\t<span class=\"comment\">//init globel data must be in data</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SHW_ADR(ID,I) printf(<span class=\"meta-string\">\"the %8s\\t is at adr:%8x\\n\"</span>,ID,&amp;I);\t\t<span class=\"comment\">//the macro to printf the addr</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc,<span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *p,*b,*nb;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Adr etext:%8x\\t Adr edata %8x\\t Adr end %8x\\t\\n\"</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\ntext Location:\\n\"</span>);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"main\"</span>,main);\t\t\t<span class=\"comment\">//text section function</span></span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"afunc\"</span>,afunc);\t\t\t<span class=\"comment\">//text section function</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nbss Location:\\n\"</span>);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"bss_var\"</span>,bss_var);\t\t<span class=\"comment\">//bss section var</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\ndata location:\\n\"</span>);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"data_var\"</span>,data_var);\t<span class=\"comment\">//data section var</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nStack Locations:\\n\"</span>);</span><br><span class=\"line\">\tafunc();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tp=(<span class=\"keyword\">char</span> *)alloca(<span class=\"number\">32</span>);\t\t\t<span class=\"comment\">//alloc memory from statck</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSHW_ADR(<span class=\"string\">\"start\"</span>,p);</span><br><span class=\"line\">\t\tSHW_ADR(<span class=\"string\">\"end\"</span>,p+<span class=\"number\">31</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tb=(<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">32</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>));\t<span class=\"comment\">//malloc memory from heap</span></span><br><span class=\"line\">\tnb=(<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">16</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nHeap Locations:\\n\"</span>);\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"the Heap start: %p\\n\"</span>,b);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"the Heap end:%p\\n\"</span>,(nb+<span class=\"number\">16</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>)));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nb and nb in Stack\\n\"</span>);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"b\"</span>,b);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"nb\"</span>,nb);</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(b);</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(nb);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afunc</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"keyword\">long</span> level=<span class=\"number\">0</span>;\t<span class=\"comment\">//data section static var</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t stack_var;\t\t\t\t<span class=\"comment\">//temp var ,in stack section</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(++level==<span class=\"number\">5</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"stack_var in stack section\"</span>,stack_var);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"Level in data section\"</span>,level);</span><br><span class=\"line\">\tafunc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"c执行期内存布局和调试：\"><a href=\"#c执行期内存布局和调试：\" class=\"headerlink\" title=\"c执行期内存布局和调试：\"></a>c执行期内存布局和调试：</h3><p>在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等<br>１、将目标文件装入:","more":"<br><em>１）重定位－－－　放在内存哪里<br> 2)  等待调度执行</em><br>这里可以使用gdb进行调试查看</p>\n<p>一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).<br>一个进程主要包括：<br>   在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等</p>\n<blockquote>\n<p>栈区　　高地址到低地址<br>堆区　　低地址到高地址<br>bss<br>数据<br>代码</p>\n</blockquote>\n<p> 以下将从两个维度进行对一个程序被执行成进程时，内存的情况：<br> １、各种段区的内存分布<br> ２、gdb 调试程序执行时的过程。－－可能涉及到汇编<br> －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>\n<h4 id=\"1、gdb-常用的命令和用法：\"><a href=\"#1、gdb-常用的命令和用法：\" class=\"headerlink\" title=\"1、gdb　常用的命令和用法：\"></a>1、gdb　常用的命令和用法：</h4><p>1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令<br> 2)设置断点：　<br>b 行号<br>b 函数名<br>b 行号　if 条件<br>eg:<br>break main  /  b main<br>  删除断点:delete 行号</p>\n<p>3)列出代码<br>l /list</p>\n<p>4)运行，start<br>  跳转到断点:c/continue   r/run<br>  until  行号　　　运行直到该行<br>5)观察变量b和地址<br>watch b  若变量值发生变化，则程序停止</p>\n<p>　p/print  b  看变量值<br>　p/print &amp;b　看变量地址<br> i  locals</p>\n<p> info registers 显示所有寄存器的值<br> 查看特定内存位置的值如：<br> print/x $eax   显示为16进制<br> print/t  2进制，　<br> print/d 十进制,<br>x/nyz  : n表示字段数，y为输出格式，z是字段长度</p>\n<p>６）单步调试<br> n/next   /   s/step　</p>\n<p> 7) 保存断点：<br> info b  查看断点信息<br> save breakpoint fig.dp 保存断点<br> 读取断点文件：　gdb hello -x fig.dp</p>\n<p> 退出quit</p>\n<p> <a href=\"http://bbs.chinaunix.net/thread-150524-1-1.html\" target=\"_blank\" rel=\"noopener\">http://bbs.chinaunix.net/thread-150524-1-1.html</a></p>\n<h4 id=\"2-使用kdbg\"><a href=\"#2-使用kdbg\" class=\"headerlink\" title=\"2 使用kdbg\"></a>2 使用kdbg</h4><p> 界面版本gdb  在gcc … -g后，用kdbg打开即可、<br> 查看程序运行时各个地址：<br>    <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SHW_ADR(ID,I) printf(<span class=\"meta-string\">\"the id %s \\t is at adr:%8X\\n\"</span>,ID,&amp;I);</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> etext,edata,end;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *cptr=<span class=\"string\">\"Hello World\\n\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buffer1[<span class=\"number\">25</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showit</span><span class=\"params\">(<span class=\"keyword\">char</span> *)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">   \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Adr etext:%8x\\tAdr edata:%8x \\t Adr end :%8x \\n\\n\"</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"main\"</span>,main);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"showit\"</span>,showit);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"cptr\"</span>,cptr);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"buffer1\"</span>,buffer1);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"i\"</span>,i);</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(buffer1,<span class=\"string\">\"A demonstration\\n\"</span>);</span><br><span class=\"line\">\twrite(<span class=\"number\">1</span>,buffer1,<span class=\"built_in\">strlen</span>(buffer1)+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;i&lt;<span class=\"number\">1</span>;++i)</span><br><span class=\"line\">\t\tshowit(cptr);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showit</span><span class=\"params\">(<span class=\"keyword\">char</span> *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *buffer2;</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"buffer2\"</span>,buffer2);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>((buffer2=(<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>((<span class=\"keyword\">unsigned</span>)(<span class=\"built_in\">strlen</span>(p)+<span class=\"number\">1</span>)))!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(buffer2,p);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,buffer2);</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(buffer2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Allocation error.\\n\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>    <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;malloc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;alloca.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">afunc</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> etext,edata,end;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> bss_var;\t\t\t\t<span class=\"comment\">//no init globel data must be in bss</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> data_var=<span class=\"number\">42</span>;\t\t\t<span class=\"comment\">//init globel data must be in data</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SHW_ADR(ID,I) printf(<span class=\"meta-string\">\"the %8s\\t is at adr:%8x\\n\"</span>,ID,&amp;I);\t\t<span class=\"comment\">//the macro to printf the addr</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc,<span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *p,*b,*nb;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Adr etext:%8x\\t Adr edata %8x\\t Adr end %8x\\t\\n\"</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\ntext Location:\\n\"</span>);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"main\"</span>,main);\t\t\t<span class=\"comment\">//text section function</span></span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"afunc\"</span>,afunc);\t\t\t<span class=\"comment\">//text section function</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nbss Location:\\n\"</span>);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"bss_var\"</span>,bss_var);\t\t<span class=\"comment\">//bss section var</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\ndata location:\\n\"</span>);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"data_var\"</span>,data_var);\t<span class=\"comment\">//data section var</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nStack Locations:\\n\"</span>);</span><br><span class=\"line\">\tafunc();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tp=(<span class=\"keyword\">char</span> *)alloca(<span class=\"number\">32</span>);\t\t\t<span class=\"comment\">//alloc memory from statck</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSHW_ADR(<span class=\"string\">\"start\"</span>,p);</span><br><span class=\"line\">\t\tSHW_ADR(<span class=\"string\">\"end\"</span>,p+<span class=\"number\">31</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tb=(<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">32</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>));\t<span class=\"comment\">//malloc memory from heap</span></span><br><span class=\"line\">\tnb=(<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">16</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nHeap Locations:\\n\"</span>);\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"the Heap start: %p\\n\"</span>,b);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"the Heap end:%p\\n\"</span>,(nb+<span class=\"number\">16</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>)));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nb and nb in Stack\\n\"</span>);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"b\"</span>,b);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"nb\"</span>,nb);</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(b);</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(nb);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afunc</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"keyword\">long</span> level=<span class=\"number\">0</span>;\t<span class=\"comment\">//data section static var</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>\t stack_var;\t\t\t\t<span class=\"comment\">//temp var ,in stack section</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(++level==<span class=\"number\">5</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"stack_var in stack section\"</span>,stack_var);</span><br><span class=\"line\">\tSHW_ADR(<span class=\"string\">\"Level in data section\"</span>,level);</span><br><span class=\"line\">\tafunc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"cpp_datamember_memory","date":"2018-06-09T06:46:49.000Z","_content":"### c++ class  datamemory\n详细介绍c++的成员布局，类本身的布局和在各种情况下的布局\n\n#### \"类\"本身的大小：\n+ the simplest 引入\n+ 1.2 多少内存能表现一个class?  \n最小是１　  size<!--more-->\n\n```c\nclass T{ };   ---1 一个char 表示这个类型\nclass X :public virtual T{};　　--指针大小，指针指向T  virtual base class subobject\nclass Y :public virtual T{};  --指针大小\nclass A:public X,public Y {};　--两个指针大小　```  \n－－从深入那本书中说有两种方式，体现class的大小，这里是优化的特殊的类型，这些好理解，但是需要类的空间的真正原因是什么？这T的一个char存储了什么？  \n用来干嘛？那在X中指向T的又是为什么需要？  \n最小１char?  \n我们知道，当一个类中仅包含一个nonstatic member时，如int ,则对象为int大小，但是当类为空时，对象如何去分配内存？\n如果同时定义了两个对象，那如何去区分这两个对象？让他们地址不相同？－－－所以这里需要一个char\n\n+ 注意，类本身也是一个类型，像int，struct一样，它的大小为４，struct成员和对齐，则类也一样，sizeof是在编译期间（确定c89中）  \n一个例子：\n```cpp\n#include<iostream>\n#define _sizeof(T) ((size_t)((T*)0+1))\n#include<stdio.h>\nusing namespace std;\nclass T {};\nclass X:public virtual T{};\nclass Y:public virtual T{};\nclass A :public X,public Y{};\nclass TT{public:int q;int x;};\nint main()\n{\n\t\tT t1,t2;\n\t\tint xx;\n\t\tif (&t1==&t2)\n\t\t\t\tcout<<\"same\"<<endl;\n\t\tprintf(\"%x\\n\",&t1);\n\t\tprintf(\"%x\\n\",&t2);\n        printf(\"%x\\n\",&xx);\n\t//\tint sie=(Y*)0+1;\n\t//\tprintf(\"%x\\n\",X{});\n\t    int s= _sizeof(TT);　８　编译期间确定，直接把８赋给内存\n        cout<<_sizeof(T)<<endl;　１\n\t\tcout<<sizeof(TT)<<endl;　　８\n\t\tcout<<sizeof(T)<<endl;\n\t\tcout<<sizeof(X)<<endl;\n\t\tcout<<sizeof(Y)<<endl;\n\t\tcout<<sizeof(A)<<endl;\n\t\treturn 0;\n}```\n自然t1,t2地址不同，相邻\n\n#### 那么一个类大的方面需要这些：\n１）类中定义的普通成员  \n２）语言本身所造成的额外负担如virtual机制，virtual table ,virtual base class subobject  \n３）Aligmnment带来的  \n（编译器的优化会带来内存布局的影响）\n\n上述例子：当编译器不做优化时，为１，8+1+3,8+1+3 ,1(X)+8+8+3(ali)\n\n#### 总结datamember的布局\n+ 对象只存非静态的成员变量，而无论中间放置了几个静态变量都不会影响他们之间的排布。\n　　　大部分的编译器将先定义的非静态成员变量放在低地址，而后的放在高地址。最好用时先用kdbg或测试程序等看下\n+ 静态成员的存取不通过对象，他们放在数据段中\n+ vptr一般会放在哪里？　\n　　对象的头或者尾巴\n+ align:C++标准要求，在同一个access section(private,public,protect等区段），member的排列只需要符和较晚出现放在较高的地址“即可，\n　　access sections的多少并不会带来额外的负担\n+ 我在g++上做了测试:\n\n```cpp\nclass TT{\n public:\n    int a;\n    char b;\n    };\n   sizeof{TT);   8\nclass TT{\n public:\n    int a;\n    char b;\n protect:\n    int c;\n    char d;\n    };\n   sizeof(TT)=16\nclass TT{\n public:\n    int a;\n    char b;\n protect:\n    int c;\n    char d;\n public:\n    int e;\n    char f;\n    };\n  sizeof(TT)=24 \nclass TT{\n public:\n    int a;\n    char b;\n    int e;\n    char f;\n protect:\n    int c;\n    char d;\n    };\n  sizeof(TT)=24\nclass TT{\n public:\n    int a;\n    int e;\n    char f;\n    char b;\n protect:\n    int c;\n    char d;\n    };\n  sizeof(TT)=20\n ```\n  由此看来这个编译器是按着c的struct对齐来的啊， \n\n\n#### data member的存取：\n+ 成本  \n比较：\n```cpp\n        TT tt1;\n\t\tTT *tt2=&tt1;\n0x400b87 lea    -0x20(%rbp),%rax\n0x400b8b mov    %rax,-0x48(%rbp)\n\t\tint d=tt1.d;\n0x400b8f mov    -0x1c(%rbp),%eax\n0x400b92 mov    %eax,-0x68(%rbp)\n\t\tint f=tt2->d;\n0x400b95 mov    -0x48(%rbp),%rax\n0x400b99 mov    0x4(%rax),%eax\n0x400b9c mov    %eax,-0x64(%rbp)\n```\n\n+ 对static成员啊而言，实际是在数据段中，所以不管什么形式的访问都是相同的\n待测试\n+ 通过成员函数\n需要通过this 指针，则同上例子中的指针访问\n\n### 总结几种情况下的的布局\n\n\n#### 单一继承不含多态\n##### 一个典型的例子如下\n```cpp\nclass Point2d{\n   public:\n    Point2d( float x=0.0,float y=0.0):_x(x),_y(y){};\n    float x() {return _x;}\n    float y() {return _y;}\n    void x(float newX) { _x=newX;}\n    void y(float newY) { _y=newY;}\n    void operator+= (const Point2d&  rhs) {\n        _x+=rhs.x();\n        _y+=rhs.y();\n        }\n    ...more member;\n   protected:\n      float _x,_y;\n};\nclass  Point3d: public Point2d{\n     public: \n        Point3d(float x=0.0,float y=0.0,float z=0.0):Point2d(x,y),_z(z){};\n        float z(){return _z;}\n        void z(float newZ){_z=newZ;} \n        void operator+=(const Point3d& rhs) {\n           Point2d::operator+=(rhs);\n           _z+=rhs.z();\n           }\n          ...more member               \n     protected:\n      float _z;\n};\n```\n##### 单一继承\n则　基类的成员被子类包含，放在较低的地址；相比之下，多了对齐的空间；\n```cpp\nclass Concrete {\n  public:\n    ...\n  private:\n     int val;\n     char c1;\n     char c2;\n     char c3;\n     };```\n则需要占用８bytes;\n\n而当被继承实现时：\n```cpp\n  class Concrete1{\n    public:\n    private: \n       int val;\n       char bit1;\n   };\n  class Concrete2：public Concrete1{\n    public:\n    private:\n         char bit2;\n   };\n   class  Concrete3:public Concrete2{\n   public:\n   private:\n      char bit3;\n      };\n      ```\n  由此带来成本 8+4+4=16\n  \n  + 那为什么要这么做的？继承的时候不能挤在一起吗？\n  （在深入c++对象模型中有图容易理解。这里仅说明：\n  　　　若：　Concrete2  *pc2;\n            Concrete1 *pc1_1,*pc1_2;\n            *pc1_2=*pc1_1; -默认复制构造\n            pc1_1 = pc2; //pc1_1指向pc2;\n            *pc1_2=*pc1_1;//覆盖掉了，如果继承是成员挤在一起，而不是对齐来的\n            \n            \n            \n\n\n\n##### 单一继承含多态：\n```cpp\n class Point2d{\n   public:\n    Point2d( float x=0.0,float y=0.0):_x(x),_y(y){};\n    float x() {return _x;}\n    float y() {return _y;}\n    virtual float z(){return 0.0;} \n    virtual void z(float){}  \n    void x(float newX) { _x=newX;}\n    void y(float newY) { _y=newY;}\n    virtual void operator+= (const Point2d&  rhs) {\n        _x+=rhs.x();\n        _y+=rhs.y();\n        }\n    ...more member;\n   protected:\n      float _x,_y;\n};\nclass  Point3d: public Point2d{\n     public: \n        Point3d(float x=0.0,float y=0.0,float z=0.0):Point2d(x,y),_z(z){};\n        virtual float z(){return _z;}\n        virtual void z(float newZ){_z=newZ;}\n        \n        virtual void operator+=(const Point3d& rhs) {\n           Point2d::operator+=(rhs);\n           _z+=rhs.z();\n           }\n          ...more member     \n     protected:\n      float _z;\n};```\n由此可以满足\n```cpp\n　　　void fool(Point2d &p1,Point2d &p2){\n     p1+=p2;\n     }```\n可以是Point2d和Point3d 这种弹性，牺牲了时间和空间\n加入了什么呢？  \n\n       virtual table\n       vptr\n\t   add constructor vptr setting\n       add destructor vptr virtual table dele\n\n所以需要视情况而定，如若只是涉及到2d&3d之间，则可以是\n```cpp\n  virtual void operator+=(const Point２d& rhs) {\n           Point2d::operator+=(rhs);\n           _z+=rhs.z();//此时＋０\n           }\nPoint2d p2d(...)\nPoint3d p3d(,,,,);\np3d+=p2d\n```\n另外：对vptr的摆放位置，若放在最后面，则兼容c\n但是损失了对继承的更好支持，所以现在放在最前面\n\n\n##### 多重继承\n多重继承考虑的问题较多？但从设计角度看，你可能会问？\n对比单一继承，子类成员起始地址和基类相同，那多重继承，和哪个基类一样？其他基类怎么办，在向上转型如何处理，指针呢？\n\n另外，在单一继承中，vptr放在最开始的地方，如果base class没有virtual func而derived　class有呢？则此时单一继承的自然多态被打破，\n若此时把一个derived class 转换为base class则　需要编译器介入，在多重继承+虚拟继承下就更有必要了\n\n考虑这个例子：\n```cpp\n　class Point2d{ 带virtual 接口\n   public: \n   protected:\n       float _x _y;\n       };\n class Point3d:public Point2d{\n    public:\n    protectd:\n       float _z;\n       }'\n  class Vertex {带virtual接口\n      protected:\n         Vertex *next;\n    };    \n  class Vertex3d:public Point3d,public Vertex {\n    protexted:\n      float mumble;\n      } ```\n\n对多重继承派生对象，若将其地址　指定给最左端的base class则情况同单一继承一样，因为二者指向相同的地址。但是对第二个及以上时\n需要将地址修改，加上或减去　介于中间的base class subobject\n```cpp\n  eg:  Vertex3d v3d;\n        Vertex *pv;\n        Point２d *p2d\n        POint3d  *p3d;  \n        pv=&v3d\n     则内部为：pv=(Vertex*)(((char*)&v3d)+sizeof(Point3d));     \n     而对p2d=&v3d;\n         p3d=&v3d则只需要简单的拷贝\n```              \n      若为Vertex3d　*v3d;  pv=v3d;则内部还要进行判断空。因为*v3d可能为空，\n      而引用不用，因为引用不可能参考到无\n对存取其第二个基类成员，也是做类似的offset操作\n##### 虚拟继承\n在多重继承加虚拟继承时，如ios istream ostream\n前面的内容会好理解一些，这部分的内容不好理解，也有些繁琐，于是，我回到之前学习的方法，即为什么，出现的原因，如果是自己实现又如何，等思考：\n+ 为什么需要虚拟继承？  \n虚拟继承出现，是因为当基类2和3都继承了基类1，而基类4继承了2和3，则基类4会同时拥有两份基类1，而虚拟继承就是为了让基类4只包含一份基类1，形成菱形继承结构\n```cpp\nclass ios{..}\nclass istream:public virtual ios{..}\nclass ostream:public virtual ios{..}\nclass iostream:\npublic istream, public ostream {..}```\n那么，虚拟继承是如何做，使得类4能只包含1份基类1，而不影响其他功能呢：\n+ 梳理下：  \n上述例子：挑战在于，将istream 和ostream 各自维护的一个ios subobj ，折叠为一个由iostream维护的单一ios subobj ，\n并且还可以保存base class 和derived class的指针（以及reference)之间的多态操作  \n 一般的实现方式如下： class 如果内含一个或者多个virtual base class obj,像istream那样，将被分割为两部分，一个不变的局部和一个共享局部  \n 不变的局部中的数据，不管后继如何演化，都总是拥有固定的offset(从obj头算起），这部分数据可以直接存取，共享局部，则是virtual base class subject，这部分数据位置会因为每次派生发生变化，所以他们只能被间接存取  \n \n 所以就是：istream 中有自己的和ios相关的部分，这部分为共享部分\n```cpp\n  class Point2d _x _y\n class Point3d:public virtual Point2d  _z\n class Vertex:public virtual Point2d\n class Vertex3d:public Point3d public Vertex \n ```\n 那 istream 如何存取这部分共享的数据？和iostream共享？感觉有点像单例模式\n+  cfront是这样实现的：（这语言没见过）： 会在每个derived class obj中安插一些指针，每个指针 指向一个virtual base class 存取继承得来的virtual base\nclass member;所以在存取时通过这个指针存取\n在多层继承时间接存取次数多；每个对象需要为每个virtual base class 背负一个指针）\n                     void Point3d::operator+=(const Point3d &rhs) {\n                      _x+=rhs._x;\n                      _y+=rhs._y;\n                      _z+=rhs._z;\n                      }\n                     则在这里：被转为：伪代码：_vbcPoint2d->_x+=rhs.__vbcPoint2d->_x;//vbc==virtual base class\n                     ....\n                    \n                    而Point2d *2d=3d;\n                    Point2d *2d=3d? 3d->__vbcPoint2d:0;\n                    \n                    \n + microsoft ：引入类似于vbtable的方法，引入virtual base class table 。而在对象中放一个指针指向该表，表则放置那些指向virtual base class 指针\n Bjarne: g++等（现在可能变了，但是类似）：\n           在虚函数表中放置virtual base class 的offset而不是地址。\n           在这里，上面的例子：（this+__vbtr__point3d[-1])->_x+= (&rhs+rhs.__vptr__point3d[-1])->_x;\n           ...\n           Point2d *2d=3d?3d+3d->__vptr__point3d[-1]:0\n           \n + 注意：若是基类1含有virtual func则会拥有一个vptr指向自己的vtable. 而虚拟继承它的基类2,3，基类2,3本身含有virtual func则不会通过继承基类1的方式\n 继承它的vptr,所以可以看到在书中的图中point3d有两个指针vptr,以下例子通过kdbg调试可以看到这个两个vptr\n \n+ 两个问题：\n+ 基类1在继承连增加时位置如何变化？\n+ 在基类自己有virtual func时为什么要自己独用一个vptr?\n```cpp\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\nclass Point2d {\n                public: virtual float printx(){return _x;}\n\t\tprotected:\n\t\t\t\tfloat _x,_y;\n};\nclass Vertex:public virtual Point2d{\n\t\tprotected:\n\t\t\t\tVertex *next;\n};\nclass Point3d:public virtual Point2d{\n\t\tprotected:\n\t\t\t\tfloat _z;\n};\nclass Vertex3d:public Vertex,public Point3d{\n\t\tprotected:\n\t\t\t\tfloat mumble;\n};\nclass PO{\n\t\tpublic:\n\t\t    // virtual ~PO();\n\t\t\t static int origin;\n\t\t\t float x,y,z;\n};\nint PO::origin =3;\nint main()\n{\n\t\tPoint2d d2d;\n\t\tPoint3d d3d;\n\t\tVertex vx;\n\t\tVertex3d v3x;\n\t\tPO po;\n        printf(\"%d\\n\",& PO::z);\n\t\tprintf(\"%d\\n\",&po);\n\t\tprintf(\"%d\\n\",&po.x);\n\t\tprintf(\"%d\\n\",&po.y);\n//\t\tprintf(\"%d\\n\",&po.origin);\n\t\tfloat PO::*p1=0;\n\t\tfloat PO::*p2=&PO::x;\n\t\tif(p1==p2)\n\t\t\t\tcout<<\"sma\"<<endl;\n\t\treturn 0;\n}          \n```\n##### 使用gdb调试：\n写完程序后：\n编译时加-g\ngdb 科执行程序名\n\n+ 设置断点：break 行号\ns向下执行\nset p obj <on/off>: 在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。 使用show print object查看对象选项的设置。\nset p pertty <on/off>: 按照层次打印结构体。可以从设置前后看到这个区别。on的确更容易阅读。\n```c\nset p obj on\nset p pertty on\np 对象名\np /a ((void ***)d3d)[0]@18 //看到更详细的内存 @18为打印的成员数，[0]指从第0个开始打印--感觉不太对\np /a ((void **)vx)[0]@16//同上\n(gdb) p b\n$1 = {_vptr.Base = 0x400a60 <vtable for Base+16>}\n(gdb) x/16x 0x400a60\n0x400a60 <_ZTV4Base+16>:    0x0040094c  0x00000000  0x72654437  0x64657669\n(gdb) x/16x 0x0040094c\n0x40094c <Base::f()>:   0xe5894855  0x10ec8348  0xf87d8948  0x400a15be\n0x40095c <Base::f()+16>:    0x10c0bf00  0xf9e80060  0xc9fffffd  0x485590c3\n0x40096c <Derived::f()+2>:  0x8348e589  0x894810ec  0x1bbef87d  0xbf00400a\n0x40097c <Derived::f()+18>: 0x006010c0  0xfffddbe8  0x66c3c9ff  0x00841f0f\n  (gdb) set $i = 0\n  (gdb) while $i < 10\n     >print $i\n     >p /a (*(void ***)obj)[$i]\n     >set $i = $i + 1\n     >end\nWhere \"obj\" is the object whose vtable you'd like to print, and 10 is the number of methods.\np /a (*(void ***)obj)[0]@10\ninfo address _ZTV3Bar\n```\n\n\n\n\n\n\n#### 对象成员的效率\n#### 指向对象成员变量的指针\n可以用于测试底层布局，如vptr放在哪，access section 次序。等\n例子：\n```cpp\n　　　class Point3d {\n     public :\n        virtual ~Point3d();\n     protected:\n        static Point3d origin；\n        float x,y,z;\n}\n```\n\n1)&Point3d::z  --得到z在class obj中的偏移量\n需用printf\n        \n书中说的为了使得指向对象和对象成员的指针区分，而+1,在g++中没有怎么体现：\n```cpp\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\nclass Point3d{\n\t\tpublic:\n\t//\t\t\tvirtual ~Point3d(){;}\n\t\t\t\tstatic Point3d origin;\n\t\t\t\tfloat x,y,z;\n};\nPoint3d Point3d::origin;\nint main ()\n{\n        Point3d p3d;\n\t\tprintf(\"&Point3d=%p\\n\",&p3d);\n\t\tprintf(\"&Point3d=%p\\n\",&p3d.x);//这两个地址相同\n\t\tprintf(\"&Point3d=%p\\n\",&p3d.y);\n\t\tprintf(\"&Point3d::x=%p\\n\",&Point3d::x);//nil,若Point3d带virtual func,则为8\n\t\tprintf(\"&Point3d::y=%p\\n\",&Point3d::y);\n\t\tprintf(\"&Point3d::z=%p\\n\",&Point3d::z);\n\t\tif((float*)&p3d==(float*)&p3d.x)cout<<\"yes\"<<endl; //输出yes\n\t\tfloat Point3d::*p1=0;\n\t\tfloat Point3d::*p2=&Point3d::x;\n\t\tfloat Point3d::*p3=NULL;\n\t\tif(p1==p2)//未输出\n\t\t{\n\t\t\t\tcout<<\"p1==p2\"<<endl;//no output in g++\n\t\t}\n        if(p2==p3)\n\t\t{\n\t\t\t\tcout<<\"p2==p3\"<<endl;//no output in g++\n\t\t}\n\t\treturn 0;\n}```\n在这里若是加了virtual func则，x为8，说明是vptr是放在前面的\n通过指针取得对象成员:  \n```cpp\n                    float *p=origin.z  \n                    struct  Base1{int val1;}\n                    struct Base2 (int val2;}\n                    struct Derved:Base1,Base2{..}\n                    void func1(int Derved::*bmp,Derved *pd)//传入offset等，多继承时易出错\n                    {\n                       pd->*dmp;.....```\n","source":"_posts/cpp-datamember-memory.md","raw":"---\ntitle: cpp_datamember_memory\ndate: 2018-06-09 14:46:49\ntags: cpp_class\ncategories: c&cpp\n---\n### c++ class  datamemory\n详细介绍c++的成员布局，类本身的布局和在各种情况下的布局\n\n#### \"类\"本身的大小：\n+ the simplest 引入\n+ 1.2 多少内存能表现一个class?  \n最小是１　  size<!--more-->\n\n```c\nclass T{ };   ---1 一个char 表示这个类型\nclass X :public virtual T{};　　--指针大小，指针指向T  virtual base class subobject\nclass Y :public virtual T{};  --指针大小\nclass A:public X,public Y {};　--两个指针大小　```  \n－－从深入那本书中说有两种方式，体现class的大小，这里是优化的特殊的类型，这些好理解，但是需要类的空间的真正原因是什么？这T的一个char存储了什么？  \n用来干嘛？那在X中指向T的又是为什么需要？  \n最小１char?  \n我们知道，当一个类中仅包含一个nonstatic member时，如int ,则对象为int大小，但是当类为空时，对象如何去分配内存？\n如果同时定义了两个对象，那如何去区分这两个对象？让他们地址不相同？－－－所以这里需要一个char\n\n+ 注意，类本身也是一个类型，像int，struct一样，它的大小为４，struct成员和对齐，则类也一样，sizeof是在编译期间（确定c89中）  \n一个例子：\n```cpp\n#include<iostream>\n#define _sizeof(T) ((size_t)((T*)0+1))\n#include<stdio.h>\nusing namespace std;\nclass T {};\nclass X:public virtual T{};\nclass Y:public virtual T{};\nclass A :public X,public Y{};\nclass TT{public:int q;int x;};\nint main()\n{\n\t\tT t1,t2;\n\t\tint xx;\n\t\tif (&t1==&t2)\n\t\t\t\tcout<<\"same\"<<endl;\n\t\tprintf(\"%x\\n\",&t1);\n\t\tprintf(\"%x\\n\",&t2);\n        printf(\"%x\\n\",&xx);\n\t//\tint sie=(Y*)0+1;\n\t//\tprintf(\"%x\\n\",X{});\n\t    int s= _sizeof(TT);　８　编译期间确定，直接把８赋给内存\n        cout<<_sizeof(T)<<endl;　１\n\t\tcout<<sizeof(TT)<<endl;　　８\n\t\tcout<<sizeof(T)<<endl;\n\t\tcout<<sizeof(X)<<endl;\n\t\tcout<<sizeof(Y)<<endl;\n\t\tcout<<sizeof(A)<<endl;\n\t\treturn 0;\n}```\n自然t1,t2地址不同，相邻\n\n#### 那么一个类大的方面需要这些：\n１）类中定义的普通成员  \n２）语言本身所造成的额外负担如virtual机制，virtual table ,virtual base class subobject  \n３）Aligmnment带来的  \n（编译器的优化会带来内存布局的影响）\n\n上述例子：当编译器不做优化时，为１，8+1+3,8+1+3 ,1(X)+8+8+3(ali)\n\n#### 总结datamember的布局\n+ 对象只存非静态的成员变量，而无论中间放置了几个静态变量都不会影响他们之间的排布。\n　　　大部分的编译器将先定义的非静态成员变量放在低地址，而后的放在高地址。最好用时先用kdbg或测试程序等看下\n+ 静态成员的存取不通过对象，他们放在数据段中\n+ vptr一般会放在哪里？　\n　　对象的头或者尾巴\n+ align:C++标准要求，在同一个access section(private,public,protect等区段），member的排列只需要符和较晚出现放在较高的地址“即可，\n　　access sections的多少并不会带来额外的负担\n+ 我在g++上做了测试:\n\n```cpp\nclass TT{\n public:\n    int a;\n    char b;\n    };\n   sizeof{TT);   8\nclass TT{\n public:\n    int a;\n    char b;\n protect:\n    int c;\n    char d;\n    };\n   sizeof(TT)=16\nclass TT{\n public:\n    int a;\n    char b;\n protect:\n    int c;\n    char d;\n public:\n    int e;\n    char f;\n    };\n  sizeof(TT)=24 \nclass TT{\n public:\n    int a;\n    char b;\n    int e;\n    char f;\n protect:\n    int c;\n    char d;\n    };\n  sizeof(TT)=24\nclass TT{\n public:\n    int a;\n    int e;\n    char f;\n    char b;\n protect:\n    int c;\n    char d;\n    };\n  sizeof(TT)=20\n ```\n  由此看来这个编译器是按着c的struct对齐来的啊， \n\n\n#### data member的存取：\n+ 成本  \n比较：\n```cpp\n        TT tt1;\n\t\tTT *tt2=&tt1;\n0x400b87 lea    -0x20(%rbp),%rax\n0x400b8b mov    %rax,-0x48(%rbp)\n\t\tint d=tt1.d;\n0x400b8f mov    -0x1c(%rbp),%eax\n0x400b92 mov    %eax,-0x68(%rbp)\n\t\tint f=tt2->d;\n0x400b95 mov    -0x48(%rbp),%rax\n0x400b99 mov    0x4(%rax),%eax\n0x400b9c mov    %eax,-0x64(%rbp)\n```\n\n+ 对static成员啊而言，实际是在数据段中，所以不管什么形式的访问都是相同的\n待测试\n+ 通过成员函数\n需要通过this 指针，则同上例子中的指针访问\n\n### 总结几种情况下的的布局\n\n\n#### 单一继承不含多态\n##### 一个典型的例子如下\n```cpp\nclass Point2d{\n   public:\n    Point2d( float x=0.0,float y=0.0):_x(x),_y(y){};\n    float x() {return _x;}\n    float y() {return _y;}\n    void x(float newX) { _x=newX;}\n    void y(float newY) { _y=newY;}\n    void operator+= (const Point2d&  rhs) {\n        _x+=rhs.x();\n        _y+=rhs.y();\n        }\n    ...more member;\n   protected:\n      float _x,_y;\n};\nclass  Point3d: public Point2d{\n     public: \n        Point3d(float x=0.0,float y=0.0,float z=0.0):Point2d(x,y),_z(z){};\n        float z(){return _z;}\n        void z(float newZ){_z=newZ;} \n        void operator+=(const Point3d& rhs) {\n           Point2d::operator+=(rhs);\n           _z+=rhs.z();\n           }\n          ...more member               \n     protected:\n      float _z;\n};\n```\n##### 单一继承\n则　基类的成员被子类包含，放在较低的地址；相比之下，多了对齐的空间；\n```cpp\nclass Concrete {\n  public:\n    ...\n  private:\n     int val;\n     char c1;\n     char c2;\n     char c3;\n     };```\n则需要占用８bytes;\n\n而当被继承实现时：\n```cpp\n  class Concrete1{\n    public:\n    private: \n       int val;\n       char bit1;\n   };\n  class Concrete2：public Concrete1{\n    public:\n    private:\n         char bit2;\n   };\n   class  Concrete3:public Concrete2{\n   public:\n   private:\n      char bit3;\n      };\n      ```\n  由此带来成本 8+4+4=16\n  \n  + 那为什么要这么做的？继承的时候不能挤在一起吗？\n  （在深入c++对象模型中有图容易理解。这里仅说明：\n  　　　若：　Concrete2  *pc2;\n            Concrete1 *pc1_1,*pc1_2;\n            *pc1_2=*pc1_1; -默认复制构造\n            pc1_1 = pc2; //pc1_1指向pc2;\n            *pc1_2=*pc1_1;//覆盖掉了，如果继承是成员挤在一起，而不是对齐来的\n            \n            \n            \n\n\n\n##### 单一继承含多态：\n```cpp\n class Point2d{\n   public:\n    Point2d( float x=0.0,float y=0.0):_x(x),_y(y){};\n    float x() {return _x;}\n    float y() {return _y;}\n    virtual float z(){return 0.0;} \n    virtual void z(float){}  \n    void x(float newX) { _x=newX;}\n    void y(float newY) { _y=newY;}\n    virtual void operator+= (const Point2d&  rhs) {\n        _x+=rhs.x();\n        _y+=rhs.y();\n        }\n    ...more member;\n   protected:\n      float _x,_y;\n};\nclass  Point3d: public Point2d{\n     public: \n        Point3d(float x=0.0,float y=0.0,float z=0.0):Point2d(x,y),_z(z){};\n        virtual float z(){return _z;}\n        virtual void z(float newZ){_z=newZ;}\n        \n        virtual void operator+=(const Point3d& rhs) {\n           Point2d::operator+=(rhs);\n           _z+=rhs.z();\n           }\n          ...more member     \n     protected:\n      float _z;\n};```\n由此可以满足\n```cpp\n　　　void fool(Point2d &p1,Point2d &p2){\n     p1+=p2;\n     }```\n可以是Point2d和Point3d 这种弹性，牺牲了时间和空间\n加入了什么呢？  \n\n       virtual table\n       vptr\n\t   add constructor vptr setting\n       add destructor vptr virtual table dele\n\n所以需要视情况而定，如若只是涉及到2d&3d之间，则可以是\n```cpp\n  virtual void operator+=(const Point２d& rhs) {\n           Point2d::operator+=(rhs);\n           _z+=rhs.z();//此时＋０\n           }\nPoint2d p2d(...)\nPoint3d p3d(,,,,);\np3d+=p2d\n```\n另外：对vptr的摆放位置，若放在最后面，则兼容c\n但是损失了对继承的更好支持，所以现在放在最前面\n\n\n##### 多重继承\n多重继承考虑的问题较多？但从设计角度看，你可能会问？\n对比单一继承，子类成员起始地址和基类相同，那多重继承，和哪个基类一样？其他基类怎么办，在向上转型如何处理，指针呢？\n\n另外，在单一继承中，vptr放在最开始的地方，如果base class没有virtual func而derived　class有呢？则此时单一继承的自然多态被打破，\n若此时把一个derived class 转换为base class则　需要编译器介入，在多重继承+虚拟继承下就更有必要了\n\n考虑这个例子：\n```cpp\n　class Point2d{ 带virtual 接口\n   public: \n   protected:\n       float _x _y;\n       };\n class Point3d:public Point2d{\n    public:\n    protectd:\n       float _z;\n       }'\n  class Vertex {带virtual接口\n      protected:\n         Vertex *next;\n    };    \n  class Vertex3d:public Point3d,public Vertex {\n    protexted:\n      float mumble;\n      } ```\n\n对多重继承派生对象，若将其地址　指定给最左端的base class则情况同单一继承一样，因为二者指向相同的地址。但是对第二个及以上时\n需要将地址修改，加上或减去　介于中间的base class subobject\n```cpp\n  eg:  Vertex3d v3d;\n        Vertex *pv;\n        Point２d *p2d\n        POint3d  *p3d;  \n        pv=&v3d\n     则内部为：pv=(Vertex*)(((char*)&v3d)+sizeof(Point3d));     \n     而对p2d=&v3d;\n         p3d=&v3d则只需要简单的拷贝\n```              \n      若为Vertex3d　*v3d;  pv=v3d;则内部还要进行判断空。因为*v3d可能为空，\n      而引用不用，因为引用不可能参考到无\n对存取其第二个基类成员，也是做类似的offset操作\n##### 虚拟继承\n在多重继承加虚拟继承时，如ios istream ostream\n前面的内容会好理解一些，这部分的内容不好理解，也有些繁琐，于是，我回到之前学习的方法，即为什么，出现的原因，如果是自己实现又如何，等思考：\n+ 为什么需要虚拟继承？  \n虚拟继承出现，是因为当基类2和3都继承了基类1，而基类4继承了2和3，则基类4会同时拥有两份基类1，而虚拟继承就是为了让基类4只包含一份基类1，形成菱形继承结构\n```cpp\nclass ios{..}\nclass istream:public virtual ios{..}\nclass ostream:public virtual ios{..}\nclass iostream:\npublic istream, public ostream {..}```\n那么，虚拟继承是如何做，使得类4能只包含1份基类1，而不影响其他功能呢：\n+ 梳理下：  \n上述例子：挑战在于，将istream 和ostream 各自维护的一个ios subobj ，折叠为一个由iostream维护的单一ios subobj ，\n并且还可以保存base class 和derived class的指针（以及reference)之间的多态操作  \n 一般的实现方式如下： class 如果内含一个或者多个virtual base class obj,像istream那样，将被分割为两部分，一个不变的局部和一个共享局部  \n 不变的局部中的数据，不管后继如何演化，都总是拥有固定的offset(从obj头算起），这部分数据可以直接存取，共享局部，则是virtual base class subject，这部分数据位置会因为每次派生发生变化，所以他们只能被间接存取  \n \n 所以就是：istream 中有自己的和ios相关的部分，这部分为共享部分\n```cpp\n  class Point2d _x _y\n class Point3d:public virtual Point2d  _z\n class Vertex:public virtual Point2d\n class Vertex3d:public Point3d public Vertex \n ```\n 那 istream 如何存取这部分共享的数据？和iostream共享？感觉有点像单例模式\n+  cfront是这样实现的：（这语言没见过）： 会在每个derived class obj中安插一些指针，每个指针 指向一个virtual base class 存取继承得来的virtual base\nclass member;所以在存取时通过这个指针存取\n在多层继承时间接存取次数多；每个对象需要为每个virtual base class 背负一个指针）\n                     void Point3d::operator+=(const Point3d &rhs) {\n                      _x+=rhs._x;\n                      _y+=rhs._y;\n                      _z+=rhs._z;\n                      }\n                     则在这里：被转为：伪代码：_vbcPoint2d->_x+=rhs.__vbcPoint2d->_x;//vbc==virtual base class\n                     ....\n                    \n                    而Point2d *2d=3d;\n                    Point2d *2d=3d? 3d->__vbcPoint2d:0;\n                    \n                    \n + microsoft ：引入类似于vbtable的方法，引入virtual base class table 。而在对象中放一个指针指向该表，表则放置那些指向virtual base class 指针\n Bjarne: g++等（现在可能变了，但是类似）：\n           在虚函数表中放置virtual base class 的offset而不是地址。\n           在这里，上面的例子：（this+__vbtr__point3d[-1])->_x+= (&rhs+rhs.__vptr__point3d[-1])->_x;\n           ...\n           Point2d *2d=3d?3d+3d->__vptr__point3d[-1]:0\n           \n + 注意：若是基类1含有virtual func则会拥有一个vptr指向自己的vtable. 而虚拟继承它的基类2,3，基类2,3本身含有virtual func则不会通过继承基类1的方式\n 继承它的vptr,所以可以看到在书中的图中point3d有两个指针vptr,以下例子通过kdbg调试可以看到这个两个vptr\n \n+ 两个问题：\n+ 基类1在继承连增加时位置如何变化？\n+ 在基类自己有virtual func时为什么要自己独用一个vptr?\n```cpp\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\nclass Point2d {\n                public: virtual float printx(){return _x;}\n\t\tprotected:\n\t\t\t\tfloat _x,_y;\n};\nclass Vertex:public virtual Point2d{\n\t\tprotected:\n\t\t\t\tVertex *next;\n};\nclass Point3d:public virtual Point2d{\n\t\tprotected:\n\t\t\t\tfloat _z;\n};\nclass Vertex3d:public Vertex,public Point3d{\n\t\tprotected:\n\t\t\t\tfloat mumble;\n};\nclass PO{\n\t\tpublic:\n\t\t    // virtual ~PO();\n\t\t\t static int origin;\n\t\t\t float x,y,z;\n};\nint PO::origin =3;\nint main()\n{\n\t\tPoint2d d2d;\n\t\tPoint3d d3d;\n\t\tVertex vx;\n\t\tVertex3d v3x;\n\t\tPO po;\n        printf(\"%d\\n\",& PO::z);\n\t\tprintf(\"%d\\n\",&po);\n\t\tprintf(\"%d\\n\",&po.x);\n\t\tprintf(\"%d\\n\",&po.y);\n//\t\tprintf(\"%d\\n\",&po.origin);\n\t\tfloat PO::*p1=0;\n\t\tfloat PO::*p2=&PO::x;\n\t\tif(p1==p2)\n\t\t\t\tcout<<\"sma\"<<endl;\n\t\treturn 0;\n}          \n```\n##### 使用gdb调试：\n写完程序后：\n编译时加-g\ngdb 科执行程序名\n\n+ 设置断点：break 行号\ns向下执行\nset p obj <on/off>: 在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。 使用show print object查看对象选项的设置。\nset p pertty <on/off>: 按照层次打印结构体。可以从设置前后看到这个区别。on的确更容易阅读。\n```c\nset p obj on\nset p pertty on\np 对象名\np /a ((void ***)d3d)[0]@18 //看到更详细的内存 @18为打印的成员数，[0]指从第0个开始打印--感觉不太对\np /a ((void **)vx)[0]@16//同上\n(gdb) p b\n$1 = {_vptr.Base = 0x400a60 <vtable for Base+16>}\n(gdb) x/16x 0x400a60\n0x400a60 <_ZTV4Base+16>:    0x0040094c  0x00000000  0x72654437  0x64657669\n(gdb) x/16x 0x0040094c\n0x40094c <Base::f()>:   0xe5894855  0x10ec8348  0xf87d8948  0x400a15be\n0x40095c <Base::f()+16>:    0x10c0bf00  0xf9e80060  0xc9fffffd  0x485590c3\n0x40096c <Derived::f()+2>:  0x8348e589  0x894810ec  0x1bbef87d  0xbf00400a\n0x40097c <Derived::f()+18>: 0x006010c0  0xfffddbe8  0x66c3c9ff  0x00841f0f\n  (gdb) set $i = 0\n  (gdb) while $i < 10\n     >print $i\n     >p /a (*(void ***)obj)[$i]\n     >set $i = $i + 1\n     >end\nWhere \"obj\" is the object whose vtable you'd like to print, and 10 is the number of methods.\np /a (*(void ***)obj)[0]@10\ninfo address _ZTV3Bar\n```\n\n\n\n\n\n\n#### 对象成员的效率\n#### 指向对象成员变量的指针\n可以用于测试底层布局，如vptr放在哪，access section 次序。等\n例子：\n```cpp\n　　　class Point3d {\n     public :\n        virtual ~Point3d();\n     protected:\n        static Point3d origin；\n        float x,y,z;\n}\n```\n\n1)&Point3d::z  --得到z在class obj中的偏移量\n需用printf\n        \n书中说的为了使得指向对象和对象成员的指针区分，而+1,在g++中没有怎么体现：\n```cpp\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\nclass Point3d{\n\t\tpublic:\n\t//\t\t\tvirtual ~Point3d(){;}\n\t\t\t\tstatic Point3d origin;\n\t\t\t\tfloat x,y,z;\n};\nPoint3d Point3d::origin;\nint main ()\n{\n        Point3d p3d;\n\t\tprintf(\"&Point3d=%p\\n\",&p3d);\n\t\tprintf(\"&Point3d=%p\\n\",&p3d.x);//这两个地址相同\n\t\tprintf(\"&Point3d=%p\\n\",&p3d.y);\n\t\tprintf(\"&Point3d::x=%p\\n\",&Point3d::x);//nil,若Point3d带virtual func,则为8\n\t\tprintf(\"&Point3d::y=%p\\n\",&Point3d::y);\n\t\tprintf(\"&Point3d::z=%p\\n\",&Point3d::z);\n\t\tif((float*)&p3d==(float*)&p3d.x)cout<<\"yes\"<<endl; //输出yes\n\t\tfloat Point3d::*p1=0;\n\t\tfloat Point3d::*p2=&Point3d::x;\n\t\tfloat Point3d::*p3=NULL;\n\t\tif(p1==p2)//未输出\n\t\t{\n\t\t\t\tcout<<\"p1==p2\"<<endl;//no output in g++\n\t\t}\n        if(p2==p3)\n\t\t{\n\t\t\t\tcout<<\"p2==p3\"<<endl;//no output in g++\n\t\t}\n\t\treturn 0;\n}```\n在这里若是加了virtual func则，x为8，说明是vptr是放在前面的\n通过指针取得对象成员:  \n```cpp\n                    float *p=origin.z  \n                    struct  Base1{int val1;}\n                    struct Base2 (int val2;}\n                    struct Derved:Base1,Base2{..}\n                    void func1(int Derved::*bmp,Derved *pd)//传入offset等，多继承时易出错\n                    {\n                       pd->*dmp;.....```\n","slug":"cpp-datamember-memory","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7nt000y2ujxbw1xpv9a","content":"<h3 id=\"c-class-datamemory\"><a href=\"#c-class-datamemory\" class=\"headerlink\" title=\"c++ class  datamemory\"></a>c++ class  datamemory</h3><p>详细介绍c++的成员布局，类本身的布局和在各种情况下的布局</p>\n<h4 id=\"“类”本身的大小：\"><a href=\"#“类”本身的大小：\" class=\"headerlink\" title=\"“类”本身的大小：\"></a>“类”本身的大小：</h4><ul>\n<li>the simplest 引入</li>\n<li>1.2 多少内存能表现一个class?<br>最小是１　  size<a id=\"more\"></a></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&#123;</span> &#125;;   --<span class=\"number\">-1</span> 一个<span class=\"keyword\">char</span> 表示这个类型</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> :</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> T&#123;&#125;;　　--指针大小，指针指向T  <span class=\"keyword\">virtual</span> base <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">subobject</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Y</span> :</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> T&#123;&#125;;  --指针大小</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span><span class=\"keyword\">public</span> X,<span class=\"keyword\">public</span> Y &#123;&#125;;　--两个指针大小　```  </span><br><span class=\"line\">－－从深入那本书中说有两种方式，体现<span class=\"class\"><span class=\"keyword\">class</span>的大小，这里是优化的特殊的类型，这些好理解，但是需要类的空间的真正原因是什么？这<span class=\"title\">T</span>的一个<span class=\"title\">char</span>存储了什么？  </span></span><br><span class=\"line\"><span class=\"class\">用来干嘛？那在<span class=\"title\">X</span>中指向<span class=\"title\">T</span>的又是为什么需要？  </span></span><br><span class=\"line\"><span class=\"class\">最小１<span class=\"title\">char</span>?  </span></span><br><span class=\"line\"><span class=\"class\">我们知道，当一个类中仅包含一个<span class=\"title\">nonstatic</span> <span class=\"title\">member</span>时，如<span class=\"title\">int</span> ,则对象为<span class=\"title\">int</span>大小，但是当类为空时，对象如何去分配内存？</span></span><br><span class=\"line\"><span class=\"class\">如果同时定义了两个对象，那如何去区分这两个对象？让他们地址不相同？－－－所以这里需要一个<span class=\"title\">char</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">+ 注意，类本身也是一个类型，像<span class=\"title\">int</span>，<span class=\"title\">struct</span>一样，它的大小为４，<span class=\"title\">struct</span>成员和对齐，则类也一样，<span class=\"title\">sizeof</span>是在编译期间（确定<span class=\"title\">c89</span>中）  </span></span><br><span class=\"line\"><span class=\"class\">一个例子：</span></span><br><span class=\"line\"><span class=\"class\">```<span class=\"title\">cpp</span></span></span><br><span class=\"line\"><span class=\"class\">#<span class=\"title\">include</span>&lt;iostream&gt;</span></span><br><span class=\"line\"><span class=\"class\">#<span class=\"title\">define</span> _<span class=\"title\">sizeof</span>(<span class=\"title\">T</span>) ((<span class=\"title\">size_t</span>)((<span class=\"title\">T</span>*)0+1))</span></span><br><span class=\"line\"><span class=\"class\">#<span class=\"title\">include</span>&lt;stdio.h&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">using</span> <span class=\"title\">namespace</span> <span class=\"title\">std</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span> &#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> T&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Y</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> T&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> :</span><span class=\"keyword\">public</span> X,<span class=\"keyword\">public</span> Y&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TT</span>&#123;</span><span class=\"keyword\">public</span>:<span class=\"keyword\">int</span> q;<span class=\"keyword\">int</span> x;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\tT t1,t2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> xx;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (&amp;t1==&amp;t2)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"same\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>,&amp;t1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>,&amp;t2);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>,&amp;xx);</span><br><span class=\"line\">\t<span class=\"comment\">//\tint sie=(Y*)0+1;</span></span><br><span class=\"line\">\t<span class=\"comment\">//\tprintf(\"%x\\n\",X&#123;&#125;);</span></span><br><span class=\"line\">\t    <span class=\"keyword\">int</span> s= _sizeof(TT);　８　编译期间确定，直接把８赋给内存</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;_sizeof(T)&lt;&lt;<span class=\"built_in\">endl</span>;　１</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(TT)&lt;&lt;<span class=\"built_in\">endl</span>;　　８</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(T)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(X)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(Y)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(A)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自然t1,t2地址不同，相邻</p>\n<h4 id=\"那么一个类大的方面需要这些：\"><a href=\"#那么一个类大的方面需要这些：\" class=\"headerlink\" title=\"那么一个类大的方面需要这些：\"></a>那么一个类大的方面需要这些：</h4><p>１）类中定义的普通成员<br>２）语言本身所造成的额外负担如virtual机制，virtual table ,virtual base class subobject<br>３）Aligmnment带来的<br>（编译器的优化会带来内存布局的影响）</p>\n<p>上述例子：当编译器不做优化时，为１，8+1+3,8+1+3 ,1(X)+8+8+3(ali)</p>\n<h4 id=\"总结datamember的布局\"><a href=\"#总结datamember的布局\" class=\"headerlink\" title=\"总结datamember的布局\"></a>总结datamember的布局</h4><ul>\n<li>对象只存非静态的成员变量，而无论中间放置了几个静态变量都不会影响他们之间的排布。<br>　　　大部分的编译器将先定义的非静态成员变量放在低地址，而后的放在高地址。最好用时先用kdbg或测试程序等看下</li>\n<li>静态成员的存取不通过对象，他们放在数据段中</li>\n<li>vptr一般会放在哪里？　<br>　　对象的头或者尾巴</li>\n<li>align:C++标准要求，在同一个access section(private,public,protect等区段），member的排列只需要符和较晚出现放在较高的地址“即可，<br>　　access sections的多少并不会带来额外的负担</li>\n<li>我在g++上做了测试:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TT</span>&#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">sizeof</span>&#123;TT);   <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TT</span>&#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\"> protect:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">sizeof</span>(TT)=<span class=\"number\">16</span></span><br><span class=\"line\">class TT&#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\"> protect:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> e;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> f;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">sizeof</span>(TT)=<span class=\"number\">24</span> </span><br><span class=\"line\">class TT&#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> e;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> f;</span><br><span class=\"line\"> protect:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">sizeof</span>(TT)=<span class=\"number\">24</span></span><br><span class=\"line\">class TT&#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> e;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> f;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\"> protect:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">sizeof</span>(TT)=<span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<p>  由此看来这个编译器是按着c的struct对齐来的啊， </p>\n<h4 id=\"data-member的存取：\"><a href=\"#data-member的存取：\" class=\"headerlink\" title=\"data member的存取：\"></a>data member的存取：</h4><ul>\n<li><p>成本<br>比较：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        TT tt1;</span><br><span class=\"line\">\t\tTT *tt2=&amp;tt1;</span><br><span class=\"line\"><span class=\"number\">0x400b87</span> lea    <span class=\"number\">-0x20</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x400b8b</span> mov    %rax,<span class=\"number\">-0x48</span>(%rbp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> d=tt1.d;</span><br><span class=\"line\"><span class=\"number\">0x400b8f</span> mov    <span class=\"number\">-0x1c</span>(%rbp),%eax</span><br><span class=\"line\"><span class=\"number\">0x400b92</span> mov    %eax,<span class=\"number\">-0x68</span>(%rbp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> f=tt2-&gt;d;</span><br><span class=\"line\"><span class=\"number\">0x400b95</span> mov    <span class=\"number\">-0x48</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x400b99</span> mov    <span class=\"number\">0x4</span>(%rax),%eax</span><br><span class=\"line\"><span class=\"number\">0x400b9c</span> mov    %eax,<span class=\"number\">-0x64</span>(%rbp)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对static成员啊而言，实际是在数据段中，所以不管什么形式的访问都是相同的<br>待测试</p>\n</li>\n<li>通过成员函数<br>需要通过this 指针，则同上例子中的指针访问</li>\n</ul>\n<h3 id=\"总结几种情况下的的布局\"><a href=\"#总结几种情况下的的布局\" class=\"headerlink\" title=\"总结几种情况下的的布局\"></a>总结几种情况下的的布局</h3><h4 id=\"单一继承不含多态\"><a href=\"#单一继承不含多态\" class=\"headerlink\" title=\"单一继承不含多态\"></a>单一继承不含多态</h4><h5 id=\"一个典型的例子如下\"><a href=\"#一个典型的例子如下\" class=\"headerlink\" title=\"一个典型的例子如下\"></a>一个典型的例子如下</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point2d</span>&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point2d( <span class=\"keyword\">float</span> x=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> y=<span class=\"number\">0.0</span>):_x(x),_y(y)&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">x</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> _x;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">y</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> _y;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">x</span><span class=\"params\">(<span class=\"keyword\">float</span> newX)</span> </span>&#123; _x=newX;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">y</span><span class=\"params\">(<span class=\"keyword\">float</span> newY)</span> </span>&#123; _y=newY;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"keyword\">operator</span>+= (<span class=\"keyword\">const</span> Point2d&amp;  rhs) &#123;</span><br><span class=\"line\">        _x+=rhs.x();</span><br><span class=\"line\">        _y+=rhs.y();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ...more member;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _x,_y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"title\">Point3d</span>:</span> <span class=\"keyword\">public</span> Point2d&#123;</span><br><span class=\"line\">     <span class=\"keyword\">public</span>: </span><br><span class=\"line\">        Point3d(<span class=\"keyword\">float</span> x=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> y=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> z=<span class=\"number\">0.0</span>):Point2d(x,y),_z(z)&#123;&#125;;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">z</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> _z;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">z</span><span class=\"params\">(<span class=\"keyword\">float</span> newZ)</span></span>&#123;_z=newZ;&#125; </span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"keyword\">operator</span>+=(<span class=\"keyword\">const</span> Point3d&amp; rhs) &#123;</span><br><span class=\"line\">           Point2d::<span class=\"keyword\">operator</span>+=(rhs);</span><br><span class=\"line\">           _z+=rhs.z();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">          ...more member               </span><br><span class=\"line\">     <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _z;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"单一继承\"><a href=\"#单一继承\" class=\"headerlink\" title=\"单一继承\"></a>单一继承</h5><p>则　基类的成员被子类包含，放在较低的地址；相比之下，多了对齐的空间；<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Concrete</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">     <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">     <span class=\"keyword\">char</span> c1;</span><br><span class=\"line\">     <span class=\"keyword\">char</span> c2;</span><br><span class=\"line\">     <span class=\"keyword\">char</span> c3;</span><br><span class=\"line\">     &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>则需要占用８bytes;</p>\n<p>而当被继承实现时：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Concrete1</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">private</span>: </span><br><span class=\"line\">     <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">     <span class=\"keyword\">char</span> bit1;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Concrete2</span>：<span class=\"title\">public</span> <span class=\"title\">Concrete1</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">       <span class=\"keyword\">char</span> bit2;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"title\">Concrete3</span>:</span><span class=\"keyword\">public</span> Concrete2&#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> bit3;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>  由此带来成本 8+4+4=16</p>\n<ul>\n<li>那为什么要这么做的？继承的时候不能挤在一起吗？<br>（在深入c++对象模型中有图容易理解。这里仅说明：<br>　　　若：　Concrete2  *pc2;<pre><code>Concrete1 *pc1_1,*pc1_2;\n*pc1_2=*pc1_1; -默认复制构造\npc1_1 = pc2; //pc1_1指向pc2;\n*pc1_2=*pc1_1;//覆盖掉了，如果继承是成员挤在一起，而不是对齐来的\n</code></pre></li>\n</ul>\n<h5 id=\"单一继承含多态：\"><a href=\"#单一继承含多态：\" class=\"headerlink\" title=\"单一继承含多态：\"></a>单一继承含多态：</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point2d</span>&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point2d( <span class=\"keyword\">float</span> x=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> y=<span class=\"number\">0.0</span>):_x(x),_y(y)&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">x</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> _x;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">y</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> _y;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">z</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">0.0</span>;&#125; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">z</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">x</span><span class=\"params\">(<span class=\"keyword\">float</span> newX)</span> </span>&#123; _x=newX;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">y</span><span class=\"params\">(<span class=\"keyword\">float</span> newY)</span> </span>&#123; _y=newY;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"keyword\">operator</span>+= (<span class=\"keyword\">const</span> Point2d&amp;  rhs) &#123;</span><br><span class=\"line\">        _x+=rhs.x();</span><br><span class=\"line\">        _y+=rhs.y();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ...more member;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _x,_y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"title\">Point3d</span>:</span> <span class=\"keyword\">public</span> Point2d&#123;</span><br><span class=\"line\">     <span class=\"keyword\">public</span>: </span><br><span class=\"line\">        Point3d(<span class=\"keyword\">float</span> x=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> y=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> z=<span class=\"number\">0.0</span>):Point2d(x,y),_z(z)&#123;&#125;;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">z</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> _z;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">z</span><span class=\"params\">(<span class=\"keyword\">float</span> newZ)</span></span>&#123;_z=newZ;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"keyword\">operator</span>+=(<span class=\"keyword\">const</span> Point3d&amp; rhs) &#123;</span><br><span class=\"line\">           Point2d::<span class=\"keyword\">operator</span>+=(rhs);</span><br><span class=\"line\">           _z+=rhs.z();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">          ...more member     </span><br><span class=\"line\">     <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _z;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由此可以满足<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fool</span><span class=\"params\">(Point2d &amp;p1,Point2d &amp;p2)</span></span>&#123;</span><br><span class=\"line\">p1+=p2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以是Point2d和Point3d 这种弹性，牺牲了时间和空间<br>加入了什么呢？  </p>\n<pre><code>virtual table\nvptr\nadd constructor vptr setting\nadd destructor vptr virtual table dele\n</code></pre><p>所以需要视情况而定，如若只是涉及到2d&amp;3d之间，则可以是<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"keyword\">operator</span>+=(<span class=\"keyword\">const</span> Point２d&amp; rhs) &#123;</span><br><span class=\"line\">           Point2d::<span class=\"keyword\">operator</span>+=(rhs);</span><br><span class=\"line\">           _z+=rhs.z();<span class=\"comment\">//此时＋０</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"><span class=\"function\">Point2d <span class=\"title\">p2d</span><span class=\"params\">(...)</span></span></span><br><span class=\"line\"><span class=\"function\">Point3d <span class=\"title\">p3d</span><span class=\"params\">(,,,,)</span></span>;</span><br><span class=\"line\">p3d+=p2d</span><br></pre></td></tr></table></figure></p>\n<p>另外：对vptr的摆放位置，若放在最后面，则兼容c<br>但是损失了对继承的更好支持，所以现在放在最前面</p>\n<h5 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h5><p>多重继承考虑的问题较多？但从设计角度看，你可能会问？<br>对比单一继承，子类成员起始地址和基类相同，那多重继承，和哪个基类一样？其他基类怎么办，在向上转型如何处理，指针呢？</p>\n<p>另外，在单一继承中，vptr放在最开始的地方，如果base class没有virtual func而derived　class有呢？则此时单一继承的自然多态被打破，<br>若此时把一个derived class 转换为base class则　需要编译器介入，在多重继承+虚拟继承下就更有必要了</p>\n<p>考虑这个例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point2d</span>&#123;</span> 带<span class=\"keyword\">virtual</span> 接口</span><br><span class=\"line\">  <span class=\"keyword\">public</span>: </span><br><span class=\"line\">  <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _x _y;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span>:</span><span class=\"keyword\">public</span> Point2d&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">   protectd:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _z;</span><br><span class=\"line\">      &#125;'</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex</span> &#123;</span>带<span class=\"keyword\">virtual</span>接口</span><br><span class=\"line\">     <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">        Vertex *next;</span><br><span class=\"line\">   &#125;;    </span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex3d</span>:</span><span class=\"keyword\">public</span> Point3d,<span class=\"keyword\">public</span> Vertex &#123;</span><br><span class=\"line\">   protexted:</span><br><span class=\"line\">     <span class=\"keyword\">float</span> mumble;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure></p>\n<p>对多重继承派生对象，若将其地址　指定给最左端的base class则情况同单一继承一样，因为二者指向相同的地址。但是对第二个及以上时<br>需要将地址修改，加上或减去　介于中间的base class subobject<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  eg:  Vertex3d v3d;</span><br><span class=\"line\">        Vertex *pv;</span><br><span class=\"line\">        Point２d *p2d</span><br><span class=\"line\">        POint3d  *p3d;  </span><br><span class=\"line\">        pv=&amp;v3d</span><br><span class=\"line\">     则内部为：pv=(Vertex*)(((<span class=\"keyword\">char</span>*)&amp;v3d)+<span class=\"keyword\">sizeof</span>(Point3d));     </span><br><span class=\"line\">     而对p2d=&amp;v3d;</span><br><span class=\"line\">         p3d=&amp;v3d则只需要简单的拷贝</span><br><span class=\"line\">```              </span><br><span class=\"line\">      若为Vertex3d　*v3d;  pv=v3d;则内部还要进行判断空。因为*v3d可能为空，</span><br><span class=\"line\">      而引用不用，因为引用不可能参考到无</span><br><span class=\"line\">对存取其第二个基类成员，也是做类似的offset操作</span><br><span class=\"line\">##### 虚拟继承</span><br><span class=\"line\">在多重继承加虚拟继承时，如ios istream ostream</span><br><span class=\"line\">前面的内容会好理解一些，这部分的内容不好理解，也有些繁琐，于是，我回到之前学习的方法，即为什么，出现的原因，如果是自己实现又如何，等思考：</span><br><span class=\"line\">+ 为什么需要虚拟继承？  </span><br><span class=\"line\">虚拟继承出现，是因为当基类<span class=\"number\">2</span>和<span class=\"number\">3</span>都继承了基类<span class=\"number\">1</span>，而基类<span class=\"number\">4</span>继承了<span class=\"number\">2</span>和<span class=\"number\">3</span>，则基类<span class=\"number\">4</span>会同时拥有两份基类<span class=\"number\">1</span>，而虚拟继承就是为了让基类<span class=\"number\">4</span>只包含一份基类<span class=\"number\">1</span>，形成菱形继承结构</span><br><span class=\"line\">```cpp</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ios</span>&#123;</span>..&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">istream</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> ios&#123;..&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ostream</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> ios&#123;..&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">iostream</span>:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> istream, <span class=\"keyword\">public</span> ostream &#123;..&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么，虚拟继承是如何做，使得类4能只包含1份基类1，而不影响其他功能呢：</p>\n<ul>\n<li><p>梳理下：<br>上述例子：挑战在于，将istream 和ostream 各自维护的一个ios subobj ，折叠为一个由iostream维护的单一ios subobj ，<br>并且还可以保存base class 和derived class的指针（以及reference)之间的多态操作<br>一般的实现方式如下： class 如果内含一个或者多个virtual base class obj,像istream那样，将被分割为两部分，一个不变的局部和一个共享局部<br>不变的局部中的数据，不管后继如何演化，都总是拥有固定的offset(从obj头算起），这部分数据可以直接存取，共享局部，则是virtual base class subject，这部分数据位置会因为每次派生发生变化，所以他们只能被间接存取  </p>\n<p>所以就是：istream 中有自己的和ios相关的部分，这部分为共享部分</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point2d</span> _<span class=\"title\">x</span> _<span class=\"title\">y</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Point3d</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> Point2d  _z</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> Point2d</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex3d</span>:</span><span class=\"keyword\">public</span> Point3d <span class=\"keyword\">public</span> Vertex</span><br></pre></td></tr></table></figure>\n<p>那 istream 如何存取这部分共享的数据？和iostream共享？感觉有点像单例模式</p>\n</li>\n<li><p>cfront是这样实现的：（这语言没见过）： 会在每个derived class obj中安插一些指针，每个指针 指向一个virtual base class 存取继承得来的virtual base<br>class member;所以在存取时通过这个指针存取<br>在多层继承时间接存取次数多；每个对象需要为每个virtual base class 背负一个指针）</p>\n<pre><code> void Point3d::operator+=(const Point3d &amp;rhs) {\n  _x+=rhs._x;\n  _y+=rhs._y;\n  _z+=rhs._z;\n  }\n 则在这里：被转为：伪代码：_vbcPoint2d-&gt;_x+=rhs.__vbcPoint2d-&gt;_x;//vbc==virtual base class\n ....\n\n而Point2d *2d=3d;\nPoint2d *2d=3d? 3d-&gt;__vbcPoint2d:0;\n</code></pre></li>\n</ul>\n<ul>\n<li><p>microsoft ：引入类似于vbtable的方法，引入virtual base class table 。而在对象中放一个指针指向该表，表则放置那些指向virtual base class 指针<br>Bjarne: g++等（现在可能变了，但是类似）：</p>\n<pre><code>在虚函数表中放置virtual base class 的offset而不是地址。\n在这里，上面的例子：（this+__vbtr__point3d[-1])-&gt;_x+= (&amp;rhs+rhs.__vptr__point3d[-1])-&gt;_x;\n...\nPoint2d *2d=3d?3d+3d-&gt;__vptr__point3d[-1]:0\n</code></pre></li>\n<li><p>注意：若是基类1含有virtual func则会拥有一个vptr指向自己的vtable. 而虚拟继承它的基类2,3，基类2,3本身含有virtual func则不会通过继承基类1的方式<br>继承它的vptr,所以可以看到在书中的图中point3d有两个指针vptr,以下例子通过kdbg调试可以看到这个两个vptr</p>\n</li>\n</ul>\n<ul>\n<li>两个问题：</li>\n<li>基类1在继承连增加时位置如何变化？</li>\n<li>在基类自己有virtual func时为什么要自己独用一个vptr?<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point2d</span> &#123;</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span>: <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">printx</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> _x;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> _x,_y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> Point2d&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t\t\tVertex *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> Point2d&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> _z;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex3d</span>:</span><span class=\"keyword\">public</span> Vertex,<span class=\"keyword\">public</span> Point3d&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> mumble;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PO</span>&#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t    <span class=\"comment\">// virtual ~PO();</span></span><br><span class=\"line\">\t\t\t <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> origin;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">float</span> x,y,z;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> PO::origin =<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\tPoint2d d2d;</span><br><span class=\"line\">\t\tPoint3d d3d;</span><br><span class=\"line\">\t\tVertex vx;</span><br><span class=\"line\">\t\tVertex3d v3x;</span><br><span class=\"line\">\t\tPO po;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,&amp; PO::z);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,&amp;po);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,&amp;po.x);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,&amp;po.y);</span><br><span class=\"line\"><span class=\"comment\">//\t\tprintf(\"%d\\n\",&amp;po.origin);</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> PO::*p1=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> PO::*p2=&amp;PO::x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p1==p2)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"sma\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"使用gdb调试：\"><a href=\"#使用gdb调试：\" class=\"headerlink\" title=\"使用gdb调试：\"></a>使用gdb调试：</h5><p>写完程序后：<br>编译时加-g<br>gdb 科执行程序名</p>\n<ul>\n<li>设置断点：break 行号<br>s向下执行<br>set p obj &lt;on/off&gt;: 在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。 使用show print object查看对象选项的设置。<br>set p pertty &lt;on/off&gt;: 按照层次打印结构体。可以从设置前后看到这个区别。on的确更容易阅读。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> p obj on</span><br><span class=\"line\"><span class=\"built_in\">set</span> p pertty on</span><br><span class=\"line\">p 对象名</span><br><span class=\"line\">p /a ((<span class=\"keyword\">void</span> ***)d3d)[<span class=\"number\">0</span>]@<span class=\"number\">18</span> <span class=\"comment\">//看到更详细的内存 @18为打印的成员数，[0]指从第0个开始打印--感觉不太对</span></span><br><span class=\"line\">p /a ((<span class=\"keyword\">void</span> **)vx)[<span class=\"number\">0</span>]@<span class=\"number\">16</span><span class=\"comment\">//同上</span></span><br><span class=\"line\">(gdb) p b</span><br><span class=\"line\">$<span class=\"number\">1</span> = &#123;_vptr.Base = <span class=\"number\">0x400a60</span> &lt;vtable <span class=\"keyword\">for</span> Base+<span class=\"number\">16</span>&gt;&#125;</span><br><span class=\"line\">(gdb) x/<span class=\"number\">16</span>x <span class=\"number\">0x400a60</span></span><br><span class=\"line\"><span class=\"number\">0x400a60</span> &lt;_ZTV4Base+<span class=\"number\">16</span>&gt;:    <span class=\"number\">0x0040094c</span>  <span class=\"number\">0x00000000</span>  <span class=\"number\">0x72654437</span>  <span class=\"number\">0x64657669</span></span><br><span class=\"line\">(gdb) x/<span class=\"number\">16</span>x <span class=\"number\">0x0040094c</span></span><br><span class=\"line\"><span class=\"number\">0x40094c</span> &lt;Base::f()&gt;:   <span class=\"number\">0xe5894855</span>  <span class=\"number\">0x10ec8348</span>  <span class=\"number\">0xf87d8948</span>  <span class=\"number\">0x400a15be</span></span><br><span class=\"line\"><span class=\"number\">0x40095c</span> &lt;Base::f()+<span class=\"number\">16</span>&gt;:    <span class=\"number\">0x10c0bf00</span>  <span class=\"number\">0xf9e80060</span>  <span class=\"number\">0xc9fffffd</span>  <span class=\"number\">0x485590c3</span></span><br><span class=\"line\"><span class=\"number\">0x40096c</span> &lt;Derived::f()+<span class=\"number\">2</span>&gt;:  <span class=\"number\">0x8348e589</span>  <span class=\"number\">0x894810ec</span>  <span class=\"number\">0x1bbef87d</span>  <span class=\"number\">0xbf00400a</span></span><br><span class=\"line\"><span class=\"number\">0x40097c</span> &lt;Derived::f()+<span class=\"number\">18</span>&gt;: <span class=\"number\">0x006010c0</span>  <span class=\"number\">0xfffddbe8</span>  <span class=\"number\">0x66c3c9ff</span>  <span class=\"number\">0x00841f0f</span></span><br><span class=\"line\">  (gdb) <span class=\"built_in\">set</span> $i = <span class=\"number\">0</span></span><br><span class=\"line\">  (gdb) <span class=\"keyword\">while</span> $i &lt; <span class=\"number\">10</span></span><br><span class=\"line\">     &gt;print $i</span><br><span class=\"line\">     &gt;p /a (*(<span class=\"keyword\">void</span> ***)obj)[$i]</span><br><span class=\"line\">     &gt;<span class=\"built_in\">set</span> $i = $i + <span class=\"number\">1</span></span><br><span class=\"line\">     &gt;end</span><br><span class=\"line\">Where <span class=\"string\">\"obj\"</span> is the object whose vtable you'd like to print, <span class=\"keyword\">and</span> <span class=\"number\">10</span> is the number of methods.</span><br><span class=\"line\">p /a (*(<span class=\"keyword\">void</span> ***)obj)[<span class=\"number\">0</span>]@<span class=\"number\">10</span></span><br><span class=\"line\">info address _ZTV3Bar</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"对象成员的效率\"><a href=\"#对象成员的效率\" class=\"headerlink\" title=\"对象成员的效率\"></a>对象成员的效率</h4><h4 id=\"指向对象成员变量的指针\"><a href=\"#指向对象成员变量的指针\" class=\"headerlink\" title=\"指向对象成员变量的指针\"></a>指向对象成员变量的指针</h4><p>可以用于测试底层布局，如vptr放在哪，access section 次序。等<br>例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span> &#123;</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> :</span><br><span class=\"line\">        <span class=\"keyword\">virtual</span> ~Point3d();</span><br><span class=\"line\">     <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Point3d origin；</span><br><span class=\"line\">        <span class=\"keyword\">float</span> x,y,z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1)&amp;Point3d::z  –得到z在class obj中的偏移量<br>需用printf</p>\n<p>书中说的为了使得指向对象和对象成员的指针区分，而+1,在g++中没有怎么体现：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span>&#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//\t\t\tvirtual ~Point3d()&#123;;&#125;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">static</span> Point3d origin;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> x,y,z;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Point3d Point3d::origin;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        Point3d p3d;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Point3d=%p\\n\"</span>,&amp;p3d);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Point3d=%p\\n\"</span>,&amp;p3d.x);<span class=\"comment\">//这两个地址相同</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Point3d=%p\\n\"</span>,&amp;p3d.y);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Point3d::x=%p\\n\"</span>,&amp;Point3d::x);<span class=\"comment\">//nil,若Point3d带virtual func,则为8</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Point3d::y=%p\\n\"</span>,&amp;Point3d::y);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Point3d::z=%p\\n\"</span>,&amp;Point3d::z);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((<span class=\"keyword\">float</span>*)&amp;p3d==(<span class=\"keyword\">float</span>*)&amp;p3d.x)<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"yes\"</span>&lt;&lt;<span class=\"built_in\">endl</span>; <span class=\"comment\">//输出yes</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> Point3d::*p1=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> Point3d::*p2=&amp;Point3d::x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> Point3d::*p3=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p1==p2)<span class=\"comment\">//未输出</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p1==p2\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//no output in g++</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p2==p3)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p2==p3\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//no output in g++</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这里若是加了virtual func则，x为8，说明是vptr是放在前面的<br>通过指针取得对象成员:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> *p=origin.z  </span><br><span class=\"line\">struct  Base1&#123;<span class=\"keyword\">int</span> val1;&#125;</span><br><span class=\"line\"><span class=\"function\">struct <span class=\"title\">Base2</span> <span class=\"params\">(<span class=\"keyword\">int</span> val2;&#125;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">struct Derved:Base1,Base2&#123;..&#125;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"keyword\">void</span> func1(<span class=\"keyword\">int</span> Derved::*bmp,Derved *pd)</span><span class=\"comment\">//传入offset等，多继承时易出错</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   pd-&gt;*dmp;.....</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"c-class-datamemory\"><a href=\"#c-class-datamemory\" class=\"headerlink\" title=\"c++ class  datamemory\"></a>c++ class  datamemory</h3><p>详细介绍c++的成员布局，类本身的布局和在各种情况下的布局</p>\n<h4 id=\"“类”本身的大小：\"><a href=\"#“类”本身的大小：\" class=\"headerlink\" title=\"“类”本身的大小：\"></a>“类”本身的大小：</h4><ul>\n<li>the simplest 引入</li>\n<li>1.2 多少内存能表现一个class?<br>最小是１　  size","more":"</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&#123;</span> &#125;;   --<span class=\"number\">-1</span> 一个<span class=\"keyword\">char</span> 表示这个类型</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> :</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> T&#123;&#125;;　　--指针大小，指针指向T  <span class=\"keyword\">virtual</span> base <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">subobject</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Y</span> :</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> T&#123;&#125;;  --指针大小</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span><span class=\"keyword\">public</span> X,<span class=\"keyword\">public</span> Y &#123;&#125;;　--两个指针大小　```  </span><br><span class=\"line\">－－从深入那本书中说有两种方式，体现<span class=\"class\"><span class=\"keyword\">class</span>的大小，这里是优化的特殊的类型，这些好理解，但是需要类的空间的真正原因是什么？这<span class=\"title\">T</span>的一个<span class=\"title\">char</span>存储了什么？  </span></span><br><span class=\"line\"><span class=\"class\">用来干嘛？那在<span class=\"title\">X</span>中指向<span class=\"title\">T</span>的又是为什么需要？  </span></span><br><span class=\"line\"><span class=\"class\">最小１<span class=\"title\">char</span>?  </span></span><br><span class=\"line\"><span class=\"class\">我们知道，当一个类中仅包含一个<span class=\"title\">nonstatic</span> <span class=\"title\">member</span>时，如<span class=\"title\">int</span> ,则对象为<span class=\"title\">int</span>大小，但是当类为空时，对象如何去分配内存？</span></span><br><span class=\"line\"><span class=\"class\">如果同时定义了两个对象，那如何去区分这两个对象？让他们地址不相同？－－－所以这里需要一个<span class=\"title\">char</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">+ 注意，类本身也是一个类型，像<span class=\"title\">int</span>，<span class=\"title\">struct</span>一样，它的大小为４，<span class=\"title\">struct</span>成员和对齐，则类也一样，<span class=\"title\">sizeof</span>是在编译期间（确定<span class=\"title\">c89</span>中）  </span></span><br><span class=\"line\"><span class=\"class\">一个例子：</span></span><br><span class=\"line\"><span class=\"class\">```<span class=\"title\">cpp</span></span></span><br><span class=\"line\"><span class=\"class\">#<span class=\"title\">include</span>&lt;iostream&gt;</span></span><br><span class=\"line\"><span class=\"class\">#<span class=\"title\">define</span> _<span class=\"title\">sizeof</span>(<span class=\"title\">T</span>) ((<span class=\"title\">size_t</span>)((<span class=\"title\">T</span>*)0+1))</span></span><br><span class=\"line\"><span class=\"class\">#<span class=\"title\">include</span>&lt;stdio.h&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">using</span> <span class=\"title\">namespace</span> <span class=\"title\">std</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span> &#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> T&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Y</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> T&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> :</span><span class=\"keyword\">public</span> X,<span class=\"keyword\">public</span> Y&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TT</span>&#123;</span><span class=\"keyword\">public</span>:<span class=\"keyword\">int</span> q;<span class=\"keyword\">int</span> x;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\tT t1,t2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> xx;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (&amp;t1==&amp;t2)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"same\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>,&amp;t1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>,&amp;t2);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>,&amp;xx);</span><br><span class=\"line\">\t<span class=\"comment\">//\tint sie=(Y*)0+1;</span></span><br><span class=\"line\">\t<span class=\"comment\">//\tprintf(\"%x\\n\",X&#123;&#125;);</span></span><br><span class=\"line\">\t    <span class=\"keyword\">int</span> s= _sizeof(TT);　８　编译期间确定，直接把８赋给内存</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;_sizeof(T)&lt;&lt;<span class=\"built_in\">endl</span>;　１</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(TT)&lt;&lt;<span class=\"built_in\">endl</span>;　　８</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(T)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(X)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(Y)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(A)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自然t1,t2地址不同，相邻</p>\n<h4 id=\"那么一个类大的方面需要这些：\"><a href=\"#那么一个类大的方面需要这些：\" class=\"headerlink\" title=\"那么一个类大的方面需要这些：\"></a>那么一个类大的方面需要这些：</h4><p>１）类中定义的普通成员<br>２）语言本身所造成的额外负担如virtual机制，virtual table ,virtual base class subobject<br>３）Aligmnment带来的<br>（编译器的优化会带来内存布局的影响）</p>\n<p>上述例子：当编译器不做优化时，为１，8+1+3,8+1+3 ,1(X)+8+8+3(ali)</p>\n<h4 id=\"总结datamember的布局\"><a href=\"#总结datamember的布局\" class=\"headerlink\" title=\"总结datamember的布局\"></a>总结datamember的布局</h4><ul>\n<li>对象只存非静态的成员变量，而无论中间放置了几个静态变量都不会影响他们之间的排布。<br>　　　大部分的编译器将先定义的非静态成员变量放在低地址，而后的放在高地址。最好用时先用kdbg或测试程序等看下</li>\n<li>静态成员的存取不通过对象，他们放在数据段中</li>\n<li>vptr一般会放在哪里？　<br>　　对象的头或者尾巴</li>\n<li>align:C++标准要求，在同一个access section(private,public,protect等区段），member的排列只需要符和较晚出现放在较高的地址“即可，<br>　　access sections的多少并不会带来额外的负担</li>\n<li>我在g++上做了测试:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TT</span>&#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">sizeof</span>&#123;TT);   <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TT</span>&#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\"> protect:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">sizeof</span>(TT)=<span class=\"number\">16</span></span><br><span class=\"line\">class TT&#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\"> protect:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> e;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> f;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">sizeof</span>(TT)=<span class=\"number\">24</span> </span><br><span class=\"line\">class TT&#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> e;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> f;</span><br><span class=\"line\"> protect:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">sizeof</span>(TT)=<span class=\"number\">24</span></span><br><span class=\"line\">class TT&#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> e;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> f;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\"> protect:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">sizeof</span>(TT)=<span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<p>  由此看来这个编译器是按着c的struct对齐来的啊， </p>\n<h4 id=\"data-member的存取：\"><a href=\"#data-member的存取：\" class=\"headerlink\" title=\"data member的存取：\"></a>data member的存取：</h4><ul>\n<li><p>成本<br>比较：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        TT tt1;</span><br><span class=\"line\">\t\tTT *tt2=&amp;tt1;</span><br><span class=\"line\"><span class=\"number\">0x400b87</span> lea    <span class=\"number\">-0x20</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x400b8b</span> mov    %rax,<span class=\"number\">-0x48</span>(%rbp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> d=tt1.d;</span><br><span class=\"line\"><span class=\"number\">0x400b8f</span> mov    <span class=\"number\">-0x1c</span>(%rbp),%eax</span><br><span class=\"line\"><span class=\"number\">0x400b92</span> mov    %eax,<span class=\"number\">-0x68</span>(%rbp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> f=tt2-&gt;d;</span><br><span class=\"line\"><span class=\"number\">0x400b95</span> mov    <span class=\"number\">-0x48</span>(%rbp),%rax</span><br><span class=\"line\"><span class=\"number\">0x400b99</span> mov    <span class=\"number\">0x4</span>(%rax),%eax</span><br><span class=\"line\"><span class=\"number\">0x400b9c</span> mov    %eax,<span class=\"number\">-0x64</span>(%rbp)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对static成员啊而言，实际是在数据段中，所以不管什么形式的访问都是相同的<br>待测试</p>\n</li>\n<li>通过成员函数<br>需要通过this 指针，则同上例子中的指针访问</li>\n</ul>\n<h3 id=\"总结几种情况下的的布局\"><a href=\"#总结几种情况下的的布局\" class=\"headerlink\" title=\"总结几种情况下的的布局\"></a>总结几种情况下的的布局</h3><h4 id=\"单一继承不含多态\"><a href=\"#单一继承不含多态\" class=\"headerlink\" title=\"单一继承不含多态\"></a>单一继承不含多态</h4><h5 id=\"一个典型的例子如下\"><a href=\"#一个典型的例子如下\" class=\"headerlink\" title=\"一个典型的例子如下\"></a>一个典型的例子如下</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point2d</span>&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point2d( <span class=\"keyword\">float</span> x=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> y=<span class=\"number\">0.0</span>):_x(x),_y(y)&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">x</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> _x;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">y</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> _y;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">x</span><span class=\"params\">(<span class=\"keyword\">float</span> newX)</span> </span>&#123; _x=newX;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">y</span><span class=\"params\">(<span class=\"keyword\">float</span> newY)</span> </span>&#123; _y=newY;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"keyword\">operator</span>+= (<span class=\"keyword\">const</span> Point2d&amp;  rhs) &#123;</span><br><span class=\"line\">        _x+=rhs.x();</span><br><span class=\"line\">        _y+=rhs.y();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ...more member;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _x,_y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"title\">Point3d</span>:</span> <span class=\"keyword\">public</span> Point2d&#123;</span><br><span class=\"line\">     <span class=\"keyword\">public</span>: </span><br><span class=\"line\">        Point3d(<span class=\"keyword\">float</span> x=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> y=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> z=<span class=\"number\">0.0</span>):Point2d(x,y),_z(z)&#123;&#125;;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">z</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> _z;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">z</span><span class=\"params\">(<span class=\"keyword\">float</span> newZ)</span></span>&#123;_z=newZ;&#125; </span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"keyword\">operator</span>+=(<span class=\"keyword\">const</span> Point3d&amp; rhs) &#123;</span><br><span class=\"line\">           Point2d::<span class=\"keyword\">operator</span>+=(rhs);</span><br><span class=\"line\">           _z+=rhs.z();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">          ...more member               </span><br><span class=\"line\">     <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _z;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"单一继承\"><a href=\"#单一继承\" class=\"headerlink\" title=\"单一继承\"></a>单一继承</h5><p>则　基类的成员被子类包含，放在较低的地址；相比之下，多了对齐的空间；<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Concrete</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">     <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">     <span class=\"keyword\">char</span> c1;</span><br><span class=\"line\">     <span class=\"keyword\">char</span> c2;</span><br><span class=\"line\">     <span class=\"keyword\">char</span> c3;</span><br><span class=\"line\">     &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>则需要占用８bytes;</p>\n<p>而当被继承实现时：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Concrete1</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">private</span>: </span><br><span class=\"line\">     <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">     <span class=\"keyword\">char</span> bit1;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Concrete2</span>：<span class=\"title\">public</span> <span class=\"title\">Concrete1</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">       <span class=\"keyword\">char</span> bit2;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"title\">Concrete3</span>:</span><span class=\"keyword\">public</span> Concrete2&#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> bit3;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>  由此带来成本 8+4+4=16</p>\n<ul>\n<li>那为什么要这么做的？继承的时候不能挤在一起吗？<br>（在深入c++对象模型中有图容易理解。这里仅说明：<br>　　　若：　Concrete2  *pc2;<pre><code>Concrete1 *pc1_1,*pc1_2;\n*pc1_2=*pc1_1; -默认复制构造\npc1_1 = pc2; //pc1_1指向pc2;\n*pc1_2=*pc1_1;//覆盖掉了，如果继承是成员挤在一起，而不是对齐来的\n</code></pre></li>\n</ul>\n<h5 id=\"单一继承含多态：\"><a href=\"#单一继承含多态：\" class=\"headerlink\" title=\"单一继承含多态：\"></a>单一继承含多态：</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point2d</span>&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point2d( <span class=\"keyword\">float</span> x=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> y=<span class=\"number\">0.0</span>):_x(x),_y(y)&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">x</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> _x;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">y</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> _y;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">z</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">0.0</span>;&#125; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">z</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">x</span><span class=\"params\">(<span class=\"keyword\">float</span> newX)</span> </span>&#123; _x=newX;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">y</span><span class=\"params\">(<span class=\"keyword\">float</span> newY)</span> </span>&#123; _y=newY;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"keyword\">operator</span>+= (<span class=\"keyword\">const</span> Point2d&amp;  rhs) &#123;</span><br><span class=\"line\">        _x+=rhs.x();</span><br><span class=\"line\">        _y+=rhs.y();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ...more member;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _x,_y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"title\">Point3d</span>:</span> <span class=\"keyword\">public</span> Point2d&#123;</span><br><span class=\"line\">     <span class=\"keyword\">public</span>: </span><br><span class=\"line\">        Point3d(<span class=\"keyword\">float</span> x=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> y=<span class=\"number\">0.0</span>,<span class=\"keyword\">float</span> z=<span class=\"number\">0.0</span>):Point2d(x,y),_z(z)&#123;&#125;;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">z</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> _z;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">z</span><span class=\"params\">(<span class=\"keyword\">float</span> newZ)</span></span>&#123;_z=newZ;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"keyword\">operator</span>+=(<span class=\"keyword\">const</span> Point3d&amp; rhs) &#123;</span><br><span class=\"line\">           Point2d::<span class=\"keyword\">operator</span>+=(rhs);</span><br><span class=\"line\">           _z+=rhs.z();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">          ...more member     </span><br><span class=\"line\">     <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _z;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由此可以满足<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fool</span><span class=\"params\">(Point2d &amp;p1,Point2d &amp;p2)</span></span>&#123;</span><br><span class=\"line\">p1+=p2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以是Point2d和Point3d 这种弹性，牺牲了时间和空间<br>加入了什么呢？  </p>\n<pre><code>virtual table\nvptr\nadd constructor vptr setting\nadd destructor vptr virtual table dele\n</code></pre><p>所以需要视情况而定，如若只是涉及到2d&amp;3d之间，则可以是<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"keyword\">operator</span>+=(<span class=\"keyword\">const</span> Point２d&amp; rhs) &#123;</span><br><span class=\"line\">           Point2d::<span class=\"keyword\">operator</span>+=(rhs);</span><br><span class=\"line\">           _z+=rhs.z();<span class=\"comment\">//此时＋０</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"><span class=\"function\">Point2d <span class=\"title\">p2d</span><span class=\"params\">(...)</span></span></span><br><span class=\"line\"><span class=\"function\">Point3d <span class=\"title\">p3d</span><span class=\"params\">(,,,,)</span></span>;</span><br><span class=\"line\">p3d+=p2d</span><br></pre></td></tr></table></figure></p>\n<p>另外：对vptr的摆放位置，若放在最后面，则兼容c<br>但是损失了对继承的更好支持，所以现在放在最前面</p>\n<h5 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h5><p>多重继承考虑的问题较多？但从设计角度看，你可能会问？<br>对比单一继承，子类成员起始地址和基类相同，那多重继承，和哪个基类一样？其他基类怎么办，在向上转型如何处理，指针呢？</p>\n<p>另外，在单一继承中，vptr放在最开始的地方，如果base class没有virtual func而derived　class有呢？则此时单一继承的自然多态被打破，<br>若此时把一个derived class 转换为base class则　需要编译器介入，在多重继承+虚拟继承下就更有必要了</p>\n<p>考虑这个例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point2d</span>&#123;</span> 带<span class=\"keyword\">virtual</span> 接口</span><br><span class=\"line\">  <span class=\"keyword\">public</span>: </span><br><span class=\"line\">  <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _x _y;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span>:</span><span class=\"keyword\">public</span> Point2d&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">   protectd:</span><br><span class=\"line\">      <span class=\"keyword\">float</span> _z;</span><br><span class=\"line\">      &#125;'</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex</span> &#123;</span>带<span class=\"keyword\">virtual</span>接口</span><br><span class=\"line\">     <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">        Vertex *next;</span><br><span class=\"line\">   &#125;;    </span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex3d</span>:</span><span class=\"keyword\">public</span> Point3d,<span class=\"keyword\">public</span> Vertex &#123;</span><br><span class=\"line\">   protexted:</span><br><span class=\"line\">     <span class=\"keyword\">float</span> mumble;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure></p>\n<p>对多重继承派生对象，若将其地址　指定给最左端的base class则情况同单一继承一样，因为二者指向相同的地址。但是对第二个及以上时<br>需要将地址修改，加上或减去　介于中间的base class subobject<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  eg:  Vertex3d v3d;</span><br><span class=\"line\">        Vertex *pv;</span><br><span class=\"line\">        Point２d *p2d</span><br><span class=\"line\">        POint3d  *p3d;  </span><br><span class=\"line\">        pv=&amp;v3d</span><br><span class=\"line\">     则内部为：pv=(Vertex*)(((<span class=\"keyword\">char</span>*)&amp;v3d)+<span class=\"keyword\">sizeof</span>(Point3d));     </span><br><span class=\"line\">     而对p2d=&amp;v3d;</span><br><span class=\"line\">         p3d=&amp;v3d则只需要简单的拷贝</span><br><span class=\"line\">```              </span><br><span class=\"line\">      若为Vertex3d　*v3d;  pv=v3d;则内部还要进行判断空。因为*v3d可能为空，</span><br><span class=\"line\">      而引用不用，因为引用不可能参考到无</span><br><span class=\"line\">对存取其第二个基类成员，也是做类似的offset操作</span><br><span class=\"line\">##### 虚拟继承</span><br><span class=\"line\">在多重继承加虚拟继承时，如ios istream ostream</span><br><span class=\"line\">前面的内容会好理解一些，这部分的内容不好理解，也有些繁琐，于是，我回到之前学习的方法，即为什么，出现的原因，如果是自己实现又如何，等思考：</span><br><span class=\"line\">+ 为什么需要虚拟继承？  </span><br><span class=\"line\">虚拟继承出现，是因为当基类<span class=\"number\">2</span>和<span class=\"number\">3</span>都继承了基类<span class=\"number\">1</span>，而基类<span class=\"number\">4</span>继承了<span class=\"number\">2</span>和<span class=\"number\">3</span>，则基类<span class=\"number\">4</span>会同时拥有两份基类<span class=\"number\">1</span>，而虚拟继承就是为了让基类<span class=\"number\">4</span>只包含一份基类<span class=\"number\">1</span>，形成菱形继承结构</span><br><span class=\"line\">```cpp</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ios</span>&#123;</span>..&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">istream</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> ios&#123;..&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ostream</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> ios&#123;..&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">iostream</span>:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> istream, <span class=\"keyword\">public</span> ostream &#123;..&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么，虚拟继承是如何做，使得类4能只包含1份基类1，而不影响其他功能呢：</p>\n<ul>\n<li><p>梳理下：<br>上述例子：挑战在于，将istream 和ostream 各自维护的一个ios subobj ，折叠为一个由iostream维护的单一ios subobj ，<br>并且还可以保存base class 和derived class的指针（以及reference)之间的多态操作<br>一般的实现方式如下： class 如果内含一个或者多个virtual base class obj,像istream那样，将被分割为两部分，一个不变的局部和一个共享局部<br>不变的局部中的数据，不管后继如何演化，都总是拥有固定的offset(从obj头算起），这部分数据可以直接存取，共享局部，则是virtual base class subject，这部分数据位置会因为每次派生发生变化，所以他们只能被间接存取  </p>\n<p>所以就是：istream 中有自己的和ios相关的部分，这部分为共享部分</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point2d</span> _<span class=\"title\">x</span> _<span class=\"title\">y</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Point3d</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> Point2d  _z</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> Point2d</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex3d</span>:</span><span class=\"keyword\">public</span> Point3d <span class=\"keyword\">public</span> Vertex</span><br></pre></td></tr></table></figure>\n<p>那 istream 如何存取这部分共享的数据？和iostream共享？感觉有点像单例模式</p>\n</li>\n<li><p>cfront是这样实现的：（这语言没见过）： 会在每个derived class obj中安插一些指针，每个指针 指向一个virtual base class 存取继承得来的virtual base<br>class member;所以在存取时通过这个指针存取<br>在多层继承时间接存取次数多；每个对象需要为每个virtual base class 背负一个指针）</p>\n<pre><code> void Point3d::operator+=(const Point3d &amp;rhs) {\n  _x+=rhs._x;\n  _y+=rhs._y;\n  _z+=rhs._z;\n  }\n 则在这里：被转为：伪代码：_vbcPoint2d-&gt;_x+=rhs.__vbcPoint2d-&gt;_x;//vbc==virtual base class\n ....\n\n而Point2d *2d=3d;\nPoint2d *2d=3d? 3d-&gt;__vbcPoint2d:0;\n</code></pre></li>\n</ul>\n<ul>\n<li><p>microsoft ：引入类似于vbtable的方法，引入virtual base class table 。而在对象中放一个指针指向该表，表则放置那些指向virtual base class 指针<br>Bjarne: g++等（现在可能变了，但是类似）：</p>\n<pre><code>在虚函数表中放置virtual base class 的offset而不是地址。\n在这里，上面的例子：（this+__vbtr__point3d[-1])-&gt;_x+= (&amp;rhs+rhs.__vptr__point3d[-1])-&gt;_x;\n...\nPoint2d *2d=3d?3d+3d-&gt;__vptr__point3d[-1]:0\n</code></pre></li>\n<li><p>注意：若是基类1含有virtual func则会拥有一个vptr指向自己的vtable. 而虚拟继承它的基类2,3，基类2,3本身含有virtual func则不会通过继承基类1的方式<br>继承它的vptr,所以可以看到在书中的图中point3d有两个指针vptr,以下例子通过kdbg调试可以看到这个两个vptr</p>\n</li>\n</ul>\n<ul>\n<li>两个问题：</li>\n<li>基类1在继承连增加时位置如何变化？</li>\n<li>在基类自己有virtual func时为什么要自己独用一个vptr?<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point2d</span> &#123;</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span>: <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">printx</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> _x;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> _x,_y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> Point2d&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t\t\tVertex *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> Point2d&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> _z;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vertex3d</span>:</span><span class=\"keyword\">public</span> Vertex,<span class=\"keyword\">public</span> Point3d&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> mumble;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PO</span>&#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t    <span class=\"comment\">// virtual ~PO();</span></span><br><span class=\"line\">\t\t\t <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> origin;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">float</span> x,y,z;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> PO::origin =<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\tPoint2d d2d;</span><br><span class=\"line\">\t\tPoint3d d3d;</span><br><span class=\"line\">\t\tVertex vx;</span><br><span class=\"line\">\t\tVertex3d v3x;</span><br><span class=\"line\">\t\tPO po;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,&amp; PO::z);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,&amp;po);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,&amp;po.x);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,&amp;po.y);</span><br><span class=\"line\"><span class=\"comment\">//\t\tprintf(\"%d\\n\",&amp;po.origin);</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> PO::*p1=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> PO::*p2=&amp;PO::x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p1==p2)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"sma\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"使用gdb调试：\"><a href=\"#使用gdb调试：\" class=\"headerlink\" title=\"使用gdb调试：\"></a>使用gdb调试：</h5><p>写完程序后：<br>编译时加-g<br>gdb 科执行程序名</p>\n<ul>\n<li>设置断点：break 行号<br>s向下执行<br>set p obj &lt;on/off&gt;: 在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。 使用show print object查看对象选项的设置。<br>set p pertty &lt;on/off&gt;: 按照层次打印结构体。可以从设置前后看到这个区别。on的确更容易阅读。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> p obj on</span><br><span class=\"line\"><span class=\"built_in\">set</span> p pertty on</span><br><span class=\"line\">p 对象名</span><br><span class=\"line\">p /a ((<span class=\"keyword\">void</span> ***)d3d)[<span class=\"number\">0</span>]@<span class=\"number\">18</span> <span class=\"comment\">//看到更详细的内存 @18为打印的成员数，[0]指从第0个开始打印--感觉不太对</span></span><br><span class=\"line\">p /a ((<span class=\"keyword\">void</span> **)vx)[<span class=\"number\">0</span>]@<span class=\"number\">16</span><span class=\"comment\">//同上</span></span><br><span class=\"line\">(gdb) p b</span><br><span class=\"line\">$<span class=\"number\">1</span> = &#123;_vptr.Base = <span class=\"number\">0x400a60</span> &lt;vtable <span class=\"keyword\">for</span> Base+<span class=\"number\">16</span>&gt;&#125;</span><br><span class=\"line\">(gdb) x/<span class=\"number\">16</span>x <span class=\"number\">0x400a60</span></span><br><span class=\"line\"><span class=\"number\">0x400a60</span> &lt;_ZTV4Base+<span class=\"number\">16</span>&gt;:    <span class=\"number\">0x0040094c</span>  <span class=\"number\">0x00000000</span>  <span class=\"number\">0x72654437</span>  <span class=\"number\">0x64657669</span></span><br><span class=\"line\">(gdb) x/<span class=\"number\">16</span>x <span class=\"number\">0x0040094c</span></span><br><span class=\"line\"><span class=\"number\">0x40094c</span> &lt;Base::f()&gt;:   <span class=\"number\">0xe5894855</span>  <span class=\"number\">0x10ec8348</span>  <span class=\"number\">0xf87d8948</span>  <span class=\"number\">0x400a15be</span></span><br><span class=\"line\"><span class=\"number\">0x40095c</span> &lt;Base::f()+<span class=\"number\">16</span>&gt;:    <span class=\"number\">0x10c0bf00</span>  <span class=\"number\">0xf9e80060</span>  <span class=\"number\">0xc9fffffd</span>  <span class=\"number\">0x485590c3</span></span><br><span class=\"line\"><span class=\"number\">0x40096c</span> &lt;Derived::f()+<span class=\"number\">2</span>&gt;:  <span class=\"number\">0x8348e589</span>  <span class=\"number\">0x894810ec</span>  <span class=\"number\">0x1bbef87d</span>  <span class=\"number\">0xbf00400a</span></span><br><span class=\"line\"><span class=\"number\">0x40097c</span> &lt;Derived::f()+<span class=\"number\">18</span>&gt;: <span class=\"number\">0x006010c0</span>  <span class=\"number\">0xfffddbe8</span>  <span class=\"number\">0x66c3c9ff</span>  <span class=\"number\">0x00841f0f</span></span><br><span class=\"line\">  (gdb) <span class=\"built_in\">set</span> $i = <span class=\"number\">0</span></span><br><span class=\"line\">  (gdb) <span class=\"keyword\">while</span> $i &lt; <span class=\"number\">10</span></span><br><span class=\"line\">     &gt;print $i</span><br><span class=\"line\">     &gt;p /a (*(<span class=\"keyword\">void</span> ***)obj)[$i]</span><br><span class=\"line\">     &gt;<span class=\"built_in\">set</span> $i = $i + <span class=\"number\">1</span></span><br><span class=\"line\">     &gt;end</span><br><span class=\"line\">Where <span class=\"string\">\"obj\"</span> is the object whose vtable you'd like to print, <span class=\"keyword\">and</span> <span class=\"number\">10</span> is the number of methods.</span><br><span class=\"line\">p /a (*(<span class=\"keyword\">void</span> ***)obj)[<span class=\"number\">0</span>]@<span class=\"number\">10</span></span><br><span class=\"line\">info address _ZTV3Bar</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"对象成员的效率\"><a href=\"#对象成员的效率\" class=\"headerlink\" title=\"对象成员的效率\"></a>对象成员的效率</h4><h4 id=\"指向对象成员变量的指针\"><a href=\"#指向对象成员变量的指针\" class=\"headerlink\" title=\"指向对象成员变量的指针\"></a>指向对象成员变量的指针</h4><p>可以用于测试底层布局，如vptr放在哪，access section 次序。等<br>例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span> &#123;</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> :</span><br><span class=\"line\">        <span class=\"keyword\">virtual</span> ~Point3d();</span><br><span class=\"line\">     <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Point3d origin；</span><br><span class=\"line\">        <span class=\"keyword\">float</span> x,y,z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1)&amp;Point3d::z  –得到z在class obj中的偏移量<br>需用printf</p>\n<p>书中说的为了使得指向对象和对象成员的指针区分，而+1,在g++中没有怎么体现：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span>&#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">//\t\t\tvirtual ~Point3d()&#123;;&#125;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">static</span> Point3d origin;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> x,y,z;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Point3d Point3d::origin;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        Point3d p3d;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Point3d=%p\\n\"</span>,&amp;p3d);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Point3d=%p\\n\"</span>,&amp;p3d.x);<span class=\"comment\">//这两个地址相同</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Point3d=%p\\n\"</span>,&amp;p3d.y);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Point3d::x=%p\\n\"</span>,&amp;Point3d::x);<span class=\"comment\">//nil,若Point3d带virtual func,则为8</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Point3d::y=%p\\n\"</span>,&amp;Point3d::y);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Point3d::z=%p\\n\"</span>,&amp;Point3d::z);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((<span class=\"keyword\">float</span>*)&amp;p3d==(<span class=\"keyword\">float</span>*)&amp;p3d.x)<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"yes\"</span>&lt;&lt;<span class=\"built_in\">endl</span>; <span class=\"comment\">//输出yes</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> Point3d::*p1=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> Point3d::*p2=&amp;Point3d::x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> Point3d::*p3=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p1==p2)<span class=\"comment\">//未输出</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p1==p2\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//no output in g++</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p2==p3)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p2==p3\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//no output in g++</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这里若是加了virtual func则，x为8，说明是vptr是放在前面的<br>通过指针取得对象成员:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> *p=origin.z  </span><br><span class=\"line\">struct  Base1&#123;<span class=\"keyword\">int</span> val1;&#125;</span><br><span class=\"line\"><span class=\"function\">struct <span class=\"title\">Base2</span> <span class=\"params\">(<span class=\"keyword\">int</span> val2;&#125;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">struct Derved:Base1,Base2&#123;..&#125;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"keyword\">void</span> func1(<span class=\"keyword\">int</span> Derved::*bmp,Derved *pd)</span><span class=\"comment\">//传入offset等，多继承时易出错</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   pd-&gt;*dmp;.....</span><br></pre></td></tr></table></figure></p>"},{"title":"cpp_inheritance","date":"2018-06-09T03:44:54.000Z","_content":"### c++ 继承：\n#### 继承是什么能做什么\n继承是创建复杂类的另一种方式，它展现出来俩个obj 的is-a的概念（前一种方式是加入复杂的函数和成员等has-a　概念）\n继承体现的是两个对象（类）之间的联系，子类继承父类的成员和方法，然后特殊化于扩展自己的成员和方法，正如苹果和梨都是水果，它们拥有水果的一般特性，等边三角形是特殊的等腰三角形<!--more-->\n几个概念引英文词： the class being inherited from is called the parent class, base class, or superclass, and the class doing the inheriting is called the child class, derived class, or subclass.\n\n#### 继承怎么使用，分为什么\n继承的使用通过例子来学习，分为单继承和多继承等\n多继承的问题：  \n１）两个基类中存在相同的方法，子类调用该方法－－－》解决，可以调用的方法前加上类限定符base::  \n2)俩个类继承自同一个类，接着另一个类继承这两个类\n懒得自己写，从learncpp拷贝\n```cpp\n#include <iostream>\n#include <string>\n ```\n \n ```cpp\nclass Person\n{\npublic:\n    std::string m_name;\n    int m_age;\n \n    Person(std::string name = \"\", int age = 0)\n        : m_name(name), m_age(age)\n    {\n    }\n \n    std::string getName() const { return m_name; }\n    int getAge() const { return m_age; }\n \n};\n \n// BaseballPlayer publicly inheriting Person\nclass BaseballPlayer : public Person\n{\npublic:\n    double m_battingAverage;\n    int m_homeRuns;\n \n    BaseballPlayer(double battingAverage = 0.0, int homeRuns = 0)\n       : m_battingAverage(battingAverage), m_homeRuns(homeRuns)\n    {\n    }\n};\n \nint main()\n{\n    // Create a new BaseballPlayer object\n    BaseballPlayer joe;\n    // Assign it a name (we can do this directly because m_name is public)\n    joe.m_name = \"Joe\";\n    // Print out the name\n    std::cout << joe.getName() << '\\n'; // use the getName() function we've acquired from the Person base class\n \n    return 0;\n}```\n#### 继承的方式，访问控制\nA child class inherits both behaviors (member functions) and properties (member variables) from the parent 但是受继承方式的限制\n继承的方式有public等，受限制，这种可以通俗的理解为，你和你妈，你姨妈，你表舅等的亲密度和能访问的内容是有等级差别的\n\n|Access specifier in base class|when inherited publicly|when　inherited privately|when inherited protectedly|\n|:-|:-|:-|:-|\n|Public|Public|Private|Protected|\n|Private|Inaccessible|Inaccessible|Inaccessible|\n|Protected|Protected|Private|Protected|\n\n#### 继承的内存\n+ 对单纯的类对象来说，没有继承时，其对象内存是成员变量，存储在栈中\n，当继承了基类后，基类的成员变量（即使是private不能访问的）会添加到子类的对象内存中，而且一般是放在低地址（前面）\n对访问控制是在编译期间去做限制的\n\n#### 编译器对继承做了什么？\n+ 构造函数  \n+ 首先，构造函数顺序：Because Derived inherits functions and variables from Base, \nyou may assume that the members of Base are copied into Derived. \nHowever, this is not true. Instead, we can consider Derived as a two part class: \none part Derived, and one part Base.\n，从构造函数可以看出，继承的类，对象先调用继承连最上层的类构造函数，最后调用它自己的构造函数\n+ 其次，基类构造函数被子类调用：//弥补了子类不能　初始化父类成员的缺陷－－－为什么子类不能在初始化队列中初始化父类成员？若为const就出错了，初始化两次\n\n```cpp\nclass Derived: public Base\n{\nprivate: // our member is now private\n    double m_cost;\n \npublic:\n    Derived(double cost=0.0, int id=0)\n        : Base(id), // Call Base(int) constructor with value id!\n            m_cost(cost)\n    {\n    }\n    ```\n    \n+ 析构函数：调用顺序和构造函数相反\n+ 子类加入自己的函数和ovrridewirte父类函数  \n + 策略：\nWhen a member function is called with a derived class object, \nthe compiler first looks to see if that member exists in the derived class.\n If not, it begins walking up the inheritance chain and checking whether the member \n has been defined in any of the parent classes. It uses the first one it finds.\n \n + 在父类中被声明为private 的函数经过子类重写后可能会变成public:  \n \n ```cpp\n class Base\n{\nprivate:\n\tvoid print()\n\t{\n\t\tstd::cout << \"Base\";\n\t}\n};\nclass Derived : public Base\n{\npublic:\n\tvoid print()\n\t{\n\t\tstd::cout << \"Derived \";\n\t}\n};\nint main()\n{\n\tDerived derived;\n\tderived.print(); // calls derived::print(), which is public\n\treturn 0;\n}\n```\n\n+ 保留父类函数的方法:\n\n```cpp\nclass Base\n{\nprotected:\n    int m_value;\n \npublic:\n    Base(int value)\n        : m_value(value)\n    {\n    }\n \n    void identify() { std::cout << \"I am a Base\\n\"; }\n};\n\nclass Derived: public Base\n{\npublic:\n    Derived(int value)\n        : Base(value)\n    {\n    }\n \n    int GetValue() { return m_value; }\n \n    void identify()\n    {\n        Base::identify(); // call Base::identify() first\n        std::cout << \"I am a Derived\\n\"; // then identify ourselves\n    }\n};\n```\n+ c++11新：  \n将base类中的保护函数，在子类中声明为public:\n\n```cpp\nclass Base\n{\nprivate:\n    int m_value;\n \npublic:\n    Base(int value)\n        : m_value(value)\n    {\n    }\n \nprotected:\n    void printValue() { std::cout << m_value; }\n};\nclass Derived: public Base\n{\npublic:\n    Derived(int value)\n        : Base(value)\n    {\n    }\n    // Base::printValue was inherited as protected, so the public has no access\n    // But we're changing it to public via a using declaration\n    using Base::printValue; // note: no parenthesis here  //c++11\n};\n\nint main()\n{\n    Derived derived(7);\n \n    // printValue is public in Derived, so this is okay\n    derived.printValue(); // prints 7\n    return 0;\n}\n```\n\n子类中将父类的方法隐藏：\n```cpp\nclass Base\n{\nprivate:\n\tint m_value;\n \npublic:\n\tBase(int value)\n\t\t: m_value(value)\n\t{\n\t}\n \n\tint getValue() { return m_value; }\n};\n \nclass Derived : public Base\n{\npublic:\n\tDerived(int value)\n\t\t: Base(value)\n\t{\n\t}\n \n \n\tint getValue() = delete; // mark this function as inaccessible\n};\n \nint main()\n{\n\tDerived derived(7);\n \n\t// The following won't work because getValue() has been deleted!\n\tstd::cout << derived.getValue();\n \n\treturn 0;\n}\n```","source":"_posts/cpp-inheritance.md","raw":"---\ntitle: cpp_inheritance\ndate: 2018-06-09 11:44:54\ntags: cpp_class\ncategories: c&cpp\n---\n### c++ 继承：\n#### 继承是什么能做什么\n继承是创建复杂类的另一种方式，它展现出来俩个obj 的is-a的概念（前一种方式是加入复杂的函数和成员等has-a　概念）\n继承体现的是两个对象（类）之间的联系，子类继承父类的成员和方法，然后特殊化于扩展自己的成员和方法，正如苹果和梨都是水果，它们拥有水果的一般特性，等边三角形是特殊的等腰三角形<!--more-->\n几个概念引英文词： the class being inherited from is called the parent class, base class, or superclass, and the class doing the inheriting is called the child class, derived class, or subclass.\n\n#### 继承怎么使用，分为什么\n继承的使用通过例子来学习，分为单继承和多继承等\n多继承的问题：  \n１）两个基类中存在相同的方法，子类调用该方法－－－》解决，可以调用的方法前加上类限定符base::  \n2)俩个类继承自同一个类，接着另一个类继承这两个类\n懒得自己写，从learncpp拷贝\n```cpp\n#include <iostream>\n#include <string>\n ```\n \n ```cpp\nclass Person\n{\npublic:\n    std::string m_name;\n    int m_age;\n \n    Person(std::string name = \"\", int age = 0)\n        : m_name(name), m_age(age)\n    {\n    }\n \n    std::string getName() const { return m_name; }\n    int getAge() const { return m_age; }\n \n};\n \n// BaseballPlayer publicly inheriting Person\nclass BaseballPlayer : public Person\n{\npublic:\n    double m_battingAverage;\n    int m_homeRuns;\n \n    BaseballPlayer(double battingAverage = 0.0, int homeRuns = 0)\n       : m_battingAverage(battingAverage), m_homeRuns(homeRuns)\n    {\n    }\n};\n \nint main()\n{\n    // Create a new BaseballPlayer object\n    BaseballPlayer joe;\n    // Assign it a name (we can do this directly because m_name is public)\n    joe.m_name = \"Joe\";\n    // Print out the name\n    std::cout << joe.getName() << '\\n'; // use the getName() function we've acquired from the Person base class\n \n    return 0;\n}```\n#### 继承的方式，访问控制\nA child class inherits both behaviors (member functions) and properties (member variables) from the parent 但是受继承方式的限制\n继承的方式有public等，受限制，这种可以通俗的理解为，你和你妈，你姨妈，你表舅等的亲密度和能访问的内容是有等级差别的\n\n|Access specifier in base class|when inherited publicly|when　inherited privately|when inherited protectedly|\n|:-|:-|:-|:-|\n|Public|Public|Private|Protected|\n|Private|Inaccessible|Inaccessible|Inaccessible|\n|Protected|Protected|Private|Protected|\n\n#### 继承的内存\n+ 对单纯的类对象来说，没有继承时，其对象内存是成员变量，存储在栈中\n，当继承了基类后，基类的成员变量（即使是private不能访问的）会添加到子类的对象内存中，而且一般是放在低地址（前面）\n对访问控制是在编译期间去做限制的\n\n#### 编译器对继承做了什么？\n+ 构造函数  \n+ 首先，构造函数顺序：Because Derived inherits functions and variables from Base, \nyou may assume that the members of Base are copied into Derived. \nHowever, this is not true. Instead, we can consider Derived as a two part class: \none part Derived, and one part Base.\n，从构造函数可以看出，继承的类，对象先调用继承连最上层的类构造函数，最后调用它自己的构造函数\n+ 其次，基类构造函数被子类调用：//弥补了子类不能　初始化父类成员的缺陷－－－为什么子类不能在初始化队列中初始化父类成员？若为const就出错了，初始化两次\n\n```cpp\nclass Derived: public Base\n{\nprivate: // our member is now private\n    double m_cost;\n \npublic:\n    Derived(double cost=0.0, int id=0)\n        : Base(id), // Call Base(int) constructor with value id!\n            m_cost(cost)\n    {\n    }\n    ```\n    \n+ 析构函数：调用顺序和构造函数相反\n+ 子类加入自己的函数和ovrridewirte父类函数  \n + 策略：\nWhen a member function is called with a derived class object, \nthe compiler first looks to see if that member exists in the derived class.\n If not, it begins walking up the inheritance chain and checking whether the member \n has been defined in any of the parent classes. It uses the first one it finds.\n \n + 在父类中被声明为private 的函数经过子类重写后可能会变成public:  \n \n ```cpp\n class Base\n{\nprivate:\n\tvoid print()\n\t{\n\t\tstd::cout << \"Base\";\n\t}\n};\nclass Derived : public Base\n{\npublic:\n\tvoid print()\n\t{\n\t\tstd::cout << \"Derived \";\n\t}\n};\nint main()\n{\n\tDerived derived;\n\tderived.print(); // calls derived::print(), which is public\n\treturn 0;\n}\n```\n\n+ 保留父类函数的方法:\n\n```cpp\nclass Base\n{\nprotected:\n    int m_value;\n \npublic:\n    Base(int value)\n        : m_value(value)\n    {\n    }\n \n    void identify() { std::cout << \"I am a Base\\n\"; }\n};\n\nclass Derived: public Base\n{\npublic:\n    Derived(int value)\n        : Base(value)\n    {\n    }\n \n    int GetValue() { return m_value; }\n \n    void identify()\n    {\n        Base::identify(); // call Base::identify() first\n        std::cout << \"I am a Derived\\n\"; // then identify ourselves\n    }\n};\n```\n+ c++11新：  \n将base类中的保护函数，在子类中声明为public:\n\n```cpp\nclass Base\n{\nprivate:\n    int m_value;\n \npublic:\n    Base(int value)\n        : m_value(value)\n    {\n    }\n \nprotected:\n    void printValue() { std::cout << m_value; }\n};\nclass Derived: public Base\n{\npublic:\n    Derived(int value)\n        : Base(value)\n    {\n    }\n    // Base::printValue was inherited as protected, so the public has no access\n    // But we're changing it to public via a using declaration\n    using Base::printValue; // note: no parenthesis here  //c++11\n};\n\nint main()\n{\n    Derived derived(7);\n \n    // printValue is public in Derived, so this is okay\n    derived.printValue(); // prints 7\n    return 0;\n}\n```\n\n子类中将父类的方法隐藏：\n```cpp\nclass Base\n{\nprivate:\n\tint m_value;\n \npublic:\n\tBase(int value)\n\t\t: m_value(value)\n\t{\n\t}\n \n\tint getValue() { return m_value; }\n};\n \nclass Derived : public Base\n{\npublic:\n\tDerived(int value)\n\t\t: Base(value)\n\t{\n\t}\n \n \n\tint getValue() = delete; // mark this function as inaccessible\n};\n \nint main()\n{\n\tDerived derived(7);\n \n\t// The following won't work because getValue() has been deleted!\n\tstd::cout << derived.getValue();\n \n\treturn 0;\n}\n```","slug":"cpp-inheritance","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7nu00102ujxrgfgldw1","content":"<h3 id=\"c-继承：\"><a href=\"#c-继承：\" class=\"headerlink\" title=\"c++ 继承：\"></a>c++ 继承：</h3><h4 id=\"继承是什么能做什么\"><a href=\"#继承是什么能做什么\" class=\"headerlink\" title=\"继承是什么能做什么\"></a>继承是什么能做什么</h4><p>继承是创建复杂类的另一种方式，它展现出来俩个obj 的is-a的概念（前一种方式是加入复杂的函数和成员等has-a　概念）<br>继承体现的是两个对象（类）之间的联系，子类继承父类的成员和方法，然后特殊化于扩展自己的成员和方法，正如苹果和梨都是水果，它们拥有水果的一般特性，等边三角形是特殊的等腰三角形<a id=\"more\"></a><br>几个概念引英文词： the class being inherited from is called the parent class, base class, or superclass, and the class doing the inheriting is called the child class, derived class, or subclass.</p>\n<h4 id=\"继承怎么使用，分为什么\"><a href=\"#继承怎么使用，分为什么\" class=\"headerlink\" title=\"继承怎么使用，分为什么\"></a>继承怎么使用，分为什么</h4><p>继承的使用通过例子来学习，分为单继承和多继承等<br>多继承的问题：<br>１）两个基类中存在相同的方法，子类调用该方法－－－》解决，可以调用的方法前加上类限定符base::<br>2)俩个类继承自同一个类，接着另一个类继承这两个类<br>懒得自己写，从learncpp拷贝<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> m_name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_age;</span><br><span class=\"line\"> </span><br><span class=\"line\">    Person(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name = <span class=\"string\">\"\"</span>, <span class=\"keyword\">int</span> age = <span class=\"number\">0</span>)</span><br><span class=\"line\">        : m_name(name), m_age(age)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">getName</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> m_name; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> m_age; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// BaseballPlayer publicly inheriting Person</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseballPlayer</span> :</span> <span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">double</span> m_battingAverage;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_homeRuns;</span><br><span class=\"line\"> </span><br><span class=\"line\">    BaseballPlayer(<span class=\"keyword\">double</span> battingAverage = <span class=\"number\">0.0</span>, <span class=\"keyword\">int</span> homeRuns = <span class=\"number\">0</span>)</span><br><span class=\"line\">       : m_battingAverage(battingAverage), m_homeRuns(homeRuns)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a new BaseballPlayer object</span></span><br><span class=\"line\">    BaseballPlayer joe;</span><br><span class=\"line\">    <span class=\"comment\">// Assign it a name (we can do this directly because m_name is public)</span></span><br><span class=\"line\">    joe.m_name = <span class=\"string\">\"Joe\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Print out the name</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; joe.getName() &lt;&lt; <span class=\"string\">'\\n'</span>; <span class=\"comment\">// use the getName() function we've acquired from the Person base class</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"继承的方式，访问控制\"><a href=\"#继承的方式，访问控制\" class=\"headerlink\" title=\"继承的方式，访问控制\"></a>继承的方式，访问控制</h4><p>A child class inherits both behaviors (member functions) and properties (member variables) from the parent 但是受继承方式的限制<br>继承的方式有public等，受限制，这种可以通俗的理解为，你和你妈，你姨妈，你表舅等的亲密度和能访问的内容是有等级差别的</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Access specifier in base class</th>\n<th style=\"text-align:left\">when inherited publicly</th>\n<th style=\"text-align:left\">when　inherited privately</th>\n<th style=\"text-align:left\">when inherited protectedly</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Public</td>\n<td style=\"text-align:left\">Public</td>\n<td style=\"text-align:left\">Private</td>\n<td style=\"text-align:left\">Protected</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Private</td>\n<td style=\"text-align:left\">Inaccessible</td>\n<td style=\"text-align:left\">Inaccessible</td>\n<td style=\"text-align:left\">Inaccessible</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Protected</td>\n<td style=\"text-align:left\">Protected</td>\n<td style=\"text-align:left\">Private</td>\n<td style=\"text-align:left\">Protected</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"继承的内存\"><a href=\"#继承的内存\" class=\"headerlink\" title=\"继承的内存\"></a>继承的内存</h4><ul>\n<li>对单纯的类对象来说，没有继承时，其对象内存是成员变量，存储在栈中<br>，当继承了基类后，基类的成员变量（即使是private不能访问的）会添加到子类的对象内存中，而且一般是放在低地址（前面）<br>对访问控制是在编译期间去做限制的</li>\n</ul>\n<h4 id=\"编译器对继承做了什么？\"><a href=\"#编译器对继承做了什么？\" class=\"headerlink\" title=\"编译器对继承做了什么？\"></a>编译器对继承做了什么？</h4><ul>\n<li>构造函数  </li>\n<li>首先，构造函数顺序：Because Derived inherits functions and variables from Base,<br>you may assume that the members of Base are copied into Derived.<br>However, this is not true. Instead, we can consider Derived as a two part class:<br>one part Derived, and one part Base.<br>，从构造函数可以看出，继承的类，对象先调用继承连最上层的类构造函数，最后调用它自己的构造函数</li>\n<li>其次，基类构造函数被子类调用：//弥补了子类不能　初始化父类成员的缺陷－－－为什么子类不能在初始化队列中初始化父类成员？若为const就出错了，初始化两次</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>: <span class=\"comment\">// our member is now private</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> m_cost;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Derived(<span class=\"keyword\">double</span> cost=<span class=\"number\">0.0</span>, <span class=\"keyword\">int</span> id=<span class=\"number\">0</span>)</span><br><span class=\"line\">        : Base(id), <span class=\"comment\">// Call Base(int) constructor with value id!</span></span><br><span class=\"line\">            m_cost(cost)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数：调用顺序和构造函数相反</li>\n<li><p>子类加入自己的函数和ovrridewirte父类函数  </p>\n<ul>\n<li><p>策略：<br>When a member function is called with a derived class object,<br>the compiler first looks to see if that member exists in the derived class.<br>If not, it begins walking up the inheritance chain and checking whether the member<br>has been defined in any of the parent classes. It uses the first one it finds.</p>\n</li>\n<li><p>在父类中被声明为private 的函数经过子类重写后可能会变成public:  </p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Base\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span> :</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Derived \"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tDerived derived;</span><br><span class=\"line\">\tderived.print(); <span class=\"comment\">// calls derived::print(), which is public</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保留父类函数的方法:</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_value;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Base(<span class=\"keyword\">int</span> value)</span><br><span class=\"line\">        : m_value(value)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">identify</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"I am a Base\\n\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Derived(<span class=\"keyword\">int</span> value)</span><br><span class=\"line\">        : Base(value)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetValue</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_value; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">identify</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Base::identify(); <span class=\"comment\">// call Base::identify() first</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"I am a Derived\\n\"</span>; <span class=\"comment\">// then identify ourselves</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>c++11新：<br>将base类中的保护函数，在子类中声明为public:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_value;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Base(<span class=\"keyword\">int</span> value)</span><br><span class=\"line\">        : m_value(value)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printValue</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; m_value; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Derived(<span class=\"keyword\">int</span> value)</span><br><span class=\"line\">        : Base(value)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Base::printValue was inherited as protected, so the public has no access</span></span><br><span class=\"line\">    <span class=\"comment\">// But we're changing it to public via a using declaration</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::printValue; <span class=\"comment\">// note: no parenthesis here  //c++11</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">derived</span><span class=\"params\">(<span class=\"number\">7</span>)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// printValue is public in Derived, so this is okay</span></span><br><span class=\"line\">    derived.printValue(); <span class=\"comment\">// prints 7</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>子类中将父类的方法隐藏：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_value;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tBase(<span class=\"keyword\">int</span> value)</span><br><span class=\"line\">\t\t: m_value(value)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_value; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span> :</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDerived(<span class=\"keyword\">int</span> value)</span><br><span class=\"line\">\t\t: Base(value)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>= <span class=\"keyword\">delete</span>; <span class=\"comment\">// mark this function as inaccessible</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Derived <span class=\"title\">derived</span><span class=\"params\">(<span class=\"number\">7</span>)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// The following won't work because getValue() has been deleted!</span></span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; derived.getValue();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"c-继承：\"><a href=\"#c-继承：\" class=\"headerlink\" title=\"c++ 继承：\"></a>c++ 继承：</h3><h4 id=\"继承是什么能做什么\"><a href=\"#继承是什么能做什么\" class=\"headerlink\" title=\"继承是什么能做什么\"></a>继承是什么能做什么</h4><p>继承是创建复杂类的另一种方式，它展现出来俩个obj 的is-a的概念（前一种方式是加入复杂的函数和成员等has-a　概念）<br>继承体现的是两个对象（类）之间的联系，子类继承父类的成员和方法，然后特殊化于扩展自己的成员和方法，正如苹果和梨都是水果，它们拥有水果的一般特性，等边三角形是特殊的等腰三角形","more":"<br>几个概念引英文词： the class being inherited from is called the parent class, base class, or superclass, and the class doing the inheriting is called the child class, derived class, or subclass.</p>\n<h4 id=\"继承怎么使用，分为什么\"><a href=\"#继承怎么使用，分为什么\" class=\"headerlink\" title=\"继承怎么使用，分为什么\"></a>继承怎么使用，分为什么</h4><p>继承的使用通过例子来学习，分为单继承和多继承等<br>多继承的问题：<br>１）两个基类中存在相同的方法，子类调用该方法－－－》解决，可以调用的方法前加上类限定符base::<br>2)俩个类继承自同一个类，接着另一个类继承这两个类<br>懒得自己写，从learncpp拷贝<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> m_name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_age;</span><br><span class=\"line\"> </span><br><span class=\"line\">    Person(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name = <span class=\"string\">\"\"</span>, <span class=\"keyword\">int</span> age = <span class=\"number\">0</span>)</span><br><span class=\"line\">        : m_name(name), m_age(age)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">getName</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> m_name; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> m_age; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// BaseballPlayer publicly inheriting Person</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseballPlayer</span> :</span> <span class=\"keyword\">public</span> Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">double</span> m_battingAverage;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_homeRuns;</span><br><span class=\"line\"> </span><br><span class=\"line\">    BaseballPlayer(<span class=\"keyword\">double</span> battingAverage = <span class=\"number\">0.0</span>, <span class=\"keyword\">int</span> homeRuns = <span class=\"number\">0</span>)</span><br><span class=\"line\">       : m_battingAverage(battingAverage), m_homeRuns(homeRuns)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a new BaseballPlayer object</span></span><br><span class=\"line\">    BaseballPlayer joe;</span><br><span class=\"line\">    <span class=\"comment\">// Assign it a name (we can do this directly because m_name is public)</span></span><br><span class=\"line\">    joe.m_name = <span class=\"string\">\"Joe\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Print out the name</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; joe.getName() &lt;&lt; <span class=\"string\">'\\n'</span>; <span class=\"comment\">// use the getName() function we've acquired from the Person base class</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"继承的方式，访问控制\"><a href=\"#继承的方式，访问控制\" class=\"headerlink\" title=\"继承的方式，访问控制\"></a>继承的方式，访问控制</h4><p>A child class inherits both behaviors (member functions) and properties (member variables) from the parent 但是受继承方式的限制<br>继承的方式有public等，受限制，这种可以通俗的理解为，你和你妈，你姨妈，你表舅等的亲密度和能访问的内容是有等级差别的</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Access specifier in base class</th>\n<th style=\"text-align:left\">when inherited publicly</th>\n<th style=\"text-align:left\">when　inherited privately</th>\n<th style=\"text-align:left\">when inherited protectedly</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Public</td>\n<td style=\"text-align:left\">Public</td>\n<td style=\"text-align:left\">Private</td>\n<td style=\"text-align:left\">Protected</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Private</td>\n<td style=\"text-align:left\">Inaccessible</td>\n<td style=\"text-align:left\">Inaccessible</td>\n<td style=\"text-align:left\">Inaccessible</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Protected</td>\n<td style=\"text-align:left\">Protected</td>\n<td style=\"text-align:left\">Private</td>\n<td style=\"text-align:left\">Protected</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"继承的内存\"><a href=\"#继承的内存\" class=\"headerlink\" title=\"继承的内存\"></a>继承的内存</h4><ul>\n<li>对单纯的类对象来说，没有继承时，其对象内存是成员变量，存储在栈中<br>，当继承了基类后，基类的成员变量（即使是private不能访问的）会添加到子类的对象内存中，而且一般是放在低地址（前面）<br>对访问控制是在编译期间去做限制的</li>\n</ul>\n<h4 id=\"编译器对继承做了什么？\"><a href=\"#编译器对继承做了什么？\" class=\"headerlink\" title=\"编译器对继承做了什么？\"></a>编译器对继承做了什么？</h4><ul>\n<li>构造函数  </li>\n<li>首先，构造函数顺序：Because Derived inherits functions and variables from Base,<br>you may assume that the members of Base are copied into Derived.<br>However, this is not true. Instead, we can consider Derived as a two part class:<br>one part Derived, and one part Base.<br>，从构造函数可以看出，继承的类，对象先调用继承连最上层的类构造函数，最后调用它自己的构造函数</li>\n<li>其次，基类构造函数被子类调用：//弥补了子类不能　初始化父类成员的缺陷－－－为什么子类不能在初始化队列中初始化父类成员？若为const就出错了，初始化两次</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>: <span class=\"comment\">// our member is now private</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> m_cost;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Derived(<span class=\"keyword\">double</span> cost=<span class=\"number\">0.0</span>, <span class=\"keyword\">int</span> id=<span class=\"number\">0</span>)</span><br><span class=\"line\">        : Base(id), <span class=\"comment\">// Call Base(int) constructor with value id!</span></span><br><span class=\"line\">            m_cost(cost)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>析构函数：调用顺序和构造函数相反</li>\n<li><p>子类加入自己的函数和ovrridewirte父类函数  </p>\n<ul>\n<li><p>策略：<br>When a member function is called with a derived class object,<br>the compiler first looks to see if that member exists in the derived class.<br>If not, it begins walking up the inheritance chain and checking whether the member<br>has been defined in any of the parent classes. It uses the first one it finds.</p>\n</li>\n<li><p>在父类中被声明为private 的函数经过子类重写后可能会变成public:  </p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Base\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span> :</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Derived \"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tDerived derived;</span><br><span class=\"line\">\tderived.print(); <span class=\"comment\">// calls derived::print(), which is public</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保留父类函数的方法:</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_value;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Base(<span class=\"keyword\">int</span> value)</span><br><span class=\"line\">        : m_value(value)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">identify</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"I am a Base\\n\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Derived(<span class=\"keyword\">int</span> value)</span><br><span class=\"line\">        : Base(value)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetValue</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_value; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">identify</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Base::identify(); <span class=\"comment\">// call Base::identify() first</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"I am a Derived\\n\"</span>; <span class=\"comment\">// then identify ourselves</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>c++11新：<br>将base类中的保护函数，在子类中声明为public:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_value;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Base(<span class=\"keyword\">int</span> value)</span><br><span class=\"line\">        : m_value(value)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printValue</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; m_value; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Derived(<span class=\"keyword\">int</span> value)</span><br><span class=\"line\">        : Base(value)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Base::printValue was inherited as protected, so the public has no access</span></span><br><span class=\"line\">    <span class=\"comment\">// But we're changing it to public via a using declaration</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::printValue; <span class=\"comment\">// note: no parenthesis here  //c++11</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">derived</span><span class=\"params\">(<span class=\"number\">7</span>)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// printValue is public in Derived, so this is okay</span></span><br><span class=\"line\">    derived.printValue(); <span class=\"comment\">// prints 7</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>子类中将父类的方法隐藏：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_value;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tBase(<span class=\"keyword\">int</span> value)</span><br><span class=\"line\">\t\t: m_value(value)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_value; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span> :</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDerived(<span class=\"keyword\">int</span> value)</span><br><span class=\"line\">\t\t: Base(value)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>= <span class=\"keyword\">delete</span>; <span class=\"comment\">// mark this function as inaccessible</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Derived <span class=\"title\">derived</span><span class=\"params\">(<span class=\"number\">7</span>)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// The following won't work because getValue() has been deleted!</span></span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; derived.getValue();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"cpp_debug_layout_static","date":"2018-05-20T10:54:58.000Z","_content":"###  c compile time memory layout\n　　标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法：\n\n　　概述：首先介绍几个概念：<!-- more -->\n　　程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候；\n　　当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程； \n      注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码　。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句；\n   \n\n　　本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c\n\n \n\n前言：\n一个源代码通过编译后生成一个目标文件.o它是一个elf　relocatable文件,以下.o文件指此类，elf文件为executable文件\n.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到\n\n              other data  ...\n              .comment    offset 0x000000c6.\n              .rodata      ...　　　//const & str 常量\n              .data\n              .text\n              .elf header\n\n一个elf文件的结构是这样的：可以通过readelf来看：\n\t　　　　　　　　elfheader　　　　　　　　文件头包含了平台信息：/usr/include/elf.h\n\t        .text　　　　　　　　　　　　段表　各个段：应用程序也可以自己定义段，和指定变量在哪个段\n\t        .data\n\t        .bss\n\t        ..\n\t        other sections\n\t        section header table　　　　\n\t        string tables　　　　　　　　重定位表和字符串表\n\t        symbol tables　　　　　　　　 符号表是链接的接口\n 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂\n 可以通过readelf -s　xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突\n  强符号和弱符号（强引用和若引用），调试信息　－g\n 扩展：\n １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀；\n 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B  i386 image.jpg image.o\n   objdump -ht image.o\n   可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们\n   具体看文档\n２）自定义段：__attribute__((section(\"FOO\"))) int global=24;\n           __attribute__((section(\"BAR\"))) void  foo(){}  既可以把变量或函数放入该段中　段名：BAR FOO\n\n\n\n正文：\n\n#### 0、先从几个命令：\n1)size filename:查看elf或.o文件中各个段大小：\n  text\t   data\t    bss\t    dec\t    hex\tfilename\n     74\t      0\t      0\t     74\t     4a\tsimplest.o\n　　代码段　　　数据段　　\n代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址\n数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）\nbss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null\n\n2)其他工具：\n readelf -a simplest.o\n 可以看到更清楚的段信息\n objdump -t simplest\n objdump -h simplest.o   替代size可以看到更多信息\n \n此时显示出来的一些地址并不是装载后的地址\n\nobjdump -s -d xx.o:　　-s 16进制，-d反汇编　　－－－查看代码段\nobjdump -s -x -d xx.o:   --查看数据段和rodata\n\n3)查看目标文件文件属性如relocatable --.o/executable --elf/share object --.so..\n file xxx\n\n\n#### １、从最简单的程序开始：simplest.c\n\tint main()\n\t{\n\t   return 0;\n\t}\n\t\n将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件：\n\t# 1 \"simplest.c\"\n\t# 1 \"<built-in>\"\n\t# 1 \"<command-line>\"\n\t# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n\t# 1 \"<command-line>\" 2\n\t# 1 \"simplest.c\"\n\tint main()\n\t {\n\t  return 0;\n\t }\n\t \n将它进行汇编：gcc -S simplest.c\n\t\t.file\t\"simplest.c\"\n\t\t.text\n\t\t.globl\tmain\n\t\t.type\tmain, @function\n\tmain:\n\t.LFB0:\n\t\t.cfi_startproc\n\t\tpushq\t%rbp\n\t\t.cfi_def_cfa_offset 16\n\t\t.cfi_offset 6, -16\n\t\tmovq\t%rsp, %rbp\n\t\t.cfi_def_cfa_register 6\n\t\tmovl\t$0, %eax\n\t\tpopq\t%rbp\n\t\t.cfi_def_cfa 7, 8\n\t\tret\n\t\t.cfi_endproc\n\t.LFE0:\n\t\t.size\tmain, .-main\n\t\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n\t\t.section\t.note.GNU-stack,\"\",@progbits\n\t\n\n\n生成.o文件：gcc -c simplest.c\n并通过file xx.o查看类型\nsimplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped\n\n通过size 查看各个段：\nsize simplest.o:  可以看到只有代码段，数据为空，bss为空，是比较纯净的\n\ntext\t   data\t    bss\t    dec\t    hex\tfilename\n     67\t      0\t      0\t     67\t     43\tsimplest.o\n     \n接着编译成elf:gcc -o simplest simplest.c\nfile simplest\nsimplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, \ninterpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=\n56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped\n可以看到连接器等信息\n\nsize simplest\n  text\t   data\t    bss\t    dec\t    hex\tfilename\n   1099\t    544\t      8\t   1651\t    673\tsimplest\n注意这里的和.o的文件大小和分段不同，\n\n#### ２、加入头文件和局部变量\n\n\t#include<stdio.h>\n\tint main()\n\t{\n\t  int locala;\n\t  int localb=3;\n\t  return 0;\n\t  }\n进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数\n汇编，可以看到分配３到内存中\n\t\t.file\t\"simplest.c\"\n\t\t.text\n\t\t.globl\tmain\n\t\t.type\tmain, @function\n\tmain:\n\t.LFB0:\n\t\t.cfi_startproc\n\t\tpushq\t%rbp\n\t\t.cfi_def_cfa_offset 16\n\t\t.cfi_offset 6, -16\n\t\tmovq\t%rsp, %rbp\n\t\t.cfi_def_cfa_register 6\n\t\tmovl\t$3, -4(%rbp)\n\t\tmovl\t$0, %eax\n\t\tpopq\t%rbp\n\t\t.cfi_def_cfa 7, 8\n\t\tret\n\t\t.cfi_endproc\n\t.LFE0:\n\t\t.size\tmain, .-main\n\t\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n\t\t.section\t.note.GNU-stack,\"\",@progbits\n\n　　生成.o文件：可以看到未改变data和bss,但是代码段变大\n  text\t   data\t    bss\t    dec\t    hex\tfilename\n     74\t      0\t      0\t     74\t     4a\tsimplest.o\n\n\n生成elf:数据区和bss未改变，代码段也未改变？\n text\t   data\t    bss\t    dec\t    hex\tfilename\n   1099\t    544\t      8\t   1651\t    673\tsimplest\n\n\n\n#### ３、加入已经初始化的局部静态变量：\n\tint main()\n\t{\n\t static int statica=3;\n\t..\n\t}\n看生成的汇编：\n\t\t.file\t\"simplest.c\"\n\t\t.text\n\t\t.globl\tmain\n\t\t.type\tmain, @function\n\tmain:\n\t.LFB0:\n\t\t.cfi_startproc\n\t\tpushq\t%rbp\n\t\t.cfi_def_cfa_offset 16\n\t\t.cfi_offset 6, -16\n\t\tmovq\t%rsp, %rbp\n\t\t.cfi_def_cfa_register 6\n\t\tmovl\t$3, -4(%rbp)\n\t\tmovl\t$0, %eax\n\t\tpopq\t%rbp\n\t\t.cfi_def_cfa 7, 8\n\t\tret\n\t\t.cfi_endproc\n\t.LFE0:\n\t\t.size\tmain, .-main\n\t\t.data\n\t\t.align 4\n\t\t.type\tstatica.2285, @object　//新加的段\n\t\t.size\tstatica.2285, 4\n\tstatica.2285:\n\t\t.long\t3\n\t\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n\t\t.section\t.note.GNU-stack,\"\",@progbits\n\t\t\n\t\n.o大小：在静态数据区增加了，４　１个int的长度\n text\t   data\t    bss\t    dec\t    hex\tfilename\n     74\t      4\t      0\t     78\t     4e\tsimplest.o\n\nelf:有点费解，。。\n text\t   data\t    bss\t    dec\t    hex\tfilename\n   1099\t    548\t      4\t   1651\t    673\tsimplest\n\n\n\n#### ４、加入已经初始化的全局变量和全局静态变量\n\n\t     int golbala=6;\n\t    　static long gs=12;\n生成的汇编\n\t\t.file\t\"simplest.c\"\n\t\t.globl\tgolbala\n\t\t.data\n\t\t.align 4\n\t\t.type\tgolbala, @object\n\t\t.size\tgolbala, 4\n\tgolbala://变量名\n\t\t.long\t6\n\t\t.align 8\n\t\t.type\tgs, @object\n\t\t.size\tgs, 8\n\tgs://变量名\n\t\t.quad\t12\n\t\t.text\n\t\t.globl\tmain\n\t\t.type\tmain, @function\n\tmain:\n\t.LFB0:\n\t\t.cfi_startproc\n\t\tpushq\t%rbp\n\t\t.cfi_def_cfa_offset 16\n\t\t.cfi_offset 6, -16\n\t\tmovq\t%rsp, %rbp\n\t\t.cfi_def_cfa_register 6\n\t\tmovl\t$3, -4(%rbp)\n\t\tmovl\t$0, %eax\n\t\tpopq\t%rbp\n\t\t.cfi_def_cfa 7, 8\n\t\tret\n\t\t.cfi_endproc\n\t.LFE0:\n\t\t.size\tmain, .-main\n\t\t.data\n\t\t.align 4\n\t\t.type\tstatica.2287, @object\n\t\t.size\tstatica.2287, 4\n\tstatica.2287:\n\t\t.long\t3\n\t\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n\t\t.section\t.note.GNU-stack,\"\",@progbits\n\t\nsize : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4=20\n      text\t   data\t    bss\t    dec\t    hex\tfilename\n       74\t     20\t      0\t     94\t     5e\tsimplest.o\n\nelf size:548-->564  16\n  text\t   data\t    bss\t    dec\t    hex\tfilename\n   1099\t    564\t      4\t   1667\t    683\tsimplest\n\n\n####  5 将 　　int golbala=6;\n    　static long gs=12;　　倒换位置！！！！！！！！！\n 则对齐成：size x.o为：１６比原来小，可以用于节省内存：\n   text\t   data\t    bss\t    dec\t    hex\tfilename\n     74\t     16\t      0\t     90\t     5a\tsimplest.o\n　　汇编：\n\t.file\t\"simplest.c\"\n\t.data\n\t.align 8\n\t.type\tgs, @object\n\t.size\tgs, 8\ngs:\n\t.quad\t12\n\t.globl\tgolbala\n\t.align 4\n\t.type\tgolbala, @object\n\t.size\tgolbala, 4\ngolbala:\n\t.long\t6\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB0:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tmovl\t$3, -4(%rbp)\n\tmovl\t$0, %eax\n\tpopq\t%rbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE0:\n\t.size\tmain, .-main\n\t.data\n\t.align 4\n\t.type\tstatica.2287, @object\n\t.size\tstatica.2287, 4\nstatica.2287:\n\t.long\t3\n\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n\t.section\t.note.GNU-stack,\"\",@progbits\nelf文件的也变小：但bss变大，费解。。\n text\t   data\t    bss\t    dec\t    hex\tfilename\n   1099\t    560\t      8\t   1667\t    683\tsimplest\n\n#### 6、加入未初始化的全局变量和全局与局部静态变量\n\t  1 #include<stdio.h>\n\t    2 static long gs=12;\n\t    3 int golbala=6;\n\t    4      \n\t    5     \n\t    6 static long gsl;\n\t    7 int gi;\n\t    8 int main()\n\t    9 {   \n\t   10      static int staticn;\n\t11      static int statica=3;\n       12      int locala;\n       13      int localb=3;\n\t   14      return 0;\n\t   15 }\n汇编没有看到什么变化：                    \n\t.file\t\"simplest.c\"\n\t.data\n\t.align 8\n\t.type\tgs, @object\n\t.size\tgs, 8\ngs:\n\t.quad\t12\n\t.globl\tgolbala\n\t.align 4\n\t.type\tgolbala, @object\n\t.size\tgolbala, 4\ngolbala:\n\t.long\t6\n\t.local\tgsl\n\t.comm\tgsl,8,8\n\t.comm\tgi,4,4\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB0:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tmovl\t$3, -4(%rbp)\n\tmovl\t$0, %eax\n\tpopq\t%rbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE0:\n\t.size\tmain, .-main\n\t.data\n\t.align 4\n\t.type\tstatica.2290, @object\n\t.size\tstatica.2290, 4\nstatica.2290:\n\t.long\t3\n\t.local\tstaticn.2289\n\t.comm\tstaticn.2289,4,4\n\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n\n\n.o文件：+12 未包含未初始化的全局变量\ntext\t   data\t    bss\t    dec\t    hex\tfilename\n     74\t     16\t     12\t    102\t     66\tsimplest.o\n\n\nelf:+16 未包含未初始化的全局变量\ntext\t   data\t    bss\t    dec\t    hex\tfilename\n   1099\t    560\t     24\t   1683\t    693\tsimplest\n\n至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同\n\n\n参考：程序员的自我修养\n","source":"_posts/cpp-debug-layout-static.md","raw":"---\ntitle: cpp_debug_layout_static\ndate: 2018-05-20 18:54:58\ntags: cpp_memory\ncategories: c&cpp\n---\n###  c compile time memory layout\n　　标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法：\n\n　　概述：首先介绍几个概念：<!-- more -->\n　　程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候；\n　　当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程； \n      注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码　。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句；\n   \n\n　　本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c\n\n \n\n前言：\n一个源代码通过编译后生成一个目标文件.o它是一个elf　relocatable文件,以下.o文件指此类，elf文件为executable文件\n.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到\n\n              other data  ...\n              .comment    offset 0x000000c6.\n              .rodata      ...　　　//const & str 常量\n              .data\n              .text\n              .elf header\n\n一个elf文件的结构是这样的：可以通过readelf来看：\n\t　　　　　　　　elfheader　　　　　　　　文件头包含了平台信息：/usr/include/elf.h\n\t        .text　　　　　　　　　　　　段表　各个段：应用程序也可以自己定义段，和指定变量在哪个段\n\t        .data\n\t        .bss\n\t        ..\n\t        other sections\n\t        section header table　　　　\n\t        string tables　　　　　　　　重定位表和字符串表\n\t        symbol tables　　　　　　　　 符号表是链接的接口\n 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂\n 可以通过readelf -s　xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突\n  强符号和弱符号（强引用和若引用），调试信息　－g\n 扩展：\n １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀；\n 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B  i386 image.jpg image.o\n   objdump -ht image.o\n   可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们\n   具体看文档\n２）自定义段：__attribute__((section(\"FOO\"))) int global=24;\n           __attribute__((section(\"BAR\"))) void  foo(){}  既可以把变量或函数放入该段中　段名：BAR FOO\n\n\n\n正文：\n\n#### 0、先从几个命令：\n1)size filename:查看elf或.o文件中各个段大小：\n  text\t   data\t    bss\t    dec\t    hex\tfilename\n     74\t      0\t      0\t     74\t     4a\tsimplest.o\n　　代码段　　　数据段　　\n代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址\n数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）\nbss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null\n\n2)其他工具：\n readelf -a simplest.o\n 可以看到更清楚的段信息\n objdump -t simplest\n objdump -h simplest.o   替代size可以看到更多信息\n \n此时显示出来的一些地址并不是装载后的地址\n\nobjdump -s -d xx.o:　　-s 16进制，-d反汇编　　－－－查看代码段\nobjdump -s -x -d xx.o:   --查看数据段和rodata\n\n3)查看目标文件文件属性如relocatable --.o/executable --elf/share object --.so..\n file xxx\n\n\n#### １、从最简单的程序开始：simplest.c\n\tint main()\n\t{\n\t   return 0;\n\t}\n\t\n将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件：\n\t# 1 \"simplest.c\"\n\t# 1 \"<built-in>\"\n\t# 1 \"<command-line>\"\n\t# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n\t# 1 \"<command-line>\" 2\n\t# 1 \"simplest.c\"\n\tint main()\n\t {\n\t  return 0;\n\t }\n\t \n将它进行汇编：gcc -S simplest.c\n\t\t.file\t\"simplest.c\"\n\t\t.text\n\t\t.globl\tmain\n\t\t.type\tmain, @function\n\tmain:\n\t.LFB0:\n\t\t.cfi_startproc\n\t\tpushq\t%rbp\n\t\t.cfi_def_cfa_offset 16\n\t\t.cfi_offset 6, -16\n\t\tmovq\t%rsp, %rbp\n\t\t.cfi_def_cfa_register 6\n\t\tmovl\t$0, %eax\n\t\tpopq\t%rbp\n\t\t.cfi_def_cfa 7, 8\n\t\tret\n\t\t.cfi_endproc\n\t.LFE0:\n\t\t.size\tmain, .-main\n\t\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n\t\t.section\t.note.GNU-stack,\"\",@progbits\n\t\n\n\n生成.o文件：gcc -c simplest.c\n并通过file xx.o查看类型\nsimplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped\n\n通过size 查看各个段：\nsize simplest.o:  可以看到只有代码段，数据为空，bss为空，是比较纯净的\n\ntext\t   data\t    bss\t    dec\t    hex\tfilename\n     67\t      0\t      0\t     67\t     43\tsimplest.o\n     \n接着编译成elf:gcc -o simplest simplest.c\nfile simplest\nsimplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, \ninterpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=\n56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped\n可以看到连接器等信息\n\nsize simplest\n  text\t   data\t    bss\t    dec\t    hex\tfilename\n   1099\t    544\t      8\t   1651\t    673\tsimplest\n注意这里的和.o的文件大小和分段不同，\n\n#### ２、加入头文件和局部变量\n\n\t#include<stdio.h>\n\tint main()\n\t{\n\t  int locala;\n\t  int localb=3;\n\t  return 0;\n\t  }\n进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数\n汇编，可以看到分配３到内存中\n\t\t.file\t\"simplest.c\"\n\t\t.text\n\t\t.globl\tmain\n\t\t.type\tmain, @function\n\tmain:\n\t.LFB0:\n\t\t.cfi_startproc\n\t\tpushq\t%rbp\n\t\t.cfi_def_cfa_offset 16\n\t\t.cfi_offset 6, -16\n\t\tmovq\t%rsp, %rbp\n\t\t.cfi_def_cfa_register 6\n\t\tmovl\t$3, -4(%rbp)\n\t\tmovl\t$0, %eax\n\t\tpopq\t%rbp\n\t\t.cfi_def_cfa 7, 8\n\t\tret\n\t\t.cfi_endproc\n\t.LFE0:\n\t\t.size\tmain, .-main\n\t\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n\t\t.section\t.note.GNU-stack,\"\",@progbits\n\n　　生成.o文件：可以看到未改变data和bss,但是代码段变大\n  text\t   data\t    bss\t    dec\t    hex\tfilename\n     74\t      0\t      0\t     74\t     4a\tsimplest.o\n\n\n生成elf:数据区和bss未改变，代码段也未改变？\n text\t   data\t    bss\t    dec\t    hex\tfilename\n   1099\t    544\t      8\t   1651\t    673\tsimplest\n\n\n\n#### ３、加入已经初始化的局部静态变量：\n\tint main()\n\t{\n\t static int statica=3;\n\t..\n\t}\n看生成的汇编：\n\t\t.file\t\"simplest.c\"\n\t\t.text\n\t\t.globl\tmain\n\t\t.type\tmain, @function\n\tmain:\n\t.LFB0:\n\t\t.cfi_startproc\n\t\tpushq\t%rbp\n\t\t.cfi_def_cfa_offset 16\n\t\t.cfi_offset 6, -16\n\t\tmovq\t%rsp, %rbp\n\t\t.cfi_def_cfa_register 6\n\t\tmovl\t$3, -4(%rbp)\n\t\tmovl\t$0, %eax\n\t\tpopq\t%rbp\n\t\t.cfi_def_cfa 7, 8\n\t\tret\n\t\t.cfi_endproc\n\t.LFE0:\n\t\t.size\tmain, .-main\n\t\t.data\n\t\t.align 4\n\t\t.type\tstatica.2285, @object　//新加的段\n\t\t.size\tstatica.2285, 4\n\tstatica.2285:\n\t\t.long\t3\n\t\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n\t\t.section\t.note.GNU-stack,\"\",@progbits\n\t\t\n\t\n.o大小：在静态数据区增加了，４　１个int的长度\n text\t   data\t    bss\t    dec\t    hex\tfilename\n     74\t      4\t      0\t     78\t     4e\tsimplest.o\n\nelf:有点费解，。。\n text\t   data\t    bss\t    dec\t    hex\tfilename\n   1099\t    548\t      4\t   1651\t    673\tsimplest\n\n\n\n#### ４、加入已经初始化的全局变量和全局静态变量\n\n\t     int golbala=6;\n\t    　static long gs=12;\n生成的汇编\n\t\t.file\t\"simplest.c\"\n\t\t.globl\tgolbala\n\t\t.data\n\t\t.align 4\n\t\t.type\tgolbala, @object\n\t\t.size\tgolbala, 4\n\tgolbala://变量名\n\t\t.long\t6\n\t\t.align 8\n\t\t.type\tgs, @object\n\t\t.size\tgs, 8\n\tgs://变量名\n\t\t.quad\t12\n\t\t.text\n\t\t.globl\tmain\n\t\t.type\tmain, @function\n\tmain:\n\t.LFB0:\n\t\t.cfi_startproc\n\t\tpushq\t%rbp\n\t\t.cfi_def_cfa_offset 16\n\t\t.cfi_offset 6, -16\n\t\tmovq\t%rsp, %rbp\n\t\t.cfi_def_cfa_register 6\n\t\tmovl\t$3, -4(%rbp)\n\t\tmovl\t$0, %eax\n\t\tpopq\t%rbp\n\t\t.cfi_def_cfa 7, 8\n\t\tret\n\t\t.cfi_endproc\n\t.LFE0:\n\t\t.size\tmain, .-main\n\t\t.data\n\t\t.align 4\n\t\t.type\tstatica.2287, @object\n\t\t.size\tstatica.2287, 4\n\tstatica.2287:\n\t\t.long\t3\n\t\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n\t\t.section\t.note.GNU-stack,\"\",@progbits\n\t\nsize : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4=20\n      text\t   data\t    bss\t    dec\t    hex\tfilename\n       74\t     20\t      0\t     94\t     5e\tsimplest.o\n\nelf size:548-->564  16\n  text\t   data\t    bss\t    dec\t    hex\tfilename\n   1099\t    564\t      4\t   1667\t    683\tsimplest\n\n\n####  5 将 　　int golbala=6;\n    　static long gs=12;　　倒换位置！！！！！！！！！\n 则对齐成：size x.o为：１６比原来小，可以用于节省内存：\n   text\t   data\t    bss\t    dec\t    hex\tfilename\n     74\t     16\t      0\t     90\t     5a\tsimplest.o\n　　汇编：\n\t.file\t\"simplest.c\"\n\t.data\n\t.align 8\n\t.type\tgs, @object\n\t.size\tgs, 8\ngs:\n\t.quad\t12\n\t.globl\tgolbala\n\t.align 4\n\t.type\tgolbala, @object\n\t.size\tgolbala, 4\ngolbala:\n\t.long\t6\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB0:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tmovl\t$3, -4(%rbp)\n\tmovl\t$0, %eax\n\tpopq\t%rbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE0:\n\t.size\tmain, .-main\n\t.data\n\t.align 4\n\t.type\tstatica.2287, @object\n\t.size\tstatica.2287, 4\nstatica.2287:\n\t.long\t3\n\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n\t.section\t.note.GNU-stack,\"\",@progbits\nelf文件的也变小：但bss变大，费解。。\n text\t   data\t    bss\t    dec\t    hex\tfilename\n   1099\t    560\t      8\t   1667\t    683\tsimplest\n\n#### 6、加入未初始化的全局变量和全局与局部静态变量\n\t  1 #include<stdio.h>\n\t    2 static long gs=12;\n\t    3 int golbala=6;\n\t    4      \n\t    5     \n\t    6 static long gsl;\n\t    7 int gi;\n\t    8 int main()\n\t    9 {   \n\t   10      static int staticn;\n\t11      static int statica=3;\n       12      int locala;\n       13      int localb=3;\n\t   14      return 0;\n\t   15 }\n汇编没有看到什么变化：                    \n\t.file\t\"simplest.c\"\n\t.data\n\t.align 8\n\t.type\tgs, @object\n\t.size\tgs, 8\ngs:\n\t.quad\t12\n\t.globl\tgolbala\n\t.align 4\n\t.type\tgolbala, @object\n\t.size\tgolbala, 4\ngolbala:\n\t.long\t6\n\t.local\tgsl\n\t.comm\tgsl,8,8\n\t.comm\tgi,4,4\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB0:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tmovl\t$3, -4(%rbp)\n\tmovl\t$0, %eax\n\tpopq\t%rbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE0:\n\t.size\tmain, .-main\n\t.data\n\t.align 4\n\t.type\tstatica.2290, @object\n\t.size\tstatica.2290, 4\nstatica.2290:\n\t.long\t3\n\t.local\tstaticn.2289\n\t.comm\tstaticn.2289,4,4\n\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n\n\n.o文件：+12 未包含未初始化的全局变量\ntext\t   data\t    bss\t    dec\t    hex\tfilename\n     74\t     16\t     12\t    102\t     66\tsimplest.o\n\n\nelf:+16 未包含未初始化的全局变量\ntext\t   data\t    bss\t    dec\t    hex\tfilename\n   1099\t    560\t     24\t   1683\t    693\tsimplest\n\n至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同\n\n\n参考：程序员的自我修养\n","slug":"cpp-debug-layout-static","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7ny00142ujxpnj3jqu0","content":"<h3 id=\"c-compile-time-memory-layout\"><a href=\"#c-compile-time-memory-layout\" class=\"headerlink\" title=\"c compile time memory layout\"></a>c compile time memory layout</h3><p>　　标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法：</p>\n<p>　　概述：首先介绍几个概念：<a id=\"more\"></a><br>　　程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候；<br>　　当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程；<br>      注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码　。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句；</p>\n<p>　　本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c</p>\n<p>前言：<br>一个源代码通过编译后生成一个目标文件.o它是一个elf　relocatable文件,以下.o文件指此类，elf文件为executable文件<br>.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到</p>\n<pre><code>other data  ...\n.comment    offset 0x000000c6.\n.rodata      ...　　　//const &amp; str 常量\n.data\n.text\n.elf header\n</code></pre><p>一个elf文件的结构是这样的：可以通过readelf来看：<br>    　　　　　　　　elfheader　　　　　　　　文件头包含了平台信息：/usr/include/elf.h<br>            .text　　　　　　　　　　　　段表　各个段：应用程序也可以自己定义段，和指定变量在哪个段<br>            .data<br>            .bss<br>            ..<br>            other sections<br>            section header table　　　　<br>            string tables　　　　　　　　重定位表和字符串表<br>            symbol tables　　　　　　　　 符号表是链接的接口<br> 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂<br> 可以通过readelf -s　xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突<br>  强符号和弱符号（强引用和若引用），调试信息　－g<br> 扩展：<br> １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀；<br> 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B  i386 image.jpg image.o<br>   objdump -ht image.o<br>   可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们<br>   具体看文档<br>２）自定义段：<strong>attribute</strong>((section(“FOO”))) int global=24;<br>           <strong>attribute</strong>((section(“BAR”))) void  foo(){}  既可以把变量或函数放入该段中　段名：BAR FOO</p>\n<p>正文：</p>\n<h4 id=\"0、先从几个命令：\"><a href=\"#0、先从几个命令：\" class=\"headerlink\" title=\"0、先从几个命令：\"></a>0、先从几个命令：</h4><p>1)size filename:查看elf或.o文件中各个段大小：<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o<br>　　代码段　　　数据段　　<br>代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址<br>数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）<br>bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null</p>\n<p>2)其他工具：<br> readelf -a simplest.o<br> 可以看到更清楚的段信息<br> objdump -t simplest<br> objdump -h simplest.o   替代size可以看到更多信息</p>\n<p>此时显示出来的一些地址并不是装载后的地址</p>\n<p>objdump -s -d xx.o:　　-s 16进制，-d反汇编　　－－－查看代码段<br>objdump -s -x -d xx.o:   –查看数据段和rodata</p>\n<p>3)查看目标文件文件属性如relocatable –.o/executable –elf/share object –.so..<br> file xxx</p>\n<h4 id=\"１、从最简单的程序开始：simplest-c\"><a href=\"#１、从最简单的程序开始：simplest-c\" class=\"headerlink\" title=\"１、从最简单的程序开始：simplest.c\"></a>１、从最简单的程序开始：simplest.c</h4><pre><code>int main()\n{\n   return 0;\n}\n</code></pre><p>将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件：</p>\n<pre><code># 1 &quot;simplest.c&quot;\n# 1 &quot;&lt;built-in&gt;&quot;\n# 1 &quot;&lt;command-line&gt;&quot;\n# 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4\n# 1 &quot;&lt;command-line&gt;&quot; 2\n# 1 &quot;simplest.c&quot;\nint main()\n {\n  return 0;\n }\n</code></pre><p>将它进行汇编：gcc -S simplest.c<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>\n<p>生成.o文件：gcc -c simplest.c<br>并通过file xx.o查看类型<br>simplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</p>\n<p>通过size 查看各个段：<br>size simplest.o:  可以看到只有代码段，数据为空，bss为空，是比较纯净的</p>\n<p>text       data        bss        dec        hex    filename<br>     67          0          0         67         43    simplest.o</p>\n<p>接着编译成elf:gcc -o simplest simplest.c<br>file simplest<br>simplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,<br>interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=<br>56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped<br>可以看到连接器等信息</p>\n<p>size simplest<br>  text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest<br>注意这里的和.o的文件大小和分段不同，</p>\n<h4 id=\"２、加入头文件和局部变量\"><a href=\"#２、加入头文件和局部变量\" class=\"headerlink\" title=\"２、加入头文件和局部变量\"></a>２、加入头文件和局部变量</h4><pre><code>#include&lt;stdio.h&gt;\nint main()\n{\n  int locala;\n  int localb=3;\n  return 0;\n  }\n</code></pre><p>进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数<br>汇编，可以看到分配３到内存中<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>\n<p>　　生成.o文件：可以看到未改变data和bss,但是代码段变大<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o</p>\n<p>生成elf:数据区和bss未改变，代码段也未改变？<br> text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest</p>\n<h4 id=\"３、加入已经初始化的局部静态变量：\"><a href=\"#３、加入已经初始化的局部静态变量：\" class=\"headerlink\" title=\"３、加入已经初始化的局部静态变量：\"></a>３、加入已经初始化的局部静态变量：</h4><pre><code>int main()\n{\n static int statica=3;\n..\n}\n</code></pre><p>看生成的汇编：<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2285, @object　//新加的段<br>        .size    statica.2285, 4<br>    statica.2285:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>\n<p>.o大小：在静态数据区增加了，４　１个int的长度<br> text       data        bss        dec        hex    filename<br>     74          4          0         78         4e    simplest.o</p>\n<p>elf:有点费解，。。<br> text       data        bss        dec        hex    filename<br>   1099        548          4       1651        673    simplest</p>\n<h4 id=\"４、加入已经初始化的全局变量和全局静态变量\"><a href=\"#４、加入已经初始化的全局变量和全局静态变量\" class=\"headerlink\" title=\"４、加入已经初始化的全局变量和全局静态变量\"></a>４、加入已经初始化的全局变量和全局静态变量</h4><pre><code>int golbala=6;\n    　static long gs=12;\n</code></pre><p>生成的汇编<br>        .file    “simplest.c”<br>        .globl    golbala<br>        .data<br>        .align 4<br>        .type    golbala, @object<br>        .size    golbala, 4<br>    golbala://变量名<br>        .long    6<br>        .align 8<br>        .type    gs, @object<br>        .size    gs, 8<br>    gs://变量名<br>        .quad    12<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2287, @object<br>        .size    statica.2287, 4<br>    statica.2287:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>\n<p>size : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4=20<br>      text       data        bss        dec        hex    filename<br>       74         20          0         94         5e    simplest.o</p>\n<p>elf size:548–&gt;564  16<br>  text       data        bss        dec        hex    filename<br>   1099        564          4       1667        683    simplest</p>\n<h4 id=\"5-将-int-golbala-6\"><a href=\"#5-将-int-golbala-6\" class=\"headerlink\" title=\"5 将 　　int golbala=6;\"></a>5 将 　　int golbala=6;</h4><pre><code>　static long gs=12;　　倒换位置！！！！！！！！！\n</code></pre><p> 则对齐成：size x.o为：１６比原来小，可以用于节省内存：<br>   text       data        bss        dec        hex    filename<br>     74         16          0         90         5a    simplest.o<br>　　汇编：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2287, @object<br>    .size    statica.2287, 4<br>statica.2287:<br>    .long    3<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits<br>elf文件的也变小：但bss变大，费解。。<br> text       data        bss        dec        hex    filename<br>   1099        560          8       1667        683    simplest</p>\n<h4 id=\"6、加入未初始化的全局变量和全局与局部静态变量\"><a href=\"#6、加入未初始化的全局变量和全局与局部静态变量\" class=\"headerlink\" title=\"6、加入未初始化的全局变量和全局与局部静态变量\"></a>6、加入未初始化的全局变量和全局与局部静态变量</h4><pre><code>  1 #include&lt;stdio.h&gt;\n    2 static long gs=12;\n    3 int golbala=6;\n    4      \n    5     \n    6 static long gsl;\n    7 int gi;\n    8 int main()\n    9 {   \n   10      static int staticn;\n11      static int statica=3;\n   12      int locala;\n   13      int localb=3;\n   14      return 0;\n   15 }\n</code></pre><p>汇编没有看到什么变化：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .local    gsl<br>    .comm    gsl,8,8<br>    .comm    gi,4,4<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2290, @object<br>    .size    statica.2290, 4<br>statica.2290:<br>    .long    3<br>    .local    staticn.2289<br>    .comm    staticn.2289,4,4<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits</p>\n<p>.o文件：+12 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>     74         16         12        102         66    simplest.o</p>\n<p>elf:+16 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>   1099        560         24       1683        693    simplest</p>\n<p>至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同</p>\n<p>参考：程序员的自我修养</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"c-compile-time-memory-layout\"><a href=\"#c-compile-time-memory-layout\" class=\"headerlink\" title=\"c compile time memory layout\"></a>c compile time memory layout</h3><p>　　标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法：</p>\n<p>　　概述：首先介绍几个概念：","more":"<br>　　程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候；<br>　　当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程；<br>      注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码　。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句；</p>\n<p>　　本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c</p>\n<p>前言：<br>一个源代码通过编译后生成一个目标文件.o它是一个elf　relocatable文件,以下.o文件指此类，elf文件为executable文件<br>.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到</p>\n<pre><code>other data  ...\n.comment    offset 0x000000c6.\n.rodata      ...　　　//const &amp; str 常量\n.data\n.text\n.elf header\n</code></pre><p>一个elf文件的结构是这样的：可以通过readelf来看：<br>    　　　　　　　　elfheader　　　　　　　　文件头包含了平台信息：/usr/include/elf.h<br>            .text　　　　　　　　　　　　段表　各个段：应用程序也可以自己定义段，和指定变量在哪个段<br>            .data<br>            .bss<br>            ..<br>            other sections<br>            section header table　　　　<br>            string tables　　　　　　　　重定位表和字符串表<br>            symbol tables　　　　　　　　 符号表是链接的接口<br> 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂<br> 可以通过readelf -s　xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突<br>  强符号和弱符号（强引用和若引用），调试信息　－g<br> 扩展：<br> １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀；<br> 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B  i386 image.jpg image.o<br>   objdump -ht image.o<br>   可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们<br>   具体看文档<br>２）自定义段：<strong>attribute</strong>((section(“FOO”))) int global=24;<br>           <strong>attribute</strong>((section(“BAR”))) void  foo(){}  既可以把变量或函数放入该段中　段名：BAR FOO</p>\n<p>正文：</p>\n<h4 id=\"0、先从几个命令：\"><a href=\"#0、先从几个命令：\" class=\"headerlink\" title=\"0、先从几个命令：\"></a>0、先从几个命令：</h4><p>1)size filename:查看elf或.o文件中各个段大小：<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o<br>　　代码段　　　数据段　　<br>代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址<br>数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）<br>bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null</p>\n<p>2)其他工具：<br> readelf -a simplest.o<br> 可以看到更清楚的段信息<br> objdump -t simplest<br> objdump -h simplest.o   替代size可以看到更多信息</p>\n<p>此时显示出来的一些地址并不是装载后的地址</p>\n<p>objdump -s -d xx.o:　　-s 16进制，-d反汇编　　－－－查看代码段<br>objdump -s -x -d xx.o:   –查看数据段和rodata</p>\n<p>3)查看目标文件文件属性如relocatable –.o/executable –elf/share object –.so..<br> file xxx</p>\n<h4 id=\"１、从最简单的程序开始：simplest-c\"><a href=\"#１、从最简单的程序开始：simplest-c\" class=\"headerlink\" title=\"１、从最简单的程序开始：simplest.c\"></a>１、从最简单的程序开始：simplest.c</h4><pre><code>int main()\n{\n   return 0;\n}\n</code></pre><p>将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件：</p>\n<pre><code># 1 &quot;simplest.c&quot;\n# 1 &quot;&lt;built-in&gt;&quot;\n# 1 &quot;&lt;command-line&gt;&quot;\n# 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4\n# 1 &quot;&lt;command-line&gt;&quot; 2\n# 1 &quot;simplest.c&quot;\nint main()\n {\n  return 0;\n }\n</code></pre><p>将它进行汇编：gcc -S simplest.c<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>\n<p>生成.o文件：gcc -c simplest.c<br>并通过file xx.o查看类型<br>simplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</p>\n<p>通过size 查看各个段：<br>size simplest.o:  可以看到只有代码段，数据为空，bss为空，是比较纯净的</p>\n<p>text       data        bss        dec        hex    filename<br>     67          0          0         67         43    simplest.o</p>\n<p>接着编译成elf:gcc -o simplest simplest.c<br>file simplest<br>simplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,<br>interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=<br>56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped<br>可以看到连接器等信息</p>\n<p>size simplest<br>  text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest<br>注意这里的和.o的文件大小和分段不同，</p>\n<h4 id=\"２、加入头文件和局部变量\"><a href=\"#２、加入头文件和局部变量\" class=\"headerlink\" title=\"２、加入头文件和局部变量\"></a>２、加入头文件和局部变量</h4><pre><code>#include&lt;stdio.h&gt;\nint main()\n{\n  int locala;\n  int localb=3;\n  return 0;\n  }\n</code></pre><p>进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数<br>汇编，可以看到分配３到内存中<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>\n<p>　　生成.o文件：可以看到未改变data和bss,但是代码段变大<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o</p>\n<p>生成elf:数据区和bss未改变，代码段也未改变？<br> text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest</p>\n<h4 id=\"３、加入已经初始化的局部静态变量：\"><a href=\"#３、加入已经初始化的局部静态变量：\" class=\"headerlink\" title=\"３、加入已经初始化的局部静态变量：\"></a>３、加入已经初始化的局部静态变量：</h4><pre><code>int main()\n{\n static int statica=3;\n..\n}\n</code></pre><p>看生成的汇编：<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2285, @object　//新加的段<br>        .size    statica.2285, 4<br>    statica.2285:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>\n<p>.o大小：在静态数据区增加了，４　１个int的长度<br> text       data        bss        dec        hex    filename<br>     74          4          0         78         4e    simplest.o</p>\n<p>elf:有点费解，。。<br> text       data        bss        dec        hex    filename<br>   1099        548          4       1651        673    simplest</p>\n<h4 id=\"４、加入已经初始化的全局变量和全局静态变量\"><a href=\"#４、加入已经初始化的全局变量和全局静态变量\" class=\"headerlink\" title=\"４、加入已经初始化的全局变量和全局静态变量\"></a>４、加入已经初始化的全局变量和全局静态变量</h4><pre><code>int golbala=6;\n    　static long gs=12;\n</code></pre><p>生成的汇编<br>        .file    “simplest.c”<br>        .globl    golbala<br>        .data<br>        .align 4<br>        .type    golbala, @object<br>        .size    golbala, 4<br>    golbala://变量名<br>        .long    6<br>        .align 8<br>        .type    gs, @object<br>        .size    gs, 8<br>    gs://变量名<br>        .quad    12<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2287, @object<br>        .size    statica.2287, 4<br>    statica.2287:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>\n<p>size : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4=20<br>      text       data        bss        dec        hex    filename<br>       74         20          0         94         5e    simplest.o</p>\n<p>elf size:548–&gt;564  16<br>  text       data        bss        dec        hex    filename<br>   1099        564          4       1667        683    simplest</p>\n<h4 id=\"5-将-int-golbala-6\"><a href=\"#5-将-int-golbala-6\" class=\"headerlink\" title=\"5 将 　　int golbala=6;\"></a>5 将 　　int golbala=6;</h4><pre><code>　static long gs=12;　　倒换位置！！！！！！！！！\n</code></pre><p> 则对齐成：size x.o为：１６比原来小，可以用于节省内存：<br>   text       data        bss        dec        hex    filename<br>     74         16          0         90         5a    simplest.o<br>　　汇编：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2287, @object<br>    .size    statica.2287, 4<br>statica.2287:<br>    .long    3<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits<br>elf文件的也变小：但bss变大，费解。。<br> text       data        bss        dec        hex    filename<br>   1099        560          8       1667        683    simplest</p>\n<h4 id=\"6、加入未初始化的全局变量和全局与局部静态变量\"><a href=\"#6、加入未初始化的全局变量和全局与局部静态变量\" class=\"headerlink\" title=\"6、加入未初始化的全局变量和全局与局部静态变量\"></a>6、加入未初始化的全局变量和全局与局部静态变量</h4><pre><code>  1 #include&lt;stdio.h&gt;\n    2 static long gs=12;\n    3 int golbala=6;\n    4      \n    5     \n    6 static long gsl;\n    7 int gi;\n    8 int main()\n    9 {   \n   10      static int staticn;\n11      static int statica=3;\n   12      int locala;\n   13      int localb=3;\n   14      return 0;\n   15 }\n</code></pre><p>汇编没有看到什么变化：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .local    gsl<br>    .comm    gsl,8,8<br>    .comm    gi,4,4<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2290, @object<br>    .size    statica.2290, 4<br>statica.2290:<br>    .long    3<br>    .local    staticn.2289<br>    .comm    staticn.2289,4,4<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits</p>\n<p>.o文件：+12 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>     74         16         12        102         66    simplest.o</p>\n<p>elf:+16 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>   1099        560         24       1683        693    simplest</p>\n<p>至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同</p>\n<p>参考：程序员的自我修养</p>"},{"title":"cpp_conandde","date":"2018-06-09T03:03:35.000Z","_content":"## c++ class constructor and destructor\n### 构造函数\n#### 构造函数表现\n##### 构造函数的作用：\n构造函数主要是用来初始化对象的－－－一般是成员，函数不用\n--所以它需要在构建对象时就执行<!--more-->\n##### 构造函数如何写：\n```cpp\npublic:　classname(arg...):member(arg),mem2(arg),..{xxx}\n    classname(..){..}\n```        \n##### 默认构造函数的生成规则（深入对象模型）\n+ 下面四个情况下会生成默认构造函数（编译器控制）(nontrivial default constructor)  \n + 带有default constructor的member class object  \n 即在类中带有对象成员，该对象成员所属的类有构造函数\n如：　\n```cpp\nclass Foo {public :Foo(),Foo(int)...}\nclass Bar{public:Foo foo;char *str};\n                          void funv()\n                          {   Bar bar;....\n                          }```\n这种情况下若程序员没有实现构造函数，则编译器会自己生成构造函数，来调用Foo的构造函数\n但是不初始化str,这个得由程序员来做。\n如类似于：\n```cpp\nBar::Bar(){\n   foo.Foo::Foo();\n ```                  \n 若程序员自己写了构造函数但是不包括初始化foo则，编译器会在程序眼写的构造函数中加入上述，另外若有多个对象\n则按照声明顺序进行调用他们的构造函数；\n + 带有Default constructor 的base class  \n 同理，当继承的基类带有构造函数时就会加入，若程序员的构造函数没有初始化他们时就会扩展  \n//以上见例子class_constructor.cpp，\n + 和vcirtual相关need to create vptr  \n    带有一个virtual　func的class  \n     1)class　声明或继承一个virtua func  \n     2)class派生自一个继承琏，其中有virtual base classes       这个比较容易理解\n                \n + 和virtual相关 need to init vptr\n   带有一个virtual　base class 的class  \n   如：\n   ```cpp\n       class X{  public int i;}  \n       class A :public virtual X {///\n       class B :public virtual X {\n       class C: public A,public B ```\n       \n\n##### 构造函数何时被执行  \n-在对象定义时若有构造函数，则会执行\n##### 实践：\n1:5构造函数的使用：重载，初始化式\n\n#### 构造函数表现的原理\n##### 构造函数在静态代码块中的位置和符号体现\n如果有定义构造函数，它本身也是一个函数，放在代码段中，可以通过kdbg查看\n```c\norigin(int ax=3,int bx=4):a(ax),b(bx){}\n0x400bae push   %rbp\n0x400baf mov    %rsp,%rbp\n0x400bb2 mov    %rdi,-0x8(%rbp)\n0x400bb6 mov    %esi,-0xc(%rbp)\n0x400bb9 mov    %edx,-0x10(%rbp)```\n##### 构造函数在动态执行时，放在哪个内存段中，如何被引用，使用\n+ 动态执行时，在代码段中，通过this引用\n+ 构造函数总结：任何c++ class只有在以上四中情况下才会产生默认构造函数，且产生的默认构造函数不会去初始化成员的值\n### 拷贝构造函数\n#### 拷贝的动作发生了什么\n拷贝的本质，为什么需要拷贝构造函数？\n+ 首先对基本的类型而言，拷贝是把值赋给另一个同类型的变量，而数租不能做=赋值拷贝\n+ 对对象而言，也是把值赋给同类型的对象，而不是共享一个指针，所以这个过程需要将对象中的成员也复制过去（复制的是当前对象在此时时成员的值　）\n+ c++中的拷贝构造函数针对三种行为：＝　，f(T t)和　f(){T t;return t}返回对象－－这三种情况都针对左值的　　　\n+ =:注意这个是在定义时做的，如origin or1=or2;此时会调用\"拷贝构造函数\"（　同or1(or2))\n　or2=or3;此时不会调用拷贝构造函数\n（当程序员自己写了拷贝构造函数时，默认调用该构造函数，而不会区做成员复制，所以若在其中没有做复制，可能得到不想要的值，见例子)\n\n#### 拷贝构造函数的作用和使用\n##### 什么情况下会生成默认的拷贝构造函数？\n类似于构造函数，在以下情形会生成默认的拷贝构造函数－\n+ 当需要调用别的拷贝构造函数时，如：当类内含有一个member object而后者的class声明有一个copy　constructor时；\n+ 当类继承自一个base class而后者有拷贝构造函数\n+ 当类声明了一个或多个virtual functions时\n+ 当class 派生自一个继承　串琏，而其中有一个或多个virtual base classes 时\n\n#### 拷贝构造函数和编译器－－－汇编，转换：\n分三种情况讨论：\n+ 初始化拷贝构造：\n```cpp\n                   X x1(x0);\n                   X x2=x0;\n                   X x3=X(x0);```\n   上述三种都是定义一个类，即定义的本质会在内存中开辟空间\n上述三个都会执行拷贝构造函数，如何执行？  \n会被转换为：伪代码\n        X x1;\n        x1.X::X(x0);\n        会调用X::X(const X& xx) \n        x2,x3也是这样，将拷贝方作为函数参数传入\n        这样就可以解释为什么拷贝构造函数的定义是      \n        classname (const classname &obj)\n+ 参数的初始化\n即传入一个参数给函数：\n       foo(X x)\n如：\n       X xx;\n       //,..\n       foo(xx);\n       则会产生一个临时的对象：\n 伪代码\n        X __temp0;\n        _temp0.X::X(xx);//use copy construtor\n         foo(__temp0)\n这里因为它是临时的，所以则定义的时候需要用引用foo(X &x)//这里不是很清楚为什么用引用～！，是否后面的操作直接面向该对象，需要做实际的修改，所以。。\n所以，为了对付临时的对象，在执行完函数后，需要调用该对象的析构函数\n+ 返回值的初始化：  \n如\n       X bar(){\n                      X xx;\n                       //...\n                       return xx;\n            }\n         如何做X xxx=bar();如何拷贝的？双阶段初始化：\n         a 增加一个额外的引用参数给函数，如void bar(X＆　_result)\n         b 在return 前插入一个copy constructor \n             void bar(X &__result){\n                       X xx;\n                       xx.X::X();\n                       __result.X::XX(xx);\n                       return ;\n               }\n        所以上述会被转化为：\n        Ｘ　xx=bar()  --->  X xx ;//注意这里不会执行默认构造函数　　bar(xx);\n            ex:bar().memfunc()--->X __temp0;(bar(__temp0),__temp0).memfunc();\n            X (*pf)();pf=bar;--->void (*pf)(X&);pf=bar;\n            \n##### 关于上述三种情况的优化：\n１)在使用者层面上优化；２）在编译器层面的优化（ＮＲＶ）具体见深入模型（书）\n##### 关于该不该编写copy  constructor: \n除非需要大量的memberwise 初始化操作，如传值给object以便做NRV优化，否则不需要\n//上述情况的检验可以通过代码，或者去看编译器的生成代码～    \n##### 拷贝构造函数的内存\n放在代码段，\n### 初始化队列\n即构造函数的一种形式如：X(int f):a(ax),b(bx)..{....}\n+ 问题：什么时候用初始化列表？它和初始化赋值有什么不同？\n        有以下四种情况需要使用初始化列表：\n        １）当初始化一个reference member时\n        ２）当初始化一个const member时\n        ３）当调用一个base class的constructor,当它拥有一组参数时\n        ４）当调用一个member　class 的consructor，而它有一组参数时；\n如\n``cpp\n   class world {\n          String _nhame;\n          int cnt;\n          public :world(){_nhame=0;cnt=0;}}```\n//此时，对_nhame这个成员，需要做较多的事，如产生临时对像，调用operator=....\n   －－－－所以想到用初始化列表：\n```cpp \n          world::world:nhame(0){\n            cnt=0;\n            }\n            这样只会调用nhame的构造函数\n            会被转换为：world::world{ //伪代码\n             _nhame.String::String(0);\n              cnt=0;\n              }```\n+ 更具体的，初始化列表如何进行：顺序如何：如前，初始化列表最终会被转换为初始化表达式到构造函数体中，那是什么顺序呢？  \n注意这里的初始化顺序是根据成员在类中的定义（声明）顺序来的，而不是初始化列表中的顺序\n看这个例子：\n```cpp \n       class X{\n                    int i; \n                    int j;\n                   public:\n                     X(int cal):i(j){}\n                     ...\n                     此时，因为i先初始化,再j,出错，i需要j```\n                     \n  ---->可以改善为：X::X(int cal):j(cal){i=j;}   \n   ----为什么这样可以？  \n   因为初始化列表的内容会放到初始化体中的表达式前面，这样j就会先定义\n        －－－－》另一个可能出错的例子：\n        　　　X::X(int cal):i(xfoo(cal)),j(cal){}\n        -->转换为：X::X(/*this pointer*/ int cal){\n                      i=this->xfoo(cal);\n                      j=cal;\n                      }\n            这个情况在这里是对的，但是当X 继承自某个类，在xfoo是基类的函数，，则会出错this->xfoo\n\n#### 几个问题：\n+ 较为简单的例子见文件中的例子\n+ 当程序员定义了拷贝构造函数时，还会执行memberwise initialization吗　－－会执行拷贝构造函数\n参考：深入c++对象模型和http://en.cppreference.com/w/cpp/language/copy_constructor\n","source":"_posts/cpp-conandde.md","raw":"---\ntitle: cpp_conandde\ndate: 2018-06-09 11:03:35\ntags: cpp_class\ncategories: c&cpp\n---\n## c++ class constructor and destructor\n### 构造函数\n#### 构造函数表现\n##### 构造函数的作用：\n构造函数主要是用来初始化对象的－－－一般是成员，函数不用\n--所以它需要在构建对象时就执行<!--more-->\n##### 构造函数如何写：\n```cpp\npublic:　classname(arg...):member(arg),mem2(arg),..{xxx}\n    classname(..){..}\n```        \n##### 默认构造函数的生成规则（深入对象模型）\n+ 下面四个情况下会生成默认构造函数（编译器控制）(nontrivial default constructor)  \n + 带有default constructor的member class object  \n 即在类中带有对象成员，该对象成员所属的类有构造函数\n如：　\n```cpp\nclass Foo {public :Foo(),Foo(int)...}\nclass Bar{public:Foo foo;char *str};\n                          void funv()\n                          {   Bar bar;....\n                          }```\n这种情况下若程序员没有实现构造函数，则编译器会自己生成构造函数，来调用Foo的构造函数\n但是不初始化str,这个得由程序员来做。\n如类似于：\n```cpp\nBar::Bar(){\n   foo.Foo::Foo();\n ```                  \n 若程序员自己写了构造函数但是不包括初始化foo则，编译器会在程序眼写的构造函数中加入上述，另外若有多个对象\n则按照声明顺序进行调用他们的构造函数；\n + 带有Default constructor 的base class  \n 同理，当继承的基类带有构造函数时就会加入，若程序员的构造函数没有初始化他们时就会扩展  \n//以上见例子class_constructor.cpp，\n + 和vcirtual相关need to create vptr  \n    带有一个virtual　func的class  \n     1)class　声明或继承一个virtua func  \n     2)class派生自一个继承琏，其中有virtual base classes       这个比较容易理解\n                \n + 和virtual相关 need to init vptr\n   带有一个virtual　base class 的class  \n   如：\n   ```cpp\n       class X{  public int i;}  \n       class A :public virtual X {///\n       class B :public virtual X {\n       class C: public A,public B ```\n       \n\n##### 构造函数何时被执行  \n-在对象定义时若有构造函数，则会执行\n##### 实践：\n1:5构造函数的使用：重载，初始化式\n\n#### 构造函数表现的原理\n##### 构造函数在静态代码块中的位置和符号体现\n如果有定义构造函数，它本身也是一个函数，放在代码段中，可以通过kdbg查看\n```c\norigin(int ax=3,int bx=4):a(ax),b(bx){}\n0x400bae push   %rbp\n0x400baf mov    %rsp,%rbp\n0x400bb2 mov    %rdi,-0x8(%rbp)\n0x400bb6 mov    %esi,-0xc(%rbp)\n0x400bb9 mov    %edx,-0x10(%rbp)```\n##### 构造函数在动态执行时，放在哪个内存段中，如何被引用，使用\n+ 动态执行时，在代码段中，通过this引用\n+ 构造函数总结：任何c++ class只有在以上四中情况下才会产生默认构造函数，且产生的默认构造函数不会去初始化成员的值\n### 拷贝构造函数\n#### 拷贝的动作发生了什么\n拷贝的本质，为什么需要拷贝构造函数？\n+ 首先对基本的类型而言，拷贝是把值赋给另一个同类型的变量，而数租不能做=赋值拷贝\n+ 对对象而言，也是把值赋给同类型的对象，而不是共享一个指针，所以这个过程需要将对象中的成员也复制过去（复制的是当前对象在此时时成员的值　）\n+ c++中的拷贝构造函数针对三种行为：＝　，f(T t)和　f(){T t;return t}返回对象－－这三种情况都针对左值的　　　\n+ =:注意这个是在定义时做的，如origin or1=or2;此时会调用\"拷贝构造函数\"（　同or1(or2))\n　or2=or3;此时不会调用拷贝构造函数\n（当程序员自己写了拷贝构造函数时，默认调用该构造函数，而不会区做成员复制，所以若在其中没有做复制，可能得到不想要的值，见例子)\n\n#### 拷贝构造函数的作用和使用\n##### 什么情况下会生成默认的拷贝构造函数？\n类似于构造函数，在以下情形会生成默认的拷贝构造函数－\n+ 当需要调用别的拷贝构造函数时，如：当类内含有一个member object而后者的class声明有一个copy　constructor时；\n+ 当类继承自一个base class而后者有拷贝构造函数\n+ 当类声明了一个或多个virtual functions时\n+ 当class 派生自一个继承　串琏，而其中有一个或多个virtual base classes 时\n\n#### 拷贝构造函数和编译器－－－汇编，转换：\n分三种情况讨论：\n+ 初始化拷贝构造：\n```cpp\n                   X x1(x0);\n                   X x2=x0;\n                   X x3=X(x0);```\n   上述三种都是定义一个类，即定义的本质会在内存中开辟空间\n上述三个都会执行拷贝构造函数，如何执行？  \n会被转换为：伪代码\n        X x1;\n        x1.X::X(x0);\n        会调用X::X(const X& xx) \n        x2,x3也是这样，将拷贝方作为函数参数传入\n        这样就可以解释为什么拷贝构造函数的定义是      \n        classname (const classname &obj)\n+ 参数的初始化\n即传入一个参数给函数：\n       foo(X x)\n如：\n       X xx;\n       //,..\n       foo(xx);\n       则会产生一个临时的对象：\n 伪代码\n        X __temp0;\n        _temp0.X::X(xx);//use copy construtor\n         foo(__temp0)\n这里因为它是临时的，所以则定义的时候需要用引用foo(X &x)//这里不是很清楚为什么用引用～！，是否后面的操作直接面向该对象，需要做实际的修改，所以。。\n所以，为了对付临时的对象，在执行完函数后，需要调用该对象的析构函数\n+ 返回值的初始化：  \n如\n       X bar(){\n                      X xx;\n                       //...\n                       return xx;\n            }\n         如何做X xxx=bar();如何拷贝的？双阶段初始化：\n         a 增加一个额外的引用参数给函数，如void bar(X＆　_result)\n         b 在return 前插入一个copy constructor \n             void bar(X &__result){\n                       X xx;\n                       xx.X::X();\n                       __result.X::XX(xx);\n                       return ;\n               }\n        所以上述会被转化为：\n        Ｘ　xx=bar()  --->  X xx ;//注意这里不会执行默认构造函数　　bar(xx);\n            ex:bar().memfunc()--->X __temp0;(bar(__temp0),__temp0).memfunc();\n            X (*pf)();pf=bar;--->void (*pf)(X&);pf=bar;\n            \n##### 关于上述三种情况的优化：\n１)在使用者层面上优化；２）在编译器层面的优化（ＮＲＶ）具体见深入模型（书）\n##### 关于该不该编写copy  constructor: \n除非需要大量的memberwise 初始化操作，如传值给object以便做NRV优化，否则不需要\n//上述情况的检验可以通过代码，或者去看编译器的生成代码～    \n##### 拷贝构造函数的内存\n放在代码段，\n### 初始化队列\n即构造函数的一种形式如：X(int f):a(ax),b(bx)..{....}\n+ 问题：什么时候用初始化列表？它和初始化赋值有什么不同？\n        有以下四种情况需要使用初始化列表：\n        １）当初始化一个reference member时\n        ２）当初始化一个const member时\n        ３）当调用一个base class的constructor,当它拥有一组参数时\n        ４）当调用一个member　class 的consructor，而它有一组参数时；\n如\n``cpp\n   class world {\n          String _nhame;\n          int cnt;\n          public :world(){_nhame=0;cnt=0;}}```\n//此时，对_nhame这个成员，需要做较多的事，如产生临时对像，调用operator=....\n   －－－－所以想到用初始化列表：\n```cpp \n          world::world:nhame(0){\n            cnt=0;\n            }\n            这样只会调用nhame的构造函数\n            会被转换为：world::world{ //伪代码\n             _nhame.String::String(0);\n              cnt=0;\n              }```\n+ 更具体的，初始化列表如何进行：顺序如何：如前，初始化列表最终会被转换为初始化表达式到构造函数体中，那是什么顺序呢？  \n注意这里的初始化顺序是根据成员在类中的定义（声明）顺序来的，而不是初始化列表中的顺序\n看这个例子：\n```cpp \n       class X{\n                    int i; \n                    int j;\n                   public:\n                     X(int cal):i(j){}\n                     ...\n                     此时，因为i先初始化,再j,出错，i需要j```\n                     \n  ---->可以改善为：X::X(int cal):j(cal){i=j;}   \n   ----为什么这样可以？  \n   因为初始化列表的内容会放到初始化体中的表达式前面，这样j就会先定义\n        －－－－》另一个可能出错的例子：\n        　　　X::X(int cal):i(xfoo(cal)),j(cal){}\n        -->转换为：X::X(/*this pointer*/ int cal){\n                      i=this->xfoo(cal);\n                      j=cal;\n                      }\n            这个情况在这里是对的，但是当X 继承自某个类，在xfoo是基类的函数，，则会出错this->xfoo\n\n#### 几个问题：\n+ 较为简单的例子见文件中的例子\n+ 当程序员定义了拷贝构造函数时，还会执行memberwise initialization吗　－－会执行拷贝构造函数\n参考：深入c++对象模型和http://en.cppreference.com/w/cpp/language/copy_constructor\n","slug":"cpp-conandde","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7o000162ujx1hbvfkbj","content":"<h2 id=\"c-class-constructor-and-destructor\"><a href=\"#c-class-constructor-and-destructor\" class=\"headerlink\" title=\"c++ class constructor and destructor\"></a>c++ class constructor and destructor</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><h4 id=\"构造函数表现\"><a href=\"#构造函数表现\" class=\"headerlink\" title=\"构造函数表现\"></a>构造函数表现</h4><h5 id=\"构造函数的作用：\"><a href=\"#构造函数的作用：\" class=\"headerlink\" title=\"构造函数的作用：\"></a>构造函数的作用：</h5><p>构造函数主要是用来初始化对象的－－－一般是成员，函数不用<br>–所以它需要在构建对象时就执行<a id=\"more\"></a></p>\n<h5 id=\"构造函数如何写：\"><a href=\"#构造函数如何写：\" class=\"headerlink\" title=\"构造函数如何写：\"></a>构造函数如何写：</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:　classname(arg...):member(arg),mem2(arg),..&#123;xxx&#125;</span><br><span class=\"line\">    classname(..)&#123;..&#125;</span><br><span class=\"line\">```        </span><br><span class=\"line\">##### 默认构造函数的生成规则（深入对象模型）</span><br><span class=\"line\">+ 下面四个情况下会生成默认构造函数（编译器控制）(nontrivial <span class=\"keyword\">default</span> constructor)  </span><br><span class=\"line\"> + 带有<span class=\"keyword\">default</span> constructor的member <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">object</span>  </span></span><br><span class=\"line\"><span class=\"class\"> 即在类中带有对象成员，该对象成员所属的类有构造函数</span></span><br><span class=\"line\"><span class=\"class\">如：　</span></span><br><span class=\"line\"><span class=\"class\">```<span class=\"title\">cpp</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Foo</span> &#123;</span><span class=\"keyword\">public</span> :Foo(),Foo(<span class=\"keyword\">int</span>)...&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span>&#123;</span><span class=\"keyword\">public</span>:Foo foo;<span class=\"keyword\">char</span> *str&#125;;</span><br><span class=\"line\">                          <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funv</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">                          </span>&#123;   Bar bar;....</span><br><span class=\"line\">                          &#125;</span><br></pre></td></tr></table></figure>\n<p>这种情况下若程序员没有实现构造函数，则编译器会自己生成构造函数，来调用Foo的构造函数<br>但是不初始化str,这个得由程序员来做。<br>如类似于：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Bar::Bar()&#123;</span><br><span class=\"line\">   foo.Foo::Foo();</span><br><span class=\"line\"> ```                  </span><br><span class=\"line\"> 若程序员自己写了构造函数但是不包括初始化foo则，编译器会在程序眼写的构造函数中加入上述，另外若有多个对象</span><br><span class=\"line\">则按照声明顺序进行调用他们的构造函数；</span><br><span class=\"line\"> + 带有Default constructor 的base <span class=\"class\"><span class=\"keyword\">class</span>  </span></span><br><span class=\"line\"><span class=\"class\"> 同理，当继承的基类带有构造函数时就会加入，若程序员的构造函数没有初始化他们时就会扩展  </span></span><br><span class=\"line\"><span class=\"class\">//以上见例子<span class=\"title\">class_constructor</span>.<span class=\"title\">cpp</span>，</span></span><br><span class=\"line\"><span class=\"class\"> + 和<span class=\"title\">vcirtual</span>相关<span class=\"title\">need</span> <span class=\"title\">to</span> <span class=\"title\">create</span> <span class=\"title\">vptr</span>  </span></span><br><span class=\"line\"><span class=\"class\">    带有一个<span class=\"title\">virtual</span>　<span class=\"title\">func</span>的<span class=\"title\">class</span>  </span></span><br><span class=\"line\"><span class=\"class\">     1)<span class=\"title\">class</span>　声明或继承一个<span class=\"title\">virtua</span> <span class=\"title\">func</span>  </span></span><br><span class=\"line\"><span class=\"class\">     2)<span class=\"title\">class</span>派生自一个继承琏，其中有<span class=\"title\">virtual</span> <span class=\"title\">base</span> <span class=\"title\">classes</span>       这个比较容易理解</span></span><br><span class=\"line\"><span class=\"class\">                </span></span><br><span class=\"line\"><span class=\"class\"> + 和<span class=\"title\">virtual</span>相关 <span class=\"title\">need</span> <span class=\"title\">to</span> <span class=\"title\">init</span> <span class=\"title\">vptr</span></span></span><br><span class=\"line\"><span class=\"class\">   带有一个<span class=\"title\">virtual</span>　<span class=\"title\">base</span> <span class=\"title\">class</span> 的<span class=\"title\">class</span>  </span></span><br><span class=\"line\"><span class=\"class\">   如：</span></span><br><span class=\"line\"><span class=\"class\">   ```<span class=\"title\">cpp</span></span></span><br><span class=\"line\"><span class=\"class\">       <span class=\"title\">class</span> <span class=\"title\">X</span>&#123;</span>  <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> i;&#125;  </span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> :</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> X &#123;<span class=\"comment\">///</span></span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> X &#123;</span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>:</span> <span class=\"keyword\">public</span> A,<span class=\"keyword\">public</span> B</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"构造函数何时被执行\"><a href=\"#构造函数何时被执行\" class=\"headerlink\" title=\"构造函数何时被执行\"></a>构造函数何时被执行</h5><p>-在对象定义时若有构造函数，则会执行</p>\n<h5 id=\"实践：\"><a href=\"#实践：\" class=\"headerlink\" title=\"实践：\"></a>实践：</h5><p>1:5构造函数的使用：重载，初始化式</p>\n<h4 id=\"构造函数表现的原理\"><a href=\"#构造函数表现的原理\" class=\"headerlink\" title=\"构造函数表现的原理\"></a>构造函数表现的原理</h4><h5 id=\"构造函数在静态代码块中的位置和符号体现\"><a href=\"#构造函数在静态代码块中的位置和符号体现\" class=\"headerlink\" title=\"构造函数在静态代码块中的位置和符号体现\"></a>构造函数在静态代码块中的位置和符号体现</h5><p>如果有定义构造函数，它本身也是一个函数，放在代码段中，可以通过kdbg查看<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin(<span class=\"keyword\">int</span> ax=<span class=\"number\">3</span>,<span class=\"keyword\">int</span> bx=<span class=\"number\">4</span>):a(ax),b(bx)&#123;&#125;</span><br><span class=\"line\"><span class=\"number\">0x400bae</span> push   %rbp</span><br><span class=\"line\"><span class=\"number\">0x400baf</span> mov    %rsp,%rbp</span><br><span class=\"line\"><span class=\"number\">0x400bb2</span> mov    %rdi,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\"><span class=\"number\">0x400bb6</span> mov    %esi,<span class=\"number\">-0xc</span>(%rbp)</span><br><span class=\"line\"><span class=\"number\">0x400bb9</span> mov    %edx,<span class=\"number\">-0x10</span>(%rbp)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"构造函数在动态执行时，放在哪个内存段中，如何被引用，使用\"><a href=\"#构造函数在动态执行时，放在哪个内存段中，如何被引用，使用\" class=\"headerlink\" title=\"构造函数在动态执行时，放在哪个内存段中，如何被引用，使用\"></a>构造函数在动态执行时，放在哪个内存段中，如何被引用，使用</h5><ul>\n<li>动态执行时，在代码段中，通过this引用</li>\n<li>构造函数总结：任何c++ class只有在以上四中情况下才会产生默认构造函数，且产生的默认构造函数不会去初始化成员的值<h3 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h3><h4 id=\"拷贝的动作发生了什么\"><a href=\"#拷贝的动作发生了什么\" class=\"headerlink\" title=\"拷贝的动作发生了什么\"></a>拷贝的动作发生了什么</h4>拷贝的本质，为什么需要拷贝构造函数？</li>\n<li>首先对基本的类型而言，拷贝是把值赋给另一个同类型的变量，而数租不能做=赋值拷贝</li>\n<li>对对象而言，也是把值赋给同类型的对象，而不是共享一个指针，所以这个过程需要将对象中的成员也复制过去（复制的是当前对象在此时时成员的值　）</li>\n<li>c++中的拷贝构造函数针对三种行为：＝　，f(T t)和　f(){T t;return t}返回对象－－这三种情况都针对左值的　　　</li>\n<li>=:注意这个是在定义时做的，如origin or1=or2;此时会调用”拷贝构造函数”（　同or1(or2))<br>　or2=or3;此时不会调用拷贝构造函数<br>（当程序员自己写了拷贝构造函数时，默认调用该构造函数，而不会区做成员复制，所以若在其中没有做复制，可能得到不想要的值，见例子)</li>\n</ul>\n<h4 id=\"拷贝构造函数的作用和使用\"><a href=\"#拷贝构造函数的作用和使用\" class=\"headerlink\" title=\"拷贝构造函数的作用和使用\"></a>拷贝构造函数的作用和使用</h4><h5 id=\"什么情况下会生成默认的拷贝构造函数？\"><a href=\"#什么情况下会生成默认的拷贝构造函数？\" class=\"headerlink\" title=\"什么情况下会生成默认的拷贝构造函数？\"></a>什么情况下会生成默认的拷贝构造函数？</h5><p>类似于构造函数，在以下情形会生成默认的拷贝构造函数－</p>\n<ul>\n<li>当需要调用别的拷贝构造函数时，如：当类内含有一个member object而后者的class声明有一个copy　constructor时；</li>\n<li>当类继承自一个base class而后者有拷贝构造函数</li>\n<li>当类声明了一个或多个virtual functions时</li>\n<li>当class 派生自一个继承　串琏，而其中有一个或多个virtual base classes 时</li>\n</ul>\n<h4 id=\"拷贝构造函数和编译器－－－汇编，转换：\"><a href=\"#拷贝构造函数和编译器－－－汇编，转换：\" class=\"headerlink\" title=\"拷贝构造函数和编译器－－－汇编，转换：\"></a>拷贝构造函数和编译器－－－汇编，转换：</h4><p>分三种情况讨论：</p>\n<ul>\n<li><p>初始化拷贝构造：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">X <span class=\"title\">x1</span><span class=\"params\">(x0)</span></span>;</span><br><span class=\"line\">X x2=x0;</span><br><span class=\"line\">X x3=X(x0);</span><br></pre></td></tr></table></figure>\n<p> 上述三种都是定义一个类，即定义的本质会在内存中开辟空间<br>上述三个都会执行拷贝构造函数，如何执行？<br>会被转换为：伪代码</p>\n<pre><code>X x1;\nx1.X::X(x0);\n会调用X::X(const X&amp; xx) \nx2,x3也是这样，将拷贝方作为函数参数传入\n这样就可以解释为什么拷贝构造函数的定义是      \nclassname (const classname &amp;obj)\n</code></pre></li>\n<li>参数的初始化<br>即传入一个参数给函数：<pre><code>foo(X x)\n</code></pre>如：<pre><code>X xx;\n//,..\nfoo(xx);\n则会产生一个临时的对象：\n</code></pre>伪代码<pre><code>X __temp0;\n_temp0.X::X(xx);//use copy construtor\n foo(__temp0)\n</code></pre>这里因为它是临时的，所以则定义的时候需要用引用foo(X &amp;x)//这里不是很清楚为什么用引用～！，是否后面的操作直接面向该对象，需要做实际的修改，所以。。<br>所以，为了对付临时的对象，在执行完函数后，需要调用该对象的析构函数</li>\n<li>返回值的初始化：<br>如<pre><code>X bar(){\n               X xx;\n                //...\n                return xx;\n     }\n  如何做X xxx=bar();如何拷贝的？双阶段初始化：\n  a 增加一个额外的引用参数给函数，如void bar(X＆　_result)\n  b 在return 前插入一个copy constructor \n      void bar(X &amp;__result){\n                X xx;\n                xx.X::X();\n                __result.X::XX(xx);\n                return ;\n        }\n 所以上述会被转化为：\n Ｘ　xx=bar()  ---&gt;  X xx ;//注意这里不会执行默认构造函数　　bar(xx);\n     ex:bar().memfunc()---&gt;X __temp0;(bar(__temp0),__temp0).memfunc();\n     X (*pf)();pf=bar;---&gt;void (*pf)(X&amp;);pf=bar;\n</code></pre></li>\n</ul>\n<h5 id=\"关于上述三种情况的优化：\"><a href=\"#关于上述三种情况的优化：\" class=\"headerlink\" title=\"关于上述三种情况的优化：\"></a>关于上述三种情况的优化：</h5><p>１)在使用者层面上优化；２）在编译器层面的优化（ＮＲＶ）具体见深入模型（书）</p>\n<h5 id=\"关于该不该编写copy-constructor\"><a href=\"#关于该不该编写copy-constructor\" class=\"headerlink\" title=\"关于该不该编写copy  constructor:\"></a>关于该不该编写copy  constructor:</h5><p>除非需要大量的memberwise 初始化操作，如传值给object以便做NRV优化，否则不需要<br>//上述情况的检验可以通过代码，或者去看编译器的生成代码～    </p>\n<h5 id=\"拷贝构造函数的内存\"><a href=\"#拷贝构造函数的内存\" class=\"headerlink\" title=\"拷贝构造函数的内存\"></a>拷贝构造函数的内存</h5><p>放在代码段，</p>\n<h3 id=\"初始化队列\"><a href=\"#初始化队列\" class=\"headerlink\" title=\"初始化队列\"></a>初始化队列</h3><p>即构造函数的一种形式如：X(int f):a(ax),b(bx)..{….}</p>\n<ul>\n<li><p>问题：什么时候用初始化列表？它和初始化赋值有什么不同？</p>\n<pre><code>有以下四种情况需要使用初始化列表：\n１）当初始化一个reference member时\n２）当初始化一个const member时\n３）当调用一个base class的constructor,当它拥有一组参数时\n４）当调用一个member　class 的consructor，而它有一组参数时；\n</code></pre><p>如<br><code></code>cpp<br> class world {</p>\n<pre><code>String _nhame;\nint cnt;\npublic :world(){_nhame=0;cnt=0;}}<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//此时，对_nhame这个成员，需要做较多的事，如产生临时对像，调用operator=....</span></span><br><span class=\"line\">   －－－－所以想到用初始化列表：</span><br><span class=\"line\">```cpp </span><br><span class=\"line\">          world::world:nhame(<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            这样只会调用nhame的构造函数</span><br><span class=\"line\">            会被转换为：world::world&#123; <span class=\"comment\">//伪代码</span></span><br><span class=\"line\">             _nhame.String::String(<span class=\"number\">0</span>);</span><br><span class=\"line\">              cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">              &#125;</span><br></pre></td></tr></table></figure>\n</code></pre></li>\n<li><p>更具体的，初始化列表如何进行：顺序如何：如前，初始化列表最终会被转换为初始化表达式到构造函数体中，那是什么顺序呢？<br>注意这里的初始化顺序是根据成员在类中的定义（声明）顺序来的，而不是初始化列表中的顺序<br>看这个例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span>&#123;</span></span><br><span class=\"line\">             <span class=\"keyword\">int</span> i; </span><br><span class=\"line\">             <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">            <span class=\"keyword\">public</span>:</span><br><span class=\"line\">              X(<span class=\"keyword\">int</span> cal):i(j)&#123;&#125;</span><br><span class=\"line\">              ...</span><br><span class=\"line\">              此时，因为i先初始化,再j,出错，i需要j</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  —-&gt;可以改善为：X::X(int cal):j(cal){i=j;}<br>   —-为什么这样可以？<br>   因为初始化列表的内容会放到初始化体中的表达式前面，这样j就会先定义<br>        －－－－》另一个可能出错的例子：<br>        　　　X::X(int cal):i(xfoo(cal)),j(cal){}<br>        –&gt;转换为：X::X(/<em>this pointer</em>/ int cal){<br>                      i=this-&gt;xfoo(cal);<br>                      j=cal;<br>                      }<br>            这个情况在这里是对的，但是当X 继承自某个类，在xfoo是基类的函数，，则会出错this-&gt;xfoo</p>\n<h4 id=\"几个问题：\"><a href=\"#几个问题：\" class=\"headerlink\" title=\"几个问题：\"></a>几个问题：</h4><ul>\n<li>较为简单的例子见文件中的例子</li>\n<li>当程序员定义了拷贝构造函数时，还会执行memberwise initialization吗　－－会执行拷贝构造函数<br>参考：深入c++对象模型和<a href=\"http://en.cppreference.com/w/cpp/language/copy_constructor\" target=\"_blank\" rel=\"noopener\">http://en.cppreference.com/w/cpp/language/copy_constructor</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"c-class-constructor-and-destructor\"><a href=\"#c-class-constructor-and-destructor\" class=\"headerlink\" title=\"c++ class constructor and destructor\"></a>c++ class constructor and destructor</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><h4 id=\"构造函数表现\"><a href=\"#构造函数表现\" class=\"headerlink\" title=\"构造函数表现\"></a>构造函数表现</h4><h5 id=\"构造函数的作用：\"><a href=\"#构造函数的作用：\" class=\"headerlink\" title=\"构造函数的作用：\"></a>构造函数的作用：</h5><p>构造函数主要是用来初始化对象的－－－一般是成员，函数不用<br>–所以它需要在构建对象时就执行","more":"</p>\n<h5 id=\"构造函数如何写：\"><a href=\"#构造函数如何写：\" class=\"headerlink\" title=\"构造函数如何写：\"></a>构造函数如何写：</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:　classname(arg...):member(arg),mem2(arg),..&#123;xxx&#125;</span><br><span class=\"line\">    classname(..)&#123;..&#125;</span><br><span class=\"line\">```        </span><br><span class=\"line\">##### 默认构造函数的生成规则（深入对象模型）</span><br><span class=\"line\">+ 下面四个情况下会生成默认构造函数（编译器控制）(nontrivial <span class=\"keyword\">default</span> constructor)  </span><br><span class=\"line\"> + 带有<span class=\"keyword\">default</span> constructor的member <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">object</span>  </span></span><br><span class=\"line\"><span class=\"class\"> 即在类中带有对象成员，该对象成员所属的类有构造函数</span></span><br><span class=\"line\"><span class=\"class\">如：　</span></span><br><span class=\"line\"><span class=\"class\">```<span class=\"title\">cpp</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Foo</span> &#123;</span><span class=\"keyword\">public</span> :Foo(),Foo(<span class=\"keyword\">int</span>)...&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span>&#123;</span><span class=\"keyword\">public</span>:Foo foo;<span class=\"keyword\">char</span> *str&#125;;</span><br><span class=\"line\">                          <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">funv</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">                          </span>&#123;   Bar bar;....</span><br><span class=\"line\">                          &#125;</span><br></pre></td></tr></table></figure>\n<p>这种情况下若程序员没有实现构造函数，则编译器会自己生成构造函数，来调用Foo的构造函数<br>但是不初始化str,这个得由程序员来做。<br>如类似于：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Bar::Bar()&#123;</span><br><span class=\"line\">   foo.Foo::Foo();</span><br><span class=\"line\"> ```                  </span><br><span class=\"line\"> 若程序员自己写了构造函数但是不包括初始化foo则，编译器会在程序眼写的构造函数中加入上述，另外若有多个对象</span><br><span class=\"line\">则按照声明顺序进行调用他们的构造函数；</span><br><span class=\"line\"> + 带有Default constructor 的base <span class=\"class\"><span class=\"keyword\">class</span>  </span></span><br><span class=\"line\"><span class=\"class\"> 同理，当继承的基类带有构造函数时就会加入，若程序员的构造函数没有初始化他们时就会扩展  </span></span><br><span class=\"line\"><span class=\"class\">//以上见例子<span class=\"title\">class_constructor</span>.<span class=\"title\">cpp</span>，</span></span><br><span class=\"line\"><span class=\"class\"> + 和<span class=\"title\">vcirtual</span>相关<span class=\"title\">need</span> <span class=\"title\">to</span> <span class=\"title\">create</span> <span class=\"title\">vptr</span>  </span></span><br><span class=\"line\"><span class=\"class\">    带有一个<span class=\"title\">virtual</span>　<span class=\"title\">func</span>的<span class=\"title\">class</span>  </span></span><br><span class=\"line\"><span class=\"class\">     1)<span class=\"title\">class</span>　声明或继承一个<span class=\"title\">virtua</span> <span class=\"title\">func</span>  </span></span><br><span class=\"line\"><span class=\"class\">     2)<span class=\"title\">class</span>派生自一个继承琏，其中有<span class=\"title\">virtual</span> <span class=\"title\">base</span> <span class=\"title\">classes</span>       这个比较容易理解</span></span><br><span class=\"line\"><span class=\"class\">                </span></span><br><span class=\"line\"><span class=\"class\"> + 和<span class=\"title\">virtual</span>相关 <span class=\"title\">need</span> <span class=\"title\">to</span> <span class=\"title\">init</span> <span class=\"title\">vptr</span></span></span><br><span class=\"line\"><span class=\"class\">   带有一个<span class=\"title\">virtual</span>　<span class=\"title\">base</span> <span class=\"title\">class</span> 的<span class=\"title\">class</span>  </span></span><br><span class=\"line\"><span class=\"class\">   如：</span></span><br><span class=\"line\"><span class=\"class\">   ```<span class=\"title\">cpp</span></span></span><br><span class=\"line\"><span class=\"class\">       <span class=\"title\">class</span> <span class=\"title\">X</span>&#123;</span>  <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> i;&#125;  </span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> :</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> X &#123;<span class=\"comment\">///</span></span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> X &#123;</span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>:</span> <span class=\"keyword\">public</span> A,<span class=\"keyword\">public</span> B</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"构造函数何时被执行\"><a href=\"#构造函数何时被执行\" class=\"headerlink\" title=\"构造函数何时被执行\"></a>构造函数何时被执行</h5><p>-在对象定义时若有构造函数，则会执行</p>\n<h5 id=\"实践：\"><a href=\"#实践：\" class=\"headerlink\" title=\"实践：\"></a>实践：</h5><p>1:5构造函数的使用：重载，初始化式</p>\n<h4 id=\"构造函数表现的原理\"><a href=\"#构造函数表现的原理\" class=\"headerlink\" title=\"构造函数表现的原理\"></a>构造函数表现的原理</h4><h5 id=\"构造函数在静态代码块中的位置和符号体现\"><a href=\"#构造函数在静态代码块中的位置和符号体现\" class=\"headerlink\" title=\"构造函数在静态代码块中的位置和符号体现\"></a>构造函数在静态代码块中的位置和符号体现</h5><p>如果有定义构造函数，它本身也是一个函数，放在代码段中，可以通过kdbg查看<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin(<span class=\"keyword\">int</span> ax=<span class=\"number\">3</span>,<span class=\"keyword\">int</span> bx=<span class=\"number\">4</span>):a(ax),b(bx)&#123;&#125;</span><br><span class=\"line\"><span class=\"number\">0x400bae</span> push   %rbp</span><br><span class=\"line\"><span class=\"number\">0x400baf</span> mov    %rsp,%rbp</span><br><span class=\"line\"><span class=\"number\">0x400bb2</span> mov    %rdi,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\"><span class=\"number\">0x400bb6</span> mov    %esi,<span class=\"number\">-0xc</span>(%rbp)</span><br><span class=\"line\"><span class=\"number\">0x400bb9</span> mov    %edx,<span class=\"number\">-0x10</span>(%rbp)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"构造函数在动态执行时，放在哪个内存段中，如何被引用，使用\"><a href=\"#构造函数在动态执行时，放在哪个内存段中，如何被引用，使用\" class=\"headerlink\" title=\"构造函数在动态执行时，放在哪个内存段中，如何被引用，使用\"></a>构造函数在动态执行时，放在哪个内存段中，如何被引用，使用</h5><ul>\n<li>动态执行时，在代码段中，通过this引用</li>\n<li>构造函数总结：任何c++ class只有在以上四中情况下才会产生默认构造函数，且产生的默认构造函数不会去初始化成员的值<h3 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h3><h4 id=\"拷贝的动作发生了什么\"><a href=\"#拷贝的动作发生了什么\" class=\"headerlink\" title=\"拷贝的动作发生了什么\"></a>拷贝的动作发生了什么</h4>拷贝的本质，为什么需要拷贝构造函数？</li>\n<li>首先对基本的类型而言，拷贝是把值赋给另一个同类型的变量，而数租不能做=赋值拷贝</li>\n<li>对对象而言，也是把值赋给同类型的对象，而不是共享一个指针，所以这个过程需要将对象中的成员也复制过去（复制的是当前对象在此时时成员的值　）</li>\n<li>c++中的拷贝构造函数针对三种行为：＝　，f(T t)和　f(){T t;return t}返回对象－－这三种情况都针对左值的　　　</li>\n<li>=:注意这个是在定义时做的，如origin or1=or2;此时会调用”拷贝构造函数”（　同or1(or2))<br>　or2=or3;此时不会调用拷贝构造函数<br>（当程序员自己写了拷贝构造函数时，默认调用该构造函数，而不会区做成员复制，所以若在其中没有做复制，可能得到不想要的值，见例子)</li>\n</ul>\n<h4 id=\"拷贝构造函数的作用和使用\"><a href=\"#拷贝构造函数的作用和使用\" class=\"headerlink\" title=\"拷贝构造函数的作用和使用\"></a>拷贝构造函数的作用和使用</h4><h5 id=\"什么情况下会生成默认的拷贝构造函数？\"><a href=\"#什么情况下会生成默认的拷贝构造函数？\" class=\"headerlink\" title=\"什么情况下会生成默认的拷贝构造函数？\"></a>什么情况下会生成默认的拷贝构造函数？</h5><p>类似于构造函数，在以下情形会生成默认的拷贝构造函数－</p>\n<ul>\n<li>当需要调用别的拷贝构造函数时，如：当类内含有一个member object而后者的class声明有一个copy　constructor时；</li>\n<li>当类继承自一个base class而后者有拷贝构造函数</li>\n<li>当类声明了一个或多个virtual functions时</li>\n<li>当class 派生自一个继承　串琏，而其中有一个或多个virtual base classes 时</li>\n</ul>\n<h4 id=\"拷贝构造函数和编译器－－－汇编，转换：\"><a href=\"#拷贝构造函数和编译器－－－汇编，转换：\" class=\"headerlink\" title=\"拷贝构造函数和编译器－－－汇编，转换：\"></a>拷贝构造函数和编译器－－－汇编，转换：</h4><p>分三种情况讨论：</p>\n<ul>\n<li><p>初始化拷贝构造：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">X <span class=\"title\">x1</span><span class=\"params\">(x0)</span></span>;</span><br><span class=\"line\">X x2=x0;</span><br><span class=\"line\">X x3=X(x0);</span><br></pre></td></tr></table></figure>\n<p> 上述三种都是定义一个类，即定义的本质会在内存中开辟空间<br>上述三个都会执行拷贝构造函数，如何执行？<br>会被转换为：伪代码</p>\n<pre><code>X x1;\nx1.X::X(x0);\n会调用X::X(const X&amp; xx) \nx2,x3也是这样，将拷贝方作为函数参数传入\n这样就可以解释为什么拷贝构造函数的定义是      \nclassname (const classname &amp;obj)\n</code></pre></li>\n<li>参数的初始化<br>即传入一个参数给函数：<pre><code>foo(X x)\n</code></pre>如：<pre><code>X xx;\n//,..\nfoo(xx);\n则会产生一个临时的对象：\n</code></pre>伪代码<pre><code>X __temp0;\n_temp0.X::X(xx);//use copy construtor\n foo(__temp0)\n</code></pre>这里因为它是临时的，所以则定义的时候需要用引用foo(X &amp;x)//这里不是很清楚为什么用引用～！，是否后面的操作直接面向该对象，需要做实际的修改，所以。。<br>所以，为了对付临时的对象，在执行完函数后，需要调用该对象的析构函数</li>\n<li>返回值的初始化：<br>如<pre><code>X bar(){\n               X xx;\n                //...\n                return xx;\n     }\n  如何做X xxx=bar();如何拷贝的？双阶段初始化：\n  a 增加一个额外的引用参数给函数，如void bar(X＆　_result)\n  b 在return 前插入一个copy constructor \n      void bar(X &amp;__result){\n                X xx;\n                xx.X::X();\n                __result.X::XX(xx);\n                return ;\n        }\n 所以上述会被转化为：\n Ｘ　xx=bar()  ---&gt;  X xx ;//注意这里不会执行默认构造函数　　bar(xx);\n     ex:bar().memfunc()---&gt;X __temp0;(bar(__temp0),__temp0).memfunc();\n     X (*pf)();pf=bar;---&gt;void (*pf)(X&amp;);pf=bar;\n</code></pre></li>\n</ul>\n<h5 id=\"关于上述三种情况的优化：\"><a href=\"#关于上述三种情况的优化：\" class=\"headerlink\" title=\"关于上述三种情况的优化：\"></a>关于上述三种情况的优化：</h5><p>１)在使用者层面上优化；２）在编译器层面的优化（ＮＲＶ）具体见深入模型（书）</p>\n<h5 id=\"关于该不该编写copy-constructor\"><a href=\"#关于该不该编写copy-constructor\" class=\"headerlink\" title=\"关于该不该编写copy  constructor:\"></a>关于该不该编写copy  constructor:</h5><p>除非需要大量的memberwise 初始化操作，如传值给object以便做NRV优化，否则不需要<br>//上述情况的检验可以通过代码，或者去看编译器的生成代码～    </p>\n<h5 id=\"拷贝构造函数的内存\"><a href=\"#拷贝构造函数的内存\" class=\"headerlink\" title=\"拷贝构造函数的内存\"></a>拷贝构造函数的内存</h5><p>放在代码段，</p>\n<h3 id=\"初始化队列\"><a href=\"#初始化队列\" class=\"headerlink\" title=\"初始化队列\"></a>初始化队列</h3><p>即构造函数的一种形式如：X(int f):a(ax),b(bx)..{….}</p>\n<ul>\n<li><p>问题：什么时候用初始化列表？它和初始化赋值有什么不同？</p>\n<pre><code>有以下四种情况需要使用初始化列表：\n１）当初始化一个reference member时\n２）当初始化一个const member时\n３）当调用一个base class的constructor,当它拥有一组参数时\n４）当调用一个member　class 的consructor，而它有一组参数时；\n</code></pre><p>如<br><code></code>cpp<br> class world {</p>\n<pre><code>String _nhame;\nint cnt;\npublic :world(){_nhame=0;cnt=0;}}<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//此时，对_nhame这个成员，需要做较多的事，如产生临时对像，调用operator=....</span></span><br><span class=\"line\">   －－－－所以想到用初始化列表：</span><br><span class=\"line\">```cpp </span><br><span class=\"line\">          world::world:nhame(<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            这样只会调用nhame的构造函数</span><br><span class=\"line\">            会被转换为：world::world&#123; <span class=\"comment\">//伪代码</span></span><br><span class=\"line\">             _nhame.String::String(<span class=\"number\">0</span>);</span><br><span class=\"line\">              cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">              &#125;</span><br></pre></td></tr></table></figure>\n</code></pre></li>\n<li><p>更具体的，初始化列表如何进行：顺序如何：如前，初始化列表最终会被转换为初始化表达式到构造函数体中，那是什么顺序呢？<br>注意这里的初始化顺序是根据成员在类中的定义（声明）顺序来的，而不是初始化列表中的顺序<br>看这个例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span>&#123;</span></span><br><span class=\"line\">             <span class=\"keyword\">int</span> i; </span><br><span class=\"line\">             <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">            <span class=\"keyword\">public</span>:</span><br><span class=\"line\">              X(<span class=\"keyword\">int</span> cal):i(j)&#123;&#125;</span><br><span class=\"line\">              ...</span><br><span class=\"line\">              此时，因为i先初始化,再j,出错，i需要j</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  —-&gt;可以改善为：X::X(int cal):j(cal){i=j;}<br>   —-为什么这样可以？<br>   因为初始化列表的内容会放到初始化体中的表达式前面，这样j就会先定义<br>        －－－－》另一个可能出错的例子：<br>        　　　X::X(int cal):i(xfoo(cal)),j(cal){}<br>        –&gt;转换为：X::X(/<em>this pointer</em>/ int cal){<br>                      i=this-&gt;xfoo(cal);<br>                      j=cal;<br>                      }<br>            这个情况在这里是对的，但是当X 继承自某个类，在xfoo是基类的函数，，则会出错this-&gt;xfoo</p>\n<h4 id=\"几个问题：\"><a href=\"#几个问题：\" class=\"headerlink\" title=\"几个问题：\"></a>几个问题：</h4><ul>\n<li>较为简单的例子见文件中的例子</li>\n<li>当程序员定义了拷贝构造函数时，还会执行memberwise initialization吗　－－会执行拷贝构造函数<br>参考：深入c++对象模型和<a href=\"http://en.cppreference.com/w/cpp/language/copy_constructor\" target=\"_blank\" rel=\"noopener\">http://en.cppreference.com/w/cpp/language/copy_constructor</a></li>\n</ul>"},{"title":"cpp_funcmember_memory","date":"2018-06-09T08:21:29.000Z","_content":"### c++ function语意学\nsomething:  \n恩，这部分记录自己对c++中的函数特殊性的理解，本想深入函数本质，之前接触过，记得在linux内核剖析那本书讲的很好。\n 可以参考；<!--more-->\n \n + 实现类的成员函数和类之间的关联，即通过对象能调用成员函数。这种实现，可以是以下几种方式：\n 1）struct+函数指针：结构体中，一个成员函数对应一个指针，增加空间 如何操作成员？\n 2）函数+this指针，普通函数，this指针一个，不添加额外多的空间，this 操作成员\n 。。。\n \n+ c++的类主要是将成员和函数封装起来。那么成员的封装就像struct一样，而函数呢？成员函数如何和类，对象联系起来？--this指针\n\n\n + c++中的成员函数和普通函数一样，只是多了个this指针，这个指针指向当前调用这个函数的对象，并以形参传入，这样，成员函数就可以使用对象成员了，通过\n this指针；\n \n+  这里也是根据深入探索c++模型中第四章，function语义学总结的：\n#### 引入这个问题：\n 通过对象和对象指针来调用成员函数的不同：  \n   Point3d obj;  \n   Point3d *p=&obj;  \n   两者效率有何不同？\n   \n   通过上面分析：当这个成员函数为普通的成员函数时，则直接调用函数，传入this指针，所以基本没有大的区别  \n #### 以下分为几种函数讨论：\n##### 非静态成员函数：\n   为了支持this指针等构成成员函数，c++做了如下步骤：  \n  +  a;改写函数原型：安插了一个this参数\n  +  b；对对象成员的操作，通过this\n  +  c;对成员函数写成外部函数，并将其名称进行mangling处理，成独一无二～类似：函数名___类名参数名 等等\n + 如何命名：成员函数和成员都会被名称特殊化处理：一般加上base class &derived class名\n      对重载函数而言如何区分：加上参数链表；\n      当extern C时，会压抑这种特殊命名化\n      具体编译器实现不同，可以通过汇编等。gdb等看\n   \n   \n+  鉴于此：看一个例子：  \n   当你需要构造一个（拷贝构造函数）或者改变一个类的成员： 伪代码：  \n  ```cpp\n  void normalize__Point(register const Point3d *const this,Point3d &_result)\n   {\n      _reuslt.Point3d::Point3d() //默认构造函数：\n      _result._x=this->__x/2;\n      ...\n      return ;\n   }\n   那么，以下这种方式：更好：\n   Point3d Point3d::normmalize() const{\n       return  Point3d(_x/2 ...)直接构建会更快） \n    =》转换为return Point3d(this->_x/2,...)   \n  ```\n ##### virtual func\n 若normilaze是虚拟函数，则  \n ptr->normilaze()=》 （*ptr->vptr[1])(ptr);  \n 可以看到效率较低，所以当确认不用多态机制的时候，最好抑制它，直接使用：Point3d::xxx  这种方式调用函数\n 而若被写成内连函数会更优--原因待探索：\n \n \n##### 静态成员函数：\n 显然这种能被类直接调用的函数，没有this指针，从而也就无法用成员  \n 这种函数的出现，是因为一种需求：即不用每个成员函数都会使用成员，不一定需要this  \n 不用声明一个对象就可以调用函数，当非要对象不可，又不用成员时：   \n ```cpp\n ((Point3d*)0)->object_count() ;```\n 有了static后，就不用上述方式了  \n 所以static的特性完全来源它的原理：  \n+ 它不能直接存取non static 成员\n+ 它不能被声明为const volatile virtual\n+ 能直接被类调用  \n 静态成员函数和普通函数更像，因为它没有this指针，也就不是这种类型：~ unsigned int(*) ();\n 所以更可以和类之外的元素沟通，比如回调函数\n \n ##### 虚拟成员函数\n + a 为了支持多态，需要在执行期间能判断到底调用哪个函数？即pz->z()这个函数，pz为基类指针，而能调用子类函数\n + b 基类指针或引用参考到的（指向的）子类，，子类中的重写父类的函数，在调用时并不知道传入哪个this,即表现为调用哪个函数\n +  c　那么为了支持通过基类能调用它，通过子类也能调用该函数，则需要基类和子类共享某个东西，他能正确决议出要调用的函数\n \n+  带来：额外的空间，和c的兼容性\n##### 积极多态的概念：\n（１）被指出的对象真正被使用；（２）dynamic_cast  \n 那么哪些函数需要支持这样的特性－－－》由virtual标志来指出  \n 如何在执行期间调用真正的函数？－－－》ptr所指的对象真实类型＋函数的位置　真实类型放在vtable[0]\n\n+ 编译期间做的：  \n在每个对象中加入：一个字符串或数字来表示class　类型＋一个指针，指向表格vtable,它带有程序的virtual func执行期地址\n确定表格中的函数指针，执行期无法改变表格一个类对应一个表格，每个virtual func被指定一个固定的索引值\n+ 执行期间做的：\n 为vptr分配内存地址。它的值在编译期间确定，类似于x=3;  指向vtable\n调用函数时激活　。编译器已经为其转换语义为xxx->vptr[n](this).. \n+ 注意，当一个子类继承基类时，vptr继承过来，当子类改写virtual函数时，则改变表中的指针指向子类的；当子类添加一个新的virtual func时，则在表中加一个slot\n+ 唯一在执行期间才知道的：slot(n)到底指向哪个函数实体\n 细想一下：  \n      derived de; //编译期间，符号表确认要分配的对象类型,执行期间分配内存和调用构造函数等，构造函数中会初始化vptr,    \n      base *p=&de;//编译期间，类似于int x=3;,执行期间分\n      配内存给x,并将３给x,确定p所指的真正对象，从而才能取得vptr,到调用到最终的函数\n      p->xx();//xx为virtual (*p->vptr[1])(p)\n     \n##### some question     \n //关于执行期和编译期确定的东西，有些困惑，为啥编译器不能在p->xx()的时候指定调用子类的xx()?\n //在编译器扫描代码的时候，知道定义了一个derived类型的变量，知道，定义了一个base指针，并指向的变量类型为derived,后面调用时也能\n 确定函数名，为啥不能根据已存的这些信息。来得到哦。这时p指向的是derive类型的。所以调用derived的函数？\n 不过也是，编译器从做词汇扫描，到语义扫描，出符号表，到语法检查，语义规则等\n \n \n##### 多重继承下面的virtual func\n 考虑以下例子：\n ```cpp\n class base1{\n    public :\n     int a;\n 　　　virtual int a(){return a;}\n    virtual base1* clone() const;\n   }\n class base2{\n  public:\n    int b;\n    virtual int b(){return b;\n    virtual base2* clone() const;\n    }\n class derive:public base1,public base2\n    int c;\n    virtual int c(){return c;}\n    virtual derive* clone() const;\n    }\n    ```\n 对于和derived有相同起点的base1不用考虑太多，关键是base2,;有三个问题要解决：\n```\n  　(1)virtual destructor (记得之前是逐层调用）\n 　（２）被继承下来的b()\n    (3）一组clone函数 \n  （a)   做base2 *pbase2=new derive;\n  　　　　＆＆＆编译期间确定：＆＆＆\n   =>  derived *tmp=new derive;\n   　　　base2 *pbase2=tmp?tmp+sizeof(base1):0;```\n      \n 为了使pbase2能访问到　b 即pbase２->b, 多重继承下使用 base *p=de;时，注意此时需要调整，让p指向的是de中的base对应部分\n+ 当通过delete pbase2时，此时需要删除完整的对象，所以pbase２指针需要调整到指出完整对象的起始点  \n  他也要通过上述a类似的加法，以及调用virtual destructor函数  \n```cpp \n   如base2 *pbase2=new derive;  \n  delete pbase2;//invoke derive class's destructor (virtual )```\n  \n 　首先这个调用要通过vptr,其次，传入的this指针需要调整\n  ＆＆＆执行期间确定＆＆＆\n+ 注意：然而，这种offset加法无法在编译期间直接设定。pbase2所指的真正对象只有在执行期间才能确定  \n//如何调整；早期的想法是：将vtable中的slot改为一个slot放置函数指针faddr和this的offset  \n //则：（*pbase2->vptr[1])(pbase2);  \n //改为　（*pbase2->vptr[1].faddr)(pbase2+pbase2-  >vptr[1].offset);但是连带处罚了其他形式virtual func调用，\n  \n + 那如何处理？  \n + [１]方法１：thunk\n  　　　～：this+=sizeof(base1)\n          Derived::~Derived(this);//只有汇编才有效率\n   如何使能？在virtual table slot继续内含一个简单的指针，slot中的地址可以指向一个virtual func或者一个thunk(若需要调整this)\n  其实多重继承来讲，每个继承的基类，都需要一个virtual table;,这样派生类就会维护多个基类的vtable\n  + 1)经由derived或第一个base class)调用，不需要调整this\n  + 2)经由>=2的base class 调用，同一种函数在virtual table中可能需要多笔对应的slot\n        base1 *pbase1 =new derived;\n        base2 *pbase2=new derived;\n        delete pbase1//不需要调整this,virtual table slot放置正真的destructor地址\n        \n        delete pbase2//需要调整this ,放置thunk\n        vptr和vtable命名也会被特殊化\n        参考图在书中，这里不放\n+ [２]方法２　：  \n   因为动态链接器的原因，使得符号链接变得缓慢\n   为了调整执行期链接器的效率，sun编译器将多个vtable 连锁为一个，指向次要表格的指针可以由主要表格加offset\n　  其他类似。\n例子：\n```cpp\n　　　　　　　base2 *ptr =new derived;\n       delete ptr;//此时调用derived::~deirved,故ptr需要被调整，若为virtual，需要更多\n       \n       derived *pder=new derived;\n       pder->b();//注意b没有被改写，所以需要调整pder指向base2 subobj\n       \n       base2 *pb1=new derived;\n       base2 *pb2=pb1->clone()//注意是调用derived:clone,所以调用后返回值要改变器指向base2 subobj\n       \n       当函数被认为足够小　，sun编译器会采用某种算法优化，split。。，否则不会，具体待了解。\n       所以virtual func的通常大小为８行```\n+ [３]IBM:  \n函数若支持多重进入点，将不必有许多thunk;将thunk操作放在virtual func中，里面判断是否需要调整this指针\n     \n     \n##### 虚拟继承下的virtual func\n这种情况相当复杂了。需要探索上述的这些问题：point2d.point3d的对象不再相符，即使只继承一个，即单一虚拟继承，也需要调整this指针\n```cpp\nclass point2d{\n  public:\n  point2d()\n  virtual ~point2d()\n  virtual void mumble()\n  virutal  float z()\n  protected:\n  float _x,_y;\n  } \n  class point3d:public virtual point2d{\n    public:\n    point3d()\n    ~point3d\n    protected:\n    float _z;\n    }```\n    可以尝试下写出例子比较point2d和point3d指针看指向是否相同\n    当virtual base class中包含virtual func和nonstatic member时，各个厂商实现不同，复杂，作者不建议这么做\n    \n    －－－－－－－－－－－－－－－－－－－\n#### 函数的效能：\n  这部分可以通过函数的调用方式感性的了解，或者根据不同的编译器。测试对比几种调用的时间，以及是否已经开启优化等\n  （如编译器将被视为不变的表达式提到循环之外）\n  （通过消除局部对象的使用可以消除对constructor的调用）\n  \n#### 指向memeber　func的指针：\n  取一个nonstatic member func的地址，若为nonvirtual 则为其在内存中的真正地址。\n  但需要this参数。　\n  指向member func的指针：double (Point::*pmf)();类似\n  定义：double (point::*coord)() =&point::x;\n       赋值:coord=&point::y\n       调用：（origin.*coord)()/(ptr->*coord)()\n       转换为：(coord)(&origin)/(coord)(ptr)\n       \n##### 指向virtual memeber func指针\n  在g++中\n  ```cpp\n  #include<iostream>\n#include<stdio.h>\nusing namespace std;\nclass Base1 {\n\t\tpublic:\n\t\t\t\tvirtual float getp() { return mp;}\n\t\t\t\tvoid setp(float mmp){mp=mmp;}\n\t\t\t\tvirtual int test(){return 3;}\n\t\t\t\tvirtual int test1(){return 4;}\n\t\tprivate:\n\t\t\t\tfloat mp;\n}; \nint main()\n{  \n\t\tfloat (Base1::*pmf)()=&Base1::getp;\n\t\tBase1 *ptr=new Base1;\n\t\tptr->setp(3.2);\n\t\tcout<<ptr->getp()<<endl;//3.2\n\t\tcout<<(ptr->*pmf)()<<endl;//3.2　　会被内部转换：（*ptr->vptr[(int)pmf])(ptr)\n\t\tprintf(\"%p\\n\",&Base1::getp);//1　索引值\n\t\tprintf(\"%p\\n\",&Base1::setp);//40xxx真实地址\n\t\tprintf(\"%p\\n\",&Base1::test);// 9，为什么是９不清楚\n\t\tprintf(\"%p\\n\",&Base1::test1);//11\n\t\t\n\t\treturn  0;\n}```\n　　所以，对于虚拟函数也是可以通过函数指针来访问的，只不过得到的地址是索引值，但不影响访问\n或者对以下\n```cpp\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\nclass Base1 {\n\t\tpublic:\n\t\t\t\tvirtual float getp() { return mp;}\n\t\t\t\tvoid setp(float mmp){mp=mmp;}\n\t\t\t        int test(){return 3;}\n\t\t\t\tvirtual int test1(){return 4;}\n\t\tprivate:\n\t\t\t\tfloat mp;\n}; \nint main()\n{  \n\t\tfloat (Base1::*pmf)()=&Base1::getp;\n\t\tBase1 *ptr=new Base1;\n\t\tptr->setp(3.2);\n\t\tcout<<ptr->getp()<<endl;\n\t\tcout<<(ptr->*pmf)()<<endl;\n\t\tprintf(\"%p\\n\",&Base1::getp);\n\t\tprintf(\"%p\\n\",&Base1::setp);\n\t\tprintf(\"%p\\n\",&Base1::test);\n\t\tprintf(\"%p\\n\",&Base1::test1);\n                  \n                int (Base1::*pmi)()=&Base1::test1;//or test　可以指向两种，编译器如何区分呢？cfront２　通过判断是索引（may <127)还是函数地址来区分\n                Base1 *ptr2=new Base1;\n                cout<<(ptr2->*pmi)()<<endl;\n                delete ptr;\n                delete ptr2;\n\t\t\n\t\treturn  0;\n}```\n##### 多重继承下指向member func指针\n为了让mem func point能支持多重继承和虚拟继承：\n噢这种情况很复杂了。你得知道它指向的是virtual 还是non virtual\n书中并没有探讨太多，野比较复杂，这里举一个例子，探索细节可以看编译器，gdb等结果：\n```cpp\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\nclass Base1 {\n\t\tpublic:\n\t\t\t\tvirtual float getp() { return mp;}\n\t\t\t\tvoid setp(float mmp){mp=mmp;}\n\t\t\t        int test(){return 3;}\n\t\t\t\tvirtual int test1(){return 4;}\n\t\tprivate:\n\t\t\t\tfloat mp;\n};\nclass Base2 {\n\t\tpublic:\n\t\t\t\tvirtual float get2p(){return m2p;}\n\t\t\t\tvirtual void set2p(float m2pp){m2p=m2pp;}\n\t\t\t\tint test22() {return 5;}\n\t\t\t\tvirtual int test21(){return 6;}\n\t\tprivate:\n\t\t\t\tfloat m2p;\n};\nclass Der:public Base1,public Base2{\n\t\tpublic:\n\t\t\t\tvirtual float get3p(){return m3p;}\n\t\tprivate:\n\t\t\t\tfloat m3p;\n\n};\nint main()\n{  \n\t\tfloat (Base1::*pmf)()=&Base1::getp;//这后面的调用就发挥想象把，想怎么尝试都行\n\t\tBase1 *ptr=new Der;\n\t\tptr->setp(3.2);\n\t\tcout<<ptr->getp()<<endl;\n\t\tcout<<(ptr->*pmf)()<<endl;\n\t\tprintf(\"%p\\n\",&Der::getp);\n\t\tprintf(\"%p\\n\",&Base1::setp);\n\t\tprintf(\"%p\\n\",&Base1::test);\n\t\tprintf(\"%p\\n\",&Base1::test1);\n                  \n                int (Base1::*pmi)()=&Base1::test1;//or test\n                Base1 *ptr2=new Base1;\n                cout<<(ptr2->*pmi)()<<endl;\n                delete ptr;\n                delete ptr2;\n\t\t\n\t\treturn  0;\n}```\n##### 效能\n##### inline func:\n首先得直到，内联函数实际上表现为什么？函数本质上被经过栈调用，而内联函数是直接　在主函数中铺开为表达式，所以调用内联函数　能提高效率，但是响应的\n源代码会变大，而且有参数的限制\n应用：在操作符函数中，指定set,get类函数，使得操作符函数能被写成普通的函数。　而set get 写成inline函数，会减少效率降低\ninline关键词只是请求，并不会所有都inline展开，编译器会做判断权衡\n具体看书，不是很细\n内联函数两个注意点：\n形式参数：inline扩展时，每一个形式参数会被对应的实际参数代替：\n```cpp\n　　　　　　　　inline int min (int i,int j){\n                   return i<j?i:j;\n                   }\n         三个调用：\n         inline int bar() {\n            int minval;\n            int val1=1024;\n            int val2=2048;\n            minval=min(val1,val2); 参数直接替换val1<val2?val1:val2;\n            minval=min(1024,2048);替换后直接使用常量：1024\n            minval=min(fool(),bar()+1) 引发参数副作用，需要导入一个临时对象，以避免重复求值：\n            　　　　     int t1,t2; minval=(t1=foo()),(t2=bar()+1),t1<t2?...)\n           \n           \n            return minval}```\n 局部变量:在内联函数中加入局部变量，会导致因为维护局部变量带来的成本；  \n 内联函数在替代c宏，是比较安全的；但是若宏中参数有副作用的话，如上，会导致大的扩展码以维护局部变量或者生成临时的变量\n            \n","source":"_posts/cpp-funcmember-memory.md","raw":"---\ntitle: cpp_funcmember_memory\ndate: 2018-06-09 16:21:29\ntags: cpp_class\ncategories: c&cpp\n---\n### c++ function语意学\nsomething:  \n恩，这部分记录自己对c++中的函数特殊性的理解，本想深入函数本质，之前接触过，记得在linux内核剖析那本书讲的很好。\n 可以参考；<!--more-->\n \n + 实现类的成员函数和类之间的关联，即通过对象能调用成员函数。这种实现，可以是以下几种方式：\n 1）struct+函数指针：结构体中，一个成员函数对应一个指针，增加空间 如何操作成员？\n 2）函数+this指针，普通函数，this指针一个，不添加额外多的空间，this 操作成员\n 。。。\n \n+ c++的类主要是将成员和函数封装起来。那么成员的封装就像struct一样，而函数呢？成员函数如何和类，对象联系起来？--this指针\n\n\n + c++中的成员函数和普通函数一样，只是多了个this指针，这个指针指向当前调用这个函数的对象，并以形参传入，这样，成员函数就可以使用对象成员了，通过\n this指针；\n \n+  这里也是根据深入探索c++模型中第四章，function语义学总结的：\n#### 引入这个问题：\n 通过对象和对象指针来调用成员函数的不同：  \n   Point3d obj;  \n   Point3d *p=&obj;  \n   两者效率有何不同？\n   \n   通过上面分析：当这个成员函数为普通的成员函数时，则直接调用函数，传入this指针，所以基本没有大的区别  \n #### 以下分为几种函数讨论：\n##### 非静态成员函数：\n   为了支持this指针等构成成员函数，c++做了如下步骤：  \n  +  a;改写函数原型：安插了一个this参数\n  +  b；对对象成员的操作，通过this\n  +  c;对成员函数写成外部函数，并将其名称进行mangling处理，成独一无二～类似：函数名___类名参数名 等等\n + 如何命名：成员函数和成员都会被名称特殊化处理：一般加上base class &derived class名\n      对重载函数而言如何区分：加上参数链表；\n      当extern C时，会压抑这种特殊命名化\n      具体编译器实现不同，可以通过汇编等。gdb等看\n   \n   \n+  鉴于此：看一个例子：  \n   当你需要构造一个（拷贝构造函数）或者改变一个类的成员： 伪代码：  \n  ```cpp\n  void normalize__Point(register const Point3d *const this,Point3d &_result)\n   {\n      _reuslt.Point3d::Point3d() //默认构造函数：\n      _result._x=this->__x/2;\n      ...\n      return ;\n   }\n   那么，以下这种方式：更好：\n   Point3d Point3d::normmalize() const{\n       return  Point3d(_x/2 ...)直接构建会更快） \n    =》转换为return Point3d(this->_x/2,...)   \n  ```\n ##### virtual func\n 若normilaze是虚拟函数，则  \n ptr->normilaze()=》 （*ptr->vptr[1])(ptr);  \n 可以看到效率较低，所以当确认不用多态机制的时候，最好抑制它，直接使用：Point3d::xxx  这种方式调用函数\n 而若被写成内连函数会更优--原因待探索：\n \n \n##### 静态成员函数：\n 显然这种能被类直接调用的函数，没有this指针，从而也就无法用成员  \n 这种函数的出现，是因为一种需求：即不用每个成员函数都会使用成员，不一定需要this  \n 不用声明一个对象就可以调用函数，当非要对象不可，又不用成员时：   \n ```cpp\n ((Point3d*)0)->object_count() ;```\n 有了static后，就不用上述方式了  \n 所以static的特性完全来源它的原理：  \n+ 它不能直接存取non static 成员\n+ 它不能被声明为const volatile virtual\n+ 能直接被类调用  \n 静态成员函数和普通函数更像，因为它没有this指针，也就不是这种类型：~ unsigned int(*) ();\n 所以更可以和类之外的元素沟通，比如回调函数\n \n ##### 虚拟成员函数\n + a 为了支持多态，需要在执行期间能判断到底调用哪个函数？即pz->z()这个函数，pz为基类指针，而能调用子类函数\n + b 基类指针或引用参考到的（指向的）子类，，子类中的重写父类的函数，在调用时并不知道传入哪个this,即表现为调用哪个函数\n +  c　那么为了支持通过基类能调用它，通过子类也能调用该函数，则需要基类和子类共享某个东西，他能正确决议出要调用的函数\n \n+  带来：额外的空间，和c的兼容性\n##### 积极多态的概念：\n（１）被指出的对象真正被使用；（２）dynamic_cast  \n 那么哪些函数需要支持这样的特性－－－》由virtual标志来指出  \n 如何在执行期间调用真正的函数？－－－》ptr所指的对象真实类型＋函数的位置　真实类型放在vtable[0]\n\n+ 编译期间做的：  \n在每个对象中加入：一个字符串或数字来表示class　类型＋一个指针，指向表格vtable,它带有程序的virtual func执行期地址\n确定表格中的函数指针，执行期无法改变表格一个类对应一个表格，每个virtual func被指定一个固定的索引值\n+ 执行期间做的：\n 为vptr分配内存地址。它的值在编译期间确定，类似于x=3;  指向vtable\n调用函数时激活　。编译器已经为其转换语义为xxx->vptr[n](this).. \n+ 注意，当一个子类继承基类时，vptr继承过来，当子类改写virtual函数时，则改变表中的指针指向子类的；当子类添加一个新的virtual func时，则在表中加一个slot\n+ 唯一在执行期间才知道的：slot(n)到底指向哪个函数实体\n 细想一下：  \n      derived de; //编译期间，符号表确认要分配的对象类型,执行期间分配内存和调用构造函数等，构造函数中会初始化vptr,    \n      base *p=&de;//编译期间，类似于int x=3;,执行期间分\n      配内存给x,并将３给x,确定p所指的真正对象，从而才能取得vptr,到调用到最终的函数\n      p->xx();//xx为virtual (*p->vptr[1])(p)\n     \n##### some question     \n //关于执行期和编译期确定的东西，有些困惑，为啥编译器不能在p->xx()的时候指定调用子类的xx()?\n //在编译器扫描代码的时候，知道定义了一个derived类型的变量，知道，定义了一个base指针，并指向的变量类型为derived,后面调用时也能\n 确定函数名，为啥不能根据已存的这些信息。来得到哦。这时p指向的是derive类型的。所以调用derived的函数？\n 不过也是，编译器从做词汇扫描，到语义扫描，出符号表，到语法检查，语义规则等\n \n \n##### 多重继承下面的virtual func\n 考虑以下例子：\n ```cpp\n class base1{\n    public :\n     int a;\n 　　　virtual int a(){return a;}\n    virtual base1* clone() const;\n   }\n class base2{\n  public:\n    int b;\n    virtual int b(){return b;\n    virtual base2* clone() const;\n    }\n class derive:public base1,public base2\n    int c;\n    virtual int c(){return c;}\n    virtual derive* clone() const;\n    }\n    ```\n 对于和derived有相同起点的base1不用考虑太多，关键是base2,;有三个问题要解决：\n```\n  　(1)virtual destructor (记得之前是逐层调用）\n 　（２）被继承下来的b()\n    (3）一组clone函数 \n  （a)   做base2 *pbase2=new derive;\n  　　　　＆＆＆编译期间确定：＆＆＆\n   =>  derived *tmp=new derive;\n   　　　base2 *pbase2=tmp?tmp+sizeof(base1):0;```\n      \n 为了使pbase2能访问到　b 即pbase２->b, 多重继承下使用 base *p=de;时，注意此时需要调整，让p指向的是de中的base对应部分\n+ 当通过delete pbase2时，此时需要删除完整的对象，所以pbase２指针需要调整到指出完整对象的起始点  \n  他也要通过上述a类似的加法，以及调用virtual destructor函数  \n```cpp \n   如base2 *pbase2=new derive;  \n  delete pbase2;//invoke derive class's destructor (virtual )```\n  \n 　首先这个调用要通过vptr,其次，传入的this指针需要调整\n  ＆＆＆执行期间确定＆＆＆\n+ 注意：然而，这种offset加法无法在编译期间直接设定。pbase2所指的真正对象只有在执行期间才能确定  \n//如何调整；早期的想法是：将vtable中的slot改为一个slot放置函数指针faddr和this的offset  \n //则：（*pbase2->vptr[1])(pbase2);  \n //改为　（*pbase2->vptr[1].faddr)(pbase2+pbase2-  >vptr[1].offset);但是连带处罚了其他形式virtual func调用，\n  \n + 那如何处理？  \n + [１]方法１：thunk\n  　　　～：this+=sizeof(base1)\n          Derived::~Derived(this);//只有汇编才有效率\n   如何使能？在virtual table slot继续内含一个简单的指针，slot中的地址可以指向一个virtual func或者一个thunk(若需要调整this)\n  其实多重继承来讲，每个继承的基类，都需要一个virtual table;,这样派生类就会维护多个基类的vtable\n  + 1)经由derived或第一个base class)调用，不需要调整this\n  + 2)经由>=2的base class 调用，同一种函数在virtual table中可能需要多笔对应的slot\n        base1 *pbase1 =new derived;\n        base2 *pbase2=new derived;\n        delete pbase1//不需要调整this,virtual table slot放置正真的destructor地址\n        \n        delete pbase2//需要调整this ,放置thunk\n        vptr和vtable命名也会被特殊化\n        参考图在书中，这里不放\n+ [２]方法２　：  \n   因为动态链接器的原因，使得符号链接变得缓慢\n   为了调整执行期链接器的效率，sun编译器将多个vtable 连锁为一个，指向次要表格的指针可以由主要表格加offset\n　  其他类似。\n例子：\n```cpp\n　　　　　　　base2 *ptr =new derived;\n       delete ptr;//此时调用derived::~deirved,故ptr需要被调整，若为virtual，需要更多\n       \n       derived *pder=new derived;\n       pder->b();//注意b没有被改写，所以需要调整pder指向base2 subobj\n       \n       base2 *pb1=new derived;\n       base2 *pb2=pb1->clone()//注意是调用derived:clone,所以调用后返回值要改变器指向base2 subobj\n       \n       当函数被认为足够小　，sun编译器会采用某种算法优化，split。。，否则不会，具体待了解。\n       所以virtual func的通常大小为８行```\n+ [３]IBM:  \n函数若支持多重进入点，将不必有许多thunk;将thunk操作放在virtual func中，里面判断是否需要调整this指针\n     \n     \n##### 虚拟继承下的virtual func\n这种情况相当复杂了。需要探索上述的这些问题：point2d.point3d的对象不再相符，即使只继承一个，即单一虚拟继承，也需要调整this指针\n```cpp\nclass point2d{\n  public:\n  point2d()\n  virtual ~point2d()\n  virtual void mumble()\n  virutal  float z()\n  protected:\n  float _x,_y;\n  } \n  class point3d:public virtual point2d{\n    public:\n    point3d()\n    ~point3d\n    protected:\n    float _z;\n    }```\n    可以尝试下写出例子比较point2d和point3d指针看指向是否相同\n    当virtual base class中包含virtual func和nonstatic member时，各个厂商实现不同，复杂，作者不建议这么做\n    \n    －－－－－－－－－－－－－－－－－－－\n#### 函数的效能：\n  这部分可以通过函数的调用方式感性的了解，或者根据不同的编译器。测试对比几种调用的时间，以及是否已经开启优化等\n  （如编译器将被视为不变的表达式提到循环之外）\n  （通过消除局部对象的使用可以消除对constructor的调用）\n  \n#### 指向memeber　func的指针：\n  取一个nonstatic member func的地址，若为nonvirtual 则为其在内存中的真正地址。\n  但需要this参数。　\n  指向member func的指针：double (Point::*pmf)();类似\n  定义：double (point::*coord)() =&point::x;\n       赋值:coord=&point::y\n       调用：（origin.*coord)()/(ptr->*coord)()\n       转换为：(coord)(&origin)/(coord)(ptr)\n       \n##### 指向virtual memeber func指针\n  在g++中\n  ```cpp\n  #include<iostream>\n#include<stdio.h>\nusing namespace std;\nclass Base1 {\n\t\tpublic:\n\t\t\t\tvirtual float getp() { return mp;}\n\t\t\t\tvoid setp(float mmp){mp=mmp;}\n\t\t\t\tvirtual int test(){return 3;}\n\t\t\t\tvirtual int test1(){return 4;}\n\t\tprivate:\n\t\t\t\tfloat mp;\n}; \nint main()\n{  \n\t\tfloat (Base1::*pmf)()=&Base1::getp;\n\t\tBase1 *ptr=new Base1;\n\t\tptr->setp(3.2);\n\t\tcout<<ptr->getp()<<endl;//3.2\n\t\tcout<<(ptr->*pmf)()<<endl;//3.2　　会被内部转换：（*ptr->vptr[(int)pmf])(ptr)\n\t\tprintf(\"%p\\n\",&Base1::getp);//1　索引值\n\t\tprintf(\"%p\\n\",&Base1::setp);//40xxx真实地址\n\t\tprintf(\"%p\\n\",&Base1::test);// 9，为什么是９不清楚\n\t\tprintf(\"%p\\n\",&Base1::test1);//11\n\t\t\n\t\treturn  0;\n}```\n　　所以，对于虚拟函数也是可以通过函数指针来访问的，只不过得到的地址是索引值，但不影响访问\n或者对以下\n```cpp\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\nclass Base1 {\n\t\tpublic:\n\t\t\t\tvirtual float getp() { return mp;}\n\t\t\t\tvoid setp(float mmp){mp=mmp;}\n\t\t\t        int test(){return 3;}\n\t\t\t\tvirtual int test1(){return 4;}\n\t\tprivate:\n\t\t\t\tfloat mp;\n}; \nint main()\n{  \n\t\tfloat (Base1::*pmf)()=&Base1::getp;\n\t\tBase1 *ptr=new Base1;\n\t\tptr->setp(3.2);\n\t\tcout<<ptr->getp()<<endl;\n\t\tcout<<(ptr->*pmf)()<<endl;\n\t\tprintf(\"%p\\n\",&Base1::getp);\n\t\tprintf(\"%p\\n\",&Base1::setp);\n\t\tprintf(\"%p\\n\",&Base1::test);\n\t\tprintf(\"%p\\n\",&Base1::test1);\n                  \n                int (Base1::*pmi)()=&Base1::test1;//or test　可以指向两种，编译器如何区分呢？cfront２　通过判断是索引（may <127)还是函数地址来区分\n                Base1 *ptr2=new Base1;\n                cout<<(ptr2->*pmi)()<<endl;\n                delete ptr;\n                delete ptr2;\n\t\t\n\t\treturn  0;\n}```\n##### 多重继承下指向member func指针\n为了让mem func point能支持多重继承和虚拟继承：\n噢这种情况很复杂了。你得知道它指向的是virtual 还是non virtual\n书中并没有探讨太多，野比较复杂，这里举一个例子，探索细节可以看编译器，gdb等结果：\n```cpp\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\nclass Base1 {\n\t\tpublic:\n\t\t\t\tvirtual float getp() { return mp;}\n\t\t\t\tvoid setp(float mmp){mp=mmp;}\n\t\t\t        int test(){return 3;}\n\t\t\t\tvirtual int test1(){return 4;}\n\t\tprivate:\n\t\t\t\tfloat mp;\n};\nclass Base2 {\n\t\tpublic:\n\t\t\t\tvirtual float get2p(){return m2p;}\n\t\t\t\tvirtual void set2p(float m2pp){m2p=m2pp;}\n\t\t\t\tint test22() {return 5;}\n\t\t\t\tvirtual int test21(){return 6;}\n\t\tprivate:\n\t\t\t\tfloat m2p;\n};\nclass Der:public Base1,public Base2{\n\t\tpublic:\n\t\t\t\tvirtual float get3p(){return m3p;}\n\t\tprivate:\n\t\t\t\tfloat m3p;\n\n};\nint main()\n{  \n\t\tfloat (Base1::*pmf)()=&Base1::getp;//这后面的调用就发挥想象把，想怎么尝试都行\n\t\tBase1 *ptr=new Der;\n\t\tptr->setp(3.2);\n\t\tcout<<ptr->getp()<<endl;\n\t\tcout<<(ptr->*pmf)()<<endl;\n\t\tprintf(\"%p\\n\",&Der::getp);\n\t\tprintf(\"%p\\n\",&Base1::setp);\n\t\tprintf(\"%p\\n\",&Base1::test);\n\t\tprintf(\"%p\\n\",&Base1::test1);\n                  \n                int (Base1::*pmi)()=&Base1::test1;//or test\n                Base1 *ptr2=new Base1;\n                cout<<(ptr2->*pmi)()<<endl;\n                delete ptr;\n                delete ptr2;\n\t\t\n\t\treturn  0;\n}```\n##### 效能\n##### inline func:\n首先得直到，内联函数实际上表现为什么？函数本质上被经过栈调用，而内联函数是直接　在主函数中铺开为表达式，所以调用内联函数　能提高效率，但是响应的\n源代码会变大，而且有参数的限制\n应用：在操作符函数中，指定set,get类函数，使得操作符函数能被写成普通的函数。　而set get 写成inline函数，会减少效率降低\ninline关键词只是请求，并不会所有都inline展开，编译器会做判断权衡\n具体看书，不是很细\n内联函数两个注意点：\n形式参数：inline扩展时，每一个形式参数会被对应的实际参数代替：\n```cpp\n　　　　　　　　inline int min (int i,int j){\n                   return i<j?i:j;\n                   }\n         三个调用：\n         inline int bar() {\n            int minval;\n            int val1=1024;\n            int val2=2048;\n            minval=min(val1,val2); 参数直接替换val1<val2?val1:val2;\n            minval=min(1024,2048);替换后直接使用常量：1024\n            minval=min(fool(),bar()+1) 引发参数副作用，需要导入一个临时对象，以避免重复求值：\n            　　　　     int t1,t2; minval=(t1=foo()),(t2=bar()+1),t1<t2?...)\n           \n           \n            return minval}```\n 局部变量:在内联函数中加入局部变量，会导致因为维护局部变量带来的成本；  \n 内联函数在替代c宏，是比较安全的；但是若宏中参数有副作用的话，如上，会导致大的扩展码以维护局部变量或者生成临时的变量\n            \n","slug":"cpp-funcmember-memory","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7o2001a2ujxjm7zp917","content":"<h3 id=\"c-function语意学\"><a href=\"#c-function语意学\" class=\"headerlink\" title=\"c++ function语意学\"></a>c++ function语意学</h3><p>something:<br>恩，这部分记录自己对c++中的函数特殊性的理解，本想深入函数本质，之前接触过，记得在linux内核剖析那本书讲的很好。<br> 可以参考；<a id=\"more\"></a></p>\n<ul>\n<li>实现类的成员函数和类之间的关联，即通过对象能调用成员函数。这种实现，可以是以下几种方式：<br>1）struct+函数指针：结构体中，一个成员函数对应一个指针，增加空间 如何操作成员？<br>2）函数+this指针，普通函数，this指针一个，不添加额外多的空间，this 操作成员<br>。。。</li>\n</ul>\n<ul>\n<li>c++的类主要是将成员和函数封装起来。那么成员的封装就像struct一样，而函数呢？成员函数如何和类，对象联系起来？–this指针</li>\n</ul>\n<ul>\n<li>c++中的成员函数和普通函数一样，只是多了个this指针，这个指针指向当前调用这个函数的对象，并以形参传入，这样，成员函数就可以使用对象成员了，通过<br>this指针；</li>\n</ul>\n<ul>\n<li><p>这里也是根据深入探索c++模型中第四章，function语义学总结的：</p>\n<h4 id=\"引入这个问题：\"><a href=\"#引入这个问题：\" class=\"headerlink\" title=\"引入这个问题：\"></a>引入这个问题：</h4><p>通过对象和对象指针来调用成员函数的不同：<br>Point3d obj;<br>Point3d *p=&obj;<br>两者效率有何不同？</p>\n<p>通过上面分析：当这个成员函数为普通的成员函数时，则直接调用函数，传入this指针，所以基本没有大的区别  </p>\n<h4 id=\"以下分为几种函数讨论：\"><a href=\"#以下分为几种函数讨论：\" class=\"headerlink\" title=\"以下分为几种函数讨论：\"></a>以下分为几种函数讨论：</h4><h5 id=\"非静态成员函数：\"><a href=\"#非静态成员函数：\" class=\"headerlink\" title=\"非静态成员函数：\"></a>非静态成员函数：</h5><p>为了支持this指针等构成成员函数，c++做了如下步骤：  </p>\n<ul>\n<li>a;改写函数原型：安插了一个this参数</li>\n<li>b；对对象成员的操作，通过this</li>\n<li>c;对成员函数写成外部函数，并将其名称进行mangling处理，成独一无二～类似：函数名___类名参数名 等等</li>\n<li>如何命名：成员函数和成员都会被名称特殊化处理：一般加上base class &amp;derived class名<br> 对重载函数而言如何区分：加上参数链表；<br> 当extern C时，会压抑这种特殊命名化<br> 具体编译器实现不同，可以通过汇编等。gdb等看</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>鉴于此：看一个例子：<br>当你需要构造一个（拷贝构造函数）或者改变一个类的成员： 伪代码：  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">normalize__Point</span><span class=\"params\">(<span class=\"keyword\">register</span> <span class=\"keyword\">const</span> Point3d *<span class=\"keyword\">const</span> <span class=\"keyword\">this</span>,Point3d &amp;_result)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">    _reuslt.Point3d::Point3d() <span class=\"comment\">//默认构造函数：</span></span><br><span class=\"line\">    _result._x=<span class=\"keyword\">this</span>-&gt;__x/<span class=\"number\">2</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> 那么，以下这种方式：更好：</span><br><span class=\"line\"> Point3d Point3d::normmalize() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span>  Point3d(_x/<span class=\"number\">2</span> ...)直接构建会更快） </span><br><span class=\"line\">  =》转换为<span class=\"keyword\">return</span> Point3d(<span class=\"keyword\">this</span>-&gt;_x/<span class=\"number\">2</span>,...)</span><br></pre></td></tr></table></figure>\n<h5 id=\"virtual-func\"><a href=\"#virtual-func\" class=\"headerlink\" title=\"virtual func\"></a>virtual func</h5><p>若normilaze是虚拟函数，则<br>ptr-&gt;normilaze()=》 （*ptr-&gt;vptr[1])(ptr);<br>可以看到效率较低，所以当确认不用多态机制的时候，最好抑制它，直接使用：Point3d::xxx  这种方式调用函数<br>而若被写成内连函数会更优–原因待探索：</p>\n</li>\n</ul>\n<h5 id=\"静态成员函数：\"><a href=\"#静态成员函数：\" class=\"headerlink\" title=\"静态成员函数：\"></a>静态成员函数：</h5><p> 显然这种能被类直接调用的函数，没有this指针，从而也就无法用成员<br> 这种函数的出现，是因为一种需求：即不用每个成员函数都会使用成员，不一定需要this<br> 不用声明一个对象就可以调用函数，当非要对象不可，又不用成员时：<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((Point3d*)<span class=\"number\">0</span>)-&gt;object_count() ;</span><br></pre></td></tr></table></figure></p>\n<p> 有了static后，就不用上述方式了<br> 所以static的特性完全来源它的原理：  </p>\n<ul>\n<li>它不能直接存取non static 成员</li>\n<li>它不能被声明为const volatile virtual</li>\n<li><p>能直接被类调用<br>静态成员函数和普通函数更像，因为它没有this指针，也就不是这种类型：~ unsigned int(*) ();<br>所以更可以和类之外的元素沟通，比如回调函数</p>\n<h5 id=\"虚拟成员函数\"><a href=\"#虚拟成员函数\" class=\"headerlink\" title=\"虚拟成员函数\"></a>虚拟成员函数</h5><ul>\n<li>a 为了支持多态，需要在执行期间能判断到底调用哪个函数？即pz-&gt;z()这个函数，pz为基类指针，而能调用子类函数</li>\n<li>b 基类指针或引用参考到的（指向的）子类，，子类中的重写父类的函数，在调用时并不知道传入哪个this,即表现为调用哪个函数</li>\n<li>c　那么为了支持通过基类能调用它，通过子类也能调用该函数，则需要基类和子类共享某个东西，他能正确决议出要调用的函数</li>\n</ul>\n</li>\n<li><p>带来：额外的空间，和c的兼容性</p>\n<h5 id=\"积极多态的概念：\"><a href=\"#积极多态的概念：\" class=\"headerlink\" title=\"积极多态的概念：\"></a>积极多态的概念：</h5><p>（１）被指出的对象真正被使用；（２）dynamic_cast<br>那么哪些函数需要支持这样的特性－－－》由virtual标志来指出<br>如何在执行期间调用真正的函数？－－－》ptr所指的对象真实类型＋函数的位置　真实类型放在vtable[0]</p>\n</li>\n<li><p>编译期间做的：<br>在每个对象中加入：一个字符串或数字来表示class　类型＋一个指针，指向表格vtable,它带有程序的virtual func执行期地址<br>确定表格中的函数指针，执行期无法改变表格一个类对应一个表格，每个virtual func被指定一个固定的索引值</p>\n</li>\n<li>执行期间做的：<br>为vptr分配内存地址。它的值在编译期间确定，类似于x=3;  指向vtable<br>调用函数时激活　。编译器已经为其转换语义为xxx-&gt;vptr<a href=\"this\">n</a>.. </li>\n<li>注意，当一个子类继承基类时，vptr继承过来，当子类改写virtual函数时，则改变表中的指针指向子类的；当子类添加一个新的virtual func时，则在表中加一个slot</li>\n<li>唯一在执行期间才知道的：slot(n)到底指向哪个函数实体<br>细想一下：  <pre><code>derived de; //编译期间，符号表确认要分配的对象类型,执行期间分配内存和调用构造函数等，构造函数中会初始化vptr,    \nbase *p=&amp;de;//编译期间，类似于int x=3;,执行期间分\n配内存给x,并将３给x,确定p所指的真正对象，从而才能取得vptr,到调用到最终的函数\np-&gt;xx();//xx为virtual (*p-&gt;vptr[1])(p)\n</code></pre></li>\n</ul>\n<h5 id=\"some-question\"><a href=\"#some-question\" class=\"headerlink\" title=\"some question\"></a>some question</h5><p> //关于执行期和编译期确定的东西，有些困惑，为啥编译器不能在p-&gt;xx()的时候指定调用子类的xx()?<br> //在编译器扫描代码的时候，知道定义了一个derived类型的变量，知道，定义了一个base指针，并指向的变量类型为derived,后面调用时也能<br> 确定函数名，为啥不能根据已存的这些信息。来得到哦。这时p指向的是derive类型的。所以调用derived的函数？<br> 不过也是，编译器从做词汇扫描，到语义扫描，出符号表，到语法检查，语义规则等</p>\n<h5 id=\"多重继承下面的virtual-func\"><a href=\"#多重继承下面的virtual-func\" class=\"headerlink\" title=\"多重继承下面的virtual func\"></a>多重继承下面的virtual func</h5><p> 考虑以下例子：<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">base1</span>&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> :</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">　　　<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">a</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> a;&#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> base1* <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">base2</span>&#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">b</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> b;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> base2* <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">derive</span>:</span><span class=\"keyword\">public</span> base1,<span class=\"keyword\">public</span> base2</span><br><span class=\"line\">   <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> c;&#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> derive* <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p> 对于和derived有相同起点的base1不用考虑太多，关键是base2,;有三个问题要解决：<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　(<span class=\"number\">1</span>)<span class=\"keyword\">virtual</span> <span class=\"function\"><span class=\"keyword\">destructor</span> <span class=\"params\">(记得之前是逐层调用）</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> 　（２）被继承下来的b()</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"params\">(3）一组clone函数 </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">（a)</span>   做<span class=\"title\">base2</span> *<span class=\"title\">pbase2</span>=<span class=\"title\">new</span> <span class=\"title\">derive</span>;</span></span><br><span class=\"line\">　　　　＆＆＆编译期间确定：＆＆＆</span><br><span class=\"line\"> =&gt;  derived *tmp=new derive;</span><br><span class=\"line\"> 　　　base2 *pbase2=tmp?tmp+sizeof(base1):<span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure></p>\n<p> 为了使pbase2能访问到　b 即pbase２-&gt;b, 多重继承下使用 base *p=de;时，注意此时需要调整，让p指向的是de中的base对应部分</p>\n<ul>\n<li>当通过delete pbase2时，此时需要删除完整的对象，所以pbase２指针需要调整到指出完整对象的起始点<br>他也要通过上述a类似的加法，以及调用virtual destructor函数  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 如base2 *pbase2=<span class=\"keyword\">new</span> derive;  </span><br><span class=\"line\"><span class=\"keyword\">delete</span> pbase2;<span class=\"comment\">//invoke derive class's destructor (virtual )</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p> 　首先这个调用要通过vptr,其次，传入的this指针需要调整<br>  ＆＆＆执行期间确定＆＆＆</p>\n<ul>\n<li><p>注意：然而，这种offset加法无法在编译期间直接设定。pbase2所指的真正对象只有在执行期间才能确定<br>//如何调整；早期的想法是：将vtable中的slot改为一个slot放置函数指针faddr和this的offset<br>//则：（<em>pbase2-&gt;vptr[1])(pbase2);<br>//改为　（</em>pbase2-&gt;vptr[1].faddr)(pbase2+pbase2-  &gt;vptr[1].offset);但是连带处罚了其他形式virtual func调用，</p>\n<ul>\n<li>那如何处理？  </li>\n<li>[１]方法１：thunk<br>　　　～：this+=sizeof(base1)<pre><code>Derived::~Derived(this);//只有汇编才有效率\n</code></pre>如何使能？在virtual table slot继续内含一个简单的指针，slot中的地址可以指向一个virtual func或者一个thunk(若需要调整this)<br>其实多重继承来讲，每个继承的基类，都需要一个virtual table;,这样派生类就会维护多个基类的vtable</li>\n<li>1)经由derived或第一个base class)调用，不需要调整this</li>\n<li><p>2)经由&gt;=2的base class 调用，同一种函数在virtual table中可能需要多笔对应的slot</p>\n<pre><code>base1 *pbase1 =new derived;\nbase2 *pbase2=new derived;\ndelete pbase1//不需要调整this,virtual table slot放置正真的destructor地址\n\ndelete pbase2//需要调整this ,放置thunk\nvptr和vtable命名也会被特殊化\n参考图在书中，这里不放\n</code></pre></li>\n</ul>\n</li>\n<li><p>[２]方法２　：<br> 因为动态链接器的原因，使得符号链接变得缓慢<br> 为了调整执行期链接器的效率，sun编译器将多个vtable 连锁为一个，指向次要表格的指针可以由主要表格加offset<br>　  其他类似。<br>例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　　　　　base2 *ptr =<span class=\"keyword\">new</span> derived;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> ptr;<span class=\"comment\">//此时调用derived::~deirved,故ptr需要被调整，若为virtual，需要更多</span></span><br><span class=\"line\"></span><br><span class=\"line\">derived *pder=<span class=\"keyword\">new</span> derived;</span><br><span class=\"line\">pder-&gt;b();<span class=\"comment\">//注意b没有被改写，所以需要调整pder指向base2 subobj</span></span><br><span class=\"line\"></span><br><span class=\"line\">base2 *pb1=<span class=\"keyword\">new</span> derived;</span><br><span class=\"line\">base2 *pb2=pb1-&gt;clone()<span class=\"comment\">//注意是调用derived:clone,所以调用后返回值要改变器指向base2 subobj</span></span><br><span class=\"line\"></span><br><span class=\"line\">当函数被认为足够小　，sun编译器会采用某种算法优化，split。。，否则不会，具体待了解。</span><br><span class=\"line\">所以<span class=\"keyword\">virtual</span> func的通常大小为８行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>[３]IBM:<br>函数若支持多重进入点，将不必有许多thunk;将thunk操作放在virtual func中，里面判断是否需要调整this指针</p>\n</li>\n</ul>\n<h5 id=\"虚拟继承下的virtual-func\"><a href=\"#虚拟继承下的virtual-func\" class=\"headerlink\" title=\"虚拟继承下的virtual func\"></a>虚拟继承下的virtual func</h5><p>这种情况相当复杂了。需要探索上述的这些问题：point2d.point3d的对象不再相符，即使只继承一个，即单一虚拟继承，也需要调整this指针<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">point2d</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  point2d()</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> ~point2d()</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">mumble</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  virutal  <span class=\"keyword\">float</span> <span class=\"title\">z</span><span class=\"params\">()</span></span></span><br><span class=\"line\">  protected:</span><br><span class=\"line\">  <span class=\"keyword\">float</span> _x,_y;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">point3d</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> point2d&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    point3d()</span><br><span class=\"line\">    ~point3d</span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">float</span> _z;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<pre><code>可以尝试下写出例子比较point2d和point3d指针看指向是否相同\n当virtual base class中包含virtual func和nonstatic member时，各个厂商实现不同，复杂，作者不建议这么做\n\n－－－－－－－－－－－－－－－－－－－\n</code></pre><h4 id=\"函数的效能：\"><a href=\"#函数的效能：\" class=\"headerlink\" title=\"函数的效能：\"></a>函数的效能：</h4><p>  这部分可以通过函数的调用方式感性的了解，或者根据不同的编译器。测试对比几种调用的时间，以及是否已经开启优化等<br>  （如编译器将被视为不变的表达式提到循环之外）<br>  （通过消除局部对象的使用可以消除对constructor的调用）</p>\n<h4 id=\"指向memeber-func的指针：\"><a href=\"#指向memeber-func的指针：\" class=\"headerlink\" title=\"指向memeber　func的指针：\"></a>指向memeber　func的指针：</h4><p>  取一个nonstatic member func的地址，若为nonvirtual 则为其在内存中的真正地址。<br>  但需要this参数。　<br>  指向member func的指针：double (Point::<em>pmf)();类似<br>  定义：double (point::</em>coord)() =&amp;point::x;<br>       赋值:coord=&amp;point::y<br>       调用：（origin.<em>coord)()/(ptr-&gt;</em>coord)()<br>       转换为：(coord)(&amp;origin)/(coord)(ptr)</p>\n<h5 id=\"指向virtual-memeber-func指针\"><a href=\"#指向virtual-memeber-func指针\" class=\"headerlink\" title=\"指向virtual memeber func指针\"></a>指向virtual memeber func指针</h5><p>  在g++中<br>  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base1</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">getp</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> mp;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setp</span><span class=\"params\">(<span class=\"keyword\">float</span> mmp)</span></span>&#123;mp=mmp;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">3</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">4</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> mp;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> (Base1::*pmf)()=&amp;Base1::getp;</span><br><span class=\"line\">\t\tBase1 *ptr=<span class=\"keyword\">new</span> Base1;</span><br><span class=\"line\">\t\tptr-&gt;setp(<span class=\"number\">3.2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;ptr-&gt;getp()&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//3.2</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//3.2　　会被内部转换：（*ptr-&gt;vptr[(int)pmf])(ptr)</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::getp);<span class=\"comment\">//1　索引值</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::setp);<span class=\"comment\">//40xxx真实地址</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::test);<span class=\"comment\">// 9，为什么是９不清楚</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::test1);<span class=\"comment\">//11</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>  <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>　　所以，对于虚拟函数也是可以通过函数指针来访问的，只不过得到的地址是索引值，但不影响访问<br>或者对以下<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base1</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">getp</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> mp;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setp</span><span class=\"params\">(<span class=\"keyword\">float</span> mmp)</span></span>&#123;mp=mmp;&#125;</span><br><span class=\"line\">\t\t\t        <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">3</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">4</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> mp;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> (Base1::*pmf)()=&amp;Base1::getp;</span><br><span class=\"line\">\t\tBase1 *ptr=<span class=\"keyword\">new</span> Base1;</span><br><span class=\"line\">\t\tptr-&gt;setp(<span class=\"number\">3.2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;ptr-&gt;getp()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::getp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::setp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::test);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::test1);</span><br><span class=\"line\">                  </span><br><span class=\"line\">                <span class=\"keyword\">int</span> (Base1::*pmi)()=&amp;Base1::test1;<span class=\"comment\">//or test　可以指向两种，编译器如何区分呢？cfront２　通过判断是索引（may &lt;127)还是函数地址来区分</span></span><br><span class=\"line\">                Base1 *ptr2=<span class=\"keyword\">new</span> Base1;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;(ptr2-&gt;*pmi)()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> ptr;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> ptr2;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>  <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"多重继承下指向member-func指针\"><a href=\"#多重继承下指向member-func指针\" class=\"headerlink\" title=\"多重继承下指向member func指针\"></a>多重继承下指向member func指针</h5><p>为了让mem func point能支持多重继承和虚拟继承：<br>噢这种情况很复杂了。你得知道它指向的是virtual 还是non virtual<br>书中并没有探讨太多，野比较复杂，这里举一个例子，探索细节可以看编译器，gdb等结果：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base1</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">getp</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> mp;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setp</span><span class=\"params\">(<span class=\"keyword\">float</span> mmp)</span></span>&#123;mp=mmp;&#125;</span><br><span class=\"line\">\t\t\t        <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">3</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">4</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> mp;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base2</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">get2p</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> m2p;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">set2p</span><span class=\"params\">(<span class=\"keyword\">float</span> m2pp)</span></span>&#123;m2p=m2pp;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test22</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">5</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">test21</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">6</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> m2p;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Der</span>:</span><span class=\"keyword\">public</span> Base1,<span class=\"keyword\">public</span> Base2&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">get3p</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> m3p;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> m3p;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> (Base1::*pmf)()=&amp;Base1::getp;<span class=\"comment\">//这后面的调用就发挥想象把，想怎么尝试都行</span></span><br><span class=\"line\">\t\tBase1 *ptr=<span class=\"keyword\">new</span> Der;</span><br><span class=\"line\">\t\tptr-&gt;setp(<span class=\"number\">3.2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;ptr-&gt;getp()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Der::getp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::setp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::test);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::test1);</span><br><span class=\"line\">                  </span><br><span class=\"line\">                <span class=\"keyword\">int</span> (Base1::*pmi)()=&amp;Base1::test1;<span class=\"comment\">//or test</span></span><br><span class=\"line\">                Base1 *ptr2=<span class=\"keyword\">new</span> Base1;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;(ptr2-&gt;*pmi)()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> ptr;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> ptr2;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>  <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"效能\"><a href=\"#效能\" class=\"headerlink\" title=\"效能\"></a>效能</h5><h5 id=\"inline-func\"><a href=\"#inline-func\" class=\"headerlink\" title=\"inline func:\"></a>inline func:</h5><p>首先得直到，内联函数实际上表现为什么？函数本质上被经过栈调用，而内联函数是直接　在主函数中铺开为表达式，所以调用内联函数　能提高效率，但是响应的<br>源代码会变大，而且有参数的限制<br>应用：在操作符函数中，指定set,get类函数，使得操作符函数能被写成普通的函数。　而set get 写成inline函数，会减少效率降低<br>inline关键词只是请求，并不会所有都inline展开，编译器会做判断权衡<br>具体看书，不是很细<br>内联函数两个注意点：<br>形式参数：inline扩展时，每一个形式参数会被对应的实际参数代替：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　　　　　　<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span> <span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> i&lt;j?i:j;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">三个调用：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> minval;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> val1=<span class=\"number\">1024</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> val2=<span class=\"number\">2048</span>;</span><br><span class=\"line\">   minval=min(val1,val2); 参数直接替换val1&lt;val2?val1:val2;</span><br><span class=\"line\">   minval=min(<span class=\"number\">1024</span>,<span class=\"number\">2048</span>);替换后直接使用常量：<span class=\"number\">1024</span></span><br><span class=\"line\">   minval=min(fool(),bar()+<span class=\"number\">1</span>) 引发参数副作用，需要导入一个临时对象，以避免重复求值：</span><br><span class=\"line\">   　　　　     <span class=\"keyword\">int</span> t1,t2; minval=(t1=foo()),(t2=bar()+<span class=\"number\">1</span>),t1&lt;t2?...)</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"keyword\">return</span> minval&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 局部变量:在内联函数中加入局部变量，会导致因为维护局部变量带来的成本；<br> 内联函数在替代c宏，是比较安全的；但是若宏中参数有副作用的话，如上，会导致大的扩展码以维护局部变量或者生成临时的变量</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"c-function语意学\"><a href=\"#c-function语意学\" class=\"headerlink\" title=\"c++ function语意学\"></a>c++ function语意学</h3><p>something:<br>恩，这部分记录自己对c++中的函数特殊性的理解，本想深入函数本质，之前接触过，记得在linux内核剖析那本书讲的很好。<br> 可以参考；","more":"</p>\n<ul>\n<li>实现类的成员函数和类之间的关联，即通过对象能调用成员函数。这种实现，可以是以下几种方式：<br>1）struct+函数指针：结构体中，一个成员函数对应一个指针，增加空间 如何操作成员？<br>2）函数+this指针，普通函数，this指针一个，不添加额外多的空间，this 操作成员<br>。。。</li>\n</ul>\n<ul>\n<li>c++的类主要是将成员和函数封装起来。那么成员的封装就像struct一样，而函数呢？成员函数如何和类，对象联系起来？–this指针</li>\n</ul>\n<ul>\n<li>c++中的成员函数和普通函数一样，只是多了个this指针，这个指针指向当前调用这个函数的对象，并以形参传入，这样，成员函数就可以使用对象成员了，通过<br>this指针；</li>\n</ul>\n<ul>\n<li><p>这里也是根据深入探索c++模型中第四章，function语义学总结的：</p>\n<h4 id=\"引入这个问题：\"><a href=\"#引入这个问题：\" class=\"headerlink\" title=\"引入这个问题：\"></a>引入这个问题：</h4><p>通过对象和对象指针来调用成员函数的不同：<br>Point3d obj;<br>Point3d *p=&obj;<br>两者效率有何不同？</p>\n<p>通过上面分析：当这个成员函数为普通的成员函数时，则直接调用函数，传入this指针，所以基本没有大的区别  </p>\n<h4 id=\"以下分为几种函数讨论：\"><a href=\"#以下分为几种函数讨论：\" class=\"headerlink\" title=\"以下分为几种函数讨论：\"></a>以下分为几种函数讨论：</h4><h5 id=\"非静态成员函数：\"><a href=\"#非静态成员函数：\" class=\"headerlink\" title=\"非静态成员函数：\"></a>非静态成员函数：</h5><p>为了支持this指针等构成成员函数，c++做了如下步骤：  </p>\n<ul>\n<li>a;改写函数原型：安插了一个this参数</li>\n<li>b；对对象成员的操作，通过this</li>\n<li>c;对成员函数写成外部函数，并将其名称进行mangling处理，成独一无二～类似：函数名___类名参数名 等等</li>\n<li>如何命名：成员函数和成员都会被名称特殊化处理：一般加上base class &amp;derived class名<br> 对重载函数而言如何区分：加上参数链表；<br> 当extern C时，会压抑这种特殊命名化<br> 具体编译器实现不同，可以通过汇编等。gdb等看</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>鉴于此：看一个例子：<br>当你需要构造一个（拷贝构造函数）或者改变一个类的成员： 伪代码：  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">normalize__Point</span><span class=\"params\">(<span class=\"keyword\">register</span> <span class=\"keyword\">const</span> Point3d *<span class=\"keyword\">const</span> <span class=\"keyword\">this</span>,Point3d &amp;_result)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">    _reuslt.Point3d::Point3d() <span class=\"comment\">//默认构造函数：</span></span><br><span class=\"line\">    _result._x=<span class=\"keyword\">this</span>-&gt;__x/<span class=\"number\">2</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> 那么，以下这种方式：更好：</span><br><span class=\"line\"> Point3d Point3d::normmalize() <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span>  Point3d(_x/<span class=\"number\">2</span> ...)直接构建会更快） </span><br><span class=\"line\">  =》转换为<span class=\"keyword\">return</span> Point3d(<span class=\"keyword\">this</span>-&gt;_x/<span class=\"number\">2</span>,...)</span><br></pre></td></tr></table></figure>\n<h5 id=\"virtual-func\"><a href=\"#virtual-func\" class=\"headerlink\" title=\"virtual func\"></a>virtual func</h5><p>若normilaze是虚拟函数，则<br>ptr-&gt;normilaze()=》 （*ptr-&gt;vptr[1])(ptr);<br>可以看到效率较低，所以当确认不用多态机制的时候，最好抑制它，直接使用：Point3d::xxx  这种方式调用函数<br>而若被写成内连函数会更优–原因待探索：</p>\n</li>\n</ul>\n<h5 id=\"静态成员函数：\"><a href=\"#静态成员函数：\" class=\"headerlink\" title=\"静态成员函数：\"></a>静态成员函数：</h5><p> 显然这种能被类直接调用的函数，没有this指针，从而也就无法用成员<br> 这种函数的出现，是因为一种需求：即不用每个成员函数都会使用成员，不一定需要this<br> 不用声明一个对象就可以调用函数，当非要对象不可，又不用成员时：<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((Point3d*)<span class=\"number\">0</span>)-&gt;object_count() ;</span><br></pre></td></tr></table></figure></p>\n<p> 有了static后，就不用上述方式了<br> 所以static的特性完全来源它的原理：  </p>\n<ul>\n<li>它不能直接存取non static 成员</li>\n<li>它不能被声明为const volatile virtual</li>\n<li><p>能直接被类调用<br>静态成员函数和普通函数更像，因为它没有this指针，也就不是这种类型：~ unsigned int(*) ();<br>所以更可以和类之外的元素沟通，比如回调函数</p>\n<h5 id=\"虚拟成员函数\"><a href=\"#虚拟成员函数\" class=\"headerlink\" title=\"虚拟成员函数\"></a>虚拟成员函数</h5><ul>\n<li>a 为了支持多态，需要在执行期间能判断到底调用哪个函数？即pz-&gt;z()这个函数，pz为基类指针，而能调用子类函数</li>\n<li>b 基类指针或引用参考到的（指向的）子类，，子类中的重写父类的函数，在调用时并不知道传入哪个this,即表现为调用哪个函数</li>\n<li>c　那么为了支持通过基类能调用它，通过子类也能调用该函数，则需要基类和子类共享某个东西，他能正确决议出要调用的函数</li>\n</ul>\n</li>\n<li><p>带来：额外的空间，和c的兼容性</p>\n<h5 id=\"积极多态的概念：\"><a href=\"#积极多态的概念：\" class=\"headerlink\" title=\"积极多态的概念：\"></a>积极多态的概念：</h5><p>（１）被指出的对象真正被使用；（２）dynamic_cast<br>那么哪些函数需要支持这样的特性－－－》由virtual标志来指出<br>如何在执行期间调用真正的函数？－－－》ptr所指的对象真实类型＋函数的位置　真实类型放在vtable[0]</p>\n</li>\n<li><p>编译期间做的：<br>在每个对象中加入：一个字符串或数字来表示class　类型＋一个指针，指向表格vtable,它带有程序的virtual func执行期地址<br>确定表格中的函数指针，执行期无法改变表格一个类对应一个表格，每个virtual func被指定一个固定的索引值</p>\n</li>\n<li>执行期间做的：<br>为vptr分配内存地址。它的值在编译期间确定，类似于x=3;  指向vtable<br>调用函数时激活　。编译器已经为其转换语义为xxx-&gt;vptr<a href=\"this\">n</a>.. </li>\n<li>注意，当一个子类继承基类时，vptr继承过来，当子类改写virtual函数时，则改变表中的指针指向子类的；当子类添加一个新的virtual func时，则在表中加一个slot</li>\n<li>唯一在执行期间才知道的：slot(n)到底指向哪个函数实体<br>细想一下：  <pre><code>derived de; //编译期间，符号表确认要分配的对象类型,执行期间分配内存和调用构造函数等，构造函数中会初始化vptr,    \nbase *p=&amp;de;//编译期间，类似于int x=3;,执行期间分\n配内存给x,并将３给x,确定p所指的真正对象，从而才能取得vptr,到调用到最终的函数\np-&gt;xx();//xx为virtual (*p-&gt;vptr[1])(p)\n</code></pre></li>\n</ul>\n<h5 id=\"some-question\"><a href=\"#some-question\" class=\"headerlink\" title=\"some question\"></a>some question</h5><p> //关于执行期和编译期确定的东西，有些困惑，为啥编译器不能在p-&gt;xx()的时候指定调用子类的xx()?<br> //在编译器扫描代码的时候，知道定义了一个derived类型的变量，知道，定义了一个base指针，并指向的变量类型为derived,后面调用时也能<br> 确定函数名，为啥不能根据已存的这些信息。来得到哦。这时p指向的是derive类型的。所以调用derived的函数？<br> 不过也是，编译器从做词汇扫描，到语义扫描，出符号表，到语法检查，语义规则等</p>\n<h5 id=\"多重继承下面的virtual-func\"><a href=\"#多重继承下面的virtual-func\" class=\"headerlink\" title=\"多重继承下面的virtual func\"></a>多重继承下面的virtual func</h5><p> 考虑以下例子：<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">base1</span>&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> :</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">　　　<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">a</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> a;&#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> base1* <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">base2</span>&#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">b</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> b;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> base2* <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">derive</span>:</span><span class=\"keyword\">public</span> base1,<span class=\"keyword\">public</span> base2</span><br><span class=\"line\">   <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> c;&#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> derive* <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p> 对于和derived有相同起点的base1不用考虑太多，关键是base2,;有三个问题要解决：<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　(<span class=\"number\">1</span>)<span class=\"keyword\">virtual</span> <span class=\"function\"><span class=\"keyword\">destructor</span> <span class=\"params\">(记得之前是逐层调用）</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> 　（２）被继承下来的b()</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"params\">(3）一组clone函数 </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">（a)</span>   做<span class=\"title\">base2</span> *<span class=\"title\">pbase2</span>=<span class=\"title\">new</span> <span class=\"title\">derive</span>;</span></span><br><span class=\"line\">　　　　＆＆＆编译期间确定：＆＆＆</span><br><span class=\"line\"> =&gt;  derived *tmp=new derive;</span><br><span class=\"line\"> 　　　base2 *pbase2=tmp?tmp+sizeof(base1):<span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure></p>\n<p> 为了使pbase2能访问到　b 即pbase２-&gt;b, 多重继承下使用 base *p=de;时，注意此时需要调整，让p指向的是de中的base对应部分</p>\n<ul>\n<li>当通过delete pbase2时，此时需要删除完整的对象，所以pbase２指针需要调整到指出完整对象的起始点<br>他也要通过上述a类似的加法，以及调用virtual destructor函数  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 如base2 *pbase2=<span class=\"keyword\">new</span> derive;  </span><br><span class=\"line\"><span class=\"keyword\">delete</span> pbase2;<span class=\"comment\">//invoke derive class's destructor (virtual )</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p> 　首先这个调用要通过vptr,其次，传入的this指针需要调整<br>  ＆＆＆执行期间确定＆＆＆</p>\n<ul>\n<li><p>注意：然而，这种offset加法无法在编译期间直接设定。pbase2所指的真正对象只有在执行期间才能确定<br>//如何调整；早期的想法是：将vtable中的slot改为一个slot放置函数指针faddr和this的offset<br>//则：（<em>pbase2-&gt;vptr[1])(pbase2);<br>//改为　（</em>pbase2-&gt;vptr[1].faddr)(pbase2+pbase2-  &gt;vptr[1].offset);但是连带处罚了其他形式virtual func调用，</p>\n<ul>\n<li>那如何处理？  </li>\n<li>[１]方法１：thunk<br>　　　～：this+=sizeof(base1)<pre><code>Derived::~Derived(this);//只有汇编才有效率\n</code></pre>如何使能？在virtual table slot继续内含一个简单的指针，slot中的地址可以指向一个virtual func或者一个thunk(若需要调整this)<br>其实多重继承来讲，每个继承的基类，都需要一个virtual table;,这样派生类就会维护多个基类的vtable</li>\n<li>1)经由derived或第一个base class)调用，不需要调整this</li>\n<li><p>2)经由&gt;=2的base class 调用，同一种函数在virtual table中可能需要多笔对应的slot</p>\n<pre><code>base1 *pbase1 =new derived;\nbase2 *pbase2=new derived;\ndelete pbase1//不需要调整this,virtual table slot放置正真的destructor地址\n\ndelete pbase2//需要调整this ,放置thunk\nvptr和vtable命名也会被特殊化\n参考图在书中，这里不放\n</code></pre></li>\n</ul>\n</li>\n<li><p>[２]方法２　：<br> 因为动态链接器的原因，使得符号链接变得缓慢<br> 为了调整执行期链接器的效率，sun编译器将多个vtable 连锁为一个，指向次要表格的指针可以由主要表格加offset<br>　  其他类似。<br>例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　　　　　base2 *ptr =<span class=\"keyword\">new</span> derived;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> ptr;<span class=\"comment\">//此时调用derived::~deirved,故ptr需要被调整，若为virtual，需要更多</span></span><br><span class=\"line\"></span><br><span class=\"line\">derived *pder=<span class=\"keyword\">new</span> derived;</span><br><span class=\"line\">pder-&gt;b();<span class=\"comment\">//注意b没有被改写，所以需要调整pder指向base2 subobj</span></span><br><span class=\"line\"></span><br><span class=\"line\">base2 *pb1=<span class=\"keyword\">new</span> derived;</span><br><span class=\"line\">base2 *pb2=pb1-&gt;clone()<span class=\"comment\">//注意是调用derived:clone,所以调用后返回值要改变器指向base2 subobj</span></span><br><span class=\"line\"></span><br><span class=\"line\">当函数被认为足够小　，sun编译器会采用某种算法优化，split。。，否则不会，具体待了解。</span><br><span class=\"line\">所以<span class=\"keyword\">virtual</span> func的通常大小为８行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>[３]IBM:<br>函数若支持多重进入点，将不必有许多thunk;将thunk操作放在virtual func中，里面判断是否需要调整this指针</p>\n</li>\n</ul>\n<h5 id=\"虚拟继承下的virtual-func\"><a href=\"#虚拟继承下的virtual-func\" class=\"headerlink\" title=\"虚拟继承下的virtual func\"></a>虚拟继承下的virtual func</h5><p>这种情况相当复杂了。需要探索上述的这些问题：point2d.point3d的对象不再相符，即使只继承一个，即单一虚拟继承，也需要调整this指针<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">point2d</span>&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  point2d()</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> ~point2d()</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">mumble</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  virutal  <span class=\"keyword\">float</span> <span class=\"title\">z</span><span class=\"params\">()</span></span></span><br><span class=\"line\">  protected:</span><br><span class=\"line\">  <span class=\"keyword\">float</span> _x,_y;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">point3d</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> point2d&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    point3d()</span><br><span class=\"line\">    ~point3d</span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">float</span> _z;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<pre><code>可以尝试下写出例子比较point2d和point3d指针看指向是否相同\n当virtual base class中包含virtual func和nonstatic member时，各个厂商实现不同，复杂，作者不建议这么做\n\n－－－－－－－－－－－－－－－－－－－\n</code></pre><h4 id=\"函数的效能：\"><a href=\"#函数的效能：\" class=\"headerlink\" title=\"函数的效能：\"></a>函数的效能：</h4><p>  这部分可以通过函数的调用方式感性的了解，或者根据不同的编译器。测试对比几种调用的时间，以及是否已经开启优化等<br>  （如编译器将被视为不变的表达式提到循环之外）<br>  （通过消除局部对象的使用可以消除对constructor的调用）</p>\n<h4 id=\"指向memeber-func的指针：\"><a href=\"#指向memeber-func的指针：\" class=\"headerlink\" title=\"指向memeber　func的指针：\"></a>指向memeber　func的指针：</h4><p>  取一个nonstatic member func的地址，若为nonvirtual 则为其在内存中的真正地址。<br>  但需要this参数。　<br>  指向member func的指针：double (Point::<em>pmf)();类似<br>  定义：double (point::</em>coord)() =&amp;point::x;<br>       赋值:coord=&amp;point::y<br>       调用：（origin.<em>coord)()/(ptr-&gt;</em>coord)()<br>       转换为：(coord)(&amp;origin)/(coord)(ptr)</p>\n<h5 id=\"指向virtual-memeber-func指针\"><a href=\"#指向virtual-memeber-func指针\" class=\"headerlink\" title=\"指向virtual memeber func指针\"></a>指向virtual memeber func指针</h5><p>  在g++中<br>  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base1</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">getp</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> mp;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setp</span><span class=\"params\">(<span class=\"keyword\">float</span> mmp)</span></span>&#123;mp=mmp;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">3</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">4</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> mp;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> (Base1::*pmf)()=&amp;Base1::getp;</span><br><span class=\"line\">\t\tBase1 *ptr=<span class=\"keyword\">new</span> Base1;</span><br><span class=\"line\">\t\tptr-&gt;setp(<span class=\"number\">3.2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;ptr-&gt;getp()&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//3.2</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//3.2　　会被内部转换：（*ptr-&gt;vptr[(int)pmf])(ptr)</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::getp);<span class=\"comment\">//1　索引值</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::setp);<span class=\"comment\">//40xxx真实地址</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::test);<span class=\"comment\">// 9，为什么是９不清楚</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::test1);<span class=\"comment\">//11</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>  <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>　　所以，对于虚拟函数也是可以通过函数指针来访问的，只不过得到的地址是索引值，但不影响访问<br>或者对以下<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base1</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">getp</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> mp;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setp</span><span class=\"params\">(<span class=\"keyword\">float</span> mmp)</span></span>&#123;mp=mmp;&#125;</span><br><span class=\"line\">\t\t\t        <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">3</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">4</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> mp;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> (Base1::*pmf)()=&amp;Base1::getp;</span><br><span class=\"line\">\t\tBase1 *ptr=<span class=\"keyword\">new</span> Base1;</span><br><span class=\"line\">\t\tptr-&gt;setp(<span class=\"number\">3.2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;ptr-&gt;getp()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::getp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::setp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::test);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::test1);</span><br><span class=\"line\">                  </span><br><span class=\"line\">                <span class=\"keyword\">int</span> (Base1::*pmi)()=&amp;Base1::test1;<span class=\"comment\">//or test　可以指向两种，编译器如何区分呢？cfront２　通过判断是索引（may &lt;127)还是函数地址来区分</span></span><br><span class=\"line\">                Base1 *ptr2=<span class=\"keyword\">new</span> Base1;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;(ptr2-&gt;*pmi)()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> ptr;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> ptr2;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>  <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"多重继承下指向member-func指针\"><a href=\"#多重继承下指向member-func指针\" class=\"headerlink\" title=\"多重继承下指向member func指针\"></a>多重继承下指向member func指针</h5><p>为了让mem func point能支持多重继承和虚拟继承：<br>噢这种情况很复杂了。你得知道它指向的是virtual 还是non virtual<br>书中并没有探讨太多，野比较复杂，这里举一个例子，探索细节可以看编译器，gdb等结果：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base1</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">getp</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> mp;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setp</span><span class=\"params\">(<span class=\"keyword\">float</span> mmp)</span></span>&#123;mp=mmp;&#125;</span><br><span class=\"line\">\t\t\t        <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">3</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">4</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> mp;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base2</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">get2p</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> m2p;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">set2p</span><span class=\"params\">(<span class=\"keyword\">float</span> m2pp)</span></span>&#123;m2p=m2pp;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test22</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">5</span>;&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">test21</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">6</span>;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> m2p;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Der</span>:</span><span class=\"keyword\">public</span> Base1,<span class=\"keyword\">public</span> Base2&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">float</span> <span class=\"title\">get3p</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> m3p;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">float</span> m3p;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> (Base1::*pmf)()=&amp;Base1::getp;<span class=\"comment\">//这后面的调用就发挥想象把，想怎么尝试都行</span></span><br><span class=\"line\">\t\tBase1 *ptr=<span class=\"keyword\">new</span> Der;</span><br><span class=\"line\">\t\tptr-&gt;setp(<span class=\"number\">3.2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;ptr-&gt;getp()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Der::getp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::setp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::test);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%p\\n\"</span>,&amp;Base1::test1);</span><br><span class=\"line\">                  </span><br><span class=\"line\">                <span class=\"keyword\">int</span> (Base1::*pmi)()=&amp;Base1::test1;<span class=\"comment\">//or test</span></span><br><span class=\"line\">                Base1 *ptr2=<span class=\"keyword\">new</span> Base1;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;(ptr2-&gt;*pmi)()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> ptr;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> ptr2;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>  <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"效能\"><a href=\"#效能\" class=\"headerlink\" title=\"效能\"></a>效能</h5><h5 id=\"inline-func\"><a href=\"#inline-func\" class=\"headerlink\" title=\"inline func:\"></a>inline func:</h5><p>首先得直到，内联函数实际上表现为什么？函数本质上被经过栈调用，而内联函数是直接　在主函数中铺开为表达式，所以调用内联函数　能提高效率，但是响应的<br>源代码会变大，而且有参数的限制<br>应用：在操作符函数中，指定set,get类函数，使得操作符函数能被写成普通的函数。　而set get 写成inline函数，会减少效率降低<br>inline关键词只是请求，并不会所有都inline展开，编译器会做判断权衡<br>具体看书，不是很细<br>内联函数两个注意点：<br>形式参数：inline扩展时，每一个形式参数会被对应的实际参数代替：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　　　　　　<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">min</span> <span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> i&lt;j?i:j;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">三个调用：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> minval;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> val1=<span class=\"number\">1024</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> val2=<span class=\"number\">2048</span>;</span><br><span class=\"line\">   minval=min(val1,val2); 参数直接替换val1&lt;val2?val1:val2;</span><br><span class=\"line\">   minval=min(<span class=\"number\">1024</span>,<span class=\"number\">2048</span>);替换后直接使用常量：<span class=\"number\">1024</span></span><br><span class=\"line\">   minval=min(fool(),bar()+<span class=\"number\">1</span>) 引发参数副作用，需要导入一个临时对象，以避免重复求值：</span><br><span class=\"line\">   　　　　     <span class=\"keyword\">int</span> t1,t2; minval=(t1=foo()),(t2=bar()+<span class=\"number\">1</span>),t1&lt;t2?...)</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"keyword\">return</span> minval&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 局部变量:在内联函数中加入局部变量，会导致因为维护局部变量带来的成本；<br> 内联函数在替代c宏，是比较安全的；但是若宏中参数有副作用的话，如上，会导致大的扩展码以维护局部变量或者生成临时的变量</p>"},{"title":"cpp_polymorphism","date":"2018-06-09T06:06:57.000Z","_content":"### 多态：\n\n#### 为什么需要多态？\n引入几个点：  \n　　继承的机制中，基类的指针和引用能指向派生类，（派生类对象中的基类成员是在内存前面的，即指向派生类对象的指针指向的是第一个基类的第一个成员）  \n+ 指针的值本质上是内存地址，也就是说指向不同变量(int char.)，对象的指针本身的值都是地址的value)\n+ 指针的类型限定了指针的操作内存范围和取值的方式，如通过int指针取值的时候，取到４byte,通过char指针取值时取得1byte;）<!--more-->\n+ 因此，基类指针限定了，即使它指向派生类，它也只能操作基类自身的成员和方法；就像char形指针指向int形，取得的只是一部分）\n\n```cpp\n　　　#include<iostream>\n  3 using namespace std;\n  4 int main()\n  5 {\n  6     int in=2;\n  7     char *pc=(char*)&in;\n  8     cout<<*pc<<endl;//乱码\n  9     return 0;\n 10 }\n```\n\n所以基类指针可以指向子类，但是只能调用基类的函数，即使子类复写了父类的函数\n```cpp\nclass Base\n{\npublic:\n    const char* getName() { return \"Base\"; }\n};\n \nclass Derived: public Base\n{\npublic:\n    const char* getName() { return \"Derived\"; }\n};\n \nint main()\n{\n    Derived derived;\n    Base &rBase = derived;\n    std::cout << \"rBase is a \" << rBase.getName() << '\\n';\n}\n```\nThis example prints the result:\n\nrBase is a Base\n\n/＝》简化：如何让下面的例子得到想要的结果？  \n```cpp\nAnimal *animals[] = { &fred, &garbo, &misty, &pooky, &truffle, &zeke };\n    for (int iii=0; iii < 6; iii++)\n        std::cout << animals[iii]->getName() << \" says \" << animals[iii]->speak() << '\\n';\n ```\n+ 如何让父类指针指向子类对象，可以调用子类函数呢？\n      －－－多态\n+ 调用的子类函数要满足:  \n  A derived function is considered a match if it has the same signature (name, parameter types, and whether it is const) and return type as the base version of the function. Such functions are called overrides.\n\n#### 如何使用－－－例子\n```cpp\nclass Base\n{\npublic:\n    virtual const char* getName() { return \"Base\"; } // note addition of virtual keyword\n};\n \nclass Derived: public Base\n{\npublic:\n    virtual const char* getName() { return \"Derived\"; }\n};\n \nint main()\n{\n    Derived derived;\n    Base &rBase = derived;\n    std::cout << \"rBase is a \" << rBase.getName() << '\\n';\n \n    return 0;\n}\n```\nThis example prints the result:\n\nrBase is a Derived\n－－－－－－－－－－－－－－－－－－－－－－－  \n再盗一个例子：\n```cpp\n#include <string>\nclass Animal\n{\nprotected:\n    std::string m_name;\n \n    // We're making this constructor protected because\n    // we don't want people creating Animal objects directly,\n    // but we still want derived classes to be able to use it.\n    Animal(std::string name)\n        : m_name(name)\n    {\n    }\n \npublic:\n    std::string getName() { return m_name; }\n    virtual const char* speak() { return \"???\"; }\n};\n \nclass Cat: public Animal\n{\npublic:\n    Cat(std::string name)\n        : Animal(name)\n    {\n    }\n \n    virtual const char* speak() { return \"Meow\"; }\n};\n \nclass Dog: public Animal\n{\npublic:\n    Dog(std::string name)\n        : Animal(name)\n    {\n    }\n \n    virtual const char* speak() { return \"Woof\"; }\n};\n \nvoid report(Animal &animal)\n{\n    std::cout << animal.getName() << \" says \" << animal.speak() << '\\n';\n}\n \nint main()\n{\n    Cat cat(\"Fred\");\n    Dog dog(\"Garbo\");\n \n    report(cat);\n    report(dog);\n}\n```\n#### 注意多态的方式：\n调用基类指针指向子类，函数时，会调用到继承琏最底端，且该最低端的子类有该virtual函数的，否则只调用到最下且复写了该函数的。如下例子：\n```cpp\n  1 #include<iostream>\n  2 using namespace std;\n  3 class A\n  4 {\n  5         public:\n  6                     virtual const char* getName() { return \"A\"; }\n  7 };\n  8 \n  9 class B: public A\n 10 {\n 11         public:\n 12                     virtual const char* getName() { return \"B\"; }\n 13 };\n 14 \n 15 class C: public B\n 16 {\n 17         public:\n 18                     virtual const char* getName() { return \"C\"; }\n                        //or const char * getName(){..} and default virtual\n 19 };\n 20 \n 21 class D: public C\n 22 {\n 23         public:\n 24                    // virtual const char* getName() { return \"D\"; }\n 25 };\n 26 \n 27 int main()\n 28 {\n 29             D d;\n 30             A &rBase = d;\n 31             std::cout << \"rBase is a \" << rBase.getName() << '\\n';\n 32 \n 33             return 0;\n 34 }```\n     输出c\n     \n#### 注意点：\n+ virtual关键字是否都需要写？：  \nOnly the most base class function needs to be tagged as virtual for all of the derived \nfunctions to work virtually. However, having the keyword virtual on the derived functions\n does not hurt, and it serves as a useful reminder that the function is a virtual function \n rather than a normal one.\n \n \n+ 不能在构造函数和西沟函数中调用它，因为此时子类对象还没有被构造\n \n+ c++11引入override和final来防止避免不匹配的复写和阻止继承：  \n １）override:  \n 出现错误的例子:\n ```cpp\n class A\n{\npublic:\n\tvirtual const char* getName1(int x) { return \"A\"; }\n\tvirtual const char* getName2(int x) { return \"A\"; }\n};\nclass B : public A\n{\npublic:\n\tvirtual const char* getName1(short int x) { return \"B\"; } // note: parameter is a short int\n\tvirtual const char* getName2(int x) const { return \"B\"; } // note: function is const\n}; \nint main()\n{\n\tB b;\n\tA &rBase = b;\n\tstd::cout << rBase.getName1(1) << '\\n';\n\tstd::cout << rBase.getName2(2) << '\\n';\n \n\treturn 0;\n}\n ```\n \n 由于参数返回值不匹配，所以编译器认为不是复写，结果：\n A\nA\n```cpp\n加入override:\nclass A\n{\npublic:\n\tvirtual const char* getName1(int x) { return \"A\"; }\n\tvirtual const char* getName2(int x) { return \"A\"; }\n\tvirtual const char* getName3(int x) { return \"A\"; }\n};\nclass B : public A\n{\npublic:\n\tvirtual const char* getName1(short int x) override { return \"B\"; } // compile error, function is not an override\n\tvirtual const char* getName2(int x) const override { return \"B\"; } // compile error, function is not an override\n\tvirtual const char* getName3(int x) override { return \"B\"; } // okay, function is an override of A::getName3(int) \n};\nint main()\n{\n\treturn 0;\n} \nRule: Apply the override specifier to every intended override function you write.\n ```\n \n+ final:\n ```cpp\n 加了final的函数无法被复写：\n class A\n{\npublic:\n\tvirtual const char* getName() { return \"A\"; }\n};\nclass B : public A\n{\npublic:\n\t// note use of final specifier on following line -- that makes this function no longer overridable\n\tvirtual const char* getName() override final { return \"B\"; } // okay, overrides A::getName()\n}; \nclass C : public B\n{\npublic:\n\tvirtual const char* getName() override { return \"C\"; } // compile error: overrides B::getName(), which is final\n};\n 加了final的类不能被继承：\n class A\n{\npublic:\n\tvirtual const char* getName() { return \"A\"; }\n};\nclass B final : public A // note use of final specifier here\n{\npublic:\n\tvirtual const char* getName() override { return \"B\"; }\n};\nclass C : public B // compile error: cannot inherit from final class\n{\npublic:\n\tvirtual const char* getName() override { return \"C\"; }\n};\n ````\n \n+ 对匹配返回值的一个“例外”：covariant return types:\n ```cpp\n class Base\n{\npublic:\n    // This version of getThis() returns a pointer to a Base class\n    virtual Base* getThis() { return this; }\n};\nclass Derived: public Base\n{\n    // Normally override functions have to return objects of the same type as the base function\n    // However, because Derived is derived from Base, it's okay to return Derived* instead of Base*\n    virtual Derived* getThis() { return this; }\n};```\n\n注意当base=&derive;\n     base.getThis()----取得的任然是base\n \n \n#### 当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：\n```cpp\n#include <iostream>\nint main()\n{\n    Derived derived;\n    Base &base = derived;\n    // Calls Base::GetName() instead of the virtualized Derived::GetName()\n    std::cout << base.Base::getName() << std::endl;\n}　　\n```\n\n \n### 虚析构函数　：\n#### 为什么需要虚析构函数：\n 当基类指针指向派生类时，当析构后，只会调用基类的析构函数：\n```cpp\n#include <iostream>\nclass Base\n{\npublic:\n    ~Base() // note: not virtual\n    {\n        std::cout << \"Calling ~Base()\" << std::endl;\n    }\n};\nclass Derived: public Base\n{\nprivate:\n    int* m_array;\npublic:\n    Derived(int length)\n    {\n        m_array = new int[length];\n    }\n    ~Derived() // note: not virtual\n    {\n        std::cout << \"Calling ~Derived()\" << std::endl;\n        delete[] m_array;\n    }\n};\nint main()\n{\n    Derived *derived = new Derived(5);\n    Base *base = derived ;\n    delete base;\n    return 0;\n}```\n 只输出Calling ~Base()\n + 所以为了调用派生类的析构函数，需要定义为虚析构函数：\n ```cpp\n #include <iostream>\nclass Base\n{\npublic:\n    virtual ~Base() // note: virtual\n    {\n        std::cout << \"Calling ~Base()\" << std::endl;\n    }\n};\nclass Derived: public Base\n{\nprivate:\n    int* m_array;\npublic:\n    Derived(int length)\n    {\n        m_array = new int[length];\n    }\n    virtual ~Derived() // note: virtual\n    {\n        std::cout << \"Calling ~Derived()\" << std::endl;\n        delete[] m_array;\n    }\n};\nint main()\n{\n    Derived *derived = new Derived(5);\n    Base *base = derived;\n    delete base;\n \n    return 0;\n}\nNow this program produces the following result:\nCalling ~Derived()\nCalling ~Base()\nRule: Whenever you are dealing with inheritance, you should make any explicit destructors virtual. ```\n \n \n \n \n ### 虚表：\n #### Early binding（静态绑定） and late binding（动态绑定）\n 前者指的是直接在代码里调用函数，通过函数名，即编译期间就可以直到函数的地址的（偏移，非真实的内存地址）  \n\"\" Early binding (also called static binding) means the compiler (or linker) is able to directly associate the identifier name (such as a function or variable name) with a machine address. \n Remember that all functions have a unique address. So when the compiler (or linker) encounters a function call, \n  it replaces the function call with a machine language instruction that tells the CPU to jump to the address of the function.\"\"\n ```cpp\n #include <iostream>\nint add(int x, int y)\n{\n    return x + y;\n}\nint subtract(int x, int y)\n{\n    return x - y;\n}\nint multiply(int x, int y)\n{\n    return x * y;\n}\nint main()\n{\n    int x;\n    std::cout << \"Enter a number: \";\n    std::cin >> x;\n    int y;\n    std::cout << \"Enter another number: \";\n    std::cin >> y;\n    int op;\n    do\n    {\n        std::cout << \"Enter an operation (0=add, 1=subtract, 2=multiply): \";\n        std::cin >> op;\n    } while (op < 0 || op > 2);\n    int result = 0;\n    switch (op)\n    {\n        // call the target function directly using early binding\n        case 0: result = add(x, y); break;\n        case 1: result = subtract(x, y); break;\n        case 2: result = multiply(x, y); break;\n    }\n    std::cout << \"The answer is: \" << result << std::endl;\n    return 0;\n}```\n 后者指的是通过函数指针等方式，即在编译期间无法确定调用什么函数，需要通过指针来访问函数（函数指针），效率比前者低\n in some programs, it is not possible to know which function will be called until runtime (when the program is run). \n This is known as late binding (or dynamic binding). In C++, one way to get late binding is to use function pointers. \n ```cpp\n #include <iostream>\nint add(int x, int y)\n{\n    return x + y;\n}\nint main()\n{\n    // Create a function pointer and make it point to the Add function\n    int (*pFcn)(int, int) = add;\n    std::cout << pFcn(5, 3) << std::endl; // add 5 + 3\n    return 0;\n}\n ```\n#### 虚表\n 为什么虚函数能成立－－基类指针指向派生类能调用派生类的函数：  \n 实际上，在定义了虚函数的基类中维护了一个虚指针：它指向一张表，表中包含各个虚函数指针；在这个继承琏中的每一个类有自己的一张虚表，这张表由编译器在编译期间生成, 虚指针在包含虚函数的类的对象被创建时自动创建\n```cpp\nclass Base\n{\npublic:\n    virtual void function1() {};\n    virtual void function2() {};\n};\nclass D1: public Base\n{\npublic:\n    virtual void function1() {};\n};\nclass D2: public Base\n{\npublic:\n    virtual void function2() {};\n}; \n 实际上为：\n class Base\n{\npublic:\n    FunctionPointer *__vptr;//虚指针\n    virtual void function1() {};\n    virtual void function2() {};\n};\nclass D1: public Base\n{\npublic:\n    virtual void function1() {};\n};\nclass D2: public Base\n{\npublic:\n    virtual void function2() {};\n};\n base\n    *__vptr;-------------------------->base vtable\n   virtual function1()<----------------function1()\n|->virtual function2()<----------------function2()\n-----------------------------------------------------|\n   D1:public base                                    |\n   *__vptr,(inherited) ----------------D1 vtable     |\n   virtual function1(); <--------------function1()   |\n                                       function2()----\n D2类似D1\n ```\n \n### 纯虚函数和纯虚类：\n#### 什么是纯虚函数和纯虚类：\n + 没有定义函数体的虚成员函数成为纯虚函数：  \n  virtual int getValue() = 0; // a pure virtual function  \n  包含一个或多个纯虚函数的类成为纯虚类  \n  虚基类是不能被对象化的，当对象化后调用纯虚函数，就会出现错误  \n```cpp\nint main()\n{\n    Base base; // We can't instantiate an abstract base class, but for the sake of example, pretend this was allowed\n    base.getValue(); // what would this do?\n}```\n#### 为什么需要纯虚函数和纯虚类？\n当子类继承了基类后，对虚函数来讲，需要复写基类的虚函数，而当忘记去写时，默认就会调用基类的虚函数；  \n而如果将基类的虚函数定义为纯虚函数。就会通过编译报错来提醒我们要复写子类的虚函数：  \n 例子：  \n ```cpp\n #include <string>\nclass Animal // This Animal is an abstract base class\n{\nprotected:\n    std::string m_name;\npublic:\n    Animal(std::string name)\n        : m_name(name)\n    {\n    }\n    std::string getName() { return m_name; }\n    virtual const char* speak() = 0; // note that speak is now a pure virtual function\n};\n#include <iostream>\nclass Cow: public Animal\n{\npublic:\n    Cow(std::string name)\n        : Animal(name)\n    {\n    }\n    // We forgot to redefine speak\n};\nint main()\n{\n    Cow cow(\"Betsy\");\n    std::cout << cow.getName() << \" says \" << cow.speak() << '\\n';\n}\n```\n\n```cpp\n#include <iostream>\nclass Cow: public Animal\n{\npublic:\n    Cow(std::string name)\n        : Animal(name)\n    {\n    }\n    virtual const char* speak() { return \"Moo\"; }\n};\nint main()\n{\n    Cow cow(\"Betsy\");\n    std::cout << cow.getName() << \" says \" << cow.speak() << '\\n';\n}\n```\n\n+ 当想要使用虚基类的实现时，又同时想让虚基类不能对象化且子类能提示需要实现纯虚函数时，应该怎么做？\n```cpp\n#include <string>\n#include <iostream> \nclass Animal // This Animal is an abstract base class\n{\nprotected:\n    std::string m_name;\npublic:\n    Animal(std::string name)\n        : m_name(name)\n    {\n    }\n    std::string getName() { return m_name; }\n    virtual const char* speak() = 0; // note that speak is a pure virtual function\n}; \nconst char* Animal::speak()\n{\n    return \"buzz\"; // some default implementation\n}\nclass Dragonfly: public Animal\n{\npublic:\n    Dragonfly(std::string name)\n        : Animal(name)\n    {\n    }\n    virtual const char* speak() // this class is no longer abstract because we defined this function\n    {\n        return Animal::speak(); // use Animal's default implementation\n    }\n};\nint main()\n{\n    Dragonfly dfly(\"Sally\");\n    std::cout << dfly.getName() << \" says \" << dfly.speak() << '\\n';\n}\nThe above code prints:\nSally says buzz\n```\n\n#### 接口类：\n接口类的类中没有成员变量。全部由纯虚函数构成；常命名为I开头的:如IErrorLog,类似于java中的接口\n```cpp\nclass IErrorLog\n{\npublic:\n    virtual bool openLog(const char *filename) = 0;\n    virtual bool closeLog() = 0;\n    virtual bool writeError(const char *errorMessage) = 0;\n    virtual ~IErrorLog() {}; // make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called\n};```\n#### virtual base class\n当普通的继承，即一个子类继承自两个不同的父类，这两个父类继承自同一个基类时。就容易出现问题：\n如：\n```cpp\nclass PoweredDevice\n{\npublic:\n    PoweredDevice(int power)\n    {\n\t\tcout << \"PoweredDevice: \" << power << '\\n';\n    }\n};\nclass Scanner: public PoweredDevice\n{\npublic:\n    Scanner(int scanner, int power)\n        : PoweredDevice(power)\n    {\n\t\tcout << \"Scanner: \" << scanner << '\\n';\n    }\n};\nclass Printer: public PoweredDevice\n{\npublic:\n    Printer(int printer, int power)\n        : PoweredDevice(power)\n    {\n\t\tcout << \"Printer: \" << printer << '\\n';\n    }\n};\nclass Copier: public Scanner, public Printer\n{\npublic:\n    Copier(int scanner, int printer, int power)\n        : Scanner(scanner, power), Printer(printer, power)\n    {\n    }\n};\nint main()\n{\n    Copier copier(1, 2, 3);\n}\nPoweredDevice: 3\nScanner: 1\nPoweredDevice: 3\nPrinter: 2\n```\n从输出看，基类被构造了两次  \n如何防止构造两个基类呢？使用virtual base class\n```cpp\nclass PoweredDevice\n{\n};\nclass Scanner: virtual public PoweredDevice\n{\n};\nclass Printer: virtual public PoweredDevice\n{\n};\nclass Copier: public Scanner, public Printer\n{\n};\n#include <iostream>\nclass PoweredDevice\n{\npublic:\n    PoweredDevice(int power)\n    {\n\t\tstd::cout << \"PoweredDevice: \" << power << '\\n';\n    }\n};\nclass Scanner: virtual public PoweredDevice // note: PoweredDevice is now a virtual base class\n{\npublic:\n    Scanner(int scanner, int power)\n        : PoweredDevice(power) // this line is required to create Scanner objects, but ignored in this case\n    {\n\t\tstd::cout << \"Scanner: \" << scanner << '\\n';\n    }\n};\nclass Printer: virtual public PoweredDevice // note: PoweredDevice is now a virtual base class\n{\npublic:\n    Printer(int printer, int power)\n        : PoweredDevice(power) // this line is required to create Printer objects, but ignored in this case\n    {\n\t\tstd::cout << \"Printer: \" << printer << '\\n';\n    }\n};\nclass Copier: public Scanner, public Printer\n{\npublic:\n    Copier(int scanner, int printer, int power)\n        : Scanner(scanner, power), Printer(printer, power),\n        PoweredDevice(power) // PoweredDevice is constructed here\n    {\n    }\n};\nThis time, our previous example:\nint main()\n{\n    Copier copier(1, 2, 3);\n}\nproduces the result:\nPoweredDevice: 3\nScanner: 1\nPrinter: 2\n```\n这样的话，基类的构造交给了继承琏最底层的类\n+ 注意：\n+ virtual base class在子类对象之前就创建了\n+ if Copier was singly inherited from Printer, and Printer was virtually inherited from PoweredDevice, Copier is still responsible for creating PoweredDevice\n+ Fourth, a virtual base class is always considered a direct base of its most derived class \n(which is why the most derived class is responsible for its construction).\n+ But classes inheriting the virtual base still need access to it. So in order to facilitate this, the compiler creates a virtual table for each class directly inheriting the virtual class (Printer and Scanner). These virtual tables point to the functions in the most derived class. Because the derived classes have a virtual table,  that also means they are now larger by a pointer (to the virtual table).\n\n#### 对象分割：\n当子类对象赋值给基类会发生什么？\n子类对象的基类部分会给基类对象\n```cpp\nint main()\n{\n    Derived derived(5);\n    Base base = derived; // what happens here?\n    std::cout << \"base is a \" << base.getName() << \" and has value \" << base.getValue() << '\\n';\n    return 0;\n}\n传值给基类\nvoid printName(const Base base) // note: base passed by value, not reference\n{\n    std::cout << \"I am a \" << base.getName() << '\\n';\n}\nThis is a pretty simple function with a const base object parameter that is passed by value. If we call this function like such:\t\nint main()\n{\n    Derived d(5);\n    printName(d); // oops, didn't realize this was pass by value on the calling end \n    return 0;\n}\n```\n\nvector<base>和vector<&base>和vector<base*>\n第一种可以但是只能调用基类的部分\n第二种不行：std::vector<Base&> v;\nUnfortunately, this won’t compile. The elements of std::vector must be assignable, whereas references can’t be reassigned (only initialized).\n第三种可以但是要做delete\n```cpp\n#include <vector>\nint main()\n{\n\tstd::vector<Base*> v;\n\tv.push_back(new Base(5)); // add a Base object to our vector\n\tv.push_back(new Derived(6)); // add a Derived object to our vector\n        // Print out all of the elements in our vector\n\tfor (int count = 0; count < v.size(); ++count)\n\t\tstd::cout << \"I am a \" << v[count]->getName() << \" with value \" << v[count]->getValue() << \"\\n\";\n\tfor (int count = 0; count < v.size(); ++count)\n\t\tdelete v[count];\n\treturn 0;\n}\n用智能指针可以避免：\n#include <vector>\n#include <functional> // for std::reference_wrapper\nint main()\n{\n\tstd::vector<std::reference_wrapper<Base> > v; // our vector is a vector of std::reference_wrapper wrapped Base (not Base&)\n\tBase b(5); // b and d can't be anonymous objects\n\tDerived d(6);\n\tv.push_back(b); // add a Base object to our vector\n\tv.push_back(d); // add a Derived object to our vector\n\t// Print out all of the elements in our vector\n\tfor (int count = 0; count < v.size(); ++count)\n\t\tstd::cout << \"I am a \" << v[count].get().getName() << \" with value \" << v[count].get().getValue() << \"\\n\"; // we use .get() to get our element from the wrapper\n\treturn 0;\n}```\n\n\n一种极端情况：\n```cpp\nint main()\n{\n    Derived d1(5);\n    Derived d2(6);\n    Base &b = d2;//b为d2的引用\n    b = d1; // this line is problematic　导致b的基类部分为d1,子类部分为d2,因为b是d2的引用，导致现在d2的基类部分是d1而子类部分是d2\n    return 0;\n}```\n\n#### 总结多态的方式＋dynamic_cast:\n+ 　shape *ps=new circle();\n    经由virtual func:  ps->rotate()    //virtual func\n    经由dynamic_cast:和type运算符：\n    if(circle *pc=dynamic_cast<circle*>(ps))\n    \n    (理解了指针类型的本质就可以理解它和理解分割的内容了:指针的类型会教导编译器如何解释某个特定地址的内容和大小:\n    所以一个void*的指针无法去确定涵盖多大的地址空间，所以它只能含有一个地址但是不能操作它指向的Ｏｂｊｅｃｔ\n    所以转型只是一种编译器指令，不改变真正的地址，而是改变解读指针的方式让它指出其内存的大小和内容）\n    更多见内存布局第一章图就能理解）\n\n","source":"_posts/cpp-polymorphism.md","raw":"---\ntitle: cpp_polymorphism\ndate: 2018-06-09 14:06:57\ntags: cpp_class\ncategories: c&cpp\n---\n### 多态：\n\n#### 为什么需要多态？\n引入几个点：  \n　　继承的机制中，基类的指针和引用能指向派生类，（派生类对象中的基类成员是在内存前面的，即指向派生类对象的指针指向的是第一个基类的第一个成员）  \n+ 指针的值本质上是内存地址，也就是说指向不同变量(int char.)，对象的指针本身的值都是地址的value)\n+ 指针的类型限定了指针的操作内存范围和取值的方式，如通过int指针取值的时候，取到４byte,通过char指针取值时取得1byte;）<!--more-->\n+ 因此，基类指针限定了，即使它指向派生类，它也只能操作基类自身的成员和方法；就像char形指针指向int形，取得的只是一部分）\n\n```cpp\n　　　#include<iostream>\n  3 using namespace std;\n  4 int main()\n  5 {\n  6     int in=2;\n  7     char *pc=(char*)&in;\n  8     cout<<*pc<<endl;//乱码\n  9     return 0;\n 10 }\n```\n\n所以基类指针可以指向子类，但是只能调用基类的函数，即使子类复写了父类的函数\n```cpp\nclass Base\n{\npublic:\n    const char* getName() { return \"Base\"; }\n};\n \nclass Derived: public Base\n{\npublic:\n    const char* getName() { return \"Derived\"; }\n};\n \nint main()\n{\n    Derived derived;\n    Base &rBase = derived;\n    std::cout << \"rBase is a \" << rBase.getName() << '\\n';\n}\n```\nThis example prints the result:\n\nrBase is a Base\n\n/＝》简化：如何让下面的例子得到想要的结果？  \n```cpp\nAnimal *animals[] = { &fred, &garbo, &misty, &pooky, &truffle, &zeke };\n    for (int iii=0; iii < 6; iii++)\n        std::cout << animals[iii]->getName() << \" says \" << animals[iii]->speak() << '\\n';\n ```\n+ 如何让父类指针指向子类对象，可以调用子类函数呢？\n      －－－多态\n+ 调用的子类函数要满足:  \n  A derived function is considered a match if it has the same signature (name, parameter types, and whether it is const) and return type as the base version of the function. Such functions are called overrides.\n\n#### 如何使用－－－例子\n```cpp\nclass Base\n{\npublic:\n    virtual const char* getName() { return \"Base\"; } // note addition of virtual keyword\n};\n \nclass Derived: public Base\n{\npublic:\n    virtual const char* getName() { return \"Derived\"; }\n};\n \nint main()\n{\n    Derived derived;\n    Base &rBase = derived;\n    std::cout << \"rBase is a \" << rBase.getName() << '\\n';\n \n    return 0;\n}\n```\nThis example prints the result:\n\nrBase is a Derived\n－－－－－－－－－－－－－－－－－－－－－－－  \n再盗一个例子：\n```cpp\n#include <string>\nclass Animal\n{\nprotected:\n    std::string m_name;\n \n    // We're making this constructor protected because\n    // we don't want people creating Animal objects directly,\n    // but we still want derived classes to be able to use it.\n    Animal(std::string name)\n        : m_name(name)\n    {\n    }\n \npublic:\n    std::string getName() { return m_name; }\n    virtual const char* speak() { return \"???\"; }\n};\n \nclass Cat: public Animal\n{\npublic:\n    Cat(std::string name)\n        : Animal(name)\n    {\n    }\n \n    virtual const char* speak() { return \"Meow\"; }\n};\n \nclass Dog: public Animal\n{\npublic:\n    Dog(std::string name)\n        : Animal(name)\n    {\n    }\n \n    virtual const char* speak() { return \"Woof\"; }\n};\n \nvoid report(Animal &animal)\n{\n    std::cout << animal.getName() << \" says \" << animal.speak() << '\\n';\n}\n \nint main()\n{\n    Cat cat(\"Fred\");\n    Dog dog(\"Garbo\");\n \n    report(cat);\n    report(dog);\n}\n```\n#### 注意多态的方式：\n调用基类指针指向子类，函数时，会调用到继承琏最底端，且该最低端的子类有该virtual函数的，否则只调用到最下且复写了该函数的。如下例子：\n```cpp\n  1 #include<iostream>\n  2 using namespace std;\n  3 class A\n  4 {\n  5         public:\n  6                     virtual const char* getName() { return \"A\"; }\n  7 };\n  8 \n  9 class B: public A\n 10 {\n 11         public:\n 12                     virtual const char* getName() { return \"B\"; }\n 13 };\n 14 \n 15 class C: public B\n 16 {\n 17         public:\n 18                     virtual const char* getName() { return \"C\"; }\n                        //or const char * getName(){..} and default virtual\n 19 };\n 20 \n 21 class D: public C\n 22 {\n 23         public:\n 24                    // virtual const char* getName() { return \"D\"; }\n 25 };\n 26 \n 27 int main()\n 28 {\n 29             D d;\n 30             A &rBase = d;\n 31             std::cout << \"rBase is a \" << rBase.getName() << '\\n';\n 32 \n 33             return 0;\n 34 }```\n     输出c\n     \n#### 注意点：\n+ virtual关键字是否都需要写？：  \nOnly the most base class function needs to be tagged as virtual for all of the derived \nfunctions to work virtually. However, having the keyword virtual on the derived functions\n does not hurt, and it serves as a useful reminder that the function is a virtual function \n rather than a normal one.\n \n \n+ 不能在构造函数和西沟函数中调用它，因为此时子类对象还没有被构造\n \n+ c++11引入override和final来防止避免不匹配的复写和阻止继承：  \n １）override:  \n 出现错误的例子:\n ```cpp\n class A\n{\npublic:\n\tvirtual const char* getName1(int x) { return \"A\"; }\n\tvirtual const char* getName2(int x) { return \"A\"; }\n};\nclass B : public A\n{\npublic:\n\tvirtual const char* getName1(short int x) { return \"B\"; } // note: parameter is a short int\n\tvirtual const char* getName2(int x) const { return \"B\"; } // note: function is const\n}; \nint main()\n{\n\tB b;\n\tA &rBase = b;\n\tstd::cout << rBase.getName1(1) << '\\n';\n\tstd::cout << rBase.getName2(2) << '\\n';\n \n\treturn 0;\n}\n ```\n \n 由于参数返回值不匹配，所以编译器认为不是复写，结果：\n A\nA\n```cpp\n加入override:\nclass A\n{\npublic:\n\tvirtual const char* getName1(int x) { return \"A\"; }\n\tvirtual const char* getName2(int x) { return \"A\"; }\n\tvirtual const char* getName3(int x) { return \"A\"; }\n};\nclass B : public A\n{\npublic:\n\tvirtual const char* getName1(short int x) override { return \"B\"; } // compile error, function is not an override\n\tvirtual const char* getName2(int x) const override { return \"B\"; } // compile error, function is not an override\n\tvirtual const char* getName3(int x) override { return \"B\"; } // okay, function is an override of A::getName3(int) \n};\nint main()\n{\n\treturn 0;\n} \nRule: Apply the override specifier to every intended override function you write.\n ```\n \n+ final:\n ```cpp\n 加了final的函数无法被复写：\n class A\n{\npublic:\n\tvirtual const char* getName() { return \"A\"; }\n};\nclass B : public A\n{\npublic:\n\t// note use of final specifier on following line -- that makes this function no longer overridable\n\tvirtual const char* getName() override final { return \"B\"; } // okay, overrides A::getName()\n}; \nclass C : public B\n{\npublic:\n\tvirtual const char* getName() override { return \"C\"; } // compile error: overrides B::getName(), which is final\n};\n 加了final的类不能被继承：\n class A\n{\npublic:\n\tvirtual const char* getName() { return \"A\"; }\n};\nclass B final : public A // note use of final specifier here\n{\npublic:\n\tvirtual const char* getName() override { return \"B\"; }\n};\nclass C : public B // compile error: cannot inherit from final class\n{\npublic:\n\tvirtual const char* getName() override { return \"C\"; }\n};\n ````\n \n+ 对匹配返回值的一个“例外”：covariant return types:\n ```cpp\n class Base\n{\npublic:\n    // This version of getThis() returns a pointer to a Base class\n    virtual Base* getThis() { return this; }\n};\nclass Derived: public Base\n{\n    // Normally override functions have to return objects of the same type as the base function\n    // However, because Derived is derived from Base, it's okay to return Derived* instead of Base*\n    virtual Derived* getThis() { return this; }\n};```\n\n注意当base=&derive;\n     base.getThis()----取得的任然是base\n \n \n#### 当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：\n```cpp\n#include <iostream>\nint main()\n{\n    Derived derived;\n    Base &base = derived;\n    // Calls Base::GetName() instead of the virtualized Derived::GetName()\n    std::cout << base.Base::getName() << std::endl;\n}　　\n```\n\n \n### 虚析构函数　：\n#### 为什么需要虚析构函数：\n 当基类指针指向派生类时，当析构后，只会调用基类的析构函数：\n```cpp\n#include <iostream>\nclass Base\n{\npublic:\n    ~Base() // note: not virtual\n    {\n        std::cout << \"Calling ~Base()\" << std::endl;\n    }\n};\nclass Derived: public Base\n{\nprivate:\n    int* m_array;\npublic:\n    Derived(int length)\n    {\n        m_array = new int[length];\n    }\n    ~Derived() // note: not virtual\n    {\n        std::cout << \"Calling ~Derived()\" << std::endl;\n        delete[] m_array;\n    }\n};\nint main()\n{\n    Derived *derived = new Derived(5);\n    Base *base = derived ;\n    delete base;\n    return 0;\n}```\n 只输出Calling ~Base()\n + 所以为了调用派生类的析构函数，需要定义为虚析构函数：\n ```cpp\n #include <iostream>\nclass Base\n{\npublic:\n    virtual ~Base() // note: virtual\n    {\n        std::cout << \"Calling ~Base()\" << std::endl;\n    }\n};\nclass Derived: public Base\n{\nprivate:\n    int* m_array;\npublic:\n    Derived(int length)\n    {\n        m_array = new int[length];\n    }\n    virtual ~Derived() // note: virtual\n    {\n        std::cout << \"Calling ~Derived()\" << std::endl;\n        delete[] m_array;\n    }\n};\nint main()\n{\n    Derived *derived = new Derived(5);\n    Base *base = derived;\n    delete base;\n \n    return 0;\n}\nNow this program produces the following result:\nCalling ~Derived()\nCalling ~Base()\nRule: Whenever you are dealing with inheritance, you should make any explicit destructors virtual. ```\n \n \n \n \n ### 虚表：\n #### Early binding（静态绑定） and late binding（动态绑定）\n 前者指的是直接在代码里调用函数，通过函数名，即编译期间就可以直到函数的地址的（偏移，非真实的内存地址）  \n\"\" Early binding (also called static binding) means the compiler (or linker) is able to directly associate the identifier name (such as a function or variable name) with a machine address. \n Remember that all functions have a unique address. So when the compiler (or linker) encounters a function call, \n  it replaces the function call with a machine language instruction that tells the CPU to jump to the address of the function.\"\"\n ```cpp\n #include <iostream>\nint add(int x, int y)\n{\n    return x + y;\n}\nint subtract(int x, int y)\n{\n    return x - y;\n}\nint multiply(int x, int y)\n{\n    return x * y;\n}\nint main()\n{\n    int x;\n    std::cout << \"Enter a number: \";\n    std::cin >> x;\n    int y;\n    std::cout << \"Enter another number: \";\n    std::cin >> y;\n    int op;\n    do\n    {\n        std::cout << \"Enter an operation (0=add, 1=subtract, 2=multiply): \";\n        std::cin >> op;\n    } while (op < 0 || op > 2);\n    int result = 0;\n    switch (op)\n    {\n        // call the target function directly using early binding\n        case 0: result = add(x, y); break;\n        case 1: result = subtract(x, y); break;\n        case 2: result = multiply(x, y); break;\n    }\n    std::cout << \"The answer is: \" << result << std::endl;\n    return 0;\n}```\n 后者指的是通过函数指针等方式，即在编译期间无法确定调用什么函数，需要通过指针来访问函数（函数指针），效率比前者低\n in some programs, it is not possible to know which function will be called until runtime (when the program is run). \n This is known as late binding (or dynamic binding). In C++, one way to get late binding is to use function pointers. \n ```cpp\n #include <iostream>\nint add(int x, int y)\n{\n    return x + y;\n}\nint main()\n{\n    // Create a function pointer and make it point to the Add function\n    int (*pFcn)(int, int) = add;\n    std::cout << pFcn(5, 3) << std::endl; // add 5 + 3\n    return 0;\n}\n ```\n#### 虚表\n 为什么虚函数能成立－－基类指针指向派生类能调用派生类的函数：  \n 实际上，在定义了虚函数的基类中维护了一个虚指针：它指向一张表，表中包含各个虚函数指针；在这个继承琏中的每一个类有自己的一张虚表，这张表由编译器在编译期间生成, 虚指针在包含虚函数的类的对象被创建时自动创建\n```cpp\nclass Base\n{\npublic:\n    virtual void function1() {};\n    virtual void function2() {};\n};\nclass D1: public Base\n{\npublic:\n    virtual void function1() {};\n};\nclass D2: public Base\n{\npublic:\n    virtual void function2() {};\n}; \n 实际上为：\n class Base\n{\npublic:\n    FunctionPointer *__vptr;//虚指针\n    virtual void function1() {};\n    virtual void function2() {};\n};\nclass D1: public Base\n{\npublic:\n    virtual void function1() {};\n};\nclass D2: public Base\n{\npublic:\n    virtual void function2() {};\n};\n base\n    *__vptr;-------------------------->base vtable\n   virtual function1()<----------------function1()\n|->virtual function2()<----------------function2()\n-----------------------------------------------------|\n   D1:public base                                    |\n   *__vptr,(inherited) ----------------D1 vtable     |\n   virtual function1(); <--------------function1()   |\n                                       function2()----\n D2类似D1\n ```\n \n### 纯虚函数和纯虚类：\n#### 什么是纯虚函数和纯虚类：\n + 没有定义函数体的虚成员函数成为纯虚函数：  \n  virtual int getValue() = 0; // a pure virtual function  \n  包含一个或多个纯虚函数的类成为纯虚类  \n  虚基类是不能被对象化的，当对象化后调用纯虚函数，就会出现错误  \n```cpp\nint main()\n{\n    Base base; // We can't instantiate an abstract base class, but for the sake of example, pretend this was allowed\n    base.getValue(); // what would this do?\n}```\n#### 为什么需要纯虚函数和纯虚类？\n当子类继承了基类后，对虚函数来讲，需要复写基类的虚函数，而当忘记去写时，默认就会调用基类的虚函数；  \n而如果将基类的虚函数定义为纯虚函数。就会通过编译报错来提醒我们要复写子类的虚函数：  \n 例子：  \n ```cpp\n #include <string>\nclass Animal // This Animal is an abstract base class\n{\nprotected:\n    std::string m_name;\npublic:\n    Animal(std::string name)\n        : m_name(name)\n    {\n    }\n    std::string getName() { return m_name; }\n    virtual const char* speak() = 0; // note that speak is now a pure virtual function\n};\n#include <iostream>\nclass Cow: public Animal\n{\npublic:\n    Cow(std::string name)\n        : Animal(name)\n    {\n    }\n    // We forgot to redefine speak\n};\nint main()\n{\n    Cow cow(\"Betsy\");\n    std::cout << cow.getName() << \" says \" << cow.speak() << '\\n';\n}\n```\n\n```cpp\n#include <iostream>\nclass Cow: public Animal\n{\npublic:\n    Cow(std::string name)\n        : Animal(name)\n    {\n    }\n    virtual const char* speak() { return \"Moo\"; }\n};\nint main()\n{\n    Cow cow(\"Betsy\");\n    std::cout << cow.getName() << \" says \" << cow.speak() << '\\n';\n}\n```\n\n+ 当想要使用虚基类的实现时，又同时想让虚基类不能对象化且子类能提示需要实现纯虚函数时，应该怎么做？\n```cpp\n#include <string>\n#include <iostream> \nclass Animal // This Animal is an abstract base class\n{\nprotected:\n    std::string m_name;\npublic:\n    Animal(std::string name)\n        : m_name(name)\n    {\n    }\n    std::string getName() { return m_name; }\n    virtual const char* speak() = 0; // note that speak is a pure virtual function\n}; \nconst char* Animal::speak()\n{\n    return \"buzz\"; // some default implementation\n}\nclass Dragonfly: public Animal\n{\npublic:\n    Dragonfly(std::string name)\n        : Animal(name)\n    {\n    }\n    virtual const char* speak() // this class is no longer abstract because we defined this function\n    {\n        return Animal::speak(); // use Animal's default implementation\n    }\n};\nint main()\n{\n    Dragonfly dfly(\"Sally\");\n    std::cout << dfly.getName() << \" says \" << dfly.speak() << '\\n';\n}\nThe above code prints:\nSally says buzz\n```\n\n#### 接口类：\n接口类的类中没有成员变量。全部由纯虚函数构成；常命名为I开头的:如IErrorLog,类似于java中的接口\n```cpp\nclass IErrorLog\n{\npublic:\n    virtual bool openLog(const char *filename) = 0;\n    virtual bool closeLog() = 0;\n    virtual bool writeError(const char *errorMessage) = 0;\n    virtual ~IErrorLog() {}; // make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called\n};```\n#### virtual base class\n当普通的继承，即一个子类继承自两个不同的父类，这两个父类继承自同一个基类时。就容易出现问题：\n如：\n```cpp\nclass PoweredDevice\n{\npublic:\n    PoweredDevice(int power)\n    {\n\t\tcout << \"PoweredDevice: \" << power << '\\n';\n    }\n};\nclass Scanner: public PoweredDevice\n{\npublic:\n    Scanner(int scanner, int power)\n        : PoweredDevice(power)\n    {\n\t\tcout << \"Scanner: \" << scanner << '\\n';\n    }\n};\nclass Printer: public PoweredDevice\n{\npublic:\n    Printer(int printer, int power)\n        : PoweredDevice(power)\n    {\n\t\tcout << \"Printer: \" << printer << '\\n';\n    }\n};\nclass Copier: public Scanner, public Printer\n{\npublic:\n    Copier(int scanner, int printer, int power)\n        : Scanner(scanner, power), Printer(printer, power)\n    {\n    }\n};\nint main()\n{\n    Copier copier(1, 2, 3);\n}\nPoweredDevice: 3\nScanner: 1\nPoweredDevice: 3\nPrinter: 2\n```\n从输出看，基类被构造了两次  \n如何防止构造两个基类呢？使用virtual base class\n```cpp\nclass PoweredDevice\n{\n};\nclass Scanner: virtual public PoweredDevice\n{\n};\nclass Printer: virtual public PoweredDevice\n{\n};\nclass Copier: public Scanner, public Printer\n{\n};\n#include <iostream>\nclass PoweredDevice\n{\npublic:\n    PoweredDevice(int power)\n    {\n\t\tstd::cout << \"PoweredDevice: \" << power << '\\n';\n    }\n};\nclass Scanner: virtual public PoweredDevice // note: PoweredDevice is now a virtual base class\n{\npublic:\n    Scanner(int scanner, int power)\n        : PoweredDevice(power) // this line is required to create Scanner objects, but ignored in this case\n    {\n\t\tstd::cout << \"Scanner: \" << scanner << '\\n';\n    }\n};\nclass Printer: virtual public PoweredDevice // note: PoweredDevice is now a virtual base class\n{\npublic:\n    Printer(int printer, int power)\n        : PoweredDevice(power) // this line is required to create Printer objects, but ignored in this case\n    {\n\t\tstd::cout << \"Printer: \" << printer << '\\n';\n    }\n};\nclass Copier: public Scanner, public Printer\n{\npublic:\n    Copier(int scanner, int printer, int power)\n        : Scanner(scanner, power), Printer(printer, power),\n        PoweredDevice(power) // PoweredDevice is constructed here\n    {\n    }\n};\nThis time, our previous example:\nint main()\n{\n    Copier copier(1, 2, 3);\n}\nproduces the result:\nPoweredDevice: 3\nScanner: 1\nPrinter: 2\n```\n这样的话，基类的构造交给了继承琏最底层的类\n+ 注意：\n+ virtual base class在子类对象之前就创建了\n+ if Copier was singly inherited from Printer, and Printer was virtually inherited from PoweredDevice, Copier is still responsible for creating PoweredDevice\n+ Fourth, a virtual base class is always considered a direct base of its most derived class \n(which is why the most derived class is responsible for its construction).\n+ But classes inheriting the virtual base still need access to it. So in order to facilitate this, the compiler creates a virtual table for each class directly inheriting the virtual class (Printer and Scanner). These virtual tables point to the functions in the most derived class. Because the derived classes have a virtual table,  that also means they are now larger by a pointer (to the virtual table).\n\n#### 对象分割：\n当子类对象赋值给基类会发生什么？\n子类对象的基类部分会给基类对象\n```cpp\nint main()\n{\n    Derived derived(5);\n    Base base = derived; // what happens here?\n    std::cout << \"base is a \" << base.getName() << \" and has value \" << base.getValue() << '\\n';\n    return 0;\n}\n传值给基类\nvoid printName(const Base base) // note: base passed by value, not reference\n{\n    std::cout << \"I am a \" << base.getName() << '\\n';\n}\nThis is a pretty simple function with a const base object parameter that is passed by value. If we call this function like such:\t\nint main()\n{\n    Derived d(5);\n    printName(d); // oops, didn't realize this was pass by value on the calling end \n    return 0;\n}\n```\n\nvector<base>和vector<&base>和vector<base*>\n第一种可以但是只能调用基类的部分\n第二种不行：std::vector<Base&> v;\nUnfortunately, this won’t compile. The elements of std::vector must be assignable, whereas references can’t be reassigned (only initialized).\n第三种可以但是要做delete\n```cpp\n#include <vector>\nint main()\n{\n\tstd::vector<Base*> v;\n\tv.push_back(new Base(5)); // add a Base object to our vector\n\tv.push_back(new Derived(6)); // add a Derived object to our vector\n        // Print out all of the elements in our vector\n\tfor (int count = 0; count < v.size(); ++count)\n\t\tstd::cout << \"I am a \" << v[count]->getName() << \" with value \" << v[count]->getValue() << \"\\n\";\n\tfor (int count = 0; count < v.size(); ++count)\n\t\tdelete v[count];\n\treturn 0;\n}\n用智能指针可以避免：\n#include <vector>\n#include <functional> // for std::reference_wrapper\nint main()\n{\n\tstd::vector<std::reference_wrapper<Base> > v; // our vector is a vector of std::reference_wrapper wrapped Base (not Base&)\n\tBase b(5); // b and d can't be anonymous objects\n\tDerived d(6);\n\tv.push_back(b); // add a Base object to our vector\n\tv.push_back(d); // add a Derived object to our vector\n\t// Print out all of the elements in our vector\n\tfor (int count = 0; count < v.size(); ++count)\n\t\tstd::cout << \"I am a \" << v[count].get().getName() << \" with value \" << v[count].get().getValue() << \"\\n\"; // we use .get() to get our element from the wrapper\n\treturn 0;\n}```\n\n\n一种极端情况：\n```cpp\nint main()\n{\n    Derived d1(5);\n    Derived d2(6);\n    Base &b = d2;//b为d2的引用\n    b = d1; // this line is problematic　导致b的基类部分为d1,子类部分为d2,因为b是d2的引用，导致现在d2的基类部分是d1而子类部分是d2\n    return 0;\n}```\n\n#### 总结多态的方式＋dynamic_cast:\n+ 　shape *ps=new circle();\n    经由virtual func:  ps->rotate()    //virtual func\n    经由dynamic_cast:和type运算符：\n    if(circle *pc=dynamic_cast<circle*>(ps))\n    \n    (理解了指针类型的本质就可以理解它和理解分割的内容了:指针的类型会教导编译器如何解释某个特定地址的内容和大小:\n    所以一个void*的指针无法去确定涵盖多大的地址空间，所以它只能含有一个地址但是不能操作它指向的Ｏｂｊｅｃｔ\n    所以转型只是一种编译器指令，不改变真正的地址，而是改变解读指针的方式让它指出其内存的大小和内容）\n    更多见内存布局第一章图就能理解）\n\n","slug":"cpp-polymorphism","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7o4001c2ujx80emwil7","content":"<h3 id=\"多态：\"><a href=\"#多态：\" class=\"headerlink\" title=\"多态：\"></a>多态：</h3><h4 id=\"为什么需要多态？\"><a href=\"#为什么需要多态？\" class=\"headerlink\" title=\"为什么需要多态？\"></a>为什么需要多态？</h4><p>引入几个点：<br>　　继承的机制中，基类的指针和引用能指向派生类，（派生类对象中的基类成员是在内存前面的，即指向派生类对象的指针指向的是第一个基类的第一个成员）  </p>\n<ul>\n<li>指针的值本质上是内存地址，也就是说指向不同变量(int char.)，对象的指针本身的值都是地址的value)</li>\n<li>指针的类型限定了指针的操作内存范围和取值的方式，如通过int指针取值的时候，取到４byte,通过char指针取值时取得1byte;）<a id=\"more\"></a></li>\n<li>因此，基类指针限定了，即使它指向派生类，它也只能操作基类自身的成员和方法；就像char形指针指向int形，取得的只是一部分）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　<span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"number\">3</span> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"> <span class=\"number\">4</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"> 5 </span>&#123;</span><br><span class=\"line\"> <span class=\"number\">6</span>     <span class=\"keyword\">int</span> in=<span class=\"number\">2</span>;</span><br><span class=\"line\"> <span class=\"number\">7</span>     <span class=\"keyword\">char</span> *pc=(<span class=\"keyword\">char</span>*)&amp;in;</span><br><span class=\"line\"> <span class=\"number\">8</span>     <span class=\"built_in\">cout</span>&lt;&lt;*pc&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//乱码</span></span><br><span class=\"line\"> <span class=\"number\">9</span>     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">10</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>所以基类指针可以指向子类，但是只能调用基类的函数，即使子类复写了父类的函数<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Base\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Derived\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Derived derived;</span><br><span class=\"line\">    Base &amp;rBase = derived;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"rBase is a \"</span> &lt;&lt; rBase.getName() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>This example prints the result:</p>\n<p>rBase is a Base</p>\n<p>/＝》简化：如何让下面的例子得到想要的结果？<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal *animals[] = &#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> iii=<span class=\"number\">0</span>; iii &lt; <span class=\"number\">6</span>; iii++)</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; animals[iii]-&gt;getName() &lt;&lt; <span class=\"string\">\" says \"</span> &lt;&lt; animals[iii]-&gt;speak() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>如何让父类指针指向子类对象，可以调用子类函数呢？<pre><code>－－－多态\n</code></pre></li>\n<li>调用的子类函数要满足:<br>A derived function is considered a match if it has the same signature (name, parameter types, and whether it is const) and return type as the base version of the function. Such functions are called overrides.</li>\n</ul>\n<h4 id=\"如何使用－－－例子\"><a href=\"#如何使用－－－例子\" class=\"headerlink\" title=\"如何使用－－－例子\"></a>如何使用－－－例子</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Base\"</span>; &#125; <span class=\"comment\">// note addition of virtual keyword</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Derived\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Derived derived;</span><br><span class=\"line\">    Base &amp;rBase = derived;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"rBase is a \"</span> &lt;&lt; rBase.getName() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>This example prints the result:</p>\n<p>rBase is a Derived<br>－－－－－－－－－－－－－－－－－－－－－－－<br>再盗一个例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> m_name;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// We're making this constructor protected because</span></span><br><span class=\"line\">    <span class=\"comment\">// we don't want people creating Animal objects directly,</span></span><br><span class=\"line\">    <span class=\"comment\">// but we still want derived classes to be able to use it.</span></span><br><span class=\"line\">    Animal(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : m_name(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_name; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"???\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span>:</span> <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Cat(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : Animal(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Meow\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span> <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Dog(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : Animal(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Woof\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">report</span><span class=\"params\">(Animal &amp;animal)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; animal.getName() &lt;&lt; <span class=\"string\">\" says \"</span> &lt;&lt; animal.speak() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Cat <span class=\"title\">cat</span><span class=\"params\">(<span class=\"string\">\"Fred\"</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Dog <span class=\"title\">dog</span><span class=\"params\">(<span class=\"string\">\"Garbo\"</span>)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    report(cat);</span><br><span class=\"line\">    report(dog);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"注意多态的方式：\"><a href=\"#注意多态的方式：\" class=\"headerlink\" title=\"注意多态的方式：\"></a>注意多态的方式：</h4><p>调用基类指针指向子类，函数时，会调用到继承琏最底端，且该最低端的子类有该virtual函数的，否则只调用到最下且复写了该函数的。如下例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">1</span> <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"number\">2</span> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"> <span class=\"number\">3</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\"> 4 &#123;</span></span><br><span class=\"line\"> <span class=\"number\">5</span>         <span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"number\">6</span>                     <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\"> <span class=\"number\">7</span> &#125;;</span><br><span class=\"line\"> <span class=\"number\">8</span> </span><br><span class=\"line\"> <span class=\"number\">9</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\"><span class=\"number\">10</span> &#123;</span><br><span class=\"line\"><span class=\"number\">11</span>         <span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"number\">12</span>                     <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125;</span><br><span class=\"line\"><span class=\"number\">13</span> &#125;;</span><br><span class=\"line\"><span class=\"number\">14</span> </span><br><span class=\"line\"><span class=\"number\">15</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>:</span> <span class=\"keyword\">public</span> B</span><br><span class=\"line\"><span class=\"number\">16</span> &#123;</span><br><span class=\"line\"><span class=\"number\">17</span>         <span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"number\">18</span>                     <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>; &#125;</span><br><span class=\"line\">                       <span class=\"comment\">//or const char * getName()&#123;..&#125; and default virtual</span></span><br><span class=\"line\"><span class=\"number\">19</span> &#125;;</span><br><span class=\"line\"><span class=\"number\">20</span> </span><br><span class=\"line\"><span class=\"number\">21</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span> <span class=\"keyword\">public</span> C</span><br><span class=\"line\"><span class=\"number\">22</span> &#123;</span><br><span class=\"line\"><span class=\"number\">23</span>         <span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"number\">24</span>                    <span class=\"comment\">// virtual const char* getName() &#123; return \"D\"; &#125;</span></span><br><span class=\"line\"><span class=\"number\">25</span> &#125;;</span><br><span class=\"line\"><span class=\"number\">26</span> </span><br><span class=\"line\"><span class=\"number\">27</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">28 </span>&#123;</span><br><span class=\"line\"><span class=\"number\">29</span>             D d;</span><br><span class=\"line\"><span class=\"number\">30</span>             A &amp;rBase = d;</span><br><span class=\"line\"><span class=\"number\">31</span>             <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"rBase is a \"</span> &lt;&lt; rBase.getName() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"><span class=\"number\">32</span> </span><br><span class=\"line\"><span class=\"number\">33</span>             <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">34</span> &#125;</span><br></pre></td></tr></table></figure></p>\n<pre><code>输出c\n</code></pre><h4 id=\"注意点：\"><a href=\"#注意点：\" class=\"headerlink\" title=\"注意点：\"></a>注意点：</h4><ul>\n<li>virtual关键字是否都需要写？：<br>Only the most base class function needs to be tagged as virtual for all of the derived<br>functions to work virtually. However, having the keyword virtual on the derived functions<br>does not hurt, and it serves as a useful reminder that the function is a virtual function<br>rather than a normal one.</li>\n</ul>\n<ul>\n<li><p>不能在构造函数和西沟函数中调用它，因为此时子类对象还没有被构造</p>\n</li>\n<li><p>c++11引入override和final来防止避免不匹配的复写和阻止继承：<br>１）override:<br>出现错误的例子:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName1</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName1</span><span class=\"params\">(<span class=\"keyword\">short</span> <span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125; <span class=\"comment\">// note: parameter is a short int</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125; <span class=\"comment\">// note: function is const</span></span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tB b;</span><br><span class=\"line\">\tA &amp;rBase = b;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; rBase.getName1(<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; rBase.getName2(<span class=\"number\">2</span>) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p> 由于参数返回值不匹配，所以编译器认为不是复写，结果：<br> A<br>A<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加入override:</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName1</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName3</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName1</span><span class=\"params\">(<span class=\"keyword\">short</span> <span class=\"keyword\">int</span> x)</span> override </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125; <span class=\"comment\">// compile error, function is not an override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> <span class=\"keyword\">const</span> override </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125; <span class=\"comment\">// compile error, function is not an override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName3</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> override </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125; <span class=\"comment\">// okay, function is an override of A::getName3(int) </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">Rule: Apply the override specifier to every intended override function you write.</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>final:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 加了final的函数无法被复写：</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// note use of final specifier on following line -- that makes this function no longer overridable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> override final </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125; <span class=\"comment\">// okay, overrides A::getName()</span></span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> :</span> <span class=\"keyword\">public</span> B</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> override </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>; &#125; <span class=\"comment\">// compile error: overrides B::getName(), which is final</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> 加了final的类不能被继承：</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"title\">final</span> :</span> <span class=\"keyword\">public</span> A <span class=\"comment\">// note use of final specifier here</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> override </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> :</span> <span class=\"keyword\">public</span> B <span class=\"comment\">// compile error: cannot inherit from final class</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> override </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> `</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>对匹配返回值的一个“例外”：covariant return types:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// This version of getThis() returns a pointer to a Base class</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Base* <span class=\"title\">getThis</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Normally override functions have to return objects of the same type as the base function</span></span><br><span class=\"line\">    <span class=\"comment\">// However, because Derived is derived from Base, it's okay to return Derived* instead of Base*</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Derived* <span class=\"title\">getThis</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意当base=&derive;<br>     base.getThis()—-取得的任然是base</p>\n<h4 id=\"当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：\"><a href=\"#当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：\" class=\"headerlink\" title=\"当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：\"></a>当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Derived derived;</span><br><span class=\"line\">    Base &amp;base = derived;</span><br><span class=\"line\">    <span class=\"comment\">// Calls Base::GetName() instead of the virtualized Derived::GetName()</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; base.Base::getName() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"虚析构函数-：\"><a href=\"#虚析构函数-：\" class=\"headerlink\" title=\"虚析构函数　：\"></a>虚析构函数　：</h3><h4 id=\"为什么需要虚析构函数：\"><a href=\"#为什么需要虚析构函数：\" class=\"headerlink\" title=\"为什么需要虚析构函数：\"></a>为什么需要虚析构函数：</h4><p> 当基类指针指向派生类时，当析构后，只会调用基类的析构函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~Base() <span class=\"comment\">// note: not virtual</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Calling ~Base()\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* m_array;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Derived(<span class=\"keyword\">int</span> length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_array = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Derived() <span class=\"comment\">// note: not virtual</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Calling ~Derived()\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] m_array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Derived *derived = <span class=\"keyword\">new</span> Derived(<span class=\"number\">5</span>);</span><br><span class=\"line\">    Base *base = derived ;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> base;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 只输出Calling ~Base()</p>\n<ul>\n<li>所以为了调用派生类的析构函数，需要定义为虚析构函数：<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Base() <span class=\"comment\">// note: virtual</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Calling ~Base()\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* m_array;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Derived(<span class=\"keyword\">int</span> length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_array = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Derived() <span class=\"comment\">// note: virtual</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Calling ~Derived()\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] m_array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Derived *derived = <span class=\"keyword\">new</span> Derived(<span class=\"number\">5</span>);</span><br><span class=\"line\">    Base *base = derived;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> base;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Now <span class=\"keyword\">this</span> program produces the following result:</span><br><span class=\"line\">Calling ~Derived()</span><br><span class=\"line\">Calling ~Base()</span><br><span class=\"line\">Rule: Whenever you are dealing with inheritance, you should make any <span class=\"keyword\">explicit</span> destructors <span class=\"keyword\">virtual</span>.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"虚表：\"><a href=\"#虚表：\" class=\"headerlink\" title=\"虚表：\"></a>虚表：</h3><h4 id=\"Early-binding（静态绑定）-and-late-binding（动态绑定）\"><a href=\"#Early-binding（静态绑定）-and-late-binding（动态绑定）\" class=\"headerlink\" title=\"Early binding（静态绑定） and late binding（动态绑定）\"></a>Early binding（静态绑定） and late binding（动态绑定）</h4><p> 前者指的是直接在代码里调用函数，通过函数名，即编译期间就可以直到函数的地址的（偏移，非真实的内存地址）<br>“” Early binding (also called static binding) means the compiler (or linker) is able to directly associate the identifier name (such as a function or variable name) with a machine address.<br> Remember that all functions have a unique address. So when the compiler (or linker) encounters a function call,<br>  it replaces the function call with a machine language instruction that tells the CPU to jump to the address of the function.””<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">subtract</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x - y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Enter a number: \"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Enter another number: \"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> op;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Enter an operation (0=add, 1=subtract, 2=multiply): \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; op;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (op &lt; <span class=\"number\">0</span> || op &gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (op)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// call the target function directly using early binding</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>: result = add(x, y); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: result = subtract(x, y); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>: result = multiply(x, y); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The answer is: \"</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 后者指的是通过函数指针等方式，即在编译期间无法确定调用什么函数，需要通过指针来访问函数（函数指针），效率比前者低<br> in some programs, it is not possible to know which function will be called until runtime (when the program is run).<br> This is known as late binding (or dynamic binding). In C++, one way to get late binding is to use function pointers.<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a function pointer and make it point to the Add function</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*pFcn)(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>) = add;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; pFcn(<span class=\"number\">5</span>, <span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">// add 5 + 3</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"虚表\"><a href=\"#虚表\" class=\"headerlink\" title=\"虚表\"></a>虚表</h4><p> 为什么虚函数能成立－－基类指针指向派生类能调用派生类的函数：<br> 实际上，在定义了虚函数的基类中维护了一个虚指针：它指向一张表，表中包含各个虚函数指针；在这个继承琏中的每一个类有自己的一张虚表，这张表由编译器在编译期间生成, 虚指针在包含虚函数的类的对象被创建时自动创建<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function1</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function2</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D1</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function1</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D2</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function2</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"> 实际上为：</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    FunctionPointer *__vptr;<span class=\"comment\">//虚指针</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function1</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function2</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D1</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function1</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D2</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function2</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> base</span><br><span class=\"line\">    *__vptr;--------------------------&gt;base vtable</span><br><span class=\"line\">   virtual function1()&lt;----------------function1()</span><br><span class=\"line\">|-&gt;virtual function2()&lt;----------------function2()</span><br><span class=\"line\">-----------------------------------------------------|</span><br><span class=\"line\">   D1:<span class=\"keyword\">public</span> base                                    |</span><br><span class=\"line\">   *__vptr,(inherited) ----------------D1 vtable     |</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"title\">function1</span><span class=\"params\">()</span></span>; &lt;--------------function1()   |</span><br><span class=\"line\">                                       function2()----</span><br><span class=\"line\"> D2类似D1</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"纯虚函数和纯虚类：\"><a href=\"#纯虚函数和纯虚类：\" class=\"headerlink\" title=\"纯虚函数和纯虚类：\"></a>纯虚函数和纯虚类：</h3><h4 id=\"什么是纯虚函数和纯虚类：\"><a href=\"#什么是纯虚函数和纯虚类：\" class=\"headerlink\" title=\"什么是纯虚函数和纯虚类：\"></a>什么是纯虚函数和纯虚类：</h4><ul>\n<li>没有定义函数体的虚成员函数成为纯虚函数：<br>virtual int getValue() = 0; // a pure virtual function<br>包含一个或多个纯虚函数的类成为纯虚类<br>虚基类是不能被对象化的，当对象化后调用纯虚函数，就会出现错误  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Base base; <span class=\"comment\">// We can't instantiate an abstract base class, but for the sake of example, pretend this was allowed</span></span><br><span class=\"line\">    base.getValue(); <span class=\"comment\">// what would this do?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"为什么需要纯虚函数和纯虚类？\"><a href=\"#为什么需要纯虚函数和纯虚类？\" class=\"headerlink\" title=\"为什么需要纯虚函数和纯虚类？\"></a>为什么需要纯虚函数和纯虚类？</h4><p>当子类继承了基类后，对虚函数来讲，需要复写基类的虚函数，而当忘记去写时，默认就会调用基类的虚函数；<br>而如果将基类的虚函数定义为纯虚函数。就会通过编译报错来提醒我们要复写子类的虚函数：<br> 例子：<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> // <span class=\"title\">This</span> <span class=\"title\">Animal</span> <span class=\"title\">is</span> <span class=\"title\">an</span> <span class=\"title\">abstract</span> <span class=\"title\">base</span> <span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> m_name;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Animal(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : m_name(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_name; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>; <span class=\"comment\">// note that speak is now a pure virtual function</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cow</span>:</span> <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Cow(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : Animal(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// We forgot to redefine speak</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Cow <span class=\"title\">cow</span><span class=\"params\">(<span class=\"string\">\"Betsy\"</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class=\"string\">\" says \"</span> &lt;&lt; cow.speak() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cow</span>:</span> <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Cow(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : Animal(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Moo\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Cow <span class=\"title\">cow</span><span class=\"params\">(<span class=\"string\">\"Betsy\"</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class=\"string\">\" says \"</span> &lt;&lt; cow.speak() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当想要使用虚基类的实现时，又同时想让虚基类不能对象化且子类能提示需要实现纯虚函数时，应该怎么做？<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt; </span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> // <span class=\"title\">This</span> <span class=\"title\">Animal</span> <span class=\"title\">is</span> <span class=\"title\">an</span> <span class=\"title\">abstract</span> <span class=\"title\">base</span> <span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> m_name;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Animal(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : m_name(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_name; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>; <span class=\"comment\">// note that speak is a pure virtual function</span></span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* Animal::speak()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"buzz\"</span>; <span class=\"comment\">// some default implementation</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dragonfly</span>:</span> <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Dragonfly(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : Animal(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"comment\">// this class is no longer abstract because we defined this function</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Animal::speak(); <span class=\"comment\">// use Animal's default implementation</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Dragonfly <span class=\"title\">dfly</span><span class=\"params\">(<span class=\"string\">\"Sally\"</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; dfly.getName() &lt;&lt; <span class=\"string\">\" says \"</span> &lt;&lt; dfly.speak() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">The above code prints:</span><br><span class=\"line\">Sally says buzz</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"接口类：\"><a href=\"#接口类：\" class=\"headerlink\" title=\"接口类：\"></a>接口类：</h4><p>接口类的类中没有成员变量。全部由纯虚函数构成；常命名为I开头的:如IErrorLog,类似于java中的接口<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IErrorLog</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">openLog</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *filename)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">closeLog</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">writeError</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *errorMessage)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~IErrorLog() &#123;&#125;; <span class=\"comment\">// make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"virtual-base-class\"><a href=\"#virtual-base-class\" class=\"headerlink\" title=\"virtual base class\"></a>virtual base class</h4><p>当普通的继承，即一个子类继承自两个不同的父类，这两个父类继承自同一个基类时。就容易出现问题：<br>如：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoweredDevice</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    PoweredDevice(<span class=\"keyword\">int</span> power)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"PoweredDevice: \"</span> &lt;&lt; power &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scanner</span>:</span> <span class=\"keyword\">public</span> PoweredDevice</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Scanner(<span class=\"keyword\">int</span> scanner, <span class=\"keyword\">int</span> power)</span><br><span class=\"line\">        : PoweredDevice(power)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Scanner: \"</span> &lt;&lt; scanner &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Printer</span>:</span> <span class=\"keyword\">public</span> PoweredDevice</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Printer(<span class=\"keyword\">int</span> printer, <span class=\"keyword\">int</span> power)</span><br><span class=\"line\">        : PoweredDevice(power)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Printer: \"</span> &lt;&lt; printer &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Copier</span>:</span> <span class=\"keyword\">public</span> Scanner, <span class=\"keyword\">public</span> Printer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Copier(<span class=\"keyword\">int</span> scanner, <span class=\"keyword\">int</span> printer, <span class=\"keyword\">int</span> power)</span><br><span class=\"line\">        : Scanner(scanner, power), Printer(printer, power)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Copier <span class=\"title\">copier</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">PoweredDevice: <span class=\"number\">3</span></span><br><span class=\"line\">Scanner: <span class=\"number\">1</span></span><br><span class=\"line\">PoweredDevice: <span class=\"number\">3</span></span><br><span class=\"line\">Printer: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>从输出看，基类被构造了两次<br>如何防止构造两个基类呢？使用virtual base class<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoweredDevice</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scanner</span>:</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> PoweredDevice</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Printer</span>:</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> PoweredDevice</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Copier</span>:</span> <span class=\"keyword\">public</span> Scanner, <span class=\"keyword\">public</span> Printer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoweredDevice</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    PoweredDevice(<span class=\"keyword\">int</span> power)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"PoweredDevice: \"</span> &lt;&lt; power &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scanner</span>:</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> PoweredDevice <span class=\"comment\">// note: PoweredDevice is now a virtual base class</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Scanner(<span class=\"keyword\">int</span> scanner, <span class=\"keyword\">int</span> power)</span><br><span class=\"line\">        : PoweredDevice(power) <span class=\"comment\">// this line is required to create Scanner objects, but ignored in this case</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Scanner: \"</span> &lt;&lt; scanner &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Printer</span>:</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> PoweredDevice <span class=\"comment\">// note: PoweredDevice is now a virtual base class</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Printer(<span class=\"keyword\">int</span> printer, <span class=\"keyword\">int</span> power)</span><br><span class=\"line\">        : PoweredDevice(power) <span class=\"comment\">// this line is required to create Printer objects, but ignored in this case</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Printer: \"</span> &lt;&lt; printer &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Copier</span>:</span> <span class=\"keyword\">public</span> Scanner, <span class=\"keyword\">public</span> Printer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Copier(<span class=\"keyword\">int</span> scanner, <span class=\"keyword\">int</span> printer, <span class=\"keyword\">int</span> power)</span><br><span class=\"line\">        : Scanner(scanner, power), Printer(printer, power),</span><br><span class=\"line\">        PoweredDevice(power) <span class=\"comment\">// PoweredDevice is constructed here</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">This time, our previous example:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Copier <span class=\"title\">copier</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">produces the result:</span><br><span class=\"line\">PoweredDevice: <span class=\"number\">3</span></span><br><span class=\"line\">Scanner: <span class=\"number\">1</span></span><br><span class=\"line\">Printer: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>这样的话，基类的构造交给了继承琏最底层的类</p>\n<ul>\n<li>注意：</li>\n<li>virtual base class在子类对象之前就创建了</li>\n<li>if Copier was singly inherited from Printer, and Printer was virtually inherited from PoweredDevice, Copier is still responsible for creating PoweredDevice</li>\n<li>Fourth, a virtual base class is always considered a direct base of its most derived class<br>(which is why the most derived class is responsible for its construction).</li>\n<li>But classes inheriting the virtual base still need access to it. So in order to facilitate this, the compiler creates a virtual table for each class directly inheriting the virtual class (Printer and Scanner). These virtual tables point to the functions in the most derived class. Because the derived classes have a virtual table,  that also means they are now larger by a pointer (to the virtual table).</li>\n</ul>\n<h4 id=\"对象分割：\"><a href=\"#对象分割：\" class=\"headerlink\" title=\"对象分割：\"></a>对象分割：</h4><p>当子类对象赋值给基类会发生什么？<br>子类对象的基类部分会给基类对象<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">derived</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">    Base base = derived; <span class=\"comment\">// what happens here?</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"base is a \"</span> &lt;&lt; base.getName() &lt;&lt; <span class=\"string\">\" and has value \"</span> &lt;&lt; base.getValue() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">传值给基类</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printName</span><span class=\"params\">(<span class=\"keyword\">const</span> Base base)</span> <span class=\"comment\">// note: base passed by value, not reference</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"I am a \"</span> &lt;&lt; base.getName() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">This is a pretty simple function with a <span class=\"keyword\">const</span> base object parameter that is passed by value. If we call <span class=\"keyword\">this</span> function like such:\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">    printName(d); <span class=\"comment\">// oops, didn't realize this was pass by value on the calling end </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>vector<base>和vector&lt;&amp;base&gt;和vector&lt;base*&gt;<br>第一种可以但是只能调用基类的部分<br>第二种不行：std::vector&lt;Base&amp;&gt; v;<br>Unfortunately, this won’t compile. The elements of std::vector must be assignable, whereas references can’t be reassigned (only initialized).<br>第三种可以但是要做delete<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Base*&gt; v;</span><br><span class=\"line\">\tv.push_back(<span class=\"keyword\">new</span> Base(<span class=\"number\">5</span>)); <span class=\"comment\">// add a Base object to our vector</span></span><br><span class=\"line\">\tv.push_back(<span class=\"keyword\">new</span> Derived(<span class=\"number\">6</span>)); <span class=\"comment\">// add a Derived object to our vector</span></span><br><span class=\"line\">        <span class=\"comment\">// Print out all of the elements in our vector</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; count &lt; v.size(); ++count)</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"I am a \"</span> &lt;&lt; v[count]-&gt;getName() &lt;&lt; <span class=\"string\">\" with value \"</span> &lt;&lt; v[count]-&gt;getValue() &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; count &lt; v.size(); ++count)</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> v[count];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">用智能指针可以避免：</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt; // for std::reference_wrapper</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::reference_wrapper&lt;Base&gt; &gt; v; <span class=\"comment\">// our vector is a vector of std::reference_wrapper wrapped Base (not Base&amp;)</span></span><br><span class=\"line\">\t<span class=\"function\">Base <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>; <span class=\"comment\">// b and d can't be anonymous objects</span></span><br><span class=\"line\">\t<span class=\"function\">Derived <span class=\"title\">d</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">\tv.push_back(b); <span class=\"comment\">// add a Base object to our vector</span></span><br><span class=\"line\">\tv.push_back(d); <span class=\"comment\">// add a Derived object to our vector</span></span><br><span class=\"line\">\t<span class=\"comment\">// Print out all of the elements in our vector</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; count &lt; v.size(); ++count)</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"I am a \"</span> &lt;&lt; v[count].get().getName() &lt;&lt; <span class=\"string\">\" with value \"</span> &lt;&lt; v[count].get().getValue() &lt;&lt; <span class=\"string\">\"\\n\"</span>; <span class=\"comment\">// we use .get() to get our element from the wrapper</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一种极端情况：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d1</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d2</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">    Base &amp;b = d2;<span class=\"comment\">//b为d2的引用</span></span><br><span class=\"line\">    b = d1; <span class=\"comment\">// this line is problematic　导致b的基类部分为d1,子类部分为d2,因为b是d2的引用，导致现在d2的基类部分是d1而子类部分是d2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"总结多态的方式＋dynamic-cast\"><a href=\"#总结多态的方式＋dynamic-cast\" class=\"headerlink\" title=\"总结多态的方式＋dynamic_cast:\"></a>总结多态的方式＋dynamic_cast:</h4><ul>\n<li><p>　shape <em>ps=new circle();<br>  经由virtual func:  ps-&gt;rotate()    //virtual func<br>  经由dynamic_cast:和type运算符：<br>  if(circle </em>pc=dynamic_cast&lt;circle*&gt;(ps))</p>\n<p>  (理解了指针类型的本质就可以理解它和理解分割的内容了:指针的类型会教导编译器如何解释某个特定地址的内容和大小:<br>  所以一个void*的指针无法去确定涵盖多大的地址空间，所以它只能含有一个地址但是不能操作它指向的Ｏｂｊｅｃｔ<br>  所以转型只是一种编译器指令，不改变真正的地址，而是改变解读指针的方式让它指出其内存的大小和内容）<br>  更多见内存布局第一章图就能理解）</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"多态：\"><a href=\"#多态：\" class=\"headerlink\" title=\"多态：\"></a>多态：</h3><h4 id=\"为什么需要多态？\"><a href=\"#为什么需要多态？\" class=\"headerlink\" title=\"为什么需要多态？\"></a>为什么需要多态？</h4><p>引入几个点：<br>　　继承的机制中，基类的指针和引用能指向派生类，（派生类对象中的基类成员是在内存前面的，即指向派生类对象的指针指向的是第一个基类的第一个成员）  </p>\n<ul>\n<li>指针的值本质上是内存地址，也就是说指向不同变量(int char.)，对象的指针本身的值都是地址的value)</li>\n<li>指针的类型限定了指针的操作内存范围和取值的方式，如通过int指针取值的时候，取到４byte,通过char指针取值时取得1byte;）","more":"</li>\n<li>因此，基类指针限定了，即使它指向派生类，它也只能操作基类自身的成员和方法；就像char形指针指向int形，取得的只是一部分）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　<span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"number\">3</span> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"> <span class=\"number\">4</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"> 5 </span>&#123;</span><br><span class=\"line\"> <span class=\"number\">6</span>     <span class=\"keyword\">int</span> in=<span class=\"number\">2</span>;</span><br><span class=\"line\"> <span class=\"number\">7</span>     <span class=\"keyword\">char</span> *pc=(<span class=\"keyword\">char</span>*)&amp;in;</span><br><span class=\"line\"> <span class=\"number\">8</span>     <span class=\"built_in\">cout</span>&lt;&lt;*pc&lt;&lt;<span class=\"built_in\">endl</span>;<span class=\"comment\">//乱码</span></span><br><span class=\"line\"> <span class=\"number\">9</span>     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">10</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>所以基类指针可以指向子类，但是只能调用基类的函数，即使子类复写了父类的函数<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Base\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Derived\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Derived derived;</span><br><span class=\"line\">    Base &amp;rBase = derived;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"rBase is a \"</span> &lt;&lt; rBase.getName() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>This example prints the result:</p>\n<p>rBase is a Base</p>\n<p>/＝》简化：如何让下面的例子得到想要的结果？<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal *animals[] = &#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> iii=<span class=\"number\">0</span>; iii &lt; <span class=\"number\">6</span>; iii++)</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; animals[iii]-&gt;getName() &lt;&lt; <span class=\"string\">\" says \"</span> &lt;&lt; animals[iii]-&gt;speak() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>如何让父类指针指向子类对象，可以调用子类函数呢？<pre><code>－－－多态\n</code></pre></li>\n<li>调用的子类函数要满足:<br>A derived function is considered a match if it has the same signature (name, parameter types, and whether it is const) and return type as the base version of the function. Such functions are called overrides.</li>\n</ul>\n<h4 id=\"如何使用－－－例子\"><a href=\"#如何使用－－－例子\" class=\"headerlink\" title=\"如何使用－－－例子\"></a>如何使用－－－例子</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Base\"</span>; &#125; <span class=\"comment\">// note addition of virtual keyword</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Derived\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Derived derived;</span><br><span class=\"line\">    Base &amp;rBase = derived;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"rBase is a \"</span> &lt;&lt; rBase.getName() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>This example prints the result:</p>\n<p>rBase is a Derived<br>－－－－－－－－－－－－－－－－－－－－－－－<br>再盗一个例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> m_name;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// We're making this constructor protected because</span></span><br><span class=\"line\">    <span class=\"comment\">// we don't want people creating Animal objects directly,</span></span><br><span class=\"line\">    <span class=\"comment\">// but we still want derived classes to be able to use it.</span></span><br><span class=\"line\">    Animal(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : m_name(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_name; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"???\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span>:</span> <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Cat(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : Animal(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Meow\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span> <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Dog(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : Animal(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Woof\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">report</span><span class=\"params\">(Animal &amp;animal)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; animal.getName() &lt;&lt; <span class=\"string\">\" says \"</span> &lt;&lt; animal.speak() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Cat <span class=\"title\">cat</span><span class=\"params\">(<span class=\"string\">\"Fred\"</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Dog <span class=\"title\">dog</span><span class=\"params\">(<span class=\"string\">\"Garbo\"</span>)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    report(cat);</span><br><span class=\"line\">    report(dog);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"注意多态的方式：\"><a href=\"#注意多态的方式：\" class=\"headerlink\" title=\"注意多态的方式：\"></a>注意多态的方式：</h4><p>调用基类指针指向子类，函数时，会调用到继承琏最底端，且该最低端的子类有该virtual函数的，否则只调用到最下且复写了该函数的。如下例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">1</span> <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"number\">2</span> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"> <span class=\"number\">3</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\"> 4 &#123;</span></span><br><span class=\"line\"> <span class=\"number\">5</span>         <span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"number\">6</span>                     <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\"> <span class=\"number\">7</span> &#125;;</span><br><span class=\"line\"> <span class=\"number\">8</span> </span><br><span class=\"line\"> <span class=\"number\">9</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\"><span class=\"number\">10</span> &#123;</span><br><span class=\"line\"><span class=\"number\">11</span>         <span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"number\">12</span>                     <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125;</span><br><span class=\"line\"><span class=\"number\">13</span> &#125;;</span><br><span class=\"line\"><span class=\"number\">14</span> </span><br><span class=\"line\"><span class=\"number\">15</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>:</span> <span class=\"keyword\">public</span> B</span><br><span class=\"line\"><span class=\"number\">16</span> &#123;</span><br><span class=\"line\"><span class=\"number\">17</span>         <span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"number\">18</span>                     <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>; &#125;</span><br><span class=\"line\">                       <span class=\"comment\">//or const char * getName()&#123;..&#125; and default virtual</span></span><br><span class=\"line\"><span class=\"number\">19</span> &#125;;</span><br><span class=\"line\"><span class=\"number\">20</span> </span><br><span class=\"line\"><span class=\"number\">21</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span> <span class=\"keyword\">public</span> C</span><br><span class=\"line\"><span class=\"number\">22</span> &#123;</span><br><span class=\"line\"><span class=\"number\">23</span>         <span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"number\">24</span>                    <span class=\"comment\">// virtual const char* getName() &#123; return \"D\"; &#125;</span></span><br><span class=\"line\"><span class=\"number\">25</span> &#125;;</span><br><span class=\"line\"><span class=\"number\">26</span> </span><br><span class=\"line\"><span class=\"number\">27</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">28 </span>&#123;</span><br><span class=\"line\"><span class=\"number\">29</span>             D d;</span><br><span class=\"line\"><span class=\"number\">30</span>             A &amp;rBase = d;</span><br><span class=\"line\"><span class=\"number\">31</span>             <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"rBase is a \"</span> &lt;&lt; rBase.getName() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"><span class=\"number\">32</span> </span><br><span class=\"line\"><span class=\"number\">33</span>             <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">34</span> &#125;</span><br></pre></td></tr></table></figure></p>\n<pre><code>输出c\n</code></pre><h4 id=\"注意点：\"><a href=\"#注意点：\" class=\"headerlink\" title=\"注意点：\"></a>注意点：</h4><ul>\n<li>virtual关键字是否都需要写？：<br>Only the most base class function needs to be tagged as virtual for all of the derived<br>functions to work virtually. However, having the keyword virtual on the derived functions<br>does not hurt, and it serves as a useful reminder that the function is a virtual function<br>rather than a normal one.</li>\n</ul>\n<ul>\n<li><p>不能在构造函数和西沟函数中调用它，因为此时子类对象还没有被构造</p>\n</li>\n<li><p>c++11引入override和final来防止避免不匹配的复写和阻止继承：<br>１）override:<br>出现错误的例子:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName1</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName1</span><span class=\"params\">(<span class=\"keyword\">short</span> <span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125; <span class=\"comment\">// note: parameter is a short int</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125; <span class=\"comment\">// note: function is const</span></span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tB b;</span><br><span class=\"line\">\tA &amp;rBase = b;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; rBase.getName1(<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; rBase.getName2(<span class=\"number\">2</span>) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p> 由于参数返回值不匹配，所以编译器认为不是复写，结果：<br> A<br>A<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加入override:</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName1</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName3</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName1</span><span class=\"params\">(<span class=\"keyword\">short</span> <span class=\"keyword\">int</span> x)</span> override </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125; <span class=\"comment\">// compile error, function is not an override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName2</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> <span class=\"keyword\">const</span> override </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125; <span class=\"comment\">// compile error, function is not an override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName3</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> override </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125; <span class=\"comment\">// okay, function is an override of A::getName3(int) </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">Rule: Apply the override specifier to every intended override function you write.</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>final:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 加了final的函数无法被复写：</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// note use of final specifier on following line -- that makes this function no longer overridable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> override final </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125; <span class=\"comment\">// okay, overrides A::getName()</span></span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> :</span> <span class=\"keyword\">public</span> B</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> override </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>; &#125; <span class=\"comment\">// compile error: overrides B::getName(), which is final</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> 加了final的类不能被继承：</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"title\">final</span> :</span> <span class=\"keyword\">public</span> A <span class=\"comment\">// note use of final specifier here</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> override </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> :</span> <span class=\"keyword\">public</span> B <span class=\"comment\">// compile error: cannot inherit from final class</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> override </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> `</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>对匹配返回值的一个“例外”：covariant return types:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// This version of getThis() returns a pointer to a Base class</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Base* <span class=\"title\">getThis</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Normally override functions have to return objects of the same type as the base function</span></span><br><span class=\"line\">    <span class=\"comment\">// However, because Derived is derived from Base, it's okay to return Derived* instead of Base*</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Derived* <span class=\"title\">getThis</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意当base=&derive;<br>     base.getThis()—-取得的任然是base</p>\n<h4 id=\"当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：\"><a href=\"#当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：\" class=\"headerlink\" title=\"当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：\"></a>当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Derived derived;</span><br><span class=\"line\">    Base &amp;base = derived;</span><br><span class=\"line\">    <span class=\"comment\">// Calls Base::GetName() instead of the virtualized Derived::GetName()</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; base.Base::getName() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"虚析构函数-：\"><a href=\"#虚析构函数-：\" class=\"headerlink\" title=\"虚析构函数　：\"></a>虚析构函数　：</h3><h4 id=\"为什么需要虚析构函数：\"><a href=\"#为什么需要虚析构函数：\" class=\"headerlink\" title=\"为什么需要虚析构函数：\"></a>为什么需要虚析构函数：</h4><p> 当基类指针指向派生类时，当析构后，只会调用基类的析构函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~Base() <span class=\"comment\">// note: not virtual</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Calling ~Base()\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* m_array;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Derived(<span class=\"keyword\">int</span> length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_array = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Derived() <span class=\"comment\">// note: not virtual</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Calling ~Derived()\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] m_array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Derived *derived = <span class=\"keyword\">new</span> Derived(<span class=\"number\">5</span>);</span><br><span class=\"line\">    Base *base = derived ;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> base;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 只输出Calling ~Base()</p>\n<ul>\n<li>所以为了调用派生类的析构函数，需要定义为虚析构函数：<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Base() <span class=\"comment\">// note: virtual</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Calling ~Base()\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* m_array;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Derived(<span class=\"keyword\">int</span> length)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_array = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Derived() <span class=\"comment\">// note: virtual</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Calling ~Derived()\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] m_array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Derived *derived = <span class=\"keyword\">new</span> Derived(<span class=\"number\">5</span>);</span><br><span class=\"line\">    Base *base = derived;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> base;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Now <span class=\"keyword\">this</span> program produces the following result:</span><br><span class=\"line\">Calling ~Derived()</span><br><span class=\"line\">Calling ~Base()</span><br><span class=\"line\">Rule: Whenever you are dealing with inheritance, you should make any <span class=\"keyword\">explicit</span> destructors <span class=\"keyword\">virtual</span>.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"虚表：\"><a href=\"#虚表：\" class=\"headerlink\" title=\"虚表：\"></a>虚表：</h3><h4 id=\"Early-binding（静态绑定）-and-late-binding（动态绑定）\"><a href=\"#Early-binding（静态绑定）-and-late-binding（动态绑定）\" class=\"headerlink\" title=\"Early binding（静态绑定） and late binding（动态绑定）\"></a>Early binding（静态绑定） and late binding（动态绑定）</h4><p> 前者指的是直接在代码里调用函数，通过函数名，即编译期间就可以直到函数的地址的（偏移，非真实的内存地址）<br>“” Early binding (also called static binding) means the compiler (or linker) is able to directly associate the identifier name (such as a function or variable name) with a machine address.<br> Remember that all functions have a unique address. So when the compiler (or linker) encounters a function call,<br>  it replaces the function call with a machine language instruction that tells the CPU to jump to the address of the function.””<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">subtract</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x - y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Enter a number: \"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Enter another number: \"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> op;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Enter an operation (0=add, 1=subtract, 2=multiply): \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; op;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (op &lt; <span class=\"number\">0</span> || op &gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (op)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// call the target function directly using early binding</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>: result = add(x, y); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: result = subtract(x, y); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>: result = multiply(x, y); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The answer is: \"</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> 后者指的是通过函数指针等方式，即在编译期间无法确定调用什么函数，需要通过指针来访问函数（函数指针），效率比前者低<br> in some programs, it is not possible to know which function will be called until runtime (when the program is run).<br> This is known as late binding (or dynamic binding). In C++, one way to get late binding is to use function pointers.<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a function pointer and make it point to the Add function</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*pFcn)(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>) = add;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; pFcn(<span class=\"number\">5</span>, <span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">// add 5 + 3</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"虚表\"><a href=\"#虚表\" class=\"headerlink\" title=\"虚表\"></a>虚表</h4><p> 为什么虚函数能成立－－基类指针指向派生类能调用派生类的函数：<br> 实际上，在定义了虚函数的基类中维护了一个虚指针：它指向一张表，表中包含各个虚函数指针；在这个继承琏中的每一个类有自己的一张虚表，这张表由编译器在编译期间生成, 虚指针在包含虚函数的类的对象被创建时自动创建<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function1</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function2</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D1</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function1</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D2</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function2</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"> 实际上为：</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    FunctionPointer *__vptr;<span class=\"comment\">//虚指针</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function1</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function2</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D1</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function1</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D2</span>:</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function2</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> base</span><br><span class=\"line\">    *__vptr;--------------------------&gt;base vtable</span><br><span class=\"line\">   virtual function1()&lt;----------------function1()</span><br><span class=\"line\">|-&gt;virtual function2()&lt;----------------function2()</span><br><span class=\"line\">-----------------------------------------------------|</span><br><span class=\"line\">   D1:<span class=\"keyword\">public</span> base                                    |</span><br><span class=\"line\">   *__vptr,(inherited) ----------------D1 vtable     |</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"title\">function1</span><span class=\"params\">()</span></span>; &lt;--------------function1()   |</span><br><span class=\"line\">                                       function2()----</span><br><span class=\"line\"> D2类似D1</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"纯虚函数和纯虚类：\"><a href=\"#纯虚函数和纯虚类：\" class=\"headerlink\" title=\"纯虚函数和纯虚类：\"></a>纯虚函数和纯虚类：</h3><h4 id=\"什么是纯虚函数和纯虚类：\"><a href=\"#什么是纯虚函数和纯虚类：\" class=\"headerlink\" title=\"什么是纯虚函数和纯虚类：\"></a>什么是纯虚函数和纯虚类：</h4><ul>\n<li>没有定义函数体的虚成员函数成为纯虚函数：<br>virtual int getValue() = 0; // a pure virtual function<br>包含一个或多个纯虚函数的类成为纯虚类<br>虚基类是不能被对象化的，当对象化后调用纯虚函数，就会出现错误  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Base base; <span class=\"comment\">// We can't instantiate an abstract base class, but for the sake of example, pretend this was allowed</span></span><br><span class=\"line\">    base.getValue(); <span class=\"comment\">// what would this do?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"为什么需要纯虚函数和纯虚类？\"><a href=\"#为什么需要纯虚函数和纯虚类？\" class=\"headerlink\" title=\"为什么需要纯虚函数和纯虚类？\"></a>为什么需要纯虚函数和纯虚类？</h4><p>当子类继承了基类后，对虚函数来讲，需要复写基类的虚函数，而当忘记去写时，默认就会调用基类的虚函数；<br>而如果将基类的虚函数定义为纯虚函数。就会通过编译报错来提醒我们要复写子类的虚函数：<br> 例子：<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> // <span class=\"title\">This</span> <span class=\"title\">Animal</span> <span class=\"title\">is</span> <span class=\"title\">an</span> <span class=\"title\">abstract</span> <span class=\"title\">base</span> <span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> m_name;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Animal(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : m_name(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_name; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>; <span class=\"comment\">// note that speak is now a pure virtual function</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cow</span>:</span> <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Cow(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : Animal(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// We forgot to redefine speak</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Cow <span class=\"title\">cow</span><span class=\"params\">(<span class=\"string\">\"Betsy\"</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class=\"string\">\" says \"</span> &lt;&lt; cow.speak() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cow</span>:</span> <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Cow(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : Animal(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Moo\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Cow <span class=\"title\">cow</span><span class=\"params\">(<span class=\"string\">\"Betsy\"</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class=\"string\">\" says \"</span> &lt;&lt; cow.speak() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当想要使用虚基类的实现时，又同时想让虚基类不能对象化且子类能提示需要实现纯虚函数时，应该怎么做？<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt; </span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> // <span class=\"title\">This</span> <span class=\"title\">Animal</span> <span class=\"title\">is</span> <span class=\"title\">an</span> <span class=\"title\">abstract</span> <span class=\"title\">base</span> <span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> m_name;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Animal(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : m_name(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_name; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>; <span class=\"comment\">// note that speak is a pure virtual function</span></span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* Animal::speak()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"buzz\"</span>; <span class=\"comment\">// some default implementation</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dragonfly</span>:</span> <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Dragonfly(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name)</span><br><span class=\"line\">        : Animal(name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"comment\">// this class is no longer abstract because we defined this function</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Animal::speak(); <span class=\"comment\">// use Animal's default implementation</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Dragonfly <span class=\"title\">dfly</span><span class=\"params\">(<span class=\"string\">\"Sally\"</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; dfly.getName() &lt;&lt; <span class=\"string\">\" says \"</span> &lt;&lt; dfly.speak() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">The above code prints:</span><br><span class=\"line\">Sally says buzz</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"接口类：\"><a href=\"#接口类：\" class=\"headerlink\" title=\"接口类：\"></a>接口类：</h4><p>接口类的类中没有成员变量。全部由纯虚函数构成；常命名为I开头的:如IErrorLog,类似于java中的接口<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IErrorLog</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">openLog</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *filename)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">closeLog</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">writeError</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *errorMessage)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~IErrorLog() &#123;&#125;; <span class=\"comment\">// make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"virtual-base-class\"><a href=\"#virtual-base-class\" class=\"headerlink\" title=\"virtual base class\"></a>virtual base class</h4><p>当普通的继承，即一个子类继承自两个不同的父类，这两个父类继承自同一个基类时。就容易出现问题：<br>如：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoweredDevice</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    PoweredDevice(<span class=\"keyword\">int</span> power)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"PoweredDevice: \"</span> &lt;&lt; power &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scanner</span>:</span> <span class=\"keyword\">public</span> PoweredDevice</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Scanner(<span class=\"keyword\">int</span> scanner, <span class=\"keyword\">int</span> power)</span><br><span class=\"line\">        : PoweredDevice(power)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Scanner: \"</span> &lt;&lt; scanner &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Printer</span>:</span> <span class=\"keyword\">public</span> PoweredDevice</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Printer(<span class=\"keyword\">int</span> printer, <span class=\"keyword\">int</span> power)</span><br><span class=\"line\">        : PoweredDevice(power)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Printer: \"</span> &lt;&lt; printer &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Copier</span>:</span> <span class=\"keyword\">public</span> Scanner, <span class=\"keyword\">public</span> Printer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Copier(<span class=\"keyword\">int</span> scanner, <span class=\"keyword\">int</span> printer, <span class=\"keyword\">int</span> power)</span><br><span class=\"line\">        : Scanner(scanner, power), Printer(printer, power)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Copier <span class=\"title\">copier</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">PoweredDevice: <span class=\"number\">3</span></span><br><span class=\"line\">Scanner: <span class=\"number\">1</span></span><br><span class=\"line\">PoweredDevice: <span class=\"number\">3</span></span><br><span class=\"line\">Printer: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>从输出看，基类被构造了两次<br>如何防止构造两个基类呢？使用virtual base class<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoweredDevice</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scanner</span>:</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> PoweredDevice</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Printer</span>:</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> PoweredDevice</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Copier</span>:</span> <span class=\"keyword\">public</span> Scanner, <span class=\"keyword\">public</span> Printer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoweredDevice</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    PoweredDevice(<span class=\"keyword\">int</span> power)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"PoweredDevice: \"</span> &lt;&lt; power &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scanner</span>:</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> PoweredDevice <span class=\"comment\">// note: PoweredDevice is now a virtual base class</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Scanner(<span class=\"keyword\">int</span> scanner, <span class=\"keyword\">int</span> power)</span><br><span class=\"line\">        : PoweredDevice(power) <span class=\"comment\">// this line is required to create Scanner objects, but ignored in this case</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Scanner: \"</span> &lt;&lt; scanner &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Printer</span>:</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> PoweredDevice <span class=\"comment\">// note: PoweredDevice is now a virtual base class</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Printer(<span class=\"keyword\">int</span> printer, <span class=\"keyword\">int</span> power)</span><br><span class=\"line\">        : PoweredDevice(power) <span class=\"comment\">// this line is required to create Printer objects, but ignored in this case</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Printer: \"</span> &lt;&lt; printer &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Copier</span>:</span> <span class=\"keyword\">public</span> Scanner, <span class=\"keyword\">public</span> Printer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Copier(<span class=\"keyword\">int</span> scanner, <span class=\"keyword\">int</span> printer, <span class=\"keyword\">int</span> power)</span><br><span class=\"line\">        : Scanner(scanner, power), Printer(printer, power),</span><br><span class=\"line\">        PoweredDevice(power) <span class=\"comment\">// PoweredDevice is constructed here</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">This time, our previous example:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Copier <span class=\"title\">copier</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">produces the result:</span><br><span class=\"line\">PoweredDevice: <span class=\"number\">3</span></span><br><span class=\"line\">Scanner: <span class=\"number\">1</span></span><br><span class=\"line\">Printer: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>这样的话，基类的构造交给了继承琏最底层的类</p>\n<ul>\n<li>注意：</li>\n<li>virtual base class在子类对象之前就创建了</li>\n<li>if Copier was singly inherited from Printer, and Printer was virtually inherited from PoweredDevice, Copier is still responsible for creating PoweredDevice</li>\n<li>Fourth, a virtual base class is always considered a direct base of its most derived class<br>(which is why the most derived class is responsible for its construction).</li>\n<li>But classes inheriting the virtual base still need access to it. So in order to facilitate this, the compiler creates a virtual table for each class directly inheriting the virtual class (Printer and Scanner). These virtual tables point to the functions in the most derived class. Because the derived classes have a virtual table,  that also means they are now larger by a pointer (to the virtual table).</li>\n</ul>\n<h4 id=\"对象分割：\"><a href=\"#对象分割：\" class=\"headerlink\" title=\"对象分割：\"></a>对象分割：</h4><p>当子类对象赋值给基类会发生什么？<br>子类对象的基类部分会给基类对象<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">derived</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">    Base base = derived; <span class=\"comment\">// what happens here?</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"base is a \"</span> &lt;&lt; base.getName() &lt;&lt; <span class=\"string\">\" and has value \"</span> &lt;&lt; base.getValue() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">传值给基类</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printName</span><span class=\"params\">(<span class=\"keyword\">const</span> Base base)</span> <span class=\"comment\">// note: base passed by value, not reference</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"I am a \"</span> &lt;&lt; base.getName() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">This is a pretty simple function with a <span class=\"keyword\">const</span> base object parameter that is passed by value. If we call <span class=\"keyword\">this</span> function like such:\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">    printName(d); <span class=\"comment\">// oops, didn't realize this was pass by value on the calling end </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>vector<base>和vector&lt;&amp;base&gt;和vector&lt;base*&gt;<br>第一种可以但是只能调用基类的部分<br>第二种不行：std::vector&lt;Base&amp;&gt; v;<br>Unfortunately, this won’t compile. The elements of std::vector must be assignable, whereas references can’t be reassigned (only initialized).<br>第三种可以但是要做delete<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Base*&gt; v;</span><br><span class=\"line\">\tv.push_back(<span class=\"keyword\">new</span> Base(<span class=\"number\">5</span>)); <span class=\"comment\">// add a Base object to our vector</span></span><br><span class=\"line\">\tv.push_back(<span class=\"keyword\">new</span> Derived(<span class=\"number\">6</span>)); <span class=\"comment\">// add a Derived object to our vector</span></span><br><span class=\"line\">        <span class=\"comment\">// Print out all of the elements in our vector</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; count &lt; v.size(); ++count)</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"I am a \"</span> &lt;&lt; v[count]-&gt;getName() &lt;&lt; <span class=\"string\">\" with value \"</span> &lt;&lt; v[count]-&gt;getValue() &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; count &lt; v.size(); ++count)</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> v[count];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">用智能指针可以避免：</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt; // for std::reference_wrapper</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::reference_wrapper&lt;Base&gt; &gt; v; <span class=\"comment\">// our vector is a vector of std::reference_wrapper wrapped Base (not Base&amp;)</span></span><br><span class=\"line\">\t<span class=\"function\">Base <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>; <span class=\"comment\">// b and d can't be anonymous objects</span></span><br><span class=\"line\">\t<span class=\"function\">Derived <span class=\"title\">d</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">\tv.push_back(b); <span class=\"comment\">// add a Base object to our vector</span></span><br><span class=\"line\">\tv.push_back(d); <span class=\"comment\">// add a Derived object to our vector</span></span><br><span class=\"line\">\t<span class=\"comment\">// Print out all of the elements in our vector</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>; count &lt; v.size(); ++count)</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"I am a \"</span> &lt;&lt; v[count].get().getName() &lt;&lt; <span class=\"string\">\" with value \"</span> &lt;&lt; v[count].get().getValue() &lt;&lt; <span class=\"string\">\"\\n\"</span>; <span class=\"comment\">// we use .get() to get our element from the wrapper</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一种极端情况：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d1</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">d2</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">    Base &amp;b = d2;<span class=\"comment\">//b为d2的引用</span></span><br><span class=\"line\">    b = d1; <span class=\"comment\">// this line is problematic　导致b的基类部分为d1,子类部分为d2,因为b是d2的引用，导致现在d2的基类部分是d1而子类部分是d2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"总结多态的方式＋dynamic-cast\"><a href=\"#总结多态的方式＋dynamic-cast\" class=\"headerlink\" title=\"总结多态的方式＋dynamic_cast:\"></a>总结多态的方式＋dynamic_cast:</h4><ul>\n<li><p>　shape <em>ps=new circle();<br>  经由virtual func:  ps-&gt;rotate()    //virtual func<br>  经由dynamic_cast:和type运算符：<br>  if(circle </em>pc=dynamic_cast&lt;circle*&gt;(ps))</p>\n<p>  (理解了指针类型的本质就可以理解它和理解分割的内容了:指针的类型会教导编译器如何解释某个特定地址的内容和大小:<br>  所以一个void*的指针无法去确定涵盖多大的地址空间，所以它只能含有一个地址但是不能操作它指向的Ｏｂｊｅｃｔ<br>  所以转型只是一种编译器指令，不改变真正的地址，而是改变解读指针的方式让它指出其内存的大小和内容）<br>  更多见内存布局第一章图就能理解）</p>\n</li>\n</ul>"},{"title":"cpp_static","date":"2018-06-08T14:44:43.000Z","_content":"### c++关键词之static\n##### something share:\n其实，一开始学习c++的时候，并没有想去了解它的语法原理。虽然学c的时候，附带学了汇编，也学到了内存段，和学编译原理的时候顺带了解了它的相关词法语法处理。　　\n现在开始从原因，历史，内存，汇编等角度去看cpp，觉得清晰了一些。虽然没有去学习g++或者其他编译器<!--more-->\n如何处理c++的语法词法。这个想着以后如果有时间再研究吧。应该也是有工具去看，毕竟，g++是开源的，可以直接看源码如何处理C++\n\n\n\n#### static overiew \n+ static在c的时候就有，因存储的地方不同于局部变量(in static mem ,not in stack)，使得在函数代码块结束后不会被销毁。从而能持续整个程序.\n+ 静态存储区(data)：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。\n\n#### 目录：\n１、static概念和用法  \n２、static内存存储和汇编  \n３、static和类相关内容与原理  \n\n#### static概念：\n　static为静态修饰符。编译器遇到这个修饰符时将对应的变量存储在静态存储区(data)  　\n+ 根据类型：static可以修饰变量和函数，修饰对象和成员函数  \n+ 根据位置：静态局部变量和全局静态变量 -存于静态数据区(data)\n\n##### c中的static:\n+ 修饰变量：作用域是本程序文件，局部变量默认为auto,静态变量不管局部或者全局都存储于静态数据区，使得不会因为函数调用而销毁\n+ 修饰函数：只能用于本程序文件，普通函数默认为extern ,能被其他文件引用，static则不行\n\n\" 举个例子：  \n在stat.h中声明static int getstats()函数.  \n并在stat.c中实现它，static int getstats(){return xxx;}  \n在main中或者其他文件中使用这个函数  \n编译时报错未能找到该函数（未定义该函数)  \nc++中的static当和类无关时同c\" \n\n\n#### static使用和内存与汇编：\n##### static全局变量\n```c\n   static int global1=4;\n   12 int main()\n   13 {\n>> 14         int loc1=global1;\n\n_ZL7global1:\n\t.long\t4\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\n\n\tmovl\t_ZL7global1(%rip), %eax\n\tmovl\t%eax, -4(%rbp)\n//且可以通过kdbg看到在执行期，\nstatic变量的内存位置约为：\n(int *) 0x601048 <global1>　数据段地址\n局部变量的位置约为：\n(char **) 0x7ffff7a54530 <loc1>　栈地址```\n\n##### 静态局部变量\n```c \nint main()\n   13 {\n   14         static int locstatic1=5;\n>> 15         int loc1=global1;\n>> 16         int loc2=locstatic1;\n\n\tmovl\t_ZZ4mainE10locstatic1(%rip), %eax\n\tmovl\t%eax, -4(%rbp)\n\n_ZZ4mainE10locstatic1:\n\t.long\t5\n执行期：\n　　loca1 　(int *) 0x7fffffffd8a8\n　　loca2 (int *) 0x7fffffffd8ac\n\n  global1 (int *) 0x601048 <global1>\n  locstatic:(int *) 0x60104c <main::locstatic1>\n\t```\n##### static定义的变量和函数只能在本程序文件中使用\n要知道这个的原因可能有些复杂，一时半会也说不清，得先直到函数为什么能被外部引用：存在“符号表”中，能被外部链接，静态函数不在符号表中所以不行，类似这样吧，\n这块不太清楚，感觉是这个原因\n##### static函数：\n```c\n static  int getv()\n    4 {\n    5         int a=5;\n    6         a++;\n    7         cout<<a<<endl;\n    8         return 4;\n    9 } \n\n\t.type\t_ZL4getvv, @function\n_ZL4getvv:\n.LFB1021:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tsubq\t$16, %rsp\n　　　。。。。\n　\n```\n　\tcall\t_ZL4getvv\n从汇编代码看貌似跟普通函数没什么差别\n```c\n运行时\n　　static  int getv()\n{\n0x400816 push   %rbp\n0x400817 mov    %rsp,%rbp\n0x40081a sub    $0x10,%rsp\n\t\tint a=5;\n\t\ta++;\n\t\tcout<<a<<endl;\n\t\treturn 4;\n} \n\nstatic int global1=4;\nint main()\n{\n\t\tstatic int locstatic1=5;\n\t\tint loc1=global1;\n\t\tint loc2=locstatic1;\n//\t\tcout<<getv()<<endl;\n    \tgetv();\n0x400866 callq  0x400816 <getv()>\n```\n\n\n#### static和类相关\n##### static成员变量的使用\n static成员变量是类的所有对象共有的，但是只有一份，通过类也可以访问到\n```cpp\nclass Something\n{\npublic:\n    static int s_value; // declares the static member variable\n};\n \nint Something::s_value = 1; // defines the static member variable (we'll discuss this section below)\n \nint main()\n{\n    // note: we're not instantiating any objects of type Something\n \n    Something::s_value = 2;\n    std::cout << Something::s_value << '\\n';\n    return 0;\n}\n```\n```c\n_ZN9Something7s_valueE:\n\t.long\t1\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\n\n　　\n  Something::s_value=3;\n0x40081a movl   $0x3,0x20083c(%rip)        # 0x601060 <Something::s_value>\n（\tmovl\t_ZN9Something7s_valueE(%rip), %eax\n\tmovl\t%eax, %esi\n）\n可见类似于上述的，存在内存的数据段中\n```\n\n##### 类静态变量作用域\n静态成员在多个文件中:\n类中的机制，可以让定义在文件中的静态成员变量能被其他文件访问；加了作用域的声明，所以可以这样用\n```cpp\n在stati.h\n class Some{\n  2         public:\n  3                 static int s_v;\n  4 };\n  5 //static int s_vv;//error 错误\n\n在stati.cpp\n   #include\"stati.h\"\n  2 int Some::s_v=4;\n  3 //static int s_vv=5;error\n\n在main\n   #include \"stati.h\"\n\n  int gets= Some::s_v;\n\nother:\nclass Whatever\n{\npublic:\n    static const int s_value = 4; // a static const int can be declared and initialized directly\n};\n```\n##### 静态成员函数的使用\n+ 考虑一个问题，当静态成员被申明为private时，则无法使用它directly by class。  \nbut you can用非静态成员函数操作或者用静态成员函数操作to use it  \n+ 静态成员函数也是可以用类直接调用，它没有this指针，所以不能修改和访问对象的成员； \n+ （非静态成员func,它可以定义在类的内部或者外部，外部不用加static,这点和static成员不同，成员得在外部初始化－－因为public等定义成员时，非const不能赋值，而\nstatic不能修饰构造函数（对象相关），所以只能在外部初始化)\n\n```cpp\nclass IDGenerator\n{\nprivate:\n    static int s_nextID; // Here's the declaration for a static member\n \npublic:\n     static int getNextID(); // Here's the declaration for a static function\n};\n \n// Here's the definition of the static member outside the class.  Note we don't use the static keyword here.\n// We'll start generating IDs at 1\nint IDGenerator::s_nextID = 1;\n \n// Here's the definition of the static function outside of the class.  Note we don't use the static keyword here.\nint IDGenerator::getNextID() { return s_nextID++; } \n \nint main()\n{\n    for (int count=0; count < 5; ++count)\n        std::cout << \"The next ID is: \" << IDGenerator::getNextID() << '\\n';\n \n    return 0;\n}\n```","source":"_posts/cpp-static.md","raw":"---\ntitle: cpp_static\ndate: 2018-06-08 22:44:43\ntags: cpp_keyword\ncategories: c&cpp\n---\n### c++关键词之static\n##### something share:\n其实，一开始学习c++的时候，并没有想去了解它的语法原理。虽然学c的时候，附带学了汇编，也学到了内存段，和学编译原理的时候顺带了解了它的相关词法语法处理。　　\n现在开始从原因，历史，内存，汇编等角度去看cpp，觉得清晰了一些。虽然没有去学习g++或者其他编译器<!--more-->\n如何处理c++的语法词法。这个想着以后如果有时间再研究吧。应该也是有工具去看，毕竟，g++是开源的，可以直接看源码如何处理C++\n\n\n\n#### static overiew \n+ static在c的时候就有，因存储的地方不同于局部变量(in static mem ,not in stack)，使得在函数代码块结束后不会被销毁。从而能持续整个程序.\n+ 静态存储区(data)：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。\n\n#### 目录：\n１、static概念和用法  \n２、static内存存储和汇编  \n３、static和类相关内容与原理  \n\n#### static概念：\n　static为静态修饰符。编译器遇到这个修饰符时将对应的变量存储在静态存储区(data)  　\n+ 根据类型：static可以修饰变量和函数，修饰对象和成员函数  \n+ 根据位置：静态局部变量和全局静态变量 -存于静态数据区(data)\n\n##### c中的static:\n+ 修饰变量：作用域是本程序文件，局部变量默认为auto,静态变量不管局部或者全局都存储于静态数据区，使得不会因为函数调用而销毁\n+ 修饰函数：只能用于本程序文件，普通函数默认为extern ,能被其他文件引用，static则不行\n\n\" 举个例子：  \n在stat.h中声明static int getstats()函数.  \n并在stat.c中实现它，static int getstats(){return xxx;}  \n在main中或者其他文件中使用这个函数  \n编译时报错未能找到该函数（未定义该函数)  \nc++中的static当和类无关时同c\" \n\n\n#### static使用和内存与汇编：\n##### static全局变量\n```c\n   static int global1=4;\n   12 int main()\n   13 {\n>> 14         int loc1=global1;\n\n_ZL7global1:\n\t.long\t4\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\n\n\tmovl\t_ZL7global1(%rip), %eax\n\tmovl\t%eax, -4(%rbp)\n//且可以通过kdbg看到在执行期，\nstatic变量的内存位置约为：\n(int *) 0x601048 <global1>　数据段地址\n局部变量的位置约为：\n(char **) 0x7ffff7a54530 <loc1>　栈地址```\n\n##### 静态局部变量\n```c \nint main()\n   13 {\n   14         static int locstatic1=5;\n>> 15         int loc1=global1;\n>> 16         int loc2=locstatic1;\n\n\tmovl\t_ZZ4mainE10locstatic1(%rip), %eax\n\tmovl\t%eax, -4(%rbp)\n\n_ZZ4mainE10locstatic1:\n\t.long\t5\n执行期：\n　　loca1 　(int *) 0x7fffffffd8a8\n　　loca2 (int *) 0x7fffffffd8ac\n\n  global1 (int *) 0x601048 <global1>\n  locstatic:(int *) 0x60104c <main::locstatic1>\n\t```\n##### static定义的变量和函数只能在本程序文件中使用\n要知道这个的原因可能有些复杂，一时半会也说不清，得先直到函数为什么能被外部引用：存在“符号表”中，能被外部链接，静态函数不在符号表中所以不行，类似这样吧，\n这块不太清楚，感觉是这个原因\n##### static函数：\n```c\n static  int getv()\n    4 {\n    5         int a=5;\n    6         a++;\n    7         cout<<a<<endl;\n    8         return 4;\n    9 } \n\n\t.type\t_ZL4getvv, @function\n_ZL4getvv:\n.LFB1021:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tsubq\t$16, %rsp\n　　　。。。。\n　\n```\n　\tcall\t_ZL4getvv\n从汇编代码看貌似跟普通函数没什么差别\n```c\n运行时\n　　static  int getv()\n{\n0x400816 push   %rbp\n0x400817 mov    %rsp,%rbp\n0x40081a sub    $0x10,%rsp\n\t\tint a=5;\n\t\ta++;\n\t\tcout<<a<<endl;\n\t\treturn 4;\n} \n\nstatic int global1=4;\nint main()\n{\n\t\tstatic int locstatic1=5;\n\t\tint loc1=global1;\n\t\tint loc2=locstatic1;\n//\t\tcout<<getv()<<endl;\n    \tgetv();\n0x400866 callq  0x400816 <getv()>\n```\n\n\n#### static和类相关\n##### static成员变量的使用\n static成员变量是类的所有对象共有的，但是只有一份，通过类也可以访问到\n```cpp\nclass Something\n{\npublic:\n    static int s_value; // declares the static member variable\n};\n \nint Something::s_value = 1; // defines the static member variable (we'll discuss this section below)\n \nint main()\n{\n    // note: we're not instantiating any objects of type Something\n \n    Something::s_value = 2;\n    std::cout << Something::s_value << '\\n';\n    return 0;\n}\n```\n```c\n_ZN9Something7s_valueE:\n\t.long\t1\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\n\n　　\n  Something::s_value=3;\n0x40081a movl   $0x3,0x20083c(%rip)        # 0x601060 <Something::s_value>\n（\tmovl\t_ZN9Something7s_valueE(%rip), %eax\n\tmovl\t%eax, %esi\n）\n可见类似于上述的，存在内存的数据段中\n```\n\n##### 类静态变量作用域\n静态成员在多个文件中:\n类中的机制，可以让定义在文件中的静态成员变量能被其他文件访问；加了作用域的声明，所以可以这样用\n```cpp\n在stati.h\n class Some{\n  2         public:\n  3                 static int s_v;\n  4 };\n  5 //static int s_vv;//error 错误\n\n在stati.cpp\n   #include\"stati.h\"\n  2 int Some::s_v=4;\n  3 //static int s_vv=5;error\n\n在main\n   #include \"stati.h\"\n\n  int gets= Some::s_v;\n\nother:\nclass Whatever\n{\npublic:\n    static const int s_value = 4; // a static const int can be declared and initialized directly\n};\n```\n##### 静态成员函数的使用\n+ 考虑一个问题，当静态成员被申明为private时，则无法使用它directly by class。  \nbut you can用非静态成员函数操作或者用静态成员函数操作to use it  \n+ 静态成员函数也是可以用类直接调用，它没有this指针，所以不能修改和访问对象的成员； \n+ （非静态成员func,它可以定义在类的内部或者外部，外部不用加static,这点和static成员不同，成员得在外部初始化－－因为public等定义成员时，非const不能赋值，而\nstatic不能修饰构造函数（对象相关），所以只能在外部初始化)\n\n```cpp\nclass IDGenerator\n{\nprivate:\n    static int s_nextID; // Here's the declaration for a static member\n \npublic:\n     static int getNextID(); // Here's the declaration for a static function\n};\n \n// Here's the definition of the static member outside the class.  Note we don't use the static keyword here.\n// We'll start generating IDs at 1\nint IDGenerator::s_nextID = 1;\n \n// Here's the definition of the static function outside of the class.  Note we don't use the static keyword here.\nint IDGenerator::getNextID() { return s_nextID++; } \n \nint main()\n{\n    for (int count=0; count < 5; ++count)\n        std::cout << \"The next ID is: \" << IDGenerator::getNextID() << '\\n';\n \n    return 0;\n}\n```","slug":"cpp-static","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7o6001g2ujxkywxhbfj","content":"<h3 id=\"c-关键词之static\"><a href=\"#c-关键词之static\" class=\"headerlink\" title=\"c++关键词之static\"></a>c++关键词之static</h3><h5 id=\"something-share\"><a href=\"#something-share\" class=\"headerlink\" title=\"something share:\"></a>something share:</h5><p>其实，一开始学习c++的时候，并没有想去了解它的语法原理。虽然学c的时候，附带学了汇编，也学到了内存段，和学编译原理的时候顺带了解了它的相关词法语法处理。　　<br>现在开始从原因，历史，内存，汇编等角度去看cpp，觉得清晰了一些。虽然没有去学习g++或者其他编译器<a id=\"more\"></a><br>如何处理c++的语法词法。这个想着以后如果有时间再研究吧。应该也是有工具去看，毕竟，g++是开源的，可以直接看源码如何处理C++</p>\n<h4 id=\"static-overiew\"><a href=\"#static-overiew\" class=\"headerlink\" title=\"static overiew\"></a>static overiew</h4><ul>\n<li>static在c的时候就有，因存储的地方不同于局部变量(in static mem ,not in stack)，使得在函数代码块结束后不会被销毁。从而能持续整个程序.</li>\n<li>静态存储区(data)：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</li>\n</ul>\n<h4 id=\"目录：\"><a href=\"#目录：\" class=\"headerlink\" title=\"目录：\"></a>目录：</h4><p>１、static概念和用法<br>２、static内存存储和汇编<br>３、static和类相关内容与原理  </p>\n<h4 id=\"static概念：\"><a href=\"#static概念：\" class=\"headerlink\" title=\"static概念：\"></a>static概念：</h4><p>　static为静态修饰符。编译器遇到这个修饰符时将对应的变量存储在静态存储区(data)  　</p>\n<ul>\n<li>根据类型：static可以修饰变量和函数，修饰对象和成员函数  </li>\n<li>根据位置：静态局部变量和全局静态变量 -存于静态数据区(data)</li>\n</ul>\n<h5 id=\"c中的static\"><a href=\"#c中的static\" class=\"headerlink\" title=\"c中的static:\"></a>c中的static:</h5><ul>\n<li>修饰变量：作用域是本程序文件，局部变量默认为auto,静态变量不管局部或者全局都存储于静态数据区，使得不会因为函数调用而销毁</li>\n<li>修饰函数：只能用于本程序文件，普通函数默认为extern ,能被其他文件引用，static则不行</li>\n</ul>\n<p>“ 举个例子：<br>在stat.h中声明static int getstats()函数.<br>并在stat.c中实现它，static int getstats(){return xxx;}<br>在main中或者其他文件中使用这个函数<br>编译时报错未能找到该函数（未定义该函数)<br>c++中的static当和类无关时同c” </p>\n<h4 id=\"static使用和内存与汇编：\"><a href=\"#static使用和内存与汇编：\" class=\"headerlink\" title=\"static使用和内存与汇编：\"></a>static使用和内存与汇编：</h4><h5 id=\"static全局变量\"><a href=\"#static全局变量\" class=\"headerlink\" title=\"static全局变量\"></a>static全局变量</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> global1=<span class=\"number\">4</span>;</span><br><span class=\"line\">   <span class=\"number\">12</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   13 </span>&#123;</span><br><span class=\"line\">&gt;&gt; <span class=\"number\">14</span>         <span class=\"keyword\">int</span> loc1=global1;</span><br><span class=\"line\"></span><br><span class=\"line\">_ZL7global1:</span><br><span class=\"line\">\t.<span class=\"keyword\">long</span>\t<span class=\"number\">4</span></span><br><span class=\"line\">\t.text</span><br><span class=\"line\">\t.globl\tmain</span><br><span class=\"line\">\t.type\tmain, @function</span><br><span class=\"line\"></span><br><span class=\"line\">\tmovl\t_ZL7global1(%rip), %eax</span><br><span class=\"line\">\tmovl\t%eax, <span class=\"number\">-4</span>(%rbp)</span><br><span class=\"line\"><span class=\"comment\">//且可以通过kdbg看到在执行期，</span></span><br><span class=\"line\"><span class=\"keyword\">static</span>变量的内存位置约为：</span><br><span class=\"line\">(<span class=\"keyword\">int</span> *) <span class=\"number\">0x601048</span> &lt;global1&gt;　数据段地址</span><br><span class=\"line\">局部变量的位置约为：</span><br><span class=\"line\">(<span class=\"keyword\">char</span> **) <span class=\"number\">0x7ffff7a54530</span> &lt;loc1&gt;　栈地址</span><br></pre></td></tr></table></figure>\n<h5 id=\"静态局部变量\"><a href=\"#静态局部变量\" class=\"headerlink\" title=\"静态局部变量\"></a>静态局部变量</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   13 </span>&#123;</span><br><span class=\"line\">   <span class=\"number\">14</span>         <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> locstatic1=<span class=\"number\">5</span>;</span><br><span class=\"line\">&gt;&gt; <span class=\"number\">15</span>         <span class=\"keyword\">int</span> loc1=global1;</span><br><span class=\"line\">&gt;&gt; <span class=\"number\">16</span>         <span class=\"keyword\">int</span> loc2=locstatic1;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmovl\t_ZZ4mainE10locstatic1(%rip), %eax</span><br><span class=\"line\">\tmovl\t%eax, <span class=\"number\">-4</span>(%rbp)</span><br><span class=\"line\"></span><br><span class=\"line\">_ZZ4mainE10locstatic1:</span><br><span class=\"line\">\t.<span class=\"keyword\">long</span>\t<span class=\"number\">5</span></span><br><span class=\"line\">执行期：</span><br><span class=\"line\">　　loca1 　(<span class=\"keyword\">int</span> *) <span class=\"number\">0x7fffffffd8a8</span></span><br><span class=\"line\">　　loca2 (<span class=\"keyword\">int</span> *) <span class=\"number\">0x7fffffffd8ac</span></span><br><span class=\"line\"></span><br><span class=\"line\">  global1 (<span class=\"keyword\">int</span> *) <span class=\"number\">0x601048</span> &lt;global1&gt;</span><br><span class=\"line\">  locstatic:(<span class=\"keyword\">int</span> *) <span class=\"number\">0x60104c</span> &lt;main::locstatic1&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"static定义的变量和函数只能在本程序文件中使用\"><a href=\"#static定义的变量和函数只能在本程序文件中使用\" class=\"headerlink\" title=\"static定义的变量和函数只能在本程序文件中使用\"></a>static定义的变量和函数只能在本程序文件中使用</h5><p>要知道这个的原因可能有些复杂，一时半会也说不清，得先直到函数为什么能被外部引用：存在“符号表”中，能被外部链接，静态函数不在符号表中所以不行，类似这样吧，<br>这块不太清楚，感觉是这个原因</p>\n<h5 id=\"static函数：\"><a href=\"#static函数：\" class=\"headerlink\" title=\"static函数：\"></a>static函数：</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">static</span>  <span class=\"keyword\">int</span> <span class=\"title\">getv</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    4 </span>&#123;</span><br><span class=\"line\">    <span class=\"number\">5</span>         <span class=\"keyword\">int</span> a=<span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"number\">6</span>         a++;</span><br><span class=\"line\">    <span class=\"number\">7</span>         <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"number\">8</span>         <span class=\"keyword\">return</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"number\">9</span> &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">\t.type\t_ZL4getvv, @function</span><br><span class=\"line\">_ZL4getvv:</span><br><span class=\"line\">.LFB1021:</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset <span class=\"number\">16</span></span><br><span class=\"line\">\t.cfi_offset <span class=\"number\">6</span>, <span class=\"number\">-16</span></span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register <span class=\"number\">6</span></span><br><span class=\"line\">\tsubq\t$<span class=\"number\">16</span>, %rsp</span><br><span class=\"line\">　　　。。。。</span><br></pre></td></tr></table></figure>\n<p>　    call    _ZL4getvv<br>从汇编代码看貌似跟普通函数没什么差别<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行时</span><br><span class=\"line\">　　<span class=\"function\"><span class=\"keyword\">static</span>  <span class=\"keyword\">int</span> <span class=\"title\">getv</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"number\">0x400816</span> push   %rbp</span><br><span class=\"line\"><span class=\"number\">0x400817</span> mov    %rsp,%rbp</span><br><span class=\"line\"><span class=\"number\">0x40081a</span> sub    $<span class=\"number\">0x10</span>,%rsp</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a=<span class=\"number\">5</span>;</span><br><span class=\"line\">\t\ta++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> global1=<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> locstatic1=<span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> loc1=global1;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> loc2=locstatic1;</span><br><span class=\"line\"><span class=\"comment\">//\t\tcout&lt;&lt;getv()&lt;&lt;endl;</span></span><br><span class=\"line\">    \tgetv();</span><br><span class=\"line\"><span class=\"number\">0x400866</span> callq  <span class=\"number\">0x400816</span> &lt;getv()&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"static和类相关\"><a href=\"#static和类相关\" class=\"headerlink\" title=\"static和类相关\"></a>static和类相关</h4><h5 id=\"static成员变量的使用\"><a href=\"#static成员变量的使用\" class=\"headerlink\" title=\"static成员变量的使用\"></a>static成员变量的使用</h5><p> static成员变量是类的所有对象共有的，但是只有一份，通过类也可以访问到<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Something</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> s_value; <span class=\"comment\">// declares the static member variable</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> Something::s_value = <span class=\"number\">1</span>; <span class=\"comment\">// defines the static member variable (we'll discuss this section below)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// note: we're not instantiating any objects of type Something</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    Something::s_value = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; Something::s_value &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_ZN9Something7s_valueE:</span><br><span class=\"line\">\t.<span class=\"keyword\">long</span>\t<span class=\"number\">1</span></span><br><span class=\"line\">\t.text</span><br><span class=\"line\">\t.globl\tmain</span><br><span class=\"line\">\t.type\tmain, @function</span><br><span class=\"line\"></span><br><span class=\"line\">　　</span><br><span class=\"line\">  Something::s_value=<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"number\">0x40081a</span> movl   $<span class=\"number\">0x3</span>,<span class=\"number\">0x20083c</span>(%rip)        # <span class=\"number\">0x601060</span> &lt;Something::s_value&gt;</span><br><span class=\"line\">（\tmovl\t_ZN9Something7s_valueE(%rip), %eax</span><br><span class=\"line\">\tmovl\t%eax, %esi</span><br><span class=\"line\">）</span><br><span class=\"line\">可见类似于上述的，存在内存的数据段中</span><br></pre></td></tr></table></figure>\n<h5 id=\"类静态变量作用域\"><a href=\"#类静态变量作用域\" class=\"headerlink\" title=\"类静态变量作用域\"></a>类静态变量作用域</h5><p>静态成员在多个文件中:<br>类中的机制，可以让定义在文件中的静态成员变量能被其他文件访问；加了作用域的声明，所以可以这样用<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在stati.h</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Some</span>&#123;</span></span><br><span class=\"line\">  <span class=\"number\">2</span>         <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"number\">3</span>                 <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> s_v;</span><br><span class=\"line\">  <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">  <span class=\"number\">5</span> <span class=\"comment\">//static int s_vv;//error 错误</span></span><br><span class=\"line\"></span><br><span class=\"line\">在stati.cpp</span><br><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">\"stati.h\"</span></span></span><br><span class=\"line\">  <span class=\"number\">2</span> <span class=\"keyword\">int</span> Some::s_v=<span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"number\">3</span> <span class=\"comment\">//static int s_vv=5;error</span></span><br><span class=\"line\"></span><br><span class=\"line\">在main</span><br><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stati.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> gets= Some::s_v;</span><br><span class=\"line\"></span><br><span class=\"line\">other:</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Whatever</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> s_value = <span class=\"number\">4</span>; <span class=\"comment\">// a static const int can be declared and initialized directly</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"静态成员函数的使用\"><a href=\"#静态成员函数的使用\" class=\"headerlink\" title=\"静态成员函数的使用\"></a>静态成员函数的使用</h5><ul>\n<li>考虑一个问题，当静态成员被申明为private时，则无法使用它directly by class。<br>but you can用非静态成员函数操作或者用静态成员函数操作to use it  </li>\n<li>静态成员函数也是可以用类直接调用，它没有this指针，所以不能修改和访问对象的成员； </li>\n<li>（非静态成员func,它可以定义在类的内部或者外部，外部不用加static,这点和static成员不同，成员得在外部初始化－－因为public等定义成员时，非const不能赋值，而<br>static不能修饰构造函数（对象相关），所以只能在外部初始化)</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IDGenerator</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> s_nextID; <span class=\"comment\">// Here's the declaration for a static member</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getNextID</span><span class=\"params\">()</span></span>; <span class=\"comment\">// Here's the declaration for a static function</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// Here's the definition of the static member outside the class.  Note we don't use the static keyword here.</span></span><br><span class=\"line\"><span class=\"comment\">// We'll start generating IDs at 1</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> IDGenerator::s_nextID = <span class=\"number\">1</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// Here's the definition of the static function outside of the class.  Note we don't use the static keyword here.</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> IDGenerator::getNextID() &#123; <span class=\"keyword\">return</span> s_nextID++; &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> count=<span class=\"number\">0</span>; count &lt; <span class=\"number\">5</span>; ++count)</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The next ID is: \"</span> &lt;&lt; IDGenerator::getNextID() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"c-关键词之static\"><a href=\"#c-关键词之static\" class=\"headerlink\" title=\"c++关键词之static\"></a>c++关键词之static</h3><h5 id=\"something-share\"><a href=\"#something-share\" class=\"headerlink\" title=\"something share:\"></a>something share:</h5><p>其实，一开始学习c++的时候，并没有想去了解它的语法原理。虽然学c的时候，附带学了汇编，也学到了内存段，和学编译原理的时候顺带了解了它的相关词法语法处理。　　<br>现在开始从原因，历史，内存，汇编等角度去看cpp，觉得清晰了一些。虽然没有去学习g++或者其他编译器","more":"<br>如何处理c++的语法词法。这个想着以后如果有时间再研究吧。应该也是有工具去看，毕竟，g++是开源的，可以直接看源码如何处理C++</p>\n<h4 id=\"static-overiew\"><a href=\"#static-overiew\" class=\"headerlink\" title=\"static overiew\"></a>static overiew</h4><ul>\n<li>static在c的时候就有，因存储的地方不同于局部变量(in static mem ,not in stack)，使得在函数代码块结束后不会被销毁。从而能持续整个程序.</li>\n<li>静态存储区(data)：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</li>\n</ul>\n<h4 id=\"目录：\"><a href=\"#目录：\" class=\"headerlink\" title=\"目录：\"></a>目录：</h4><p>１、static概念和用法<br>２、static内存存储和汇编<br>３、static和类相关内容与原理  </p>\n<h4 id=\"static概念：\"><a href=\"#static概念：\" class=\"headerlink\" title=\"static概念：\"></a>static概念：</h4><p>　static为静态修饰符。编译器遇到这个修饰符时将对应的变量存储在静态存储区(data)  　</p>\n<ul>\n<li>根据类型：static可以修饰变量和函数，修饰对象和成员函数  </li>\n<li>根据位置：静态局部变量和全局静态变量 -存于静态数据区(data)</li>\n</ul>\n<h5 id=\"c中的static\"><a href=\"#c中的static\" class=\"headerlink\" title=\"c中的static:\"></a>c中的static:</h5><ul>\n<li>修饰变量：作用域是本程序文件，局部变量默认为auto,静态变量不管局部或者全局都存储于静态数据区，使得不会因为函数调用而销毁</li>\n<li>修饰函数：只能用于本程序文件，普通函数默认为extern ,能被其他文件引用，static则不行</li>\n</ul>\n<p>“ 举个例子：<br>在stat.h中声明static int getstats()函数.<br>并在stat.c中实现它，static int getstats(){return xxx;}<br>在main中或者其他文件中使用这个函数<br>编译时报错未能找到该函数（未定义该函数)<br>c++中的static当和类无关时同c” </p>\n<h4 id=\"static使用和内存与汇编：\"><a href=\"#static使用和内存与汇编：\" class=\"headerlink\" title=\"static使用和内存与汇编：\"></a>static使用和内存与汇编：</h4><h5 id=\"static全局变量\"><a href=\"#static全局变量\" class=\"headerlink\" title=\"static全局变量\"></a>static全局变量</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> global1=<span class=\"number\">4</span>;</span><br><span class=\"line\">   <span class=\"number\">12</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   13 </span>&#123;</span><br><span class=\"line\">&gt;&gt; <span class=\"number\">14</span>         <span class=\"keyword\">int</span> loc1=global1;</span><br><span class=\"line\"></span><br><span class=\"line\">_ZL7global1:</span><br><span class=\"line\">\t.<span class=\"keyword\">long</span>\t<span class=\"number\">4</span></span><br><span class=\"line\">\t.text</span><br><span class=\"line\">\t.globl\tmain</span><br><span class=\"line\">\t.type\tmain, @function</span><br><span class=\"line\"></span><br><span class=\"line\">\tmovl\t_ZL7global1(%rip), %eax</span><br><span class=\"line\">\tmovl\t%eax, <span class=\"number\">-4</span>(%rbp)</span><br><span class=\"line\"><span class=\"comment\">//且可以通过kdbg看到在执行期，</span></span><br><span class=\"line\"><span class=\"keyword\">static</span>变量的内存位置约为：</span><br><span class=\"line\">(<span class=\"keyword\">int</span> *) <span class=\"number\">0x601048</span> &lt;global1&gt;　数据段地址</span><br><span class=\"line\">局部变量的位置约为：</span><br><span class=\"line\">(<span class=\"keyword\">char</span> **) <span class=\"number\">0x7ffff7a54530</span> &lt;loc1&gt;　栈地址</span><br></pre></td></tr></table></figure>\n<h5 id=\"静态局部变量\"><a href=\"#静态局部变量\" class=\"headerlink\" title=\"静态局部变量\"></a>静态局部变量</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   13 </span>&#123;</span><br><span class=\"line\">   <span class=\"number\">14</span>         <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> locstatic1=<span class=\"number\">5</span>;</span><br><span class=\"line\">&gt;&gt; <span class=\"number\">15</span>         <span class=\"keyword\">int</span> loc1=global1;</span><br><span class=\"line\">&gt;&gt; <span class=\"number\">16</span>         <span class=\"keyword\">int</span> loc2=locstatic1;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmovl\t_ZZ4mainE10locstatic1(%rip), %eax</span><br><span class=\"line\">\tmovl\t%eax, <span class=\"number\">-4</span>(%rbp)</span><br><span class=\"line\"></span><br><span class=\"line\">_ZZ4mainE10locstatic1:</span><br><span class=\"line\">\t.<span class=\"keyword\">long</span>\t<span class=\"number\">5</span></span><br><span class=\"line\">执行期：</span><br><span class=\"line\">　　loca1 　(<span class=\"keyword\">int</span> *) <span class=\"number\">0x7fffffffd8a8</span></span><br><span class=\"line\">　　loca2 (<span class=\"keyword\">int</span> *) <span class=\"number\">0x7fffffffd8ac</span></span><br><span class=\"line\"></span><br><span class=\"line\">  global1 (<span class=\"keyword\">int</span> *) <span class=\"number\">0x601048</span> &lt;global1&gt;</span><br><span class=\"line\">  locstatic:(<span class=\"keyword\">int</span> *) <span class=\"number\">0x60104c</span> &lt;main::locstatic1&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"static定义的变量和函数只能在本程序文件中使用\"><a href=\"#static定义的变量和函数只能在本程序文件中使用\" class=\"headerlink\" title=\"static定义的变量和函数只能在本程序文件中使用\"></a>static定义的变量和函数只能在本程序文件中使用</h5><p>要知道这个的原因可能有些复杂，一时半会也说不清，得先直到函数为什么能被外部引用：存在“符号表”中，能被外部链接，静态函数不在符号表中所以不行，类似这样吧，<br>这块不太清楚，感觉是这个原因</p>\n<h5 id=\"static函数：\"><a href=\"#static函数：\" class=\"headerlink\" title=\"static函数：\"></a>static函数：</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">static</span>  <span class=\"keyword\">int</span> <span class=\"title\">getv</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    4 </span>&#123;</span><br><span class=\"line\">    <span class=\"number\">5</span>         <span class=\"keyword\">int</span> a=<span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"number\">6</span>         a++;</span><br><span class=\"line\">    <span class=\"number\">7</span>         <span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"number\">8</span>         <span class=\"keyword\">return</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"number\">9</span> &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">\t.type\t_ZL4getvv, @function</span><br><span class=\"line\">_ZL4getvv:</span><br><span class=\"line\">.LFB1021:</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset <span class=\"number\">16</span></span><br><span class=\"line\">\t.cfi_offset <span class=\"number\">6</span>, <span class=\"number\">-16</span></span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register <span class=\"number\">6</span></span><br><span class=\"line\">\tsubq\t$<span class=\"number\">16</span>, %rsp</span><br><span class=\"line\">　　　。。。。</span><br></pre></td></tr></table></figure>\n<p>　    call    _ZL4getvv<br>从汇编代码看貌似跟普通函数没什么差别<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行时</span><br><span class=\"line\">　　<span class=\"function\"><span class=\"keyword\">static</span>  <span class=\"keyword\">int</span> <span class=\"title\">getv</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"number\">0x400816</span> push   %rbp</span><br><span class=\"line\"><span class=\"number\">0x400817</span> mov    %rsp,%rbp</span><br><span class=\"line\"><span class=\"number\">0x40081a</span> sub    $<span class=\"number\">0x10</span>,%rsp</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a=<span class=\"number\">5</span>;</span><br><span class=\"line\">\t\ta++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> global1=<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> locstatic1=<span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> loc1=global1;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> loc2=locstatic1;</span><br><span class=\"line\"><span class=\"comment\">//\t\tcout&lt;&lt;getv()&lt;&lt;endl;</span></span><br><span class=\"line\">    \tgetv();</span><br><span class=\"line\"><span class=\"number\">0x400866</span> callq  <span class=\"number\">0x400816</span> &lt;getv()&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"static和类相关\"><a href=\"#static和类相关\" class=\"headerlink\" title=\"static和类相关\"></a>static和类相关</h4><h5 id=\"static成员变量的使用\"><a href=\"#static成员变量的使用\" class=\"headerlink\" title=\"static成员变量的使用\"></a>static成员变量的使用</h5><p> static成员变量是类的所有对象共有的，但是只有一份，通过类也可以访问到<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Something</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> s_value; <span class=\"comment\">// declares the static member variable</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> Something::s_value = <span class=\"number\">1</span>; <span class=\"comment\">// defines the static member variable (we'll discuss this section below)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// note: we're not instantiating any objects of type Something</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    Something::s_value = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; Something::s_value &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_ZN9Something7s_valueE:</span><br><span class=\"line\">\t.<span class=\"keyword\">long</span>\t<span class=\"number\">1</span></span><br><span class=\"line\">\t.text</span><br><span class=\"line\">\t.globl\tmain</span><br><span class=\"line\">\t.type\tmain, @function</span><br><span class=\"line\"></span><br><span class=\"line\">　　</span><br><span class=\"line\">  Something::s_value=<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"number\">0x40081a</span> movl   $<span class=\"number\">0x3</span>,<span class=\"number\">0x20083c</span>(%rip)        # <span class=\"number\">0x601060</span> &lt;Something::s_value&gt;</span><br><span class=\"line\">（\tmovl\t_ZN9Something7s_valueE(%rip), %eax</span><br><span class=\"line\">\tmovl\t%eax, %esi</span><br><span class=\"line\">）</span><br><span class=\"line\">可见类似于上述的，存在内存的数据段中</span><br></pre></td></tr></table></figure>\n<h5 id=\"类静态变量作用域\"><a href=\"#类静态变量作用域\" class=\"headerlink\" title=\"类静态变量作用域\"></a>类静态变量作用域</h5><p>静态成员在多个文件中:<br>类中的机制，可以让定义在文件中的静态成员变量能被其他文件访问；加了作用域的声明，所以可以这样用<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在stati.h</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Some</span>&#123;</span></span><br><span class=\"line\">  <span class=\"number\">2</span>         <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"number\">3</span>                 <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> s_v;</span><br><span class=\"line\">  <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">  <span class=\"number\">5</span> <span class=\"comment\">//static int s_vv;//error 错误</span></span><br><span class=\"line\"></span><br><span class=\"line\">在stati.cpp</span><br><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">\"stati.h\"</span></span></span><br><span class=\"line\">  <span class=\"number\">2</span> <span class=\"keyword\">int</span> Some::s_v=<span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"number\">3</span> <span class=\"comment\">//static int s_vv=5;error</span></span><br><span class=\"line\"></span><br><span class=\"line\">在main</span><br><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stati.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> gets= Some::s_v;</span><br><span class=\"line\"></span><br><span class=\"line\">other:</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Whatever</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> s_value = <span class=\"number\">4</span>; <span class=\"comment\">// a static const int can be declared and initialized directly</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"静态成员函数的使用\"><a href=\"#静态成员函数的使用\" class=\"headerlink\" title=\"静态成员函数的使用\"></a>静态成员函数的使用</h5><ul>\n<li>考虑一个问题，当静态成员被申明为private时，则无法使用它directly by class。<br>but you can用非静态成员函数操作或者用静态成员函数操作to use it  </li>\n<li>静态成员函数也是可以用类直接调用，它没有this指针，所以不能修改和访问对象的成员； </li>\n<li>（非静态成员func,它可以定义在类的内部或者外部，外部不用加static,这点和static成员不同，成员得在外部初始化－－因为public等定义成员时，非const不能赋值，而<br>static不能修饰构造函数（对象相关），所以只能在外部初始化)</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IDGenerator</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> s_nextID; <span class=\"comment\">// Here's the declaration for a static member</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getNextID</span><span class=\"params\">()</span></span>; <span class=\"comment\">// Here's the declaration for a static function</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// Here's the definition of the static member outside the class.  Note we don't use the static keyword here.</span></span><br><span class=\"line\"><span class=\"comment\">// We'll start generating IDs at 1</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> IDGenerator::s_nextID = <span class=\"number\">1</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// Here's the definition of the static function outside of the class.  Note we don't use the static keyword here.</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> IDGenerator::getNextID() &#123; <span class=\"keyword\">return</span> s_nextID++; &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> count=<span class=\"number\">0</span>; count &lt; <span class=\"number\">5</span>; ++count)</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The next ID is: \"</span> &lt;&lt; IDGenerator::getNextID() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"cpp_this","date":"2018-06-09T02:13:46.000Z","_content":"### c++关键字之this\n#### this指针是什么\nthis是一个指向当前正在使用的对象的指针，它是一个指针；\n成员函数通过它来使用对象的值，通过它知道要对哪个对象的成员操作\n如：<!--more-->\n```cpp\nclass Simple\n{\nprivate:\n    int m_id;\npublic:\n    Simple(int id)\n    {\n        setID(id);\n    }\n    void setID(int id) { m_id = id; }\n    int getID() { return m_id; }\n};\nint main()\n{\n    Simple simple(1);\n    simple.setID(2);\n    std::cout << simple.getID() << '\\n';\n    return 0;\n}\n```\n```cpp\nsimple.setID(2);--->\nsetID(&simple, 2); // note that simple has been changed from an object prefix to a function argument!\n  void setID(int id) { m_id = id; }--->\n  void setID(Simple* const this, int id) { this->m_id = id; }\n  ```\n#### this指针用法\n关键词 this 是一个纯右值表达式，其值是在调用成员函数时的对象地址。它能出现于下列语境：\n+  在任何非静态成员函数体内，含成员初始化列表\n+  在非静态成员函数的声明内任何(可选) cv 限定符序列后处，包含动态异常规定(弃用)、 noexcept 规定(C++11)及尾随返回类型(C++11 起)\n+ 在默认成员初始化中 (C++11 起)\n+ 在一个对象的构造期间，若通过不直接或间接从构造函数的 this 指针获得的泛左值，访问对象的值或任何其子对象，则如此获得的对象或子对象的值是未指定的。换言之，构造函数中 this 指针不能别名使用：\n\n```cpp\nextern struct D d;\nstruct D {\nD(int a) : a(a), b(d.a) {} // a(a)will change to this->a(a),but b(d.a)-->this->b(d.a),and will get random value,but b(a) 或 b(this->a) 是正确的\n    int a, b;\n};\nD d = D(1);   // 因为 b(d.a) 不通过 this 访问， d.b 现在是未指定的,i try in g++.find it d.b==1\n```\n\n#### this指针于内存哪里？  \nthis 指针是不占类的内存的，它是传入成员函数的参数，所以它在栈中  \n#### this 指针总是指向正在操作的对象：\n```cpp\nint main()\n{\n    Simple A(1); // *this = &A inside the Simple constructor\n    Simple B(2); // *this = &B inside the Simple constructor\n    A.setID(3); // *this = &A inside member function setID\n    B.setID(4); // *this = &B inside member function setID\n \n    return 0;\n}\n``\n+ this指针的连锁使用：  \n由this指针理解cout<<xxx<<<xxx<<<xxxxx....\n对上述的表达式，cout是一个类，<<是该类的操作符函数，则<<函数返回this，若返回空，则无法进行：  \n```cpp\nstd::cout << \"Hello, \" << userName;\n(std::cout << \"Hello, \") << userName;\n\n(void) << userName;　错误\n(std::cout) << userName;正确\n如何写？\nclass Calc\n{\nprivate:\n    int m_value;\n \npublic:\n    Calc() { m_value = 0; }\n \n    Calc& add(int value) { m_value += value; return *this; }\n    Calc& sub(int value) { m_value -= value; return *this; }\n    Calc& mult(int value) { m_value *= value; return *this; }\n \n    int getValue() { return m_value; }\n};\n\n#include <iostream>\nint main()\n{\n    Calc calc;\n    calc.add(5).sub(3).mult(4);\n \n    std::cout << calc.getValue() << '\\n';\n    return 0;\n}```\n\n注意Calc& 和return *this\n#### this指针到对象名代表的是什么\n由above和以下例子：来看对象的地址等\n```cpp\n#include<iostream>\nusing namespace std;\nclass set\n{\n    int m_i;\npublic:\n    set()\n    {\n        m_i = 0;\n    }\n    set add(int i)\n    {\n        m_i += i;\n        return *this;\n    }\n    int  getval()\n    {\n        return m_i;\n    }\n};\nint main()\n{\n    set s;\n    s.add(2).add(2);\n    cout<<s.getval();\n}```\n//结果是２　因为函数返回的*this是一个值，它是set对象的值：\n```cpp\nclass set\n    5 {   \n    6     int m_e;\n    7     int m_i;\n    8  public:\n    9     set()\n   10     {\n   11         m_e=0;\n   12         m_i=0;\n   13     }\n   14     set add(int i){\n   15             m_i+=i;\n   16             return *this;\n   17     }\n   18     int getval() { \n   19             return m_i;\n   20     }\n   21 };\n\nint main()\n   33 {\n   34         set s;\n   35         set s2;\n>> 36         printf(\"%x\\n\",s.add(2));--输出0,返回的是*this，为s的值，m_e是其第一个成员\n>> 37         printf(\"%x\\n\",s);－－输出0\n   38         s2=s.add(2);--s2被赋值了s，s此时的m_i=2+2\n   39         s2.add(2);--s2的m_i=6\n>> 40         printf(\"%d\\n\",s2);//输出的是０－－－ m_e=0\n   41         cout<<s2.getval()<<endl;-输出6，因为\n   42         return 0;\n   43 }\n 由此可以看出this->object  this->s\n            *this==s\n            *this==s的内容\n　　　　　　取对象的地址　&s\n```\nref:  \nhttp://zh.cppreference.com/w/cpp/language/this\nhttp://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/\n","source":"_posts/cpp-this.md","raw":"---\ntitle: cpp_this\ndate: 2018-06-09 10:13:46\ntags: cpp_keyword\ncategories: c&cpp\n---\n### c++关键字之this\n#### this指针是什么\nthis是一个指向当前正在使用的对象的指针，它是一个指针；\n成员函数通过它来使用对象的值，通过它知道要对哪个对象的成员操作\n如：<!--more-->\n```cpp\nclass Simple\n{\nprivate:\n    int m_id;\npublic:\n    Simple(int id)\n    {\n        setID(id);\n    }\n    void setID(int id) { m_id = id; }\n    int getID() { return m_id; }\n};\nint main()\n{\n    Simple simple(1);\n    simple.setID(2);\n    std::cout << simple.getID() << '\\n';\n    return 0;\n}\n```\n```cpp\nsimple.setID(2);--->\nsetID(&simple, 2); // note that simple has been changed from an object prefix to a function argument!\n  void setID(int id) { m_id = id; }--->\n  void setID(Simple* const this, int id) { this->m_id = id; }\n  ```\n#### this指针用法\n关键词 this 是一个纯右值表达式，其值是在调用成员函数时的对象地址。它能出现于下列语境：\n+  在任何非静态成员函数体内，含成员初始化列表\n+  在非静态成员函数的声明内任何(可选) cv 限定符序列后处，包含动态异常规定(弃用)、 noexcept 规定(C++11)及尾随返回类型(C++11 起)\n+ 在默认成员初始化中 (C++11 起)\n+ 在一个对象的构造期间，若通过不直接或间接从构造函数的 this 指针获得的泛左值，访问对象的值或任何其子对象，则如此获得的对象或子对象的值是未指定的。换言之，构造函数中 this 指针不能别名使用：\n\n```cpp\nextern struct D d;\nstruct D {\nD(int a) : a(a), b(d.a) {} // a(a)will change to this->a(a),but b(d.a)-->this->b(d.a),and will get random value,but b(a) 或 b(this->a) 是正确的\n    int a, b;\n};\nD d = D(1);   // 因为 b(d.a) 不通过 this 访问， d.b 现在是未指定的,i try in g++.find it d.b==1\n```\n\n#### this指针于内存哪里？  \nthis 指针是不占类的内存的，它是传入成员函数的参数，所以它在栈中  \n#### this 指针总是指向正在操作的对象：\n```cpp\nint main()\n{\n    Simple A(1); // *this = &A inside the Simple constructor\n    Simple B(2); // *this = &B inside the Simple constructor\n    A.setID(3); // *this = &A inside member function setID\n    B.setID(4); // *this = &B inside member function setID\n \n    return 0;\n}\n``\n+ this指针的连锁使用：  \n由this指针理解cout<<xxx<<<xxx<<<xxxxx....\n对上述的表达式，cout是一个类，<<是该类的操作符函数，则<<函数返回this，若返回空，则无法进行：  \n```cpp\nstd::cout << \"Hello, \" << userName;\n(std::cout << \"Hello, \") << userName;\n\n(void) << userName;　错误\n(std::cout) << userName;正确\n如何写？\nclass Calc\n{\nprivate:\n    int m_value;\n \npublic:\n    Calc() { m_value = 0; }\n \n    Calc& add(int value) { m_value += value; return *this; }\n    Calc& sub(int value) { m_value -= value; return *this; }\n    Calc& mult(int value) { m_value *= value; return *this; }\n \n    int getValue() { return m_value; }\n};\n\n#include <iostream>\nint main()\n{\n    Calc calc;\n    calc.add(5).sub(3).mult(4);\n \n    std::cout << calc.getValue() << '\\n';\n    return 0;\n}```\n\n注意Calc& 和return *this\n#### this指针到对象名代表的是什么\n由above和以下例子：来看对象的地址等\n```cpp\n#include<iostream>\nusing namespace std;\nclass set\n{\n    int m_i;\npublic:\n    set()\n    {\n        m_i = 0;\n    }\n    set add(int i)\n    {\n        m_i += i;\n        return *this;\n    }\n    int  getval()\n    {\n        return m_i;\n    }\n};\nint main()\n{\n    set s;\n    s.add(2).add(2);\n    cout<<s.getval();\n}```\n//结果是２　因为函数返回的*this是一个值，它是set对象的值：\n```cpp\nclass set\n    5 {   \n    6     int m_e;\n    7     int m_i;\n    8  public:\n    9     set()\n   10     {\n   11         m_e=0;\n   12         m_i=0;\n   13     }\n   14     set add(int i){\n   15             m_i+=i;\n   16             return *this;\n   17     }\n   18     int getval() { \n   19             return m_i;\n   20     }\n   21 };\n\nint main()\n   33 {\n   34         set s;\n   35         set s2;\n>> 36         printf(\"%x\\n\",s.add(2));--输出0,返回的是*this，为s的值，m_e是其第一个成员\n>> 37         printf(\"%x\\n\",s);－－输出0\n   38         s2=s.add(2);--s2被赋值了s，s此时的m_i=2+2\n   39         s2.add(2);--s2的m_i=6\n>> 40         printf(\"%d\\n\",s2);//输出的是０－－－ m_e=0\n   41         cout<<s2.getval()<<endl;-输出6，因为\n   42         return 0;\n   43 }\n 由此可以看出this->object  this->s\n            *this==s\n            *this==s的内容\n　　　　　　取对象的地址　&s\n```\nref:  \nhttp://zh.cppreference.com/w/cpp/language/this\nhttp://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/\n","slug":"cpp-this","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7o8001i2ujx8jwcjp95","content":"<h3 id=\"c-关键字之this\"><a href=\"#c-关键字之this\" class=\"headerlink\" title=\"c++关键字之this\"></a>c++关键字之this</h3><h4 id=\"this指针是什么\"><a href=\"#this指针是什么\" class=\"headerlink\" title=\"this指针是什么\"></a>this指针是什么</h4><p>this是一个指向当前正在使用的对象的指针，它是一个指针；<br>成员函数通过它来使用对象的值，通过它知道要对哪个对象的成员操作<br>如：<a id=\"more\"></a><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Simple</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_id;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Simple(<span class=\"keyword\">int</span> id)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        setID(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setID</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123; m_id = id; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getID</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_id; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Simple <span class=\"title\">simple</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    simple.setID(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; simple.getID() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">simple.setID(<span class=\"number\">2</span>);---&gt;</span><br><span class=\"line\">setID(&amp;simple, <span class=\"number\">2</span>); <span class=\"comment\">// note that simple has been changed from an object prefix to a function argument!</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setID</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123; m_id = id; &#125;---&gt;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setID</span><span class=\"params\">(Simple* <span class=\"keyword\">const</span> <span class=\"keyword\">this</span>, <span class=\"keyword\">int</span> id)</span> </span>&#123; <span class=\"keyword\">this</span>-&gt;m_id = id; &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"this指针用法\"><a href=\"#this指针用法\" class=\"headerlink\" title=\"this指针用法\"></a>this指针用法</h4><p>关键词 this 是一个纯右值表达式，其值是在调用成员函数时的对象地址。它能出现于下列语境：</p>\n<ul>\n<li>在任何非静态成员函数体内，含成员初始化列表</li>\n<li>在非静态成员函数的声明内任何(可选) cv 限定符序列后处，包含动态异常规定(弃用)、 noexcept 规定(C++11)及尾随返回类型(C++11 起)</li>\n<li>在默认成员初始化中 (C++11 起)</li>\n<li>在一个对象的构造期间，若通过不直接或间接从构造函数的 this 指针获得的泛左值，访问对象的值或任何其子对象，则如此获得的对象或子对象的值是未指定的。换言之，构造函数中 this 指针不能别名使用：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D</span> <span class=\"title\">d</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D</span> &#123;</span></span><br><span class=\"line\">D(<span class=\"keyword\">int</span> a) : a(a), b(d.a) &#123;&#125; <span class=\"comment\">// a(a)will change to this-&gt;a(a),but b(d.a)--&gt;this-&gt;b(d.a),and will get random value,but b(a) 或 b(this-&gt;a) 是正确的</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">D d = D(<span class=\"number\">1</span>);   <span class=\"comment\">// 因为 b(d.a) 不通过 this 访问， d.b 现在是未指定的,i try in g++.find it d.b==1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"this指针于内存哪里？\"><a href=\"#this指针于内存哪里？\" class=\"headerlink\" title=\"this指针于内存哪里？\"></a>this指针于内存哪里？</h4><p>this 指针是不占类的内存的，它是传入成员函数的参数，所以它在栈中  </p>\n<h4 id=\"this-指针总是指向正在操作的对象：\"><a href=\"#this-指针总是指向正在操作的对象：\" class=\"headerlink\" title=\"this 指针总是指向正在操作的对象：\"></a>this 指针总是指向正在操作的对象：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Simple <span class=\"title\">A</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>; <span class=\"comment\">// *this = &amp;A inside the Simple constructor</span></span><br><span class=\"line\">    <span class=\"function\">Simple <span class=\"title\">B</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span>; <span class=\"comment\">// *this = &amp;B inside the Simple constructor</span></span><br><span class=\"line\">    A.setID(<span class=\"number\">3</span>); <span class=\"comment\">// *this = &amp;A inside member function setID</span></span><br><span class=\"line\">    B.setID(<span class=\"number\">4</span>); <span class=\"comment\">// *this = &amp;B inside member function setID</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``</span><br><span class=\"line\">+ <span class=\"keyword\">this</span>指针的连锁使用：  </span><br><span class=\"line\">由<span class=\"keyword\">this</span>指针理解<span class=\"built_in\">cout</span>&lt;&lt;xxx&lt;&lt;&lt;xxx&lt;&lt;&lt;xxxxx....</span><br><span class=\"line\">对上述的表达式，<span class=\"built_in\">cout</span>是一个类，&lt;&lt;是该类的操作符函数，则&lt;&lt;函数返回<span class=\"keyword\">this</span>，若返回空，则无法进行：  </span><br><span class=\"line\">```cpp</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello, \"</span> &lt;&lt; userName;</span><br><span class=\"line\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello, \"</span>) &lt;&lt; userName;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">void</span>) &lt;&lt; userName;　错误</span><br><span class=\"line\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>) &lt;&lt; userName;正确</span><br><span class=\"line\">如何写？</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calc</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_value;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Calc() &#123; m_value = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\">Calc&amp; <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123; m_value += value; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\">Calc&amp; <span class=\"title\">sub</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123; m_value -= value; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\">Calc&amp; <span class=\"title\">mult</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123; m_value *= value; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_value; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Calc calc;</span><br><span class=\"line\">    calc.add(<span class=\"number\">5</span>).sub(<span class=\"number\">3</span>).mult(<span class=\"number\">4</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; calc.getValue() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意Calc&amp; 和return *this</p>\n<h4 id=\"this指针到对象名代表的是什么\"><a href=\"#this指针到对象名代表的是什么\" class=\"headerlink\" title=\"this指针到对象名代表的是什么\"></a>this指针到对象名代表的是什么</h4><p>由above和以下例子：来看对象的地址等<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">set</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_i;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">set</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">set</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        m_i += i;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span>  <span class=\"title\">getval</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> s;</span><br><span class=\"line\">    s.add(<span class=\"number\">2</span>).add(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;s.getval();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//结果是２　因为函数返回的*this是一个值，它是set对象的值：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">set</span></span></span><br><span class=\"line\"><span class=\"class\">    5 &#123;</span>   </span><br><span class=\"line\">    <span class=\"number\">6</span>     <span class=\"keyword\">int</span> m_e;</span><br><span class=\"line\">    <span class=\"number\">7</span>     <span class=\"keyword\">int</span> m_i;</span><br><span class=\"line\">    <span class=\"number\">8</span>  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"number\">9</span>     <span class=\"built_in\">set</span>()</span><br><span class=\"line\">   <span class=\"number\">10</span>     &#123;</span><br><span class=\"line\">   <span class=\"number\">11</span>         m_e=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"number\">12</span>         m_i=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"number\">13</span>     &#125;</span><br><span class=\"line\">   <span class=\"number\">14</span>     <span class=\"function\"><span class=\"built_in\">set</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">   <span class=\"number\">15</span>             m_i+=i;</span><br><span class=\"line\">   <span class=\"number\">16</span>             <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">   <span class=\"number\">17</span>     &#125;</span><br><span class=\"line\">   <span class=\"number\">18</span>     <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getval</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">   <span class=\"number\">19</span>             <span class=\"keyword\">return</span> m_i;</span><br><span class=\"line\">   <span class=\"number\">20</span>     &#125;</span><br><span class=\"line\">   <span class=\"number\">21</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   33 </span>&#123;</span><br><span class=\"line\">   <span class=\"number\">34</span>         <span class=\"built_in\">set</span> s;</span><br><span class=\"line\">   <span class=\"number\">35</span>         <span class=\"built_in\">set</span> s2;</span><br><span class=\"line\">&gt;&gt; <span class=\"number\">36</span>         <span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>,s.add(<span class=\"number\">2</span>));--输出<span class=\"number\">0</span>,返回的是*<span class=\"keyword\">this</span>，为s的值，m_e是其第一个成员</span><br><span class=\"line\">&gt;&gt; <span class=\"number\">37</span>         <span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>,s);－－输出<span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"number\">38</span>         s2=s.add(<span class=\"number\">2</span>);--s2被赋值了s，s此时的m_i=<span class=\"number\">2</span>+<span class=\"number\">2</span></span><br><span class=\"line\">   <span class=\"number\">39</span>         s2.add(<span class=\"number\">2</span>);--s2的m_i=<span class=\"number\">6</span></span><br><span class=\"line\">&gt;&gt; <span class=\"number\">40</span>         <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,s2);<span class=\"comment\">//输出的是０－－－ m_e=0</span></span><br><span class=\"line\">   <span class=\"number\">41</span>         <span class=\"built_in\">cout</span>&lt;&lt;s2.getval()&lt;&lt;<span class=\"built_in\">endl</span>;-输出<span class=\"number\">6</span>，因为</span><br><span class=\"line\">   <span class=\"number\">42</span>         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"number\">43</span> &#125;</span><br><span class=\"line\"> 由此可以看出<span class=\"keyword\">this</span>-&gt;object  <span class=\"keyword\">this</span>-&gt;s</span><br><span class=\"line\">            *<span class=\"keyword\">this</span>==s</span><br><span class=\"line\">            *<span class=\"keyword\">this</span>==s的内容</span><br><span class=\"line\">　　　　　　取对象的地址　&amp;s</span><br></pre></td></tr></table></figure></p>\n<p>ref:<br><a href=\"http://zh.cppreference.com/w/cpp/language/this\" target=\"_blank\" rel=\"noopener\">http://zh.cppreference.com/w/cpp/language/this</a><br><a href=\"http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/\" target=\"_blank\" rel=\"noopener\">http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"c-关键字之this\"><a href=\"#c-关键字之this\" class=\"headerlink\" title=\"c++关键字之this\"></a>c++关键字之this</h3><h4 id=\"this指针是什么\"><a href=\"#this指针是什么\" class=\"headerlink\" title=\"this指针是什么\"></a>this指针是什么</h4><p>this是一个指向当前正在使用的对象的指针，它是一个指针；<br>成员函数通过它来使用对象的值，通过它知道要对哪个对象的成员操作<br>如：","more":"<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Simple</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_id;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Simple(<span class=\"keyword\">int</span> id)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        setID(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setID</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123; m_id = id; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getID</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_id; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Simple <span class=\"title\">simple</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    simple.setID(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; simple.getID() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">simple.setID(<span class=\"number\">2</span>);---&gt;</span><br><span class=\"line\">setID(&amp;simple, <span class=\"number\">2</span>); <span class=\"comment\">// note that simple has been changed from an object prefix to a function argument!</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setID</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123; m_id = id; &#125;---&gt;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setID</span><span class=\"params\">(Simple* <span class=\"keyword\">const</span> <span class=\"keyword\">this</span>, <span class=\"keyword\">int</span> id)</span> </span>&#123; <span class=\"keyword\">this</span>-&gt;m_id = id; &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"this指针用法\"><a href=\"#this指针用法\" class=\"headerlink\" title=\"this指针用法\"></a>this指针用法</h4><p>关键词 this 是一个纯右值表达式，其值是在调用成员函数时的对象地址。它能出现于下列语境：</p>\n<ul>\n<li>在任何非静态成员函数体内，含成员初始化列表</li>\n<li>在非静态成员函数的声明内任何(可选) cv 限定符序列后处，包含动态异常规定(弃用)、 noexcept 规定(C++11)及尾随返回类型(C++11 起)</li>\n<li>在默认成员初始化中 (C++11 起)</li>\n<li>在一个对象的构造期间，若通过不直接或间接从构造函数的 this 指针获得的泛左值，访问对象的值或任何其子对象，则如此获得的对象或子对象的值是未指定的。换言之，构造函数中 this 指针不能别名使用：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D</span> <span class=\"title\">d</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">D</span> &#123;</span></span><br><span class=\"line\">D(<span class=\"keyword\">int</span> a) : a(a), b(d.a) &#123;&#125; <span class=\"comment\">// a(a)will change to this-&gt;a(a),but b(d.a)--&gt;this-&gt;b(d.a),and will get random value,but b(a) 或 b(this-&gt;a) 是正确的</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">D d = D(<span class=\"number\">1</span>);   <span class=\"comment\">// 因为 b(d.a) 不通过 this 访问， d.b 现在是未指定的,i try in g++.find it d.b==1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"this指针于内存哪里？\"><a href=\"#this指针于内存哪里？\" class=\"headerlink\" title=\"this指针于内存哪里？\"></a>this指针于内存哪里？</h4><p>this 指针是不占类的内存的，它是传入成员函数的参数，所以它在栈中  </p>\n<h4 id=\"this-指针总是指向正在操作的对象：\"><a href=\"#this-指针总是指向正在操作的对象：\" class=\"headerlink\" title=\"this 指针总是指向正在操作的对象：\"></a>this 指针总是指向正在操作的对象：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Simple <span class=\"title\">A</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>; <span class=\"comment\">// *this = &amp;A inside the Simple constructor</span></span><br><span class=\"line\">    <span class=\"function\">Simple <span class=\"title\">B</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span>; <span class=\"comment\">// *this = &amp;B inside the Simple constructor</span></span><br><span class=\"line\">    A.setID(<span class=\"number\">3</span>); <span class=\"comment\">// *this = &amp;A inside member function setID</span></span><br><span class=\"line\">    B.setID(<span class=\"number\">4</span>); <span class=\"comment\">// *this = &amp;B inside member function setID</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``</span><br><span class=\"line\">+ <span class=\"keyword\">this</span>指针的连锁使用：  </span><br><span class=\"line\">由<span class=\"keyword\">this</span>指针理解<span class=\"built_in\">cout</span>&lt;&lt;xxx&lt;&lt;&lt;xxx&lt;&lt;&lt;xxxxx....</span><br><span class=\"line\">对上述的表达式，<span class=\"built_in\">cout</span>是一个类，&lt;&lt;是该类的操作符函数，则&lt;&lt;函数返回<span class=\"keyword\">this</span>，若返回空，则无法进行：  </span><br><span class=\"line\">```cpp</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello, \"</span> &lt;&lt; userName;</span><br><span class=\"line\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello, \"</span>) &lt;&lt; userName;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">void</span>) &lt;&lt; userName;　错误</span><br><span class=\"line\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>) &lt;&lt; userName;正确</span><br><span class=\"line\">如何写？</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calc</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_value;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Calc() &#123; m_value = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\">Calc&amp; <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123; m_value += value; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\">Calc&amp; <span class=\"title\">sub</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123; m_value -= value; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\">Calc&amp; <span class=\"title\">mult</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123; m_value *= value; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_value; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Calc calc;</span><br><span class=\"line\">    calc.add(<span class=\"number\">5</span>).sub(<span class=\"number\">3</span>).mult(<span class=\"number\">4</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; calc.getValue() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意Calc&amp; 和return *this</p>\n<h4 id=\"this指针到对象名代表的是什么\"><a href=\"#this指针到对象名代表的是什么\" class=\"headerlink\" title=\"this指针到对象名代表的是什么\"></a>this指针到对象名代表的是什么</h4><p>由above和以下例子：来看对象的地址等<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">set</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_i;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">set</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">set</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        m_i += i;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span>  <span class=\"title\">getval</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> s;</span><br><span class=\"line\">    s.add(<span class=\"number\">2</span>).add(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;s.getval();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//结果是２　因为函数返回的*this是一个值，它是set对象的值：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">set</span></span></span><br><span class=\"line\"><span class=\"class\">    5 &#123;</span>   </span><br><span class=\"line\">    <span class=\"number\">6</span>     <span class=\"keyword\">int</span> m_e;</span><br><span class=\"line\">    <span class=\"number\">7</span>     <span class=\"keyword\">int</span> m_i;</span><br><span class=\"line\">    <span class=\"number\">8</span>  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"number\">9</span>     <span class=\"built_in\">set</span>()</span><br><span class=\"line\">   <span class=\"number\">10</span>     &#123;</span><br><span class=\"line\">   <span class=\"number\">11</span>         m_e=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"number\">12</span>         m_i=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"number\">13</span>     &#125;</span><br><span class=\"line\">   <span class=\"number\">14</span>     <span class=\"function\"><span class=\"built_in\">set</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">   <span class=\"number\">15</span>             m_i+=i;</span><br><span class=\"line\">   <span class=\"number\">16</span>             <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">   <span class=\"number\">17</span>     &#125;</span><br><span class=\"line\">   <span class=\"number\">18</span>     <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getval</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">   <span class=\"number\">19</span>             <span class=\"keyword\">return</span> m_i;</span><br><span class=\"line\">   <span class=\"number\">20</span>     &#125;</span><br><span class=\"line\">   <span class=\"number\">21</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   33 </span>&#123;</span><br><span class=\"line\">   <span class=\"number\">34</span>         <span class=\"built_in\">set</span> s;</span><br><span class=\"line\">   <span class=\"number\">35</span>         <span class=\"built_in\">set</span> s2;</span><br><span class=\"line\">&gt;&gt; <span class=\"number\">36</span>         <span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>,s.add(<span class=\"number\">2</span>));--输出<span class=\"number\">0</span>,返回的是*<span class=\"keyword\">this</span>，为s的值，m_e是其第一个成员</span><br><span class=\"line\">&gt;&gt; <span class=\"number\">37</span>         <span class=\"built_in\">printf</span>(<span class=\"string\">\"%x\\n\"</span>,s);－－输出<span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"number\">38</span>         s2=s.add(<span class=\"number\">2</span>);--s2被赋值了s，s此时的m_i=<span class=\"number\">2</span>+<span class=\"number\">2</span></span><br><span class=\"line\">   <span class=\"number\">39</span>         s2.add(<span class=\"number\">2</span>);--s2的m_i=<span class=\"number\">6</span></span><br><span class=\"line\">&gt;&gt; <span class=\"number\">40</span>         <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,s2);<span class=\"comment\">//输出的是０－－－ m_e=0</span></span><br><span class=\"line\">   <span class=\"number\">41</span>         <span class=\"built_in\">cout</span>&lt;&lt;s2.getval()&lt;&lt;<span class=\"built_in\">endl</span>;-输出<span class=\"number\">6</span>，因为</span><br><span class=\"line\">   <span class=\"number\">42</span>         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"number\">43</span> &#125;</span><br><span class=\"line\"> 由此可以看出<span class=\"keyword\">this</span>-&gt;object  <span class=\"keyword\">this</span>-&gt;s</span><br><span class=\"line\">            *<span class=\"keyword\">this</span>==s</span><br><span class=\"line\">            *<span class=\"keyword\">this</span>==s的内容</span><br><span class=\"line\">　　　　　　取对象的地址　&amp;s</span><br></pre></td></tr></table></figure></p>\n<p>ref:<br><a href=\"http://zh.cppreference.com/w/cpp/language/this\" target=\"_blank\" rel=\"noopener\">http://zh.cppreference.com/w/cpp/language/this</a><br><a href=\"http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/\" target=\"_blank\" rel=\"noopener\">http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/</a></p>"},{"title":"gdb基础","date":"2020-07-11T09:48:05.000Z","_content":"\n1、总体\nGDB可以做四种主要的事情（以及支持这些事情的其他事情）来帮助您捕获行为中的错误：\n<!--more-->\n1）启动程序，并指定可能影响其行为的所有内容。\n2）使程序在指定条件下停止。\n3）检查程序停止时发生的情况。\n4）更改程序中的内容，以便您可以尝试纠正一个错误的影响，然后继续学习另一个错误。\n2、一个例子：\ngdb 调试运行一个程序：\n$ gdb m4  --运行\n(gdb) set width 70 --设置显示最大字符数，类似more\n(gdb) break m4_changequote   --设置断点，断点可以是某个函数，如main\nBreakpoint 1 at 0x62f4: file builtin.c, line 879.\n(gdb) run\nStarting program: /work/Editorial/gdb/gnu/m4/m4  --开始运行\n(gdb) n   --next 不进入函数运行，运行下一行；\n(gdb) s  --step 运行下一行，遇到函数会进入\n\n(gdb) bt --backtrace 打印调用栈\n(gdb) p lquote  --打印变量lquote,这个是变量名\n(gdb) p 表达式，这个表达式可以是符合语法的表达式，比如赋值语句和函数调用等，是生效的；\neg (gdb) p ++a\n\n$1 = 0x35d40 \"<QUOTE>\"\n(gdb) l    ---list，显示源代码\n533             xfree(rquote);\n(gdb) Ctrl-d --退出程序\n(gdb)quit  /q --退出gdb\n3、经常使用分类\n3.1 如何开始：\n 1）gdb programname\n        2）gdb programname corefile\n        3)  gdb  programname pid   / gdb -p pid  (关联上一个-g编译过的正在运行的进程)\n        4)  gdb --args programname arg1 2 3....\n        eg:gdb --args gcc -O2 -c foo.c\n        5) gdb xx     --silent/--quit /-q 不用输出信息 \n3.2 在gdb中也可以使用shell指令：\n(gdb) !ifconfig\n\n3.3 设置log文件\n使用技巧：\n1）回车表示重复上一个命令，除了run等；\n2）step 数字，可以表示步进多少\n3.4 设置打印方式：\n1)要更改要打印的数组元素的限制\n(gdb)set print elements 10\n2)是否打印数组：\n       (GDB) set print array on\n       (GDB) print some_array\n       (GDB) set print array off\n3.5 gdb的自动补全，按tab即可，甚至可以补全函数名；\n3.6 gdb 命令有option ,tab键可以召唤出来；\n3.7 gdb和线程；\n3.8 gdb的栈概念\n4  常见命令\ngdb栈查看命令\nbacktrace [option]… [qualifier]… [count]\nbt [option]… [qualifier]… [count]\n(gdb) frame 3\n(gdb) frame level 3\n(gdb) info frame\nStack level 1, frame at 0x7fffffffda30:\n向上或向下跳帧；\nup n\ndown n \n\n(gdb) frame apply all p j\n#0  some_function (i=5) at fun.c:4\nNo symbol \"j\" in current context.\n(gdb) frame apply all -c p j\n#0  some_function (i=5) at fun.c:4\nNo symbol \"j\" in current context.\n打印变量：p\n显示源码 l\n\n5 参考资料\n\nhttps://scc.ustc.edu.cn/zlsc/sugon/intel/debugger/cl/index.htm#commandref/gdb_mode/cmd_set_width.htm\nmore:\nhttps://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\nhttps://sourceware.org/gdb/current/onlinedocs/gdb/\n\n使用例子：\n","source":"_posts/gdb基本使用.md","raw":"---\n\ntitle: gdb基础\ndate: 2020-07-11 17:48:05\ntags: gdb\ncategories: linux\n---\n\n1、总体\nGDB可以做四种主要的事情（以及支持这些事情的其他事情）来帮助您捕获行为中的错误：\n<!--more-->\n1）启动程序，并指定可能影响其行为的所有内容。\n2）使程序在指定条件下停止。\n3）检查程序停止时发生的情况。\n4）更改程序中的内容，以便您可以尝试纠正一个错误的影响，然后继续学习另一个错误。\n2、一个例子：\ngdb 调试运行一个程序：\n$ gdb m4  --运行\n(gdb) set width 70 --设置显示最大字符数，类似more\n(gdb) break m4_changequote   --设置断点，断点可以是某个函数，如main\nBreakpoint 1 at 0x62f4: file builtin.c, line 879.\n(gdb) run\nStarting program: /work/Editorial/gdb/gnu/m4/m4  --开始运行\n(gdb) n   --next 不进入函数运行，运行下一行；\n(gdb) s  --step 运行下一行，遇到函数会进入\n\n(gdb) bt --backtrace 打印调用栈\n(gdb) p lquote  --打印变量lquote,这个是变量名\n(gdb) p 表达式，这个表达式可以是符合语法的表达式，比如赋值语句和函数调用等，是生效的；\neg (gdb) p ++a\n\n$1 = 0x35d40 \"<QUOTE>\"\n(gdb) l    ---list，显示源代码\n533             xfree(rquote);\n(gdb) Ctrl-d --退出程序\n(gdb)quit  /q --退出gdb\n3、经常使用分类\n3.1 如何开始：\n 1）gdb programname\n        2）gdb programname corefile\n        3)  gdb  programname pid   / gdb -p pid  (关联上一个-g编译过的正在运行的进程)\n        4)  gdb --args programname arg1 2 3....\n        eg:gdb --args gcc -O2 -c foo.c\n        5) gdb xx     --silent/--quit /-q 不用输出信息 \n3.2 在gdb中也可以使用shell指令：\n(gdb) !ifconfig\n\n3.3 设置log文件\n使用技巧：\n1）回车表示重复上一个命令，除了run等；\n2）step 数字，可以表示步进多少\n3.4 设置打印方式：\n1)要更改要打印的数组元素的限制\n(gdb)set print elements 10\n2)是否打印数组：\n       (GDB) set print array on\n       (GDB) print some_array\n       (GDB) set print array off\n3.5 gdb的自动补全，按tab即可，甚至可以补全函数名；\n3.6 gdb 命令有option ,tab键可以召唤出来；\n3.7 gdb和线程；\n3.8 gdb的栈概念\n4  常见命令\ngdb栈查看命令\nbacktrace [option]… [qualifier]… [count]\nbt [option]… [qualifier]… [count]\n(gdb) frame 3\n(gdb) frame level 3\n(gdb) info frame\nStack level 1, frame at 0x7fffffffda30:\n向上或向下跳帧；\nup n\ndown n \n\n(gdb) frame apply all p j\n#0  some_function (i=5) at fun.c:4\nNo symbol \"j\" in current context.\n(gdb) frame apply all -c p j\n#0  some_function (i=5) at fun.c:4\nNo symbol \"j\" in current context.\n打印变量：p\n显示源码 l\n\n5 参考资料\n\nhttps://scc.ustc.edu.cn/zlsc/sugon/intel/debugger/cl/index.htm#commandref/gdb_mode/cmd_set_width.htm\nmore:\nhttps://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\nhttps://sourceware.org/gdb/current/onlinedocs/gdb/\n\n使用例子：\n","slug":"gdb基本使用","published":1,"updated":"2020-07-11T07:45:16.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7oa001l2ujxracpurpm","content":"<p>1、总体<br>GDB可以做四种主要的事情（以及支持这些事情的其他事情）来帮助您捕获行为中的错误：<br><a id=\"more\"></a><br>1）启动程序，并指定可能影响其行为的所有内容。<br>2）使程序在指定条件下停止。<br>3）检查程序停止时发生的情况。<br>4）更改程序中的内容，以便您可以尝试纠正一个错误的影响，然后继续学习另一个错误。<br>2、一个例子：<br>gdb 调试运行一个程序：<br>$ gdb m4  –运行<br>(gdb) set width 70 –设置显示最大字符数，类似more<br>(gdb) break m4_changequote   –设置断点，断点可以是某个函数，如main<br>Breakpoint 1 at 0x62f4: file builtin.c, line 879.<br>(gdb) run<br>Starting program: /work/Editorial/gdb/gnu/m4/m4  –开始运行<br>(gdb) n   –next 不进入函数运行，运行下一行；<br>(gdb) s  –step 运行下一行，遇到函数会进入</p>\n<p>(gdb) bt –backtrace 打印调用栈<br>(gdb) p lquote  –打印变量lquote,这个是变量名<br>(gdb) p 表达式，这个表达式可以是符合语法的表达式，比如赋值语句和函数调用等，是生效的；<br>eg (gdb) p ++a</p>\n<p>$1 = 0x35d40 “<quote>“<br>(gdb) l    —list，显示源代码<br>533             xfree(rquote);<br>(gdb) Ctrl-d –退出程序<br>(gdb)quit  /q –退出gdb<br>3、经常使用分类<br>3.1 如何开始：<br> 1）gdb programname<br>        2）gdb programname corefile<br>        3)  gdb  programname pid   / gdb -p pid  (关联上一个-g编译过的正在运行的进程)<br>        4)  gdb –args programname arg1 2 3….<br>        eg:gdb –args gcc -O2 -c foo.c<br>        5) gdb xx     –silent/–quit /-q 不用输出信息<br>3.2 在gdb中也可以使用shell指令：<br>(gdb) !ifconfig</quote></p>\n<p>3.3 设置log文件<br>使用技巧：<br>1）回车表示重复上一个命令，除了run等；<br>2）step 数字，可以表示步进多少<br>3.4 设置打印方式：<br>1)要更改要打印的数组元素的限制<br>(gdb)set print elements 10<br>2)是否打印数组：<br>       (GDB) set print array on<br>       (GDB) print some_array<br>       (GDB) set print array off<br>3.5 gdb的自动补全，按tab即可，甚至可以补全函数名；<br>3.6 gdb 命令有option ,tab键可以召唤出来；<br>3.7 gdb和线程；<br>3.8 gdb的栈概念<br>4  常见命令<br>gdb栈查看命令<br>backtrace [option]… [qualifier]… [count]<br>bt [option]… [qualifier]… [count]<br>(gdb) frame 3<br>(gdb) frame level 3<br>(gdb) info frame<br>Stack level 1, frame at 0x7fffffffda30:<br>向上或向下跳帧；<br>up n<br>down n </p>\n<p>(gdb) frame apply all p j</p>\n<p>#0  some_function (i=5) at fun.c:4<br>No symbol “j” in current context.<br>(gdb) frame apply all -c p j</p>\n<p>#0  some_function (i=5) at fun.c:4<br>No symbol “j” in current context.<br>打印变量：p<br>显示源码 l</p>\n<p>5 参考资料</p>\n<p><a href=\"https://scc.ustc.edu.cn/zlsc/sugon/intel/debugger/cl/index.htm#commandref/gdb_mode/cmd_set_width.htm\" target=\"_blank\" rel=\"noopener\">https://scc.ustc.edu.cn/zlsc/sugon/intel/debugger/cl/index.htm#commandref/gdb_mode/cmd_set_width.htm</a><br>more:<br><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\" target=\"_blank\" rel=\"noopener\">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a><br><a href=\"https://sourceware.org/gdb/current/onlinedocs/gdb/\" target=\"_blank\" rel=\"noopener\">https://sourceware.org/gdb/current/onlinedocs/gdb/</a></p>\n<p>使用例子：</p>\n","site":{"data":{}},"excerpt":"<p>1、总体<br>GDB可以做四种主要的事情（以及支持这些事情的其他事情）来帮助您捕获行为中的错误：<br>","more":"<br>1）启动程序，并指定可能影响其行为的所有内容。<br>2）使程序在指定条件下停止。<br>3）检查程序停止时发生的情况。<br>4）更改程序中的内容，以便您可以尝试纠正一个错误的影响，然后继续学习另一个错误。<br>2、一个例子：<br>gdb 调试运行一个程序：<br>$ gdb m4  –运行<br>(gdb) set width 70 –设置显示最大字符数，类似more<br>(gdb) break m4_changequote   –设置断点，断点可以是某个函数，如main<br>Breakpoint 1 at 0x62f4: file builtin.c, line 879.<br>(gdb) run<br>Starting program: /work/Editorial/gdb/gnu/m4/m4  –开始运行<br>(gdb) n   –next 不进入函数运行，运行下一行；<br>(gdb) s  –step 运行下一行，遇到函数会进入</p>\n<p>(gdb) bt –backtrace 打印调用栈<br>(gdb) p lquote  –打印变量lquote,这个是变量名<br>(gdb) p 表达式，这个表达式可以是符合语法的表达式，比如赋值语句和函数调用等，是生效的；<br>eg (gdb) p ++a</p>\n<p>$1 = 0x35d40 “<quote>“<br>(gdb) l    —list，显示源代码<br>533             xfree(rquote);<br>(gdb) Ctrl-d –退出程序<br>(gdb)quit  /q –退出gdb<br>3、经常使用分类<br>3.1 如何开始：<br> 1）gdb programname<br>        2）gdb programname corefile<br>        3)  gdb  programname pid   / gdb -p pid  (关联上一个-g编译过的正在运行的进程)<br>        4)  gdb –args programname arg1 2 3….<br>        eg:gdb –args gcc -O2 -c foo.c<br>        5) gdb xx     –silent/–quit /-q 不用输出信息<br>3.2 在gdb中也可以使用shell指令：<br>(gdb) !ifconfig</quote></p>\n<p>3.3 设置log文件<br>使用技巧：<br>1）回车表示重复上一个命令，除了run等；<br>2）step 数字，可以表示步进多少<br>3.4 设置打印方式：<br>1)要更改要打印的数组元素的限制<br>(gdb)set print elements 10<br>2)是否打印数组：<br>       (GDB) set print array on<br>       (GDB) print some_array<br>       (GDB) set print array off<br>3.5 gdb的自动补全，按tab即可，甚至可以补全函数名；<br>3.6 gdb 命令有option ,tab键可以召唤出来；<br>3.7 gdb和线程；<br>3.8 gdb的栈概念<br>4  常见命令<br>gdb栈查看命令<br>backtrace [option]… [qualifier]… [count]<br>bt [option]… [qualifier]… [count]<br>(gdb) frame 3<br>(gdb) frame level 3<br>(gdb) info frame<br>Stack level 1, frame at 0x7fffffffda30:<br>向上或向下跳帧；<br>up n<br>down n </p>\n<p>(gdb) frame apply all p j</p>\n<p>#0  some_function (i=5) at fun.c:4<br>No symbol “j” in current context.<br>(gdb) frame apply all -c p j</p>\n<p>#0  some_function (i=5) at fun.c:4<br>No symbol “j” in current context.<br>打印变量：p<br>显示源码 l</p>\n<p>5 参考资料</p>\n<p><a href=\"https://scc.ustc.edu.cn/zlsc/sugon/intel/debugger/cl/index.htm#commandref/gdb_mode/cmd_set_width.htm\" target=\"_blank\" rel=\"noopener\">https://scc.ustc.edu.cn/zlsc/sugon/intel/debugger/cl/index.htm#commandref/gdb_mode/cmd_set_width.htm</a><br>more:<br><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\" target=\"_blank\" rel=\"noopener\">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a><br><a href=\"https://sourceware.org/gdb/current/onlinedocs/gdb/\" target=\"_blank\" rel=\"noopener\">https://sourceware.org/gdb/current/onlinedocs/gdb/</a></p>\n<p>使用例子：</p>"},{"title":"leetcode_linklist1","date":"2018-06-03T13:37:57.000Z","_content":"### leetcode——单链表\n\n#### 两数相加：\n+ 这道题是经一年多没刷题目之后，重新开始的第一道题，本来想着只是本地刷刷，后面开始就到leetcode提交了，毕竟写的程序还是得经过检验\n+ 所以这道题就纯粹的解答，未经检验，只是本地跑通，并且加上了自己的一些看法，比如对该题目该思路可能可以应用在哪些地方，这样算法才有了真正的意义，个人十分不赞同一些在公司呆久了的人说数据结构算法没什么用的人2333\n+ 废话不多说：  好久没写，第一道就别吐槽了，慢慢来\n+ 题目描述：  <!--more-->\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.  \nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\nExplanation: 342 + 465 = 807.\n注意两个数字位数可能不同，所以需要一些特殊情况要处理\n```c\n#include<stdio.h>\n#include<stdlib.h>```\n\n```c\nstruct ListNode {\n\t\tstruct ListNode *next;\n\t\tint num;\n} *linklist,listnode;\n\n//这是自己加的扩展，把输入的两个大数字符串转换为链表\nint changtolist(struct ListNode *list1,char num1[],struct ListNode *list2,char  num2[])\n{//应该在接口内计算长度好些\n   int i=0;\n   int lennum1=0;\n   while(num1[lennum1]!='\\0'){lennum1++;}\n   int lennum2=0;\n   while(num2[lennum2]!='\\0'){lennum2++;}\n//分配空间加字母转数字，无头节点\n   list1->num=num1[lennum1-1]-48;\n   for(i=lennum1-2;i>=0;i--)\n   {\n\t\tlist1->next=(struct ListNode*)malloc(sizeof(struct ListNode));\n\t\tlist1=list1->next;\n        list1->num=num1[i]-48;\n   }\n   list1->next=NULL;\n   list2->num=num2[lennum2-1]-48;\n   for(i=lennum2-2;i>=0;i--)\n   {\n\t\tlist2->next=(struct ListNode*)malloc(sizeof(struct ListNode));\n\t\tlist2=list2->next;\n\t\tlist2->num=num2[i]-48;\n   }\n   list2->next=NULL;\n   return 0;\n}\n//两个大数相加，不用头节点的方式，麻烦一些\nint Add_two_num(struct ListNode *list1,struct ListNode *list2)\n{\n\t int adding = 0;\n     if(list1 == NULL || list2 == NULL)\n\t\t\t return -1;\n/*\t while(list1!=NULL && list2!=NULL)\n\t {\n\t\t\t list1->num = (list1->num+list2->num+adding)%10;\n             adding = (list1->num + list2->num+adding)/10;\n\t\t\t list1 = list1->next;\n\t\t\t list2 = list2->next;\n\t}\n\t if(list1==NULL && list2!=NULL)\n\t*/\t\t \n\t  struct ListNode *xx=list1;\n      int n=0;\n\t  int sum=0;\n\t  sum = list1->num+list2->num+adding;\n\t  list1->num = sum%10;\n      adding = sum/10;\n\tdo {//常规情况，两个同长度部分\n\t\t\t list1 = list1->next;\n\t\t\t list2 = list2->next;\n\t\t\t sum= list1->num+list2->num+adding;\n\t\t\t list1->num = sum %10;\n\t\t\t// printf(\"%d \",list1->num);\n             adding = sum/10;\n    }while(list1->next!=NULL && list2->next!=NULL);\n\tif(list1->next ==NULL&& list2->next==NULL &&adding!=0)//串1短于串2\n\t{\n\t\t\tlist1->next = (struct ListNode *)malloc(sizeof(struct ListNode));\n\t\t\tlist1->next->num= adding;\n\t\t\tprintf(\"show:%d\\n\",adding);\n\t}\n\tif(list1->next==NULL && list2->next !=NULL)\n\t{\n\n\t\t\tlist1->next = list2->next;\n\t\t\twhile(list2->next!=NULL&&adding !=0)\n\t\t\t{\n              list2=list2->next;\n\t\t\t  sum= list2->num+adding;\n              list2->num=sum%10;\n\t\t\t  adding = sum/10;\n\t\t\t}\n\t\t\tif(adding>0)\n\t\t\t{\n\t\t\t\t\tlist2->next=(struct ListNode *)malloc(sizeof(struct ListNode));\n\t\t            list2->next->num=adding;\n\t\t\t}\n\t}  \n    ...//串1长于 串2\n    .....\n  \treturn 0;\n\n}\n//需要思考，当进位到最后时，可能1,2都结束了，但是产生高位，此时要new　listnode 完成\n//或者剩下２，和进位，则考虑２加进位\nint main ()\n{\n  struct ListNode *list1,*list2;\n  list1 = (struct ListNode*)malloc(sizeof(struct ListNode));\n  list2 = (struct ListNode*)malloc(sizeof(struct ListNode));\n  list1->num=3;\n  list2->num=5;\n  struct ListNode *tmplist1=list1;\n  struct ListNode *tmplist2=list2;\n  int i;\n  for(i=1; i<9;i++)\n  {\n    \n\tlist1->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n\tlist2->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n\tlist1 = list1->next;\n\tlist2 = list2->next;\n    list1->num = 2;\n\tlist2->num= 8;\n  }\n  list2->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n  list2->next->num=9; \n  struct ListNode *result=tmplist1;\n  struct ListNode *freelist1 = tmplist1;\n  struct ListNode *freelist2 = tmplist2;\n  for (i=0;i<9;i++,tmplist1=tmplist1->next)\n\t\t  printf(\"%d \",tmplist1->num);\n  printf(\"\\n\");\n\n  for (i=0;i<10;i++,tmplist2=tmplist2->next)\n\t\t  printf(\"%d \",tmplist2->num);\n  printf(\"\\n\");\n  Add_two_num(freelist1,freelist2);\n  for(i=0;result!=NULL ;i++,result=result->next)\n       printf(\"%d \",result->num); \n  free(freelist1);\n  free(freelist2);\n\n\n  printf(\"\\n\");\n//-------------------------------\n  struct ListNode *list11,*list22;\n  list11 = (struct ListNode*)malloc(sizeof(struct ListNode));\n  list22 = (struct ListNode*)malloc(sizeof(struct ListNode));\n\n\n  char num1[100],num2[100];\n  gets(num1);\n  gets(num2);\n  changtolist(list11,num1,list22,num2);\n  struct ListNode *result11 = list11;\n  Add_two_num(list11,list22);\n  for(i=0;result11!=NULL ;i++,result11=result11->next)\n       printf(\"%d \",result11->num); \n  free(list11);\n  free(list22);\n  return 0;\n}```\n//思考，扩大这道题的应用，在大数相加的时候，增加用户输入接口:\"\n//5263565656554+5656537677834546\n//由char读入，int/char相加，\n-------极其丑的程序，以后不能这么搞，留个纪念\n想贴下两年多前（大三吧，那会刷这道题通过的程序--看来最喜欢的还是c）\n```c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\n class Solution {\n public:\n\t ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n\t\t ListNode *sum, *l4;\n\t\t sum = new ListNode(0); //新节点\n\t\t l4 = sum;\n\t\t int sum_single, en = 0;//en表示进位的标志\n\t\t while (l1 != NULL&&l2 != NULL)\n\t\t {\n\t\t\t \n\t\t\t\t sum->next = new ListNode(0);//这里有个问题变为sum=NULL就行\n\t\t\t\t sum = sum->next;\n\t\t\t// signal = 0;\n\t\t\t sum_single = l1->val + l2->val + en;\n\t\t\t if (sum_single<10)\n\t\t\t {\n\t\t\t\t sum->val = sum_single;\n\t\t\t\t en = 0;\n\t\t\t }\n\t\t\t else if (sum_single >= 10)\n\t\t\t {\n\t\t\t\t sum->val = sum_single - 10;\n\t\t\t\t en = 1;\n\t\t\t }\n\t\t\t l1 = l1->next;\n\t\t\t l2 = l2->next;\n\t\t\n\t\t }\n\t\t while (l1 != NULL&&l2 == NULL)\n\t\t { \n\t\t\t sum->next = new ListNode(0);\n\t\t\t sum = sum->next;\n\t\t\t sum_single = en + l1->val;\n\t\t\t if (sum_single >= 10)\n\t\t\t {\n\t\t\t\t sum->val = sum_single - 10;\n\t\t\t\t en = 1;\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t sum->val = sum_single;\n\t\t\t\t en = 0;\n\t\t\t }\n\t\t\t l1 = l1->next;\n\t\t\t\n\n\t\t }\n\t\t while (l2 != NULL&&l1 == NULL)\n\t\t { \n\t\t\t sum->next = new ListNode(0);\n\t\t\t sum = sum->next;\n\t\t\t sum_single = en + l2->val;\n\t\t\t if (sum_single >= 10)\n\t\t\t {\n\t\t\t\t sum->val = sum_single - 10;\n\t\t\t\t en = 1;\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t sum->val = sum_single;\n\t\t\t\t en = 0;\n\t\t\t }\n\t\t\t l2 = l2->next;\n\t\t }\n\t\t if (l1 == NULL&&l2 == NULL&&en == 1)\n\t\t\t sum->next = new ListNode(en);\n\t\t//if(l1==NULL&&l2==NULL&&en==0)sum = NULL;\n\t/*\t while (l3)\n\t\t {\n\t\t\t cout << l3->val;\n\t\t\t l3 = l3->next;\n\t\t }*/\n\t\t return l4->next;\n\t }\n };\n/*\nint main()\n{\n    Solution sou;\n    ListNode *l1,*l2,*l3;\n    l1=new ListNode(3);\n    l1->next=new ListNode(7);\n    l1->next->next=new ListNode(5);\n    \n     l2=new ListNode(7);\n    l2->next=new ListNode(7);\n    l2->next->next=new ListNode(5);\n    l3=sou.addTwoNumbers(l1,l2);\n    cout<<l3->val<<l3->next->val<<l3->next->next->val;\n    return 0;\n}\n\n\n\n*/```","source":"_posts/leetcode-linklist1.md","raw":"---\ntitle: leetcode_linklist1\ndate: 2018-06-03 21:37:57\ntags: leetcode_linklist\ncategories: leetcode\n---\n### leetcode——单链表\n\n#### 两数相加：\n+ 这道题是经一年多没刷题目之后，重新开始的第一道题，本来想着只是本地刷刷，后面开始就到leetcode提交了，毕竟写的程序还是得经过检验\n+ 所以这道题就纯粹的解答，未经检验，只是本地跑通，并且加上了自己的一些看法，比如对该题目该思路可能可以应用在哪些地方，这样算法才有了真正的意义，个人十分不赞同一些在公司呆久了的人说数据结构算法没什么用的人2333\n+ 废话不多说：  好久没写，第一道就别吐槽了，慢慢来\n+ 题目描述：  <!--more-->\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.  \nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\nExplanation: 342 + 465 = 807.\n注意两个数字位数可能不同，所以需要一些特殊情况要处理\n```c\n#include<stdio.h>\n#include<stdlib.h>```\n\n```c\nstruct ListNode {\n\t\tstruct ListNode *next;\n\t\tint num;\n} *linklist,listnode;\n\n//这是自己加的扩展，把输入的两个大数字符串转换为链表\nint changtolist(struct ListNode *list1,char num1[],struct ListNode *list2,char  num2[])\n{//应该在接口内计算长度好些\n   int i=0;\n   int lennum1=0;\n   while(num1[lennum1]!='\\0'){lennum1++;}\n   int lennum2=0;\n   while(num2[lennum2]!='\\0'){lennum2++;}\n//分配空间加字母转数字，无头节点\n   list1->num=num1[lennum1-1]-48;\n   for(i=lennum1-2;i>=0;i--)\n   {\n\t\tlist1->next=(struct ListNode*)malloc(sizeof(struct ListNode));\n\t\tlist1=list1->next;\n        list1->num=num1[i]-48;\n   }\n   list1->next=NULL;\n   list2->num=num2[lennum2-1]-48;\n   for(i=lennum2-2;i>=0;i--)\n   {\n\t\tlist2->next=(struct ListNode*)malloc(sizeof(struct ListNode));\n\t\tlist2=list2->next;\n\t\tlist2->num=num2[i]-48;\n   }\n   list2->next=NULL;\n   return 0;\n}\n//两个大数相加，不用头节点的方式，麻烦一些\nint Add_two_num(struct ListNode *list1,struct ListNode *list2)\n{\n\t int adding = 0;\n     if(list1 == NULL || list2 == NULL)\n\t\t\t return -1;\n/*\t while(list1!=NULL && list2!=NULL)\n\t {\n\t\t\t list1->num = (list1->num+list2->num+adding)%10;\n             adding = (list1->num + list2->num+adding)/10;\n\t\t\t list1 = list1->next;\n\t\t\t list2 = list2->next;\n\t}\n\t if(list1==NULL && list2!=NULL)\n\t*/\t\t \n\t  struct ListNode *xx=list1;\n      int n=0;\n\t  int sum=0;\n\t  sum = list1->num+list2->num+adding;\n\t  list1->num = sum%10;\n      adding = sum/10;\n\tdo {//常规情况，两个同长度部分\n\t\t\t list1 = list1->next;\n\t\t\t list2 = list2->next;\n\t\t\t sum= list1->num+list2->num+adding;\n\t\t\t list1->num = sum %10;\n\t\t\t// printf(\"%d \",list1->num);\n             adding = sum/10;\n    }while(list1->next!=NULL && list2->next!=NULL);\n\tif(list1->next ==NULL&& list2->next==NULL &&adding!=0)//串1短于串2\n\t{\n\t\t\tlist1->next = (struct ListNode *)malloc(sizeof(struct ListNode));\n\t\t\tlist1->next->num= adding;\n\t\t\tprintf(\"show:%d\\n\",adding);\n\t}\n\tif(list1->next==NULL && list2->next !=NULL)\n\t{\n\n\t\t\tlist1->next = list2->next;\n\t\t\twhile(list2->next!=NULL&&adding !=0)\n\t\t\t{\n              list2=list2->next;\n\t\t\t  sum= list2->num+adding;\n              list2->num=sum%10;\n\t\t\t  adding = sum/10;\n\t\t\t}\n\t\t\tif(adding>0)\n\t\t\t{\n\t\t\t\t\tlist2->next=(struct ListNode *)malloc(sizeof(struct ListNode));\n\t\t            list2->next->num=adding;\n\t\t\t}\n\t}  \n    ...//串1长于 串2\n    .....\n  \treturn 0;\n\n}\n//需要思考，当进位到最后时，可能1,2都结束了，但是产生高位，此时要new　listnode 完成\n//或者剩下２，和进位，则考虑２加进位\nint main ()\n{\n  struct ListNode *list1,*list2;\n  list1 = (struct ListNode*)malloc(sizeof(struct ListNode));\n  list2 = (struct ListNode*)malloc(sizeof(struct ListNode));\n  list1->num=3;\n  list2->num=5;\n  struct ListNode *tmplist1=list1;\n  struct ListNode *tmplist2=list2;\n  int i;\n  for(i=1; i<9;i++)\n  {\n    \n\tlist1->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n\tlist2->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n\tlist1 = list1->next;\n\tlist2 = list2->next;\n    list1->num = 2;\n\tlist2->num= 8;\n  }\n  list2->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n  list2->next->num=9; \n  struct ListNode *result=tmplist1;\n  struct ListNode *freelist1 = tmplist1;\n  struct ListNode *freelist2 = tmplist2;\n  for (i=0;i<9;i++,tmplist1=tmplist1->next)\n\t\t  printf(\"%d \",tmplist1->num);\n  printf(\"\\n\");\n\n  for (i=0;i<10;i++,tmplist2=tmplist2->next)\n\t\t  printf(\"%d \",tmplist2->num);\n  printf(\"\\n\");\n  Add_two_num(freelist1,freelist2);\n  for(i=0;result!=NULL ;i++,result=result->next)\n       printf(\"%d \",result->num); \n  free(freelist1);\n  free(freelist2);\n\n\n  printf(\"\\n\");\n//-------------------------------\n  struct ListNode *list11,*list22;\n  list11 = (struct ListNode*)malloc(sizeof(struct ListNode));\n  list22 = (struct ListNode*)malloc(sizeof(struct ListNode));\n\n\n  char num1[100],num2[100];\n  gets(num1);\n  gets(num2);\n  changtolist(list11,num1,list22,num2);\n  struct ListNode *result11 = list11;\n  Add_two_num(list11,list22);\n  for(i=0;result11!=NULL ;i++,result11=result11->next)\n       printf(\"%d \",result11->num); \n  free(list11);\n  free(list22);\n  return 0;\n}```\n//思考，扩大这道题的应用，在大数相加的时候，增加用户输入接口:\"\n//5263565656554+5656537677834546\n//由char读入，int/char相加，\n-------极其丑的程序，以后不能这么搞，留个纪念\n想贴下两年多前（大三吧，那会刷这道题通过的程序--看来最喜欢的还是c）\n```c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\n class Solution {\n public:\n\t ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n\t\t ListNode *sum, *l4;\n\t\t sum = new ListNode(0); //新节点\n\t\t l4 = sum;\n\t\t int sum_single, en = 0;//en表示进位的标志\n\t\t while (l1 != NULL&&l2 != NULL)\n\t\t {\n\t\t\t \n\t\t\t\t sum->next = new ListNode(0);//这里有个问题变为sum=NULL就行\n\t\t\t\t sum = sum->next;\n\t\t\t// signal = 0;\n\t\t\t sum_single = l1->val + l2->val + en;\n\t\t\t if (sum_single<10)\n\t\t\t {\n\t\t\t\t sum->val = sum_single;\n\t\t\t\t en = 0;\n\t\t\t }\n\t\t\t else if (sum_single >= 10)\n\t\t\t {\n\t\t\t\t sum->val = sum_single - 10;\n\t\t\t\t en = 1;\n\t\t\t }\n\t\t\t l1 = l1->next;\n\t\t\t l2 = l2->next;\n\t\t\n\t\t }\n\t\t while (l1 != NULL&&l2 == NULL)\n\t\t { \n\t\t\t sum->next = new ListNode(0);\n\t\t\t sum = sum->next;\n\t\t\t sum_single = en + l1->val;\n\t\t\t if (sum_single >= 10)\n\t\t\t {\n\t\t\t\t sum->val = sum_single - 10;\n\t\t\t\t en = 1;\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t sum->val = sum_single;\n\t\t\t\t en = 0;\n\t\t\t }\n\t\t\t l1 = l1->next;\n\t\t\t\n\n\t\t }\n\t\t while (l2 != NULL&&l1 == NULL)\n\t\t { \n\t\t\t sum->next = new ListNode(0);\n\t\t\t sum = sum->next;\n\t\t\t sum_single = en + l2->val;\n\t\t\t if (sum_single >= 10)\n\t\t\t {\n\t\t\t\t sum->val = sum_single - 10;\n\t\t\t\t en = 1;\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t sum->val = sum_single;\n\t\t\t\t en = 0;\n\t\t\t }\n\t\t\t l2 = l2->next;\n\t\t }\n\t\t if (l1 == NULL&&l2 == NULL&&en == 1)\n\t\t\t sum->next = new ListNode(en);\n\t\t//if(l1==NULL&&l2==NULL&&en==0)sum = NULL;\n\t/*\t while (l3)\n\t\t {\n\t\t\t cout << l3->val;\n\t\t\t l3 = l3->next;\n\t\t }*/\n\t\t return l4->next;\n\t }\n };\n/*\nint main()\n{\n    Solution sou;\n    ListNode *l1,*l2,*l3;\n    l1=new ListNode(3);\n    l1->next=new ListNode(7);\n    l1->next->next=new ListNode(5);\n    \n     l2=new ListNode(7);\n    l2->next=new ListNode(7);\n    l2->next->next=new ListNode(5);\n    l3=sou.addTwoNumbers(l1,l2);\n    cout<<l3->val<<l3->next->val<<l3->next->next->val;\n    return 0;\n}\n\n\n\n*/```","slug":"leetcode-linklist1","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7oe001o2ujx3rvea9w3","content":"<h3 id=\"leetcode——单链表\"><a href=\"#leetcode——单链表\" class=\"headerlink\" title=\"leetcode——单链表\"></a>leetcode——单链表</h3><h4 id=\"两数相加：\"><a href=\"#两数相加：\" class=\"headerlink\" title=\"两数相加：\"></a>两数相加：</h4><ul>\n<li>这道题是经一年多没刷题目之后，重新开始的第一道题，本来想着只是本地刷刷，后面开始就到leetcode提交了，毕竟写的程序还是得经过检验</li>\n<li>所以这道题就纯粹的解答，未经检验，只是本地跑通，并且加上了自己的一些看法，比如对该题目该思路可能可以应用在哪些地方，这样算法才有了真正的意义，个人十分不赞同一些在公司呆久了的人说数据结构算法没什么用的人2333</li>\n<li>废话不多说：  好久没写，第一道就别吐槽了，慢慢来</li>\n<li>题目描述：  <a id=\"more\"></a><br>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>Example<br>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.<br>注意两个数字位数可能不同，所以需要一些特殊情况要处理<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> num;</span><br><span class=\"line\">&#125; *linklist,listnode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这是自己加的扩展，把输入的两个大数字符串转换为链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">changtolist</span><span class=\"params\">(struct ListNode *list1,<span class=\"keyword\">char</span> num1[],struct ListNode *list2,<span class=\"keyword\">char</span>  num2[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;<span class=\"comment\">//应该在接口内计算长度好些</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> lennum1=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">while</span>(num1[lennum1]!=<span class=\"string\">'\\0'</span>)&#123;lennum1++;&#125;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> lennum2=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">while</span>(num2[lennum2]!=<span class=\"string\">'\\0'</span>)&#123;lennum2++;&#125;</span><br><span class=\"line\"><span class=\"comment\">//分配空间加字母转数字，无头节点</span></span><br><span class=\"line\">   list1-&gt;num=num1[lennum1<span class=\"number\">-1</span>]<span class=\"number\">-48</span>;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=lennum1<span class=\"number\">-2</span>;i&gt;=<span class=\"number\">0</span>;i--)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">\t\tlist1-&gt;next=(struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\t\tlist1=list1-&gt;next;</span><br><span class=\"line\">        list1-&gt;num=num1[i]<span class=\"number\">-48</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   list1-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   list2-&gt;num=num2[lennum2<span class=\"number\">-1</span>]<span class=\"number\">-48</span>;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=lennum2<span class=\"number\">-2</span>;i&gt;=<span class=\"number\">0</span>;i--)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">\t\tlist2-&gt;next=(struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\t\tlist2=list2-&gt;next;</span><br><span class=\"line\">\t\tlist2-&gt;num=num2[i]<span class=\"number\">-48</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   list2-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//两个大数相加，不用头节点的方式，麻烦一些</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Add_two_num</span><span class=\"params\">(struct ListNode *list1,struct ListNode *list2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">int</span> adding = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(list1 == <span class=\"literal\">NULL</span> || list2 == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"comment\">/*\t while(list1!=NULL &amp;&amp; list2!=NULL)</span></span><br><span class=\"line\"><span class=\"comment\">\t &#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t list1-&gt;num = (list1-&gt;num+list2-&gt;num+adding)%10;</span></span><br><span class=\"line\"><span class=\"comment\">             adding = (list1-&gt;num + list2-&gt;num+adding)/10;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t list1 = list1-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t list2 = list2-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t if(list1==NULL &amp;&amp; list2!=NULL)</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span>\t\t </span><br><span class=\"line\">\t  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">xx</span>=<span class=\"title\">list1</span>;</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> n=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t  <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t  sum = list1-&gt;num+list2-&gt;num+adding;</span><br><span class=\"line\">\t  list1-&gt;num = sum%<span class=\"number\">10</span>;</span><br><span class=\"line\">      adding = sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;<span class=\"comment\">//常规情况，两个同长度部分</span></span><br><span class=\"line\">\t\t\t list1 = list1-&gt;next;</span><br><span class=\"line\">\t\t\t list2 = list2-&gt;next;</span><br><span class=\"line\">\t\t\t sum= list1-&gt;num+list2-&gt;num+adding;</span><br><span class=\"line\">\t\t\t list1-&gt;num = sum %<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// printf(\"%d \",list1-&gt;num);</span></span><br><span class=\"line\">             adding = sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(list1-&gt;next!=<span class=\"literal\">NULL</span> &amp;&amp; list2-&gt;next!=<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(list1-&gt;next ==<span class=\"literal\">NULL</span>&amp;&amp; list2-&gt;next==<span class=\"literal\">NULL</span> &amp;&amp;adding!=<span class=\"number\">0</span>)<span class=\"comment\">//串1短于串2</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t\tlist1-&gt;next = (struct ListNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\t\t\tlist1-&gt;next-&gt;num= adding;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"show:%d\\n\"</span>,adding);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(list1-&gt;next==<span class=\"literal\">NULL</span> &amp;&amp; list2-&gt;next !=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tlist1-&gt;next = list2-&gt;next;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(list2-&gt;next!=<span class=\"literal\">NULL</span>&amp;&amp;adding !=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">              list2=list2-&gt;next;</span><br><span class=\"line\">\t\t\t  sum= list2-&gt;num+adding;</span><br><span class=\"line\">              list2-&gt;num=sum%<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t  adding = sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(adding&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tlist2-&gt;next=(struct ListNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\t\t            list2-&gt;next-&gt;num=adding;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">    ...<span class=\"comment\">//串1长于 串2</span></span><br><span class=\"line\">    .....</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//需要思考，当进位到最后时，可能1,2都结束了，但是产生高位，此时要new　listnode 完成</span></span><br><span class=\"line\"><span class=\"comment\">//或者剩下２，和进位，则考虑２加进位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">list1</span>,*<span class=\"title\">list2</span>;</span></span><br><span class=\"line\">  list1 = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">  list2 = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">  list1-&gt;num=<span class=\"number\">3</span>;</span><br><span class=\"line\">  list2-&gt;num=<span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">tmplist1</span>=<span class=\"title\">list1</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">tmplist2</span>=<span class=\"title\">list2</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;<span class=\"number\">9</span>;i++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\tlist1-&gt;next = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\tlist2-&gt;next = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\tlist1 = list1-&gt;next;</span><br><span class=\"line\">\tlist2 = list2-&gt;next;</span><br><span class=\"line\">    list1-&gt;num = <span class=\"number\">2</span>;</span><br><span class=\"line\">\tlist2-&gt;num= <span class=\"number\">8</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  list2-&gt;next = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">  list2-&gt;next-&gt;num=<span class=\"number\">9</span>; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">result</span>=<span class=\"title\">tmplist1</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">freelist1</span> = <span class=\"title\">tmplist1</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">freelist2</span> = <span class=\"title\">tmplist2</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">9</span>;i++,tmplist1=tmplist1-&gt;next)</span><br><span class=\"line\">\t\t  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,tmplist1-&gt;num);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++,tmplist2=tmplist2-&gt;next)</span><br><span class=\"line\">\t\t  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,tmplist2-&gt;num);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">  Add_two_num(freelist1,freelist2);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;result!=<span class=\"literal\">NULL</span> ;i++,result=result-&gt;next)</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,result-&gt;num); </span><br><span class=\"line\">  <span class=\"built_in\">free</span>(freelist1);</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(freelist2);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//-------------------------------</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">list11</span>,*<span class=\"title\">list22</span>;</span></span><br><span class=\"line\">  list11 = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">  list22 = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">char</span> num1[<span class=\"number\">100</span>],num2[<span class=\"number\">100</span>];</span><br><span class=\"line\">  gets(num1);</span><br><span class=\"line\">  gets(num2);</span><br><span class=\"line\">  changtolist(list11,num1,list22,num2);</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">result11</span> = <span class=\"title\">list11</span>;</span></span><br><span class=\"line\">  Add_two_num(list11,list22);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;result11!=<span class=\"literal\">NULL</span> ;i++,result11=result11-&gt;next)</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,result11-&gt;num); </span><br><span class=\"line\">  <span class=\"built_in\">free</span>(list11);</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(list22);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>//思考，扩大这道题的应用，在大数相加的时候，增加用户输入接口:”<br>//5263565656554+5656537677834546<br>//由char读入，int/char相加，<br>——-极其丑的程序，以后不能这么搞，留个纪念<br>想贴下两年多前（大三吧，那会刷这道题通过的程序–看来最喜欢的还是c）<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">\t\t ListNode *sum, *l4;</span><br><span class=\"line\">\t\t sum = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>); <span class=\"comment\">//新节点</span></span><br><span class=\"line\">\t\t l4 = sum;</span><br><span class=\"line\">\t\t <span class=\"keyword\">int</span> sum_single, en = <span class=\"number\">0</span>;<span class=\"comment\">//en表示进位的标志</span></span><br><span class=\"line\">\t\t <span class=\"keyword\">while</span> (l1 != <span class=\"literal\">NULL</span>&amp;&amp;l2 != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t &#123;</span><br><span class=\"line\">\t\t\t </span><br><span class=\"line\">\t\t\t\t sum-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);<span class=\"comment\">//这里有个问题变为sum=NULL就行</span></span><br><span class=\"line\">\t\t\t\t sum = sum-&gt;next;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// signal = 0;</span></span><br><span class=\"line\">\t\t\t sum_single = l1-&gt;val + l2-&gt;val + en;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">if</span> (sum_single&lt;<span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t sum-&gt;val = sum_single;</span><br><span class=\"line\">\t\t\t\t en = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum_single &gt;= <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t sum-&gt;val = sum_single - <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t\t en = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t l1 = l1-&gt;next;</span><br><span class=\"line\">\t\t\t l2 = l2-&gt;next;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">while</span> (l1 != <span class=\"literal\">NULL</span>&amp;&amp;l2 == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t &#123; </span><br><span class=\"line\">\t\t\t sum-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t sum = sum-&gt;next;</span><br><span class=\"line\">\t\t\t sum_single = en + l1-&gt;val;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">if</span> (sum_single &gt;= <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t sum-&gt;val = sum_single - <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t\t en = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t sum-&gt;val = sum_single;</span><br><span class=\"line\">\t\t\t\t en = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t l1 = l1-&gt;next;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">while</span> (l2 != <span class=\"literal\">NULL</span>&amp;&amp;l1 == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t &#123; </span><br><span class=\"line\">\t\t\t sum-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t sum = sum-&gt;next;</span><br><span class=\"line\">\t\t\t sum_single = en + l2-&gt;val;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">if</span> (sum_single &gt;= <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t sum-&gt;val = sum_single - <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t\t en = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t sum-&gt;val = sum_single;</span><br><span class=\"line\">\t\t\t\t en = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t l2 = l2-&gt;next;</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">if</span> (l1 == <span class=\"literal\">NULL</span>&amp;&amp;l2 == <span class=\"literal\">NULL</span>&amp;&amp;en == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t sum-&gt;next = <span class=\"keyword\">new</span> ListNode(en);</span><br><span class=\"line\">\t\t<span class=\"comment\">//if(l1==NULL&amp;&amp;l2==NULL&amp;&amp;en==0)sum = NULL;</span></span><br><span class=\"line\">\t<span class=\"comment\">/*\t while (l3)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t &#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t cout &lt;&lt; l3-&gt;val;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t l3 = l3-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t &#125;*/</span></span><br><span class=\"line\">\t\t <span class=\"keyword\">return</span> l4-&gt;next;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">int main()</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    Solution sou;</span></span><br><span class=\"line\"><span class=\"comment\">    ListNode *l1,*l2,*l3;</span></span><br><span class=\"line\"><span class=\"comment\">    l1=new ListNode(3);</span></span><br><span class=\"line\"><span class=\"comment\">    l1-&gt;next=new ListNode(7);</span></span><br><span class=\"line\"><span class=\"comment\">    l1-&gt;next-&gt;next=new ListNode(5);</span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"><span class=\"comment\">     l2=new ListNode(7);</span></span><br><span class=\"line\"><span class=\"comment\">    l2-&gt;next=new ListNode(7);</span></span><br><span class=\"line\"><span class=\"comment\">    l2-&gt;next-&gt;next=new ListNode(5);</span></span><br><span class=\"line\"><span class=\"comment\">    l3=sou.addTwoNumbers(l1,l2);</span></span><br><span class=\"line\"><span class=\"comment\">    cout&lt;&lt;l3-&gt;val&lt;&lt;l3-&gt;next-&gt;val&lt;&lt;l3-&gt;next-&gt;next-&gt;val;</span></span><br><span class=\"line\"><span class=\"comment\">    return 0;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"leetcode——单链表\"><a href=\"#leetcode——单链表\" class=\"headerlink\" title=\"leetcode——单链表\"></a>leetcode——单链表</h3><h4 id=\"两数相加：\"><a href=\"#两数相加：\" class=\"headerlink\" title=\"两数相加：\"></a>两数相加：</h4><ul>\n<li>这道题是经一年多没刷题目之后，重新开始的第一道题，本来想着只是本地刷刷，后面开始就到leetcode提交了，毕竟写的程序还是得经过检验</li>\n<li>所以这道题就纯粹的解答，未经检验，只是本地跑通，并且加上了自己的一些看法，比如对该题目该思路可能可以应用在哪些地方，这样算法才有了真正的意义，个人十分不赞同一些在公司呆久了的人说数据结构算法没什么用的人2333</li>\n<li>废话不多说：  好久没写，第一道就别吐槽了，慢慢来</li>\n<li>题目描述：","more":"<br>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>Example<br>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.<br>注意两个数字位数可能不同，所以需要一些特殊情况要处理<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> num;</span><br><span class=\"line\">&#125; *linklist,listnode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这是自己加的扩展，把输入的两个大数字符串转换为链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">changtolist</span><span class=\"params\">(struct ListNode *list1,<span class=\"keyword\">char</span> num1[],struct ListNode *list2,<span class=\"keyword\">char</span>  num2[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;<span class=\"comment\">//应该在接口内计算长度好些</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> lennum1=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">while</span>(num1[lennum1]!=<span class=\"string\">'\\0'</span>)&#123;lennum1++;&#125;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> lennum2=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">while</span>(num2[lennum2]!=<span class=\"string\">'\\0'</span>)&#123;lennum2++;&#125;</span><br><span class=\"line\"><span class=\"comment\">//分配空间加字母转数字，无头节点</span></span><br><span class=\"line\">   list1-&gt;num=num1[lennum1<span class=\"number\">-1</span>]<span class=\"number\">-48</span>;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=lennum1<span class=\"number\">-2</span>;i&gt;=<span class=\"number\">0</span>;i--)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">\t\tlist1-&gt;next=(struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\t\tlist1=list1-&gt;next;</span><br><span class=\"line\">        list1-&gt;num=num1[i]<span class=\"number\">-48</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   list1-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   list2-&gt;num=num2[lennum2<span class=\"number\">-1</span>]<span class=\"number\">-48</span>;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=lennum2<span class=\"number\">-2</span>;i&gt;=<span class=\"number\">0</span>;i--)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">\t\tlist2-&gt;next=(struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\t\tlist2=list2-&gt;next;</span><br><span class=\"line\">\t\tlist2-&gt;num=num2[i]<span class=\"number\">-48</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   list2-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//两个大数相加，不用头节点的方式，麻烦一些</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Add_two_num</span><span class=\"params\">(struct ListNode *list1,struct ListNode *list2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">int</span> adding = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(list1 == <span class=\"literal\">NULL</span> || list2 == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"comment\">/*\t while(list1!=NULL &amp;&amp; list2!=NULL)</span></span><br><span class=\"line\"><span class=\"comment\">\t &#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t list1-&gt;num = (list1-&gt;num+list2-&gt;num+adding)%10;</span></span><br><span class=\"line\"><span class=\"comment\">             adding = (list1-&gt;num + list2-&gt;num+adding)/10;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t list1 = list1-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t list2 = list2-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t if(list1==NULL &amp;&amp; list2!=NULL)</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span>\t\t </span><br><span class=\"line\">\t  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">xx</span>=<span class=\"title\">list1</span>;</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> n=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t  <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t  sum = list1-&gt;num+list2-&gt;num+adding;</span><br><span class=\"line\">\t  list1-&gt;num = sum%<span class=\"number\">10</span>;</span><br><span class=\"line\">      adding = sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;<span class=\"comment\">//常规情况，两个同长度部分</span></span><br><span class=\"line\">\t\t\t list1 = list1-&gt;next;</span><br><span class=\"line\">\t\t\t list2 = list2-&gt;next;</span><br><span class=\"line\">\t\t\t sum= list1-&gt;num+list2-&gt;num+adding;</span><br><span class=\"line\">\t\t\t list1-&gt;num = sum %<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// printf(\"%d \",list1-&gt;num);</span></span><br><span class=\"line\">             adding = sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(list1-&gt;next!=<span class=\"literal\">NULL</span> &amp;&amp; list2-&gt;next!=<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(list1-&gt;next ==<span class=\"literal\">NULL</span>&amp;&amp; list2-&gt;next==<span class=\"literal\">NULL</span> &amp;&amp;adding!=<span class=\"number\">0</span>)<span class=\"comment\">//串1短于串2</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t\tlist1-&gt;next = (struct ListNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\t\t\tlist1-&gt;next-&gt;num= adding;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"show:%d\\n\"</span>,adding);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(list1-&gt;next==<span class=\"literal\">NULL</span> &amp;&amp; list2-&gt;next !=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tlist1-&gt;next = list2-&gt;next;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(list2-&gt;next!=<span class=\"literal\">NULL</span>&amp;&amp;adding !=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">              list2=list2-&gt;next;</span><br><span class=\"line\">\t\t\t  sum= list2-&gt;num+adding;</span><br><span class=\"line\">              list2-&gt;num=sum%<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t  adding = sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(adding&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tlist2-&gt;next=(struct ListNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\t\t            list2-&gt;next-&gt;num=adding;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">    ...<span class=\"comment\">//串1长于 串2</span></span><br><span class=\"line\">    .....</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//需要思考，当进位到最后时，可能1,2都结束了，但是产生高位，此时要new　listnode 完成</span></span><br><span class=\"line\"><span class=\"comment\">//或者剩下２，和进位，则考虑２加进位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">list1</span>,*<span class=\"title\">list2</span>;</span></span><br><span class=\"line\">  list1 = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">  list2 = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">  list1-&gt;num=<span class=\"number\">3</span>;</span><br><span class=\"line\">  list2-&gt;num=<span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">tmplist1</span>=<span class=\"title\">list1</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">tmplist2</span>=<span class=\"title\">list2</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;<span class=\"number\">9</span>;i++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\tlist1-&gt;next = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\tlist2-&gt;next = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\tlist1 = list1-&gt;next;</span><br><span class=\"line\">\tlist2 = list2-&gt;next;</span><br><span class=\"line\">    list1-&gt;num = <span class=\"number\">2</span>;</span><br><span class=\"line\">\tlist2-&gt;num= <span class=\"number\">8</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  list2-&gt;next = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">  list2-&gt;next-&gt;num=<span class=\"number\">9</span>; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">result</span>=<span class=\"title\">tmplist1</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">freelist1</span> = <span class=\"title\">tmplist1</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">freelist2</span> = <span class=\"title\">tmplist2</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">9</span>;i++,tmplist1=tmplist1-&gt;next)</span><br><span class=\"line\">\t\t  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,tmplist1-&gt;num);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++,tmplist2=tmplist2-&gt;next)</span><br><span class=\"line\">\t\t  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,tmplist2-&gt;num);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">  Add_two_num(freelist1,freelist2);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;result!=<span class=\"literal\">NULL</span> ;i++,result=result-&gt;next)</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,result-&gt;num); </span><br><span class=\"line\">  <span class=\"built_in\">free</span>(freelist1);</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(freelist2);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//-------------------------------</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">list11</span>,*<span class=\"title\">list22</span>;</span></span><br><span class=\"line\">  list11 = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">  list22 = (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">char</span> num1[<span class=\"number\">100</span>],num2[<span class=\"number\">100</span>];</span><br><span class=\"line\">  gets(num1);</span><br><span class=\"line\">  gets(num2);</span><br><span class=\"line\">  changtolist(list11,num1,list22,num2);</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">result11</span> = <span class=\"title\">list11</span>;</span></span><br><span class=\"line\">  Add_two_num(list11,list22);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;result11!=<span class=\"literal\">NULL</span> ;i++,result11=result11-&gt;next)</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,result11-&gt;num); </span><br><span class=\"line\">  <span class=\"built_in\">free</span>(list11);</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(list22);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>//思考，扩大这道题的应用，在大数相加的时候，增加用户输入接口:”<br>//5263565656554+5656537677834546<br>//由char读入，int/char相加，<br>——-极其丑的程序，以后不能这么搞，留个纪念<br>想贴下两年多前（大三吧，那会刷这道题通过的程序–看来最喜欢的还是c）<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">\t\t ListNode *sum, *l4;</span><br><span class=\"line\">\t\t sum = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>); <span class=\"comment\">//新节点</span></span><br><span class=\"line\">\t\t l4 = sum;</span><br><span class=\"line\">\t\t <span class=\"keyword\">int</span> sum_single, en = <span class=\"number\">0</span>;<span class=\"comment\">//en表示进位的标志</span></span><br><span class=\"line\">\t\t <span class=\"keyword\">while</span> (l1 != <span class=\"literal\">NULL</span>&amp;&amp;l2 != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t &#123;</span><br><span class=\"line\">\t\t\t </span><br><span class=\"line\">\t\t\t\t sum-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);<span class=\"comment\">//这里有个问题变为sum=NULL就行</span></span><br><span class=\"line\">\t\t\t\t sum = sum-&gt;next;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// signal = 0;</span></span><br><span class=\"line\">\t\t\t sum_single = l1-&gt;val + l2-&gt;val + en;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">if</span> (sum_single&lt;<span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t sum-&gt;val = sum_single;</span><br><span class=\"line\">\t\t\t\t en = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum_single &gt;= <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t sum-&gt;val = sum_single - <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t\t en = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t l1 = l1-&gt;next;</span><br><span class=\"line\">\t\t\t l2 = l2-&gt;next;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">while</span> (l1 != <span class=\"literal\">NULL</span>&amp;&amp;l2 == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t &#123; </span><br><span class=\"line\">\t\t\t sum-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t sum = sum-&gt;next;</span><br><span class=\"line\">\t\t\t sum_single = en + l1-&gt;val;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">if</span> (sum_single &gt;= <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t sum-&gt;val = sum_single - <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t\t en = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t sum-&gt;val = sum_single;</span><br><span class=\"line\">\t\t\t\t en = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t l1 = l1-&gt;next;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">while</span> (l2 != <span class=\"literal\">NULL</span>&amp;&amp;l1 == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t &#123; </span><br><span class=\"line\">\t\t\t sum-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t sum = sum-&gt;next;</span><br><span class=\"line\">\t\t\t sum_single = en + l2-&gt;val;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">if</span> (sum_single &gt;= <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t sum-&gt;val = sum_single - <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t\t en = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t sum-&gt;val = sum_single;</span><br><span class=\"line\">\t\t\t\t en = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t l2 = l2-&gt;next;</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">if</span> (l1 == <span class=\"literal\">NULL</span>&amp;&amp;l2 == <span class=\"literal\">NULL</span>&amp;&amp;en == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t sum-&gt;next = <span class=\"keyword\">new</span> ListNode(en);</span><br><span class=\"line\">\t\t<span class=\"comment\">//if(l1==NULL&amp;&amp;l2==NULL&amp;&amp;en==0)sum = NULL;</span></span><br><span class=\"line\">\t<span class=\"comment\">/*\t while (l3)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t &#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t cout &lt;&lt; l3-&gt;val;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t l3 = l3-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t &#125;*/</span></span><br><span class=\"line\">\t\t <span class=\"keyword\">return</span> l4-&gt;next;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">int main()</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    Solution sou;</span></span><br><span class=\"line\"><span class=\"comment\">    ListNode *l1,*l2,*l3;</span></span><br><span class=\"line\"><span class=\"comment\">    l1=new ListNode(3);</span></span><br><span class=\"line\"><span class=\"comment\">    l1-&gt;next=new ListNode(7);</span></span><br><span class=\"line\"><span class=\"comment\">    l1-&gt;next-&gt;next=new ListNode(5);</span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"><span class=\"comment\">     l2=new ListNode(7);</span></span><br><span class=\"line\"><span class=\"comment\">    l2-&gt;next=new ListNode(7);</span></span><br><span class=\"line\"><span class=\"comment\">    l2-&gt;next-&gt;next=new ListNode(5);</span></span><br><span class=\"line\"><span class=\"comment\">    l3=sou.addTwoNumbers(l1,l2);</span></span><br><span class=\"line\"><span class=\"comment\">    cout&lt;&lt;l3-&gt;val&lt;&lt;l3-&gt;next-&gt;val&lt;&lt;l3-&gt;next-&gt;next-&gt;val;</span></span><br><span class=\"line\"><span class=\"comment\">    return 0;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></p>"},{"title":"leetcode_linklist3","date":"2018-06-07T15:33:03.000Z","_content":"### leetcode_linklist3\ncontinue..\n#### 反转链表\nGiven a linked list, rotate the list to the right by k places, where k is non-negative.\n<!--more-->\nExample 1:\n\nInput: 1->2->3->4->5->NULL, k = 2\nOutput: 4->5->1->2->3->NULL\nExplanation:\nrotate 1 steps to the right: 5->1->2->3->4->NULL\nrotate 2 steps to the right: 4->5->1->2->3->NULL\n\nExample 2:\n\nInput: 0->1->2->NULL, k = 4\nOutput: 2->0->1->NULL\nExplanation:\nrotate 1 steps to the right: 2->0->1->NULL\nrotate 2 steps to the right: 1->2->0->NULL\nrotate 3 steps to the right: 0->1->2->NULL\nrotate 4 steps to the right: 2->0->1->NULL\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n \n```c\nstruct ListNode* rotateRight(struct ListNode* head, int k) {\n    if(head==NULL)\n        return NULL;\n    if(head->next==NULL)\n        return head;\n    struct ListNode *headnode=(struct ListNode*)malloc(sizeof(struct ListNode));\n    headnode->next=head;\n    struct ListNode *sumhead=head;\n    //compute len of list\n    int sum=0;\n    while(sumhead->next!=NULL)\n    {\n        sum++;\n        sumhead=sumhead->next;\n    }\n    sum++;\n    //compare k and len,or just compute the rota num\n    int num=k%sum;\n    int i=0;\n    struct ListNode *dealheadf=head;\n    for(i=1;i<sum-num;i++)\n    {\n        dealheadf=dealheadf->next;\n    }\n    \n    sumhead->next=headnode->next;\n    headnode->next=dealheadf->next;\n    dealheadf->next=NULL;\n   \n    head=headnode->next;\n    headnode->next=NULL;\n    free(headnode);\n    return  head;\n}\n```\n\n\n\n\n\n#### 移除倒数第n个元素\nGiven a linked list, remove the n-th node from the end of list and return its head.\n\nExample:\n\nGiven linked list: 1->2->3->4->5, and n = 2.\n\nAfter removing the second node from the end, the linked list becomes 1->2->3->5.\n\nNote:\n\nGiven n will always be valid.\n\nFollow up:\n\nCould you do this in one pass?\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n \n```c\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\n     if(head==NULL)//这个几乎没道题都要注意\n         return head;\n     if(head->next==NULL&&n>=1)\n         return NULL;\n     \n     int sum=0;\n     struct ListNode *sumhead=head;\n     while(sumhead!=NULL)\n     {\n         sum++;\n         sumhead=sumhead->next;\n     }\n     int remove=sum-n;\n     struct ListNode *removenode=head;\n     while(remove>1)\n     {\n         removenode=removenode->next;\n         remove--;\n     }\n     struct ListNode *rmnode;\n    if(remove==1)\n    {\n     struct ListNode *rmnode;\n     rmnode=removenode->next;\n     removenode->next=removenode->next->next;\n     rmnode->next=NULL;\n     free(rmnode);\n    }\n    else//删除头\n    {\n        rmnode=removenode;\n        head=head->next;\n        rmnode->next=NULL;\n        free(rmnode);\n        \n    }\n     return head;\n    \n}\n```\n//一开始未考虑到删除头的情况，所以加了else 部分\n\n#### 交换元素\nGiven a linked list, swap every two adjacent nodes and return its head.\n\nExample:\n\nGiven 1->2->3->4, you should return the list as 2->1->4->3.\n\nNote:\n\n    Your algorithm should use only constant extra space.\n    You may not modify the values in the list's nodes, only nodes itself may be changed.\n\n\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n \n```c\nstruct ListNode* swapPairs(struct ListNode* head) {\n    if(head==NULL)\n        return head;\n    if(head->next==NULL)\n        return head;\n    struct ListNode *headNode=(struct ListNode*)malloc(sizeof(struct ListNode));\n    struct ListNode *second=head->next;\n    struct ListNode *first=head;\n    struct ListNode *curhead=headNode;\n    while(1)\n    {\n        if(first==NULL)break;\n        second=first->next;\n        if(second!=NULL)\n       {\n          first->next=second->next==NULL?NULL:second->next;\n          second->next=first;\n          curhead->next=second;\n          curhead=first;\n          first=first->next==NULL?NULL:first->next;\n        }\n        else break;\n    }\n    head=headNode->next;\n    headNode->next=NULL;\n    free(headNode);\n    return head;\n     \n}\n```\n\n#### k组反转\n\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n\nExample:\n\nGiven this linked list: 1->2->3->4->5\n\nFor k = 2, you should return: 2->1->4->3->5\n\nFor k = 3, you should return: 3->2->1->4->5\n\nNote:\n\n    Only constant extra memory is allowed.\n    You may not alter the values in the list's nodes, only nodes itself may be changed.\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n/*\n这道题目原想在遍历一次就解决，可是还是想不出好的方法，得遍历两次，一次计算长度，一次正真的处理；\n在处理的过程使用头插法。注意边界条件，但因为有数量控制好些*/\n```c\nstruct ListNode* reverseKGroup(struct ListNode* head, int k) {\n    if(head==NULL)\n        return head;\n    struct ListNode* headnode=(struct ListNode*)malloc(sizeof(struct ListNode));\n    headnode->next=head;\n    int len=0;\n    struct ListNode  *lenhead=head,*curhead=headnode,*cur=head,*tmp=NULL;\n    while(lenhead!=NULL)//计算长度\n    {\n        len++;\n        lenhead=lenhead->next;\n    }\n    int numofreverse=len/k;//要reverse几次\n    int i=0;\n    int j=0;\n    for(i=1;i<=numofreverse;i++)\n    {\n        j=k;\n        while(j>1)//每一次reverse k次，头插法\n        {\n            tmp=curhead->next;\n            curhead->next=cur->next;\n            cur->next=cur->next->next;\n            curhead->next->next=tmp;\n            j--;\n        }\n        curhead=cur;\n        cur=cur->next;\n    }\n    head=headnode->next;\n    headnode->next=NULL;\n    free(headnode);\n    return head;   \n}\n```\n#### 总结\n后面还有几道题，不贴了，这里简述下：  \n+ 检查是否链表中存在循环\n+ 检查链表中是否存在循环并找到循环的起点\n+ 深度复制链表，链表中的每个节点存在一个指向任意节点的指针\n+ 设计一个LRU cache,即（最近使用的）\n+ 。。。。。\n\n+ 链表的套路：\n  + 常使用头插法进行反转操作\n  + 使用两个指针解决循环问题，指针相遇测试是否存在循环，指针遍历减少时间\n  + 使用哈希，以空间换时间\n  + 加头节点，简化逻辑\n+ 使用链表注意\n  + 检查空和是否只有一个节点\n  + 释放空间，和放置取空指针，可以通过次数控制和判空","source":"_posts/leetcode-linklist3.md","raw":"---\ntitle: leetcode_linklist3\ndate: 2018-06-07 23:33:03\ntags: leetcode_linklist\ncategories: leetcode\n---\n### leetcode_linklist3\ncontinue..\n#### 反转链表\nGiven a linked list, rotate the list to the right by k places, where k is non-negative.\n<!--more-->\nExample 1:\n\nInput: 1->2->3->4->5->NULL, k = 2\nOutput: 4->5->1->2->3->NULL\nExplanation:\nrotate 1 steps to the right: 5->1->2->3->4->NULL\nrotate 2 steps to the right: 4->5->1->2->3->NULL\n\nExample 2:\n\nInput: 0->1->2->NULL, k = 4\nOutput: 2->0->1->NULL\nExplanation:\nrotate 1 steps to the right: 2->0->1->NULL\nrotate 2 steps to the right: 1->2->0->NULL\nrotate 3 steps to the right: 0->1->2->NULL\nrotate 4 steps to the right: 2->0->1->NULL\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n \n```c\nstruct ListNode* rotateRight(struct ListNode* head, int k) {\n    if(head==NULL)\n        return NULL;\n    if(head->next==NULL)\n        return head;\n    struct ListNode *headnode=(struct ListNode*)malloc(sizeof(struct ListNode));\n    headnode->next=head;\n    struct ListNode *sumhead=head;\n    //compute len of list\n    int sum=0;\n    while(sumhead->next!=NULL)\n    {\n        sum++;\n        sumhead=sumhead->next;\n    }\n    sum++;\n    //compare k and len,or just compute the rota num\n    int num=k%sum;\n    int i=0;\n    struct ListNode *dealheadf=head;\n    for(i=1;i<sum-num;i++)\n    {\n        dealheadf=dealheadf->next;\n    }\n    \n    sumhead->next=headnode->next;\n    headnode->next=dealheadf->next;\n    dealheadf->next=NULL;\n   \n    head=headnode->next;\n    headnode->next=NULL;\n    free(headnode);\n    return  head;\n}\n```\n\n\n\n\n\n#### 移除倒数第n个元素\nGiven a linked list, remove the n-th node from the end of list and return its head.\n\nExample:\n\nGiven linked list: 1->2->3->4->5, and n = 2.\n\nAfter removing the second node from the end, the linked list becomes 1->2->3->5.\n\nNote:\n\nGiven n will always be valid.\n\nFollow up:\n\nCould you do this in one pass?\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n \n```c\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\n     if(head==NULL)//这个几乎没道题都要注意\n         return head;\n     if(head->next==NULL&&n>=1)\n         return NULL;\n     \n     int sum=0;\n     struct ListNode *sumhead=head;\n     while(sumhead!=NULL)\n     {\n         sum++;\n         sumhead=sumhead->next;\n     }\n     int remove=sum-n;\n     struct ListNode *removenode=head;\n     while(remove>1)\n     {\n         removenode=removenode->next;\n         remove--;\n     }\n     struct ListNode *rmnode;\n    if(remove==1)\n    {\n     struct ListNode *rmnode;\n     rmnode=removenode->next;\n     removenode->next=removenode->next->next;\n     rmnode->next=NULL;\n     free(rmnode);\n    }\n    else//删除头\n    {\n        rmnode=removenode;\n        head=head->next;\n        rmnode->next=NULL;\n        free(rmnode);\n        \n    }\n     return head;\n    \n}\n```\n//一开始未考虑到删除头的情况，所以加了else 部分\n\n#### 交换元素\nGiven a linked list, swap every two adjacent nodes and return its head.\n\nExample:\n\nGiven 1->2->3->4, you should return the list as 2->1->4->3.\n\nNote:\n\n    Your algorithm should use only constant extra space.\n    You may not modify the values in the list's nodes, only nodes itself may be changed.\n\n\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n \n```c\nstruct ListNode* swapPairs(struct ListNode* head) {\n    if(head==NULL)\n        return head;\n    if(head->next==NULL)\n        return head;\n    struct ListNode *headNode=(struct ListNode*)malloc(sizeof(struct ListNode));\n    struct ListNode *second=head->next;\n    struct ListNode *first=head;\n    struct ListNode *curhead=headNode;\n    while(1)\n    {\n        if(first==NULL)break;\n        second=first->next;\n        if(second!=NULL)\n       {\n          first->next=second->next==NULL?NULL:second->next;\n          second->next=first;\n          curhead->next=second;\n          curhead=first;\n          first=first->next==NULL?NULL:first->next;\n        }\n        else break;\n    }\n    head=headNode->next;\n    headNode->next=NULL;\n    free(headNode);\n    return head;\n     \n}\n```\n\n#### k组反转\n\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n\nExample:\n\nGiven this linked list: 1->2->3->4->5\n\nFor k = 2, you should return: 2->1->4->3->5\n\nFor k = 3, you should return: 3->2->1->4->5\n\nNote:\n\n    Only constant extra memory is allowed.\n    You may not alter the values in the list's nodes, only nodes itself may be changed.\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n/*\n这道题目原想在遍历一次就解决，可是还是想不出好的方法，得遍历两次，一次计算长度，一次正真的处理；\n在处理的过程使用头插法。注意边界条件，但因为有数量控制好些*/\n```c\nstruct ListNode* reverseKGroup(struct ListNode* head, int k) {\n    if(head==NULL)\n        return head;\n    struct ListNode* headnode=(struct ListNode*)malloc(sizeof(struct ListNode));\n    headnode->next=head;\n    int len=0;\n    struct ListNode  *lenhead=head,*curhead=headnode,*cur=head,*tmp=NULL;\n    while(lenhead!=NULL)//计算长度\n    {\n        len++;\n        lenhead=lenhead->next;\n    }\n    int numofreverse=len/k;//要reverse几次\n    int i=0;\n    int j=0;\n    for(i=1;i<=numofreverse;i++)\n    {\n        j=k;\n        while(j>1)//每一次reverse k次，头插法\n        {\n            tmp=curhead->next;\n            curhead->next=cur->next;\n            cur->next=cur->next->next;\n            curhead->next->next=tmp;\n            j--;\n        }\n        curhead=cur;\n        cur=cur->next;\n    }\n    head=headnode->next;\n    headnode->next=NULL;\n    free(headnode);\n    return head;   \n}\n```\n#### 总结\n后面还有几道题，不贴了，这里简述下：  \n+ 检查是否链表中存在循环\n+ 检查链表中是否存在循环并找到循环的起点\n+ 深度复制链表，链表中的每个节点存在一个指向任意节点的指针\n+ 设计一个LRU cache,即（最近使用的）\n+ 。。。。。\n\n+ 链表的套路：\n  + 常使用头插法进行反转操作\n  + 使用两个指针解决循环问题，指针相遇测试是否存在循环，指针遍历减少时间\n  + 使用哈希，以空间换时间\n  + 加头节点，简化逻辑\n+ 使用链表注意\n  + 检查空和是否只有一个节点\n  + 释放空间，和放置取空指针，可以通过次数控制和判空","slug":"leetcode-linklist3","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7oh001r2ujx7zcz6k1p","content":"<h3 id=\"leetcode-linklist3\"><a href=\"#leetcode-linklist3\" class=\"headerlink\" title=\"leetcode_linklist3\"></a>leetcode_linklist3</h3><p>continue..</p>\n<h4 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h4><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.<br><a id=\"more\"></a><br>Example 1:</p>\n<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>\n<p>Example 2:</p>\n<p>Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>Output: 2-&gt;0-&gt;1-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL<br>rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL<br>rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>/**</p>\n<ul>\n<li>Definition for singly-linked list.</li>\n<li>struct ListNode {</li>\n<li>int val;</li>\n<li>struct ListNode *next;</li>\n<li>};<br>*/</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">rotateRight</span><span class=\"params\">(struct ListNode* head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head-&gt;next==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">headnode</span>=(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>*)<span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>));</span></span><br><span class=\"line\">    headnode-&gt;next=head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">sumhead</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">//compute len of list</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(sumhead-&gt;next!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sum++;</span><br><span class=\"line\">        sumhead=sumhead-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sum++;</span><br><span class=\"line\">    <span class=\"comment\">//compare k and len,or just compute the rota num</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num=k%sum;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">dealheadf</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;sum-num;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dealheadf=dealheadf-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    sumhead-&gt;next=headnode-&gt;next;</span><br><span class=\"line\">    headnode-&gt;next=dealheadf-&gt;next;</span><br><span class=\"line\">    dealheadf-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">    head=headnode-&gt;next;</span><br><span class=\"line\">    headnode-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(headnode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"移除倒数第n个元素\"><a href=\"#移除倒数第n个元素\" class=\"headerlink\" title=\"移除倒数第n个元素\"></a>移除倒数第n个元素</h4><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>\n<p>Example:</p>\n<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>\n<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p>\n<p>Note:</p>\n<p>Given n will always be valid.</p>\n<p>Follow up:</p>\n<p>Could you do this in one pass?</p>\n<p>/**</p>\n<ul>\n<li>Definition for singly-linked list.</li>\n<li>struct ListNode {</li>\n<li>int val;</li>\n<li>struct ListNode *next;</li>\n<li>};<br>*/</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(struct ListNode* head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)<span class=\"comment\">//这个几乎没道题都要注意</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(head-&gt;next==<span class=\"literal\">NULL</span>&amp;&amp;n&gt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">sumhead</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">     <span class=\"keyword\">while</span>(sumhead!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         sum++;</span><br><span class=\"line\">         sumhead=sumhead-&gt;next;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> remove=sum-n;</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">removenode</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">     <span class=\"keyword\">while</span>(remove&gt;<span class=\"number\">1</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         removenode=removenode-&gt;next;</span><br><span class=\"line\">         remove--;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">rmnode</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(remove==<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">rmnode</span>;</span></span><br><span class=\"line\">     rmnode=removenode-&gt;next;</span><br><span class=\"line\">     removenode-&gt;next=removenode-&gt;next-&gt;next;</span><br><span class=\"line\">     rmnode-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">     <span class=\"built_in\">free</span>(rmnode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span><span class=\"comment\">//删除头</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rmnode=removenode;</span><br><span class=\"line\">        head=head-&gt;next;</span><br><span class=\"line\">        rmnode-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(rmnode);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>//一开始未考虑到删除头的情况，所以加了else 部分</p>\n<h4 id=\"交换元素\"><a href=\"#交换元素\" class=\"headerlink\" title=\"交换元素\"></a>交换元素</h4><p>Given a linked list, swap every two adjacent nodes and return its head.</p>\n<p>Example:</p>\n<p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>\n<p>Note:</p>\n<pre><code>Your algorithm should use only constant extra space.\nYou may not modify the values in the list&apos;s nodes, only nodes itself may be changed.\n</code></pre><p>/**</p>\n<ul>\n<li>Definition for singly-linked list.</li>\n<li>struct ListNode {</li>\n<li>int val;</li>\n<li>struct ListNode *next;</li>\n<li>};<br>*/</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">swapPairs</span><span class=\"params\">(struct ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head-&gt;next==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">headNode</span>=(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>*)<span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>));</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">second</span>=<span class=\"title\">head</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">first</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">curhead</span>=<span class=\"title\">headNode</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first==<span class=\"literal\">NULL</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        second=first-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(second!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">          first-&gt;next=second-&gt;next==<span class=\"literal\">NULL</span>?<span class=\"literal\">NULL</span>:second-&gt;next;</span><br><span class=\"line\">          second-&gt;next=first;</span><br><span class=\"line\">          curhead-&gt;next=second;</span><br><span class=\"line\">          curhead=first;</span><br><span class=\"line\">          first=first-&gt;next==<span class=\"literal\">NULL</span>?<span class=\"literal\">NULL</span>:first-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    head=headNode-&gt;next;</span><br><span class=\"line\">    headNode-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(headNode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"k组反转\"><a href=\"#k组反转\" class=\"headerlink\" title=\"k组反转\"></a>k组反转</h4><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>\n<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>\n<p>Example:</p>\n<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>\n<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>\n<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>\n<p>Note:</p>\n<pre><code>Only constant extra memory is allowed.\nYou may not alter the values in the list&apos;s nodes, only nodes itself may be changed.\n</code></pre><p>/**</p>\n<ul>\n<li>Definition for singly-linked list.</li>\n<li>struct ListNode {</li>\n<li>int val;</li>\n<li>struct ListNode *next;</li>\n<li>};<br><em>/<br>/</em><br>这道题目原想在遍历一次就解决，可是还是想不出好的方法，得遍历两次，一次计算长度，一次正真的处理；<br>在处理的过程使用头插法。注意边界条件，但因为有数量控制好些*/<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">reverseKGroup</span><span class=\"params\">(struct ListNode* head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">headnode</span>=(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>*)<span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>));</span></span><br><span class=\"line\">    headnode-&gt;next=head;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>  *<span class=\"title\">lenhead</span>=<span class=\"title\">head</span>,*<span class=\"title\">curhead</span>=<span class=\"title\">headnode</span>,*<span class=\"title\">cur</span>=<span class=\"title\">head</span>,*<span class=\"title\">tmp</span>=<span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(lenhead!=<span class=\"literal\">NULL</span>)<span class=\"comment\">//计算长度</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">        lenhead=lenhead-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numofreverse=len/k;<span class=\"comment\">//要reverse几次</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=numofreverse;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        j=k;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&gt;<span class=\"number\">1</span>)<span class=\"comment\">//每一次reverse k次，头插法</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tmp=curhead-&gt;next;</span><br><span class=\"line\">            curhead-&gt;next=cur-&gt;next;</span><br><span class=\"line\">            cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class=\"line\">            curhead-&gt;next-&gt;next=tmp;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        curhead=cur;</span><br><span class=\"line\">        cur=cur-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    head=headnode-&gt;next;</span><br><span class=\"line\">    headnode-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(headnode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>后面还有几道题，不贴了，这里简述下：  </p>\n<ul>\n<li>检查是否链表中存在循环</li>\n<li>检查链表中是否存在循环并找到循环的起点</li>\n<li>深度复制链表，链表中的每个节点存在一个指向任意节点的指针</li>\n<li>设计一个LRU cache,即（最近使用的）</li>\n<li><p>。。。。。</p>\n</li>\n<li><p>链表的套路：</p>\n<ul>\n<li>常使用头插法进行反转操作</li>\n<li>使用两个指针解决循环问题，指针相遇测试是否存在循环，指针遍历减少时间</li>\n<li>使用哈希，以空间换时间</li>\n<li>加头节点，简化逻辑</li>\n</ul>\n</li>\n<li>使用链表注意<ul>\n<li>检查空和是否只有一个节点</li>\n<li>释放空间，和放置取空指针，可以通过次数控制和判空</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"leetcode-linklist3\"><a href=\"#leetcode-linklist3\" class=\"headerlink\" title=\"leetcode_linklist3\"></a>leetcode_linklist3</h3><p>continue..</p>\n<h4 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h4><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.<br>","more":"<br>Example 1:</p>\n<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>\n<p>Example 2:</p>\n<p>Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>Output: 2-&gt;0-&gt;1-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL<br>rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL<br>rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>/**</p>\n<ul>\n<li>Definition for singly-linked list.</li>\n<li>struct ListNode {</li>\n<li>int val;</li>\n<li>struct ListNode *next;</li>\n<li>};<br>*/</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">rotateRight</span><span class=\"params\">(struct ListNode* head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head-&gt;next==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">headnode</span>=(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>*)<span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>));</span></span><br><span class=\"line\">    headnode-&gt;next=head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">sumhead</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">//compute len of list</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(sumhead-&gt;next!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sum++;</span><br><span class=\"line\">        sumhead=sumhead-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sum++;</span><br><span class=\"line\">    <span class=\"comment\">//compare k and len,or just compute the rota num</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num=k%sum;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">dealheadf</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;sum-num;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dealheadf=dealheadf-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    sumhead-&gt;next=headnode-&gt;next;</span><br><span class=\"line\">    headnode-&gt;next=dealheadf-&gt;next;</span><br><span class=\"line\">    dealheadf-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">    head=headnode-&gt;next;</span><br><span class=\"line\">    headnode-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(headnode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"移除倒数第n个元素\"><a href=\"#移除倒数第n个元素\" class=\"headerlink\" title=\"移除倒数第n个元素\"></a>移除倒数第n个元素</h4><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>\n<p>Example:</p>\n<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>\n<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p>\n<p>Note:</p>\n<p>Given n will always be valid.</p>\n<p>Follow up:</p>\n<p>Could you do this in one pass?</p>\n<p>/**</p>\n<ul>\n<li>Definition for singly-linked list.</li>\n<li>struct ListNode {</li>\n<li>int val;</li>\n<li>struct ListNode *next;</li>\n<li>};<br>*/</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(struct ListNode* head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)<span class=\"comment\">//这个几乎没道题都要注意</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(head-&gt;next==<span class=\"literal\">NULL</span>&amp;&amp;n&gt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">sumhead</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">     <span class=\"keyword\">while</span>(sumhead!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         sum++;</span><br><span class=\"line\">         sumhead=sumhead-&gt;next;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> remove=sum-n;</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">removenode</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">     <span class=\"keyword\">while</span>(remove&gt;<span class=\"number\">1</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         removenode=removenode-&gt;next;</span><br><span class=\"line\">         remove--;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">rmnode</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(remove==<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">rmnode</span>;</span></span><br><span class=\"line\">     rmnode=removenode-&gt;next;</span><br><span class=\"line\">     removenode-&gt;next=removenode-&gt;next-&gt;next;</span><br><span class=\"line\">     rmnode-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">     <span class=\"built_in\">free</span>(rmnode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span><span class=\"comment\">//删除头</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rmnode=removenode;</span><br><span class=\"line\">        head=head-&gt;next;</span><br><span class=\"line\">        rmnode-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(rmnode);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>//一开始未考虑到删除头的情况，所以加了else 部分</p>\n<h4 id=\"交换元素\"><a href=\"#交换元素\" class=\"headerlink\" title=\"交换元素\"></a>交换元素</h4><p>Given a linked list, swap every two adjacent nodes and return its head.</p>\n<p>Example:</p>\n<p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>\n<p>Note:</p>\n<pre><code>Your algorithm should use only constant extra space.\nYou may not modify the values in the list&apos;s nodes, only nodes itself may be changed.\n</code></pre><p>/**</p>\n<ul>\n<li>Definition for singly-linked list.</li>\n<li>struct ListNode {</li>\n<li>int val;</li>\n<li>struct ListNode *next;</li>\n<li>};<br>*/</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">swapPairs</span><span class=\"params\">(struct ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head-&gt;next==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">headNode</span>=(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>*)<span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>));</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">second</span>=<span class=\"title\">head</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">first</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">curhead</span>=<span class=\"title\">headNode</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first==<span class=\"literal\">NULL</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        second=first-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(second!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">          first-&gt;next=second-&gt;next==<span class=\"literal\">NULL</span>?<span class=\"literal\">NULL</span>:second-&gt;next;</span><br><span class=\"line\">          second-&gt;next=first;</span><br><span class=\"line\">          curhead-&gt;next=second;</span><br><span class=\"line\">          curhead=first;</span><br><span class=\"line\">          first=first-&gt;next==<span class=\"literal\">NULL</span>?<span class=\"literal\">NULL</span>:first-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    head=headNode-&gt;next;</span><br><span class=\"line\">    headNode-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(headNode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"k组反转\"><a href=\"#k组反转\" class=\"headerlink\" title=\"k组反转\"></a>k组反转</h4><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>\n<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>\n<p>Example:</p>\n<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>\n<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>\n<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>\n<p>Note:</p>\n<pre><code>Only constant extra memory is allowed.\nYou may not alter the values in the list&apos;s nodes, only nodes itself may be changed.\n</code></pre><p>/**</p>\n<ul>\n<li>Definition for singly-linked list.</li>\n<li>struct ListNode {</li>\n<li>int val;</li>\n<li>struct ListNode *next;</li>\n<li>};<br><em>/<br>/</em><br>这道题目原想在遍历一次就解决，可是还是想不出好的方法，得遍历两次，一次计算长度，一次正真的处理；<br>在处理的过程使用头插法。注意边界条件，但因为有数量控制好些*/<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">reverseKGroup</span><span class=\"params\">(struct ListNode* head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">headnode</span>=(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>*)<span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>));</span></span><br><span class=\"line\">    headnode-&gt;next=head;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>  *<span class=\"title\">lenhead</span>=<span class=\"title\">head</span>,*<span class=\"title\">curhead</span>=<span class=\"title\">headnode</span>,*<span class=\"title\">cur</span>=<span class=\"title\">head</span>,*<span class=\"title\">tmp</span>=<span class=\"title\">NULL</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(lenhead!=<span class=\"literal\">NULL</span>)<span class=\"comment\">//计算长度</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">        lenhead=lenhead-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numofreverse=len/k;<span class=\"comment\">//要reverse几次</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=numofreverse;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        j=k;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&gt;<span class=\"number\">1</span>)<span class=\"comment\">//每一次reverse k次，头插法</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tmp=curhead-&gt;next;</span><br><span class=\"line\">            curhead-&gt;next=cur-&gt;next;</span><br><span class=\"line\">            cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class=\"line\">            curhead-&gt;next-&gt;next=tmp;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        curhead=cur;</span><br><span class=\"line\">        cur=cur-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    head=headnode-&gt;next;</span><br><span class=\"line\">    headnode-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(headnode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>后面还有几道题，不贴了，这里简述下：  </p>\n<ul>\n<li>检查是否链表中存在循环</li>\n<li>检查链表中是否存在循环并找到循环的起点</li>\n<li>深度复制链表，链表中的每个节点存在一个指向任意节点的指针</li>\n<li>设计一个LRU cache,即（最近使用的）</li>\n<li><p>。。。。。</p>\n</li>\n<li><p>链表的套路：</p>\n<ul>\n<li>常使用头插法进行反转操作</li>\n<li>使用两个指针解决循环问题，指针相遇测试是否存在循环，指针遍历减少时间</li>\n<li>使用哈希，以空间换时间</li>\n<li>加头节点，简化逻辑</li>\n</ul>\n</li>\n<li>使用链表注意<ul>\n<li>检查空和是否只有一个节点</li>\n<li>释放空间，和放置取空指针，可以通过次数控制和判空</li>\n</ul>\n</li>\n</ul>"},{"title":"leetcode_string","date":"2018-06-24T09:48:05.000Z","_content":"### leetcode_string\n#### 传统字符串匹配：\n+ 简单写写,变量命名等就先不纠结了\n\n```cpp\nint strStr(char s[],char p[])\n{\n\t\tif(s[0]=='\\0'||p[0]=='\\0')\n\t\t\t\tcout<<\"p or s is null\"<<endl;\n\t\tint k=0,j=0,i=0;\n\t\tfor(i=0,j=0;s[i]!='\\0'&&s[k]!='\\0';)\n\t\t{\n\t\t     if(p[j]=='\\0')\n\t\t\t\t   break;\t \n\t\t\t if(s[k]==p[j])\n\t\t\t {\n\t\t\t\t\t k++;\n\t\t\t\t\t j++;\n\t\t\t }\n\t\t\t else //不匹配时重新来过\n\t\t\t {\n\t\t\t\t\t i++;\n\t\t\t\t\t k=i;\n\t\t\t\t\t j=0;\n\t\t\t }\n\t\t}\n        if(p[j]=='\\0')\n\t\t\t\treturn i;\n        else \n\t\t\t\treturn -1;\n}```\n#### kmp匹配算法\nkmp算法：基本过程见另一篇文章数据结构之字符串<!--more-->，这里贴写代码(未经大数据检验，谨慎观看)\n```cpp\nint nextfunc(char p[],int next[])\n{\n   next[0]=-1;\n   next[1]=0;\n   int j=1;\n   int k=0;\n   while(p[j]!='\\0')\n   {\n\t\t   if(k==0||p[j]==p[k])\n\t\t   {\n\t\t\t\t   ++j;\n\t\t\t\t   ++k;\n\t\t\t\t   next[j]=k;\n\t\t   }\n\t\t   else\n\t\t\t\t   k=next[k];\n   }\n   return 0;\n}\n\nint kmp(char s[],char p[])\n{\n   int i=0;\n   int j=0;\n   int next[100];\n   nextfunc(p,next);\n   for (i=0;s[i]!='\\0'&&p[j]!='\\0';i++)\n   {\n\t\t   //if(j==-1)j=0;\n\t\t   if(s[i]==p[j])\n\t\t   {\n\t\t     j++;\n\t\t\t continue;\n\t\t   }\n\t\t   while(s[i]!=p[j]&&j>=0)j=next[j];\n\t\t   j++;\n   }\n  if(p[j]=='\\0')\n\t\t return i-j;\n  else \n\t\t return -1;\n} \n```\n简单测试\n```cpp\nint main ()\n{\n\t\tchar a[19]={'a','b','c','a','b','c','a','s','s','f','r','e','r'};\n\t\tchar b[10]={'a','b','c','a','s'};\n\t\tint pos=strStr(a,b);\n\t\tcout<<pos<<endl;\n\t\tint pos2=kmp(a,b);\n\t\tcout<<pos2<<endl;\n\t\treturn 0;\n}\n```\n#### 其他字符串算法题目：\n##### 判读字符串是否为回文串\n+ 所谓回文串即正者读反着读都一样：\n+ 解决方案：\n  +  1.设置两个索引，一个从字符串开始位置往后走，一个从字符串最后的位置往前走，比较这两个索引指向的字符是否相等，直到遍历完整个字符串；注意这里其实并不需要遍历整个字符串，一个索引只需要走一半就可以，回文串两边对称的。\n  +  2.利用栈，思路类似\n\n##### 字符串转整数(atoi)\n+ 分析：这个题目需要注意的是各种不规则的输入和其他边缘条件如int整数的范围等\n+ 解决方案:\n  + 若是严格的检查，则判断字符ASCII码是否在0-9之间，注意整数的首位不能为0）；整数的正负；数据是否溢出；是否数据的表现形式如33x8fe；等等。\n  + 非严格的检查，如遇到非法的字符跳过即可；首位为0时跳过或者当成八进制等等\n\n##### 对两个二进制字符串求和\n+ 如\"111\"+\"101\"=\"1100\"\n+ 解决方案：\n  + 1. 像十进制那样直接求和，进位，从最右边的字符开始，若相加大于1则进位，注意两个字符串可能一个很长一个很短，而进位可能一直需要延续\n  + 2.将两个字符串分别转换为十进制再做运算，结果再转为二进制\n\n##### 最长回文子串\n+ 暴力方法：将所有子串列出来先判断哪些是回文串，再取长度最长的；\n##### 正则表达式\n+ 我对正则表达式的处理方案一直很倾向于用状态机，这种方法可以用图表示出来，方案的完备性好判断，别人也好理解；\n+ 递归方案\n##### 最长公共前缀\n+ 找出字符串数组中的最长公共前缀：给定一个字符串数组，找出他们的最长公共前缀\n+ 分析：这道题目需求不明确，是需要 所有的字符串=都有的公共前缀还是若只有部分字符串有公共前缀也可以？也可能我理解有误~\n\n##### 实现strtod()函数\n+ 即判断一个字符串是否表示一个数字如:\"1.0\"\n+ 分析：可以用状态机实现\n\n##### 整数和罗马数字的相互转换\n+ 这道题有些无聊\n##### count and say\n+ 一个数列如下：\n1 11 21 1211 111221,...\n意思是1,第二个表示第一个的情况，即1个1故为11,第三个数表示第二个数的情况，即两个1,21，以此类推  \n+ 求数列中的第n个数\n+ 解决方案，直接模拟，一个一个算出来\n\n##### Anagrams:\n+ 字符串中的打乱字母顺序从而得到新的单词如eat打乱后得到tea等\n\n##### 给定绝对路径简化它\n\n##### 在一个英文句子中找到最后一个单词的长度\n","source":"_posts/leetcode-string.md","raw":"---\ntitle: leetcode_string\ndate: 2018-06-24 17:48:05\ntags: leetcode_string\ncategories: leetcode\n---\n### leetcode_string\n#### 传统字符串匹配：\n+ 简单写写,变量命名等就先不纠结了\n\n```cpp\nint strStr(char s[],char p[])\n{\n\t\tif(s[0]=='\\0'||p[0]=='\\0')\n\t\t\t\tcout<<\"p or s is null\"<<endl;\n\t\tint k=0,j=0,i=0;\n\t\tfor(i=0,j=0;s[i]!='\\0'&&s[k]!='\\0';)\n\t\t{\n\t\t     if(p[j]=='\\0')\n\t\t\t\t   break;\t \n\t\t\t if(s[k]==p[j])\n\t\t\t {\n\t\t\t\t\t k++;\n\t\t\t\t\t j++;\n\t\t\t }\n\t\t\t else //不匹配时重新来过\n\t\t\t {\n\t\t\t\t\t i++;\n\t\t\t\t\t k=i;\n\t\t\t\t\t j=0;\n\t\t\t }\n\t\t}\n        if(p[j]=='\\0')\n\t\t\t\treturn i;\n        else \n\t\t\t\treturn -1;\n}```\n#### kmp匹配算法\nkmp算法：基本过程见另一篇文章数据结构之字符串<!--more-->，这里贴写代码(未经大数据检验，谨慎观看)\n```cpp\nint nextfunc(char p[],int next[])\n{\n   next[0]=-1;\n   next[1]=0;\n   int j=1;\n   int k=0;\n   while(p[j]!='\\0')\n   {\n\t\t   if(k==0||p[j]==p[k])\n\t\t   {\n\t\t\t\t   ++j;\n\t\t\t\t   ++k;\n\t\t\t\t   next[j]=k;\n\t\t   }\n\t\t   else\n\t\t\t\t   k=next[k];\n   }\n   return 0;\n}\n\nint kmp(char s[],char p[])\n{\n   int i=0;\n   int j=0;\n   int next[100];\n   nextfunc(p,next);\n   for (i=0;s[i]!='\\0'&&p[j]!='\\0';i++)\n   {\n\t\t   //if(j==-1)j=0;\n\t\t   if(s[i]==p[j])\n\t\t   {\n\t\t     j++;\n\t\t\t continue;\n\t\t   }\n\t\t   while(s[i]!=p[j]&&j>=0)j=next[j];\n\t\t   j++;\n   }\n  if(p[j]=='\\0')\n\t\t return i-j;\n  else \n\t\t return -1;\n} \n```\n简单测试\n```cpp\nint main ()\n{\n\t\tchar a[19]={'a','b','c','a','b','c','a','s','s','f','r','e','r'};\n\t\tchar b[10]={'a','b','c','a','s'};\n\t\tint pos=strStr(a,b);\n\t\tcout<<pos<<endl;\n\t\tint pos2=kmp(a,b);\n\t\tcout<<pos2<<endl;\n\t\treturn 0;\n}\n```\n#### 其他字符串算法题目：\n##### 判读字符串是否为回文串\n+ 所谓回文串即正者读反着读都一样：\n+ 解决方案：\n  +  1.设置两个索引，一个从字符串开始位置往后走，一个从字符串最后的位置往前走，比较这两个索引指向的字符是否相等，直到遍历完整个字符串；注意这里其实并不需要遍历整个字符串，一个索引只需要走一半就可以，回文串两边对称的。\n  +  2.利用栈，思路类似\n\n##### 字符串转整数(atoi)\n+ 分析：这个题目需要注意的是各种不规则的输入和其他边缘条件如int整数的范围等\n+ 解决方案:\n  + 若是严格的检查，则判断字符ASCII码是否在0-9之间，注意整数的首位不能为0）；整数的正负；数据是否溢出；是否数据的表现形式如33x8fe；等等。\n  + 非严格的检查，如遇到非法的字符跳过即可；首位为0时跳过或者当成八进制等等\n\n##### 对两个二进制字符串求和\n+ 如\"111\"+\"101\"=\"1100\"\n+ 解决方案：\n  + 1. 像十进制那样直接求和，进位，从最右边的字符开始，若相加大于1则进位，注意两个字符串可能一个很长一个很短，而进位可能一直需要延续\n  + 2.将两个字符串分别转换为十进制再做运算，结果再转为二进制\n\n##### 最长回文子串\n+ 暴力方法：将所有子串列出来先判断哪些是回文串，再取长度最长的；\n##### 正则表达式\n+ 我对正则表达式的处理方案一直很倾向于用状态机，这种方法可以用图表示出来，方案的完备性好判断，别人也好理解；\n+ 递归方案\n##### 最长公共前缀\n+ 找出字符串数组中的最长公共前缀：给定一个字符串数组，找出他们的最长公共前缀\n+ 分析：这道题目需求不明确，是需要 所有的字符串=都有的公共前缀还是若只有部分字符串有公共前缀也可以？也可能我理解有误~\n\n##### 实现strtod()函数\n+ 即判断一个字符串是否表示一个数字如:\"1.0\"\n+ 分析：可以用状态机实现\n\n##### 整数和罗马数字的相互转换\n+ 这道题有些无聊\n##### count and say\n+ 一个数列如下：\n1 11 21 1211 111221,...\n意思是1,第二个表示第一个的情况，即1个1故为11,第三个数表示第二个数的情况，即两个1,21，以此类推  \n+ 求数列中的第n个数\n+ 解决方案，直接模拟，一个一个算出来\n\n##### Anagrams:\n+ 字符串中的打乱字母顺序从而得到新的单词如eat打乱后得到tea等\n\n##### 给定绝对路径简化它\n\n##### 在一个英文句子中找到最后一个单词的长度\n","slug":"leetcode-string","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7ok001u2ujxv8zgm75a","content":"<h3 id=\"leetcode-string\"><a href=\"#leetcode-string\" class=\"headerlink\" title=\"leetcode_string\"></a>leetcode_string</h3><h4 id=\"传统字符串匹配：\"><a href=\"#传统字符串匹配：\" class=\"headerlink\" title=\"传统字符串匹配：\"></a>传统字符串匹配：</h4><ul>\n<li>简单写写,变量命名等就先不纠结了</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(<span class=\"keyword\">char</span> s[],<span class=\"keyword\">char</span> p[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>]==<span class=\"string\">'\\0'</span>||p[<span class=\"number\">0</span>]==<span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p or s is null\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>,i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>;s[i]!=<span class=\"string\">'\\0'</span>&amp;&amp;s[k]!=<span class=\"string\">'\\0'</span>;)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t     <span class=\"keyword\">if</span>(p[j]==<span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">\t\t\t\t   <span class=\"keyword\">break</span>;\t </span><br><span class=\"line\">\t\t\t <span class=\"keyword\">if</span>(s[k]==p[j])</span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t\t k++;</span><br><span class=\"line\">\t\t\t\t\t j++;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">else</span> <span class=\"comment\">//不匹配时重新来过</span></span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t\t i++;</span><br><span class=\"line\">\t\t\t\t\t k=i;</span><br><span class=\"line\">\t\t\t\t\t j=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p[j]==<span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"kmp匹配算法\"><a href=\"#kmp匹配算法\" class=\"headerlink\" title=\"kmp匹配算法\"></a>kmp匹配算法</h4><p>kmp算法：基本过程见另一篇文章数据结构之字符串<a id=\"more\"></a>，这里贴写代码(未经大数据检验，谨慎观看)<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">nextfunc</span><span class=\"params\">(<span class=\"keyword\">char</span> p[],<span class=\"keyword\">int</span> next[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   next[<span class=\"number\">0</span>]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">   next[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">while</span>(p[j]!=<span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">\t\t   <span class=\"keyword\">if</span>(k==<span class=\"number\">0</span>||p[j]==p[k])</span><br><span class=\"line\">\t\t   &#123;</span><br><span class=\"line\">\t\t\t\t   ++j;</span><br><span class=\"line\">\t\t\t\t   ++k;</span><br><span class=\"line\">\t\t\t\t   next[j]=k;</span><br><span class=\"line\">\t\t   &#125;</span><br><span class=\"line\">\t\t   <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t   k=next[k];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kmp</span><span class=\"params\">(<span class=\"keyword\">char</span> s[],<span class=\"keyword\">char</span> p[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> next[<span class=\"number\">100</span>];</span><br><span class=\"line\">   nextfunc(p,next);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>;s[i]!=<span class=\"string\">'\\0'</span>&amp;&amp;p[j]!=<span class=\"string\">'\\0'</span>;i++)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">\t\t   <span class=\"comment\">//if(j==-1)j=0;</span></span><br><span class=\"line\">\t\t   <span class=\"keyword\">if</span>(s[i]==p[j])</span><br><span class=\"line\">\t\t   &#123;</span><br><span class=\"line\">\t\t     j++;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t   &#125;</span><br><span class=\"line\">\t\t   <span class=\"keyword\">while</span>(s[i]!=p[j]&amp;&amp;j&gt;=<span class=\"number\">0</span>)j=next[j];</span><br><span class=\"line\">\t\t   j++;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p[j]==<span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">\t\t <span class=\"keyword\">return</span> i-j;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>简单测试<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> a[<span class=\"number\">19</span>]=&#123;<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'a'</span>,<span class=\"string\">'s'</span>,<span class=\"string\">'s'</span>,<span class=\"string\">'f'</span>,<span class=\"string\">'r'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'r'</span>&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> b[<span class=\"number\">10</span>]=&#123;<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'a'</span>,<span class=\"string\">'s'</span>&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> pos=strStr(a,b);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;pos&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> pos2=kmp(a,b);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;pos2&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"其他字符串算法题目：\"><a href=\"#其他字符串算法题目：\" class=\"headerlink\" title=\"其他字符串算法题目：\"></a>其他字符串算法题目：</h4><h5 id=\"判读字符串是否为回文串\"><a href=\"#判读字符串是否为回文串\" class=\"headerlink\" title=\"判读字符串是否为回文串\"></a>判读字符串是否为回文串</h5><ul>\n<li>所谓回文串即正者读反着读都一样：</li>\n<li>解决方案：<ul>\n<li>1.设置两个索引，一个从字符串开始位置往后走，一个从字符串最后的位置往前走，比较这两个索引指向的字符是否相等，直到遍历完整个字符串；注意这里其实并不需要遍历整个字符串，一个索引只需要走一半就可以，回文串两边对称的。</li>\n<li>2.利用栈，思路类似</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"字符串转整数-atoi\"><a href=\"#字符串转整数-atoi\" class=\"headerlink\" title=\"字符串转整数(atoi)\"></a>字符串转整数(atoi)</h5><ul>\n<li>分析：这个题目需要注意的是各种不规则的输入和其他边缘条件如int整数的范围等</li>\n<li>解决方案:<ul>\n<li>若是严格的检查，则判断字符ASCII码是否在0-9之间，注意整数的首位不能为0）；整数的正负；数据是否溢出；是否数据的表现形式如33x8fe；等等。</li>\n<li>非严格的检查，如遇到非法的字符跳过即可；首位为0时跳过或者当成八进制等等</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"对两个二进制字符串求和\"><a href=\"#对两个二进制字符串求和\" class=\"headerlink\" title=\"对两个二进制字符串求和\"></a>对两个二进制字符串求和</h5><ul>\n<li>如”111”+”101”=”1100”</li>\n<li>解决方案：<ul>\n<li><ol>\n<li>像十进制那样直接求和，进位，从最右边的字符开始，若相加大于1则进位，注意两个字符串可能一个很长一个很短，而进位可能一直需要延续</li>\n</ol>\n</li>\n<li>2.将两个字符串分别转换为十进制再做运算，结果再转为二进制</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"最长回文子串\"><a href=\"#最长回文子串\" class=\"headerlink\" title=\"最长回文子串\"></a>最长回文子串</h5><ul>\n<li>暴力方法：将所有子串列出来先判断哪些是回文串，再取长度最长的；<h5 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h5></li>\n<li>我对正则表达式的处理方案一直很倾向于用状态机，这种方法可以用图表示出来，方案的完备性好判断，别人也好理解；</li>\n<li>递归方案<h5 id=\"最长公共前缀\"><a href=\"#最长公共前缀\" class=\"headerlink\" title=\"最长公共前缀\"></a>最长公共前缀</h5></li>\n<li>找出字符串数组中的最长公共前缀：给定一个字符串数组，找出他们的最长公共前缀</li>\n<li>分析：这道题目需求不明确，是需要 所有的字符串=都有的公共前缀还是若只有部分字符串有公共前缀也可以？也可能我理解有误~</li>\n</ul>\n<h5 id=\"实现strtod-函数\"><a href=\"#实现strtod-函数\" class=\"headerlink\" title=\"实现strtod()函数\"></a>实现strtod()函数</h5><ul>\n<li>即判断一个字符串是否表示一个数字如:”1.0”</li>\n<li>分析：可以用状态机实现</li>\n</ul>\n<h5 id=\"整数和罗马数字的相互转换\"><a href=\"#整数和罗马数字的相互转换\" class=\"headerlink\" title=\"整数和罗马数字的相互转换\"></a>整数和罗马数字的相互转换</h5><ul>\n<li>这道题有些无聊<h5 id=\"count-and-say\"><a href=\"#count-and-say\" class=\"headerlink\" title=\"count and say\"></a>count and say</h5></li>\n<li>一个数列如下：<br>1 11 21 1211 111221,…<br>意思是1,第二个表示第一个的情况，即1个1故为11,第三个数表示第二个数的情况，即两个1,21，以此类推  </li>\n<li>求数列中的第n个数</li>\n<li>解决方案，直接模拟，一个一个算出来</li>\n</ul>\n<h5 id=\"Anagrams\"><a href=\"#Anagrams\" class=\"headerlink\" title=\"Anagrams:\"></a>Anagrams:</h5><ul>\n<li>字符串中的打乱字母顺序从而得到新的单词如eat打乱后得到tea等</li>\n</ul>\n<h5 id=\"给定绝对路径简化它\"><a href=\"#给定绝对路径简化它\" class=\"headerlink\" title=\"给定绝对路径简化它\"></a>给定绝对路径简化它</h5><h5 id=\"在一个英文句子中找到最后一个单词的长度\"><a href=\"#在一个英文句子中找到最后一个单词的长度\" class=\"headerlink\" title=\"在一个英文句子中找到最后一个单词的长度\"></a>在一个英文句子中找到最后一个单词的长度</h5>","site":{"data":{}},"excerpt":"<h3 id=\"leetcode-string\"><a href=\"#leetcode-string\" class=\"headerlink\" title=\"leetcode_string\"></a>leetcode_string</h3><h4 id=\"传统字符串匹配：\"><a href=\"#传统字符串匹配：\" class=\"headerlink\" title=\"传统字符串匹配：\"></a>传统字符串匹配：</h4><ul>\n<li>简单写写,变量命名等就先不纠结了</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(<span class=\"keyword\">char</span> s[],<span class=\"keyword\">char</span> p[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>]==<span class=\"string\">'\\0'</span>||p[<span class=\"number\">0</span>]==<span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"p or s is null\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>,i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>;s[i]!=<span class=\"string\">'\\0'</span>&amp;&amp;s[k]!=<span class=\"string\">'\\0'</span>;)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t     <span class=\"keyword\">if</span>(p[j]==<span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">\t\t\t\t   <span class=\"keyword\">break</span>;\t </span><br><span class=\"line\">\t\t\t <span class=\"keyword\">if</span>(s[k]==p[j])</span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t\t k++;</span><br><span class=\"line\">\t\t\t\t\t j++;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">else</span> <span class=\"comment\">//不匹配时重新来过</span></span><br><span class=\"line\">\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t\t i++;</span><br><span class=\"line\">\t\t\t\t\t k=i;</span><br><span class=\"line\">\t\t\t\t\t j=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p[j]==<span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"kmp匹配算法\"><a href=\"#kmp匹配算法\" class=\"headerlink\" title=\"kmp匹配算法\"></a>kmp匹配算法</h4><p>kmp算法：基本过程见另一篇文章数据结构之字符串","more":"，这里贴写代码(未经大数据检验，谨慎观看)<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">nextfunc</span><span class=\"params\">(<span class=\"keyword\">char</span> p[],<span class=\"keyword\">int</span> next[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   next[<span class=\"number\">0</span>]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">   next[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">while</span>(p[j]!=<span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">\t\t   <span class=\"keyword\">if</span>(k==<span class=\"number\">0</span>||p[j]==p[k])</span><br><span class=\"line\">\t\t   &#123;</span><br><span class=\"line\">\t\t\t\t   ++j;</span><br><span class=\"line\">\t\t\t\t   ++k;</span><br><span class=\"line\">\t\t\t\t   next[j]=k;</span><br><span class=\"line\">\t\t   &#125;</span><br><span class=\"line\">\t\t   <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t   k=next[k];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kmp</span><span class=\"params\">(<span class=\"keyword\">char</span> s[],<span class=\"keyword\">char</span> p[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> next[<span class=\"number\">100</span>];</span><br><span class=\"line\">   nextfunc(p,next);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>;s[i]!=<span class=\"string\">'\\0'</span>&amp;&amp;p[j]!=<span class=\"string\">'\\0'</span>;i++)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">\t\t   <span class=\"comment\">//if(j==-1)j=0;</span></span><br><span class=\"line\">\t\t   <span class=\"keyword\">if</span>(s[i]==p[j])</span><br><span class=\"line\">\t\t   &#123;</span><br><span class=\"line\">\t\t     j++;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t   &#125;</span><br><span class=\"line\">\t\t   <span class=\"keyword\">while</span>(s[i]!=p[j]&amp;&amp;j&gt;=<span class=\"number\">0</span>)j=next[j];</span><br><span class=\"line\">\t\t   j++;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p[j]==<span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">\t\t <span class=\"keyword\">return</span> i-j;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>简单测试<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> a[<span class=\"number\">19</span>]=&#123;<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'a'</span>,<span class=\"string\">'s'</span>,<span class=\"string\">'s'</span>,<span class=\"string\">'f'</span>,<span class=\"string\">'r'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'r'</span>&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> b[<span class=\"number\">10</span>]=&#123;<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'a'</span>,<span class=\"string\">'s'</span>&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> pos=strStr(a,b);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;pos&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> pos2=kmp(a,b);</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;pos2&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"其他字符串算法题目：\"><a href=\"#其他字符串算法题目：\" class=\"headerlink\" title=\"其他字符串算法题目：\"></a>其他字符串算法题目：</h4><h5 id=\"判读字符串是否为回文串\"><a href=\"#判读字符串是否为回文串\" class=\"headerlink\" title=\"判读字符串是否为回文串\"></a>判读字符串是否为回文串</h5><ul>\n<li>所谓回文串即正者读反着读都一样：</li>\n<li>解决方案：<ul>\n<li>1.设置两个索引，一个从字符串开始位置往后走，一个从字符串最后的位置往前走，比较这两个索引指向的字符是否相等，直到遍历完整个字符串；注意这里其实并不需要遍历整个字符串，一个索引只需要走一半就可以，回文串两边对称的。</li>\n<li>2.利用栈，思路类似</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"字符串转整数-atoi\"><a href=\"#字符串转整数-atoi\" class=\"headerlink\" title=\"字符串转整数(atoi)\"></a>字符串转整数(atoi)</h5><ul>\n<li>分析：这个题目需要注意的是各种不规则的输入和其他边缘条件如int整数的范围等</li>\n<li>解决方案:<ul>\n<li>若是严格的检查，则判断字符ASCII码是否在0-9之间，注意整数的首位不能为0）；整数的正负；数据是否溢出；是否数据的表现形式如33x8fe；等等。</li>\n<li>非严格的检查，如遇到非法的字符跳过即可；首位为0时跳过或者当成八进制等等</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"对两个二进制字符串求和\"><a href=\"#对两个二进制字符串求和\" class=\"headerlink\" title=\"对两个二进制字符串求和\"></a>对两个二进制字符串求和</h5><ul>\n<li>如”111”+”101”=”1100”</li>\n<li>解决方案：<ul>\n<li><ol>\n<li>像十进制那样直接求和，进位，从最右边的字符开始，若相加大于1则进位，注意两个字符串可能一个很长一个很短，而进位可能一直需要延续</li>\n</ol>\n</li>\n<li>2.将两个字符串分别转换为十进制再做运算，结果再转为二进制</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"最长回文子串\"><a href=\"#最长回文子串\" class=\"headerlink\" title=\"最长回文子串\"></a>最长回文子串</h5><ul>\n<li>暴力方法：将所有子串列出来先判断哪些是回文串，再取长度最长的；<h5 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h5></li>\n<li>我对正则表达式的处理方案一直很倾向于用状态机，这种方法可以用图表示出来，方案的完备性好判断，别人也好理解；</li>\n<li>递归方案<h5 id=\"最长公共前缀\"><a href=\"#最长公共前缀\" class=\"headerlink\" title=\"最长公共前缀\"></a>最长公共前缀</h5></li>\n<li>找出字符串数组中的最长公共前缀：给定一个字符串数组，找出他们的最长公共前缀</li>\n<li>分析：这道题目需求不明确，是需要 所有的字符串=都有的公共前缀还是若只有部分字符串有公共前缀也可以？也可能我理解有误~</li>\n</ul>\n<h5 id=\"实现strtod-函数\"><a href=\"#实现strtod-函数\" class=\"headerlink\" title=\"实现strtod()函数\"></a>实现strtod()函数</h5><ul>\n<li>即判断一个字符串是否表示一个数字如:”1.0”</li>\n<li>分析：可以用状态机实现</li>\n</ul>\n<h5 id=\"整数和罗马数字的相互转换\"><a href=\"#整数和罗马数字的相互转换\" class=\"headerlink\" title=\"整数和罗马数字的相互转换\"></a>整数和罗马数字的相互转换</h5><ul>\n<li>这道题有些无聊<h5 id=\"count-and-say\"><a href=\"#count-and-say\" class=\"headerlink\" title=\"count and say\"></a>count and say</h5></li>\n<li>一个数列如下：<br>1 11 21 1211 111221,…<br>意思是1,第二个表示第一个的情况，即1个1故为11,第三个数表示第二个数的情况，即两个1,21，以此类推  </li>\n<li>求数列中的第n个数</li>\n<li>解决方案，直接模拟，一个一个算出来</li>\n</ul>\n<h5 id=\"Anagrams\"><a href=\"#Anagrams\" class=\"headerlink\" title=\"Anagrams:\"></a>Anagrams:</h5><ul>\n<li>字符串中的打乱字母顺序从而得到新的单词如eat打乱后得到tea等</li>\n</ul>\n<h5 id=\"给定绝对路径简化它\"><a href=\"#给定绝对路径简化它\" class=\"headerlink\" title=\"给定绝对路径简化它\"></a>给定绝对路径简化它</h5><h5 id=\"在一个英文句子中找到最后一个单词的长度\"><a href=\"#在一个英文句子中找到最后一个单词的长度\" class=\"headerlink\" title=\"在一个英文句子中找到最后一个单词的长度\"></a>在一个英文句子中找到最后一个单词的长度</h5>"},{"title":"cpp_runtime_semantis","date":"2018-07-29T09:54:07.000Z","_content":"### c++ 执行期语意学\n#### 执行期和编译期的理解\n+ 执行期：此时是对已经编译等生成的可执行文件装载到内存并调用cpu将其作为一个进程执行的过程，对c.c++来说程序的入口为main,即第一条指令是执行main函数开始的，而c++可能会加入一些额外的代码，所以实际写的第一条语句和执行的第一条语句可能有偏差；　　　<!--more-->\n+ 在执行的过程，是程序代码运行的过程，可以想象为工厂开始生产，此时需要空间来运行，需要生产线，产品，工人，工人们走来走去搬运物品等；对程序的运行而言，此时主要的活动空间为栈和堆，即在栈和堆分配空间，而流程制式就是代码段，静态变量的数据区可以比喻为整个工厂共有的数据等；　这个过程中栈会被不断生成消失，堆也是，承载他们的是内存对应的区域；执行完后就从内存消失；\n+ 　编译期，就像生孩子之前的扫描，检查，看看语法对不对，添加额外的内容(c++).生成对应的汇编代码和二进制代码，而程序员需要尽力　编译出高效，整洁，可读等特性的代码，就像这个过程中通过调理，吃合适的东西等；尽可能避开一些坑和耗时的行为le.\n+ 　这部分的内容并不涉及太多执行期的，而更多的是编译器在编译代码时做了什么手脚\n#### c++中的运算符函数和运算符语法糖\n+ 运算符被编译器转换为运算符函数\n操作符函数例子-->到临时对象的产生和销毁带来的效率问题\n-->如何在程序中尽量避免产生临时变量和调用析构函数  \n例子：  \n```cpp\nX xx;\nY yy;\nif(yy==xx.getvalue()) ``` \n其中涉及到yy的==运算符函数和xx的getvalue函数，前者为：  \nbool operator==(const Y&) const后者为X getvalue()  　　\nyy==xx.getvalue()被转换为yy.operator==(xx.getvalue),显然类型不相符；  \n而此时若X有函数operator Y()const;//conversion运算符，则进一步转换为：  \n     yy.operator==(xx.getvalue.operator Y())  \n 这行代码看上去是这样简单，但是实际上需要产生中间变量，转为伪代码:  \n   X　tmp1=xx.getvalue;//放返回值  \n   Y tmp2=tmp1.operator Y()//同上  \n   int tmp3=yy.operator==(tmp2);//放置返回值  \n   总共产生三个临时变量，而且还得析构，麻烦效率低  \n   (注意，上述的为什么不能直接连锁调用?因为返回的是值而不是指针，思考this指针的连锁操作，cout的连锁操作，个人思考，应该是因为返回的是指针，上述返回的是值，所以无法用值调用下面的函数）\n\n\n#### 对象的构造和解构\n+ 构造函数在哪里被安插:  \n构造函数在编译时，由编译器在合适的地方安插，一般情况下，正如我们想像的一样：在定义对象时会执行构造函数,解构在对象销毁时;\n//c++伪代码  \n```cpp\n{\n   Point point ;\n   //point.Point::Point() 一般而言会被安插在这里\n   ...\n   //point.Point::~Point() 一般而言会被安插在这里\n   }\n ```\n+ 解构函数在哪里被安插:  \n1、解构函数的安插需要考虑程序的退出时间（或者某个代码块的退出时间，在可能退出的地方都要加解构函数\n```cpp\n{\n  Point point;\n  //constructor here\n  switch (int (point.x()) {\n  case -1:\n    //mumble;\n    //destructor here\n    return ;\n  case 0:\n    //mumble;\n    //destructor here\n    ....\n    default :\n      //mumble\n      //destructor here\n      return ;\n     }\n    destructor here\n    }\n  ```\n  \n\n+ 解构代码应该在任何可能退出代码块的地方，return等，switch,if，goto等都会使加上解构函数的调用以避免出现退出但是还没有执行析构函数的尴尬；\n+ 而在如下例子：\n```cpp\n{\n   if(cache)\n      return 1;\n   Point xx;\n   if(xx.get()==1)\n   return 1;\n   }\n   和\n   {\n     Point xx;\n     if(cache）\n       return 1;\n       ...\n   }\n   ```\n   前者不需要在if(cache）的return 前加解构和　构造函数，而后者需要，显然后者综合效率更差些；\n   所以设计c++代码时候需要考虑，尽量在使用它的附近定义它\n   \n+ 对特殊情况的考虑--全局对象的构造函数和解构函数的安插，有特殊的处理    \n\"前面看到的是正常的局部情况，现在考虑的是全局对象，定义在main外面，它的构造函数被安插在哪里，什么时候执行?\"\n考虑以下例子：  \n```\n  Matrix identity;\n   main ()\n   {\n      //identity 必须在这里被初始化\n      Matrix m1=identity;\n      ...\n      return 0;\n   }\n   ```\n   很明显，c++ 必须保证第一次用到identity把他构造出来而在main结束前销毁它；对全局对象而言，有构造函数和析构函数时，称为静态的初始化和内存释放操作；\n   全局对象和全局变量一样被放在数据段(data segment),在c中，可以在编译期间给定全局变量常量值，而c++中的全局对象需要程序激活后才能执行构造函数给初值；相当于给全局对象做静态初始化；\n```\n  //例如,cfront在执行前，加入_main来初始化各种全局对象；\n  //sti_xxx---static initialization\n   int main()\n   {\n      _main();---(_sti_xxx(); _sti_xxx();,,,)\n      ...\n      ...\n      _exit()---(_std_xxx()....)\n      //而在结束时调用他们的析构函数\n      }\n      但是需要收集程序中各个对象文件的_sti函数和_std函数，此时可以用nm命令，即它会倾倒出符号表项目，nm会施加到.o文件上；搜寻_sti _std开头的函数；最后总结整理出来；\n```\n\n+ 对特殊情况的考虑--局部静态对象\n考虑局部静态对象只会构造一次和销毁一次，却是可能调用多次包含定义局部静态对象的函数，如何保证只会构造一次和销毁一次呢?\n``` \n   const Matrix&\n   identify() {\n      static Matrix mat_identify;\n      //....\n      return mat_identify;\n   }\n  //1\\首先要保证在调用该函数才初始化局部静态变量，\n  //2、其次，保证多次调用该函数不会重复初始化对象；\n```\n简单的说，解决方案就是用一个标志变量，当已经初始化一次局部静态变量就置为真；\n+ 对象数组什么时候构造和解构?\n考虑一下定义了一个对象数组，之后未做任何改动，要取其中的值，会在定义数组的时候也初始化数组中每一个对象（即调用构造函数)吗？\n```\nclass Point{\n   public:\n      int a;\n      Point (){a=3;}\n }\nPoint knot[10];\ncout<<knot[3].a;//会打印3\n}\n```\n当这种对象数组没有默认构造函数和析构函数，则定义时和内置类型相同，只需配置足够的内存保存即可；\n而当对象有构造函数和析构函数时，编译器提供了vec_new() vec_delete()之类的函数来统一做构造和析构\n\n```\nvoid *vec_new(void *array,//数组起始地址\n      size_t elem_size,int elem_count,//对象大小和数组对象个数\n      void (*constructor)(*void)\n      void(*destructor)(*void)\n      而实际上调用时：\n      Point knots[10]\n      //可能是这样调用，delete类似\n      vec_new(&knnots,sizeof(Point),10,&Point::Point,0)\n```\n而如果程序员额外调用了其中一些元素的构造函数，则：\n```\nPoint knots[10]={Point(),Point(1.8,2.1,0.2),-1.9};\n类似这样，则可能会明确的初始化前三个元素，后面的其他则用vec_new\n```\n\n\n+ 默认构造函数和数组\n\n#### new和delete运算符\n上述是针对对象的，new和delete是针对指针的；\n\n+ 本质上调用malloc函数和free函数,编译器解析new，delete会安插构造函数和解构函数\nnew 的实际过程：\n\n```cpp\n对内建类型\nint *pi=new int(5);\n//1 调用函数库的new:_new \n//int *pi=_new(sizeof(int));\n//2 设置初值：*pi=5;\n//或加条件：\n(int  *pi ; if(pi=_new(...))*pi=5)\n//delete类似；\n对对象：\nPoint3d *origin =new Point3d;\n转换为：\nPoint3d *origin;\n//伪代码\nif(origin =_new(sizeof(Point3d))\norigin=Pointed::Point3d(origin)//注意这里会调用构造函数\n\ndelete origin;\n转换为：\nif (!origin !=0) {\n//伪代码\nPoint3d::~Point3d(origin);\n_delete(origin);\n}\n\n而new 一般由malloc实现，delete由free实现；\nextern void operator new(size_t)\n{\n  if (size =0)\n    size=1;\n  void *last_alloc\n  while(!(last_alloc=malloc(size)))\n  {\n   if(_new_handle)\n   (*_new_handle)();\n   else \n      return 0;\n   }\n      return last_alloc\n}\n      \n ```\n\n\n+ 针对数组的new和delete\n实际上的new数组，若不存在构造函数，则只会做new的运算符函数：int *parray=(*int)_new(5*sizeof(int));\n待续，略复杂。。。\n+ placement operator new的语意-——new的重载；\n\n#### 影响c++效率因素之一---临时性对象\n+ 为什么需要临时性对象\n临时性对象是影响程序效率和引入bug的来源之一；\n  + 隐式的类型转换需要临时性对象：\n  当用内建类型写下：\n ```cpp\n    int a,b,c;\n    ....\n    a=b+c;//内建类型将算出的值赋给a\n    //想象一下如果此时a,b,c都是对象，b+c返回一个对象呢？\n    在c++中操作符运算本质上也是函数，则这里单纯靠b+c返回\n    一个对象的值赋值给a已经不现实了，对象是一个结构性的\n    变量；所以在这种情况下就需要构建一个临时性对象，并将\n    此临时性对象（函数的结果）利用赋值函数拷贝给a;\n```\n + 单纯传入对象作为函数参数时，即使不返回对象，也会产生临时性对象，为什么? 随意写了个例子：\n ```\n     1 #include<iostream>\n    2 class Point {\n    3         public:\n    4                 int a;\n    5                 Point(){std::cout<<\"constructor\"<<std::endl; a=4;}\n    6                 void printa() const { std::cout<<a<<32<<std::endl;}\n    7                 ~Point(){\n    8                         std::cout<<\"~destrucot\"<<std::endl;}\n>>  9                Point(const Point& p)\n   10                {\n   11                                 std::cout << \"Copy Constructor\" << std::en      dl;\n   12                }\n   13 \n>> 14               Point& operator=(const Point& p)\n   15               {\n   16                  std::cout << \"Assign\" << std::endl;\n   17                  return *this;\n   18               }\n   19 \n   20 };\n   21 void getv(const Point pp)\n   22 {\n   23     //= pp.a=6;\n   24         pp.printa();\n   25         std::cout<<pp.a<<std::endl;\n   26 }\n   27 \n   28 int main()\n   29 {\n   30         Point pplist;\n   31         std::cout<<pplist.a<<std::endl;\n   32         getv(pplist);//这里产生临时对象是调用拷贝构造函数\n   33         return 0;\n   34 }\n```\n\n  按照内建类型来看，传入函数参数，其实传入的是值，\n  而对于对象来说，若传入的是引用或指针则不需要产生临时性对象，但是传入的若是值，则c++编译器需要产生一个临时性对象，在函数的栈中，供函数中对该对象调用函数和值等操作；\n  + 函数返回对象；\n```\n 另一个例子：\n    如何做X xxx=bar();如何拷贝的？双阶段初始化：\n  a 增加一个额外的引用参数给函数，如void bar(X＆　_result)\n  b 在return 前插入一个copy constructor \n      void bar(X &__result){\n                X xx;\n                xx.X::X();\n                __result.X::XX(xx);\n                return ;\n        }\n    X xxx=bar()\n    //->bar(X &__result);\n        xxx=_result;\n```\n  + 手动调用构造函数：此时也会生成临时性对象；\n  + 其他如通过构造函数调用成员函数的：单纯一个表达式 a+b这种的\n \n```cpp\n   #include <iostream>\nclass tmpclass\n{\npublic:\n    int a;\n    tmpclass(int i)\n    {\n        a = i;\n    }\n\n    tmpclass()\n    {\n        tmpclass(0);//手动调用构造函数会产生临时对象，临时对象的a=0,故最后结果show还是无初值\n    }\n\n    void show()\n    {\n        std::cout << \"a = \" << a << std::endl;\n    }\n};\n\nint main(void)\n{\n    tmpclass c;\n    c.show();\n    return 0;\n}\n其他：\n tmpclass c1 = tmpclass(6);//赋值构造+构造函数\n tmpclass(6).show()//产生临时性对象；\n```\n\n+ 如何避免产生临时性对象\n尽量不用上述的手法编程\n+ 临时性对象的效率（迷思，测试)\n临时性对象会造成效率低下，在不当的代码下容易产生很多临时性对象；不当的使用也会造成非预期的结果；\n+ 临时性对象的生命周期：\n可能是这个表达式的生命周期，具体可以通过构造类函数和析构函数调试；\n","source":"_posts/cpp-runtime-semantis.md","raw":"---\ntitle: cpp_runtime_semantis\ndate: 2018-07-29 17:54:07\ntags: cpp_class\ncategories: c&cpp\n---\n### c++ 执行期语意学\n#### 执行期和编译期的理解\n+ 执行期：此时是对已经编译等生成的可执行文件装载到内存并调用cpu将其作为一个进程执行的过程，对c.c++来说程序的入口为main,即第一条指令是执行main函数开始的，而c++可能会加入一些额外的代码，所以实际写的第一条语句和执行的第一条语句可能有偏差；　　　<!--more-->\n+ 在执行的过程，是程序代码运行的过程，可以想象为工厂开始生产，此时需要空间来运行，需要生产线，产品，工人，工人们走来走去搬运物品等；对程序的运行而言，此时主要的活动空间为栈和堆，即在栈和堆分配空间，而流程制式就是代码段，静态变量的数据区可以比喻为整个工厂共有的数据等；　这个过程中栈会被不断生成消失，堆也是，承载他们的是内存对应的区域；执行完后就从内存消失；\n+ 　编译期，就像生孩子之前的扫描，检查，看看语法对不对，添加额外的内容(c++).生成对应的汇编代码和二进制代码，而程序员需要尽力　编译出高效，整洁，可读等特性的代码，就像这个过程中通过调理，吃合适的东西等；尽可能避开一些坑和耗时的行为le.\n+ 　这部分的内容并不涉及太多执行期的，而更多的是编译器在编译代码时做了什么手脚\n#### c++中的运算符函数和运算符语法糖\n+ 运算符被编译器转换为运算符函数\n操作符函数例子-->到临时对象的产生和销毁带来的效率问题\n-->如何在程序中尽量避免产生临时变量和调用析构函数  \n例子：  \n```cpp\nX xx;\nY yy;\nif(yy==xx.getvalue()) ``` \n其中涉及到yy的==运算符函数和xx的getvalue函数，前者为：  \nbool operator==(const Y&) const后者为X getvalue()  　　\nyy==xx.getvalue()被转换为yy.operator==(xx.getvalue),显然类型不相符；  \n而此时若X有函数operator Y()const;//conversion运算符，则进一步转换为：  \n     yy.operator==(xx.getvalue.operator Y())  \n 这行代码看上去是这样简单，但是实际上需要产生中间变量，转为伪代码:  \n   X　tmp1=xx.getvalue;//放返回值  \n   Y tmp2=tmp1.operator Y()//同上  \n   int tmp3=yy.operator==(tmp2);//放置返回值  \n   总共产生三个临时变量，而且还得析构，麻烦效率低  \n   (注意，上述的为什么不能直接连锁调用?因为返回的是值而不是指针，思考this指针的连锁操作，cout的连锁操作，个人思考，应该是因为返回的是指针，上述返回的是值，所以无法用值调用下面的函数）\n\n\n#### 对象的构造和解构\n+ 构造函数在哪里被安插:  \n构造函数在编译时，由编译器在合适的地方安插，一般情况下，正如我们想像的一样：在定义对象时会执行构造函数,解构在对象销毁时;\n//c++伪代码  \n```cpp\n{\n   Point point ;\n   //point.Point::Point() 一般而言会被安插在这里\n   ...\n   //point.Point::~Point() 一般而言会被安插在这里\n   }\n ```\n+ 解构函数在哪里被安插:  \n1、解构函数的安插需要考虑程序的退出时间（或者某个代码块的退出时间，在可能退出的地方都要加解构函数\n```cpp\n{\n  Point point;\n  //constructor here\n  switch (int (point.x()) {\n  case -1:\n    //mumble;\n    //destructor here\n    return ;\n  case 0:\n    //mumble;\n    //destructor here\n    ....\n    default :\n      //mumble\n      //destructor here\n      return ;\n     }\n    destructor here\n    }\n  ```\n  \n\n+ 解构代码应该在任何可能退出代码块的地方，return等，switch,if，goto等都会使加上解构函数的调用以避免出现退出但是还没有执行析构函数的尴尬；\n+ 而在如下例子：\n```cpp\n{\n   if(cache)\n      return 1;\n   Point xx;\n   if(xx.get()==1)\n   return 1;\n   }\n   和\n   {\n     Point xx;\n     if(cache）\n       return 1;\n       ...\n   }\n   ```\n   前者不需要在if(cache）的return 前加解构和　构造函数，而后者需要，显然后者综合效率更差些；\n   所以设计c++代码时候需要考虑，尽量在使用它的附近定义它\n   \n+ 对特殊情况的考虑--全局对象的构造函数和解构函数的安插，有特殊的处理    \n\"前面看到的是正常的局部情况，现在考虑的是全局对象，定义在main外面，它的构造函数被安插在哪里，什么时候执行?\"\n考虑以下例子：  \n```\n  Matrix identity;\n   main ()\n   {\n      //identity 必须在这里被初始化\n      Matrix m1=identity;\n      ...\n      return 0;\n   }\n   ```\n   很明显，c++ 必须保证第一次用到identity把他构造出来而在main结束前销毁它；对全局对象而言，有构造函数和析构函数时，称为静态的初始化和内存释放操作；\n   全局对象和全局变量一样被放在数据段(data segment),在c中，可以在编译期间给定全局变量常量值，而c++中的全局对象需要程序激活后才能执行构造函数给初值；相当于给全局对象做静态初始化；\n```\n  //例如,cfront在执行前，加入_main来初始化各种全局对象；\n  //sti_xxx---static initialization\n   int main()\n   {\n      _main();---(_sti_xxx(); _sti_xxx();,,,)\n      ...\n      ...\n      _exit()---(_std_xxx()....)\n      //而在结束时调用他们的析构函数\n      }\n      但是需要收集程序中各个对象文件的_sti函数和_std函数，此时可以用nm命令，即它会倾倒出符号表项目，nm会施加到.o文件上；搜寻_sti _std开头的函数；最后总结整理出来；\n```\n\n+ 对特殊情况的考虑--局部静态对象\n考虑局部静态对象只会构造一次和销毁一次，却是可能调用多次包含定义局部静态对象的函数，如何保证只会构造一次和销毁一次呢?\n``` \n   const Matrix&\n   identify() {\n      static Matrix mat_identify;\n      //....\n      return mat_identify;\n   }\n  //1\\首先要保证在调用该函数才初始化局部静态变量，\n  //2、其次，保证多次调用该函数不会重复初始化对象；\n```\n简单的说，解决方案就是用一个标志变量，当已经初始化一次局部静态变量就置为真；\n+ 对象数组什么时候构造和解构?\n考虑一下定义了一个对象数组，之后未做任何改动，要取其中的值，会在定义数组的时候也初始化数组中每一个对象（即调用构造函数)吗？\n```\nclass Point{\n   public:\n      int a;\n      Point (){a=3;}\n }\nPoint knot[10];\ncout<<knot[3].a;//会打印3\n}\n```\n当这种对象数组没有默认构造函数和析构函数，则定义时和内置类型相同，只需配置足够的内存保存即可；\n而当对象有构造函数和析构函数时，编译器提供了vec_new() vec_delete()之类的函数来统一做构造和析构\n\n```\nvoid *vec_new(void *array,//数组起始地址\n      size_t elem_size,int elem_count,//对象大小和数组对象个数\n      void (*constructor)(*void)\n      void(*destructor)(*void)\n      而实际上调用时：\n      Point knots[10]\n      //可能是这样调用，delete类似\n      vec_new(&knnots,sizeof(Point),10,&Point::Point,0)\n```\n而如果程序员额外调用了其中一些元素的构造函数，则：\n```\nPoint knots[10]={Point(),Point(1.8,2.1,0.2),-1.9};\n类似这样，则可能会明确的初始化前三个元素，后面的其他则用vec_new\n```\n\n\n+ 默认构造函数和数组\n\n#### new和delete运算符\n上述是针对对象的，new和delete是针对指针的；\n\n+ 本质上调用malloc函数和free函数,编译器解析new，delete会安插构造函数和解构函数\nnew 的实际过程：\n\n```cpp\n对内建类型\nint *pi=new int(5);\n//1 调用函数库的new:_new \n//int *pi=_new(sizeof(int));\n//2 设置初值：*pi=5;\n//或加条件：\n(int  *pi ; if(pi=_new(...))*pi=5)\n//delete类似；\n对对象：\nPoint3d *origin =new Point3d;\n转换为：\nPoint3d *origin;\n//伪代码\nif(origin =_new(sizeof(Point3d))\norigin=Pointed::Point3d(origin)//注意这里会调用构造函数\n\ndelete origin;\n转换为：\nif (!origin !=0) {\n//伪代码\nPoint3d::~Point3d(origin);\n_delete(origin);\n}\n\n而new 一般由malloc实现，delete由free实现；\nextern void operator new(size_t)\n{\n  if (size =0)\n    size=1;\n  void *last_alloc\n  while(!(last_alloc=malloc(size)))\n  {\n   if(_new_handle)\n   (*_new_handle)();\n   else \n      return 0;\n   }\n      return last_alloc\n}\n      \n ```\n\n\n+ 针对数组的new和delete\n实际上的new数组，若不存在构造函数，则只会做new的运算符函数：int *parray=(*int)_new(5*sizeof(int));\n待续，略复杂。。。\n+ placement operator new的语意-——new的重载；\n\n#### 影响c++效率因素之一---临时性对象\n+ 为什么需要临时性对象\n临时性对象是影响程序效率和引入bug的来源之一；\n  + 隐式的类型转换需要临时性对象：\n  当用内建类型写下：\n ```cpp\n    int a,b,c;\n    ....\n    a=b+c;//内建类型将算出的值赋给a\n    //想象一下如果此时a,b,c都是对象，b+c返回一个对象呢？\n    在c++中操作符运算本质上也是函数，则这里单纯靠b+c返回\n    一个对象的值赋值给a已经不现实了，对象是一个结构性的\n    变量；所以在这种情况下就需要构建一个临时性对象，并将\n    此临时性对象（函数的结果）利用赋值函数拷贝给a;\n```\n + 单纯传入对象作为函数参数时，即使不返回对象，也会产生临时性对象，为什么? 随意写了个例子：\n ```\n     1 #include<iostream>\n    2 class Point {\n    3         public:\n    4                 int a;\n    5                 Point(){std::cout<<\"constructor\"<<std::endl; a=4;}\n    6                 void printa() const { std::cout<<a<<32<<std::endl;}\n    7                 ~Point(){\n    8                         std::cout<<\"~destrucot\"<<std::endl;}\n>>  9                Point(const Point& p)\n   10                {\n   11                                 std::cout << \"Copy Constructor\" << std::en      dl;\n   12                }\n   13 \n>> 14               Point& operator=(const Point& p)\n   15               {\n   16                  std::cout << \"Assign\" << std::endl;\n   17                  return *this;\n   18               }\n   19 \n   20 };\n   21 void getv(const Point pp)\n   22 {\n   23     //= pp.a=6;\n   24         pp.printa();\n   25         std::cout<<pp.a<<std::endl;\n   26 }\n   27 \n   28 int main()\n   29 {\n   30         Point pplist;\n   31         std::cout<<pplist.a<<std::endl;\n   32         getv(pplist);//这里产生临时对象是调用拷贝构造函数\n   33         return 0;\n   34 }\n```\n\n  按照内建类型来看，传入函数参数，其实传入的是值，\n  而对于对象来说，若传入的是引用或指针则不需要产生临时性对象，但是传入的若是值，则c++编译器需要产生一个临时性对象，在函数的栈中，供函数中对该对象调用函数和值等操作；\n  + 函数返回对象；\n```\n 另一个例子：\n    如何做X xxx=bar();如何拷贝的？双阶段初始化：\n  a 增加一个额外的引用参数给函数，如void bar(X＆　_result)\n  b 在return 前插入一个copy constructor \n      void bar(X &__result){\n                X xx;\n                xx.X::X();\n                __result.X::XX(xx);\n                return ;\n        }\n    X xxx=bar()\n    //->bar(X &__result);\n        xxx=_result;\n```\n  + 手动调用构造函数：此时也会生成临时性对象；\n  + 其他如通过构造函数调用成员函数的：单纯一个表达式 a+b这种的\n \n```cpp\n   #include <iostream>\nclass tmpclass\n{\npublic:\n    int a;\n    tmpclass(int i)\n    {\n        a = i;\n    }\n\n    tmpclass()\n    {\n        tmpclass(0);//手动调用构造函数会产生临时对象，临时对象的a=0,故最后结果show还是无初值\n    }\n\n    void show()\n    {\n        std::cout << \"a = \" << a << std::endl;\n    }\n};\n\nint main(void)\n{\n    tmpclass c;\n    c.show();\n    return 0;\n}\n其他：\n tmpclass c1 = tmpclass(6);//赋值构造+构造函数\n tmpclass(6).show()//产生临时性对象；\n```\n\n+ 如何避免产生临时性对象\n尽量不用上述的手法编程\n+ 临时性对象的效率（迷思，测试)\n临时性对象会造成效率低下，在不当的代码下容易产生很多临时性对象；不当的使用也会造成非预期的结果；\n+ 临时性对象的生命周期：\n可能是这个表达式的生命周期，具体可以通过构造类函数和析构函数调试；\n","slug":"cpp-runtime-semantis","published":1,"updated":"2020-03-21T08:20:24.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7om001y2ujxqt2xj8qf","content":"<h3 id=\"c-执行期语意学\"><a href=\"#c-执行期语意学\" class=\"headerlink\" title=\"c++ 执行期语意学\"></a>c++ 执行期语意学</h3><h4 id=\"执行期和编译期的理解\"><a href=\"#执行期和编译期的理解\" class=\"headerlink\" title=\"执行期和编译期的理解\"></a>执行期和编译期的理解</h4><ul>\n<li>执行期：此时是对已经编译等生成的可执行文件装载到内存并调用cpu将其作为一个进程执行的过程，对c.c++来说程序的入口为main,即第一条指令是执行main函数开始的，而c++可能会加入一些额外的代码，所以实际写的第一条语句和执行的第一条语句可能有偏差；　　　<a id=\"more\"></a></li>\n<li>在执行的过程，是程序代码运行的过程，可以想象为工厂开始生产，此时需要空间来运行，需要生产线，产品，工人，工人们走来走去搬运物品等；对程序的运行而言，此时主要的活动空间为栈和堆，即在栈和堆分配空间，而流程制式就是代码段，静态变量的数据区可以比喻为整个工厂共有的数据等；　这个过程中栈会被不断生成消失，堆也是，承载他们的是内存对应的区域；执行完后就从内存消失；</li>\n<li>　编译期，就像生孩子之前的扫描，检查，看看语法对不对，添加额外的内容(c++).生成对应的汇编代码和二进制代码，而程序员需要尽力　编译出高效，整洁，可读等特性的代码，就像这个过程中通过调理，吃合适的东西等；尽可能避开一些坑和耗时的行为le.</li>\n<li>　这部分的内容并不涉及太多执行期的，而更多的是编译器在编译代码时做了什么手脚<h4 id=\"c-中的运算符函数和运算符语法糖\"><a href=\"#c-中的运算符函数和运算符语法糖\" class=\"headerlink\" title=\"c++中的运算符函数和运算符语法糖\"></a>c++中的运算符函数和运算符语法糖</h4></li>\n<li><p>运算符被编译器转换为运算符函数<br>操作符函数例子–&gt;到临时对象的产生和销毁带来的效率问题<br>–&gt;如何在程序中尽量避免产生临时变量和调用析构函数<br>例子：  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X xx;</span><br><span class=\"line\">Y yy;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(yy==xx.getvalue()) ``` </span><br><span class=\"line\">其中涉及到yy的==运算符函数和xx的getvalue函数，前者为：  </span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> Y&amp;) <span class=\"keyword\">const</span>后者为X getvalue()  　　</span><br><span class=\"line\">yy==xx.getvalue()被转换为yy.<span class=\"keyword\">operator</span>==(xx.getvalue),显然类型不相符；  </span><br><span class=\"line\">而此时若X有函数<span class=\"keyword\">operator</span> Y()<span class=\"keyword\">const</span>;<span class=\"comment\">//conversion运算符，则进一步转换为：  </span></span><br><span class=\"line\">     yy.<span class=\"keyword\">operator</span>==(xx.getvalue.<span class=\"keyword\">operator</span> Y())  </span><br><span class=\"line\"> 这行代码看上去是这样简单，但是实际上需要产生中间变量，转为伪代码:  </span><br><span class=\"line\">   X　tmp1=xx.getvalue;<span class=\"comment\">//放返回值  </span></span><br><span class=\"line\">   Y tmp2=tmp1.<span class=\"keyword\">operator</span> Y()<span class=\"comment\">//同上  </span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> tmp3=yy.<span class=\"keyword\">operator</span>==(tmp2);<span class=\"comment\">//放置返回值  </span></span><br><span class=\"line\">   总共产生三个临时变量，而且还得析构，麻烦效率低  </span><br><span class=\"line\">   (注意，上述的为什么不能直接连锁调用?因为返回的是值而不是指针，思考<span class=\"keyword\">this</span>指针的连锁操作，<span class=\"built_in\">cout</span>的连锁操作，个人思考，应该是因为返回的是指针，上述返回的是值，所以无法用值调用下面的函数）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### 对象的构造和解构</span><br><span class=\"line\">+ 构造函数在哪里被安插:  </span><br><span class=\"line\">构造函数在编译时，由编译器在合适的地方安插，一般情况下，正如我们想像的一样：在定义对象时会执行构造函数,解构在对象销毁时;</span><br><span class=\"line\"><span class=\"comment\">//c++伪代码  </span></span><br><span class=\"line\">```cpp</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   Point point ;</span><br><span class=\"line\">   <span class=\"comment\">//point.Point::Point() 一般而言会被安插在这里</span></span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"comment\">//point.Point::~Point() 一般而言会被安插在这里</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解构函数在哪里被安插:<br>1、解构函数的安插需要考虑程序的退出时间（或者某个代码块的退出时间，在可能退出的地方都要加解构函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  Point point;</span><br><span class=\"line\">  <span class=\"comment\">//constructor here</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"keyword\">int</span> (point.x()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">-1</span>:</span><br><span class=\"line\">    <span class=\"comment\">//mumble;</span></span><br><span class=\"line\">    <span class=\"comment\">//destructor here</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"comment\">//mumble;</span></span><br><span class=\"line\">    <span class=\"comment\">//destructor here</span></span><br><span class=\"line\">    ....</span><br><span class=\"line\">    <span class=\"keyword\">default</span> :</span><br><span class=\"line\">      <span class=\"comment\">//mumble</span></span><br><span class=\"line\">      <span class=\"comment\">//destructor here</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    destructor here</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>解构代码应该在任何可能退出代码块的地方，return等，switch,if，goto等都会使加上解构函数的调用以避免出现退出但是还没有执行析构函数的尴尬；</li>\n<li><p>而在如下例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(cache)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">   Point xx;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(xx.get()==<span class=\"number\">1</span>)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   和</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     Point xx;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(cache）</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p> 前者不需要在if(cache）的return 前加解构和　构造函数，而后者需要，显然后者综合效率更差些；<br> 所以设计c++代码时候需要考虑，尽量在使用它的附近定义它</p>\n</li>\n<li><p>对特殊情况的考虑–全局对象的构造函数和解构函数的安插，有特殊的处理<br>“前面看到的是正常的局部情况，现在考虑的是全局对象，定义在main外面，它的构造函数被安插在哪里，什么时候执行?”<br>考虑以下例子：  </p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Matrix</span> identity;</span><br><span class=\"line\"> main ()</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//identity 必须在这里被初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">Matrix</span> m1=identity;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p> 很明显，c++ 必须保证第一次用到identity把他构造出来而在main结束前销毁它；对全局对象而言，有构造函数和析构函数时，称为静态的初始化和内存释放操作；<br> 全局对象和全局变量一样被放在数据段(data segment),在c中，可以在编译期间给定全局变量常量值，而c++中的全局对象需要程序激活后才能执行构造函数给初值；相当于给全局对象做静态初始化；</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例如,cfront在执行前，加入_main来初始化各种全局对象；</span></span><br><span class=\"line\"><span class=\"comment\">//sti_xxx---static initialization</span></span><br><span class=\"line\"> int main()</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">    <span class=\"variable\">_main</span>();---(<span class=\"variable\">_sti_xxx</span>(); <span class=\"variable\">_sti_xxx</span>();,,,)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"variable\">_exit</span>()---(<span class=\"variable\">_std_xxx</span>()....)</span><br><span class=\"line\">    <span class=\"comment\">//而在结束时调用他们的析构函数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    但是需要收集程序中各个对象文件的<span class=\"variable\">_sti</span>函数和<span class=\"variable\">_std</span>函数，此时可以用nm命令，即它会倾倒出符号表项目，nm会施加到.o文件上；搜寻<span class=\"variable\">_sti</span> <span class=\"variable\">_std</span>开头的函数；最后总结整理出来；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对特殊情况的考虑–局部静态对象<br>考虑局部静态对象只会构造一次和销毁一次，却是可能调用多次包含定义局部静态对象的函数，如何保证只会构造一次和销毁一次呢?</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">const</span> Matrix&amp;</span><br><span class=\"line\"> identify() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Matrix mat_identify;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mat_identify;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//1\\首先要保证在调用该函数才初始化局部静态变量，</span></span><br><span class=\"line\"><span class=\"comment\">//2、其次，保证多次调用该函数不会重复初始化对象；</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>简单的说，解决方案就是用一个标志变量，当已经初始化一次局部静态变量就置为真；</p>\n<ul>\n<li>对象数组什么时候构造和解构?<br>考虑一下定义了一个对象数组，之后未做任何改动，要取其中的值，会在定义数组的时候也初始化数组中每一个对象（即调用构造函数)吗？<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">      Point ()&#123;a=<span class=\"number\">3</span>;&#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">Point knot[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;knot[<span class=\"number\">3</span>].a;<span class=\"comment\">//会打印3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当这种对象数组没有默认构造函数和析构函数，则定义时和内置类型相同，只需配置足够的内存保存即可；<br>而当对象有构造函数和析构函数时，编译器提供了vec_new() vec_delete()之类的函数来统一做构造和析构</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> *vec_new(<span class=\"keyword\">void</span> *<span class=\"keyword\">array</span>,<span class=\"comment\">//数组起始地址</span></span><br><span class=\"line\">      size_t elem_size,<span class=\"keyword\">int</span> elem_count,<span class=\"comment\">//对象大小和数组对象个数</span></span><br><span class=\"line\">      <span class=\"keyword\">void</span> (*constructor)(*<span class=\"keyword\">void</span>)</span><br><span class=\"line\">      <span class=\"keyword\">void</span>(*destructor)(*<span class=\"keyword\">void</span>)</span><br><span class=\"line\">      而实际上调用时：</span><br><span class=\"line\">      Point knots[<span class=\"number\">10</span>]</span><br><span class=\"line\">      <span class=\"comment\">//可能是这样调用，delete类似</span></span><br><span class=\"line\">      vec_new(&amp;knnots,<span class=\"keyword\">sizeof</span>(Point),<span class=\"number\">10</span>,&amp;Point::Point,<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>而如果程序员额外调用了其中一些元素的构造函数，则：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point knots[<span class=\"number\">10</span>]=&#123;Point(),Point(<span class=\"number\">1.8</span>,<span class=\"number\">2.1</span>,<span class=\"number\">0.2</span>),<span class=\"number\">-1.9</span>&#125;;</span><br><span class=\"line\">类似这样，则可能会明确的初始化前三个元素，后面的其他则用vec_new</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>默认构造函数和数组</li>\n</ul>\n<h4 id=\"new和delete运算符\"><a href=\"#new和delete运算符\" class=\"headerlink\" title=\"new和delete运算符\"></a>new和delete运算符</h4><p>上述是针对对象的，new和delete是针对指针的；</p>\n<ul>\n<li>本质上调用malloc函数和free函数,编译器解析new，delete会安插构造函数和解构函数<br>new 的实际过程：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对内建类型</span><br><span class=\"line\"><span class=\"keyword\">int</span> *pi=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">//1 调用函数库的new:_new </span></span><br><span class=\"line\"><span class=\"comment\">//int *pi=_new(sizeof(int));</span></span><br><span class=\"line\"><span class=\"comment\">//2 设置初值：*pi=5;</span></span><br><span class=\"line\"><span class=\"comment\">//或加条件：</span></span><br><span class=\"line\">(<span class=\"keyword\">int</span>  *pi ; <span class=\"keyword\">if</span>(pi=_new(...))*pi=<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">//delete类似；</span></span><br><span class=\"line\">对对象：</span><br><span class=\"line\">Point3d *origin =<span class=\"keyword\">new</span> Point3d;</span><br><span class=\"line\">转换为：</span><br><span class=\"line\">Point3d *origin;</span><br><span class=\"line\"><span class=\"comment\">//伪代码</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(origin =_new(<span class=\"keyword\">sizeof</span>(Point3d))</span><br><span class=\"line\">origin=Pointed::Point3d(origin)<span class=\"comment\">//注意这里会调用构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> origin;</span><br><span class=\"line\">转换为：</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!origin !=<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//伪代码</span></span><br><span class=\"line\">Point3d::~Point3d(origin);</span><br><span class=\"line\">_delete(origin);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">而<span class=\"keyword\">new</span> 一般由<span class=\"built_in\">malloc</span>实现，<span class=\"keyword\">delete</span>由<span class=\"built_in\">free</span>实现；</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"keyword\">operator</span> <span class=\"keyword\">new</span>(<span class=\"keyword\">size_t</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (size =<span class=\"number\">0</span>)</span><br><span class=\"line\">    size=<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> *last_alloc</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!(last_alloc=<span class=\"built_in\">malloc</span>(size)))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(_new_handle)</span><br><span class=\"line\">   (*_new_handle)();</span><br><span class=\"line\">   <span class=\"keyword\">else</span> </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> last_alloc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>针对数组的new和delete<br>实际上的new数组，若不存在构造函数，则只会做new的运算符函数：int <em>parray=(</em>int)_new(5*sizeof(int));<br>待续，略复杂。。。</li>\n<li>placement operator new的语意-——new的重载；</li>\n</ul>\n<h4 id=\"影响c-效率因素之一—临时性对象\"><a href=\"#影响c-效率因素之一—临时性对象\" class=\"headerlink\" title=\"影响c++效率因素之一—临时性对象\"></a>影响c++效率因素之一—临时性对象</h4><ul>\n<li><p>为什么需要临时性对象<br>临时性对象是影响程序效率和引入bug的来源之一；</p>\n<ul>\n<li><p>隐式的类型转换需要临时性对象：<br>当用内建类型写下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">....</span><br><span class=\"line\">a=b+c;<span class=\"comment\">//内建类型将算出的值赋给a</span></span><br><span class=\"line\"><span class=\"comment\">//想象一下如果此时a,b,c都是对象，b+c返回一个对象呢？</span></span><br><span class=\"line\">在c++中操作符运算本质上也是函数，则这里单纯靠b+c返回</span><br><span class=\"line\">一个对象的值赋值给a已经不现实了，对象是一个结构性的</span><br><span class=\"line\">变量；所以在这种情况下就需要构建一个临时性对象，并将</span><br><span class=\"line\">此临时性对象（函数的结果）利用赋值函数拷贝给a;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>单纯传入对象作为函数参数时，即使不返回对象，也会产生临时性对象，为什么? 随意写了个例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"number\">1</span> <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\">    <span class=\"number\">2</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">    <span class=\"number\">3</span>         <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"number\">4</span>                 <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"number\">5</span>                 Point()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"constructor\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; a=<span class=\"number\">4</span>;&#125;</span><br><span class=\"line\">    <span class=\"number\">6</span>                 <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printa</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"number\">32</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">    <span class=\"number\">7</span>                 ~Point()&#123;</span><br><span class=\"line\">    <span class=\"number\">8</span>                         <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"~destrucot\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">9</span>                Point(<span class=\"keyword\">const</span> Point&amp; p)</span><br><span class=\"line\">   <span class=\"number\">10</span>                &#123;</span><br><span class=\"line\">   <span class=\"number\">11</span>                                 <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Copy Constructor\"</span> &lt;&lt; <span class=\"built_in\">std</span>::en      dl;</span><br><span class=\"line\">   <span class=\"number\">12</span>                &#125;</span><br><span class=\"line\">   <span class=\"number\">13</span> </span><br><span class=\"line\">&gt;&gt; <span class=\"number\">14</span>               Point&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Point&amp; p)</span><br><span class=\"line\">   <span class=\"number\">15</span>               &#123;</span><br><span class=\"line\">   <span class=\"number\">16</span>                  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Assign\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"number\">17</span>                  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">   <span class=\"number\">18</span>               &#125;</span><br><span class=\"line\">   <span class=\"number\">19</span> </span><br><span class=\"line\">   <span class=\"number\">20</span> &#125;;</span><br><span class=\"line\">   <span class=\"number\">21</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getv</span><span class=\"params\">(<span class=\"keyword\">const</span> Point pp)</span></span></span><br><span class=\"line\"><span class=\"function\">   22 </span>&#123;</span><br><span class=\"line\">   <span class=\"number\">23</span>     <span class=\"comment\">//= pp.a=6;</span></span><br><span class=\"line\">   <span class=\"number\">24</span>         pp.printa();</span><br><span class=\"line\">   <span class=\"number\">25</span>         <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;pp.a&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"number\">26</span> &#125;</span><br><span class=\"line\">   <span class=\"number\">27</span> </span><br><span class=\"line\">   <span class=\"number\">28</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   29 </span>&#123;</span><br><span class=\"line\">   <span class=\"number\">30</span>         Point pplist;</span><br><span class=\"line\">   <span class=\"number\">31</span>         <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;pplist.a&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"number\">32</span>         getv(pplist);<span class=\"comment\">//这里产生临时对象是调用拷贝构造函数</span></span><br><span class=\"line\">   <span class=\"number\">33</span>         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"number\">34</span> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>按照内建类型来看，传入函数参数，其实传入的是值，<br>而对于对象来说，若传入的是引用或指针则不需要产生临时性对象，但是传入的若是值，则c++编译器需要产生一个临时性对象，在函数的栈中，供函数中对该对象调用函数和值等操作；</p>\n<ul>\n<li><p>函数返回对象；</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">另一个例子：</span><br><span class=\"line\">   如何做X xxx=bar();如何拷贝的？双阶段初始化：</span><br><span class=\"line\"> a 增加一个额外的引用参数给函数，如void bar(X＆　_result)</span><br><span class=\"line\"> b 在return 前插入一个<span class=\"keyword\">copy</span> <span class=\"function\"><span class=\"keyword\">constructor</span> </span></span><br><span class=\"line\"><span class=\"function\">     <span class=\"title\">void</span> <span class=\"title\">bar</span><span class=\"params\">(X &amp;__result)</span><span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">               X xx;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">               xx.X::X();</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">               __result.X::XX(xx);</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">               return ;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">       &#125;</span></span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"title\">X</span> <span class=\"title\">xxx</span>=<span class=\"title\">bar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   //-&gt;<span class=\"title\">bar</span><span class=\"params\">(X &amp;__result)</span>;</span></span><br><span class=\"line\">       xxx=_result;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>手动调用构造函数：此时也会生成临时性对象；</p>\n</li>\n<li>其他如通过构造函数调用成员函数的：单纯一个表达式 a+b这种的</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tmpclass</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    tmpclass(<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmpclass()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmpclass(<span class=\"number\">0</span>);<span class=\"comment\">//手动调用构造函数会产生临时对象，临时对象的a=0,故最后结果show还是无初值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    tmpclass c;</span><br><span class=\"line\">    c.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">其他：</span><br><span class=\"line\"> tmpclass c1 = tmpclass(<span class=\"number\">6</span>);<span class=\"comment\">//赋值构造+构造函数</span></span><br><span class=\"line\"> tmpclass(<span class=\"number\">6</span>).show()<span class=\"comment\">//产生临时性对象；</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>如何避免产生临时性对象<br>尽量不用上述的手法编程</li>\n<li>临时性对象的效率（迷思，测试)<br>临时性对象会造成效率低下，在不当的代码下容易产生很多临时性对象；不当的使用也会造成非预期的结果；</li>\n<li>临时性对象的生命周期：<br>可能是这个表达式的生命周期，具体可以通过构造类函数和析构函数调试；</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"c-执行期语意学\"><a href=\"#c-执行期语意学\" class=\"headerlink\" title=\"c++ 执行期语意学\"></a>c++ 执行期语意学</h3><h4 id=\"执行期和编译期的理解\"><a href=\"#执行期和编译期的理解\" class=\"headerlink\" title=\"执行期和编译期的理解\"></a>执行期和编译期的理解</h4><ul>\n<li>执行期：此时是对已经编译等生成的可执行文件装载到内存并调用cpu将其作为一个进程执行的过程，对c.c++来说程序的入口为main,即第一条指令是执行main函数开始的，而c++可能会加入一些额外的代码，所以实际写的第一条语句和执行的第一条语句可能有偏差；","more":"</li>\n<li>在执行的过程，是程序代码运行的过程，可以想象为工厂开始生产，此时需要空间来运行，需要生产线，产品，工人，工人们走来走去搬运物品等；对程序的运行而言，此时主要的活动空间为栈和堆，即在栈和堆分配空间，而流程制式就是代码段，静态变量的数据区可以比喻为整个工厂共有的数据等；　这个过程中栈会被不断生成消失，堆也是，承载他们的是内存对应的区域；执行完后就从内存消失；</li>\n<li>　编译期，就像生孩子之前的扫描，检查，看看语法对不对，添加额外的内容(c++).生成对应的汇编代码和二进制代码，而程序员需要尽力　编译出高效，整洁，可读等特性的代码，就像这个过程中通过调理，吃合适的东西等；尽可能避开一些坑和耗时的行为le.</li>\n<li>　这部分的内容并不涉及太多执行期的，而更多的是编译器在编译代码时做了什么手脚<h4 id=\"c-中的运算符函数和运算符语法糖\"><a href=\"#c-中的运算符函数和运算符语法糖\" class=\"headerlink\" title=\"c++中的运算符函数和运算符语法糖\"></a>c++中的运算符函数和运算符语法糖</h4></li>\n<li><p>运算符被编译器转换为运算符函数<br>操作符函数例子–&gt;到临时对象的产生和销毁带来的效率问题<br>–&gt;如何在程序中尽量避免产生临时变量和调用析构函数<br>例子：  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X xx;</span><br><span class=\"line\">Y yy;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(yy==xx.getvalue()) ``` </span><br><span class=\"line\">其中涉及到yy的==运算符函数和xx的getvalue函数，前者为：  </span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> Y&amp;) <span class=\"keyword\">const</span>后者为X getvalue()  　　</span><br><span class=\"line\">yy==xx.getvalue()被转换为yy.<span class=\"keyword\">operator</span>==(xx.getvalue),显然类型不相符；  </span><br><span class=\"line\">而此时若X有函数<span class=\"keyword\">operator</span> Y()<span class=\"keyword\">const</span>;<span class=\"comment\">//conversion运算符，则进一步转换为：  </span></span><br><span class=\"line\">     yy.<span class=\"keyword\">operator</span>==(xx.getvalue.<span class=\"keyword\">operator</span> Y())  </span><br><span class=\"line\"> 这行代码看上去是这样简单，但是实际上需要产生中间变量，转为伪代码:  </span><br><span class=\"line\">   X　tmp1=xx.getvalue;<span class=\"comment\">//放返回值  </span></span><br><span class=\"line\">   Y tmp2=tmp1.<span class=\"keyword\">operator</span> Y()<span class=\"comment\">//同上  </span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> tmp3=yy.<span class=\"keyword\">operator</span>==(tmp2);<span class=\"comment\">//放置返回值  </span></span><br><span class=\"line\">   总共产生三个临时变量，而且还得析构，麻烦效率低  </span><br><span class=\"line\">   (注意，上述的为什么不能直接连锁调用?因为返回的是值而不是指针，思考<span class=\"keyword\">this</span>指针的连锁操作，<span class=\"built_in\">cout</span>的连锁操作，个人思考，应该是因为返回的是指针，上述返回的是值，所以无法用值调用下面的函数）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### 对象的构造和解构</span><br><span class=\"line\">+ 构造函数在哪里被安插:  </span><br><span class=\"line\">构造函数在编译时，由编译器在合适的地方安插，一般情况下，正如我们想像的一样：在定义对象时会执行构造函数,解构在对象销毁时;</span><br><span class=\"line\"><span class=\"comment\">//c++伪代码  </span></span><br><span class=\"line\">```cpp</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   Point point ;</span><br><span class=\"line\">   <span class=\"comment\">//point.Point::Point() 一般而言会被安插在这里</span></span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"comment\">//point.Point::~Point() 一般而言会被安插在这里</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解构函数在哪里被安插:<br>1、解构函数的安插需要考虑程序的退出时间（或者某个代码块的退出时间，在可能退出的地方都要加解构函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  Point point;</span><br><span class=\"line\">  <span class=\"comment\">//constructor here</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"keyword\">int</span> (point.x()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">-1</span>:</span><br><span class=\"line\">    <span class=\"comment\">//mumble;</span></span><br><span class=\"line\">    <span class=\"comment\">//destructor here</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"comment\">//mumble;</span></span><br><span class=\"line\">    <span class=\"comment\">//destructor here</span></span><br><span class=\"line\">    ....</span><br><span class=\"line\">    <span class=\"keyword\">default</span> :</span><br><span class=\"line\">      <span class=\"comment\">//mumble</span></span><br><span class=\"line\">      <span class=\"comment\">//destructor here</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    destructor here</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>解构代码应该在任何可能退出代码块的地方，return等，switch,if，goto等都会使加上解构函数的调用以避免出现退出但是还没有执行析构函数的尴尬；</li>\n<li><p>而在如下例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(cache)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">   Point xx;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(xx.get()==<span class=\"number\">1</span>)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   和</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     Point xx;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(cache）</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p> 前者不需要在if(cache）的return 前加解构和　构造函数，而后者需要，显然后者综合效率更差些；<br> 所以设计c++代码时候需要考虑，尽量在使用它的附近定义它</p>\n</li>\n<li><p>对特殊情况的考虑–全局对象的构造函数和解构函数的安插，有特殊的处理<br>“前面看到的是正常的局部情况，现在考虑的是全局对象，定义在main外面，它的构造函数被安插在哪里，什么时候执行?”<br>考虑以下例子：  </p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Matrix</span> identity;</span><br><span class=\"line\"> main ()</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//identity 必须在这里被初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">Matrix</span> m1=identity;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p> 很明显，c++ 必须保证第一次用到identity把他构造出来而在main结束前销毁它；对全局对象而言，有构造函数和析构函数时，称为静态的初始化和内存释放操作；<br> 全局对象和全局变量一样被放在数据段(data segment),在c中，可以在编译期间给定全局变量常量值，而c++中的全局对象需要程序激活后才能执行构造函数给初值；相当于给全局对象做静态初始化；</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例如,cfront在执行前，加入_main来初始化各种全局对象；</span></span><br><span class=\"line\"><span class=\"comment\">//sti_xxx---static initialization</span></span><br><span class=\"line\"> int main()</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">    <span class=\"variable\">_main</span>();---(<span class=\"variable\">_sti_xxx</span>(); <span class=\"variable\">_sti_xxx</span>();,,,)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"variable\">_exit</span>()---(<span class=\"variable\">_std_xxx</span>()....)</span><br><span class=\"line\">    <span class=\"comment\">//而在结束时调用他们的析构函数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    但是需要收集程序中各个对象文件的<span class=\"variable\">_sti</span>函数和<span class=\"variable\">_std</span>函数，此时可以用nm命令，即它会倾倒出符号表项目，nm会施加到.o文件上；搜寻<span class=\"variable\">_sti</span> <span class=\"variable\">_std</span>开头的函数；最后总结整理出来；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对特殊情况的考虑–局部静态对象<br>考虑局部静态对象只会构造一次和销毁一次，却是可能调用多次包含定义局部静态对象的函数，如何保证只会构造一次和销毁一次呢?</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">const</span> Matrix&amp;</span><br><span class=\"line\"> identify() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Matrix mat_identify;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mat_identify;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//1\\首先要保证在调用该函数才初始化局部静态变量，</span></span><br><span class=\"line\"><span class=\"comment\">//2、其次，保证多次调用该函数不会重复初始化对象；</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>简单的说，解决方案就是用一个标志变量，当已经初始化一次局部静态变量就置为真；</p>\n<ul>\n<li>对象数组什么时候构造和解构?<br>考虑一下定义了一个对象数组，之后未做任何改动，要取其中的值，会在定义数组的时候也初始化数组中每一个对象（即调用构造函数)吗？<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">      Point ()&#123;a=<span class=\"number\">3</span>;&#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">Point knot[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;knot[<span class=\"number\">3</span>].a;<span class=\"comment\">//会打印3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当这种对象数组没有默认构造函数和析构函数，则定义时和内置类型相同，只需配置足够的内存保存即可；<br>而当对象有构造函数和析构函数时，编译器提供了vec_new() vec_delete()之类的函数来统一做构造和析构</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> *vec_new(<span class=\"keyword\">void</span> *<span class=\"keyword\">array</span>,<span class=\"comment\">//数组起始地址</span></span><br><span class=\"line\">      size_t elem_size,<span class=\"keyword\">int</span> elem_count,<span class=\"comment\">//对象大小和数组对象个数</span></span><br><span class=\"line\">      <span class=\"keyword\">void</span> (*constructor)(*<span class=\"keyword\">void</span>)</span><br><span class=\"line\">      <span class=\"keyword\">void</span>(*destructor)(*<span class=\"keyword\">void</span>)</span><br><span class=\"line\">      而实际上调用时：</span><br><span class=\"line\">      Point knots[<span class=\"number\">10</span>]</span><br><span class=\"line\">      <span class=\"comment\">//可能是这样调用，delete类似</span></span><br><span class=\"line\">      vec_new(&amp;knnots,<span class=\"keyword\">sizeof</span>(Point),<span class=\"number\">10</span>,&amp;Point::Point,<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>而如果程序员额外调用了其中一些元素的构造函数，则：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point knots[<span class=\"number\">10</span>]=&#123;Point(),Point(<span class=\"number\">1.8</span>,<span class=\"number\">2.1</span>,<span class=\"number\">0.2</span>),<span class=\"number\">-1.9</span>&#125;;</span><br><span class=\"line\">类似这样，则可能会明确的初始化前三个元素，后面的其他则用vec_new</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>默认构造函数和数组</li>\n</ul>\n<h4 id=\"new和delete运算符\"><a href=\"#new和delete运算符\" class=\"headerlink\" title=\"new和delete运算符\"></a>new和delete运算符</h4><p>上述是针对对象的，new和delete是针对指针的；</p>\n<ul>\n<li>本质上调用malloc函数和free函数,编译器解析new，delete会安插构造函数和解构函数<br>new 的实际过程：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对内建类型</span><br><span class=\"line\"><span class=\"keyword\">int</span> *pi=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">//1 调用函数库的new:_new </span></span><br><span class=\"line\"><span class=\"comment\">//int *pi=_new(sizeof(int));</span></span><br><span class=\"line\"><span class=\"comment\">//2 设置初值：*pi=5;</span></span><br><span class=\"line\"><span class=\"comment\">//或加条件：</span></span><br><span class=\"line\">(<span class=\"keyword\">int</span>  *pi ; <span class=\"keyword\">if</span>(pi=_new(...))*pi=<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">//delete类似；</span></span><br><span class=\"line\">对对象：</span><br><span class=\"line\">Point3d *origin =<span class=\"keyword\">new</span> Point3d;</span><br><span class=\"line\">转换为：</span><br><span class=\"line\">Point3d *origin;</span><br><span class=\"line\"><span class=\"comment\">//伪代码</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(origin =_new(<span class=\"keyword\">sizeof</span>(Point3d))</span><br><span class=\"line\">origin=Pointed::Point3d(origin)<span class=\"comment\">//注意这里会调用构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> origin;</span><br><span class=\"line\">转换为：</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!origin !=<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//伪代码</span></span><br><span class=\"line\">Point3d::~Point3d(origin);</span><br><span class=\"line\">_delete(origin);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">而<span class=\"keyword\">new</span> 一般由<span class=\"built_in\">malloc</span>实现，<span class=\"keyword\">delete</span>由<span class=\"built_in\">free</span>实现；</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"keyword\">operator</span> <span class=\"keyword\">new</span>(<span class=\"keyword\">size_t</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (size =<span class=\"number\">0</span>)</span><br><span class=\"line\">    size=<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> *last_alloc</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!(last_alloc=<span class=\"built_in\">malloc</span>(size)))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(_new_handle)</span><br><span class=\"line\">   (*_new_handle)();</span><br><span class=\"line\">   <span class=\"keyword\">else</span> </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> last_alloc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>针对数组的new和delete<br>实际上的new数组，若不存在构造函数，则只会做new的运算符函数：int <em>parray=(</em>int)_new(5*sizeof(int));<br>待续，略复杂。。。</li>\n<li>placement operator new的语意-——new的重载；</li>\n</ul>\n<h4 id=\"影响c-效率因素之一—临时性对象\"><a href=\"#影响c-效率因素之一—临时性对象\" class=\"headerlink\" title=\"影响c++效率因素之一—临时性对象\"></a>影响c++效率因素之一—临时性对象</h4><ul>\n<li><p>为什么需要临时性对象<br>临时性对象是影响程序效率和引入bug的来源之一；</p>\n<ul>\n<li><p>隐式的类型转换需要临时性对象：<br>当用内建类型写下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">....</span><br><span class=\"line\">a=b+c;<span class=\"comment\">//内建类型将算出的值赋给a</span></span><br><span class=\"line\"><span class=\"comment\">//想象一下如果此时a,b,c都是对象，b+c返回一个对象呢？</span></span><br><span class=\"line\">在c++中操作符运算本质上也是函数，则这里单纯靠b+c返回</span><br><span class=\"line\">一个对象的值赋值给a已经不现实了，对象是一个结构性的</span><br><span class=\"line\">变量；所以在这种情况下就需要构建一个临时性对象，并将</span><br><span class=\"line\">此临时性对象（函数的结果）利用赋值函数拷贝给a;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>单纯传入对象作为函数参数时，即使不返回对象，也会产生临时性对象，为什么? 随意写了个例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"number\">1</span> <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\">    <span class=\"number\">2</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">    <span class=\"number\">3</span>         <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"number\">4</span>                 <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"number\">5</span>                 Point()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"constructor\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; a=<span class=\"number\">4</span>;&#125;</span><br><span class=\"line\">    <span class=\"number\">6</span>                 <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printa</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;a&lt;&lt;<span class=\"number\">32</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">    <span class=\"number\">7</span>                 ~Point()&#123;</span><br><span class=\"line\">    <span class=\"number\">8</span>                         <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"~destrucot\"</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">9</span>                Point(<span class=\"keyword\">const</span> Point&amp; p)</span><br><span class=\"line\">   <span class=\"number\">10</span>                &#123;</span><br><span class=\"line\">   <span class=\"number\">11</span>                                 <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Copy Constructor\"</span> &lt;&lt; <span class=\"built_in\">std</span>::en      dl;</span><br><span class=\"line\">   <span class=\"number\">12</span>                &#125;</span><br><span class=\"line\">   <span class=\"number\">13</span> </span><br><span class=\"line\">&gt;&gt; <span class=\"number\">14</span>               Point&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Point&amp; p)</span><br><span class=\"line\">   <span class=\"number\">15</span>               &#123;</span><br><span class=\"line\">   <span class=\"number\">16</span>                  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Assign\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"number\">17</span>                  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">   <span class=\"number\">18</span>               &#125;</span><br><span class=\"line\">   <span class=\"number\">19</span> </span><br><span class=\"line\">   <span class=\"number\">20</span> &#125;;</span><br><span class=\"line\">   <span class=\"number\">21</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getv</span><span class=\"params\">(<span class=\"keyword\">const</span> Point pp)</span></span></span><br><span class=\"line\"><span class=\"function\">   22 </span>&#123;</span><br><span class=\"line\">   <span class=\"number\">23</span>     <span class=\"comment\">//= pp.a=6;</span></span><br><span class=\"line\">   <span class=\"number\">24</span>         pp.printa();</span><br><span class=\"line\">   <span class=\"number\">25</span>         <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;pp.a&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"number\">26</span> &#125;</span><br><span class=\"line\">   <span class=\"number\">27</span> </span><br><span class=\"line\">   <span class=\"number\">28</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   29 </span>&#123;</span><br><span class=\"line\">   <span class=\"number\">30</span>         Point pplist;</span><br><span class=\"line\">   <span class=\"number\">31</span>         <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;pplist.a&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"number\">32</span>         getv(pplist);<span class=\"comment\">//这里产生临时对象是调用拷贝构造函数</span></span><br><span class=\"line\">   <span class=\"number\">33</span>         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"number\">34</span> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>按照内建类型来看，传入函数参数，其实传入的是值，<br>而对于对象来说，若传入的是引用或指针则不需要产生临时性对象，但是传入的若是值，则c++编译器需要产生一个临时性对象，在函数的栈中，供函数中对该对象调用函数和值等操作；</p>\n<ul>\n<li><p>函数返回对象；</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">另一个例子：</span><br><span class=\"line\">   如何做X xxx=bar();如何拷贝的？双阶段初始化：</span><br><span class=\"line\"> a 增加一个额外的引用参数给函数，如void bar(X＆　_result)</span><br><span class=\"line\"> b 在return 前插入一个<span class=\"keyword\">copy</span> <span class=\"function\"><span class=\"keyword\">constructor</span> </span></span><br><span class=\"line\"><span class=\"function\">     <span class=\"title\">void</span> <span class=\"title\">bar</span><span class=\"params\">(X &amp;__result)</span><span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">               X xx;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">               xx.X::X();</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">               __result.X::XX(xx);</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">               return ;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">       &#125;</span></span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"title\">X</span> <span class=\"title\">xxx</span>=<span class=\"title\">bar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   //-&gt;<span class=\"title\">bar</span><span class=\"params\">(X &amp;__result)</span>;</span></span><br><span class=\"line\">       xxx=_result;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>手动调用构造函数：此时也会生成临时性对象；</p>\n</li>\n<li>其他如通过构造函数调用成员函数的：单纯一个表达式 a+b这种的</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tmpclass</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    tmpclass(<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmpclass()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmpclass(<span class=\"number\">0</span>);<span class=\"comment\">//手动调用构造函数会产生临时对象，临时对象的a=0,故最后结果show还是无初值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a = \"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    tmpclass c;</span><br><span class=\"line\">    c.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">其他：</span><br><span class=\"line\"> tmpclass c1 = tmpclass(<span class=\"number\">6</span>);<span class=\"comment\">//赋值构造+构造函数</span></span><br><span class=\"line\"> tmpclass(<span class=\"number\">6</span>).show()<span class=\"comment\">//产生临时性对象；</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>如何避免产生临时性对象<br>尽量不用上述的手法编程</li>\n<li>临时性对象的效率（迷思，测试)<br>临时性对象会造成效率低下，在不当的代码下容易产生很多临时性对象；不当的使用也会造成非预期的结果；</li>\n<li>临时性对象的生命周期：<br>可能是这个表达式的生命周期，具体可以通过构造类函数和析构函数调试；</li>\n</ul>"},{"title":"tcpip_IP","date":"2018-06-03T11:31:27.000Z","_content":"\n### IP 协议和路由\n#### IP的作用--路由\n##### 路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?\n 1. 从广义上讲，路由是路线图，就像百度地图上源地址到目的地址的路线，路线有很多，故路由也很多；  <!--more-->\n   从网络层面讲，路由是一个数据包从源地址到目的地的传输路径，它如何被决定怎么走，即中间经过哪些路由器，选择哪一条路线等等。\n   \n 2. 一个数据包在网络上传输实例：  \n A,B连上AP进行上网，AP和外网连接，AP的下一站是D;  \n A 在构造了数据包后选择发送，要查询路由表，若该数据包发送给B,则通过路由表中的直连路由，找到B的ip,发送时不知道B的mac地址，故先做arp,得到后将数据包发给B:    \n  数据包：源ip：A,源mac A ，目的IP:B,目的mac:B  \n若A在构造了数据包后，查询路由，该数据包是发送给外网，目的地址是百度ip,则无此条目，向默认路由；即发给路由器，此时若不知道mac地址会做arp;  \n数据包：源ip:A,源mac：A  ,目的ip:百度，目的mac：路由器(arp代理）  \n数据包到路由器后，将做下一步转发：  \n在路由发送的数据包：源ip:路由外网地址，源mac:路由，目的ip:百度ip.目的mac,D  \n(注意，在源ip改为路由外网地址后，此时ip唯一，源地址在传输过程中不会再改变）  \n\n 3. 内网的路由器会将源地址改为路由器的外网地址  \n---想想像192.168.0.4这样的源地址是内网地址，如果在包的传输过程中不做处理，到达目的地如QQ的服务器，那QQ处理完要发给你，这时得到包是从192.168.0.4来的，它作为内网地址，全世界很多个，怎么决定-----所以ip首部中的源地址和目的地址必须是全球唯一的ip地址，即外网地址；\n 4. 路由器会对ttl做减1,然后再重新做校验和--即直接加1\n 5. 路由器会将数据包的mac首部，源地址改为路由的mac地址，目的地址改为默认路由（或其他导向路由）ip对应的mac地址\n \n#### 网络地址和子网\n这里不记录太多的ip地址相关的内容，毕竟比较基础，且协议卷或者网上很多介绍\n##### 网络地址简介\n网络地址用来在网络上代表一台设备，就像家庭地址一样，当然现在的设备，如手机可以同时拥有几个ip地址（数据网，wifi，等等，可以理解为家有多个门）  \n而现在的网络地址从32位点分十进制地址，  \n * 决定了它的数量-->一个网络中的设备数量决定了它如何划分网络   \n * 网络中的设备数量动态性，可能很少，ip地址不够用-->子网出现（CIDR)  \n * 网络地址不够用了-->NAT出现，内网  \n\n\n##### 网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?\n---其实本质上，设备间可以通过知道mac地址相互通信，即没有网络的隔离（只要介质支持如wifi,或者有线网下设备能被连在一起)在二层上考虑的    \n + 到了三层，ip层，设备与设备之间的通信，取决于网络的大小，在同一个局域网中，设备间可以直接通信，但是不同局域网，就必须借助路由器，网络，为什么?  \n 首先，考虑他们的距离，若很远，则单纯直连很难，则需要转发，转发单知道mac地址（好吧，假设一开始知道对方的mac地址），很难像现在用ip地址的方式去找到它emm感觉考虑到协议设计了。。。  \n 其次，考虑相邻的不同网络，对应不同的网段，路由表规定了只能和该网络地址范围的主机直接连接，否则就要用默认路由了\n + 考虑这样一个例子：A 在子网192.168.0.0中，地址为192.168.0.3,B在子网10.170.3.0,地址为10.170.3.2,使用wifi,他们之间相邻，此时，A向B发送ARP请求，广播帧，所以B可以接收到，接着B给A回复了响应帧，单波能收到，因为在二层传递，能接收到，不被内核过滤，此时arp表中应该多了条目；接着为了能在三层通信，在路由表中增加一条路由指示不同网段的一个地址，表示他们可以直连，接着测试看看能不能相互发送ip包，ping通，当然可能因为防火墙等；就理论而言，应该是能通的，没试过~-->问题总结：IP地址网段不同的两个设备，一定不能直接通信码?\n+ 网关地址必须是.1结尾码?\n恩当然可以是别的地址\n+ 路由表和路由规则决定了这些\n路由表如何决定了网络的方向，下一跳，和限制了网络范围？\n\n##### IP封包简介\n+ ip封包网上能找到详情，这里记录几个注意点：\n+ 网络字节序的概念，是大端字节序，传输的次序是先0-7bit---最后到24-31这样，所以小端的设备需要线转换为网络字节序再传输\n+ 首部长度字段是指占32bit的数量，有4bit，最大1111*4bytes=60bytes,即ip首部最长为60字节，普通ip同不带选项时是20字节\n+ 服务类型现在已经不怎么用，主要是指在不同服务下拥有不同的最小时延，最大吞吐，最高可靠性的情况，具体见协议卷１图3-2\n+ 总长度，指整个ip数据包的长度，包含首部和数据报，16位，即最大2^16=65535个字节，（考虑超级通道的mtu=65535并非是真正的mtu,而是最长ip数据报），数据报分片时会随着变化\n+ 标示和分片偏移等后面补充\n+ 校验和为ip首部校验和:首先校验和设置为0，接着每个16bit进行反码求和。rfc1071\n\n#### 网络的拓扑结构:\n理论上，网络中的每台设备都能相互通信，即使是点对点通信p2p.但是这要求设备能在网络上被唯一标示，如外网ip地址；\n+ 所以常见的设备A和B的通信借助服务器如：  \n主机A<-->路由器(给主机唯一标识)<-->服务器<-->路由器<-->主机B  \n(现有的大部分通信软件等都是这样的)\n+ 而主机A可以直接和主机B通信不通过服务器吗?  \n答案是可以，我们使用的迅雷，bt,这些下载资源就是利用的各个主机的资源，其结构如何：  \n主机A<-->路由器(做NAPT等)<-->路由器<-->主机B\n那和主机A和B如何在网络上被唯一标示，且被B知道该地址呢?路由器在其中充当什么角色，会做什么限制呢？\n见下NAT和NAT穿透\n#### 路由深入--NAT和NAT穿透\n感谢这两篇文章把我带进门：\nhttps://blog.csdn.net/u012908515/article/details/53518062  \nhttps://blog.csdn.net/ustcgy/article/details/5655050  \nrfc ：nat  \nhttps://tools.ietf.org/html/rfc1631  \nhttps://tools.ietf.org/html/rfc2663\nrfc：p2p  \nhttps://tools.ietf.org/html/rfc5694\n##### NAT的由来\n+ NAT的出现是因为ipv4的地址不够用，所以大量主机在内网使用内网地址，这样在互联网上通信的时候不能被寻找到，此时路由器将内网的设备发送的包中的ip转换为外网的ip,并记录映射在路由器中，这样就能实现主机在互联网上的正常通信，即发包和收包都能找到；\n+ 而这种方式阻碍了不同内网的主机之间的通信，即p2p;\n#### NAT的分类（路由器决定）\n+ 静态NAT:即内网的一个IP对应外网的一个IP，且一一对应，即每次分配的时候都是相同的，永久的\n+ 动态NAT：即内网的一个IP对应外网的一个IP,但是每次分配的外网IP可能不同，映射不同\n+ NAPT:即为了使同一个外网IP能被多个内网的主机使用而出现；\n如何区分各个主机？即路由器发包时和收包时，如收包时，如何确定该包是发给主机A还是B?即用NAPT,IP加端口号的形式来区分  \n+ NAPT分为以下两大类：cone锥形NAT和symmetric 对称NAT\n1. cone NAT的特点是对内网的主机A，和外网所有的服务器通信，都使用相同的端口号；\n如：内网：192.168.4.5:4323-->server:222.33.22.334:80\n则经过路由器：外网ip:122.332.43.32:1234-->server:22...路由器把源地址改为122.332.43.32:1234后发送  \n进过服务器2也是类似的，使用同一个端口1234  \n//这里有个疑问，即内网下相同的ip地址，不同的端口时，经过路由器转换后是否为不同端口   \n考虑在接收服务器回复的内容时:  \n222.33.22.334:80-->122.332.43.32：1234此时路由器根据映射，即端口122.332.43.32：1234对应的是192.168.4.5把目的地址和端口更改为它后发送。所以为了能让包在主机内找到对应端口的程序，路由器的设置应为内网同ip不同端口，映射外网的ip+不同端口（待验证）\n+ 锥形NAT类型：完全锥形full cone和受限锥形( restricted cone) 以及端口受限锥形（port restricted cone)  \n   * 完全锥形：任何知道主机B银蛇在NAT上的外部地址和端口的主机都可以通过它发包给内部主机B,即使A在内网(在内网时通过映射的外网地址）\n   * 受限锥形：只有内部主机B向其发送过包的主机A才能对这个内部主机B发包（通过主机B映射在外部的地址端口）\n   * 端口受限：在受限锥形的基础上加了端口限制\n2. 对称NAT(symmetric nat):\n会为新的session分配新的端口，即和服务器1通信时使用端口1234，接着发起新的服务器2访问时，使用端口1235等  \n如何检测类型？https://blog.csdn.net/u012908515/article/details/53518062\n\n##### ipv6不需要NAT\nipv6地址很多，有人形容世界上的每个沙子都能被定址，所以地址够用，也就不用内网，所以用来做p2p更适用，自然也就不用什么nat转换\n##### p2p网络架构和内网穿透\n基于上面的napt类型介绍，可以知道内网的主机如何和外网的服务器通信，那内网的主机1如何和另一个内网的主机2直接通信?（不借助服务器）  \n答案:基于上面的限制，有几种方案：  \n+ 针对full cone类型的，内网主机2只要知道内网主机1映射到外部的ip地址和端口，就可以直接发送数据包给1，且能接收；\n+ 针对受限的cone类型，内网机2像上面的方式是不行的：得满足两个条件：1是知道主机1映射到外部的ip和端口，2是主机1曾向主机2发送过请求，相当于开了个口，显然这个条件下2为服务器或者有公网ip的设备；所以针对此受限的类型，有一下场景+方案：\n + 场景1：主机1在nat后，打开了和服务器A通信，主机2想和1通信，主机2不在nat后；显然直接向主机1发起请求是不行的，上述条件2不满足，主机1不曾向2发起请求；  \n + 解决方案是，借助服务器A请求主机1做一个反向连接，即向2发起请求，从而打开通道，进而2就可以跟1通信了\n + 场景2：主机1在nat后，主机2在nat后，主机1，2均打开了和服务器A通信，主机1想直接和2通过双方映射到外网的地址端口进行通信 \n + 解决方案：UDP打洞：假如1开始发送一个UDP信息到2的公网地址上,与此同时,他又通过A中转发送了一个邀请信息给2,请求2也给1发送一个UDP信息到1的公网地址上.这时1向2的公网IP发送的信息导致 NAT 1 打开一个处于1的私有地址和2的公网地址之间的新的通信会话,与此同时NAT 2也打开了一个处于2的私有地址和1的公网地址之间的新的通信会话.一旦这个新的UDP会话各自向对方打开了,1和2之间就可以直接通信,而无需A来牵线搭桥了.这就是所谓的打洞技术.一旦这种处于NAT之后的端对端的直连建立之后,连接的双方可以轮流担任对方的\"媒人\",把对方介绍给其他的客户端,这样就极大的降低了服务器A的工作量.\n + 场景3：主机1和2处于同一个NAT下，他们却不知道：\n + 解决方案：综合相同内网下主机可以直接相互通信原理：在主机1发送给A的包中携带其内网地址和端口，A从而知道了1的外网端口地址和内网端口地址，相互都发给1,2，若接着1发起请求给2能收到回复说明在同一个内网，否则采用场景2的解决方案\n + 场景4：主机1处于多层NAT下\n + 问题：udp空闲状态下超时断开的问题：使用心跳包\n + 扩展：tcp的打洞，同时开放tcp连接，原理类似，较复杂\n+ 针对对称性的cone,不定因素多，不建议写\n+ 所以p2p网络即是多个内网主机1,2,3,4等之间的相互直接通信，即他们之间的下载数据可以相互共享，也就是平常说的挂种子，bt下载，也是为什么能达到那么快速的原因;当然可想这个过程和普通的cs架构区别：\n+ p2p架构，bt模型（猜测)：首先客户端负责下载和挂种的基本功能。下载:需要向服务器取得可以获取资源的主机的nat外网地址和ip,接着服务器为其打洞，将正在挂种的客户ip等提供给该客户端，从而能下载；挂种：给服务器声明自己能提供资源，并通过心跳维持一个持续的洞；BT服务器做什么?综合客户端资源和打洞，即让下载方能方访问挂种放 。   这个过程需要考虑：下载方面对多个挂种方，如何下载文件块和组装，最多同时和几个挂种方下载等等；\n+ 回忆：之前学校的rs bt站就是这样，只是开放在学校的内网，可以说是相同nat下的不同主机???好像也不能这么说。。然后采用的原理就是上述的，记得一开始速度不是很快，但是后面15年吧，下载速度能达到10+m/s,很快的，我想可能是优化了下载多个挂种方的方案，增加了最多的下载源，或者学校的网络变优～\n##### Cbitterrot源码分析（待~)\n https://linux.cn/thread-5529-1-1.html\n 对于p2p架构的软件设计，其实跟平常的cs架构很象，都需要用到socket等","source":"_posts/tcpip-IP.md","raw":"---\ntitle: tcpip_IP\ndate: 2018-06-03 19:31:27\ntags: tcpip_ip\ncategories: tcpip\n---\n\n### IP 协议和路由\n#### IP的作用--路由\n##### 路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?\n 1. 从广义上讲，路由是路线图，就像百度地图上源地址到目的地址的路线，路线有很多，故路由也很多；  <!--more-->\n   从网络层面讲，路由是一个数据包从源地址到目的地的传输路径，它如何被决定怎么走，即中间经过哪些路由器，选择哪一条路线等等。\n   \n 2. 一个数据包在网络上传输实例：  \n A,B连上AP进行上网，AP和外网连接，AP的下一站是D;  \n A 在构造了数据包后选择发送，要查询路由表，若该数据包发送给B,则通过路由表中的直连路由，找到B的ip,发送时不知道B的mac地址，故先做arp,得到后将数据包发给B:    \n  数据包：源ip：A,源mac A ，目的IP:B,目的mac:B  \n若A在构造了数据包后，查询路由，该数据包是发送给外网，目的地址是百度ip,则无此条目，向默认路由；即发给路由器，此时若不知道mac地址会做arp;  \n数据包：源ip:A,源mac：A  ,目的ip:百度，目的mac：路由器(arp代理）  \n数据包到路由器后，将做下一步转发：  \n在路由发送的数据包：源ip:路由外网地址，源mac:路由，目的ip:百度ip.目的mac,D  \n(注意，在源ip改为路由外网地址后，此时ip唯一，源地址在传输过程中不会再改变）  \n\n 3. 内网的路由器会将源地址改为路由器的外网地址  \n---想想像192.168.0.4这样的源地址是内网地址，如果在包的传输过程中不做处理，到达目的地如QQ的服务器，那QQ处理完要发给你，这时得到包是从192.168.0.4来的，它作为内网地址，全世界很多个，怎么决定-----所以ip首部中的源地址和目的地址必须是全球唯一的ip地址，即外网地址；\n 4. 路由器会对ttl做减1,然后再重新做校验和--即直接加1\n 5. 路由器会将数据包的mac首部，源地址改为路由的mac地址，目的地址改为默认路由（或其他导向路由）ip对应的mac地址\n \n#### 网络地址和子网\n这里不记录太多的ip地址相关的内容，毕竟比较基础，且协议卷或者网上很多介绍\n##### 网络地址简介\n网络地址用来在网络上代表一台设备，就像家庭地址一样，当然现在的设备，如手机可以同时拥有几个ip地址（数据网，wifi，等等，可以理解为家有多个门）  \n而现在的网络地址从32位点分十进制地址，  \n * 决定了它的数量-->一个网络中的设备数量决定了它如何划分网络   \n * 网络中的设备数量动态性，可能很少，ip地址不够用-->子网出现（CIDR)  \n * 网络地址不够用了-->NAT出现，内网  \n\n\n##### 网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?\n---其实本质上，设备间可以通过知道mac地址相互通信，即没有网络的隔离（只要介质支持如wifi,或者有线网下设备能被连在一起)在二层上考虑的    \n + 到了三层，ip层，设备与设备之间的通信，取决于网络的大小，在同一个局域网中，设备间可以直接通信，但是不同局域网，就必须借助路由器，网络，为什么?  \n 首先，考虑他们的距离，若很远，则单纯直连很难，则需要转发，转发单知道mac地址（好吧，假设一开始知道对方的mac地址），很难像现在用ip地址的方式去找到它emm感觉考虑到协议设计了。。。  \n 其次，考虑相邻的不同网络，对应不同的网段，路由表规定了只能和该网络地址范围的主机直接连接，否则就要用默认路由了\n + 考虑这样一个例子：A 在子网192.168.0.0中，地址为192.168.0.3,B在子网10.170.3.0,地址为10.170.3.2,使用wifi,他们之间相邻，此时，A向B发送ARP请求，广播帧，所以B可以接收到，接着B给A回复了响应帧，单波能收到，因为在二层传递，能接收到，不被内核过滤，此时arp表中应该多了条目；接着为了能在三层通信，在路由表中增加一条路由指示不同网段的一个地址，表示他们可以直连，接着测试看看能不能相互发送ip包，ping通，当然可能因为防火墙等；就理论而言，应该是能通的，没试过~-->问题总结：IP地址网段不同的两个设备，一定不能直接通信码?\n+ 网关地址必须是.1结尾码?\n恩当然可以是别的地址\n+ 路由表和路由规则决定了这些\n路由表如何决定了网络的方向，下一跳，和限制了网络范围？\n\n##### IP封包简介\n+ ip封包网上能找到详情，这里记录几个注意点：\n+ 网络字节序的概念，是大端字节序，传输的次序是先0-7bit---最后到24-31这样，所以小端的设备需要线转换为网络字节序再传输\n+ 首部长度字段是指占32bit的数量，有4bit，最大1111*4bytes=60bytes,即ip首部最长为60字节，普通ip同不带选项时是20字节\n+ 服务类型现在已经不怎么用，主要是指在不同服务下拥有不同的最小时延，最大吞吐，最高可靠性的情况，具体见协议卷１图3-2\n+ 总长度，指整个ip数据包的长度，包含首部和数据报，16位，即最大2^16=65535个字节，（考虑超级通道的mtu=65535并非是真正的mtu,而是最长ip数据报），数据报分片时会随着变化\n+ 标示和分片偏移等后面补充\n+ 校验和为ip首部校验和:首先校验和设置为0，接着每个16bit进行反码求和。rfc1071\n\n#### 网络的拓扑结构:\n理论上，网络中的每台设备都能相互通信，即使是点对点通信p2p.但是这要求设备能在网络上被唯一标示，如外网ip地址；\n+ 所以常见的设备A和B的通信借助服务器如：  \n主机A<-->路由器(给主机唯一标识)<-->服务器<-->路由器<-->主机B  \n(现有的大部分通信软件等都是这样的)\n+ 而主机A可以直接和主机B通信不通过服务器吗?  \n答案是可以，我们使用的迅雷，bt,这些下载资源就是利用的各个主机的资源，其结构如何：  \n主机A<-->路由器(做NAPT等)<-->路由器<-->主机B\n那和主机A和B如何在网络上被唯一标示，且被B知道该地址呢?路由器在其中充当什么角色，会做什么限制呢？\n见下NAT和NAT穿透\n#### 路由深入--NAT和NAT穿透\n感谢这两篇文章把我带进门：\nhttps://blog.csdn.net/u012908515/article/details/53518062  \nhttps://blog.csdn.net/ustcgy/article/details/5655050  \nrfc ：nat  \nhttps://tools.ietf.org/html/rfc1631  \nhttps://tools.ietf.org/html/rfc2663\nrfc：p2p  \nhttps://tools.ietf.org/html/rfc5694\n##### NAT的由来\n+ NAT的出现是因为ipv4的地址不够用，所以大量主机在内网使用内网地址，这样在互联网上通信的时候不能被寻找到，此时路由器将内网的设备发送的包中的ip转换为外网的ip,并记录映射在路由器中，这样就能实现主机在互联网上的正常通信，即发包和收包都能找到；\n+ 而这种方式阻碍了不同内网的主机之间的通信，即p2p;\n#### NAT的分类（路由器决定）\n+ 静态NAT:即内网的一个IP对应外网的一个IP，且一一对应，即每次分配的时候都是相同的，永久的\n+ 动态NAT：即内网的一个IP对应外网的一个IP,但是每次分配的外网IP可能不同，映射不同\n+ NAPT:即为了使同一个外网IP能被多个内网的主机使用而出现；\n如何区分各个主机？即路由器发包时和收包时，如收包时，如何确定该包是发给主机A还是B?即用NAPT,IP加端口号的形式来区分  \n+ NAPT分为以下两大类：cone锥形NAT和symmetric 对称NAT\n1. cone NAT的特点是对内网的主机A，和外网所有的服务器通信，都使用相同的端口号；\n如：内网：192.168.4.5:4323-->server:222.33.22.334:80\n则经过路由器：外网ip:122.332.43.32:1234-->server:22...路由器把源地址改为122.332.43.32:1234后发送  \n进过服务器2也是类似的，使用同一个端口1234  \n//这里有个疑问，即内网下相同的ip地址，不同的端口时，经过路由器转换后是否为不同端口   \n考虑在接收服务器回复的内容时:  \n222.33.22.334:80-->122.332.43.32：1234此时路由器根据映射，即端口122.332.43.32：1234对应的是192.168.4.5把目的地址和端口更改为它后发送。所以为了能让包在主机内找到对应端口的程序，路由器的设置应为内网同ip不同端口，映射外网的ip+不同端口（待验证）\n+ 锥形NAT类型：完全锥形full cone和受限锥形( restricted cone) 以及端口受限锥形（port restricted cone)  \n   * 完全锥形：任何知道主机B银蛇在NAT上的外部地址和端口的主机都可以通过它发包给内部主机B,即使A在内网(在内网时通过映射的外网地址）\n   * 受限锥形：只有内部主机B向其发送过包的主机A才能对这个内部主机B发包（通过主机B映射在外部的地址端口）\n   * 端口受限：在受限锥形的基础上加了端口限制\n2. 对称NAT(symmetric nat):\n会为新的session分配新的端口，即和服务器1通信时使用端口1234，接着发起新的服务器2访问时，使用端口1235等  \n如何检测类型？https://blog.csdn.net/u012908515/article/details/53518062\n\n##### ipv6不需要NAT\nipv6地址很多，有人形容世界上的每个沙子都能被定址，所以地址够用，也就不用内网，所以用来做p2p更适用，自然也就不用什么nat转换\n##### p2p网络架构和内网穿透\n基于上面的napt类型介绍，可以知道内网的主机如何和外网的服务器通信，那内网的主机1如何和另一个内网的主机2直接通信?（不借助服务器）  \n答案:基于上面的限制，有几种方案：  \n+ 针对full cone类型的，内网主机2只要知道内网主机1映射到外部的ip地址和端口，就可以直接发送数据包给1，且能接收；\n+ 针对受限的cone类型，内网机2像上面的方式是不行的：得满足两个条件：1是知道主机1映射到外部的ip和端口，2是主机1曾向主机2发送过请求，相当于开了个口，显然这个条件下2为服务器或者有公网ip的设备；所以针对此受限的类型，有一下场景+方案：\n + 场景1：主机1在nat后，打开了和服务器A通信，主机2想和1通信，主机2不在nat后；显然直接向主机1发起请求是不行的，上述条件2不满足，主机1不曾向2发起请求；  \n + 解决方案是，借助服务器A请求主机1做一个反向连接，即向2发起请求，从而打开通道，进而2就可以跟1通信了\n + 场景2：主机1在nat后，主机2在nat后，主机1，2均打开了和服务器A通信，主机1想直接和2通过双方映射到外网的地址端口进行通信 \n + 解决方案：UDP打洞：假如1开始发送一个UDP信息到2的公网地址上,与此同时,他又通过A中转发送了一个邀请信息给2,请求2也给1发送一个UDP信息到1的公网地址上.这时1向2的公网IP发送的信息导致 NAT 1 打开一个处于1的私有地址和2的公网地址之间的新的通信会话,与此同时NAT 2也打开了一个处于2的私有地址和1的公网地址之间的新的通信会话.一旦这个新的UDP会话各自向对方打开了,1和2之间就可以直接通信,而无需A来牵线搭桥了.这就是所谓的打洞技术.一旦这种处于NAT之后的端对端的直连建立之后,连接的双方可以轮流担任对方的\"媒人\",把对方介绍给其他的客户端,这样就极大的降低了服务器A的工作量.\n + 场景3：主机1和2处于同一个NAT下，他们却不知道：\n + 解决方案：综合相同内网下主机可以直接相互通信原理：在主机1发送给A的包中携带其内网地址和端口，A从而知道了1的外网端口地址和内网端口地址，相互都发给1,2，若接着1发起请求给2能收到回复说明在同一个内网，否则采用场景2的解决方案\n + 场景4：主机1处于多层NAT下\n + 问题：udp空闲状态下超时断开的问题：使用心跳包\n + 扩展：tcp的打洞，同时开放tcp连接，原理类似，较复杂\n+ 针对对称性的cone,不定因素多，不建议写\n+ 所以p2p网络即是多个内网主机1,2,3,4等之间的相互直接通信，即他们之间的下载数据可以相互共享，也就是平常说的挂种子，bt下载，也是为什么能达到那么快速的原因;当然可想这个过程和普通的cs架构区别：\n+ p2p架构，bt模型（猜测)：首先客户端负责下载和挂种的基本功能。下载:需要向服务器取得可以获取资源的主机的nat外网地址和ip,接着服务器为其打洞，将正在挂种的客户ip等提供给该客户端，从而能下载；挂种：给服务器声明自己能提供资源，并通过心跳维持一个持续的洞；BT服务器做什么?综合客户端资源和打洞，即让下载方能方访问挂种放 。   这个过程需要考虑：下载方面对多个挂种方，如何下载文件块和组装，最多同时和几个挂种方下载等等；\n+ 回忆：之前学校的rs bt站就是这样，只是开放在学校的内网，可以说是相同nat下的不同主机???好像也不能这么说。。然后采用的原理就是上述的，记得一开始速度不是很快，但是后面15年吧，下载速度能达到10+m/s,很快的，我想可能是优化了下载多个挂种方的方案，增加了最多的下载源，或者学校的网络变优～\n##### Cbitterrot源码分析（待~)\n https://linux.cn/thread-5529-1-1.html\n 对于p2p架构的软件设计，其实跟平常的cs架构很象，都需要用到socket等","slug":"tcpip-IP","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7r2003h2ujx814tb19f","content":"<h3 id=\"IP-协议和路由\"><a href=\"#IP-协议和路由\" class=\"headerlink\" title=\"IP 协议和路由\"></a>IP 协议和路由</h3><h4 id=\"IP的作用–路由\"><a href=\"#IP的作用–路由\" class=\"headerlink\" title=\"IP的作用–路由\"></a>IP的作用–路由</h4><h5 id=\"路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作\"><a href=\"#路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作\" class=\"headerlink\" title=\"路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?\"></a>路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?</h5><ol>\n<li><p>从广义上讲，路由是路线图，就像百度地图上源地址到目的地址的路线，路线有很多，故路由也很多；  <a id=\"more\"></a><br>从网络层面讲，路由是一个数据包从源地址到目的地的传输路径，它如何被决定怎么走，即中间经过哪些路由器，选择哪一条路线等等。</p>\n</li>\n<li><p>一个数据包在网络上传输实例：<br>A,B连上AP进行上网，AP和外网连接，AP的下一站是D;<br>A 在构造了数据包后选择发送，要查询路由表，若该数据包发送给B,则通过路由表中的直连路由，找到B的ip,发送时不知道B的mac地址，故先做arp,得到后将数据包发给B:<br>数据包：源ip：A,源mac A ，目的IP:B,目的mac:B<br>若A在构造了数据包后，查询路由，该数据包是发送给外网，目的地址是百度ip,则无此条目，向默认路由；即发给路由器，此时若不知道mac地址会做arp;<br>数据包：源ip:A,源mac：A  ,目的ip:百度，目的mac：路由器(arp代理）<br>数据包到路由器后，将做下一步转发：<br>在路由发送的数据包：源ip:路由外网地址，源mac:路由，目的ip:百度ip.目的mac,D<br>(注意，在源ip改为路由外网地址后，此时ip唯一，源地址在传输过程中不会再改变）  </p>\n</li>\n<li><p>内网的路由器会将源地址改为路由器的外网地址<br>—想想像192.168.0.4这样的源地址是内网地址，如果在包的传输过程中不做处理，到达目的地如QQ的服务器，那QQ处理完要发给你，这时得到包是从192.168.0.4来的，它作为内网地址，全世界很多个，怎么决定—–所以ip首部中的源地址和目的地址必须是全球唯一的ip地址，即外网地址；</p>\n</li>\n<li>路由器会对ttl做减1,然后再重新做校验和–即直接加1</li>\n<li>路由器会将数据包的mac首部，源地址改为路由的mac地址，目的地址改为默认路由（或其他导向路由）ip对应的mac地址</li>\n</ol>\n<h4 id=\"网络地址和子网\"><a href=\"#网络地址和子网\" class=\"headerlink\" title=\"网络地址和子网\"></a>网络地址和子网</h4><p>这里不记录太多的ip地址相关的内容，毕竟比较基础，且协议卷或者网上很多介绍</p>\n<h5 id=\"网络地址简介\"><a href=\"#网络地址简介\" class=\"headerlink\" title=\"网络地址简介\"></a>网络地址简介</h5><p>网络地址用来在网络上代表一台设备，就像家庭地址一样，当然现在的设备，如手机可以同时拥有几个ip地址（数据网，wifi，等等，可以理解为家有多个门）<br>而现在的网络地址从32位点分十进制地址，  </p>\n<ul>\n<li>决定了它的数量–&gt;一个网络中的设备数量决定了它如何划分网络   </li>\n<li>网络中的设备数量动态性，可能很少，ip地址不够用–&gt;子网出现（CIDR)  </li>\n<li>网络地址不够用了–&gt;NAT出现，内网  </li>\n</ul>\n<h5 id=\"网段，网络范围内，由谁主导生效进行实际的网络隔离和连接\"><a href=\"#网段，网络范围内，由谁主导生效进行实际的网络隔离和连接\" class=\"headerlink\" title=\"网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?\"></a>网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?</h5><p>—其实本质上，设备间可以通过知道mac地址相互通信，即没有网络的隔离（只要介质支持如wifi,或者有线网下设备能被连在一起)在二层上考虑的    </p>\n<ul>\n<li>到了三层，ip层，设备与设备之间的通信，取决于网络的大小，在同一个局域网中，设备间可以直接通信，但是不同局域网，就必须借助路由器，网络，为什么?<br>首先，考虑他们的距离，若很远，则单纯直连很难，则需要转发，转发单知道mac地址（好吧，假设一开始知道对方的mac地址），很难像现在用ip地址的方式去找到它emm感觉考虑到协议设计了。。。<br>其次，考虑相邻的不同网络，对应不同的网段，路由表规定了只能和该网络地址范围的主机直接连接，否则就要用默认路由了</li>\n<li>考虑这样一个例子：A 在子网192.168.0.0中，地址为192.168.0.3,B在子网10.170.3.0,地址为10.170.3.2,使用wifi,他们之间相邻，此时，A向B发送ARP请求，广播帧，所以B可以接收到，接着B给A回复了响应帧，单波能收到，因为在二层传递，能接收到，不被内核过滤，此时arp表中应该多了条目；接着为了能在三层通信，在路由表中增加一条路由指示不同网段的一个地址，表示他们可以直连，接着测试看看能不能相互发送ip包，ping通，当然可能因为防火墙等；就理论而言，应该是能通的，没试过~–&gt;问题总结：IP地址网段不同的两个设备，一定不能直接通信码?<ul>\n<li>网关地址必须是.1结尾码?<br>恩当然可以是别的地址</li>\n<li>路由表和路由规则决定了这些<br>路由表如何决定了网络的方向，下一跳，和限制了网络范围？</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"IP封包简介\"><a href=\"#IP封包简介\" class=\"headerlink\" title=\"IP封包简介\"></a>IP封包简介</h5><ul>\n<li>ip封包网上能找到详情，这里记录几个注意点：</li>\n<li>网络字节序的概念，是大端字节序，传输的次序是先0-7bit—最后到24-31这样，所以小端的设备需要线转换为网络字节序再传输</li>\n<li>首部长度字段是指占32bit的数量，有4bit，最大1111*4bytes=60bytes,即ip首部最长为60字节，普通ip同不带选项时是20字节</li>\n<li>服务类型现在已经不怎么用，主要是指在不同服务下拥有不同的最小时延，最大吞吐，最高可靠性的情况，具体见协议卷１图3-2</li>\n<li>总长度，指整个ip数据包的长度，包含首部和数据报，16位，即最大2^16=65535个字节，（考虑超级通道的mtu=65535并非是真正的mtu,而是最长ip数据报），数据报分片时会随着变化</li>\n<li>标示和分片偏移等后面补充</li>\n<li>校验和为ip首部校验和:首先校验和设置为0，接着每个16bit进行反码求和。rfc1071</li>\n</ul>\n<h4 id=\"网络的拓扑结构\"><a href=\"#网络的拓扑结构\" class=\"headerlink\" title=\"网络的拓扑结构:\"></a>网络的拓扑结构:</h4><p>理论上，网络中的每台设备都能相互通信，即使是点对点通信p2p.但是这要求设备能在网络上被唯一标示，如外网ip地址；</p>\n<ul>\n<li>所以常见的设备A和B的通信借助服务器如：<br>主机A<-->路由器(给主机唯一标识)<-->服务器<-->路由器<-->主机B<br>(现有的大部分通信软件等都是这样的)</--></--></--></--></li>\n<li>而主机A可以直接和主机B通信不通过服务器吗?<br>答案是可以，我们使用的迅雷，bt,这些下载资源就是利用的各个主机的资源，其结构如何：<br>主机A<-->路由器(做NAPT等)<-->路由器<-->主机B<br>那和主机A和B如何在网络上被唯一标示，且被B知道该地址呢?路由器在其中充当什么角色，会做什么限制呢？<br>见下NAT和NAT穿透<h4 id=\"路由深入–NAT和NAT穿透\"><a href=\"#路由深入–NAT和NAT穿透\" class=\"headerlink\" title=\"路由深入–NAT和NAT穿透\"></a>路由深入–NAT和NAT穿透</h4>感谢这两篇文章把我带进门：<br><a href=\"https://blog.csdn.net/u012908515/article/details/53518062\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012908515/article/details/53518062</a><br><a href=\"https://blog.csdn.net/ustcgy/article/details/5655050\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/ustcgy/article/details/5655050</a><br>rfc ：nat<br><a href=\"https://tools.ietf.org/html/rfc1631\" target=\"_blank\" rel=\"noopener\">https://tools.ietf.org/html/rfc1631</a><br><a href=\"https://tools.ietf.org/html/rfc2663\" target=\"_blank\" rel=\"noopener\">https://tools.ietf.org/html/rfc2663</a><br>rfc：p2p<br><a href=\"https://tools.ietf.org/html/rfc5694\" target=\"_blank\" rel=\"noopener\">https://tools.ietf.org/html/rfc5694</a><h5 id=\"NAT的由来\"><a href=\"#NAT的由来\" class=\"headerlink\" title=\"NAT的由来\"></a>NAT的由来</h5></--></--></--></li>\n<li>NAT的出现是因为ipv4的地址不够用，所以大量主机在内网使用内网地址，这样在互联网上通信的时候不能被寻找到，此时路由器将内网的设备发送的包中的ip转换为外网的ip,并记录映射在路由器中，这样就能实现主机在互联网上的正常通信，即发包和收包都能找到；</li>\n<li>而这种方式阻碍了不同内网的主机之间的通信，即p2p;<h4 id=\"NAT的分类（路由器决定）\"><a href=\"#NAT的分类（路由器决定）\" class=\"headerlink\" title=\"NAT的分类（路由器决定）\"></a>NAT的分类（路由器决定）</h4></li>\n<li>静态NAT:即内网的一个IP对应外网的一个IP，且一一对应，即每次分配的时候都是相同的，永久的</li>\n<li>动态NAT：即内网的一个IP对应外网的一个IP,但是每次分配的外网IP可能不同，映射不同</li>\n<li>NAPT:即为了使同一个外网IP能被多个内网的主机使用而出现；<br>如何区分各个主机？即路由器发包时和收包时，如收包时，如何确定该包是发给主机A还是B?即用NAPT,IP加端口号的形式来区分  </li>\n<li>NAPT分为以下两大类：cone锥形NAT和symmetric 对称NAT</li>\n</ul>\n<ol>\n<li>cone NAT的特点是对内网的主机A，和外网所有的服务器通信，都使用相同的端口号；<br>如：内网：192.168.4.5:4323–&gt;server:222.33.22.334:80<br>则经过路由器：外网ip:122.332.43.32:1234–&gt;server:22…路由器把源地址改为122.332.43.32:1234后发送<br>进过服务器2也是类似的，使用同一个端口1234<br>//这里有个疑问，即内网下相同的ip地址，不同的端口时，经过路由器转换后是否为不同端口<br>考虑在接收服务器回复的内容时:<br>222.33.22.334:80–&gt;122.332.43.32：1234此时路由器根据映射，即端口122.332.43.32：1234对应的是192.168.4.5把目的地址和端口更改为它后发送。所以为了能让包在主机内找到对应端口的程序，路由器的设置应为内网同ip不同端口，映射外网的ip+不同端口（待验证）</li>\n</ol>\n<ul>\n<li>锥形NAT类型：完全锥形full cone和受限锥形( restricted cone) 以及端口受限锥形（port restricted cone)  <ul>\n<li>完全锥形：任何知道主机B银蛇在NAT上的外部地址和端口的主机都可以通过它发包给内部主机B,即使A在内网(在内网时通过映射的外网地址）</li>\n<li>受限锥形：只有内部主机B向其发送过包的主机A才能对这个内部主机B发包（通过主机B映射在外部的地址端口）</li>\n<li>端口受限：在受限锥形的基础上加了端口限制</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>对称NAT(symmetric nat):<br>会为新的session分配新的端口，即和服务器1通信时使用端口1234，接着发起新的服务器2访问时，使用端口1235等<br>如何检测类型？<a href=\"https://blog.csdn.net/u012908515/article/details/53518062\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012908515/article/details/53518062</a></li>\n</ol>\n<h5 id=\"ipv6不需要NAT\"><a href=\"#ipv6不需要NAT\" class=\"headerlink\" title=\"ipv6不需要NAT\"></a>ipv6不需要NAT</h5><p>ipv6地址很多，有人形容世界上的每个沙子都能被定址，所以地址够用，也就不用内网，所以用来做p2p更适用，自然也就不用什么nat转换</p>\n<h5 id=\"p2p网络架构和内网穿透\"><a href=\"#p2p网络架构和内网穿透\" class=\"headerlink\" title=\"p2p网络架构和内网穿透\"></a>p2p网络架构和内网穿透</h5><p>基于上面的napt类型介绍，可以知道内网的主机如何和外网的服务器通信，那内网的主机1如何和另一个内网的主机2直接通信?（不借助服务器）<br>答案:基于上面的限制，有几种方案：  </p>\n<ul>\n<li>针对full cone类型的，内网主机2只要知道内网主机1映射到外部的ip地址和端口，就可以直接发送数据包给1，且能接收；</li>\n<li>针对受限的cone类型，内网机2像上面的方式是不行的：得满足两个条件：1是知道主机1映射到外部的ip和端口，2是主机1曾向主机2发送过请求，相当于开了个口，显然这个条件下2为服务器或者有公网ip的设备；所以针对此受限的类型，有一下场景+方案：<ul>\n<li>场景1：主机1在nat后，打开了和服务器A通信，主机2想和1通信，主机2不在nat后；显然直接向主机1发起请求是不行的，上述条件2不满足，主机1不曾向2发起请求；  </li>\n<li>解决方案是，借助服务器A请求主机1做一个反向连接，即向2发起请求，从而打开通道，进而2就可以跟1通信了</li>\n<li>场景2：主机1在nat后，主机2在nat后，主机1，2均打开了和服务器A通信，主机1想直接和2通过双方映射到外网的地址端口进行通信 </li>\n<li>解决方案：UDP打洞：假如1开始发送一个UDP信息到2的公网地址上,与此同时,他又通过A中转发送了一个邀请信息给2,请求2也给1发送一个UDP信息到1的公网地址上.这时1向2的公网IP发送的信息导致 NAT 1 打开一个处于1的私有地址和2的公网地址之间的新的通信会话,与此同时NAT 2也打开了一个处于2的私有地址和1的公网地址之间的新的通信会话.一旦这个新的UDP会话各自向对方打开了,1和2之间就可以直接通信,而无需A来牵线搭桥了.这就是所谓的打洞技术.一旦这种处于NAT之后的端对端的直连建立之后,连接的双方可以轮流担任对方的”媒人”,把对方介绍给其他的客户端,这样就极大的降低了服务器A的工作量.</li>\n<li>场景3：主机1和2处于同一个NAT下，他们却不知道：</li>\n<li>解决方案：综合相同内网下主机可以直接相互通信原理：在主机1发送给A的包中携带其内网地址和端口，A从而知道了1的外网端口地址和内网端口地址，相互都发给1,2，若接着1发起请求给2能收到回复说明在同一个内网，否则采用场景2的解决方案</li>\n<li>场景4：主机1处于多层NAT下</li>\n<li>问题：udp空闲状态下超时断开的问题：使用心跳包</li>\n<li>扩展：tcp的打洞，同时开放tcp连接，原理类似，较复杂</li>\n</ul>\n</li>\n<li>针对对称性的cone,不定因素多，不建议写</li>\n<li>所以p2p网络即是多个内网主机1,2,3,4等之间的相互直接通信，即他们之间的下载数据可以相互共享，也就是平常说的挂种子，bt下载，也是为什么能达到那么快速的原因;当然可想这个过程和普通的cs架构区别：</li>\n<li>p2p架构，bt模型（猜测)：首先客户端负责下载和挂种的基本功能。下载:需要向服务器取得可以获取资源的主机的nat外网地址和ip,接着服务器为其打洞，将正在挂种的客户ip等提供给该客户端，从而能下载；挂种：给服务器声明自己能提供资源，并通过心跳维持一个持续的洞；BT服务器做什么?综合客户端资源和打洞，即让下载方能方访问挂种放 。   这个过程需要考虑：下载方面对多个挂种方，如何下载文件块和组装，最多同时和几个挂种方下载等等；</li>\n<li>回忆：之前学校的rs bt站就是这样，只是开放在学校的内网，可以说是相同nat下的不同主机???好像也不能这么说。。然后采用的原理就是上述的，记得一开始速度不是很快，但是后面15年吧，下载速度能达到10+m/s,很快的，我想可能是优化了下载多个挂种方的方案，增加了最多的下载源，或者学校的网络变优～<h5 id=\"Cbitterrot源码分析（待\"><a href=\"#Cbitterrot源码分析（待\" class=\"headerlink\" title=\"Cbitterrot源码分析（待~)\"></a>Cbitterrot源码分析（待~)</h5><a href=\"https://linux.cn/thread-5529-1-1.html\" target=\"_blank\" rel=\"noopener\">https://linux.cn/thread-5529-1-1.html</a><br>对于p2p架构的软件设计，其实跟平常的cs架构很象，都需要用到socket等</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"IP-协议和路由\"><a href=\"#IP-协议和路由\" class=\"headerlink\" title=\"IP 协议和路由\"></a>IP 协议和路由</h3><h4 id=\"IP的作用–路由\"><a href=\"#IP的作用–路由\" class=\"headerlink\" title=\"IP的作用–路由\"></a>IP的作用–路由</h4><h5 id=\"路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作\"><a href=\"#路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作\" class=\"headerlink\" title=\"路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?\"></a>路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?</h5><ol>\n<li><p>从广义上讲，路由是路线图，就像百度地图上源地址到目的地址的路线，路线有很多，故路由也很多；","more":"<br>从网络层面讲，路由是一个数据包从源地址到目的地的传输路径，它如何被决定怎么走，即中间经过哪些路由器，选择哪一条路线等等。</p>\n</li>\n<li><p>一个数据包在网络上传输实例：<br>A,B连上AP进行上网，AP和外网连接，AP的下一站是D;<br>A 在构造了数据包后选择发送，要查询路由表，若该数据包发送给B,则通过路由表中的直连路由，找到B的ip,发送时不知道B的mac地址，故先做arp,得到后将数据包发给B:<br>数据包：源ip：A,源mac A ，目的IP:B,目的mac:B<br>若A在构造了数据包后，查询路由，该数据包是发送给外网，目的地址是百度ip,则无此条目，向默认路由；即发给路由器，此时若不知道mac地址会做arp;<br>数据包：源ip:A,源mac：A  ,目的ip:百度，目的mac：路由器(arp代理）<br>数据包到路由器后，将做下一步转发：<br>在路由发送的数据包：源ip:路由外网地址，源mac:路由，目的ip:百度ip.目的mac,D<br>(注意，在源ip改为路由外网地址后，此时ip唯一，源地址在传输过程中不会再改变）  </p>\n</li>\n<li><p>内网的路由器会将源地址改为路由器的外网地址<br>—想想像192.168.0.4这样的源地址是内网地址，如果在包的传输过程中不做处理，到达目的地如QQ的服务器，那QQ处理完要发给你，这时得到包是从192.168.0.4来的，它作为内网地址，全世界很多个，怎么决定—–所以ip首部中的源地址和目的地址必须是全球唯一的ip地址，即外网地址；</p>\n</li>\n<li>路由器会对ttl做减1,然后再重新做校验和–即直接加1</li>\n<li>路由器会将数据包的mac首部，源地址改为路由的mac地址，目的地址改为默认路由（或其他导向路由）ip对应的mac地址</li>\n</ol>\n<h4 id=\"网络地址和子网\"><a href=\"#网络地址和子网\" class=\"headerlink\" title=\"网络地址和子网\"></a>网络地址和子网</h4><p>这里不记录太多的ip地址相关的内容，毕竟比较基础，且协议卷或者网上很多介绍</p>\n<h5 id=\"网络地址简介\"><a href=\"#网络地址简介\" class=\"headerlink\" title=\"网络地址简介\"></a>网络地址简介</h5><p>网络地址用来在网络上代表一台设备，就像家庭地址一样，当然现在的设备，如手机可以同时拥有几个ip地址（数据网，wifi，等等，可以理解为家有多个门）<br>而现在的网络地址从32位点分十进制地址，  </p>\n<ul>\n<li>决定了它的数量–&gt;一个网络中的设备数量决定了它如何划分网络   </li>\n<li>网络中的设备数量动态性，可能很少，ip地址不够用–&gt;子网出现（CIDR)  </li>\n<li>网络地址不够用了–&gt;NAT出现，内网  </li>\n</ul>\n<h5 id=\"网段，网络范围内，由谁主导生效进行实际的网络隔离和连接\"><a href=\"#网段，网络范围内，由谁主导生效进行实际的网络隔离和连接\" class=\"headerlink\" title=\"网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?\"></a>网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?</h5><p>—其实本质上，设备间可以通过知道mac地址相互通信，即没有网络的隔离（只要介质支持如wifi,或者有线网下设备能被连在一起)在二层上考虑的    </p>\n<ul>\n<li>到了三层，ip层，设备与设备之间的通信，取决于网络的大小，在同一个局域网中，设备间可以直接通信，但是不同局域网，就必须借助路由器，网络，为什么?<br>首先，考虑他们的距离，若很远，则单纯直连很难，则需要转发，转发单知道mac地址（好吧，假设一开始知道对方的mac地址），很难像现在用ip地址的方式去找到它emm感觉考虑到协议设计了。。。<br>其次，考虑相邻的不同网络，对应不同的网段，路由表规定了只能和该网络地址范围的主机直接连接，否则就要用默认路由了</li>\n<li>考虑这样一个例子：A 在子网192.168.0.0中，地址为192.168.0.3,B在子网10.170.3.0,地址为10.170.3.2,使用wifi,他们之间相邻，此时，A向B发送ARP请求，广播帧，所以B可以接收到，接着B给A回复了响应帧，单波能收到，因为在二层传递，能接收到，不被内核过滤，此时arp表中应该多了条目；接着为了能在三层通信，在路由表中增加一条路由指示不同网段的一个地址，表示他们可以直连，接着测试看看能不能相互发送ip包，ping通，当然可能因为防火墙等；就理论而言，应该是能通的，没试过~–&gt;问题总结：IP地址网段不同的两个设备，一定不能直接通信码?<ul>\n<li>网关地址必须是.1结尾码?<br>恩当然可以是别的地址</li>\n<li>路由表和路由规则决定了这些<br>路由表如何决定了网络的方向，下一跳，和限制了网络范围？</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"IP封包简介\"><a href=\"#IP封包简介\" class=\"headerlink\" title=\"IP封包简介\"></a>IP封包简介</h5><ul>\n<li>ip封包网上能找到详情，这里记录几个注意点：</li>\n<li>网络字节序的概念，是大端字节序，传输的次序是先0-7bit—最后到24-31这样，所以小端的设备需要线转换为网络字节序再传输</li>\n<li>首部长度字段是指占32bit的数量，有4bit，最大1111*4bytes=60bytes,即ip首部最长为60字节，普通ip同不带选项时是20字节</li>\n<li>服务类型现在已经不怎么用，主要是指在不同服务下拥有不同的最小时延，最大吞吐，最高可靠性的情况，具体见协议卷１图3-2</li>\n<li>总长度，指整个ip数据包的长度，包含首部和数据报，16位，即最大2^16=65535个字节，（考虑超级通道的mtu=65535并非是真正的mtu,而是最长ip数据报），数据报分片时会随着变化</li>\n<li>标示和分片偏移等后面补充</li>\n<li>校验和为ip首部校验和:首先校验和设置为0，接着每个16bit进行反码求和。rfc1071</li>\n</ul>\n<h4 id=\"网络的拓扑结构\"><a href=\"#网络的拓扑结构\" class=\"headerlink\" title=\"网络的拓扑结构:\"></a>网络的拓扑结构:</h4><p>理论上，网络中的每台设备都能相互通信，即使是点对点通信p2p.但是这要求设备能在网络上被唯一标示，如外网ip地址；</p>\n<ul>\n<li>所以常见的设备A和B的通信借助服务器如：<br>主机A<-->路由器(给主机唯一标识)<-->服务器<-->路由器<-->主机B<br>(现有的大部分通信软件等都是这样的)</--></--></--></--></li>\n<li>而主机A可以直接和主机B通信不通过服务器吗?<br>答案是可以，我们使用的迅雷，bt,这些下载资源就是利用的各个主机的资源，其结构如何：<br>主机A<-->路由器(做NAPT等)<-->路由器<-->主机B<br>那和主机A和B如何在网络上被唯一标示，且被B知道该地址呢?路由器在其中充当什么角色，会做什么限制呢？<br>见下NAT和NAT穿透<h4 id=\"路由深入–NAT和NAT穿透\"><a href=\"#路由深入–NAT和NAT穿透\" class=\"headerlink\" title=\"路由深入–NAT和NAT穿透\"></a>路由深入–NAT和NAT穿透</h4>感谢这两篇文章把我带进门：<br><a href=\"https://blog.csdn.net/u012908515/article/details/53518062\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012908515/article/details/53518062</a><br><a href=\"https://blog.csdn.net/ustcgy/article/details/5655050\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/ustcgy/article/details/5655050</a><br>rfc ：nat<br><a href=\"https://tools.ietf.org/html/rfc1631\" target=\"_blank\" rel=\"noopener\">https://tools.ietf.org/html/rfc1631</a><br><a href=\"https://tools.ietf.org/html/rfc2663\" target=\"_blank\" rel=\"noopener\">https://tools.ietf.org/html/rfc2663</a><br>rfc：p2p<br><a href=\"https://tools.ietf.org/html/rfc5694\" target=\"_blank\" rel=\"noopener\">https://tools.ietf.org/html/rfc5694</a><h5 id=\"NAT的由来\"><a href=\"#NAT的由来\" class=\"headerlink\" title=\"NAT的由来\"></a>NAT的由来</h5></--></--></--></li>\n<li>NAT的出现是因为ipv4的地址不够用，所以大量主机在内网使用内网地址，这样在互联网上通信的时候不能被寻找到，此时路由器将内网的设备发送的包中的ip转换为外网的ip,并记录映射在路由器中，这样就能实现主机在互联网上的正常通信，即发包和收包都能找到；</li>\n<li>而这种方式阻碍了不同内网的主机之间的通信，即p2p;<h4 id=\"NAT的分类（路由器决定）\"><a href=\"#NAT的分类（路由器决定）\" class=\"headerlink\" title=\"NAT的分类（路由器决定）\"></a>NAT的分类（路由器决定）</h4></li>\n<li>静态NAT:即内网的一个IP对应外网的一个IP，且一一对应，即每次分配的时候都是相同的，永久的</li>\n<li>动态NAT：即内网的一个IP对应外网的一个IP,但是每次分配的外网IP可能不同，映射不同</li>\n<li>NAPT:即为了使同一个外网IP能被多个内网的主机使用而出现；<br>如何区分各个主机？即路由器发包时和收包时，如收包时，如何确定该包是发给主机A还是B?即用NAPT,IP加端口号的形式来区分  </li>\n<li>NAPT分为以下两大类：cone锥形NAT和symmetric 对称NAT</li>\n</ul>\n<ol>\n<li>cone NAT的特点是对内网的主机A，和外网所有的服务器通信，都使用相同的端口号；<br>如：内网：192.168.4.5:4323–&gt;server:222.33.22.334:80<br>则经过路由器：外网ip:122.332.43.32:1234–&gt;server:22…路由器把源地址改为122.332.43.32:1234后发送<br>进过服务器2也是类似的，使用同一个端口1234<br>//这里有个疑问，即内网下相同的ip地址，不同的端口时，经过路由器转换后是否为不同端口<br>考虑在接收服务器回复的内容时:<br>222.33.22.334:80–&gt;122.332.43.32：1234此时路由器根据映射，即端口122.332.43.32：1234对应的是192.168.4.5把目的地址和端口更改为它后发送。所以为了能让包在主机内找到对应端口的程序，路由器的设置应为内网同ip不同端口，映射外网的ip+不同端口（待验证）</li>\n</ol>\n<ul>\n<li>锥形NAT类型：完全锥形full cone和受限锥形( restricted cone) 以及端口受限锥形（port restricted cone)  <ul>\n<li>完全锥形：任何知道主机B银蛇在NAT上的外部地址和端口的主机都可以通过它发包给内部主机B,即使A在内网(在内网时通过映射的外网地址）</li>\n<li>受限锥形：只有内部主机B向其发送过包的主机A才能对这个内部主机B发包（通过主机B映射在外部的地址端口）</li>\n<li>端口受限：在受限锥形的基础上加了端口限制</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>对称NAT(symmetric nat):<br>会为新的session分配新的端口，即和服务器1通信时使用端口1234，接着发起新的服务器2访问时，使用端口1235等<br>如何检测类型？<a href=\"https://blog.csdn.net/u012908515/article/details/53518062\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012908515/article/details/53518062</a></li>\n</ol>\n<h5 id=\"ipv6不需要NAT\"><a href=\"#ipv6不需要NAT\" class=\"headerlink\" title=\"ipv6不需要NAT\"></a>ipv6不需要NAT</h5><p>ipv6地址很多，有人形容世界上的每个沙子都能被定址，所以地址够用，也就不用内网，所以用来做p2p更适用，自然也就不用什么nat转换</p>\n<h5 id=\"p2p网络架构和内网穿透\"><a href=\"#p2p网络架构和内网穿透\" class=\"headerlink\" title=\"p2p网络架构和内网穿透\"></a>p2p网络架构和内网穿透</h5><p>基于上面的napt类型介绍，可以知道内网的主机如何和外网的服务器通信，那内网的主机1如何和另一个内网的主机2直接通信?（不借助服务器）<br>答案:基于上面的限制，有几种方案：  </p>\n<ul>\n<li>针对full cone类型的，内网主机2只要知道内网主机1映射到外部的ip地址和端口，就可以直接发送数据包给1，且能接收；</li>\n<li>针对受限的cone类型，内网机2像上面的方式是不行的：得满足两个条件：1是知道主机1映射到外部的ip和端口，2是主机1曾向主机2发送过请求，相当于开了个口，显然这个条件下2为服务器或者有公网ip的设备；所以针对此受限的类型，有一下场景+方案：<ul>\n<li>场景1：主机1在nat后，打开了和服务器A通信，主机2想和1通信，主机2不在nat后；显然直接向主机1发起请求是不行的，上述条件2不满足，主机1不曾向2发起请求；  </li>\n<li>解决方案是，借助服务器A请求主机1做一个反向连接，即向2发起请求，从而打开通道，进而2就可以跟1通信了</li>\n<li>场景2：主机1在nat后，主机2在nat后，主机1，2均打开了和服务器A通信，主机1想直接和2通过双方映射到外网的地址端口进行通信 </li>\n<li>解决方案：UDP打洞：假如1开始发送一个UDP信息到2的公网地址上,与此同时,他又通过A中转发送了一个邀请信息给2,请求2也给1发送一个UDP信息到1的公网地址上.这时1向2的公网IP发送的信息导致 NAT 1 打开一个处于1的私有地址和2的公网地址之间的新的通信会话,与此同时NAT 2也打开了一个处于2的私有地址和1的公网地址之间的新的通信会话.一旦这个新的UDP会话各自向对方打开了,1和2之间就可以直接通信,而无需A来牵线搭桥了.这就是所谓的打洞技术.一旦这种处于NAT之后的端对端的直连建立之后,连接的双方可以轮流担任对方的”媒人”,把对方介绍给其他的客户端,这样就极大的降低了服务器A的工作量.</li>\n<li>场景3：主机1和2处于同一个NAT下，他们却不知道：</li>\n<li>解决方案：综合相同内网下主机可以直接相互通信原理：在主机1发送给A的包中携带其内网地址和端口，A从而知道了1的外网端口地址和内网端口地址，相互都发给1,2，若接着1发起请求给2能收到回复说明在同一个内网，否则采用场景2的解决方案</li>\n<li>场景4：主机1处于多层NAT下</li>\n<li>问题：udp空闲状态下超时断开的问题：使用心跳包</li>\n<li>扩展：tcp的打洞，同时开放tcp连接，原理类似，较复杂</li>\n</ul>\n</li>\n<li>针对对称性的cone,不定因素多，不建议写</li>\n<li>所以p2p网络即是多个内网主机1,2,3,4等之间的相互直接通信，即他们之间的下载数据可以相互共享，也就是平常说的挂种子，bt下载，也是为什么能达到那么快速的原因;当然可想这个过程和普通的cs架构区别：</li>\n<li>p2p架构，bt模型（猜测)：首先客户端负责下载和挂种的基本功能。下载:需要向服务器取得可以获取资源的主机的nat外网地址和ip,接着服务器为其打洞，将正在挂种的客户ip等提供给该客户端，从而能下载；挂种：给服务器声明自己能提供资源，并通过心跳维持一个持续的洞；BT服务器做什么?综合客户端资源和打洞，即让下载方能方访问挂种放 。   这个过程需要考虑：下载方面对多个挂种方，如何下载文件块和组装，最多同时和几个挂种方下载等等；</li>\n<li>回忆：之前学校的rs bt站就是这样，只是开放在学校的内网，可以说是相同nat下的不同主机???好像也不能这么说。。然后采用的原理就是上述的，记得一开始速度不是很快，但是后面15年吧，下载速度能达到10+m/s,很快的，我想可能是优化了下载多个挂种方的方案，增加了最多的下载源，或者学校的网络变优～<h5 id=\"Cbitterrot源码分析（待\"><a href=\"#Cbitterrot源码分析（待\" class=\"headerlink\" title=\"Cbitterrot源码分析（待~)\"></a>Cbitterrot源码分析（待~)</h5><a href=\"https://linux.cn/thread-5529-1-1.html\" target=\"_blank\" rel=\"noopener\">https://linux.cn/thread-5529-1-1.html</a><br>对于p2p架构的软件设计，其实跟平常的cs架构很象，都需要用到socket等</li>\n</ul>"},{"title":"tcpip_MAC","date":"2018-06-03T04:29:48.000Z","_content":"### mac数据链路层的理解  \n#### mac层的功能介绍 \nmac层在理论上赋予了较全的功能，但是其实，实际上在使用的时候，由于无噪声通道，或者一些功能交给了上层的协议，所以实际的mac功能没有理论那么全面。mac层的实现包括在驱动和固件中，所以实际的功能得看芯片和固件的支持，比如是否支持监听模式；  <!--more-->\n理论上：建议书籍《数据通信与网络》  \n寻址：实际的端到端通信，都是需要先知到对方的mac地址(通过arp),才能进行实际传输的；  \n帧构建：这一层结束后就是完成了包封装，下一步传送给物理层编码发送了；   \n数据差错检查；传送控制，流量控制，差错控制，编码，校验和等等；，编码是指在原始数据mac封包后，在实际传输时进行编码（按照某个80x协议等，这个属于偏物理层的事情了）  \n实际上：数据差错检查，流量控制，差错控制等都没做，或者要看具体的厂商实现如高通，mtk等\n#### mac层的传输限制 \n 考虑一个包从电脑发出去，最后一次封包根据接口不同(有线，无线),协议不同，采用的mac头也不同，如ppp协议要加其他信息；  \n -->简述:接着可能发给无线路由器或者交换机，路由器会判断是wifi的mac头，接着要向以太网传输时，或者无线传输时，需要去掉mac头，并加上自己的mac头，改变mac源地址为自己，目的地址为(路由表对应)arp寻找的下一跳mac地址;若为以太网，还要转换为以太网的头类型等\n ...  \n 整个过程，从物理层角度看，是可以顺利进行的，但是实际为了效率，不接受无用的包，不发送无效的包和安全等，在驱动和固件都会有做相应的过滤处理，从而使发包收包，转发包等受到了限制，见下实验等；\n#### mac层的封包,mtu,msdu,mpdu  \n在包的封装上，有线网和无线网不同，更确切的是协议不同，其mac层封包也不同--对相同的ip包(ip头+上层数据/arp/...）带有不同的mac头：  \n例如对以太网（有线）：常见有一下四种mac头封装的帧：\n+ EthernetII:  dest addr+src addr+type+data+fcs\n+ Ethernet 802.2:dest addr+srcaddr+len+ llc+data+fcs\n+ Ethernet 802.3:dest addr+src addr+len+data+fcs \n+ Ethernet SNAP:dest addr+src addr+len+llc+snap+data+fcs\n参考：https://blog.csdn.net/xiao628945/article/details/8006022\n针对无线网络：802.11n等，更复杂些：\n+ 802.11头+msdu(数据部分)+fcs(crc)  \n而802.11wifi无线帧分为控制帧，管理帧和数据帧，因为在无线网络中的安全性等考虑，需要扫描，关联，认证四次握手等步骤,在802.11头就包含了subtype，即数据部分是什么类型（控制，。。）https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末  \nhttps://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了   \n这么多的封包类型，除却ip层只有一种，那在传递的过程中如何处理?即有线到无线，怎么识别?答案是在路由器，主机中进行去头和加头  \n不同厂商实现不同，在无线中，非数据帧部分：底层的实现分为full mac driver（Full Mac的Driver，一般Auth和Assoc的包直接在芯片里边处理了，Driver通过command形式告诉Firmware要连接AP的信息，Firmware处理了Assoc Response之后，report给Driver一个Event，说明连接的情况（result和AID）以及assoc相关的IE，Driver会直接调用cfg80211的接口报告给supplicant，然后处理EAPOL的握手过程，因为之后的EAPOL Data的处理会用到Assoc Response里边的IE）  而用soft mac则软件可以控制较多的事情(Soft Mac模块开源代码mac80211的WiFi芯片，会将这两种包送到Mac80211处理，mac80211处理完后调用cfg80211的接口通过nl80211(netlink)通知wpa_supplicant准备认证以及四次握手的状态机，等待处理EAPOL包，EAPOL是二层的Data包，会在Supplicant里边处理，连接加密的路由情况就是这样处理的，如果不加密，那就直接DHCP了)；扯远了。。\n在pc等设备中，在封装到数据链路层时，封装时用的是ethernetII，到底层驱动时就被替换为对应的802.11的头了，进而发送出去，而在接收数据包的时候，底层上报上来又会把802.11格式的转换为ehternetII的形式，所以我在实验wifi的时候，用的PF_PACKET来操作数据包，加的是ethernetII的头，接收到打印出来后还是ethernetII的头  \n晒张空中包的和本地tcpdump抓到的包对比：  \n//to do\n\n\n当然除却mac头的不同，mtu的概念还是存在:\nmac层在传输时一次传输一帧，这一帧即是封装了mac头的数据包，它常为[46-1500]+mac头,而mtu即是最大的传输单元，是去掉mac头的负载部分最大值，如1500    \n而在实际传输的空中包，情况又可能不同，这里看msdu 和mpdu:\nhttps://blog.csdn.net/zhengnice/article/details/51923132\n这篇文章讲的很好，在理解了上述的内容后，看这篇文章里面的msdu和mpdu就能很好的理解了，spec的416页也有相关的内容\n\n##### mac头格式：不同协议可能不同：\n常见：dest addr,src addr ,proto type; 14byte\n见上文\n#### mac层的发包和收包限制  \n考虑一个问题，即在不考虑网络网段的情况下，两台设备在开启wifi或者连接网线的情况下，能相互直接通信吗？  \n从理论上是可以的，首先是发送，无问题，接收，可以接收；其次，接收之后解码，需要双方使用相同的编码协议等；  \n其次：实际上，需要几个条件，且有线和无线的方式不同：\n+ 有线：需要双方相同的编码，直连的情况下，可以直接通信；\n+ 无线: (分为数据部分和管理部分，需要双方相同的编码)，但是仅开启wifi，只能接收小量信息的beacon帧；即wifi为了安全性，效率等(wifi本身可以接收所有数据），做了连接前的扫描，关联认证，四次握手等过程，并且对mac地址进行过滤，使不同网段的两个相邻设备不能通过直接发送接收mac层数据来交互；具体见厂商的实现，可以参考实验部分；  \n+ 所以关键看厂商怎么实现，底层的东西，他们提供接口给你，你就能操作了balalal\n##### 普通模式，混杂模式和监听模式\n#### mac层的几个实验\n普通模式下，wifi实验，以station架构进行：  \n设备A，B,路由器C，D;  \n+ A,B连接同一个路由器C,A,B通过PF_PACKET发送和接收mac头加任意数据，成功发送接收，即使arp表无对方的条目  \n+ A,B都不连接wifi,只是打开wifi，此时无法发送和接收数据，厂商默认的只会发送主动扫苗和接收beacon帧，扫描的具体过程待文章写,在没有连接上时，只会发送小数据\n+ A,B间任意设备连上路由器，同上\n+ _A连接路由C,B连接路由D,相互发送和接收mac头加任意数据，目的地址为对方mac，源地址为自己的mac---失败，其实一开始是怀着疑问的，从理论分析是可以的，但是还是不行，若只是在二层的话，对方怎么知道这个源mac地址是在不同网段并做过滤?难道发之前，底层进行了隐式arp？但是我发的包里面没有带ip信息啊，同时进行了广播帧的发送接收，还是失败了；应该都是出在接收的环节；也有可能是两个ap使用的协议不同导致编码方式不同从而接收失败_\n+ 考虑到可能是两个路由器编码和使用的协议如一个是802.11n,一个是ac，等，可能导致接收不到，所以可以再尝试使用两个相同的型号的路由器；//待测试\n+ 发送方普通模式，接收方监听模式，接收方可以收到所有包，所以可以接收到\n\n#### openwrt开源路由系统，驱动，固件\n了解一下。。。\nspec:Wireless LAN Medium Access Control\n(MAC)\nand Physical Layer (PHY) Specifications","source":"_posts/tcpip-MAC.md","raw":"---\ntitle: tcpip_MAC\ndate: 2018-06-03 12:29:48\ntags: tcpip_mac\ncategories: tcpip\n---\n### mac数据链路层的理解  \n#### mac层的功能介绍 \nmac层在理论上赋予了较全的功能，但是其实，实际上在使用的时候，由于无噪声通道，或者一些功能交给了上层的协议，所以实际的mac功能没有理论那么全面。mac层的实现包括在驱动和固件中，所以实际的功能得看芯片和固件的支持，比如是否支持监听模式；  <!--more-->\n理论上：建议书籍《数据通信与网络》  \n寻址：实际的端到端通信，都是需要先知到对方的mac地址(通过arp),才能进行实际传输的；  \n帧构建：这一层结束后就是完成了包封装，下一步传送给物理层编码发送了；   \n数据差错检查；传送控制，流量控制，差错控制，编码，校验和等等；，编码是指在原始数据mac封包后，在实际传输时进行编码（按照某个80x协议等，这个属于偏物理层的事情了）  \n实际上：数据差错检查，流量控制，差错控制等都没做，或者要看具体的厂商实现如高通，mtk等\n#### mac层的传输限制 \n 考虑一个包从电脑发出去，最后一次封包根据接口不同(有线，无线),协议不同，采用的mac头也不同，如ppp协议要加其他信息；  \n -->简述:接着可能发给无线路由器或者交换机，路由器会判断是wifi的mac头，接着要向以太网传输时，或者无线传输时，需要去掉mac头，并加上自己的mac头，改变mac源地址为自己，目的地址为(路由表对应)arp寻找的下一跳mac地址;若为以太网，还要转换为以太网的头类型等\n ...  \n 整个过程，从物理层角度看，是可以顺利进行的，但是实际为了效率，不接受无用的包，不发送无效的包和安全等，在驱动和固件都会有做相应的过滤处理，从而使发包收包，转发包等受到了限制，见下实验等；\n#### mac层的封包,mtu,msdu,mpdu  \n在包的封装上，有线网和无线网不同，更确切的是协议不同，其mac层封包也不同--对相同的ip包(ip头+上层数据/arp/...）带有不同的mac头：  \n例如对以太网（有线）：常见有一下四种mac头封装的帧：\n+ EthernetII:  dest addr+src addr+type+data+fcs\n+ Ethernet 802.2:dest addr+srcaddr+len+ llc+data+fcs\n+ Ethernet 802.3:dest addr+src addr+len+data+fcs \n+ Ethernet SNAP:dest addr+src addr+len+llc+snap+data+fcs\n参考：https://blog.csdn.net/xiao628945/article/details/8006022\n针对无线网络：802.11n等，更复杂些：\n+ 802.11头+msdu(数据部分)+fcs(crc)  \n而802.11wifi无线帧分为控制帧，管理帧和数据帧，因为在无线网络中的安全性等考虑，需要扫描，关联，认证四次握手等步骤,在802.11头就包含了subtype，即数据部分是什么类型（控制，。。）https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末  \nhttps://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了   \n这么多的封包类型，除却ip层只有一种，那在传递的过程中如何处理?即有线到无线，怎么识别?答案是在路由器，主机中进行去头和加头  \n不同厂商实现不同，在无线中，非数据帧部分：底层的实现分为full mac driver（Full Mac的Driver，一般Auth和Assoc的包直接在芯片里边处理了，Driver通过command形式告诉Firmware要连接AP的信息，Firmware处理了Assoc Response之后，report给Driver一个Event，说明连接的情况（result和AID）以及assoc相关的IE，Driver会直接调用cfg80211的接口报告给supplicant，然后处理EAPOL的握手过程，因为之后的EAPOL Data的处理会用到Assoc Response里边的IE）  而用soft mac则软件可以控制较多的事情(Soft Mac模块开源代码mac80211的WiFi芯片，会将这两种包送到Mac80211处理，mac80211处理完后调用cfg80211的接口通过nl80211(netlink)通知wpa_supplicant准备认证以及四次握手的状态机，等待处理EAPOL包，EAPOL是二层的Data包，会在Supplicant里边处理，连接加密的路由情况就是这样处理的，如果不加密，那就直接DHCP了)；扯远了。。\n在pc等设备中，在封装到数据链路层时，封装时用的是ethernetII，到底层驱动时就被替换为对应的802.11的头了，进而发送出去，而在接收数据包的时候，底层上报上来又会把802.11格式的转换为ehternetII的形式，所以我在实验wifi的时候，用的PF_PACKET来操作数据包，加的是ethernetII的头，接收到打印出来后还是ethernetII的头  \n晒张空中包的和本地tcpdump抓到的包对比：  \n//to do\n\n\n当然除却mac头的不同，mtu的概念还是存在:\nmac层在传输时一次传输一帧，这一帧即是封装了mac头的数据包，它常为[46-1500]+mac头,而mtu即是最大的传输单元，是去掉mac头的负载部分最大值，如1500    \n而在实际传输的空中包，情况又可能不同，这里看msdu 和mpdu:\nhttps://blog.csdn.net/zhengnice/article/details/51923132\n这篇文章讲的很好，在理解了上述的内容后，看这篇文章里面的msdu和mpdu就能很好的理解了，spec的416页也有相关的内容\n\n##### mac头格式：不同协议可能不同：\n常见：dest addr,src addr ,proto type; 14byte\n见上文\n#### mac层的发包和收包限制  \n考虑一个问题，即在不考虑网络网段的情况下，两台设备在开启wifi或者连接网线的情况下，能相互直接通信吗？  \n从理论上是可以的，首先是发送，无问题，接收，可以接收；其次，接收之后解码，需要双方使用相同的编码协议等；  \n其次：实际上，需要几个条件，且有线和无线的方式不同：\n+ 有线：需要双方相同的编码，直连的情况下，可以直接通信；\n+ 无线: (分为数据部分和管理部分，需要双方相同的编码)，但是仅开启wifi，只能接收小量信息的beacon帧；即wifi为了安全性，效率等(wifi本身可以接收所有数据），做了连接前的扫描，关联认证，四次握手等过程，并且对mac地址进行过滤，使不同网段的两个相邻设备不能通过直接发送接收mac层数据来交互；具体见厂商的实现，可以参考实验部分；  \n+ 所以关键看厂商怎么实现，底层的东西，他们提供接口给你，你就能操作了balalal\n##### 普通模式，混杂模式和监听模式\n#### mac层的几个实验\n普通模式下，wifi实验，以station架构进行：  \n设备A，B,路由器C，D;  \n+ A,B连接同一个路由器C,A,B通过PF_PACKET发送和接收mac头加任意数据，成功发送接收，即使arp表无对方的条目  \n+ A,B都不连接wifi,只是打开wifi，此时无法发送和接收数据，厂商默认的只会发送主动扫苗和接收beacon帧，扫描的具体过程待文章写,在没有连接上时，只会发送小数据\n+ A,B间任意设备连上路由器，同上\n+ _A连接路由C,B连接路由D,相互发送和接收mac头加任意数据，目的地址为对方mac，源地址为自己的mac---失败，其实一开始是怀着疑问的，从理论分析是可以的，但是还是不行，若只是在二层的话，对方怎么知道这个源mac地址是在不同网段并做过滤?难道发之前，底层进行了隐式arp？但是我发的包里面没有带ip信息啊，同时进行了广播帧的发送接收，还是失败了；应该都是出在接收的环节；也有可能是两个ap使用的协议不同导致编码方式不同从而接收失败_\n+ 考虑到可能是两个路由器编码和使用的协议如一个是802.11n,一个是ac，等，可能导致接收不到，所以可以再尝试使用两个相同的型号的路由器；//待测试\n+ 发送方普通模式，接收方监听模式，接收方可以收到所有包，所以可以接收到\n\n#### openwrt开源路由系统，驱动，固件\n了解一下。。。\nspec:Wireless LAN Medium Access Control\n(MAC)\nand Physical Layer (PHY) Specifications","slug":"tcpip-MAC","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7r9003j2ujx6ecxnbgb","content":"<h3 id=\"mac数据链路层的理解\"><a href=\"#mac数据链路层的理解\" class=\"headerlink\" title=\"mac数据链路层的理解\"></a>mac数据链路层的理解</h3><h4 id=\"mac层的功能介绍\"><a href=\"#mac层的功能介绍\" class=\"headerlink\" title=\"mac层的功能介绍\"></a>mac层的功能介绍</h4><p>mac层在理论上赋予了较全的功能，但是其实，实际上在使用的时候，由于无噪声通道，或者一些功能交给了上层的协议，所以实际的mac功能没有理论那么全面。mac层的实现包括在驱动和固件中，所以实际的功能得看芯片和固件的支持，比如是否支持监听模式；  <a id=\"more\"></a><br>理论上：建议书籍《数据通信与网络》<br>寻址：实际的端到端通信，都是需要先知到对方的mac地址(通过arp),才能进行实际传输的；<br>帧构建：这一层结束后就是完成了包封装，下一步传送给物理层编码发送了；<br>数据差错检查；传送控制，流量控制，差错控制，编码，校验和等等；，编码是指在原始数据mac封包后，在实际传输时进行编码（按照某个80x协议等，这个属于偏物理层的事情了）<br>实际上：数据差错检查，流量控制，差错控制等都没做，或者要看具体的厂商实现如高通，mtk等</p>\n<h4 id=\"mac层的传输限制\"><a href=\"#mac层的传输限制\" class=\"headerlink\" title=\"mac层的传输限制\"></a>mac层的传输限制</h4><p> 考虑一个包从电脑发出去，最后一次封包根据接口不同(有线，无线),协议不同，采用的mac头也不同，如ppp协议要加其他信息；<br> –&gt;简述:接着可能发给无线路由器或者交换机，路由器会判断是wifi的mac头，接着要向以太网传输时，或者无线传输时，需要去掉mac头，并加上自己的mac头，改变mac源地址为自己，目的地址为(路由表对应)arp寻找的下一跳mac地址;若为以太网，还要转换为以太网的头类型等<br> …<br> 整个过程，从物理层角度看，是可以顺利进行的，但是实际为了效率，不接受无用的包，不发送无效的包和安全等，在驱动和固件都会有做相应的过滤处理，从而使发包收包，转发包等受到了限制，见下实验等；</p>\n<h4 id=\"mac层的封包-mtu-msdu-mpdu\"><a href=\"#mac层的封包-mtu-msdu-mpdu\" class=\"headerlink\" title=\"mac层的封包,mtu,msdu,mpdu\"></a>mac层的封包,mtu,msdu,mpdu</h4><p>在包的封装上，有线网和无线网不同，更确切的是协议不同，其mac层封包也不同–对相同的ip包(ip头+上层数据/arp/…）带有不同的mac头：<br>例如对以太网（有线）：常见有一下四种mac头封装的帧：</p>\n<ul>\n<li>EthernetII:  dest addr+src addr+type+data+fcs</li>\n<li>Ethernet 802.2:dest addr+srcaddr+len+ llc+data+fcs</li>\n<li>Ethernet 802.3:dest addr+src addr+len+data+fcs </li>\n<li>Ethernet SNAP:dest addr+src addr+len+llc+snap+data+fcs<br>参考：<a href=\"https://blog.csdn.net/xiao628945/article/details/8006022\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xiao628945/article/details/8006022</a><br>针对无线网络：802.11n等，更复杂些：</li>\n<li>802.11头+msdu(数据部分)+fcs(crc)<br>而802.11wifi无线帧分为控制帧，管理帧和数据帧，因为在无线网络中的安全性等考虑，需要扫描，关联，认证四次握手等步骤,在802.11头就包含了subtype，即数据部分是什么类型（控制，。。）<a href=\"https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末</a><br><a href=\"https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了</a><br>这么多的封包类型，除却ip层只有一种，那在传递的过程中如何处理?即有线到无线，怎么识别?答案是在路由器，主机中进行去头和加头<br>不同厂商实现不同，在无线中，非数据帧部分：底层的实现分为full mac driver（Full Mac的Driver，一般Auth和Assoc的包直接在芯片里边处理了，Driver通过command形式告诉Firmware要连接AP的信息，Firmware处理了Assoc Response之后，report给Driver一个Event，说明连接的情况（result和AID）以及assoc相关的IE，Driver会直接调用cfg80211的接口报告给supplicant，然后处理EAPOL的握手过程，因为之后的EAPOL Data的处理会用到Assoc Response里边的IE）  而用soft mac则软件可以控制较多的事情(Soft Mac模块开源代码mac80211的WiFi芯片，会将这两种包送到Mac80211处理，mac80211处理完后调用cfg80211的接口通过nl80211(netlink)通知wpa_supplicant准备认证以及四次握手的状态机，等待处理EAPOL包，EAPOL是二层的Data包，会在Supplicant里边处理，连接加密的路由情况就是这样处理的，如果不加密，那就直接DHCP了)；扯远了。。<br>在pc等设备中，在封装到数据链路层时，封装时用的是ethernetII，到底层驱动时就被替换为对应的802.11的头了，进而发送出去，而在接收数据包的时候，底层上报上来又会把802.11格式的转换为ehternetII的形式，所以我在实验wifi的时候，用的PF_PACKET来操作数据包，加的是ethernetII的头，接收到打印出来后还是ethernetII的头<br>晒张空中包的和本地tcpdump抓到的包对比：<br>//to do</li>\n</ul>\n<p>当然除却mac头的不同，mtu的概念还是存在:<br>mac层在传输时一次传输一帧，这一帧即是封装了mac头的数据包，它常为[46-1500]+mac头,而mtu即是最大的传输单元，是去掉mac头的负载部分最大值，如1500<br>而在实际传输的空中包，情况又可能不同，这里看msdu 和mpdu:<br><a href=\"https://blog.csdn.net/zhengnice/article/details/51923132\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhengnice/article/details/51923132</a><br>这篇文章讲的很好，在理解了上述的内容后，看这篇文章里面的msdu和mpdu就能很好的理解了，spec的416页也有相关的内容</p>\n<h5 id=\"mac头格式：不同协议可能不同：\"><a href=\"#mac头格式：不同协议可能不同：\" class=\"headerlink\" title=\"mac头格式：不同协议可能不同：\"></a>mac头格式：不同协议可能不同：</h5><p>常见：dest addr,src addr ,proto type; 14byte<br>见上文</p>\n<h4 id=\"mac层的发包和收包限制\"><a href=\"#mac层的发包和收包限制\" class=\"headerlink\" title=\"mac层的发包和收包限制\"></a>mac层的发包和收包限制</h4><p>考虑一个问题，即在不考虑网络网段的情况下，两台设备在开启wifi或者连接网线的情况下，能相互直接通信吗？<br>从理论上是可以的，首先是发送，无问题，接收，可以接收；其次，接收之后解码，需要双方使用相同的编码协议等；<br>其次：实际上，需要几个条件，且有线和无线的方式不同：</p>\n<ul>\n<li>有线：需要双方相同的编码，直连的情况下，可以直接通信；</li>\n<li>无线: (分为数据部分和管理部分，需要双方相同的编码)，但是仅开启wifi，只能接收小量信息的beacon帧；即wifi为了安全性，效率等(wifi本身可以接收所有数据），做了连接前的扫描，关联认证，四次握手等过程，并且对mac地址进行过滤，使不同网段的两个相邻设备不能通过直接发送接收mac层数据来交互；具体见厂商的实现，可以参考实验部分；  </li>\n<li>所以关键看厂商怎么实现，底层的东西，他们提供接口给你，你就能操作了balalal<h5 id=\"普通模式，混杂模式和监听模式\"><a href=\"#普通模式，混杂模式和监听模式\" class=\"headerlink\" title=\"普通模式，混杂模式和监听模式\"></a>普通模式，混杂模式和监听模式</h5><h4 id=\"mac层的几个实验\"><a href=\"#mac层的几个实验\" class=\"headerlink\" title=\"mac层的几个实验\"></a>mac层的几个实验</h4>普通模式下，wifi实验，以station架构进行：<br>设备A，B,路由器C，D;  </li>\n<li>A,B连接同一个路由器C,A,B通过PF_PACKET发送和接收mac头加任意数据，成功发送接收，即使arp表无对方的条目  </li>\n<li>A,B都不连接wifi,只是打开wifi，此时无法发送和接收数据，厂商默认的只会发送主动扫苗和接收beacon帧，扫描的具体过程待文章写,在没有连接上时，只会发送小数据</li>\n<li>A,B间任意设备连上路由器，同上</li>\n<li><em>A连接路由C,B连接路由D,相互发送和接收mac头加任意数据，目的地址为对方mac，源地址为自己的mac—失败，其实一开始是怀着疑问的，从理论分析是可以的，但是还是不行，若只是在二层的话，对方怎么知道这个源mac地址是在不同网段并做过滤?难道发之前，底层进行了隐式arp？但是我发的包里面没有带ip信息啊，同时进行了广播帧的发送接收，还是失败了；应该都是出在接收的环节；也有可能是两个ap使用的协议不同导致编码方式不同从而接收失败</em></li>\n<li>考虑到可能是两个路由器编码和使用的协议如一个是802.11n,一个是ac，等，可能导致接收不到，所以可以再尝试使用两个相同的型号的路由器；//待测试</li>\n<li>发送方普通模式，接收方监听模式，接收方可以收到所有包，所以可以接收到</li>\n</ul>\n<h4 id=\"openwrt开源路由系统，驱动，固件\"><a href=\"#openwrt开源路由系统，驱动，固件\" class=\"headerlink\" title=\"openwrt开源路由系统，驱动，固件\"></a>openwrt开源路由系统，驱动，固件</h4><p>了解一下。。。<br>spec:Wireless LAN Medium Access Control<br>(MAC)<br>and Physical Layer (PHY) Specifications</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"mac数据链路层的理解\"><a href=\"#mac数据链路层的理解\" class=\"headerlink\" title=\"mac数据链路层的理解\"></a>mac数据链路层的理解</h3><h4 id=\"mac层的功能介绍\"><a href=\"#mac层的功能介绍\" class=\"headerlink\" title=\"mac层的功能介绍\"></a>mac层的功能介绍</h4><p>mac层在理论上赋予了较全的功能，但是其实，实际上在使用的时候，由于无噪声通道，或者一些功能交给了上层的协议，所以实际的mac功能没有理论那么全面。mac层的实现包括在驱动和固件中，所以实际的功能得看芯片和固件的支持，比如是否支持监听模式；","more":"<br>理论上：建议书籍《数据通信与网络》<br>寻址：实际的端到端通信，都是需要先知到对方的mac地址(通过arp),才能进行实际传输的；<br>帧构建：这一层结束后就是完成了包封装，下一步传送给物理层编码发送了；<br>数据差错检查；传送控制，流量控制，差错控制，编码，校验和等等；，编码是指在原始数据mac封包后，在实际传输时进行编码（按照某个80x协议等，这个属于偏物理层的事情了）<br>实际上：数据差错检查，流量控制，差错控制等都没做，或者要看具体的厂商实现如高通，mtk等</p>\n<h4 id=\"mac层的传输限制\"><a href=\"#mac层的传输限制\" class=\"headerlink\" title=\"mac层的传输限制\"></a>mac层的传输限制</h4><p> 考虑一个包从电脑发出去，最后一次封包根据接口不同(有线，无线),协议不同，采用的mac头也不同，如ppp协议要加其他信息；<br> –&gt;简述:接着可能发给无线路由器或者交换机，路由器会判断是wifi的mac头，接着要向以太网传输时，或者无线传输时，需要去掉mac头，并加上自己的mac头，改变mac源地址为自己，目的地址为(路由表对应)arp寻找的下一跳mac地址;若为以太网，还要转换为以太网的头类型等<br> …<br> 整个过程，从物理层角度看，是可以顺利进行的，但是实际为了效率，不接受无用的包，不发送无效的包和安全等，在驱动和固件都会有做相应的过滤处理，从而使发包收包，转发包等受到了限制，见下实验等；</p>\n<h4 id=\"mac层的封包-mtu-msdu-mpdu\"><a href=\"#mac层的封包-mtu-msdu-mpdu\" class=\"headerlink\" title=\"mac层的封包,mtu,msdu,mpdu\"></a>mac层的封包,mtu,msdu,mpdu</h4><p>在包的封装上，有线网和无线网不同，更确切的是协议不同，其mac层封包也不同–对相同的ip包(ip头+上层数据/arp/…）带有不同的mac头：<br>例如对以太网（有线）：常见有一下四种mac头封装的帧：</p>\n<ul>\n<li>EthernetII:  dest addr+src addr+type+data+fcs</li>\n<li>Ethernet 802.2:dest addr+srcaddr+len+ llc+data+fcs</li>\n<li>Ethernet 802.3:dest addr+src addr+len+data+fcs </li>\n<li>Ethernet SNAP:dest addr+src addr+len+llc+snap+data+fcs<br>参考：<a href=\"https://blog.csdn.net/xiao628945/article/details/8006022\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xiao628945/article/details/8006022</a><br>针对无线网络：802.11n等，更复杂些：</li>\n<li>802.11头+msdu(数据部分)+fcs(crc)<br>而802.11wifi无线帧分为控制帧，管理帧和数据帧，因为在无线网络中的安全性等考虑，需要扫描，关联，认证四次握手等步骤,在802.11头就包含了subtype，即数据部分是什么类型（控制，。。）<a href=\"https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末</a><br><a href=\"https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了</a><br>这么多的封包类型，除却ip层只有一种，那在传递的过程中如何处理?即有线到无线，怎么识别?答案是在路由器，主机中进行去头和加头<br>不同厂商实现不同，在无线中，非数据帧部分：底层的实现分为full mac driver（Full Mac的Driver，一般Auth和Assoc的包直接在芯片里边处理了，Driver通过command形式告诉Firmware要连接AP的信息，Firmware处理了Assoc Response之后，report给Driver一个Event，说明连接的情况（result和AID）以及assoc相关的IE，Driver会直接调用cfg80211的接口报告给supplicant，然后处理EAPOL的握手过程，因为之后的EAPOL Data的处理会用到Assoc Response里边的IE）  而用soft mac则软件可以控制较多的事情(Soft Mac模块开源代码mac80211的WiFi芯片，会将这两种包送到Mac80211处理，mac80211处理完后调用cfg80211的接口通过nl80211(netlink)通知wpa_supplicant准备认证以及四次握手的状态机，等待处理EAPOL包，EAPOL是二层的Data包，会在Supplicant里边处理，连接加密的路由情况就是这样处理的，如果不加密，那就直接DHCP了)；扯远了。。<br>在pc等设备中，在封装到数据链路层时，封装时用的是ethernetII，到底层驱动时就被替换为对应的802.11的头了，进而发送出去，而在接收数据包的时候，底层上报上来又会把802.11格式的转换为ehternetII的形式，所以我在实验wifi的时候，用的PF_PACKET来操作数据包，加的是ethernetII的头，接收到打印出来后还是ethernetII的头<br>晒张空中包的和本地tcpdump抓到的包对比：<br>//to do</li>\n</ul>\n<p>当然除却mac头的不同，mtu的概念还是存在:<br>mac层在传输时一次传输一帧，这一帧即是封装了mac头的数据包，它常为[46-1500]+mac头,而mtu即是最大的传输单元，是去掉mac头的负载部分最大值，如1500<br>而在实际传输的空中包，情况又可能不同，这里看msdu 和mpdu:<br><a href=\"https://blog.csdn.net/zhengnice/article/details/51923132\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhengnice/article/details/51923132</a><br>这篇文章讲的很好，在理解了上述的内容后，看这篇文章里面的msdu和mpdu就能很好的理解了，spec的416页也有相关的内容</p>\n<h5 id=\"mac头格式：不同协议可能不同：\"><a href=\"#mac头格式：不同协议可能不同：\" class=\"headerlink\" title=\"mac头格式：不同协议可能不同：\"></a>mac头格式：不同协议可能不同：</h5><p>常见：dest addr,src addr ,proto type; 14byte<br>见上文</p>\n<h4 id=\"mac层的发包和收包限制\"><a href=\"#mac层的发包和收包限制\" class=\"headerlink\" title=\"mac层的发包和收包限制\"></a>mac层的发包和收包限制</h4><p>考虑一个问题，即在不考虑网络网段的情况下，两台设备在开启wifi或者连接网线的情况下，能相互直接通信吗？<br>从理论上是可以的，首先是发送，无问题，接收，可以接收；其次，接收之后解码，需要双方使用相同的编码协议等；<br>其次：实际上，需要几个条件，且有线和无线的方式不同：</p>\n<ul>\n<li>有线：需要双方相同的编码，直连的情况下，可以直接通信；</li>\n<li>无线: (分为数据部分和管理部分，需要双方相同的编码)，但是仅开启wifi，只能接收小量信息的beacon帧；即wifi为了安全性，效率等(wifi本身可以接收所有数据），做了连接前的扫描，关联认证，四次握手等过程，并且对mac地址进行过滤，使不同网段的两个相邻设备不能通过直接发送接收mac层数据来交互；具体见厂商的实现，可以参考实验部分；  </li>\n<li>所以关键看厂商怎么实现，底层的东西，他们提供接口给你，你就能操作了balalal<h5 id=\"普通模式，混杂模式和监听模式\"><a href=\"#普通模式，混杂模式和监听模式\" class=\"headerlink\" title=\"普通模式，混杂模式和监听模式\"></a>普通模式，混杂模式和监听模式</h5><h4 id=\"mac层的几个实验\"><a href=\"#mac层的几个实验\" class=\"headerlink\" title=\"mac层的几个实验\"></a>mac层的几个实验</h4>普通模式下，wifi实验，以station架构进行：<br>设备A，B,路由器C，D;  </li>\n<li>A,B连接同一个路由器C,A,B通过PF_PACKET发送和接收mac头加任意数据，成功发送接收，即使arp表无对方的条目  </li>\n<li>A,B都不连接wifi,只是打开wifi，此时无法发送和接收数据，厂商默认的只会发送主动扫苗和接收beacon帧，扫描的具体过程待文章写,在没有连接上时，只会发送小数据</li>\n<li>A,B间任意设备连上路由器，同上</li>\n<li><em>A连接路由C,B连接路由D,相互发送和接收mac头加任意数据，目的地址为对方mac，源地址为自己的mac—失败，其实一开始是怀着疑问的，从理论分析是可以的，但是还是不行，若只是在二层的话，对方怎么知道这个源mac地址是在不同网段并做过滤?难道发之前，底层进行了隐式arp？但是我发的包里面没有带ip信息啊，同时进行了广播帧的发送接收，还是失败了；应该都是出在接收的环节；也有可能是两个ap使用的协议不同导致编码方式不同从而接收失败</em></li>\n<li>考虑到可能是两个路由器编码和使用的协议如一个是802.11n,一个是ac，等，可能导致接收不到，所以可以再尝试使用两个相同的型号的路由器；//待测试</li>\n<li>发送方普通模式，接收方监听模式，接收方可以收到所有包，所以可以接收到</li>\n</ul>\n<h4 id=\"openwrt开源路由系统，驱动，固件\"><a href=\"#openwrt开源路由系统，驱动，固件\" class=\"headerlink\" title=\"openwrt开源路由系统，驱动，固件\"></a>openwrt开源路由系统，驱动，固件</h4><p>了解一下。。。<br>spec:Wireless LAN Medium Access Control<br>(MAC)<br>and Physical Layer (PHY) Specifications</p>"},{"title":"tcpip_ARP","date":"2018-05-27T16:19:57.000Z","_content":"### ARP 协议\n#### ARP协议的作用\n+ ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信；\n+ 在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：  \n  端设备手机pc等-->(交换机)路由器--->下一个路由器--->下一个终端设备  <!--more-->\n  端设备默认路由到网关-->网关收到包后，将源地址改为网关的外网地址--->下一个路由-->....->设备地址为目的地址时，接收而不转发\n+ 考虑一个问题：在上述的网络上发送时，如pc发给路由器时，只知道它的ip地址，怎么发给它：  \n  即端到端的发送：是借助设备唯一的mac地址来发送的  \n  在有线网中。利用了交换机的端口和mac地址关系，转发  \n  在wifi中，能接收到所有的包，但是会在驱动中将mac目的地址非本地的包丢弃，除非开启了混杂监听模式\n+ 但是路由器怎么知道设备如手机的mac地址呢？\n  通过arp协议来获取，arp是依赖mac和ip的\"映射\"\n+ tcpip卷1中4.2举了一个完整的例子，可以去看\n#### ARP协议的交互过程\n+ 基本的交互方式：  \n例如ping网关：  \nstation  ---ARP request---->   AP  ARP请求，广播帧    \nstation  <---ARP response ---  AP  ARP应答 ,单播帧  \n通过上述的方式，station得到了AP的mac地址，之后将AP的MAC地址存在缓存中，在下次数据包等包的时候就可以将该mac地址填在mac头中，即知道了AP的地址后，包就可以顺利的被AP接收了\n+ AP(路由器)也会主动的向station发送arp request，当它不知道station的mac地址（或缓存过期），例如，AP收到一个外网的包，要转发给对应192.168.0.4的staton,但是没有他的mac地址，或者过期了或者其他情况，则向该station发出arp请求。从而得打station的mac地址\n+ 什么时候会触发arp请求？  \n  1.在ping的时候  \n  2.在发送tcp，ip包的时候  \n  3.在缓存过期时主动发出，这个由arp状态机中实现\n#### ARP代理和免费ARP\n+ 当我们通过ping百度，或者想访问百度的时候，怎么在mac头中填写目的mac地址呢？即怎么找到百度?（另一个网络)\n+ 是通过在mac头目的mac地址填写网关的mac地址实现的，借助w网关的来帮我们寻找，这个叫做ARP代理,其实欺骗了主机\n+ tcpip卷对此有较详细解说4.6\n+ 免费ARP是用于检测是否周围有使用相同的ip地址的设备，即通过ping自己，寻找有自己的ip的主机\n#### ARP协议的包封装格式和抓包分析\n+ 分组格式：  ()为字节数\nmac头：以太网目的地址(6) mac源地址(6) 帧类型(2)(0x0806)   \n28byte arp帧：硬件类型(2)|协议类型(2)|硬件地址长度(1)|协议地址长度(1)|op(请求或应答或rarp 2)|发送端mac地址(6)|发送端ip(4)|接收端mac地址(6)|接收端ip(4)  \n+ 请求广播帧：目的mac地址为全1，电缆上所有的以太网接口都要接收广播帧,硬件类型为1表示以太网地址，协议类型为要映射的协议地址类型0x0800,表示为ip地址，op（arp请求为1，答应为2，rarp请求为3，rarp答应为4）\n+ arp填充：以太网帧最小值为60，mac头14，所以=46，要填充：46-28=18个字节\n+ arp抓包，可以用wireshark,Omnipeek - Savvius,tcpdump,或者自己写一个程序来抓～  \n tcpdump : sudo tcpdump -vv arp  \n ```c\n tcpdump: listening on wlp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes\n21:51:21.134575 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.101 tell 192.168.0.1, length 28 //ap ask me\n21:51:21.135404 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.110 tell 192.168.0.1, length 28\n21:51:21.135413 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.0.110 is-at 48:5a:b6:6e:c9:5f (oui Unknown), length 28// i reply ap\n21:51:32.081916 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.106 tell 192.168.0.1, length 28 //ask other\n```\n\n```c \n22:01:27.149947 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.107 tell 192.168.0.1, length 28\n\t0x0000:  0001 0800 0604 0001 206b e70f 1b42 c0a8  .........k...B..\n\t0x0010:  0001 0000 0000 0000 c0a8 006b            ...........k\n    \n    22:04:17.114593 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.0.110 is-at 48:5a:b6:6e:c9:5f (oui Unknown), length 28\n\t0x0000:  0001 0800 0604 0002 485a b66e c95f c0a8  ........HZ.n._..\n\t0x0010:  006e 206b e70f 1b42 c0a8 0001            .n.k...B....\n```\n\n#### ARP协议的常用命令和调试分析\n+ 查看ARP缓存：即现在保存的arp映射表:  \n```\narp -a\n? (192.168.0.101) at 4c:32:75:3a:09:b3 [ether] on wlp2s0\n? (192.168.0.1) at 20:6b:e7:0f:1b:42 [ether] on wlp2s0\n? (192.168.0.108) at 94:d0:29:9d:74:dd [ether] on wlp2s0\n? (192.168.0.107) at 94:65:2d:ab:88:8b [ether] on wlp2s0\n```\n```\narp \nAddress                  HWtype  HWaddress           Flags Mask            Iface\n192.168.0.101            ether   4c:32:75:3a:09:b3   C                     wlp2s0\n192.168.0.1              ether   20:6b:e7:0f:1b:42   C                     wlp2s0\n```\n```c\nip neigh\n192.168.0.101 dev wlp2s0 lladdr 4c:32:75:3a:09:b3 STALE\n192.168.0.1 dev wlp2s0 lladdr 20:6b:e7:0f:1b:42 STALE\n192.168.0.108 dev wlp2s0 lladdr 94:d0:29:9d:74:dd STALE\n192.168.0.107 dev wlp2s0 lladdr 94:65:2d:ab:88:8b STALE\n192.168.0.104 dev wlp2s0 lladdr e4:9a:dc:b0:a5:36 STALE\n```\n+ arping命令：  \nhttp://man.linuxde.net/arping\n+ arp 命令\nman arp 包括删除arp表项等，有问题，找男人~\n#### ARP协议内核状态机\n+ 对不存在的主机，arp请求的超时机制  \n+ arp缓存和老化时间：\nhttp://www.jb51.net/LINUXjishu/65693.html：\n改变老化时间：在Linux上如果你想设置你的ARP缓存老化时间，那么执行sysctl -w net.ipv4.neigh.ethX=Y即\n#### ARP协议的编程\n+ 在PF_PACKET中发出ARP包\n+ 直接贴例子，具体可以看博客的PF_PACKET文章：\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <linux/if.h>\n#include <sys/ioctl.h>\n#include <linux/if_packet.h>\n#include <linux/if_ether.h>\n```\n\n```cpp\n//获取硬件网卡的相应信息\nvoid GetEthInfor(char *name , char *MAC_addr , struct in_addr * IP_addr);\n//arp包的结构定义\nstruct ARP_PACKET\n{\n       //以太网首部\n unsigned char dest_mac[6]; //6字节\n unsigned char sorce_mac[6];//6字节\n unsigned short type;       //2字节\n  //arp——内容\n unsigned short hw_type;   //2字节：硬件地址类型     0x0001 表示mac地址\n unsigned short pro_type;  //2字节：软件地址类型    0x0806 表示IPV4地址\n unsigned char hw_len;     //1字节：硬件地址长度  \n unsigned char pro_len;    //1字节：软件地址长度\n unsigned short op;        //2字节：操作类型           0x0001表示ARP请求；0x0002表示ARP应答\n unsigned char from_mac[6];//6字节\n unsigned char from_ip[4]; //4字节\n unsigned char to_mac[6];  //6字节\n unsigned char to_ip[4];   //4字节\n unsigned char padding[18];//18字节：填充字节，因为以太网数据最少要46字节\n};\n//主函数\nint main()\n{\n int i = 0;\n int fd = 0;\n int num=0;\n unsigned char MAC_ADDR[6];\n struct in_addr IP_ADDR;//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.\n struct ARP_PACKET arp_pk={0};\n struct sockaddr_ll eth_info;//结构体的定义//在/linux/if_packet.h中， 表示设备无关的物理层地址结构\n //第一步：获取指定网卡的信息（MAC地址和IP地址）\n GetEthInfor(\"wlp2s0\",MAC_ADDR,&IP_ADDR);\n   /*printf(\"The MAC_addr is:\");\n for(i =0 ;i<6;i++)\n    printf(\"%4X\",MAC_ADDR[i]); \n printf(\"\\n\");\n    printf(\"the IP is:%s\\n\",inet_ntoa(IP_ADDR));*/\n      \n    //第二步：填充ARP数据包的内容\n for(i=0;i<6;i++)                 //填充以太网首部的目的mac地址\n {\n  arp_pk.dest_mac[i]=0XFF;      \n }\n  \n for(i=0;i<6;i++)                 //填充以太网首部的源mac地址\n {\n  arp_pk.sorce_mac[i]=MAC_ADDR[i];\n }\n   arp_pk.type = htons(0x0806);    //填充以太网首部的侦类型\n   arp_pk.hw_type = htons(0x0001); //填充硬件地址类型：0x0001表示的是MAC地址\n   arp_pk.pro_type = htons(0x0800);//填充协议地址类型：0x0800表示的是IP地址\n   arp_pk.hw_len = 6;              //填充硬件地址长度\n   arp_pk.pro_len = 4;             //填充协议地址长度\n   arp_pk.op = htons(0x0001);      //填充操作类型：0x0001表示ARP请求\n\n   for(i=0;i<6;i++)                 //填充源mac地址\n   {\n  arp_pk.from_mac[i]=MAC_ADDR[i];\n   }\n   in_addr_t ipaddr=inet_network(inet_ntoa(IP_ADDR));\n   for(i=3;i>=0;i--)                 //填充源IP地址\n   {\n  arp_pk.from_ip[i]=(unsigned char)ipaddr&0xFF;\n   ipaddr=ipaddr>>8;\n  printf(\"-%d-\",arp_pk.from_ip[i]);\n   }\n /* arp_pk.from_ip[0]=192;\n  arp_pk.from_ip[1]=168;\n  arp_pk.from_ip[2]=199;\n  arp_pk.from_ip[3]=145;*/\n  \n   for(i=0;i<6;i++)                 //填充欲获取的目的mac地址\n   {\n    arp_pk.to_mac[i]=0X00;\n   }\n  \n   arp_pk.to_ip[0]=0X0B;        //填充想要装换为MAC地址的IP地址。可以使用命令行参数来做\n   arp_pk.to_ip[1]=0X40;\n   arp_pk.to_ip[2]=0X39;\n   arp_pk.to_ip[3]=0X0A;\n \n //第三步：填充sockaddr_ll eth_info结构\n    eth_info.sll_family = PF_PACKET;\n eth_info.sll_ifindex = if_nametoindex(\"wlp2s0\");//返回输入的接口名称的索引值\n //printf(\"number is:%d\\n\",eth_info.sll_family);\n \n //第四步：创建原始套接字\n fd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));  //\n if(fd<0)\n {\n  printf(\"socket SOCK_RAW failed!\\n\");\n  exit(1);\n }\n\n \n\n //第五步：发送ARP数据包\n num = sendto(fd , &arp_pk , sizeof(struct ARP_PACKET) , 0 ,(struct sockaddr*)(&eth_info),sizeof(eth_info));\n if(num<0)\n {\n  printf(\"sendto failed!\\n\");\n  exit(1);\n }\n        //第六步：接受ARP应答\n num = recvfrom(fd , &arp_pk , sizeof(struct ARP_PACKET) ,0,NULL,0);\n\n if(num<0)\n {\n  printf(\"rcvfrom failed!\\n\");\n  exit(1);\n }\n else\n {\n  printf(\"I receive %d bytes!\\n\",num);\n  printf(\"the mac  is:\");\n  for(i=0;i<6;i++)\n  {\n   printf(\"%4X \",arp_pk.from_mac[i]);\n  }\n  printf(\"op:%d\\n\",arp_pk.op);\n for(i=0;i<4;i++)\n  {\n   printf(\"%d. \",arp_pk.to_ip[i]);\n  }\n  printf(\"\\n\");\n }\n\n close(fd);\n return 0;\n}\n\nvoid GetEthInfor(char *name ,  char *MAC_addr , struct in_addr * IP_addr)\n{\n struct ifreq  eth;  //够结构用于存放最初多获取的接口信息\n//该结构存放在：/net/if.h,详细字段表示在头文件中\n   int fd;             //用于创建套接字\n int temp=0;         //用于验证接口调用\n int i=0;            //用于循环\n \n strncpy(eth.ifr_name,name,sizeof(struct ifreq)-1);\n// fd = socket(AF_INET,SOCK_DGRAM,0);\n // fd=socket(AF_INET,SOCK_STREAM,0); \n    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));\nif(fd<0)\n {\n   printf(\"socket failed!\\n\");\n   exit(1);\n }\n //获取并且保存和打印指定的物理接口MAC地址信息\n   temp = ioctl(fd,SIOCGIFHWADDR,&eth);\n if(temp<0)\n {\n  printf(\"ioctl--get hardware addr failed!\\n\");\n  exit(1);\n        }\n strncpy(MAC_addr,eth.ifr_hwaddr.sa_data,6);\n printf(\"The MAC_addr is:\");\n for(i =0 ;i<6;i++)\n  printf(\"%4X\",(unsigned char)eth.ifr_hwaddr.sa_data[i]); \n printf(\"\\n\");\n       \n        //获取并且保存和打印指定的物理接口IP地址信息\n   temp = ioctl(fd,SIOCGIFADDR,&eth);\n if(temp<0)\n {\n  printf(\"ioctl--get hardware addr failed!\\n\");\n  exit(1);\n        }\n memcpy(IP_addr ,&(((struct sockaddr_in *)(&eth.ifr_addr))->sin_addr),4);\n //关闭套接口\n  printf(\"got ipaddr:%s\\n\",inet_ntoa(*IP_addr));\n/*i=0;\nprintf(\"get the MAC_ADDR:\\n\");\nfor(i;i<6;i++)\n  printf(\"%.2X:\",MAC_addr[i]&0xFF);*/\n   close(fd);\n}\n//第二步填充arp数据包的时候，填充的数据和类型根据需要进行。\n//这里的arp数据包结构体是自己定义的，也可以是利用linux的相关结构：\n/*eg:\ntypedef struct _tagARP_PACKET{    \n    struct ether_header  eh;    ///net/ethernet.h\n    struct ether_arp arp;    \n}ARP_PACKET_OBJ, *ARP_PACKET_HANDLE; /netinet/if_ether.h;/net/if_arp.h\n各个字段的填充见头文件*/\n\n/*第三步：填充sockaddr_ll eth_info结构,关键是填充网络接口索引值，最直接的方法是上面的函数，\n还有另外的方法:利用ioctl函数获取struct ifreq结构的信息，该结构放置了很多网络接口的相关信息*/\n/*  struct sockaddr_ll{\n    unsigned short sll_family; //总是 AF_PACKET \n    unsigned short sll_protocol; // 物理层的协议 \n    int sll_ifindex; //接口号 \n    unsigned short sll_hatype; // 报头类型 \n    unsigned char sll_pkttype; // 分组类型 \n    unsigned char sll_halen; // 地址长度 \n    unsigned char sll_addr[8]; // 物理层地址 \n};\neg:\n*     struct sockaddr_ll peer_addr;  \n*    memset(&peer_addr, 0, sizeof(peer_addr));    \n        peer_addr.sll_family = AF_PACKET;    \n        struct ifreq req;  \n    bzero(&req, sizeof(struct ifreq));  \n        strcpy(req.ifr_name, \"eth0\");    \n        if(ioctl(sockfd, SIOCGIFINDEX, &req) != 0)  \n        perror(\"ioctl()\");    \n        peer_addr.sll_ifindex = req.ifr_ifindex;    \n        peer_addr.sll_protocol = htons(ETH_P_ARP);  \n\n*/\n/*第四步，创建套结字的时候，有以下的组合：更多见：man packet\n * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.\n * 第二个参数： 2）套接字类型：\n          SOCK_DGRAM----以太网头已经构造好了\n          SOCK_RAW------自己构造以太头 \n          * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字\n          * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），\n          * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，\n          * 而发送时也无须用户添加头部字段。\n   第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP\n   * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：\n   1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)\n  和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)\n    2)IEEE维护的注册以太网类型列表\n     3）半官方的列表由IANA维护\n      ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。\n      0x88b5和0x88b6是保留以太网类型，供实验或私人使用。 \n      */\n   /*第五步发送和接收套接字的函数可以是read write操作套结字，也可以是上文的UDP无连接用的函数*/\n```\n\n处理的时候可能需要获取网关的ip地址：\n```cpp\n/*proc方法获取网关地址*/\nvoid GetGateWayIP(uint8 *ip_addr)\n{\n      char inf[100];\n      FILE *file_fd;\n      uint8 high=0,low=0,value;\n      int i;\n      file_fd = fopen(\"/proc/net/route\",\"r\");\n      if(file_fd==NULL)\n      {\n            printf(\"can not open /proc/net/route\\n\");\n      }\n      else\n     {\n             while(!feof(file_fd))\n             {\n                     memset(inf,0,sizeof(inf));\n                     fgets(inf,100,file_fd);\n                     if(inf[5]=='0'&&inf[6]=='0'&&inf[7]=='0'&&inf[8]=='0'&&inf[9]=='0'&&inf[10]=='0'&&inf[11]=='0'&&inf[12]=='0')\n                     {\n                              for(i=20;i>=14;i-=2)\n                              {\n                                         if(inf[i]>=65)\n                                                 high = inf[i]-55;\n                                         else\n                                                 high = inf[i]-48;\n                                         if(inf[i+1]>=65)\n                                                 low = inf[i+1]-55;\n                                         else\n                                                 low = inf[i+1]-48;\n                                        value = high*16+low;\n                                       ip_addr[10-i/2] = value;\n                              }\n                              break;\n                       }\n              }\n      }\n}```\n#### ARP攻击\n+ ARP包可以直接发送给对端不经过路由器，有趣\n在一个局域网中，客户端的几乎所有的包都是发往路由器的，这归结于默认路由设置，而在无线网，网卡其实可以接收所有数据，毕竟空气介质，所以，局域网中的设备可以直接通信  \n实验：在文件全能王中开启wifi文件传输，和它在同一个局域网的sta能访问该地址，抓包，发现目的地址和源地址都为同一个局域网的不同ip,且不为路由器网关ip，证明其两个设备是可以直接通信的\n+ 再来做一个实验：通过pf_packet  \n1、在电脑A上写一个程序，mac目的地址为B,源地址为A,协议类型随机，数据随意，发送给B  \n   同时在B端进行接收，过滤掉其他mac地址，看是否可以接收到，在连接ap和不连接ap的条件下  \n2、在A和B设置静态ip地址，且不同网段，都不连接AP ,让A向B 发送ARP请求包，B接收到后回复arp响应包，接着做ping或其他操作，看是否能互相通信\n+ 编程可以参考上述程序，改一下地址什么的就可以，或者参考其他：\nhttp://www.freebuf.com/articles/system/5157.html\n这篇文章讲的很具体，个人也喜欢这个网站，emm,实验过了，还可以，can also make your own program,具体程序不贴了  \n+ arp欺骗的基本原理：   \n在局域网中，设备A,B连接同一个路由器，他们之间可以直接相互通信，因此可以直接向对方发送arp包；   \n设备A ,B都会定期和AP交互arp请求和回复，相互知道对方的mac地址，这样，就能给ap发送请求，ap也能知道回复给谁；    \narp欺骗的基本原理在于，如B是攻击方，则B向A发送ARP回复自己是AP ,即在ARP回复包中带上自己的mac地址，ap的ip地址；\n同时向AP回复自己是A，即带上A的ip地址，自己的mac地址；   \n这样A就会以为B是AP，就会把请求发给B ,同时AP以为B是A，会把回复传给B,但是同时得配置B的转发功能，  \necho 1 >> /proc/sys/net/ipv4/ip_forwardroot  \n该博文中有一处错误，见评论\n","source":"_posts/tcpip-ARP.md","raw":"---\ntitle: tcpip_ARP\ndate: 2018-05-28 00:19:57\ntags: tcpip_mac\ncategories: tcpip\n---\n### ARP 协议\n#### ARP协议的作用\n+ ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信；\n+ 在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：  \n  端设备手机pc等-->(交换机)路由器--->下一个路由器--->下一个终端设备  <!--more-->\n  端设备默认路由到网关-->网关收到包后，将源地址改为网关的外网地址--->下一个路由-->....->设备地址为目的地址时，接收而不转发\n+ 考虑一个问题：在上述的网络上发送时，如pc发给路由器时，只知道它的ip地址，怎么发给它：  \n  即端到端的发送：是借助设备唯一的mac地址来发送的  \n  在有线网中。利用了交换机的端口和mac地址关系，转发  \n  在wifi中，能接收到所有的包，但是会在驱动中将mac目的地址非本地的包丢弃，除非开启了混杂监听模式\n+ 但是路由器怎么知道设备如手机的mac地址呢？\n  通过arp协议来获取，arp是依赖mac和ip的\"映射\"\n+ tcpip卷1中4.2举了一个完整的例子，可以去看\n#### ARP协议的交互过程\n+ 基本的交互方式：  \n例如ping网关：  \nstation  ---ARP request---->   AP  ARP请求，广播帧    \nstation  <---ARP response ---  AP  ARP应答 ,单播帧  \n通过上述的方式，station得到了AP的mac地址，之后将AP的MAC地址存在缓存中，在下次数据包等包的时候就可以将该mac地址填在mac头中，即知道了AP的地址后，包就可以顺利的被AP接收了\n+ AP(路由器)也会主动的向station发送arp request，当它不知道station的mac地址（或缓存过期），例如，AP收到一个外网的包，要转发给对应192.168.0.4的staton,但是没有他的mac地址，或者过期了或者其他情况，则向该station发出arp请求。从而得打station的mac地址\n+ 什么时候会触发arp请求？  \n  1.在ping的时候  \n  2.在发送tcp，ip包的时候  \n  3.在缓存过期时主动发出，这个由arp状态机中实现\n#### ARP代理和免费ARP\n+ 当我们通过ping百度，或者想访问百度的时候，怎么在mac头中填写目的mac地址呢？即怎么找到百度?（另一个网络)\n+ 是通过在mac头目的mac地址填写网关的mac地址实现的，借助w网关的来帮我们寻找，这个叫做ARP代理,其实欺骗了主机\n+ tcpip卷对此有较详细解说4.6\n+ 免费ARP是用于检测是否周围有使用相同的ip地址的设备，即通过ping自己，寻找有自己的ip的主机\n#### ARP协议的包封装格式和抓包分析\n+ 分组格式：  ()为字节数\nmac头：以太网目的地址(6) mac源地址(6) 帧类型(2)(0x0806)   \n28byte arp帧：硬件类型(2)|协议类型(2)|硬件地址长度(1)|协议地址长度(1)|op(请求或应答或rarp 2)|发送端mac地址(6)|发送端ip(4)|接收端mac地址(6)|接收端ip(4)  \n+ 请求广播帧：目的mac地址为全1，电缆上所有的以太网接口都要接收广播帧,硬件类型为1表示以太网地址，协议类型为要映射的协议地址类型0x0800,表示为ip地址，op（arp请求为1，答应为2，rarp请求为3，rarp答应为4）\n+ arp填充：以太网帧最小值为60，mac头14，所以=46，要填充：46-28=18个字节\n+ arp抓包，可以用wireshark,Omnipeek - Savvius,tcpdump,或者自己写一个程序来抓～  \n tcpdump : sudo tcpdump -vv arp  \n ```c\n tcpdump: listening on wlp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes\n21:51:21.134575 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.101 tell 192.168.0.1, length 28 //ap ask me\n21:51:21.135404 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.110 tell 192.168.0.1, length 28\n21:51:21.135413 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.0.110 is-at 48:5a:b6:6e:c9:5f (oui Unknown), length 28// i reply ap\n21:51:32.081916 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.106 tell 192.168.0.1, length 28 //ask other\n```\n\n```c \n22:01:27.149947 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.107 tell 192.168.0.1, length 28\n\t0x0000:  0001 0800 0604 0001 206b e70f 1b42 c0a8  .........k...B..\n\t0x0010:  0001 0000 0000 0000 c0a8 006b            ...........k\n    \n    22:04:17.114593 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.0.110 is-at 48:5a:b6:6e:c9:5f (oui Unknown), length 28\n\t0x0000:  0001 0800 0604 0002 485a b66e c95f c0a8  ........HZ.n._..\n\t0x0010:  006e 206b e70f 1b42 c0a8 0001            .n.k...B....\n```\n\n#### ARP协议的常用命令和调试分析\n+ 查看ARP缓存：即现在保存的arp映射表:  \n```\narp -a\n? (192.168.0.101) at 4c:32:75:3a:09:b3 [ether] on wlp2s0\n? (192.168.0.1) at 20:6b:e7:0f:1b:42 [ether] on wlp2s0\n? (192.168.0.108) at 94:d0:29:9d:74:dd [ether] on wlp2s0\n? (192.168.0.107) at 94:65:2d:ab:88:8b [ether] on wlp2s0\n```\n```\narp \nAddress                  HWtype  HWaddress           Flags Mask            Iface\n192.168.0.101            ether   4c:32:75:3a:09:b3   C                     wlp2s0\n192.168.0.1              ether   20:6b:e7:0f:1b:42   C                     wlp2s0\n```\n```c\nip neigh\n192.168.0.101 dev wlp2s0 lladdr 4c:32:75:3a:09:b3 STALE\n192.168.0.1 dev wlp2s0 lladdr 20:6b:e7:0f:1b:42 STALE\n192.168.0.108 dev wlp2s0 lladdr 94:d0:29:9d:74:dd STALE\n192.168.0.107 dev wlp2s0 lladdr 94:65:2d:ab:88:8b STALE\n192.168.0.104 dev wlp2s0 lladdr e4:9a:dc:b0:a5:36 STALE\n```\n+ arping命令：  \nhttp://man.linuxde.net/arping\n+ arp 命令\nman arp 包括删除arp表项等，有问题，找男人~\n#### ARP协议内核状态机\n+ 对不存在的主机，arp请求的超时机制  \n+ arp缓存和老化时间：\nhttp://www.jb51.net/LINUXjishu/65693.html：\n改变老化时间：在Linux上如果你想设置你的ARP缓存老化时间，那么执行sysctl -w net.ipv4.neigh.ethX=Y即\n#### ARP协议的编程\n+ 在PF_PACKET中发出ARP包\n+ 直接贴例子，具体可以看博客的PF_PACKET文章：\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <linux/if.h>\n#include <sys/ioctl.h>\n#include <linux/if_packet.h>\n#include <linux/if_ether.h>\n```\n\n```cpp\n//获取硬件网卡的相应信息\nvoid GetEthInfor(char *name , char *MAC_addr , struct in_addr * IP_addr);\n//arp包的结构定义\nstruct ARP_PACKET\n{\n       //以太网首部\n unsigned char dest_mac[6]; //6字节\n unsigned char sorce_mac[6];//6字节\n unsigned short type;       //2字节\n  //arp——内容\n unsigned short hw_type;   //2字节：硬件地址类型     0x0001 表示mac地址\n unsigned short pro_type;  //2字节：软件地址类型    0x0806 表示IPV4地址\n unsigned char hw_len;     //1字节：硬件地址长度  \n unsigned char pro_len;    //1字节：软件地址长度\n unsigned short op;        //2字节：操作类型           0x0001表示ARP请求；0x0002表示ARP应答\n unsigned char from_mac[6];//6字节\n unsigned char from_ip[4]; //4字节\n unsigned char to_mac[6];  //6字节\n unsigned char to_ip[4];   //4字节\n unsigned char padding[18];//18字节：填充字节，因为以太网数据最少要46字节\n};\n//主函数\nint main()\n{\n int i = 0;\n int fd = 0;\n int num=0;\n unsigned char MAC_ADDR[6];\n struct in_addr IP_ADDR;//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.\n struct ARP_PACKET arp_pk={0};\n struct sockaddr_ll eth_info;//结构体的定义//在/linux/if_packet.h中， 表示设备无关的物理层地址结构\n //第一步：获取指定网卡的信息（MAC地址和IP地址）\n GetEthInfor(\"wlp2s0\",MAC_ADDR,&IP_ADDR);\n   /*printf(\"The MAC_addr is:\");\n for(i =0 ;i<6;i++)\n    printf(\"%4X\",MAC_ADDR[i]); \n printf(\"\\n\");\n    printf(\"the IP is:%s\\n\",inet_ntoa(IP_ADDR));*/\n      \n    //第二步：填充ARP数据包的内容\n for(i=0;i<6;i++)                 //填充以太网首部的目的mac地址\n {\n  arp_pk.dest_mac[i]=0XFF;      \n }\n  \n for(i=0;i<6;i++)                 //填充以太网首部的源mac地址\n {\n  arp_pk.sorce_mac[i]=MAC_ADDR[i];\n }\n   arp_pk.type = htons(0x0806);    //填充以太网首部的侦类型\n   arp_pk.hw_type = htons(0x0001); //填充硬件地址类型：0x0001表示的是MAC地址\n   arp_pk.pro_type = htons(0x0800);//填充协议地址类型：0x0800表示的是IP地址\n   arp_pk.hw_len = 6;              //填充硬件地址长度\n   arp_pk.pro_len = 4;             //填充协议地址长度\n   arp_pk.op = htons(0x0001);      //填充操作类型：0x0001表示ARP请求\n\n   for(i=0;i<6;i++)                 //填充源mac地址\n   {\n  arp_pk.from_mac[i]=MAC_ADDR[i];\n   }\n   in_addr_t ipaddr=inet_network(inet_ntoa(IP_ADDR));\n   for(i=3;i>=0;i--)                 //填充源IP地址\n   {\n  arp_pk.from_ip[i]=(unsigned char)ipaddr&0xFF;\n   ipaddr=ipaddr>>8;\n  printf(\"-%d-\",arp_pk.from_ip[i]);\n   }\n /* arp_pk.from_ip[0]=192;\n  arp_pk.from_ip[1]=168;\n  arp_pk.from_ip[2]=199;\n  arp_pk.from_ip[3]=145;*/\n  \n   for(i=0;i<6;i++)                 //填充欲获取的目的mac地址\n   {\n    arp_pk.to_mac[i]=0X00;\n   }\n  \n   arp_pk.to_ip[0]=0X0B;        //填充想要装换为MAC地址的IP地址。可以使用命令行参数来做\n   arp_pk.to_ip[1]=0X40;\n   arp_pk.to_ip[2]=0X39;\n   arp_pk.to_ip[3]=0X0A;\n \n //第三步：填充sockaddr_ll eth_info结构\n    eth_info.sll_family = PF_PACKET;\n eth_info.sll_ifindex = if_nametoindex(\"wlp2s0\");//返回输入的接口名称的索引值\n //printf(\"number is:%d\\n\",eth_info.sll_family);\n \n //第四步：创建原始套接字\n fd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));  //\n if(fd<0)\n {\n  printf(\"socket SOCK_RAW failed!\\n\");\n  exit(1);\n }\n\n \n\n //第五步：发送ARP数据包\n num = sendto(fd , &arp_pk , sizeof(struct ARP_PACKET) , 0 ,(struct sockaddr*)(&eth_info),sizeof(eth_info));\n if(num<0)\n {\n  printf(\"sendto failed!\\n\");\n  exit(1);\n }\n        //第六步：接受ARP应答\n num = recvfrom(fd , &arp_pk , sizeof(struct ARP_PACKET) ,0,NULL,0);\n\n if(num<0)\n {\n  printf(\"rcvfrom failed!\\n\");\n  exit(1);\n }\n else\n {\n  printf(\"I receive %d bytes!\\n\",num);\n  printf(\"the mac  is:\");\n  for(i=0;i<6;i++)\n  {\n   printf(\"%4X \",arp_pk.from_mac[i]);\n  }\n  printf(\"op:%d\\n\",arp_pk.op);\n for(i=0;i<4;i++)\n  {\n   printf(\"%d. \",arp_pk.to_ip[i]);\n  }\n  printf(\"\\n\");\n }\n\n close(fd);\n return 0;\n}\n\nvoid GetEthInfor(char *name ,  char *MAC_addr , struct in_addr * IP_addr)\n{\n struct ifreq  eth;  //够结构用于存放最初多获取的接口信息\n//该结构存放在：/net/if.h,详细字段表示在头文件中\n   int fd;             //用于创建套接字\n int temp=0;         //用于验证接口调用\n int i=0;            //用于循环\n \n strncpy(eth.ifr_name,name,sizeof(struct ifreq)-1);\n// fd = socket(AF_INET,SOCK_DGRAM,0);\n // fd=socket(AF_INET,SOCK_STREAM,0); \n    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));\nif(fd<0)\n {\n   printf(\"socket failed!\\n\");\n   exit(1);\n }\n //获取并且保存和打印指定的物理接口MAC地址信息\n   temp = ioctl(fd,SIOCGIFHWADDR,&eth);\n if(temp<0)\n {\n  printf(\"ioctl--get hardware addr failed!\\n\");\n  exit(1);\n        }\n strncpy(MAC_addr,eth.ifr_hwaddr.sa_data,6);\n printf(\"The MAC_addr is:\");\n for(i =0 ;i<6;i++)\n  printf(\"%4X\",(unsigned char)eth.ifr_hwaddr.sa_data[i]); \n printf(\"\\n\");\n       \n        //获取并且保存和打印指定的物理接口IP地址信息\n   temp = ioctl(fd,SIOCGIFADDR,&eth);\n if(temp<0)\n {\n  printf(\"ioctl--get hardware addr failed!\\n\");\n  exit(1);\n        }\n memcpy(IP_addr ,&(((struct sockaddr_in *)(&eth.ifr_addr))->sin_addr),4);\n //关闭套接口\n  printf(\"got ipaddr:%s\\n\",inet_ntoa(*IP_addr));\n/*i=0;\nprintf(\"get the MAC_ADDR:\\n\");\nfor(i;i<6;i++)\n  printf(\"%.2X:\",MAC_addr[i]&0xFF);*/\n   close(fd);\n}\n//第二步填充arp数据包的时候，填充的数据和类型根据需要进行。\n//这里的arp数据包结构体是自己定义的，也可以是利用linux的相关结构：\n/*eg:\ntypedef struct _tagARP_PACKET{    \n    struct ether_header  eh;    ///net/ethernet.h\n    struct ether_arp arp;    \n}ARP_PACKET_OBJ, *ARP_PACKET_HANDLE; /netinet/if_ether.h;/net/if_arp.h\n各个字段的填充见头文件*/\n\n/*第三步：填充sockaddr_ll eth_info结构,关键是填充网络接口索引值，最直接的方法是上面的函数，\n还有另外的方法:利用ioctl函数获取struct ifreq结构的信息，该结构放置了很多网络接口的相关信息*/\n/*  struct sockaddr_ll{\n    unsigned short sll_family; //总是 AF_PACKET \n    unsigned short sll_protocol; // 物理层的协议 \n    int sll_ifindex; //接口号 \n    unsigned short sll_hatype; // 报头类型 \n    unsigned char sll_pkttype; // 分组类型 \n    unsigned char sll_halen; // 地址长度 \n    unsigned char sll_addr[8]; // 物理层地址 \n};\neg:\n*     struct sockaddr_ll peer_addr;  \n*    memset(&peer_addr, 0, sizeof(peer_addr));    \n        peer_addr.sll_family = AF_PACKET;    \n        struct ifreq req;  \n    bzero(&req, sizeof(struct ifreq));  \n        strcpy(req.ifr_name, \"eth0\");    \n        if(ioctl(sockfd, SIOCGIFINDEX, &req) != 0)  \n        perror(\"ioctl()\");    \n        peer_addr.sll_ifindex = req.ifr_ifindex;    \n        peer_addr.sll_protocol = htons(ETH_P_ARP);  \n\n*/\n/*第四步，创建套结字的时候，有以下的组合：更多见：man packet\n * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.\n * 第二个参数： 2）套接字类型：\n          SOCK_DGRAM----以太网头已经构造好了\n          SOCK_RAW------自己构造以太头 \n          * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字\n          * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），\n          * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，\n          * 而发送时也无须用户添加头部字段。\n   第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP\n   * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：\n   1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)\n  和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)\n    2)IEEE维护的注册以太网类型列表\n     3）半官方的列表由IANA维护\n      ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。\n      0x88b5和0x88b6是保留以太网类型，供实验或私人使用。 \n      */\n   /*第五步发送和接收套接字的函数可以是read write操作套结字，也可以是上文的UDP无连接用的函数*/\n```\n\n处理的时候可能需要获取网关的ip地址：\n```cpp\n/*proc方法获取网关地址*/\nvoid GetGateWayIP(uint8 *ip_addr)\n{\n      char inf[100];\n      FILE *file_fd;\n      uint8 high=0,low=0,value;\n      int i;\n      file_fd = fopen(\"/proc/net/route\",\"r\");\n      if(file_fd==NULL)\n      {\n            printf(\"can not open /proc/net/route\\n\");\n      }\n      else\n     {\n             while(!feof(file_fd))\n             {\n                     memset(inf,0,sizeof(inf));\n                     fgets(inf,100,file_fd);\n                     if(inf[5]=='0'&&inf[6]=='0'&&inf[7]=='0'&&inf[8]=='0'&&inf[9]=='0'&&inf[10]=='0'&&inf[11]=='0'&&inf[12]=='0')\n                     {\n                              for(i=20;i>=14;i-=2)\n                              {\n                                         if(inf[i]>=65)\n                                                 high = inf[i]-55;\n                                         else\n                                                 high = inf[i]-48;\n                                         if(inf[i+1]>=65)\n                                                 low = inf[i+1]-55;\n                                         else\n                                                 low = inf[i+1]-48;\n                                        value = high*16+low;\n                                       ip_addr[10-i/2] = value;\n                              }\n                              break;\n                       }\n              }\n      }\n}```\n#### ARP攻击\n+ ARP包可以直接发送给对端不经过路由器，有趣\n在一个局域网中，客户端的几乎所有的包都是发往路由器的，这归结于默认路由设置，而在无线网，网卡其实可以接收所有数据，毕竟空气介质，所以，局域网中的设备可以直接通信  \n实验：在文件全能王中开启wifi文件传输，和它在同一个局域网的sta能访问该地址，抓包，发现目的地址和源地址都为同一个局域网的不同ip,且不为路由器网关ip，证明其两个设备是可以直接通信的\n+ 再来做一个实验：通过pf_packet  \n1、在电脑A上写一个程序，mac目的地址为B,源地址为A,协议类型随机，数据随意，发送给B  \n   同时在B端进行接收，过滤掉其他mac地址，看是否可以接收到，在连接ap和不连接ap的条件下  \n2、在A和B设置静态ip地址，且不同网段，都不连接AP ,让A向B 发送ARP请求包，B接收到后回复arp响应包，接着做ping或其他操作，看是否能互相通信\n+ 编程可以参考上述程序，改一下地址什么的就可以，或者参考其他：\nhttp://www.freebuf.com/articles/system/5157.html\n这篇文章讲的很具体，个人也喜欢这个网站，emm,实验过了，还可以，can also make your own program,具体程序不贴了  \n+ arp欺骗的基本原理：   \n在局域网中，设备A,B连接同一个路由器，他们之间可以直接相互通信，因此可以直接向对方发送arp包；   \n设备A ,B都会定期和AP交互arp请求和回复，相互知道对方的mac地址，这样，就能给ap发送请求，ap也能知道回复给谁；    \narp欺骗的基本原理在于，如B是攻击方，则B向A发送ARP回复自己是AP ,即在ARP回复包中带上自己的mac地址，ap的ip地址；\n同时向AP回复自己是A，即带上A的ip地址，自己的mac地址；   \n这样A就会以为B是AP，就会把请求发给B ,同时AP以为B是A，会把回复传给B,但是同时得配置B的转发功能，  \necho 1 >> /proc/sys/net/ipv4/ip_forwardroot  \n该博文中有一处错误，见评论\n","slug":"tcpip-ARP","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7rc003n2ujxgy3aikpg","content":"<h3 id=\"ARP-协议\"><a href=\"#ARP-协议\" class=\"headerlink\" title=\"ARP 协议\"></a>ARP 协议</h3><h4 id=\"ARP协议的作用\"><a href=\"#ARP协议的作用\" class=\"headerlink\" title=\"ARP协议的作用\"></a>ARP协议的作用</h4><ul>\n<li>ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信；</li>\n<li>在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：<br>端设备手机pc等–&gt;(交换机)路由器—&gt;下一个路由器—&gt;下一个终端设备  <a id=\"more\"></a><br>端设备默认路由到网关–&gt;网关收到包后，将源地址改为网关的外网地址—&gt;下一个路由–&gt;….-&gt;设备地址为目的地址时，接收而不转发</li>\n<li>考虑一个问题：在上述的网络上发送时，如pc发给路由器时，只知道它的ip地址，怎么发给它：<br>即端到端的发送：是借助设备唯一的mac地址来发送的<br>在有线网中。利用了交换机的端口和mac地址关系，转发<br>在wifi中，能接收到所有的包，但是会在驱动中将mac目的地址非本地的包丢弃，除非开启了混杂监听模式</li>\n<li>但是路由器怎么知道设备如手机的mac地址呢？<br>通过arp协议来获取，arp是依赖mac和ip的”映射”</li>\n<li>tcpip卷1中4.2举了一个完整的例子，可以去看<h4 id=\"ARP协议的交互过程\"><a href=\"#ARP协议的交互过程\" class=\"headerlink\" title=\"ARP协议的交互过程\"></a>ARP协议的交互过程</h4></li>\n<li>基本的交互方式：<br>例如ping网关：<br>station  —ARP request—-&gt;   AP  ARP请求，广播帧<br>station  &lt;—ARP response —  AP  ARP应答 ,单播帧<br>通过上述的方式，station得到了AP的mac地址，之后将AP的MAC地址存在缓存中，在下次数据包等包的时候就可以将该mac地址填在mac头中，即知道了AP的地址后，包就可以顺利的被AP接收了</li>\n<li>AP(路由器)也会主动的向station发送arp request，当它不知道station的mac地址（或缓存过期），例如，AP收到一个外网的包，要转发给对应192.168.0.4的staton,但是没有他的mac地址，或者过期了或者其他情况，则向该station发出arp请求。从而得打station的mac地址</li>\n<li>什么时候会触发arp请求？<br>1.在ping的时候<br>2.在发送tcp，ip包的时候<br>3.在缓存过期时主动发出，这个由arp状态机中实现<h4 id=\"ARP代理和免费ARP\"><a href=\"#ARP代理和免费ARP\" class=\"headerlink\" title=\"ARP代理和免费ARP\"></a>ARP代理和免费ARP</h4></li>\n<li>当我们通过ping百度，或者想访问百度的时候，怎么在mac头中填写目的mac地址呢？即怎么找到百度?（另一个网络)</li>\n<li>是通过在mac头目的mac地址填写网关的mac地址实现的，借助w网关的来帮我们寻找，这个叫做ARP代理,其实欺骗了主机</li>\n<li>tcpip卷对此有较详细解说4.6</li>\n<li>免费ARP是用于检测是否周围有使用相同的ip地址的设备，即通过ping自己，寻找有自己的ip的主机<h4 id=\"ARP协议的包封装格式和抓包分析\"><a href=\"#ARP协议的包封装格式和抓包分析\" class=\"headerlink\" title=\"ARP协议的包封装格式和抓包分析\"></a>ARP协议的包封装格式和抓包分析</h4></li>\n<li>分组格式：  ()为字节数<br>mac头：以太网目的地址(6) mac源地址(6) 帧类型(2)(0x0806)<br>28byte arp帧：硬件类型(2)|协议类型(2)|硬件地址长度(1)|协议地址长度(1)|op(请求或应答或rarp 2)|发送端mac地址(6)|发送端ip(4)|接收端mac地址(6)|接收端ip(4)  </li>\n<li>请求广播帧：目的mac地址为全1，电缆上所有的以太网接口都要接收广播帧,硬件类型为1表示以太网地址，协议类型为要映射的协议地址类型0x0800,表示为ip地址，op（arp请求为1，答应为2，rarp请求为3，rarp答应为4）</li>\n<li>arp填充：以太网帧最小值为60，mac头14，所以=46，要填充：46-28=18个字节</li>\n<li>arp抓包，可以用wireshark,Omnipeek - Savvius,tcpdump,或者自己写一个程序来抓～<br>tcpdump : sudo tcpdump -vv arp  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> tcpdump: listening on wlp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">51</span>:<span class=\"number\">21.134575</span> ARP, Ethernet (len <span class=\"number\">6</span>), IPv4 (len <span class=\"number\">4</span>), Request who-has <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.101</span> tell <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>, length <span class=\"number\">28</span> <span class=\"comment\">//ap ask me</span></span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">51</span>:<span class=\"number\">21.135404</span> ARP, Ethernet (len <span class=\"number\">6</span>), IPv4 (len <span class=\"number\">4</span>), Request who-has <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.110</span> tell <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>, length <span class=\"number\">28</span></span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">51</span>:<span class=\"number\">21.135413</span> ARP, Ethernet (len <span class=\"number\">6</span>), IPv4 (len <span class=\"number\">4</span>), Reply <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.110</span> is-at <span class=\"number\">48</span>:<span class=\"number\">5</span>a:b6:<span class=\"number\">6</span>e:c9:<span class=\"number\">5f</span> (oui Unknown), length <span class=\"number\">28</span><span class=\"comment\">// i reply ap</span></span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">51</span>:<span class=\"number\">32.081916</span> ARP, Ethernet (len <span class=\"number\">6</span>), IPv4 (len <span class=\"number\">4</span>), Request who-has <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.106</span> tell <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>, length <span class=\"number\">28</span> <span class=\"comment\">//ask other</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">01</span>:<span class=\"number\">27.149947</span> ARP, Ethernet (len <span class=\"number\">6</span>), IPv4 (len <span class=\"number\">4</span>), Request who-has <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.107</span> tell <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>, length <span class=\"number\">28</span></span><br><span class=\"line\">\t<span class=\"number\">0x0000</span>:  <span class=\"number\">0001</span> <span class=\"number\">0800</span> <span class=\"number\">0604</span> <span class=\"number\">0001</span> <span class=\"number\">206b</span> e70f <span class=\"number\">1b</span>42 c0a8  .........k...B..</span><br><span class=\"line\">\t<span class=\"number\">0x0010</span>:  <span class=\"number\">0001</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> c0a8 <span class=\"number\">006b</span>            ...........k</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">22</span>:<span class=\"number\">04</span>:<span class=\"number\">17.114593</span> ARP, Ethernet (len <span class=\"number\">6</span>), IPv4 (len <span class=\"number\">4</span>), Reply <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.110</span> is-at <span class=\"number\">48</span>:<span class=\"number\">5</span>a:b6:<span class=\"number\">6</span>e:c9:<span class=\"number\">5f</span> (oui Unknown), length <span class=\"number\">28</span></span><br><span class=\"line\">\t<span class=\"number\">0x0000</span>:  <span class=\"number\">0001</span> <span class=\"number\">0800</span> <span class=\"number\">0604</span> <span class=\"number\">0002</span> <span class=\"number\">485</span>a b66e c95f c0a8  ........HZ.n._..</span><br><span class=\"line\">\t<span class=\"number\">0x0010</span>:  <span class=\"number\">006</span>e <span class=\"number\">206b</span> e70f <span class=\"number\">1b</span>42 c0a8 <span class=\"number\">0001</span>            .n.k...B....</span><br></pre></td></tr></table></figure>\n<h4 id=\"ARP协议的常用命令和调试分析\"><a href=\"#ARP协议的常用命令和调试分析\" class=\"headerlink\" title=\"ARP协议的常用命令和调试分析\"></a>ARP协议的常用命令和调试分析</h4><ul>\n<li>查看ARP缓存：即现在保存的arp映射表:  <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">arp</span> <span class=\"selector-tag\">-a</span></span><br><span class=\"line\">? (192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.101</span>) <span class=\"selector-tag\">at</span> 4<span class=\"selector-tag\">c</span><span class=\"selector-pseudo\">:32</span><span class=\"selector-pseudo\">:75</span><span class=\"selector-pseudo\">:3a</span><span class=\"selector-pseudo\">:09</span><span class=\"selector-pseudo\">:b3</span> <span class=\"selector-attr\">[ether]</span> <span class=\"selector-tag\">on</span> <span class=\"selector-tag\">wlp2s0</span></span><br><span class=\"line\">? (192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.1</span>) <span class=\"selector-tag\">at</span> 20<span class=\"selector-pseudo\">:6b</span><span class=\"selector-pseudo\">:e7</span><span class=\"selector-pseudo\">:0f</span><span class=\"selector-pseudo\">:1b</span><span class=\"selector-pseudo\">:42</span> <span class=\"selector-attr\">[ether]</span> <span class=\"selector-tag\">on</span> <span class=\"selector-tag\">wlp2s0</span></span><br><span class=\"line\">? (192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.108</span>) <span class=\"selector-tag\">at</span> 94<span class=\"selector-pseudo\">:d0</span><span class=\"selector-pseudo\">:29</span><span class=\"selector-pseudo\">:9d</span><span class=\"selector-pseudo\">:74</span><span class=\"selector-pseudo\">:dd</span> <span class=\"selector-attr\">[ether]</span> <span class=\"selector-tag\">on</span> <span class=\"selector-tag\">wlp2s0</span></span><br><span class=\"line\">? (192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.107</span>) <span class=\"selector-tag\">at</span> 94<span class=\"selector-pseudo\">:65</span><span class=\"selector-pseudo\">:2d</span><span class=\"selector-pseudo\">:ab</span><span class=\"selector-pseudo\">:88</span><span class=\"selector-pseudo\">:8b</span> <span class=\"selector-attr\">[ether]</span> <span class=\"selector-tag\">on</span> <span class=\"selector-tag\">wlp2s0</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">arp</span> </span><br><span class=\"line\"><span class=\"selector-tag\">Address</span>                  <span class=\"selector-tag\">HWtype</span>  <span class=\"selector-tag\">HWaddress</span>           <span class=\"selector-tag\">Flags</span> <span class=\"selector-tag\">Mask</span>            <span class=\"selector-tag\">Iface</span></span><br><span class=\"line\">192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.101</span>            <span class=\"selector-tag\">ether</span>   4<span class=\"selector-tag\">c</span><span class=\"selector-pseudo\">:32</span><span class=\"selector-pseudo\">:75</span><span class=\"selector-pseudo\">:3a</span><span class=\"selector-pseudo\">:09</span><span class=\"selector-pseudo\">:b3</span>   <span class=\"selector-tag\">C</span>                     <span class=\"selector-tag\">wlp2s0</span></span><br><span class=\"line\">192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.1</span>              <span class=\"selector-tag\">ether</span>   20<span class=\"selector-pseudo\">:6b</span><span class=\"selector-pseudo\">:e7</span><span class=\"selector-pseudo\">:0f</span><span class=\"selector-pseudo\">:1b</span><span class=\"selector-pseudo\">:42</span>   <span class=\"selector-tag\">C</span>                     <span class=\"selector-tag\">wlp2s0</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip neigh</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.101</span> dev wlp2s0 lladdr <span class=\"number\">4</span>c:<span class=\"number\">32</span>:<span class=\"number\">75</span>:<span class=\"number\">3</span>a:<span class=\"number\">09</span>:b3 STALE</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span> dev wlp2s0 lladdr <span class=\"number\">20</span>:<span class=\"number\">6b</span>:e7:<span class=\"number\">0f</span>:<span class=\"number\">1b</span>:<span class=\"number\">42</span> STALE</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.108</span> dev wlp2s0 lladdr <span class=\"number\">94</span>:d0:<span class=\"number\">29</span>:<span class=\"number\">9</span>d:<span class=\"number\">74</span>:dd STALE</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.107</span> dev wlp2s0 lladdr <span class=\"number\">94</span>:<span class=\"number\">65</span>:<span class=\"number\">2</span>d:ab:<span class=\"number\">88</span>:<span class=\"number\">8b</span> STALE</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.104</span> dev wlp2s0 lladdr e4:<span class=\"number\">9</span>a:dc:b0:a5:<span class=\"number\">36</span> STALE</span><br></pre></td></tr></table></figure>\n<ul>\n<li>arping命令：<br><a href=\"http://man.linuxde.net/arping\" target=\"_blank\" rel=\"noopener\">http://man.linuxde.net/arping</a></li>\n<li>arp 命令<br>man arp 包括删除arp表项等，有问题，找男人~<h4 id=\"ARP协议内核状态机\"><a href=\"#ARP协议内核状态机\" class=\"headerlink\" title=\"ARP协议内核状态机\"></a>ARP协议内核状态机</h4></li>\n<li>对不存在的主机，arp请求的超时机制  </li>\n<li>arp缓存和老化时间：<br><a href=\"http://www.jb51.net/LINUXjishu/65693.html：\" target=\"_blank\" rel=\"noopener\">http://www.jb51.net/LINUXjishu/65693.html：</a><br>改变老化时间：在Linux上如果你想设置你的ARP缓存老化时间，那么执行sysctl -w net.ipv4.neigh.ethX=Y即<h4 id=\"ARP协议的编程\"><a href=\"#ARP协议的编程\" class=\"headerlink\" title=\"ARP协议的编程\"></a>ARP协议的编程</h4></li>\n<li>在PF_PACKET中发出ARP包</li>\n<li>直接贴例子，具体可以看博客的PF_PACKET文章：<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ioctl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_packet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取硬件网卡的相应信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetEthInfor</span><span class=\"params\">(<span class=\"keyword\">char</span> *name , <span class=\"keyword\">char</span> *MAC_addr , struct in_addr * IP_addr)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//arp包的结构定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ARP_PACKET</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">       <span class=\"comment\">//以太网首部</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> dest_mac[<span class=\"number\">6</span>]; <span class=\"comment\">//6字节</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> sorce_mac[<span class=\"number\">6</span>];<span class=\"comment\">//6字节</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> type;       <span class=\"comment\">//2字节</span></span><br><span class=\"line\">  <span class=\"comment\">//arp——内容</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> hw_type;   <span class=\"comment\">//2字节：硬件地址类型     0x0001 表示mac地址</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> pro_type;  <span class=\"comment\">//2字节：软件地址类型    0x0806 表示IPV4地址</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> hw_len;     <span class=\"comment\">//1字节：硬件地址长度  </span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> pro_len;    <span class=\"comment\">//1字节：软件地址长度</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> op;        <span class=\"comment\">//2字节：操作类型           0x0001表示ARP请求；0x0002表示ARP应答</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> from_mac[<span class=\"number\">6</span>];<span class=\"comment\">//6字节</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> from_ip[<span class=\"number\">4</span>]; <span class=\"comment\">//4字节</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> to_mac[<span class=\"number\">6</span>];  <span class=\"comment\">//6字节</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> to_ip[<span class=\"number\">4</span>];   <span class=\"comment\">//4字节</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> padding[<span class=\"number\">18</span>];<span class=\"comment\">//18字节：填充字节，因为以太网数据最少要46字节</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> fd = <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> num=<span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> MAC_ADDR[<span class=\"number\">6</span>];</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">in_addr</span> <span class=\"title\">IP_ADDR</span>;</span><span class=\"comment\">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ARP_PACKET</span> <span class=\"title\">arp_pk</span>=&#123;</span><span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_ll</span> <span class=\"title\">eth_info</span>;</span><span class=\"comment\">//结构体的定义//在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class=\"line\"> <span class=\"comment\">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class=\"line\"> GetEthInfor(<span class=\"string\">\"wlp2s0\"</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class=\"line\">   <span class=\"comment\">/*printf(\"The MAC_addr is:\");</span></span><br><span class=\"line\"><span class=\"comment\"> for(i =0 ;i&lt;6;i++)</span></span><br><span class=\"line\"><span class=\"comment\">    printf(\"%4X\",MAC_ADDR[i]); </span></span><br><span class=\"line\"><span class=\"comment\"> printf(\"\\n\");</span></span><br><span class=\"line\"><span class=\"comment\">    printf(\"the IP is:%s\\n\",inet_ntoa(IP_ADDR));*/</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//第二步：填充ARP数据包的内容</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)                 <span class=\"comment\">//填充以太网首部的目的mac地址</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  arp_pk.dest_mac[i]=<span class=\"number\">0XFF</span>;      </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)                 <span class=\"comment\">//填充以太网首部的源mac地址</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  arp_pk.sorce_mac[i]=MAC_ADDR[i];</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">   arp_pk.type = htons(<span class=\"number\">0x0806</span>);    <span class=\"comment\">//填充以太网首部的侦类型</span></span><br><span class=\"line\">   arp_pk.hw_type = htons(<span class=\"number\">0x0001</span>); <span class=\"comment\">//填充硬件地址类型：0x0001表示的是MAC地址</span></span><br><span class=\"line\">   arp_pk.pro_type = htons(<span class=\"number\">0x0800</span>);<span class=\"comment\">//填充协议地址类型：0x0800表示的是IP地址</span></span><br><span class=\"line\">   arp_pk.hw_len = <span class=\"number\">6</span>;              <span class=\"comment\">//填充硬件地址长度</span></span><br><span class=\"line\">   arp_pk.pro_len = <span class=\"number\">4</span>;             <span class=\"comment\">//填充协议地址长度</span></span><br><span class=\"line\">   arp_pk.op = htons(<span class=\"number\">0x0001</span>);      <span class=\"comment\">//填充操作类型：0x0001表示ARP请求</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)                 <span class=\"comment\">//填充源mac地址</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">  arp_pk.from_mac[i]=MAC_ADDR[i];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">in_addr_t</span> ipaddr=inet_network(inet_ntoa(IP_ADDR));</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">3</span>;i&gt;=<span class=\"number\">0</span>;i--)                 <span class=\"comment\">//填充源IP地址</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">  arp_pk.from_ip[i]=(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>)ipaddr&amp;<span class=\"number\">0xFF</span>;</span><br><span class=\"line\">   ipaddr=ipaddr&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"-%d-\"</span>,arp_pk.from_ip[i]);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> <span class=\"comment\">/* arp_pk.from_ip[0]=192;</span></span><br><span class=\"line\"><span class=\"comment\">  arp_pk.from_ip[1]=168;</span></span><br><span class=\"line\"><span class=\"comment\">  arp_pk.from_ip[2]=199;</span></span><br><span class=\"line\"><span class=\"comment\">  arp_pk.from_ip[3]=145;*/</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)                 <span class=\"comment\">//填充欲获取的目的mac地址</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    arp_pk.to_mac[i]=<span class=\"number\">0X00</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   arp_pk.to_ip[<span class=\"number\">0</span>]=<span class=\"number\">0X0B</span>;        <span class=\"comment\">//填充想要装换为MAC地址的IP地址。可以使用命令行参数来做</span></span><br><span class=\"line\">   arp_pk.to_ip[<span class=\"number\">1</span>]=<span class=\"number\">0X40</span>;</span><br><span class=\"line\">   arp_pk.to_ip[<span class=\"number\">2</span>]=<span class=\"number\">0X39</span>;</span><br><span class=\"line\">   arp_pk.to_ip[<span class=\"number\">3</span>]=<span class=\"number\">0X0A</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//第三步：填充sockaddr_ll eth_info结构</span></span><br><span class=\"line\">    eth_info.sll_family = PF_PACKET;</span><br><span class=\"line\"> eth_info.sll_ifindex = if_nametoindex(<span class=\"string\">\"wlp2s0\"</span>);<span class=\"comment\">//返回输入的接口名称的索引值</span></span><br><span class=\"line\"> <span class=\"comment\">//printf(\"number is:%d\\n\",eth_info.sll_family);</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//第四步：创建原始套接字</span></span><br><span class=\"line\"> fd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));  <span class=\"comment\">//</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>(fd&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"socket SOCK_RAW failed!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//第五步：发送ARP数据包</span></span><br><span class=\"line\"> num = sendto(fd , &amp;arp_pk , <span class=\"keyword\">sizeof</span>(struct ARP_PACKET) , <span class=\"number\">0</span> ,(struct sockaddr*)(&amp;eth_info),<span class=\"keyword\">sizeof</span>(eth_info));</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(num&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"sendto failed!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">        <span class=\"comment\">//第六步：接受ARP应答</span></span><br><span class=\"line\"> num = recvfrom(fd , &amp;arp_pk , <span class=\"keyword\">sizeof</span>(struct ARP_PACKET) ,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span>(num&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"rcvfrom failed!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">else</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"I receive %d bytes!\\n\"</span>,num);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"the mac  is:\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4X \"</span>,arp_pk.from_mac[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"op:%d\\n\"</span>,arp_pk.op);</span><br><span class=\"line\"> <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d. \"</span>,arp_pk.to_ip[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> close(fd);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetEthInfor</span><span class=\"params\">(<span class=\"keyword\">char</span> *name ,  <span class=\"keyword\">char</span> *MAC_addr , struct in_addr * IP_addr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ifreq</span>  <span class=\"title\">eth</span>;</span>  <span class=\"comment\">//够结构用于存放最初多获取的接口信息</span></span><br><span class=\"line\"><span class=\"comment\">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> fd;             <span class=\"comment\">//用于创建套接字</span></span><br><span class=\"line\"> <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;         <span class=\"comment\">//用于验证接口调用</span></span><br><span class=\"line\"> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;            <span class=\"comment\">//用于循环</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"built_in\">strncpy</span>(eth.ifr_name,name,<span class=\"keyword\">sizeof</span>(struct ifreq)<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"comment\">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class=\"line\"> <span class=\"comment\">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class=\"line\">    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));</span><br><span class=\"line\"><span class=\"keyword\">if</span>(fd&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"socket failed!\\n\"</span>);</span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class=\"line\">   temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(temp&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"ioctl--get hardware addr failed!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> <span class=\"built_in\">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class=\"number\">6</span>);</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"The MAC_addr is:\"</span>);</span><br><span class=\"line\"> <span class=\"keyword\">for</span>(i =<span class=\"number\">0</span> ;i&lt;<span class=\"number\">6</span>;i++)</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4X\"</span>,(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"comment\">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class=\"line\">   temp = ioctl(fd,SIOCGIFADDR,&amp;eth);</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(temp&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"ioctl--get hardware addr failed!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> <span class=\"built_in\">memcpy</span>(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class=\"number\">4</span>);</span><br><span class=\"line\"> <span class=\"comment\">//关闭套接口</span></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"got ipaddr:%s\\n\"</span>,inet_ntoa(*IP_addr));</span><br><span class=\"line\"><span class=\"comment\">/*i=0;</span></span><br><span class=\"line\"><span class=\"comment\">printf(\"get the MAC_ADDR:\\n\");</span></span><br><span class=\"line\"><span class=\"comment\">for(i;i&lt;6;i++)</span></span><br><span class=\"line\"><span class=\"comment\">  printf(\"%.2X:\",MAC_addr[i]&amp;0xFF);*/</span></span><br><span class=\"line\">   close(fd);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第二步填充arp数据包的时候，填充的数据和类型根据需要进行。</span></span><br><span class=\"line\"><span class=\"comment\">//这里的arp数据包结构体是自己定义的，也可以是利用linux的相关结构：</span></span><br><span class=\"line\"><span class=\"comment\">/*eg:</span></span><br><span class=\"line\"><span class=\"comment\">typedef struct _tagARP_PACKET&#123;    </span></span><br><span class=\"line\"><span class=\"comment\">    struct ether_header  eh;    ///net/ethernet.h</span></span><br><span class=\"line\"><span class=\"comment\">    struct ether_arp arp;    </span></span><br><span class=\"line\"><span class=\"comment\">&#125;ARP_PACKET_OBJ, *ARP_PACKET_HANDLE; /netinet/if_ether.h;/net/if_arp.h</span></span><br><span class=\"line\"><span class=\"comment\">各个字段的填充见头文件*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*第三步：填充sockaddr_ll eth_info结构,关键是填充网络接口索引值，最直接的方法是上面的函数，</span></span><br><span class=\"line\"><span class=\"comment\">还有另外的方法:利用ioctl函数获取struct ifreq结构的信息，该结构放置了很多网络接口的相关信息*/</span></span><br><span class=\"line\"><span class=\"comment\">/*  struct sockaddr_ll&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    unsigned short sll_family; //总是 AF_PACKET </span></span><br><span class=\"line\"><span class=\"comment\">    unsigned short sll_protocol; // 物理层的协议 </span></span><br><span class=\"line\"><span class=\"comment\">    int sll_ifindex; //接口号 </span></span><br><span class=\"line\"><span class=\"comment\">    unsigned short sll_hatype; // 报头类型 </span></span><br><span class=\"line\"><span class=\"comment\">    unsigned char sll_pkttype; // 分组类型 </span></span><br><span class=\"line\"><span class=\"comment\">    unsigned char sll_halen; // 地址长度 </span></span><br><span class=\"line\"><span class=\"comment\">    unsigned char sll_addr[8]; // 物理层地址 </span></span><br><span class=\"line\"><span class=\"comment\">&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">eg:</span></span><br><span class=\"line\"><span class=\"comment\">*     struct sockaddr_ll peer_addr;  </span></span><br><span class=\"line\"><span class=\"comment\">*    memset(&amp;peer_addr, 0, sizeof(peer_addr));    </span></span><br><span class=\"line\"><span class=\"comment\">        peer_addr.sll_family = AF_PACKET;    </span></span><br><span class=\"line\"><span class=\"comment\">        struct ifreq req;  </span></span><br><span class=\"line\"><span class=\"comment\">    bzero(&amp;req, sizeof(struct ifreq));  </span></span><br><span class=\"line\"><span class=\"comment\">        strcpy(req.ifr_name, \"eth0\");    </span></span><br><span class=\"line\"><span class=\"comment\">        if(ioctl(sockfd, SIOCGIFINDEX, &amp;req) != 0)  </span></span><br><span class=\"line\"><span class=\"comment\">        perror(\"ioctl()\");    </span></span><br><span class=\"line\"><span class=\"comment\">        peer_addr.sll_ifindex = req.ifr_ifindex;    </span></span><br><span class=\"line\"><span class=\"comment\">        peer_addr.sll_protocol = htons(ETH_P_ARP);  </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">/*第四步，创建套结字的时候，有以下的组合：更多见：man packet</span></span><br><span class=\"line\"><span class=\"comment\"> * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</span></span><br><span class=\"line\"><span class=\"comment\"> * 第二个参数： 2）套接字类型：</span></span><br><span class=\"line\"><span class=\"comment\">          SOCK_DGRAM----以太网头已经构造好了</span></span><br><span class=\"line\"><span class=\"comment\">          SOCK_RAW------自己构造以太头 </span></span><br><span class=\"line\"><span class=\"comment\">          * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字</span></span><br><span class=\"line\"><span class=\"comment\">          * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），</span></span><br><span class=\"line\"><span class=\"comment\">          * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，</span></span><br><span class=\"line\"><span class=\"comment\">          * 而发送时也无须用户添加头部字段。</span></span><br><span class=\"line\"><span class=\"comment\">   第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP</span></span><br><span class=\"line\"><span class=\"comment\">   * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：</span></span><br><span class=\"line\"><span class=\"comment\">   1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)</span></span><br><span class=\"line\"><span class=\"comment\">  和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)</span></span><br><span class=\"line\"><span class=\"comment\">    2)IEEE维护的注册以太网类型列表</span></span><br><span class=\"line\"><span class=\"comment\">     3）半官方的列表由IANA维护</span></span><br><span class=\"line\"><span class=\"comment\">      ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。</span></span><br><span class=\"line\"><span class=\"comment\">      0x88b5和0x88b6是保留以太网类型，供实验或私人使用。 </span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">   <span class=\"comment\">/*第五步发送和接收套接字的函数可以是read write操作套结字，也可以是上文的UDP无连接用的函数*/</span></span><br></pre></td></tr></table></figure>\n<p>处理的时候可能需要获取网关的ip地址：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*proc方法获取网关地址*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetGateWayIP</span><span class=\"params\">(uint8 *ip_addr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">char</span> inf[<span class=\"number\">100</span>];</span><br><span class=\"line\">      FILE *file_fd;</span><br><span class=\"line\">      uint8 high=<span class=\"number\">0</span>,low=<span class=\"number\">0</span>,value;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">      file_fd = fopen(<span class=\"string\">\"/proc/net/route\"</span>,<span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(file_fd==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"can not open /proc/net/route\\n\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">             <span class=\"keyword\">while</span>(!feof(file_fd))</span><br><span class=\"line\">             &#123;</span><br><span class=\"line\">                     <span class=\"built_in\">memset</span>(inf,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(inf));</span><br><span class=\"line\">                     fgets(inf,<span class=\"number\">100</span>,file_fd);</span><br><span class=\"line\">                     <span class=\"keyword\">if</span>(inf[<span class=\"number\">5</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">6</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">7</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">8</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">9</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">10</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">11</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">12</span>]==<span class=\"string\">'0'</span>)</span><br><span class=\"line\">                     &#123;</span><br><span class=\"line\">                              <span class=\"keyword\">for</span>(i=<span class=\"number\">20</span>;i&gt;=<span class=\"number\">14</span>;i-=<span class=\"number\">2</span>)</span><br><span class=\"line\">                              &#123;</span><br><span class=\"line\">                                         <span class=\"keyword\">if</span>(inf[i]&gt;=<span class=\"number\">65</span>)</span><br><span class=\"line\">                                                 high = inf[i]<span class=\"number\">-55</span>;</span><br><span class=\"line\">                                         <span class=\"keyword\">else</span></span><br><span class=\"line\">                                                 high = inf[i]<span class=\"number\">-48</span>;</span><br><span class=\"line\">                                         <span class=\"keyword\">if</span>(inf[i+<span class=\"number\">1</span>]&gt;=<span class=\"number\">65</span>)</span><br><span class=\"line\">                                                 low = inf[i+<span class=\"number\">1</span>]<span class=\"number\">-55</span>;</span><br><span class=\"line\">                                         <span class=\"keyword\">else</span></span><br><span class=\"line\">                                                 low = inf[i+<span class=\"number\">1</span>]<span class=\"number\">-48</span>;</span><br><span class=\"line\">                                        value = high*<span class=\"number\">16</span>+low;</span><br><span class=\"line\">                                       ip_addr[<span class=\"number\">10</span>-i/<span class=\"number\">2</span>] = value;</span><br><span class=\"line\">                              &#125;</span><br><span class=\"line\">                              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ARP攻击\"><a href=\"#ARP攻击\" class=\"headerlink\" title=\"ARP攻击\"></a>ARP攻击</h4><ul>\n<li>ARP包可以直接发送给对端不经过路由器，有趣<br>在一个局域网中，客户端的几乎所有的包都是发往路由器的，这归结于默认路由设置，而在无线网，网卡其实可以接收所有数据，毕竟空气介质，所以，局域网中的设备可以直接通信<br>实验：在文件全能王中开启wifi文件传输，和它在同一个局域网的sta能访问该地址，抓包，发现目的地址和源地址都为同一个局域网的不同ip,且不为路由器网关ip，证明其两个设备是可以直接通信的</li>\n<li>再来做一个实验：通过pf_packet<br>1、在电脑A上写一个程序，mac目的地址为B,源地址为A,协议类型随机，数据随意，发送给B<br> 同时在B端进行接收，过滤掉其他mac地址，看是否可以接收到，在连接ap和不连接ap的条件下<br>2、在A和B设置静态ip地址，且不同网段，都不连接AP ,让A向B 发送ARP请求包，B接收到后回复arp响应包，接着做ping或其他操作，看是否能互相通信</li>\n<li>编程可以参考上述程序，改一下地址什么的就可以，或者参考其他：<br><a href=\"http://www.freebuf.com/articles/system/5157.html\" target=\"_blank\" rel=\"noopener\">http://www.freebuf.com/articles/system/5157.html</a><br>这篇文章讲的很具体，个人也喜欢这个网站，emm,实验过了，还可以，can also make your own program,具体程序不贴了  </li>\n<li>arp欺骗的基本原理：<br>在局域网中，设备A,B连接同一个路由器，他们之间可以直接相互通信，因此可以直接向对方发送arp包；<br>设备A ,B都会定期和AP交互arp请求和回复，相互知道对方的mac地址，这样，就能给ap发送请求，ap也能知道回复给谁；<br>arp欺骗的基本原理在于，如B是攻击方，则B向A发送ARP回复自己是AP ,即在ARP回复包中带上自己的mac地址，ap的ip地址；<br>同时向AP回复自己是A，即带上A的ip地址，自己的mac地址；<br>这样A就会以为B是AP，就会把请求发给B ,同时AP以为B是A，会把回复传给B,但是同时得配置B的转发功能，<br>echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot<br>该博文中有一处错误，见评论</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"ARP-协议\"><a href=\"#ARP-协议\" class=\"headerlink\" title=\"ARP 协议\"></a>ARP 协议</h3><h4 id=\"ARP协议的作用\"><a href=\"#ARP协议的作用\" class=\"headerlink\" title=\"ARP协议的作用\"></a>ARP协议的作用</h4><ul>\n<li>ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信；</li>\n<li>在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：<br>端设备手机pc等–&gt;(交换机)路由器—&gt;下一个路由器—&gt;下一个终端设备","more":"<br>端设备默认路由到网关–&gt;网关收到包后，将源地址改为网关的外网地址—&gt;下一个路由–&gt;….-&gt;设备地址为目的地址时，接收而不转发</li>\n<li>考虑一个问题：在上述的网络上发送时，如pc发给路由器时，只知道它的ip地址，怎么发给它：<br>即端到端的发送：是借助设备唯一的mac地址来发送的<br>在有线网中。利用了交换机的端口和mac地址关系，转发<br>在wifi中，能接收到所有的包，但是会在驱动中将mac目的地址非本地的包丢弃，除非开启了混杂监听模式</li>\n<li>但是路由器怎么知道设备如手机的mac地址呢？<br>通过arp协议来获取，arp是依赖mac和ip的”映射”</li>\n<li>tcpip卷1中4.2举了一个完整的例子，可以去看<h4 id=\"ARP协议的交互过程\"><a href=\"#ARP协议的交互过程\" class=\"headerlink\" title=\"ARP协议的交互过程\"></a>ARP协议的交互过程</h4></li>\n<li>基本的交互方式：<br>例如ping网关：<br>station  —ARP request—-&gt;   AP  ARP请求，广播帧<br>station  &lt;—ARP response —  AP  ARP应答 ,单播帧<br>通过上述的方式，station得到了AP的mac地址，之后将AP的MAC地址存在缓存中，在下次数据包等包的时候就可以将该mac地址填在mac头中，即知道了AP的地址后，包就可以顺利的被AP接收了</li>\n<li>AP(路由器)也会主动的向station发送arp request，当它不知道station的mac地址（或缓存过期），例如，AP收到一个外网的包，要转发给对应192.168.0.4的staton,但是没有他的mac地址，或者过期了或者其他情况，则向该station发出arp请求。从而得打station的mac地址</li>\n<li>什么时候会触发arp请求？<br>1.在ping的时候<br>2.在发送tcp，ip包的时候<br>3.在缓存过期时主动发出，这个由arp状态机中实现<h4 id=\"ARP代理和免费ARP\"><a href=\"#ARP代理和免费ARP\" class=\"headerlink\" title=\"ARP代理和免费ARP\"></a>ARP代理和免费ARP</h4></li>\n<li>当我们通过ping百度，或者想访问百度的时候，怎么在mac头中填写目的mac地址呢？即怎么找到百度?（另一个网络)</li>\n<li>是通过在mac头目的mac地址填写网关的mac地址实现的，借助w网关的来帮我们寻找，这个叫做ARP代理,其实欺骗了主机</li>\n<li>tcpip卷对此有较详细解说4.6</li>\n<li>免费ARP是用于检测是否周围有使用相同的ip地址的设备，即通过ping自己，寻找有自己的ip的主机<h4 id=\"ARP协议的包封装格式和抓包分析\"><a href=\"#ARP协议的包封装格式和抓包分析\" class=\"headerlink\" title=\"ARP协议的包封装格式和抓包分析\"></a>ARP协议的包封装格式和抓包分析</h4></li>\n<li>分组格式：  ()为字节数<br>mac头：以太网目的地址(6) mac源地址(6) 帧类型(2)(0x0806)<br>28byte arp帧：硬件类型(2)|协议类型(2)|硬件地址长度(1)|协议地址长度(1)|op(请求或应答或rarp 2)|发送端mac地址(6)|发送端ip(4)|接收端mac地址(6)|接收端ip(4)  </li>\n<li>请求广播帧：目的mac地址为全1，电缆上所有的以太网接口都要接收广播帧,硬件类型为1表示以太网地址，协议类型为要映射的协议地址类型0x0800,表示为ip地址，op（arp请求为1，答应为2，rarp请求为3，rarp答应为4）</li>\n<li>arp填充：以太网帧最小值为60，mac头14，所以=46，要填充：46-28=18个字节</li>\n<li>arp抓包，可以用wireshark,Omnipeek - Savvius,tcpdump,或者自己写一个程序来抓～<br>tcpdump : sudo tcpdump -vv arp  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> tcpdump: listening on wlp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">51</span>:<span class=\"number\">21.134575</span> ARP, Ethernet (len <span class=\"number\">6</span>), IPv4 (len <span class=\"number\">4</span>), Request who-has <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.101</span> tell <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>, length <span class=\"number\">28</span> <span class=\"comment\">//ap ask me</span></span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">51</span>:<span class=\"number\">21.135404</span> ARP, Ethernet (len <span class=\"number\">6</span>), IPv4 (len <span class=\"number\">4</span>), Request who-has <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.110</span> tell <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>, length <span class=\"number\">28</span></span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">51</span>:<span class=\"number\">21.135413</span> ARP, Ethernet (len <span class=\"number\">6</span>), IPv4 (len <span class=\"number\">4</span>), Reply <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.110</span> is-at <span class=\"number\">48</span>:<span class=\"number\">5</span>a:b6:<span class=\"number\">6</span>e:c9:<span class=\"number\">5f</span> (oui Unknown), length <span class=\"number\">28</span><span class=\"comment\">// i reply ap</span></span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">51</span>:<span class=\"number\">32.081916</span> ARP, Ethernet (len <span class=\"number\">6</span>), IPv4 (len <span class=\"number\">4</span>), Request who-has <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.106</span> tell <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>, length <span class=\"number\">28</span> <span class=\"comment\">//ask other</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">01</span>:<span class=\"number\">27.149947</span> ARP, Ethernet (len <span class=\"number\">6</span>), IPv4 (len <span class=\"number\">4</span>), Request who-has <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.107</span> tell <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>, length <span class=\"number\">28</span></span><br><span class=\"line\">\t<span class=\"number\">0x0000</span>:  <span class=\"number\">0001</span> <span class=\"number\">0800</span> <span class=\"number\">0604</span> <span class=\"number\">0001</span> <span class=\"number\">206b</span> e70f <span class=\"number\">1b</span>42 c0a8  .........k...B..</span><br><span class=\"line\">\t<span class=\"number\">0x0010</span>:  <span class=\"number\">0001</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span> c0a8 <span class=\"number\">006b</span>            ...........k</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">22</span>:<span class=\"number\">04</span>:<span class=\"number\">17.114593</span> ARP, Ethernet (len <span class=\"number\">6</span>), IPv4 (len <span class=\"number\">4</span>), Reply <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.110</span> is-at <span class=\"number\">48</span>:<span class=\"number\">5</span>a:b6:<span class=\"number\">6</span>e:c9:<span class=\"number\">5f</span> (oui Unknown), length <span class=\"number\">28</span></span><br><span class=\"line\">\t<span class=\"number\">0x0000</span>:  <span class=\"number\">0001</span> <span class=\"number\">0800</span> <span class=\"number\">0604</span> <span class=\"number\">0002</span> <span class=\"number\">485</span>a b66e c95f c0a8  ........HZ.n._..</span><br><span class=\"line\">\t<span class=\"number\">0x0010</span>:  <span class=\"number\">006</span>e <span class=\"number\">206b</span> e70f <span class=\"number\">1b</span>42 c0a8 <span class=\"number\">0001</span>            .n.k...B....</span><br></pre></td></tr></table></figure>\n<h4 id=\"ARP协议的常用命令和调试分析\"><a href=\"#ARP协议的常用命令和调试分析\" class=\"headerlink\" title=\"ARP协议的常用命令和调试分析\"></a>ARP协议的常用命令和调试分析</h4><ul>\n<li>查看ARP缓存：即现在保存的arp映射表:  <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">arp</span> <span class=\"selector-tag\">-a</span></span><br><span class=\"line\">? (192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.101</span>) <span class=\"selector-tag\">at</span> 4<span class=\"selector-tag\">c</span><span class=\"selector-pseudo\">:32</span><span class=\"selector-pseudo\">:75</span><span class=\"selector-pseudo\">:3a</span><span class=\"selector-pseudo\">:09</span><span class=\"selector-pseudo\">:b3</span> <span class=\"selector-attr\">[ether]</span> <span class=\"selector-tag\">on</span> <span class=\"selector-tag\">wlp2s0</span></span><br><span class=\"line\">? (192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.1</span>) <span class=\"selector-tag\">at</span> 20<span class=\"selector-pseudo\">:6b</span><span class=\"selector-pseudo\">:e7</span><span class=\"selector-pseudo\">:0f</span><span class=\"selector-pseudo\">:1b</span><span class=\"selector-pseudo\">:42</span> <span class=\"selector-attr\">[ether]</span> <span class=\"selector-tag\">on</span> <span class=\"selector-tag\">wlp2s0</span></span><br><span class=\"line\">? (192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.108</span>) <span class=\"selector-tag\">at</span> 94<span class=\"selector-pseudo\">:d0</span><span class=\"selector-pseudo\">:29</span><span class=\"selector-pseudo\">:9d</span><span class=\"selector-pseudo\">:74</span><span class=\"selector-pseudo\">:dd</span> <span class=\"selector-attr\">[ether]</span> <span class=\"selector-tag\">on</span> <span class=\"selector-tag\">wlp2s0</span></span><br><span class=\"line\">? (192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.107</span>) <span class=\"selector-tag\">at</span> 94<span class=\"selector-pseudo\">:65</span><span class=\"selector-pseudo\">:2d</span><span class=\"selector-pseudo\">:ab</span><span class=\"selector-pseudo\">:88</span><span class=\"selector-pseudo\">:8b</span> <span class=\"selector-attr\">[ether]</span> <span class=\"selector-tag\">on</span> <span class=\"selector-tag\">wlp2s0</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">arp</span> </span><br><span class=\"line\"><span class=\"selector-tag\">Address</span>                  <span class=\"selector-tag\">HWtype</span>  <span class=\"selector-tag\">HWaddress</span>           <span class=\"selector-tag\">Flags</span> <span class=\"selector-tag\">Mask</span>            <span class=\"selector-tag\">Iface</span></span><br><span class=\"line\">192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.101</span>            <span class=\"selector-tag\">ether</span>   4<span class=\"selector-tag\">c</span><span class=\"selector-pseudo\">:32</span><span class=\"selector-pseudo\">:75</span><span class=\"selector-pseudo\">:3a</span><span class=\"selector-pseudo\">:09</span><span class=\"selector-pseudo\">:b3</span>   <span class=\"selector-tag\">C</span>                     <span class=\"selector-tag\">wlp2s0</span></span><br><span class=\"line\">192<span class=\"selector-class\">.168</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.1</span>              <span class=\"selector-tag\">ether</span>   20<span class=\"selector-pseudo\">:6b</span><span class=\"selector-pseudo\">:e7</span><span class=\"selector-pseudo\">:0f</span><span class=\"selector-pseudo\">:1b</span><span class=\"selector-pseudo\">:42</span>   <span class=\"selector-tag\">C</span>                     <span class=\"selector-tag\">wlp2s0</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ip neigh</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.101</span> dev wlp2s0 lladdr <span class=\"number\">4</span>c:<span class=\"number\">32</span>:<span class=\"number\">75</span>:<span class=\"number\">3</span>a:<span class=\"number\">09</span>:b3 STALE</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span> dev wlp2s0 lladdr <span class=\"number\">20</span>:<span class=\"number\">6b</span>:e7:<span class=\"number\">0f</span>:<span class=\"number\">1b</span>:<span class=\"number\">42</span> STALE</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.108</span> dev wlp2s0 lladdr <span class=\"number\">94</span>:d0:<span class=\"number\">29</span>:<span class=\"number\">9</span>d:<span class=\"number\">74</span>:dd STALE</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.107</span> dev wlp2s0 lladdr <span class=\"number\">94</span>:<span class=\"number\">65</span>:<span class=\"number\">2</span>d:ab:<span class=\"number\">88</span>:<span class=\"number\">8b</span> STALE</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.104</span> dev wlp2s0 lladdr e4:<span class=\"number\">9</span>a:dc:b0:a5:<span class=\"number\">36</span> STALE</span><br></pre></td></tr></table></figure>\n<ul>\n<li>arping命令：<br><a href=\"http://man.linuxde.net/arping\" target=\"_blank\" rel=\"noopener\">http://man.linuxde.net/arping</a></li>\n<li>arp 命令<br>man arp 包括删除arp表项等，有问题，找男人~<h4 id=\"ARP协议内核状态机\"><a href=\"#ARP协议内核状态机\" class=\"headerlink\" title=\"ARP协议内核状态机\"></a>ARP协议内核状态机</h4></li>\n<li>对不存在的主机，arp请求的超时机制  </li>\n<li>arp缓存和老化时间：<br><a href=\"http://www.jb51.net/LINUXjishu/65693.html：\" target=\"_blank\" rel=\"noopener\">http://www.jb51.net/LINUXjishu/65693.html：</a><br>改变老化时间：在Linux上如果你想设置你的ARP缓存老化时间，那么执行sysctl -w net.ipv4.neigh.ethX=Y即<h4 id=\"ARP协议的编程\"><a href=\"#ARP协议的编程\" class=\"headerlink\" title=\"ARP协议的编程\"></a>ARP协议的编程</h4></li>\n<li>在PF_PACKET中发出ARP包</li>\n<li>直接贴例子，具体可以看博客的PF_PACKET文章：<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ioctl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_packet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取硬件网卡的相应信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetEthInfor</span><span class=\"params\">(<span class=\"keyword\">char</span> *name , <span class=\"keyword\">char</span> *MAC_addr , struct in_addr * IP_addr)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//arp包的结构定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ARP_PACKET</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">       <span class=\"comment\">//以太网首部</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> dest_mac[<span class=\"number\">6</span>]; <span class=\"comment\">//6字节</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> sorce_mac[<span class=\"number\">6</span>];<span class=\"comment\">//6字节</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> type;       <span class=\"comment\">//2字节</span></span><br><span class=\"line\">  <span class=\"comment\">//arp——内容</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> hw_type;   <span class=\"comment\">//2字节：硬件地址类型     0x0001 表示mac地址</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> pro_type;  <span class=\"comment\">//2字节：软件地址类型    0x0806 表示IPV4地址</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> hw_len;     <span class=\"comment\">//1字节：硬件地址长度  </span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> pro_len;    <span class=\"comment\">//1字节：软件地址长度</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> op;        <span class=\"comment\">//2字节：操作类型           0x0001表示ARP请求；0x0002表示ARP应答</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> from_mac[<span class=\"number\">6</span>];<span class=\"comment\">//6字节</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> from_ip[<span class=\"number\">4</span>]; <span class=\"comment\">//4字节</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> to_mac[<span class=\"number\">6</span>];  <span class=\"comment\">//6字节</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> to_ip[<span class=\"number\">4</span>];   <span class=\"comment\">//4字节</span></span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> padding[<span class=\"number\">18</span>];<span class=\"comment\">//18字节：填充字节，因为以太网数据最少要46字节</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> fd = <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> num=<span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> MAC_ADDR[<span class=\"number\">6</span>];</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">in_addr</span> <span class=\"title\">IP_ADDR</span>;</span><span class=\"comment\">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ARP_PACKET</span> <span class=\"title\">arp_pk</span>=&#123;</span><span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_ll</span> <span class=\"title\">eth_info</span>;</span><span class=\"comment\">//结构体的定义//在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class=\"line\"> <span class=\"comment\">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class=\"line\"> GetEthInfor(<span class=\"string\">\"wlp2s0\"</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class=\"line\">   <span class=\"comment\">/*printf(\"The MAC_addr is:\");</span></span><br><span class=\"line\"><span class=\"comment\"> for(i =0 ;i&lt;6;i++)</span></span><br><span class=\"line\"><span class=\"comment\">    printf(\"%4X\",MAC_ADDR[i]); </span></span><br><span class=\"line\"><span class=\"comment\"> printf(\"\\n\");</span></span><br><span class=\"line\"><span class=\"comment\">    printf(\"the IP is:%s\\n\",inet_ntoa(IP_ADDR));*/</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//第二步：填充ARP数据包的内容</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)                 <span class=\"comment\">//填充以太网首部的目的mac地址</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  arp_pk.dest_mac[i]=<span class=\"number\">0XFF</span>;      </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"> <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)                 <span class=\"comment\">//填充以太网首部的源mac地址</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  arp_pk.sorce_mac[i]=MAC_ADDR[i];</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">   arp_pk.type = htons(<span class=\"number\">0x0806</span>);    <span class=\"comment\">//填充以太网首部的侦类型</span></span><br><span class=\"line\">   arp_pk.hw_type = htons(<span class=\"number\">0x0001</span>); <span class=\"comment\">//填充硬件地址类型：0x0001表示的是MAC地址</span></span><br><span class=\"line\">   arp_pk.pro_type = htons(<span class=\"number\">0x0800</span>);<span class=\"comment\">//填充协议地址类型：0x0800表示的是IP地址</span></span><br><span class=\"line\">   arp_pk.hw_len = <span class=\"number\">6</span>;              <span class=\"comment\">//填充硬件地址长度</span></span><br><span class=\"line\">   arp_pk.pro_len = <span class=\"number\">4</span>;             <span class=\"comment\">//填充协议地址长度</span></span><br><span class=\"line\">   arp_pk.op = htons(<span class=\"number\">0x0001</span>);      <span class=\"comment\">//填充操作类型：0x0001表示ARP请求</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)                 <span class=\"comment\">//填充源mac地址</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">  arp_pk.from_mac[i]=MAC_ADDR[i];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">in_addr_t</span> ipaddr=inet_network(inet_ntoa(IP_ADDR));</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">3</span>;i&gt;=<span class=\"number\">0</span>;i--)                 <span class=\"comment\">//填充源IP地址</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">  arp_pk.from_ip[i]=(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>)ipaddr&amp;<span class=\"number\">0xFF</span>;</span><br><span class=\"line\">   ipaddr=ipaddr&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"-%d-\"</span>,arp_pk.from_ip[i]);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> <span class=\"comment\">/* arp_pk.from_ip[0]=192;</span></span><br><span class=\"line\"><span class=\"comment\">  arp_pk.from_ip[1]=168;</span></span><br><span class=\"line\"><span class=\"comment\">  arp_pk.from_ip[2]=199;</span></span><br><span class=\"line\"><span class=\"comment\">  arp_pk.from_ip[3]=145;*/</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)                 <span class=\"comment\">//填充欲获取的目的mac地址</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">    arp_pk.to_mac[i]=<span class=\"number\">0X00</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   arp_pk.to_ip[<span class=\"number\">0</span>]=<span class=\"number\">0X0B</span>;        <span class=\"comment\">//填充想要装换为MAC地址的IP地址。可以使用命令行参数来做</span></span><br><span class=\"line\">   arp_pk.to_ip[<span class=\"number\">1</span>]=<span class=\"number\">0X40</span>;</span><br><span class=\"line\">   arp_pk.to_ip[<span class=\"number\">2</span>]=<span class=\"number\">0X39</span>;</span><br><span class=\"line\">   arp_pk.to_ip[<span class=\"number\">3</span>]=<span class=\"number\">0X0A</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//第三步：填充sockaddr_ll eth_info结构</span></span><br><span class=\"line\">    eth_info.sll_family = PF_PACKET;</span><br><span class=\"line\"> eth_info.sll_ifindex = if_nametoindex(<span class=\"string\">\"wlp2s0\"</span>);<span class=\"comment\">//返回输入的接口名称的索引值</span></span><br><span class=\"line\"> <span class=\"comment\">//printf(\"number is:%d\\n\",eth_info.sll_family);</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//第四步：创建原始套接字</span></span><br><span class=\"line\"> fd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));  <span class=\"comment\">//</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>(fd&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"socket SOCK_RAW failed!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//第五步：发送ARP数据包</span></span><br><span class=\"line\"> num = sendto(fd , &amp;arp_pk , <span class=\"keyword\">sizeof</span>(struct ARP_PACKET) , <span class=\"number\">0</span> ,(struct sockaddr*)(&amp;eth_info),<span class=\"keyword\">sizeof</span>(eth_info));</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(num&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"sendto failed!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">        <span class=\"comment\">//第六步：接受ARP应答</span></span><br><span class=\"line\"> num = recvfrom(fd , &amp;arp_pk , <span class=\"keyword\">sizeof</span>(struct ARP_PACKET) ,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span>(num&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"rcvfrom failed!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">else</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"I receive %d bytes!\\n\"</span>,num);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"the mac  is:\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4X \"</span>,arp_pk.from_mac[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"op:%d\\n\"</span>,arp_pk.op);</span><br><span class=\"line\"> <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d. \"</span>,arp_pk.to_ip[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> close(fd);</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetEthInfor</span><span class=\"params\">(<span class=\"keyword\">char</span> *name ,  <span class=\"keyword\">char</span> *MAC_addr , struct in_addr * IP_addr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ifreq</span>  <span class=\"title\">eth</span>;</span>  <span class=\"comment\">//够结构用于存放最初多获取的接口信息</span></span><br><span class=\"line\"><span class=\"comment\">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> fd;             <span class=\"comment\">//用于创建套接字</span></span><br><span class=\"line\"> <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;         <span class=\"comment\">//用于验证接口调用</span></span><br><span class=\"line\"> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;            <span class=\"comment\">//用于循环</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"built_in\">strncpy</span>(eth.ifr_name,name,<span class=\"keyword\">sizeof</span>(struct ifreq)<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"comment\">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class=\"line\"> <span class=\"comment\">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class=\"line\">    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));</span><br><span class=\"line\"><span class=\"keyword\">if</span>(fd&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"socket failed!\\n\"</span>);</span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class=\"line\">   temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(temp&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"ioctl--get hardware addr failed!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> <span class=\"built_in\">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class=\"number\">6</span>);</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"The MAC_addr is:\"</span>);</span><br><span class=\"line\"> <span class=\"keyword\">for</span>(i =<span class=\"number\">0</span> ;i&lt;<span class=\"number\">6</span>;i++)</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4X\"</span>,(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"comment\">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class=\"line\">   temp = ioctl(fd,SIOCGIFADDR,&amp;eth);</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(temp&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"ioctl--get hardware addr failed!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> <span class=\"built_in\">memcpy</span>(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class=\"number\">4</span>);</span><br><span class=\"line\"> <span class=\"comment\">//关闭套接口</span></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"got ipaddr:%s\\n\"</span>,inet_ntoa(*IP_addr));</span><br><span class=\"line\"><span class=\"comment\">/*i=0;</span></span><br><span class=\"line\"><span class=\"comment\">printf(\"get the MAC_ADDR:\\n\");</span></span><br><span class=\"line\"><span class=\"comment\">for(i;i&lt;6;i++)</span></span><br><span class=\"line\"><span class=\"comment\">  printf(\"%.2X:\",MAC_addr[i]&amp;0xFF);*/</span></span><br><span class=\"line\">   close(fd);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第二步填充arp数据包的时候，填充的数据和类型根据需要进行。</span></span><br><span class=\"line\"><span class=\"comment\">//这里的arp数据包结构体是自己定义的，也可以是利用linux的相关结构：</span></span><br><span class=\"line\"><span class=\"comment\">/*eg:</span></span><br><span class=\"line\"><span class=\"comment\">typedef struct _tagARP_PACKET&#123;    </span></span><br><span class=\"line\"><span class=\"comment\">    struct ether_header  eh;    ///net/ethernet.h</span></span><br><span class=\"line\"><span class=\"comment\">    struct ether_arp arp;    </span></span><br><span class=\"line\"><span class=\"comment\">&#125;ARP_PACKET_OBJ, *ARP_PACKET_HANDLE; /netinet/if_ether.h;/net/if_arp.h</span></span><br><span class=\"line\"><span class=\"comment\">各个字段的填充见头文件*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*第三步：填充sockaddr_ll eth_info结构,关键是填充网络接口索引值，最直接的方法是上面的函数，</span></span><br><span class=\"line\"><span class=\"comment\">还有另外的方法:利用ioctl函数获取struct ifreq结构的信息，该结构放置了很多网络接口的相关信息*/</span></span><br><span class=\"line\"><span class=\"comment\">/*  struct sockaddr_ll&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    unsigned short sll_family; //总是 AF_PACKET </span></span><br><span class=\"line\"><span class=\"comment\">    unsigned short sll_protocol; // 物理层的协议 </span></span><br><span class=\"line\"><span class=\"comment\">    int sll_ifindex; //接口号 </span></span><br><span class=\"line\"><span class=\"comment\">    unsigned short sll_hatype; // 报头类型 </span></span><br><span class=\"line\"><span class=\"comment\">    unsigned char sll_pkttype; // 分组类型 </span></span><br><span class=\"line\"><span class=\"comment\">    unsigned char sll_halen; // 地址长度 </span></span><br><span class=\"line\"><span class=\"comment\">    unsigned char sll_addr[8]; // 物理层地址 </span></span><br><span class=\"line\"><span class=\"comment\">&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">eg:</span></span><br><span class=\"line\"><span class=\"comment\">*     struct sockaddr_ll peer_addr;  </span></span><br><span class=\"line\"><span class=\"comment\">*    memset(&amp;peer_addr, 0, sizeof(peer_addr));    </span></span><br><span class=\"line\"><span class=\"comment\">        peer_addr.sll_family = AF_PACKET;    </span></span><br><span class=\"line\"><span class=\"comment\">        struct ifreq req;  </span></span><br><span class=\"line\"><span class=\"comment\">    bzero(&amp;req, sizeof(struct ifreq));  </span></span><br><span class=\"line\"><span class=\"comment\">        strcpy(req.ifr_name, \"eth0\");    </span></span><br><span class=\"line\"><span class=\"comment\">        if(ioctl(sockfd, SIOCGIFINDEX, &amp;req) != 0)  </span></span><br><span class=\"line\"><span class=\"comment\">        perror(\"ioctl()\");    </span></span><br><span class=\"line\"><span class=\"comment\">        peer_addr.sll_ifindex = req.ifr_ifindex;    </span></span><br><span class=\"line\"><span class=\"comment\">        peer_addr.sll_protocol = htons(ETH_P_ARP);  </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">/*第四步，创建套结字的时候，有以下的组合：更多见：man packet</span></span><br><span class=\"line\"><span class=\"comment\"> * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</span></span><br><span class=\"line\"><span class=\"comment\"> * 第二个参数： 2）套接字类型：</span></span><br><span class=\"line\"><span class=\"comment\">          SOCK_DGRAM----以太网头已经构造好了</span></span><br><span class=\"line\"><span class=\"comment\">          SOCK_RAW------自己构造以太头 </span></span><br><span class=\"line\"><span class=\"comment\">          * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字</span></span><br><span class=\"line\"><span class=\"comment\">          * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），</span></span><br><span class=\"line\"><span class=\"comment\">          * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，</span></span><br><span class=\"line\"><span class=\"comment\">          * 而发送时也无须用户添加头部字段。</span></span><br><span class=\"line\"><span class=\"comment\">   第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP</span></span><br><span class=\"line\"><span class=\"comment\">   * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：</span></span><br><span class=\"line\"><span class=\"comment\">   1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)</span></span><br><span class=\"line\"><span class=\"comment\">  和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)</span></span><br><span class=\"line\"><span class=\"comment\">    2)IEEE维护的注册以太网类型列表</span></span><br><span class=\"line\"><span class=\"comment\">     3）半官方的列表由IANA维护</span></span><br><span class=\"line\"><span class=\"comment\">      ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。</span></span><br><span class=\"line\"><span class=\"comment\">      0x88b5和0x88b6是保留以太网类型，供实验或私人使用。 </span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">   <span class=\"comment\">/*第五步发送和接收套接字的函数可以是read write操作套结字，也可以是上文的UDP无连接用的函数*/</span></span><br></pre></td></tr></table></figure>\n<p>处理的时候可能需要获取网关的ip地址：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*proc方法获取网关地址*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetGateWayIP</span><span class=\"params\">(uint8 *ip_addr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">char</span> inf[<span class=\"number\">100</span>];</span><br><span class=\"line\">      FILE *file_fd;</span><br><span class=\"line\">      uint8 high=<span class=\"number\">0</span>,low=<span class=\"number\">0</span>,value;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">      file_fd = fopen(<span class=\"string\">\"/proc/net/route\"</span>,<span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(file_fd==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"can not open /proc/net/route\\n\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">             <span class=\"keyword\">while</span>(!feof(file_fd))</span><br><span class=\"line\">             &#123;</span><br><span class=\"line\">                     <span class=\"built_in\">memset</span>(inf,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(inf));</span><br><span class=\"line\">                     fgets(inf,<span class=\"number\">100</span>,file_fd);</span><br><span class=\"line\">                     <span class=\"keyword\">if</span>(inf[<span class=\"number\">5</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">6</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">7</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">8</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">9</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">10</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">11</span>]==<span class=\"string\">'0'</span>&amp;&amp;inf[<span class=\"number\">12</span>]==<span class=\"string\">'0'</span>)</span><br><span class=\"line\">                     &#123;</span><br><span class=\"line\">                              <span class=\"keyword\">for</span>(i=<span class=\"number\">20</span>;i&gt;=<span class=\"number\">14</span>;i-=<span class=\"number\">2</span>)</span><br><span class=\"line\">                              &#123;</span><br><span class=\"line\">                                         <span class=\"keyword\">if</span>(inf[i]&gt;=<span class=\"number\">65</span>)</span><br><span class=\"line\">                                                 high = inf[i]<span class=\"number\">-55</span>;</span><br><span class=\"line\">                                         <span class=\"keyword\">else</span></span><br><span class=\"line\">                                                 high = inf[i]<span class=\"number\">-48</span>;</span><br><span class=\"line\">                                         <span class=\"keyword\">if</span>(inf[i+<span class=\"number\">1</span>]&gt;=<span class=\"number\">65</span>)</span><br><span class=\"line\">                                                 low = inf[i+<span class=\"number\">1</span>]<span class=\"number\">-55</span>;</span><br><span class=\"line\">                                         <span class=\"keyword\">else</span></span><br><span class=\"line\">                                                 low = inf[i+<span class=\"number\">1</span>]<span class=\"number\">-48</span>;</span><br><span class=\"line\">                                        value = high*<span class=\"number\">16</span>+low;</span><br><span class=\"line\">                                       ip_addr[<span class=\"number\">10</span>-i/<span class=\"number\">2</span>] = value;</span><br><span class=\"line\">                              &#125;</span><br><span class=\"line\">                              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ARP攻击\"><a href=\"#ARP攻击\" class=\"headerlink\" title=\"ARP攻击\"></a>ARP攻击</h4><ul>\n<li>ARP包可以直接发送给对端不经过路由器，有趣<br>在一个局域网中，客户端的几乎所有的包都是发往路由器的，这归结于默认路由设置，而在无线网，网卡其实可以接收所有数据，毕竟空气介质，所以，局域网中的设备可以直接通信<br>实验：在文件全能王中开启wifi文件传输，和它在同一个局域网的sta能访问该地址，抓包，发现目的地址和源地址都为同一个局域网的不同ip,且不为路由器网关ip，证明其两个设备是可以直接通信的</li>\n<li>再来做一个实验：通过pf_packet<br>1、在电脑A上写一个程序，mac目的地址为B,源地址为A,协议类型随机，数据随意，发送给B<br> 同时在B端进行接收，过滤掉其他mac地址，看是否可以接收到，在连接ap和不连接ap的条件下<br>2、在A和B设置静态ip地址，且不同网段，都不连接AP ,让A向B 发送ARP请求包，B接收到后回复arp响应包，接着做ping或其他操作，看是否能互相通信</li>\n<li>编程可以参考上述程序，改一下地址什么的就可以，或者参考其他：<br><a href=\"http://www.freebuf.com/articles/system/5157.html\" target=\"_blank\" rel=\"noopener\">http://www.freebuf.com/articles/system/5157.html</a><br>这篇文章讲的很具体，个人也喜欢这个网站，emm,实验过了，还可以，can also make your own program,具体程序不贴了  </li>\n<li>arp欺骗的基本原理：<br>在局域网中，设备A,B连接同一个路由器，他们之间可以直接相互通信，因此可以直接向对方发送arp包；<br>设备A ,B都会定期和AP交互arp请求和回复，相互知道对方的mac地址，这样，就能给ap发送请求，ap也能知道回复给谁；<br>arp欺骗的基本原理在于，如B是攻击方，则B向A发送ARP回复自己是AP ,即在ARP回复包中带上自己的mac地址，ap的ip地址；<br>同时向AP回复自己是A，即带上A的ip地址，自己的mac地址；<br>这样A就会以为B是AP，就会把请求发给B ,同时AP以为B是A，会把回复传给B,但是同时得配置B的转发功能，<br>echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot<br>该博文中有一处错误，见评论</li>\n</ul>"},{"title":"tcpip_mtu","date":"2018-05-20T14:27:55.000Z","_content":"# MTU \n这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍：\n### 理论部分：\n#### １、MTU(Maximum Transmission Unit)如何定义:  \n   * 指的是通信协议中的某一层上面所能通过的最大数据包大小\n   * 这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？  <!-- more -->\n   　答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B>1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:  \n    分片：ip净载荷：MTU-IP头：1500-20=1480;\n      3008B 需要分为3片，3008=1480,1480,48  \n 总结：MTU就是MAC承载的载荷的最大值  \n \n#### 2、MTU会影响什么:  \n* 数据包太大->分片重组->网络性能变差  \n* 数据包太小->一次能传输的数据小->网速差  \n* 路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191)　　\n\n#### 3、如何知道这个值呢？  \n路径最大传输单元发现方法(RFC1191)　　\n* 越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。  \n* MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：  \nping -c 3 -s 1474 -M do 192.168.0.1  \nPING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.  \nping: local error: Message too long, mtu=1500\n提示错误即消息太大且未设置分片\n\n#### 4 MTU大小的来源:  \nref https://www.zhihu.com/question/31460305/answer/183766816  \n以太网传输帧的最小值：    \n* 最早的以太网工作方式：载波多路复用/冲突检测（CSMA/D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。\n* 假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。  \n\n为什么标准以太网帧长度上限为1518字节?  \n* IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。\n* 由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 byte那有效传输效率= 160 / 218 = 73%而如果以太网长度为1518，那有效传输效率= 1460 / 1518 = 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题.\n* 于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。\n\n其他疑问：  \n* 最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？\n* 这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到> 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。\n* 有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度>接口MTU，怎么办？\n丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。\n* 所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？\n* 我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU = MRU，但比如9000侧的数据到达1500，由于9000 > MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样\n### 实践部分：\n如何设置MTU：  \n ifconfig eth0 mtu 1460  \n如何查看mtu:  \nnetstat -i\n","source":"_posts/tcpip-mtu.md","raw":"---\ntitle: tcpip_mtu\ndate: 2018-05-20 22:27:55\ntags: tcpip_mac\ncategories: tcpip\n---\n# MTU \n这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍：\n### 理论部分：\n#### １、MTU(Maximum Transmission Unit)如何定义:  \n   * 指的是通信协议中的某一层上面所能通过的最大数据包大小\n   * 这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？  <!-- more -->\n   　答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B>1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:  \n    分片：ip净载荷：MTU-IP头：1500-20=1480;\n      3008B 需要分为3片，3008=1480,1480,48  \n 总结：MTU就是MAC承载的载荷的最大值  \n \n#### 2、MTU会影响什么:  \n* 数据包太大->分片重组->网络性能变差  \n* 数据包太小->一次能传输的数据小->网速差  \n* 路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191)　　\n\n#### 3、如何知道这个值呢？  \n路径最大传输单元发现方法(RFC1191)　　\n* 越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。  \n* MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：  \nping -c 3 -s 1474 -M do 192.168.0.1  \nPING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.  \nping: local error: Message too long, mtu=1500\n提示错误即消息太大且未设置分片\n\n#### 4 MTU大小的来源:  \nref https://www.zhihu.com/question/31460305/answer/183766816  \n以太网传输帧的最小值：    \n* 最早的以太网工作方式：载波多路复用/冲突检测（CSMA/D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。\n* 假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。  \n\n为什么标准以太网帧长度上限为1518字节?  \n* IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。\n* 由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 byte那有效传输效率= 160 / 218 = 73%而如果以太网长度为1518，那有效传输效率= 1460 / 1518 = 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题.\n* 于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。\n\n其他疑问：  \n* 最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？\n* 这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到> 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。\n* 有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度>接口MTU，怎么办？\n丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。\n* 所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？\n* 我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU = MRU，但比如9000侧的数据到达1500，由于9000 > MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样\n### 实践部分：\n如何设置MTU：  \n ifconfig eth0 mtu 1460  \n如何查看mtu:  \nnetstat -i\n","slug":"tcpip-mtu","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7re003p2ujxdbzsyoly","content":"<h1 id=\"MTU\"><a href=\"#MTU\" class=\"headerlink\" title=\"MTU\"></a>MTU</h1><p>这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍：</p>\n<h3 id=\"理论部分：\"><a href=\"#理论部分：\" class=\"headerlink\" title=\"理论部分：\"></a>理论部分：</h3><h4 id=\"１、MTU-Maximum-Transmission-Unit-如何定义\"><a href=\"#１、MTU-Maximum-Transmission-Unit-如何定义\" class=\"headerlink\" title=\"１、MTU(Maximum Transmission Unit)如何定义:\"></a>１、MTU(Maximum Transmission Unit)如何定义:</h4><ul>\n<li>指的是通信协议中的某一层上面所能通过的最大数据包大小</li>\n<li>这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？  <a id=\"more\"></a><br>　答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B&gt;1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:<br>分片：ip净载荷：MTU-IP头：1500-20=1480;<br> 3008B 需要分为3片，3008=1480,1480,48<br>总结：MTU就是MAC承载的载荷的最大值  </li>\n</ul>\n<h4 id=\"2、MTU会影响什么\"><a href=\"#2、MTU会影响什么\" class=\"headerlink\" title=\"2、MTU会影响什么:\"></a>2、MTU会影响什么:</h4><ul>\n<li>数据包太大-&gt;分片重组-&gt;网络性能变差  </li>\n<li>数据包太小-&gt;一次能传输的数据小-&gt;网速差  </li>\n<li>路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191)　　</li>\n</ul>\n<h4 id=\"3、如何知道这个值呢？\"><a href=\"#3、如何知道这个值呢？\" class=\"headerlink\" title=\"3、如何知道这个值呢？\"></a>3、如何知道这个值呢？</h4><p>路径最大传输单元发现方法(RFC1191)　　</p>\n<ul>\n<li>越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。  </li>\n<li>MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：<br>ping -c 3 -s 1474 -M do 192.168.0.1<br>PING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.<br>ping: local error: Message too long, mtu=1500<br>提示错误即消息太大且未设置分片</li>\n</ul>\n<h4 id=\"4-MTU大小的来源\"><a href=\"#4-MTU大小的来源\" class=\"headerlink\" title=\"4 MTU大小的来源:\"></a>4 MTU大小的来源:</h4><p>ref <a href=\"https://www.zhihu.com/question/31460305/answer/183766816\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/31460305/answer/183766816</a><br>以太网传输帧的最小值：    </p>\n<ul>\n<li>最早的以太网工作方式：载波多路复用/冲突检测（CSMA/D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。</li>\n<li>假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。  </li>\n</ul>\n<p>为什么标准以太网帧长度上限为1518字节?  </p>\n<ul>\n<li>IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。</li>\n<li>由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 byte那有效传输效率= 160 / 218 = 73%而如果以太网长度为1518，那有效传输效率= 1460 / 1518 = 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题.</li>\n<li>于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。</li>\n</ul>\n<p>其他疑问：  </p>\n<ul>\n<li>最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？</li>\n<li>这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到&gt; 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。</li>\n<li>有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度&gt;接口MTU，怎么办？<br>丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。</li>\n<li>所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？</li>\n<li>我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU = MRU，但比如9000侧的数据到达1500，由于9000 &gt; MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样<h3 id=\"实践部分：\"><a href=\"#实践部分：\" class=\"headerlink\" title=\"实践部分：\"></a>实践部分：</h3>如何设置MTU：<br>ifconfig eth0 mtu 1460<br>如何查看mtu:<br>netstat -i</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"MTU\"><a href=\"#MTU\" class=\"headerlink\" title=\"MTU\"></a>MTU</h1><p>这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍：</p>\n<h3 id=\"理论部分：\"><a href=\"#理论部分：\" class=\"headerlink\" title=\"理论部分：\"></a>理论部分：</h3><h4 id=\"１、MTU-Maximum-Transmission-Unit-如何定义\"><a href=\"#１、MTU-Maximum-Transmission-Unit-如何定义\" class=\"headerlink\" title=\"１、MTU(Maximum Transmission Unit)如何定义:\"></a>１、MTU(Maximum Transmission Unit)如何定义:</h4><ul>\n<li>指的是通信协议中的某一层上面所能通过的最大数据包大小</li>\n<li>这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？","more":"<br>　答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B&gt;1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:<br>分片：ip净载荷：MTU-IP头：1500-20=1480;<br> 3008B 需要分为3片，3008=1480,1480,48<br>总结：MTU就是MAC承载的载荷的最大值  </li>\n</ul>\n<h4 id=\"2、MTU会影响什么\"><a href=\"#2、MTU会影响什么\" class=\"headerlink\" title=\"2、MTU会影响什么:\"></a>2、MTU会影响什么:</h4><ul>\n<li>数据包太大-&gt;分片重组-&gt;网络性能变差  </li>\n<li>数据包太小-&gt;一次能传输的数据小-&gt;网速差  </li>\n<li>路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191)　　</li>\n</ul>\n<h4 id=\"3、如何知道这个值呢？\"><a href=\"#3、如何知道这个值呢？\" class=\"headerlink\" title=\"3、如何知道这个值呢？\"></a>3、如何知道这个值呢？</h4><p>路径最大传输单元发现方法(RFC1191)　　</p>\n<ul>\n<li>越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。  </li>\n<li>MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：<br>ping -c 3 -s 1474 -M do 192.168.0.1<br>PING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.<br>ping: local error: Message too long, mtu=1500<br>提示错误即消息太大且未设置分片</li>\n</ul>\n<h4 id=\"4-MTU大小的来源\"><a href=\"#4-MTU大小的来源\" class=\"headerlink\" title=\"4 MTU大小的来源:\"></a>4 MTU大小的来源:</h4><p>ref <a href=\"https://www.zhihu.com/question/31460305/answer/183766816\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/31460305/answer/183766816</a><br>以太网传输帧的最小值：    </p>\n<ul>\n<li>最早的以太网工作方式：载波多路复用/冲突检测（CSMA/D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。</li>\n<li>假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。  </li>\n</ul>\n<p>为什么标准以太网帧长度上限为1518字节?  </p>\n<ul>\n<li>IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。</li>\n<li>由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 byte那有效传输效率= 160 / 218 = 73%而如果以太网长度为1518，那有效传输效率= 1460 / 1518 = 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题.</li>\n<li>于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。</li>\n</ul>\n<p>其他疑问：  </p>\n<ul>\n<li>最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？</li>\n<li>这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到&gt; 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。</li>\n<li>有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度&gt;接口MTU，怎么办？<br>丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。</li>\n<li>所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？</li>\n<li>我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU = MRU，但比如9000侧的数据到达1500，由于9000 &gt; MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样<h3 id=\"实践部分：\"><a href=\"#实践部分：\" class=\"headerlink\" title=\"实践部分：\"></a>实践部分：</h3>如何设置MTU：<br>ifconfig eth0 mtu 1460<br>如何查看mtu:<br>netstat -i</li>\n</ul>"},{"title":"tcpip_pingtraceroute","date":"2018-06-24T14:42:49.000Z","_content":"### ping and traceroute\n#### ping\nping是ICMP中的回显报文类型：\n+ ping 对应的icmp，type字段为0/8,code字段为0\n+ ICMP回显请求和应答报文格式：<!--more-->\n\n```cpp\n类型(0/8）       code(0)       检验和 --4B\n标示符（unix系统中为进程pid)   序号   --4B\n           选项数据\n ```\n\n+ 最常见，回显时间，得到往返时间：  \n通过在icmp数据报文中存放发送请求的时间值来计算往返时间，当应答返回时，用当前时间减去存放在ICMP报文中的时间值，即是往返时间\n\n```cpp\n类型(0/8）       code(0)       检验和 --4B\n标示符（unix系统中为进程pid)   序号   --4B\n           struct timeval tv;         --8B\n```\n\n共16Byte,除开ip头\n+ 放抓包的图片，ping回显示时间\n+ ping程序代码\n\n```cpp\nint addr_conv(char *address,struct in_addr *inaddr)\n{\n\tstruct hostent *he;\n\tif(inet_aton(address,inaddr)==1)\n\t\treturn (1);\n\the=gethostbyname(address);\n\tif(he!=NULL)\n\t{\n\t\t*inaddr=*((struct in_addr *)he->h_addr_list[0]);\n\t\treturn (1);\n\t}\n\treturn 0;\n}\nvoid send_icmp(int sockfd,sockaddr_in send_addr);\nvoid recv_icmp(int sockfd,sockaddr_in send_addr);\nint main(int argc,char **argv)\n{\n    int sockfd;\n\tsockfd=socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);\n    if(sockfd<0)\n \t{\n\t\tcout<<\"creat socket error\"<<endl;\n\t\treturn 1;\n\t}\n\tsockaddr_in send_addr;\n\tbzero(&send_addr,sizeof(send_addr));\n\tsend_addr.sin_family=AF_INET;\n\taddr_conv(argv[1],&send_addr.sin_addr);\n//send_addr.sin_addr.s_addr=inet_addr(\"192.168.0.110\");\n\tfor(int i=0;i<3;i++)\n \t{\n\t\tsend_icmp(sockfd,send_addr);\n\t\trecv_icmp(sockfd,send_addr);\n\t\tsleep(1);\n\t}\n\treturn 0;\n}\nunsigned short checksum(unsigned short *addr,int len)\n{\n\tint nleft=len;\n\tint sum=0;\n\tunsigned short *w=addr;\n\tunsigned short answer=0;\n\twhile(nleft>1)\n\t{\n\t\tsum+=*w++;\n\t\tnleft-=2;\n\t}\n\tif(nleft==1)\n\t{\n\t\t*(unsigned char *)(&answer)=*(unsigned char *)w;\n\t\tsum+=answer;\n\t}\n\tsum=(sum>>16)+(sum&0xffff);\n\tsum+=(sum>>16);\n\tanswer=~sum;\n\t//answer=(unsigned short)sum&0xffff;\n\treturn answer;\n}\nvoid send_icmp(int sockfd,sockaddr_in send_addr)\n{\n\tstatic short int seq=10;\n\tchar  buf[8+8];\n\tstruct icmphdr *icmp=(struct icmphdr *)buf;\n\t//填充icmp首部\n\ticmp->type=ICMP_ECHO;//类型\n\ticmp->code=0;//和编码共同决定是回显报文\n\ticmp->checksum=0;//头部包含校验和\n\ticmp->un.echo.id=getpid();//标识符，唯一性，一般填充pid，这样即使几个程序发送ping也能识别，写成其他时接收失败\n\ticmp->un.echo.sequence=seq++;//顺序号，回显时，显示，一般无规定，但是会在此基础上加１，接着加１，，\n\t//填充icmp数据(时间)//这里报文数据只有时间戳\n\tstruct timeval tv;\n\t//tv=(struct timeval*)icmp->icmp_data;\n\tgettimeofday(&tv,NULL);\n\tmemcpy(buf+8,&tv,sizeof(tv));\n\tint buflen=sizeof(struct icmphdr)+sizeof(struct timeval);\n\t//计算校验和\n\ticmp->checksum=checksum((unsigned short *)buf,buflen);\n\t//发送icmp数据包\n\tint len=sendto(sockfd,buf,buflen,0,(struct sockaddr *)&send_addr,sizeof(send_addr));\n\tif(len<0)\n\t\tcout<<\"send icmp error\"<<endl;\n\telse cout<<\"senmd ok\"<<endl;\n}\nvoid recv_icmp(int sockfd,sockaddr_in send_addr)\n{\n\tchar buf[256];\n\tstruct icmphdr *icmp;\n\tstruct ip *ip;\n\tint ipheadlen;\n\tint icmplen;\n\t//接收icmp响应\n\tfor(;;)\n\t{\n\t\tint n=recvfrom(sockfd,buf,sizeof(buf),0,NULL,NULL);\n\t\tif(n<0)\n\t\t{\n\t\t\tcout<<\"recv error\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tip=(struct ip *)buf;\t\n\t\tipheadlen=ip->ip_hl<<2;\n\t\ticmplen=n-ipheadlen;\n\t\tif(icmplen<16)\n\t\t\tcontinue;\n\t\ticmp=(struct icmphdr *)(buf+ipheadlen);\n\t\tif(icmp->type==ICMP_ECHOREPLY&&icmp->un.echo.id==getpid())\n\t\t\tbreak;\n\t}\n\t//计算时间差\n\tstruct timeval recv_tv;\n\tgettimeofday(&recv_tv,NULL);\n\tstruct timeval send_tv;\n\tmemcpy(&send_tv,icmp+1,sizeof(send_tv));\n\trecv_tv.tv_sec-=send_tv.tv_sec;\n\trecv_tv.tv_usec+=recv_tv.tv_sec*1000000L;\n\tlong interval=recv_tv.tv_usec-send_tv.tv_usec;\n\t//输出信息\n\tcout<<icmplen<< \" bytes fromfdfd \"<<inet_ntoa(send_addr.sin_addr);\n\tcout<<\" icmp_seq=\"<<icmp->un.echo.sequence<<\" bytes=\"<<icmplen<<\" ttl=\"<<(int)ip->ip_ttl;\n\tcout<<\" time=\"<<(float)interval/1000.0<<\"ms\"<<endl;\n}\n```\n\n+ ip 记录路由选项：  \n利用ip头，ip头长度字段为4bit,最长的ip首部为15x32bit=60字节，所以除去头20字节，选项字段最大40字节，除去3字节的code,len.ptr三个字节，剩下37个字节，可以容纳9个ip地址\nwindows下可以通过ping -r ip来尝试\n+ ip时间戳选项\n\n#### traceroute\n##### traceroute主要两点\n+ 利用ttl,ttl是一个有限值，每经过一个路由器减1，这样放置循环发包。\n+ 利用icmp报文，当路由器接收到ttl为0或1时，不转发，而是丢弃，并给信源回复一个icmp超时信息，且包含该路由器的ip\n+ 具体流程：  \ntraceroute发送一份ttl字段为1的ip数据报给目的主机，处理这个数据报的第一个路由器将ttl值减去1，丢弃该数据报，并发送一份超时icmp报文，这样就得到了该路径的第一个路由器的地址；  \n以此类推，发送ttl为2的数据报，则得到第二个路由器的地址；直到到达目的地址；  \n怎么知道到达了目的地?  \ntraceroute发送了一份udp数据包给目的主机，但它选择了一个不可能的值作为udp端口号（大于30000)，使目的主机的任何一个应用程序都不可能使用该端口号，则当包到达目的主机时，目的主机的udp模块会产生一个端口不可达的错误icmp报文。traceroute要做的是区分icmp是超时还是端口不可达，以判断什么时候结束\n\n##### traceroute命令\n\n```\ntraceroute www.baidu.com\ntraceroute to www.baidu.com (119.75.216.20), 30 hops max, 60 byte packets//ttl字段为30跳，每个数据包为60字节（20ip头等）\n 1  192.168.0.1 (192.168.0.1)  2.762 ms  3.485 ms  3.477 ms/发到网关1,针对每个ttl值发送三份包，分别在2.762,3.485,3.477收到\n 2  192.168.1.1 (192.168.1.1)  3.466 ms  3.453 ms  3.443 ms\n 3  101.232.192.1 (101.232.192.1)  6.807 ms  6.813 ms  7.412 ms\n 4  10.144.11.37 (10.144.11.37)  7.405 ms  7.393 ms  7.381 ms\n 5  10.144.14.138 (10.144.14.138)  7.369 ms  7.362 ms  7.340 ms\n 6  * * 14.197.242.145 (14.197.242.145)  10.329 ms\n 7  14.197.218.173 (14.197.218.173)  7.240 ms 14.197.248.253 (14.197.248.253)  6.855 ms  7.212 ms\n 8  14.197.240.249 (14.197.240.249)  44.799 ms 14.197.252.189 (14.197.252.189)  42.107 ms 14.197.253.145 (14.197.253.145)  50.051 ms\n 9  14.197.252.54 (14.197.252.54)  49.394 ms  49.414 ms 14.197.248.94 (14.197.248.94)  49.406 ms\n10  14.197.149.178 (14.197.149.178)  49.406 ms  49.383 ms 14.197.178.102 (14.197.178.102)  49.382 ms\n11  182.61.253.119 (182.61.253.119)  49.912 ms 182.61.253.117 (182.61.253.117)  50.916 ms 182.61.253.119 (182.61.253.119)  50.554 ms\n12  182.61.253.126 (182.61.253.126)  47.975 ms *  50.625 ms//5s未收到时打印一个*号并发送下一份数据包\n13  * * *\n14  * * *\n15  * * *\n16  * * *\n17  * * *\n18  * * *\n19  * * *\n20  * * *\n21  * * *\n22  * * *\n23  * * *\n24  * * *\n25  * * *\n26  * * *\n27  * * *\n28  * * *\n29  * * *\n30  * * *\n```\n\ntcpdump输出：\n\n```\ntraceroute www.baidu.com(119.75.213.61)\n192.168.0.110.39650 > 119.75.213.61.33434: [udp sum ok] UDP, length 32\n20:21:58.009075 IP (tos 0x0, ttl 1, id 5354, offset 0, flags [none], proto UDP (17), length 60)//ttl=1\n192.168.0.1 > 192.168.0.110: ICMP time exceeded in-transit, length 68//网关回复icmp超时\n\tIP (tos 0x0, ttl 1, id 941, offset 0, flags [none], proto UDP (17), length 60)\n    192.168.0.110.48912 > 119.75.213.61.33435: [udp sum ok] UDP, length 32\n20:21:58.009114 IP (tos 0x0, ttl 1, id 5355, offset 0, flags [none], proto UDP (17), length 60)\n    192.168.0.110.43061 > 119.75.213.61.33436: [udp sum ok] UDP, length 32\n20:21:58.009148 IP (tos 0x0, ttl 2, id 5356, offset 0, flags [none], proto UDP (17), length 60)//ttl=2\n 192.168.1.1 > 192.168.0.110: ICMP time exceeded in-transit, length 68\n\tIP (tos 0x0, ttl 1, id 942, offset 0, flags [none], proto UDP (17), length 60)\n//第2个路由器回复超时\n    192.168.0.110.52554 > 119.75.213.61.33437: [udp sum ok] UDP, length 32\n20:21:58.009189 IP (tos 0x0, ttl 2, id 5357, offset 0, flags [none], proto UDP (17), length 60)\n    192.168.0.110.51967 > 119.75.213.61.33438: [udp sum ok] UDP, length 32\n20:21:58.009243 IP (tos 0x0, ttl 2, id 5358, offset 0, flags [none], proto UDP (17), length 60)\n    192.168.0.110.45922 > 119.75.213.61.33439: [udp sum ok] UDP, length 32\n20:21:58.009281 IP (tos 0x0, ttl 3, id 5359, offset 0, flags [none], proto UDP (17), length 60)//ttl==3\n    192.168.0.110.34392 > 119.75.213.61.33440: [udp sum ok] UDP, length 32  \n    101.232.192.1 > 192.168.0.110: ICMP time exceeded in-transit, length 60\n\tIP (tos 0x0, id 945, offset 0, flags [none], proto UDP (17), length 60)\n    192.168.0.110.57724 > 119.75.216.20.33440: UDP, length 32\n//第三个路由器回复icmpc超时\n20:21:59.304604 IP (tos 0x0, ttl 59, id 0, offset 0, flags [DF], proto UDP (17), length 161)\n```\n\n从上面包的情况可以看到:\n+ 设备首先发送ucp包。若用更详细的打印看到端口号为源55050 目的端口:33443别的设备可能不同，但是都很大，这样到达时会发出端口不可达；ttl字段从1递增，源地址目的地址不变\n+ 路由器根据ttl的值，回复icmp超时包，回复给设备，从源地址可以看到，经过的路由器；\n+ 该icmp的包格式：\n类型11  code 0/1  校验和  \nip首部（包括选项)+原始ip数据报中数据的前8个字节\n+ 注意：每一次的路由都可能不一样\n\n##### 关于ip源站选路选项\n+ ip通常都是动态的，即每个路由都要判断数据报下面该转发到哪个路由器，一般不对此进行控制；这里提供的思想是：\n+ 由源站发送者指定路由，即经过哪些ip\n+ 分为严格的源路由选择和宽松的源站选路\n+ 前者必须采用确切的路由，若发现失败则路由器返回源站选路失败的icmp报文；\n+ 后者致命一个数据包经过的ip清单，但是数据包在清单上指明的任意两个地址之间可以通过其他路由器；\n+ ip源站路由选项的格式：  \n包含在ip头部的选项中，因长度有限只能包含9个ip:  \ncode(1) len(1) ptr(1) ip1(4) ip2(4)....\n+ eg: traceroute -g 192.168.23.1 www.baidu.com\n\n##### traceroute实现\n+ 参考linux traceroute源码实现；\n+ 主要就是发送一多个dp包设置ttl递增，并将接收到的icmp报文打印出来；直到收到端口不可达报文时退出；","source":"_posts/tcpip-pingtraceroute.md","raw":"---\ntitle: tcpip_pingtraceroute\ndate: 2018-06-24 22:42:49\ntags: tcpip_ip\ncategories: tcpip\n---\n### ping and traceroute\n#### ping\nping是ICMP中的回显报文类型：\n+ ping 对应的icmp，type字段为0/8,code字段为0\n+ ICMP回显请求和应答报文格式：<!--more-->\n\n```cpp\n类型(0/8）       code(0)       检验和 --4B\n标示符（unix系统中为进程pid)   序号   --4B\n           选项数据\n ```\n\n+ 最常见，回显时间，得到往返时间：  \n通过在icmp数据报文中存放发送请求的时间值来计算往返时间，当应答返回时，用当前时间减去存放在ICMP报文中的时间值，即是往返时间\n\n```cpp\n类型(0/8）       code(0)       检验和 --4B\n标示符（unix系统中为进程pid)   序号   --4B\n           struct timeval tv;         --8B\n```\n\n共16Byte,除开ip头\n+ 放抓包的图片，ping回显示时间\n+ ping程序代码\n\n```cpp\nint addr_conv(char *address,struct in_addr *inaddr)\n{\n\tstruct hostent *he;\n\tif(inet_aton(address,inaddr)==1)\n\t\treturn (1);\n\the=gethostbyname(address);\n\tif(he!=NULL)\n\t{\n\t\t*inaddr=*((struct in_addr *)he->h_addr_list[0]);\n\t\treturn (1);\n\t}\n\treturn 0;\n}\nvoid send_icmp(int sockfd,sockaddr_in send_addr);\nvoid recv_icmp(int sockfd,sockaddr_in send_addr);\nint main(int argc,char **argv)\n{\n    int sockfd;\n\tsockfd=socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);\n    if(sockfd<0)\n \t{\n\t\tcout<<\"creat socket error\"<<endl;\n\t\treturn 1;\n\t}\n\tsockaddr_in send_addr;\n\tbzero(&send_addr,sizeof(send_addr));\n\tsend_addr.sin_family=AF_INET;\n\taddr_conv(argv[1],&send_addr.sin_addr);\n//send_addr.sin_addr.s_addr=inet_addr(\"192.168.0.110\");\n\tfor(int i=0;i<3;i++)\n \t{\n\t\tsend_icmp(sockfd,send_addr);\n\t\trecv_icmp(sockfd,send_addr);\n\t\tsleep(1);\n\t}\n\treturn 0;\n}\nunsigned short checksum(unsigned short *addr,int len)\n{\n\tint nleft=len;\n\tint sum=0;\n\tunsigned short *w=addr;\n\tunsigned short answer=0;\n\twhile(nleft>1)\n\t{\n\t\tsum+=*w++;\n\t\tnleft-=2;\n\t}\n\tif(nleft==1)\n\t{\n\t\t*(unsigned char *)(&answer)=*(unsigned char *)w;\n\t\tsum+=answer;\n\t}\n\tsum=(sum>>16)+(sum&0xffff);\n\tsum+=(sum>>16);\n\tanswer=~sum;\n\t//answer=(unsigned short)sum&0xffff;\n\treturn answer;\n}\nvoid send_icmp(int sockfd,sockaddr_in send_addr)\n{\n\tstatic short int seq=10;\n\tchar  buf[8+8];\n\tstruct icmphdr *icmp=(struct icmphdr *)buf;\n\t//填充icmp首部\n\ticmp->type=ICMP_ECHO;//类型\n\ticmp->code=0;//和编码共同决定是回显报文\n\ticmp->checksum=0;//头部包含校验和\n\ticmp->un.echo.id=getpid();//标识符，唯一性，一般填充pid，这样即使几个程序发送ping也能识别，写成其他时接收失败\n\ticmp->un.echo.sequence=seq++;//顺序号，回显时，显示，一般无规定，但是会在此基础上加１，接着加１，，\n\t//填充icmp数据(时间)//这里报文数据只有时间戳\n\tstruct timeval tv;\n\t//tv=(struct timeval*)icmp->icmp_data;\n\tgettimeofday(&tv,NULL);\n\tmemcpy(buf+8,&tv,sizeof(tv));\n\tint buflen=sizeof(struct icmphdr)+sizeof(struct timeval);\n\t//计算校验和\n\ticmp->checksum=checksum((unsigned short *)buf,buflen);\n\t//发送icmp数据包\n\tint len=sendto(sockfd,buf,buflen,0,(struct sockaddr *)&send_addr,sizeof(send_addr));\n\tif(len<0)\n\t\tcout<<\"send icmp error\"<<endl;\n\telse cout<<\"senmd ok\"<<endl;\n}\nvoid recv_icmp(int sockfd,sockaddr_in send_addr)\n{\n\tchar buf[256];\n\tstruct icmphdr *icmp;\n\tstruct ip *ip;\n\tint ipheadlen;\n\tint icmplen;\n\t//接收icmp响应\n\tfor(;;)\n\t{\n\t\tint n=recvfrom(sockfd,buf,sizeof(buf),0,NULL,NULL);\n\t\tif(n<0)\n\t\t{\n\t\t\tcout<<\"recv error\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tip=(struct ip *)buf;\t\n\t\tipheadlen=ip->ip_hl<<2;\n\t\ticmplen=n-ipheadlen;\n\t\tif(icmplen<16)\n\t\t\tcontinue;\n\t\ticmp=(struct icmphdr *)(buf+ipheadlen);\n\t\tif(icmp->type==ICMP_ECHOREPLY&&icmp->un.echo.id==getpid())\n\t\t\tbreak;\n\t}\n\t//计算时间差\n\tstruct timeval recv_tv;\n\tgettimeofday(&recv_tv,NULL);\n\tstruct timeval send_tv;\n\tmemcpy(&send_tv,icmp+1,sizeof(send_tv));\n\trecv_tv.tv_sec-=send_tv.tv_sec;\n\trecv_tv.tv_usec+=recv_tv.tv_sec*1000000L;\n\tlong interval=recv_tv.tv_usec-send_tv.tv_usec;\n\t//输出信息\n\tcout<<icmplen<< \" bytes fromfdfd \"<<inet_ntoa(send_addr.sin_addr);\n\tcout<<\" icmp_seq=\"<<icmp->un.echo.sequence<<\" bytes=\"<<icmplen<<\" ttl=\"<<(int)ip->ip_ttl;\n\tcout<<\" time=\"<<(float)interval/1000.0<<\"ms\"<<endl;\n}\n```\n\n+ ip 记录路由选项：  \n利用ip头，ip头长度字段为4bit,最长的ip首部为15x32bit=60字节，所以除去头20字节，选项字段最大40字节，除去3字节的code,len.ptr三个字节，剩下37个字节，可以容纳9个ip地址\nwindows下可以通过ping -r ip来尝试\n+ ip时间戳选项\n\n#### traceroute\n##### traceroute主要两点\n+ 利用ttl,ttl是一个有限值，每经过一个路由器减1，这样放置循环发包。\n+ 利用icmp报文，当路由器接收到ttl为0或1时，不转发，而是丢弃，并给信源回复一个icmp超时信息，且包含该路由器的ip\n+ 具体流程：  \ntraceroute发送一份ttl字段为1的ip数据报给目的主机，处理这个数据报的第一个路由器将ttl值减去1，丢弃该数据报，并发送一份超时icmp报文，这样就得到了该路径的第一个路由器的地址；  \n以此类推，发送ttl为2的数据报，则得到第二个路由器的地址；直到到达目的地址；  \n怎么知道到达了目的地?  \ntraceroute发送了一份udp数据包给目的主机，但它选择了一个不可能的值作为udp端口号（大于30000)，使目的主机的任何一个应用程序都不可能使用该端口号，则当包到达目的主机时，目的主机的udp模块会产生一个端口不可达的错误icmp报文。traceroute要做的是区分icmp是超时还是端口不可达，以判断什么时候结束\n\n##### traceroute命令\n\n```\ntraceroute www.baidu.com\ntraceroute to www.baidu.com (119.75.216.20), 30 hops max, 60 byte packets//ttl字段为30跳，每个数据包为60字节（20ip头等）\n 1  192.168.0.1 (192.168.0.1)  2.762 ms  3.485 ms  3.477 ms/发到网关1,针对每个ttl值发送三份包，分别在2.762,3.485,3.477收到\n 2  192.168.1.1 (192.168.1.1)  3.466 ms  3.453 ms  3.443 ms\n 3  101.232.192.1 (101.232.192.1)  6.807 ms  6.813 ms  7.412 ms\n 4  10.144.11.37 (10.144.11.37)  7.405 ms  7.393 ms  7.381 ms\n 5  10.144.14.138 (10.144.14.138)  7.369 ms  7.362 ms  7.340 ms\n 6  * * 14.197.242.145 (14.197.242.145)  10.329 ms\n 7  14.197.218.173 (14.197.218.173)  7.240 ms 14.197.248.253 (14.197.248.253)  6.855 ms  7.212 ms\n 8  14.197.240.249 (14.197.240.249)  44.799 ms 14.197.252.189 (14.197.252.189)  42.107 ms 14.197.253.145 (14.197.253.145)  50.051 ms\n 9  14.197.252.54 (14.197.252.54)  49.394 ms  49.414 ms 14.197.248.94 (14.197.248.94)  49.406 ms\n10  14.197.149.178 (14.197.149.178)  49.406 ms  49.383 ms 14.197.178.102 (14.197.178.102)  49.382 ms\n11  182.61.253.119 (182.61.253.119)  49.912 ms 182.61.253.117 (182.61.253.117)  50.916 ms 182.61.253.119 (182.61.253.119)  50.554 ms\n12  182.61.253.126 (182.61.253.126)  47.975 ms *  50.625 ms//5s未收到时打印一个*号并发送下一份数据包\n13  * * *\n14  * * *\n15  * * *\n16  * * *\n17  * * *\n18  * * *\n19  * * *\n20  * * *\n21  * * *\n22  * * *\n23  * * *\n24  * * *\n25  * * *\n26  * * *\n27  * * *\n28  * * *\n29  * * *\n30  * * *\n```\n\ntcpdump输出：\n\n```\ntraceroute www.baidu.com(119.75.213.61)\n192.168.0.110.39650 > 119.75.213.61.33434: [udp sum ok] UDP, length 32\n20:21:58.009075 IP (tos 0x0, ttl 1, id 5354, offset 0, flags [none], proto UDP (17), length 60)//ttl=1\n192.168.0.1 > 192.168.0.110: ICMP time exceeded in-transit, length 68//网关回复icmp超时\n\tIP (tos 0x0, ttl 1, id 941, offset 0, flags [none], proto UDP (17), length 60)\n    192.168.0.110.48912 > 119.75.213.61.33435: [udp sum ok] UDP, length 32\n20:21:58.009114 IP (tos 0x0, ttl 1, id 5355, offset 0, flags [none], proto UDP (17), length 60)\n    192.168.0.110.43061 > 119.75.213.61.33436: [udp sum ok] UDP, length 32\n20:21:58.009148 IP (tos 0x0, ttl 2, id 5356, offset 0, flags [none], proto UDP (17), length 60)//ttl=2\n 192.168.1.1 > 192.168.0.110: ICMP time exceeded in-transit, length 68\n\tIP (tos 0x0, ttl 1, id 942, offset 0, flags [none], proto UDP (17), length 60)\n//第2个路由器回复超时\n    192.168.0.110.52554 > 119.75.213.61.33437: [udp sum ok] UDP, length 32\n20:21:58.009189 IP (tos 0x0, ttl 2, id 5357, offset 0, flags [none], proto UDP (17), length 60)\n    192.168.0.110.51967 > 119.75.213.61.33438: [udp sum ok] UDP, length 32\n20:21:58.009243 IP (tos 0x0, ttl 2, id 5358, offset 0, flags [none], proto UDP (17), length 60)\n    192.168.0.110.45922 > 119.75.213.61.33439: [udp sum ok] UDP, length 32\n20:21:58.009281 IP (tos 0x0, ttl 3, id 5359, offset 0, flags [none], proto UDP (17), length 60)//ttl==3\n    192.168.0.110.34392 > 119.75.213.61.33440: [udp sum ok] UDP, length 32  \n    101.232.192.1 > 192.168.0.110: ICMP time exceeded in-transit, length 60\n\tIP (tos 0x0, id 945, offset 0, flags [none], proto UDP (17), length 60)\n    192.168.0.110.57724 > 119.75.216.20.33440: UDP, length 32\n//第三个路由器回复icmpc超时\n20:21:59.304604 IP (tos 0x0, ttl 59, id 0, offset 0, flags [DF], proto UDP (17), length 161)\n```\n\n从上面包的情况可以看到:\n+ 设备首先发送ucp包。若用更详细的打印看到端口号为源55050 目的端口:33443别的设备可能不同，但是都很大，这样到达时会发出端口不可达；ttl字段从1递增，源地址目的地址不变\n+ 路由器根据ttl的值，回复icmp超时包，回复给设备，从源地址可以看到，经过的路由器；\n+ 该icmp的包格式：\n类型11  code 0/1  校验和  \nip首部（包括选项)+原始ip数据报中数据的前8个字节\n+ 注意：每一次的路由都可能不一样\n\n##### 关于ip源站选路选项\n+ ip通常都是动态的，即每个路由都要判断数据报下面该转发到哪个路由器，一般不对此进行控制；这里提供的思想是：\n+ 由源站发送者指定路由，即经过哪些ip\n+ 分为严格的源路由选择和宽松的源站选路\n+ 前者必须采用确切的路由，若发现失败则路由器返回源站选路失败的icmp报文；\n+ 后者致命一个数据包经过的ip清单，但是数据包在清单上指明的任意两个地址之间可以通过其他路由器；\n+ ip源站路由选项的格式：  \n包含在ip头部的选项中，因长度有限只能包含9个ip:  \ncode(1) len(1) ptr(1) ip1(4) ip2(4)....\n+ eg: traceroute -g 192.168.23.1 www.baidu.com\n\n##### traceroute实现\n+ 参考linux traceroute源码实现；\n+ 主要就是发送一多个dp包设置ttl递增，并将接收到的icmp报文打印出来；直到收到端口不可达报文时退出；","slug":"tcpip-pingtraceroute","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7rj003r2ujxy540esgu","content":"<h3 id=\"ping-and-traceroute\"><a href=\"#ping-and-traceroute\" class=\"headerlink\" title=\"ping and traceroute\"></a>ping and traceroute</h3><h4 id=\"ping\"><a href=\"#ping\" class=\"headerlink\" title=\"ping\"></a>ping</h4><p>ping是ICMP中的回显报文类型：</p>\n<ul>\n<li>ping 对应的icmp，type字段为0/8,code字段为0</li>\n<li>ICMP回显请求和应答报文格式：<a id=\"more\"></a></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型(<span class=\"number\">0</span>/<span class=\"number\">8</span>）       code(<span class=\"number\">0</span>)       检验和 -<span class=\"number\">-4B</span></span><br><span class=\"line\">标示符（unix系统中为进程pid)   序号   -<span class=\"number\">-4B</span></span><br><span class=\"line\">           选项数据</span><br></pre></td></tr></table></figure>\n<ul>\n<li>最常见，回显时间，得到往返时间：<br>通过在icmp数据报文中存放发送请求的时间值来计算往返时间，当应答返回时，用当前时间减去存放在ICMP报文中的时间值，即是往返时间</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型(<span class=\"number\">0</span>/<span class=\"number\">8</span>）       code(<span class=\"number\">0</span>)       检验和 -<span class=\"number\">-4B</span></span><br><span class=\"line\">标示符（unix系统中为进程pid)   序号   -<span class=\"number\">-4B</span></span><br><span class=\"line\">           <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span>         -<span class=\"number\">-8B</span></span><br></pre></td></tr></table></figure>\n<p>共16Byte,除开ip头</p>\n<ul>\n<li>放抓包的图片，ping回显示时间</li>\n<li>ping程序代码</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">addr_conv</span><span class=\"params\">(<span class=\"keyword\">char</span> *address,struct in_addr *inaddr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> *<span class=\"title\">he</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(inet_aton(address,inaddr)==<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (<span class=\"number\">1</span>);</span><br><span class=\"line\">\the=gethostbyname(address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(he!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t*inaddr=*((struct in_addr *)he-&gt;h_addr_list[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send_icmp</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd,sockaddr_in send_addr)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recv_icmp</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd,sockaddr_in send_addr)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc,<span class=\"keyword\">char</span> **argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd;</span><br><span class=\"line\">\tsockfd=socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sockfd&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> \t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"creat socket error\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsockaddr_in send_addr;</span><br><span class=\"line\">\tbzero(&amp;send_addr,<span class=\"keyword\">sizeof</span>(send_addr));</span><br><span class=\"line\">\tsend_addr.sin_family=AF_INET;</span><br><span class=\"line\">\taddr_conv(argv[<span class=\"number\">1</span>],&amp;send_addr.sin_addr);</span><br><span class=\"line\"><span class=\"comment\">//send_addr.sin_addr.s_addr=inet_addr(\"192.168.0.110\");</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)</span><br><span class=\"line\"> \t&#123;</span><br><span class=\"line\">\t\tsend_icmp(sockfd,send_addr);</span><br><span class=\"line\">\t\trecv_icmp(sockfd,send_addr);</span><br><span class=\"line\">\t\tsleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> <span class=\"title\">checksum</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> *addr,<span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nleft=len;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> *w=addr;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> answer=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(nleft&gt;<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum+=*w++;</span><br><span class=\"line\">\t\tnleft-=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(nleft==<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t*(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)(&amp;answer)=*(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)w;</span><br><span class=\"line\">\t\tsum+=answer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsum=(sum&gt;&gt;<span class=\"number\">16</span>)+(sum&amp;<span class=\"number\">0xffff</span>);</span><br><span class=\"line\">\tsum+=(sum&gt;&gt;<span class=\"number\">16</span>);</span><br><span class=\"line\">\tanswer=~sum;</span><br><span class=\"line\">\t<span class=\"comment\">//answer=(unsigned short)sum&amp;0xffff;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> answer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send_icmp</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd,sockaddr_in send_addr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">short</span> <span class=\"keyword\">int</span> seq=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>  buf[<span class=\"number\">8</span>+<span class=\"number\">8</span>];</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">icmphdr</span> *<span class=\"title\">icmp</span>=(<span class=\"title\">struct</span> <span class=\"title\">icmphdr</span> *)<span class=\"title\">buf</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">//填充icmp首部</span></span><br><span class=\"line\">\ticmp-&gt;type=ICMP_ECHO;<span class=\"comment\">//类型</span></span><br><span class=\"line\">\ticmp-&gt;code=<span class=\"number\">0</span>;<span class=\"comment\">//和编码共同决定是回显报文</span></span><br><span class=\"line\">\ticmp-&gt;checksum=<span class=\"number\">0</span>;<span class=\"comment\">//头部包含校验和</span></span><br><span class=\"line\">\ticmp-&gt;un.echo.id=getpid();<span class=\"comment\">//标识符，唯一性，一般填充pid，这样即使几个程序发送ping也能识别，写成其他时接收失败</span></span><br><span class=\"line\">\ticmp-&gt;un.echo.sequence=seq++;<span class=\"comment\">//顺序号，回显时，显示，一般无规定，但是会在此基础上加１，接着加１，，</span></span><br><span class=\"line\">\t<span class=\"comment\">//填充icmp数据(时间)//这里报文数据只有时间戳</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">//tv=(struct timeval*)icmp-&gt;icmp_data;</span></span><br><span class=\"line\">\tgettimeofday(&amp;tv,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(buf+<span class=\"number\">8</span>,&amp;tv,<span class=\"keyword\">sizeof</span>(tv));</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> buflen=<span class=\"keyword\">sizeof</span>(struct icmphdr)+<span class=\"keyword\">sizeof</span>(struct timeval);</span><br><span class=\"line\">\t<span class=\"comment\">//计算校验和</span></span><br><span class=\"line\">\ticmp-&gt;checksum=checksum((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> *)buf,buflen);</span><br><span class=\"line\">\t<span class=\"comment\">//发送icmp数据包</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len=sendto(sockfd,buf,buflen,<span class=\"number\">0</span>,(struct sockaddr *)&amp;send_addr,<span class=\"keyword\">sizeof</span>(send_addr));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(len&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"send icmp error\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"senmd ok\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recv_icmp</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd,sockaddr_in send_addr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">256</span>];</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">icmphdr</span> *<span class=\"title\">icmp</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ip</span> *<span class=\"title\">ip</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ipheadlen;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> icmplen;</span><br><span class=\"line\">\t<span class=\"comment\">//接收icmp响应</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> n=recvfrom(sockfd,buf,<span class=\"keyword\">sizeof</span>(buf),<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(n&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"recv error\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tip=(struct ip *)buf;\t</span><br><span class=\"line\">\t\tipheadlen=ip-&gt;ip_hl&lt;&lt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\ticmplen=n-ipheadlen;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(icmplen&lt;<span class=\"number\">16</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\ticmp=(struct icmphdr *)(buf+ipheadlen);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(icmp-&gt;type==ICMP_ECHOREPLY&amp;&amp;icmp-&gt;un.echo.id==getpid())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//计算时间差</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">recv_tv</span>;</span></span><br><span class=\"line\">\tgettimeofday(&amp;recv_tv,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">send_tv</span>;</span></span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(&amp;send_tv,icmp+<span class=\"number\">1</span>,<span class=\"keyword\">sizeof</span>(send_tv));</span><br><span class=\"line\">\trecv_tv.tv_sec-=send_tv.tv_sec;</span><br><span class=\"line\">\trecv_tv.tv_usec+=recv_tv.tv_sec*<span class=\"number\">1000000L</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> interval=recv_tv.tv_usec-send_tv.tv_usec;</span><br><span class=\"line\">\t<span class=\"comment\">//输出信息</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;icmplen&lt;&lt; <span class=\"string\">\" bytes fromfdfd \"</span>&lt;&lt;inet_ntoa(send_addr.sin_addr);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" icmp_seq=\"</span>&lt;&lt;icmp-&gt;un.echo.sequence&lt;&lt;<span class=\"string\">\" bytes=\"</span>&lt;&lt;icmplen&lt;&lt;<span class=\"string\">\" ttl=\"</span>&lt;&lt;(<span class=\"keyword\">int</span>)ip-&gt;ip_ttl;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" time=\"</span>&lt;&lt;(<span class=\"keyword\">float</span>)interval/<span class=\"number\">1000.0</span>&lt;&lt;<span class=\"string\">\"ms\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ip 记录路由选项：<br>利用ip头，ip头长度字段为4bit,最长的ip首部为15x32bit=60字节，所以除去头20字节，选项字段最大40字节，除去3字节的code,len.ptr三个字节，剩下37个字节，可以容纳9个ip地址<br>windows下可以通过ping -r ip来尝试</li>\n<li>ip时间戳选项</li>\n</ul>\n<h4 id=\"traceroute\"><a href=\"#traceroute\" class=\"headerlink\" title=\"traceroute\"></a>traceroute</h4><h5 id=\"traceroute主要两点\"><a href=\"#traceroute主要两点\" class=\"headerlink\" title=\"traceroute主要两点\"></a>traceroute主要两点</h5><ul>\n<li>利用ttl,ttl是一个有限值，每经过一个路由器减1，这样放置循环发包。</li>\n<li>利用icmp报文，当路由器接收到ttl为0或1时，不转发，而是丢弃，并给信源回复一个icmp超时信息，且包含该路由器的ip</li>\n<li>具体流程：<br>traceroute发送一份ttl字段为1的ip数据报给目的主机，处理这个数据报的第一个路由器将ttl值减去1，丢弃该数据报，并发送一份超时icmp报文，这样就得到了该路径的第一个路由器的地址；<br>以此类推，发送ttl为2的数据报，则得到第二个路由器的地址；直到到达目的地址；<br>怎么知道到达了目的地?<br>traceroute发送了一份udp数据包给目的主机，但它选择了一个不可能的值作为udp端口号（大于30000)，使目的主机的任何一个应用程序都不可能使用该端口号，则当包到达目的主机时，目的主机的udp模块会产生一个端口不可达的错误icmp报文。traceroute要做的是区分icmp是超时还是端口不可达，以判断什么时候结束</li>\n</ul>\n<h5 id=\"traceroute命令\"><a href=\"#traceroute命令\" class=\"headerlink\" title=\"traceroute命令\"></a>traceroute命令</h5><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">traceroute www.baidu.com</span><br><span class=\"line\">traceroute to www.baidu.com (<span class=\"number\">119.75</span><span class=\"number\">.216</span><span class=\"number\">.20</span>), <span class=\"number\">30</span> hops max, <span class=\"number\">60</span> byte packets<span class=\"comment\">//ttl字段为30跳，每个数据包为60字节（20ip头等）</span></span><br><span class=\"line\"> <span class=\"number\">1</span>  <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span> (<span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>)  <span class=\"number\">2.762</span> ms  <span class=\"number\">3.485</span> ms  <span class=\"number\">3.477</span> ms/发到网关<span class=\"number\">1</span>,针对每个ttl值发送三份包，分别在<span class=\"number\">2.762</span>,<span class=\"number\">3.485</span>,<span class=\"number\">3.477</span>收到</span><br><span class=\"line\"> <span class=\"number\">2</span>  <span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.1</span> (<span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.1</span>)  <span class=\"number\">3.466</span> ms  <span class=\"number\">3.453</span> ms  <span class=\"number\">3.443</span> ms</span><br><span class=\"line\"> <span class=\"number\">3</span>  <span class=\"number\">101.232</span><span class=\"number\">.192</span><span class=\"number\">.1</span> (<span class=\"number\">101.232</span><span class=\"number\">.192</span><span class=\"number\">.1</span>)  <span class=\"number\">6.807</span> ms  <span class=\"number\">6.813</span> ms  <span class=\"number\">7.412</span> ms</span><br><span class=\"line\"> <span class=\"number\">4</span>  <span class=\"number\">10.144</span><span class=\"number\">.11</span><span class=\"number\">.37</span> (<span class=\"number\">10.144</span><span class=\"number\">.11</span><span class=\"number\">.37</span>)  <span class=\"number\">7.405</span> ms  <span class=\"number\">7.393</span> ms  <span class=\"number\">7.381</span> ms</span><br><span class=\"line\"> <span class=\"number\">5</span>  <span class=\"number\">10.144</span><span class=\"number\">.14</span><span class=\"number\">.138</span> (<span class=\"number\">10.144</span><span class=\"number\">.14</span><span class=\"number\">.138</span>)  <span class=\"number\">7.369</span> ms  <span class=\"number\">7.362</span> ms  <span class=\"number\">7.340</span> ms</span><br><span class=\"line\"> <span class=\"number\">6</span>  * * <span class=\"number\">14.197</span><span class=\"number\">.242</span><span class=\"number\">.145</span> (<span class=\"number\">14.197</span><span class=\"number\">.242</span><span class=\"number\">.145</span>)  <span class=\"number\">10.329</span> ms</span><br><span class=\"line\"> <span class=\"number\">7</span>  <span class=\"number\">14.197</span><span class=\"number\">.218</span><span class=\"number\">.173</span> (<span class=\"number\">14.197</span><span class=\"number\">.218</span><span class=\"number\">.173</span>)  <span class=\"number\">7.240</span> ms <span class=\"number\">14.197</span><span class=\"number\">.248</span><span class=\"number\">.253</span> (<span class=\"number\">14.197</span><span class=\"number\">.248</span><span class=\"number\">.253</span>)  <span class=\"number\">6.855</span> ms  <span class=\"number\">7.212</span> ms</span><br><span class=\"line\"> <span class=\"number\">8</span>  <span class=\"number\">14.197</span><span class=\"number\">.240</span><span class=\"number\">.249</span> (<span class=\"number\">14.197</span><span class=\"number\">.240</span><span class=\"number\">.249</span>)  <span class=\"number\">44.799</span> ms <span class=\"number\">14.197</span><span class=\"number\">.252</span><span class=\"number\">.189</span> (<span class=\"number\">14.197</span><span class=\"number\">.252</span><span class=\"number\">.189</span>)  <span class=\"number\">42.107</span> ms <span class=\"number\">14.197</span><span class=\"number\">.253</span><span class=\"number\">.145</span> (<span class=\"number\">14.197</span><span class=\"number\">.253</span><span class=\"number\">.145</span>)  <span class=\"number\">50.051</span> ms</span><br><span class=\"line\"> <span class=\"number\">9</span>  <span class=\"number\">14.197</span><span class=\"number\">.252</span><span class=\"number\">.54</span> (<span class=\"number\">14.197</span><span class=\"number\">.252</span><span class=\"number\">.54</span>)  <span class=\"number\">49.394</span> ms  <span class=\"number\">49.414</span> ms <span class=\"number\">14.197</span><span class=\"number\">.248</span><span class=\"number\">.94</span> (<span class=\"number\">14.197</span><span class=\"number\">.248</span><span class=\"number\">.94</span>)  <span class=\"number\">49.406</span> ms</span><br><span class=\"line\"><span class=\"number\">10</span>  <span class=\"number\">14.197</span><span class=\"number\">.149</span><span class=\"number\">.178</span> (<span class=\"number\">14.197</span><span class=\"number\">.149</span><span class=\"number\">.178</span>)  <span class=\"number\">49.406</span> ms  <span class=\"number\">49.383</span> ms <span class=\"number\">14.197</span><span class=\"number\">.178</span><span class=\"number\">.102</span> (<span class=\"number\">14.197</span><span class=\"number\">.178</span><span class=\"number\">.102</span>)  <span class=\"number\">49.382</span> ms</span><br><span class=\"line\"><span class=\"number\">11</span>  <span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.119</span> (<span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.119</span>)  <span class=\"number\">49.912</span> ms <span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.117</span> (<span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.117</span>)  <span class=\"number\">50.916</span> ms <span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.119</span> (<span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.119</span>)  <span class=\"number\">50.554</span> ms</span><br><span class=\"line\"><span class=\"number\">12</span>  <span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.126</span> (<span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.126</span>)  <span class=\"number\">47.975</span> ms *  <span class=\"number\">50.625</span> ms<span class=\"comment\">//5s未收到时打印一个*号并发送下一份数据包</span></span><br><span class=\"line\"><span class=\"number\">13</span>  * * *</span><br><span class=\"line\"><span class=\"number\">14</span>  * * *</span><br><span class=\"line\"><span class=\"number\">15</span>  * * *</span><br><span class=\"line\"><span class=\"number\">16</span>  * * *</span><br><span class=\"line\"><span class=\"number\">17</span>  * * *</span><br><span class=\"line\"><span class=\"number\">18</span>  * * *</span><br><span class=\"line\"><span class=\"number\">19</span>  * * *</span><br><span class=\"line\"><span class=\"number\">20</span>  * * *</span><br><span class=\"line\"><span class=\"number\">21</span>  * * *</span><br><span class=\"line\"><span class=\"number\">22</span>  * * *</span><br><span class=\"line\"><span class=\"number\">23</span>  * * *</span><br><span class=\"line\"><span class=\"number\">24</span>  * * *</span><br><span class=\"line\"><span class=\"number\">25</span>  * * *</span><br><span class=\"line\"><span class=\"number\">26</span>  * * *</span><br><span class=\"line\"><span class=\"number\">27</span>  * * *</span><br><span class=\"line\"><span class=\"number\">28</span>  * * *</span><br><span class=\"line\"><span class=\"number\">29</span>  * * *</span><br><span class=\"line\"><span class=\"number\">30</span>  * * *</span><br></pre></td></tr></table></figure>\n<p>tcpdump输出：</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">traceroute www.baidu.com(<span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span>)</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.39650</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33434</span>: [udp sum ok] UDP, length <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">58.009075</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">1</span>, id <span class=\"number\">5354</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)//ttl=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.1</span> &gt; <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span>: ICMP time exceeded <span class=\"keyword\">in</span>-transit, length <span class=\"number\">68</span>//网关回复icmp超时</span><br><span class=\"line\">\t<span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">1</span>, id <span class=\"number\">941</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.48912</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33435</span>: [udp sum ok] UDP, length <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">58.009114</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">1</span>, id <span class=\"number\">5355</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.43061</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33436</span>: [udp sum ok] UDP, length <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">58.009148</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">2</span>, id <span class=\"number\">5356</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)//ttl=<span class=\"number\">2</span></span><br><span class=\"line\"> <span class=\"number\">192.168</span><span class=\"meta\">.1</span><span class=\"meta\">.1</span> &gt; <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span>: ICMP time exceeded <span class=\"keyword\">in</span>-transit, length <span class=\"number\">68</span></span><br><span class=\"line\">\t<span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">1</span>, id <span class=\"number\">942</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)</span><br><span class=\"line\">//第<span class=\"number\">2</span>个路由器回复超时</span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.52554</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33437</span>: [udp sum ok] UDP, length <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">58.009189</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">2</span>, id <span class=\"number\">5357</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.51967</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33438</span>: [udp sum ok] UDP, length <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">58.009243</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">2</span>, id <span class=\"number\">5358</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.45922</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33439</span>: [udp sum ok] UDP, length <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">58.009281</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">3</span>, id <span class=\"number\">5359</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)//ttl==<span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.34392</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33440</span>: [udp sum ok] UDP, length <span class=\"number\">32</span>  </span><br><span class=\"line\">    <span class=\"number\">101.232</span><span class=\"meta\">.192</span><span class=\"meta\">.1</span> &gt; <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span>: ICMP time exceeded <span class=\"keyword\">in</span>-transit, length <span class=\"number\">60</span></span><br><span class=\"line\">\t<span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, id <span class=\"number\">945</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.57724</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.216</span><span class=\"meta\">.20</span><span class=\"meta\">.33440</span>: UDP, length <span class=\"number\">32</span></span><br><span class=\"line\">//第三个路由器回复icmpc超时</span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">59.304604</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">59</span>, id <span class=\"number\">0</span>, offset <span class=\"number\">0</span>, flags [DF], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">161</span>)</span><br></pre></td></tr></table></figure>\n<p>从上面包的情况可以看到:</p>\n<ul>\n<li>设备首先发送ucp包。若用更详细的打印看到端口号为源55050 目的端口:33443别的设备可能不同，但是都很大，这样到达时会发出端口不可达；ttl字段从1递增，源地址目的地址不变</li>\n<li>路由器根据ttl的值，回复icmp超时包，回复给设备，从源地址可以看到，经过的路由器；</li>\n<li>该icmp的包格式：<br>类型11  code 0/1  校验和<br>ip首部（包括选项)+原始ip数据报中数据的前8个字节</li>\n<li>注意：每一次的路由都可能不一样</li>\n</ul>\n<h5 id=\"关于ip源站选路选项\"><a href=\"#关于ip源站选路选项\" class=\"headerlink\" title=\"关于ip源站选路选项\"></a>关于ip源站选路选项</h5><ul>\n<li>ip通常都是动态的，即每个路由都要判断数据报下面该转发到哪个路由器，一般不对此进行控制；这里提供的思想是：</li>\n<li>由源站发送者指定路由，即经过哪些ip</li>\n<li>分为严格的源路由选择和宽松的源站选路</li>\n<li>前者必须采用确切的路由，若发现失败则路由器返回源站选路失败的icmp报文；</li>\n<li>后者致命一个数据包经过的ip清单，但是数据包在清单上指明的任意两个地址之间可以通过其他路由器；</li>\n<li>ip源站路由选项的格式：<br>包含在ip头部的选项中，因长度有限只能包含9个ip:<br>code(1) len(1) ptr(1) ip1(4) ip2(4)….</li>\n<li>eg: traceroute -g 192.168.23.1 <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a></li>\n</ul>\n<h5 id=\"traceroute实现\"><a href=\"#traceroute实现\" class=\"headerlink\" title=\"traceroute实现\"></a>traceroute实现</h5><ul>\n<li>参考linux traceroute源码实现；</li>\n<li>主要就是发送一多个dp包设置ttl递增，并将接收到的icmp报文打印出来；直到收到端口不可达报文时退出；</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"ping-and-traceroute\"><a href=\"#ping-and-traceroute\" class=\"headerlink\" title=\"ping and traceroute\"></a>ping and traceroute</h3><h4 id=\"ping\"><a href=\"#ping\" class=\"headerlink\" title=\"ping\"></a>ping</h4><p>ping是ICMP中的回显报文类型：</p>\n<ul>\n<li>ping 对应的icmp，type字段为0/8,code字段为0</li>\n<li>ICMP回显请求和应答报文格式：","more":"</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型(<span class=\"number\">0</span>/<span class=\"number\">8</span>）       code(<span class=\"number\">0</span>)       检验和 -<span class=\"number\">-4B</span></span><br><span class=\"line\">标示符（unix系统中为进程pid)   序号   -<span class=\"number\">-4B</span></span><br><span class=\"line\">           选项数据</span><br></pre></td></tr></table></figure>\n<ul>\n<li>最常见，回显时间，得到往返时间：<br>通过在icmp数据报文中存放发送请求的时间值来计算往返时间，当应答返回时，用当前时间减去存放在ICMP报文中的时间值，即是往返时间</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型(<span class=\"number\">0</span>/<span class=\"number\">8</span>）       code(<span class=\"number\">0</span>)       检验和 -<span class=\"number\">-4B</span></span><br><span class=\"line\">标示符（unix系统中为进程pid)   序号   -<span class=\"number\">-4B</span></span><br><span class=\"line\">           <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span>         -<span class=\"number\">-8B</span></span><br></pre></td></tr></table></figure>\n<p>共16Byte,除开ip头</p>\n<ul>\n<li>放抓包的图片，ping回显示时间</li>\n<li>ping程序代码</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">addr_conv</span><span class=\"params\">(<span class=\"keyword\">char</span> *address,struct in_addr *inaddr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> *<span class=\"title\">he</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(inet_aton(address,inaddr)==<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (<span class=\"number\">1</span>);</span><br><span class=\"line\">\the=gethostbyname(address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(he!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t*inaddr=*((struct in_addr *)he-&gt;h_addr_list[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send_icmp</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd,sockaddr_in send_addr)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recv_icmp</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd,sockaddr_in send_addr)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc,<span class=\"keyword\">char</span> **argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd;</span><br><span class=\"line\">\tsockfd=socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sockfd&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> \t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"creat socket error\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsockaddr_in send_addr;</span><br><span class=\"line\">\tbzero(&amp;send_addr,<span class=\"keyword\">sizeof</span>(send_addr));</span><br><span class=\"line\">\tsend_addr.sin_family=AF_INET;</span><br><span class=\"line\">\taddr_conv(argv[<span class=\"number\">1</span>],&amp;send_addr.sin_addr);</span><br><span class=\"line\"><span class=\"comment\">//send_addr.sin_addr.s_addr=inet_addr(\"192.168.0.110\");</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)</span><br><span class=\"line\"> \t&#123;</span><br><span class=\"line\">\t\tsend_icmp(sockfd,send_addr);</span><br><span class=\"line\">\t\trecv_icmp(sockfd,send_addr);</span><br><span class=\"line\">\t\tsleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> <span class=\"title\">checksum</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> *addr,<span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nleft=len;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> *w=addr;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> answer=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(nleft&gt;<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum+=*w++;</span><br><span class=\"line\">\t\tnleft-=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(nleft==<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t*(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)(&amp;answer)=*(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)w;</span><br><span class=\"line\">\t\tsum+=answer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsum=(sum&gt;&gt;<span class=\"number\">16</span>)+(sum&amp;<span class=\"number\">0xffff</span>);</span><br><span class=\"line\">\tsum+=(sum&gt;&gt;<span class=\"number\">16</span>);</span><br><span class=\"line\">\tanswer=~sum;</span><br><span class=\"line\">\t<span class=\"comment\">//answer=(unsigned short)sum&amp;0xffff;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> answer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send_icmp</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd,sockaddr_in send_addr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">short</span> <span class=\"keyword\">int</span> seq=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>  buf[<span class=\"number\">8</span>+<span class=\"number\">8</span>];</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">icmphdr</span> *<span class=\"title\">icmp</span>=(<span class=\"title\">struct</span> <span class=\"title\">icmphdr</span> *)<span class=\"title\">buf</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">//填充icmp首部</span></span><br><span class=\"line\">\ticmp-&gt;type=ICMP_ECHO;<span class=\"comment\">//类型</span></span><br><span class=\"line\">\ticmp-&gt;code=<span class=\"number\">0</span>;<span class=\"comment\">//和编码共同决定是回显报文</span></span><br><span class=\"line\">\ticmp-&gt;checksum=<span class=\"number\">0</span>;<span class=\"comment\">//头部包含校验和</span></span><br><span class=\"line\">\ticmp-&gt;un.echo.id=getpid();<span class=\"comment\">//标识符，唯一性，一般填充pid，这样即使几个程序发送ping也能识别，写成其他时接收失败</span></span><br><span class=\"line\">\ticmp-&gt;un.echo.sequence=seq++;<span class=\"comment\">//顺序号，回显时，显示，一般无规定，但是会在此基础上加１，接着加１，，</span></span><br><span class=\"line\">\t<span class=\"comment\">//填充icmp数据(时间)//这里报文数据只有时间戳</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">//tv=(struct timeval*)icmp-&gt;icmp_data;</span></span><br><span class=\"line\">\tgettimeofday(&amp;tv,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(buf+<span class=\"number\">8</span>,&amp;tv,<span class=\"keyword\">sizeof</span>(tv));</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> buflen=<span class=\"keyword\">sizeof</span>(struct icmphdr)+<span class=\"keyword\">sizeof</span>(struct timeval);</span><br><span class=\"line\">\t<span class=\"comment\">//计算校验和</span></span><br><span class=\"line\">\ticmp-&gt;checksum=checksum((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> *)buf,buflen);</span><br><span class=\"line\">\t<span class=\"comment\">//发送icmp数据包</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len=sendto(sockfd,buf,buflen,<span class=\"number\">0</span>,(struct sockaddr *)&amp;send_addr,<span class=\"keyword\">sizeof</span>(send_addr));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(len&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"send icmp error\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"senmd ok\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recv_icmp</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd,sockaddr_in send_addr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">256</span>];</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">icmphdr</span> *<span class=\"title\">icmp</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ip</span> *<span class=\"title\">ip</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ipheadlen;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> icmplen;</span><br><span class=\"line\">\t<span class=\"comment\">//接收icmp响应</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> n=recvfrom(sockfd,buf,<span class=\"keyword\">sizeof</span>(buf),<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(n&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"recv error\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tip=(struct ip *)buf;\t</span><br><span class=\"line\">\t\tipheadlen=ip-&gt;ip_hl&lt;&lt;<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\ticmplen=n-ipheadlen;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(icmplen&lt;<span class=\"number\">16</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\ticmp=(struct icmphdr *)(buf+ipheadlen);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(icmp-&gt;type==ICMP_ECHOREPLY&amp;&amp;icmp-&gt;un.echo.id==getpid())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//计算时间差</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">recv_tv</span>;</span></span><br><span class=\"line\">\tgettimeofday(&amp;recv_tv,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">send_tv</span>;</span></span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(&amp;send_tv,icmp+<span class=\"number\">1</span>,<span class=\"keyword\">sizeof</span>(send_tv));</span><br><span class=\"line\">\trecv_tv.tv_sec-=send_tv.tv_sec;</span><br><span class=\"line\">\trecv_tv.tv_usec+=recv_tv.tv_sec*<span class=\"number\">1000000L</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> interval=recv_tv.tv_usec-send_tv.tv_usec;</span><br><span class=\"line\">\t<span class=\"comment\">//输出信息</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;icmplen&lt;&lt; <span class=\"string\">\" bytes fromfdfd \"</span>&lt;&lt;inet_ntoa(send_addr.sin_addr);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" icmp_seq=\"</span>&lt;&lt;icmp-&gt;un.echo.sequence&lt;&lt;<span class=\"string\">\" bytes=\"</span>&lt;&lt;icmplen&lt;&lt;<span class=\"string\">\" ttl=\"</span>&lt;&lt;(<span class=\"keyword\">int</span>)ip-&gt;ip_ttl;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\" time=\"</span>&lt;&lt;(<span class=\"keyword\">float</span>)interval/<span class=\"number\">1000.0</span>&lt;&lt;<span class=\"string\">\"ms\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ip 记录路由选项：<br>利用ip头，ip头长度字段为4bit,最长的ip首部为15x32bit=60字节，所以除去头20字节，选项字段最大40字节，除去3字节的code,len.ptr三个字节，剩下37个字节，可以容纳9个ip地址<br>windows下可以通过ping -r ip来尝试</li>\n<li>ip时间戳选项</li>\n</ul>\n<h4 id=\"traceroute\"><a href=\"#traceroute\" class=\"headerlink\" title=\"traceroute\"></a>traceroute</h4><h5 id=\"traceroute主要两点\"><a href=\"#traceroute主要两点\" class=\"headerlink\" title=\"traceroute主要两点\"></a>traceroute主要两点</h5><ul>\n<li>利用ttl,ttl是一个有限值，每经过一个路由器减1，这样放置循环发包。</li>\n<li>利用icmp报文，当路由器接收到ttl为0或1时，不转发，而是丢弃，并给信源回复一个icmp超时信息，且包含该路由器的ip</li>\n<li>具体流程：<br>traceroute发送一份ttl字段为1的ip数据报给目的主机，处理这个数据报的第一个路由器将ttl值减去1，丢弃该数据报，并发送一份超时icmp报文，这样就得到了该路径的第一个路由器的地址；<br>以此类推，发送ttl为2的数据报，则得到第二个路由器的地址；直到到达目的地址；<br>怎么知道到达了目的地?<br>traceroute发送了一份udp数据包给目的主机，但它选择了一个不可能的值作为udp端口号（大于30000)，使目的主机的任何一个应用程序都不可能使用该端口号，则当包到达目的主机时，目的主机的udp模块会产生一个端口不可达的错误icmp报文。traceroute要做的是区分icmp是超时还是端口不可达，以判断什么时候结束</li>\n</ul>\n<h5 id=\"traceroute命令\"><a href=\"#traceroute命令\" class=\"headerlink\" title=\"traceroute命令\"></a>traceroute命令</h5><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">traceroute www.baidu.com</span><br><span class=\"line\">traceroute to www.baidu.com (<span class=\"number\">119.75</span><span class=\"number\">.216</span><span class=\"number\">.20</span>), <span class=\"number\">30</span> hops max, <span class=\"number\">60</span> byte packets<span class=\"comment\">//ttl字段为30跳，每个数据包为60字节（20ip头等）</span></span><br><span class=\"line\"> <span class=\"number\">1</span>  <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span> (<span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>)  <span class=\"number\">2.762</span> ms  <span class=\"number\">3.485</span> ms  <span class=\"number\">3.477</span> ms/发到网关<span class=\"number\">1</span>,针对每个ttl值发送三份包，分别在<span class=\"number\">2.762</span>,<span class=\"number\">3.485</span>,<span class=\"number\">3.477</span>收到</span><br><span class=\"line\"> <span class=\"number\">2</span>  <span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.1</span> (<span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.1</span>)  <span class=\"number\">3.466</span> ms  <span class=\"number\">3.453</span> ms  <span class=\"number\">3.443</span> ms</span><br><span class=\"line\"> <span class=\"number\">3</span>  <span class=\"number\">101.232</span><span class=\"number\">.192</span><span class=\"number\">.1</span> (<span class=\"number\">101.232</span><span class=\"number\">.192</span><span class=\"number\">.1</span>)  <span class=\"number\">6.807</span> ms  <span class=\"number\">6.813</span> ms  <span class=\"number\">7.412</span> ms</span><br><span class=\"line\"> <span class=\"number\">4</span>  <span class=\"number\">10.144</span><span class=\"number\">.11</span><span class=\"number\">.37</span> (<span class=\"number\">10.144</span><span class=\"number\">.11</span><span class=\"number\">.37</span>)  <span class=\"number\">7.405</span> ms  <span class=\"number\">7.393</span> ms  <span class=\"number\">7.381</span> ms</span><br><span class=\"line\"> <span class=\"number\">5</span>  <span class=\"number\">10.144</span><span class=\"number\">.14</span><span class=\"number\">.138</span> (<span class=\"number\">10.144</span><span class=\"number\">.14</span><span class=\"number\">.138</span>)  <span class=\"number\">7.369</span> ms  <span class=\"number\">7.362</span> ms  <span class=\"number\">7.340</span> ms</span><br><span class=\"line\"> <span class=\"number\">6</span>  * * <span class=\"number\">14.197</span><span class=\"number\">.242</span><span class=\"number\">.145</span> (<span class=\"number\">14.197</span><span class=\"number\">.242</span><span class=\"number\">.145</span>)  <span class=\"number\">10.329</span> ms</span><br><span class=\"line\"> <span class=\"number\">7</span>  <span class=\"number\">14.197</span><span class=\"number\">.218</span><span class=\"number\">.173</span> (<span class=\"number\">14.197</span><span class=\"number\">.218</span><span class=\"number\">.173</span>)  <span class=\"number\">7.240</span> ms <span class=\"number\">14.197</span><span class=\"number\">.248</span><span class=\"number\">.253</span> (<span class=\"number\">14.197</span><span class=\"number\">.248</span><span class=\"number\">.253</span>)  <span class=\"number\">6.855</span> ms  <span class=\"number\">7.212</span> ms</span><br><span class=\"line\"> <span class=\"number\">8</span>  <span class=\"number\">14.197</span><span class=\"number\">.240</span><span class=\"number\">.249</span> (<span class=\"number\">14.197</span><span class=\"number\">.240</span><span class=\"number\">.249</span>)  <span class=\"number\">44.799</span> ms <span class=\"number\">14.197</span><span class=\"number\">.252</span><span class=\"number\">.189</span> (<span class=\"number\">14.197</span><span class=\"number\">.252</span><span class=\"number\">.189</span>)  <span class=\"number\">42.107</span> ms <span class=\"number\">14.197</span><span class=\"number\">.253</span><span class=\"number\">.145</span> (<span class=\"number\">14.197</span><span class=\"number\">.253</span><span class=\"number\">.145</span>)  <span class=\"number\">50.051</span> ms</span><br><span class=\"line\"> <span class=\"number\">9</span>  <span class=\"number\">14.197</span><span class=\"number\">.252</span><span class=\"number\">.54</span> (<span class=\"number\">14.197</span><span class=\"number\">.252</span><span class=\"number\">.54</span>)  <span class=\"number\">49.394</span> ms  <span class=\"number\">49.414</span> ms <span class=\"number\">14.197</span><span class=\"number\">.248</span><span class=\"number\">.94</span> (<span class=\"number\">14.197</span><span class=\"number\">.248</span><span class=\"number\">.94</span>)  <span class=\"number\">49.406</span> ms</span><br><span class=\"line\"><span class=\"number\">10</span>  <span class=\"number\">14.197</span><span class=\"number\">.149</span><span class=\"number\">.178</span> (<span class=\"number\">14.197</span><span class=\"number\">.149</span><span class=\"number\">.178</span>)  <span class=\"number\">49.406</span> ms  <span class=\"number\">49.383</span> ms <span class=\"number\">14.197</span><span class=\"number\">.178</span><span class=\"number\">.102</span> (<span class=\"number\">14.197</span><span class=\"number\">.178</span><span class=\"number\">.102</span>)  <span class=\"number\">49.382</span> ms</span><br><span class=\"line\"><span class=\"number\">11</span>  <span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.119</span> (<span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.119</span>)  <span class=\"number\">49.912</span> ms <span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.117</span> (<span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.117</span>)  <span class=\"number\">50.916</span> ms <span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.119</span> (<span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.119</span>)  <span class=\"number\">50.554</span> ms</span><br><span class=\"line\"><span class=\"number\">12</span>  <span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.126</span> (<span class=\"number\">182.61</span><span class=\"number\">.253</span><span class=\"number\">.126</span>)  <span class=\"number\">47.975</span> ms *  <span class=\"number\">50.625</span> ms<span class=\"comment\">//5s未收到时打印一个*号并发送下一份数据包</span></span><br><span class=\"line\"><span class=\"number\">13</span>  * * *</span><br><span class=\"line\"><span class=\"number\">14</span>  * * *</span><br><span class=\"line\"><span class=\"number\">15</span>  * * *</span><br><span class=\"line\"><span class=\"number\">16</span>  * * *</span><br><span class=\"line\"><span class=\"number\">17</span>  * * *</span><br><span class=\"line\"><span class=\"number\">18</span>  * * *</span><br><span class=\"line\"><span class=\"number\">19</span>  * * *</span><br><span class=\"line\"><span class=\"number\">20</span>  * * *</span><br><span class=\"line\"><span class=\"number\">21</span>  * * *</span><br><span class=\"line\"><span class=\"number\">22</span>  * * *</span><br><span class=\"line\"><span class=\"number\">23</span>  * * *</span><br><span class=\"line\"><span class=\"number\">24</span>  * * *</span><br><span class=\"line\"><span class=\"number\">25</span>  * * *</span><br><span class=\"line\"><span class=\"number\">26</span>  * * *</span><br><span class=\"line\"><span class=\"number\">27</span>  * * *</span><br><span class=\"line\"><span class=\"number\">28</span>  * * *</span><br><span class=\"line\"><span class=\"number\">29</span>  * * *</span><br><span class=\"line\"><span class=\"number\">30</span>  * * *</span><br></pre></td></tr></table></figure>\n<p>tcpdump输出：</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">traceroute www.baidu.com(<span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span>)</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.39650</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33434</span>: [udp sum ok] UDP, length <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">58.009075</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">1</span>, id <span class=\"number\">5354</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)//ttl=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.1</span> &gt; <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span>: ICMP time exceeded <span class=\"keyword\">in</span>-transit, length <span class=\"number\">68</span>//网关回复icmp超时</span><br><span class=\"line\">\t<span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">1</span>, id <span class=\"number\">941</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.48912</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33435</span>: [udp sum ok] UDP, length <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">58.009114</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">1</span>, id <span class=\"number\">5355</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.43061</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33436</span>: [udp sum ok] UDP, length <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">58.009148</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">2</span>, id <span class=\"number\">5356</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)//ttl=<span class=\"number\">2</span></span><br><span class=\"line\"> <span class=\"number\">192.168</span><span class=\"meta\">.1</span><span class=\"meta\">.1</span> &gt; <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span>: ICMP time exceeded <span class=\"keyword\">in</span>-transit, length <span class=\"number\">68</span></span><br><span class=\"line\">\t<span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">1</span>, id <span class=\"number\">942</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)</span><br><span class=\"line\">//第<span class=\"number\">2</span>个路由器回复超时</span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.52554</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33437</span>: [udp sum ok] UDP, length <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">58.009189</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">2</span>, id <span class=\"number\">5357</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.51967</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33438</span>: [udp sum ok] UDP, length <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">58.009243</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">2</span>, id <span class=\"number\">5358</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.45922</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33439</span>: [udp sum ok] UDP, length <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">58.009281</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">3</span>, id <span class=\"number\">5359</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)//ttl==<span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.34392</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.213</span><span class=\"meta\">.61</span><span class=\"meta\">.33440</span>: [udp sum ok] UDP, length <span class=\"number\">32</span>  </span><br><span class=\"line\">    <span class=\"number\">101.232</span><span class=\"meta\">.192</span><span class=\"meta\">.1</span> &gt; <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span>: ICMP time exceeded <span class=\"keyword\">in</span>-transit, length <span class=\"number\">60</span></span><br><span class=\"line\">\t<span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, id <span class=\"number\">945</span>, offset <span class=\"number\">0</span>, flags [none], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">60</span>)</span><br><span class=\"line\">    <span class=\"number\">192.168</span><span class=\"meta\">.0</span><span class=\"meta\">.110</span><span class=\"meta\">.57724</span> &gt; <span class=\"number\">119.75</span><span class=\"meta\">.216</span><span class=\"meta\">.20</span><span class=\"meta\">.33440</span>: UDP, length <span class=\"number\">32</span></span><br><span class=\"line\">//第三个路由器回复icmpc超时</span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">21</span>:<span class=\"number\">59.304604</span> <span class=\"built_in\">IP</span> (tos <span class=\"number\">0x0</span>, ttl <span class=\"number\">59</span>, id <span class=\"number\">0</span>, offset <span class=\"number\">0</span>, flags [DF], proto UDP (<span class=\"number\">17</span>), length <span class=\"number\">161</span>)</span><br></pre></td></tr></table></figure>\n<p>从上面包的情况可以看到:</p>\n<ul>\n<li>设备首先发送ucp包。若用更详细的打印看到端口号为源55050 目的端口:33443别的设备可能不同，但是都很大，这样到达时会发出端口不可达；ttl字段从1递增，源地址目的地址不变</li>\n<li>路由器根据ttl的值，回复icmp超时包，回复给设备，从源地址可以看到，经过的路由器；</li>\n<li>该icmp的包格式：<br>类型11  code 0/1  校验和<br>ip首部（包括选项)+原始ip数据报中数据的前8个字节</li>\n<li>注意：每一次的路由都可能不一样</li>\n</ul>\n<h5 id=\"关于ip源站选路选项\"><a href=\"#关于ip源站选路选项\" class=\"headerlink\" title=\"关于ip源站选路选项\"></a>关于ip源站选路选项</h5><ul>\n<li>ip通常都是动态的，即每个路由都要判断数据报下面该转发到哪个路由器，一般不对此进行控制；这里提供的思想是：</li>\n<li>由源站发送者指定路由，即经过哪些ip</li>\n<li>分为严格的源路由选择和宽松的源站选路</li>\n<li>前者必须采用确切的路由，若发现失败则路由器返回源站选路失败的icmp报文；</li>\n<li>后者致命一个数据包经过的ip清单，但是数据包在清单上指明的任意两个地址之间可以通过其他路由器；</li>\n<li>ip源站路由选项的格式：<br>包含在ip头部的选项中，因长度有限只能包含9个ip:<br>code(1) len(1) ptr(1) ip1(4) ip2(4)….</li>\n<li>eg: traceroute -g 192.168.23.1 <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a></li>\n</ul>\n<h5 id=\"traceroute实现\"><a href=\"#traceroute实现\" class=\"headerlink\" title=\"traceroute实现\"></a>traceroute实现</h5><ul>\n<li>参考linux traceroute源码实现；</li>\n<li>主要就是发送一多个dp包设置ttl递增，并将接收到的icmp报文打印出来；直到收到端口不可达报文时退出；</li>\n</ul>"},{"title":"tcpip_routeicmp","date":"2018-06-10T08:59:04.000Z","_content":"### IP选路和ICMP协议\n#### IP如何选路概述：\n+ ip选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组，区别于选路策略，后者是一组决定把哪些路由放入路由表的规则；ip执行选路机制，而路由守护程序则一般提供选路策略如rip,ospf\n+ 点对点时，直接送到  \n+ 非点对点时，经过路由器送到  \n+ Ip层可以是配置为路由或者主机前者非则转发，后者非则丢弃\n+ 路由表项：每一项为<!--more-->\n  + 目的ip地址（网络地址指定网络中所有主机或主机地址);\n  + 下一站路由器的ip地址，可能充当中继转发的，下一站非终点；\n  + 标志：指明目的地址是网络还是主机，下一站是路由器还是直连的接口\n  + 数据传输的网络接口如wlan0,eth0\n+ ip选路是逐跳进行的，\n+ 例子：\n没连接热点前：\n```\nernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n10.42.0.0       *               255.255.255.0   U     600    0        0 wlp2s0\nlink-local      *               255.255.0.0     U     1000   0        0 wlp2s0```\n\n连接热点后：\n```\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         192.168.0.1     0.0.0.0         UG    600    0        0 wlp2s0\nlink-local      *               255.255.0.0     U     1000   0        0 wlp2s0\n192.168.0.0     *               255.255.255.0   U     600    0        0 wlp2s0\n```\n```\nDestination \t目标网段或者主机\nGateway \t网关地址，”*” 表示目标是本主机所属的网络，不需要路由\nGenmask \t网络掩码\nFlags \t标记。一些可能的标记如下：\n  \tU — 路由是活动的\n  \tH — 目标是一个主机\n  \tG — 路由指向网关\n  \tR — 恢复动态路由产生的表项\n  \tD — 由路由的后台程序动态地安装,(由重定向报文创建）\n  \tM — 由路由的后台程序修改(已被重定向报文修改）\n  \t! — 拒绝路由\nMetric \t路由距离，到达指定网络所需的中转数（linux 内核中没有使用）\nRef \t路由项引用次数（linux 内核中没有使用）\nUse \t此路由项被路由软件查找的次数\nIface \t该路由表项对应的输出接口```\n\n##### 如何搜索路由表\n+ 搜索路由表，目的ip地址匹配条母时，送到该条目的下一站，否则下一步：\n+ 搜索路由表，寻找与目的网络相匹配的条目，找到则送到下一站，如本地局域网；否则下一步：\n+ 搜索路由表，寻找标为默认的条目，有则使用它\n+ 若走完最后一步都没有，则数据包无法被传送，会向生成数据包的程序返回主机不可达或者网络不可达的错误\n+ 详细例子见卷１，这里较清楚了\n\n##### 子网寻址rfc950\n+ 主机号再分为子网号和主机号，子网掩码也跟着变化；这样可以缩小路由表规模，想象一个包含30个子网的B类地址和30个C类地址相比\n+ 此时，外网-->网关-->局域网１-->局域网１中的子网（局域网）10-->子网11。。。\n+ 所以此时网关并非就是其直接路由器，若主机在子网11,10中，路由器需要知道发往哪个子网，通过子网掩码\n+ 给定ip地址和子网掩码后能知道什么：\n知道该主机所在的子网；路由器可以知道是本子网的主机还是本网络中其他子网的主机还是其他网络的主机。。。路由进行的比较不需要比较到主机，如先比较类别网络地址如A,B,C:  \n如我们主机为140.252.1.1,子掩码为255.255.255.0,则与目的ip地址比较：140.252.4.5,可以知道B类网络地址相同但是子网不同(1,4),就不用再比较主机了，\n\n#####  特殊的网络地址\n##### ifconfig命令\n+ ifconfig -a\n```\nwlp2s0    Link encap:Ethernet  HWaddr 48:5a:b6:6e:c9:5f  \n          inet addr:192.168.0.110  Bcast:192.168.0.255  Mask:255.255.255.0\n          inet6 addr: fe80::d713:7c0f:b40c:c085/64 Scope:Link\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:7032 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:4297 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:3668623 (3.6 MB)  TX bytes:703812 (703.8 KB)\n```\n##### netstat命令\n+ 其实这个命令的功能很强，可以相互开服务端客户端通信和反向shell\n+ netstat -in\n```\nKernel Interface table\nIface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg\nenp1s0     1500 0         0      0      0 0             0      0      0      0 BMU\nlo        65536 0      1404      0      0 0          1404      0      0      0 LRU\nwlp2s0     1500 0      7257      0      0 0          4311      0      0      0 BMRU\n```\n\n```\nnetstat -rn\nKernel IP routing table\nDestination     Gateway         Genmask         Flags   MSS Window  irtt Iface\n0.0.0.0         192.168.0.1     0.0.0.0         UG        0 0          0 wlp2s0\n169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 wlp2s0\n192.168.0.0     0.0.0.0         255.255.255.0   U         0 0          0 wlp2s0\n```\n##### 初始化路由表\n+ ifconfig设置接口地址，并用route　命令添加或删除路由表项\n##### 主机可以选择转发或者不转发报文\n+ 在配置文件中配置ipfordwarding:\n+ echo 1 >> /proc/sys/net/ipv4/ip_forwardroot\n#### ICMP协议rfc792\n##### Icmp报文：\n+ ICMP：IP头(20字节）+ICMP报文\n+ IP头：\n```\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |Version|  IHL  |Type of Service|          Total Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |         Identification        |Flags|      Fragment Offset    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Time to Live |    Protocol   |         Header Checksum       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                       Source Address                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Destination Address                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Options                    |    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n其中options和padding不一定有\n+ ICMP报文：type+code共同决定ICMP类型，如回显or差错，，，\n```\n   0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |     Type      |     Code      |          Checksum             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |       different type and code has different content           |\n   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n+ 被封装于ip报文中，ip头加icmp,所有报文前四个字节都相同\n(8位类型，8位代码，16位校验和）\n+ 类型+代码决定ICMP的报文类型，种类很多，见协议卷表\n+ 下列几种不会导致icmp差错报文：\n + icmp差错报文；\n + 目的地址为广播地址\n + 作为链路层的广播地址\n + 不是ip分片第一片\n + 源地址不能为零地址，环回地址，广播地址或多播地址\n + 上述是为了防止过去允许icmp差错报文对广播分组带来的广播风暴\n+ ##### ICMP协议总结几种类型：\n + 主机不可达\n + 重定向错误\n + 路由发现报文\n + icmp地址掩码请求和应答\n + icmp时间戳请求和应答\n + icmp端口不可达\n + ping 回显请求：\n + 等等见表\n + 且类型不同发送的报文格式不同\n+ 主机不可达：当路由器收到一份ip数据报但是在路由表中搜索后找不到，不能转发时，会发送一份icmp主机不可达的差错报文\n+ 还有可能是已经经过了几个路由器后出现主机或网络不可达的情况，所以若是测试局域网，则先让路由器断开网络，ping路由器则确保问题不是在本地，而是在网络上；\n+ icmp重定向错误：  \n举个例子，主机在路由表中搜索后将数据包发给默认路由，R1路由器，接着R1路由器搜索后发送给R2路由器，并同时发现它正在发送的接口(R2)和数据报到达的接口相同，即主机和两个路由器所在lan，即在同一个lan中）此时主机可以直接发送给R2,所以R1就发送一份ICMP重定向报文给主机，这样主机下次就可以直接发给R2了\n+ 如何更新路由表?通过ICMP的路由器发现报文：\n以及利用路由器的定期广播多播它们的路由器通告报文rfc1256,而它一般是由用户守护进程来创建和处理\n+ icmp地址掩码请求和应答，发送对某个ip地址请求地址掩码，并接收到子网掩码。路由器回复或者主机回复\n+  icmp时间戳请求和应答，通过向某个IP主机发送这个，从而得到时间信息，telnet也可以进行，如NTP协议（网络时间协议）\n+ icmp端口不可达：udp报文发送给主机后，若端口不匹配，对方主机会发送端口不可达的差错报文\n+ ping回显，后面有文章记录ping程序编写\n#### 动态选路 \n##### 使用场景\n上述讲的是静态路由表的情况：适合于1网络较小，2且与其他网络只有单个连接点，3且没有多余的路由时（如主路由失败，可以选择备用路由）；\n+ 总结：一种更新路由表的动态协议，从而达到最短路径  \n+ 上述三个条件不满足时，通常使用动态选路协议\n+ 当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时出现动态选路，路由器之间必须采用选路协议进行通信；路由器上有一个称为路由守护程序的进程，它运行选路协议，并与相邻的路由器通信，根据收到的信息，更新路由表\n\n##### 分类：\nRIP ,OSPF(开放最短路径优先）,BGP\n\n##### 宏观上看\n在internet上，存在大量的主机，路由器等；并以一组自治系统(AS)的方式组织的，每个自治系统通常由单个实体管理，比如大学校园，公司，常常被定义为一个自治系统，NSFNET的internet骨干网形成一个自治系统；\n+ 自治系统中使用的选路协议，称为内部网关协议IGP或者称为域内选路协议，这些协议有RIP,OSPF\n+ 用于不同自治系统之间的路由器，称为外部网关协议EGP,常见有BGP\n+ unix选路守护程序：routed,gated等\n\n##### RIP：rfc1058\n+ rip采用udp报文，端口号位520，为一种采用距离向量的协议,易受攻击\n+ 流程：\n  + 初始化：启动一个路由守护进程时，先判断启动了哪些接口，接着在每个接口上发送请求报文，要求其他路由器发送完整的路由表，广播或点对点\n  + 接收请求：接收到上述请求后，会回复完整的路由表，否则处理请求报文每一个表项，若有链接到指明地址路由，则度量设置为我们的值，否则设置为16表示无穷大。返回响应\n  + 接收到响应后，更新路由表，如增加或修改或删除,采用Dijkstra算法得到最短路径树\n  + 定期选路更新，30s一次，进行广播发送完整路由表给相邻的路由器\n  + 触发更新：即每当度量发生变化，则对它进行更新，只需要发送度量变化的表项\n  + 定时器：3min内无更新路由，则度量设置为无穷大，标注为删除，再过60s删除并传波\n+ 注:度量就是跳数，相邻路由度量为１\n+ rip问题：无子网概念；路由器或链路故障要很久才能稳定下来，即收敛慢；易发生环回路由；跳数限制了网络大小15\n \n##### OSPF开放最短路径优先：rfc1247\n+ 是一个链路状态协议；\n+ 使用ip协议而不是udp.tcp,\n+ 不与邻站交换距离信息而是主动测试与其他邻站相连链路状态，并将这些信息发送给它的其他邻站，邻站接着广播出去，每个路由器接收到后更新路由表\n+ 收敛快\n+ 可以对每个ip服务类型计算各自的路由集，意味着对任何目的，可以有多个路由表表项，每个表项对应一个ip服务类型；\n+ 给每个接口指派一个费用，通过吞吐率，往返时间，可靠性等，可以给每个ip服务类型指派一个费用\n+ **同一个目的地址存在多个相同费用的路由时，在这些路由上平均分配流量，即流量平衡**\n+ **支持子网**\n+ 路由器之间的点对点链路不需要每端都有一个ip地址，－无编号网络，节省ip\n+ 多播而非广播\n\n##### BGP边界网关协议rfc1268\n+ 自治系统分类：\n + 残桩自治系统，他和其他自治系统只有单个连接，只有本地流量\n + 多接口自治系统，和其他多个自治系统有多个链接，但是拒绝传送流量\n + 转送自治系统，多链接且在一些策略准则下，它可以传送本地流量和通过流量\n+ 是距离向量协议，用于自治系统之间，定期发送keepalive报文，30s\n##### CIDR无类型域间选路：rfc1518,1519\n待探索","source":"_posts/tcpip-routeicmp.md","raw":"---\ntitle: tcpip_routeicmp\ndate: 2018-06-10 16:59:04\ntags: tcpip_ip\ncategories: tcpip\n---\n### IP选路和ICMP协议\n#### IP如何选路概述：\n+ ip选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组，区别于选路策略，后者是一组决定把哪些路由放入路由表的规则；ip执行选路机制，而路由守护程序则一般提供选路策略如rip,ospf\n+ 点对点时，直接送到  \n+ 非点对点时，经过路由器送到  \n+ Ip层可以是配置为路由或者主机前者非则转发，后者非则丢弃\n+ 路由表项：每一项为<!--more-->\n  + 目的ip地址（网络地址指定网络中所有主机或主机地址);\n  + 下一站路由器的ip地址，可能充当中继转发的，下一站非终点；\n  + 标志：指明目的地址是网络还是主机，下一站是路由器还是直连的接口\n  + 数据传输的网络接口如wlan0,eth0\n+ ip选路是逐跳进行的，\n+ 例子：\n没连接热点前：\n```\nernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n10.42.0.0       *               255.255.255.0   U     600    0        0 wlp2s0\nlink-local      *               255.255.0.0     U     1000   0        0 wlp2s0```\n\n连接热点后：\n```\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         192.168.0.1     0.0.0.0         UG    600    0        0 wlp2s0\nlink-local      *               255.255.0.0     U     1000   0        0 wlp2s0\n192.168.0.0     *               255.255.255.0   U     600    0        0 wlp2s0\n```\n```\nDestination \t目标网段或者主机\nGateway \t网关地址，”*” 表示目标是本主机所属的网络，不需要路由\nGenmask \t网络掩码\nFlags \t标记。一些可能的标记如下：\n  \tU — 路由是活动的\n  \tH — 目标是一个主机\n  \tG — 路由指向网关\n  \tR — 恢复动态路由产生的表项\n  \tD — 由路由的后台程序动态地安装,(由重定向报文创建）\n  \tM — 由路由的后台程序修改(已被重定向报文修改）\n  \t! — 拒绝路由\nMetric \t路由距离，到达指定网络所需的中转数（linux 内核中没有使用）\nRef \t路由项引用次数（linux 内核中没有使用）\nUse \t此路由项被路由软件查找的次数\nIface \t该路由表项对应的输出接口```\n\n##### 如何搜索路由表\n+ 搜索路由表，目的ip地址匹配条母时，送到该条目的下一站，否则下一步：\n+ 搜索路由表，寻找与目的网络相匹配的条目，找到则送到下一站，如本地局域网；否则下一步：\n+ 搜索路由表，寻找标为默认的条目，有则使用它\n+ 若走完最后一步都没有，则数据包无法被传送，会向生成数据包的程序返回主机不可达或者网络不可达的错误\n+ 详细例子见卷１，这里较清楚了\n\n##### 子网寻址rfc950\n+ 主机号再分为子网号和主机号，子网掩码也跟着变化；这样可以缩小路由表规模，想象一个包含30个子网的B类地址和30个C类地址相比\n+ 此时，外网-->网关-->局域网１-->局域网１中的子网（局域网）10-->子网11。。。\n+ 所以此时网关并非就是其直接路由器，若主机在子网11,10中，路由器需要知道发往哪个子网，通过子网掩码\n+ 给定ip地址和子网掩码后能知道什么：\n知道该主机所在的子网；路由器可以知道是本子网的主机还是本网络中其他子网的主机还是其他网络的主机。。。路由进行的比较不需要比较到主机，如先比较类别网络地址如A,B,C:  \n如我们主机为140.252.1.1,子掩码为255.255.255.0,则与目的ip地址比较：140.252.4.5,可以知道B类网络地址相同但是子网不同(1,4),就不用再比较主机了，\n\n#####  特殊的网络地址\n##### ifconfig命令\n+ ifconfig -a\n```\nwlp2s0    Link encap:Ethernet  HWaddr 48:5a:b6:6e:c9:5f  \n          inet addr:192.168.0.110  Bcast:192.168.0.255  Mask:255.255.255.0\n          inet6 addr: fe80::d713:7c0f:b40c:c085/64 Scope:Link\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:7032 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:4297 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:3668623 (3.6 MB)  TX bytes:703812 (703.8 KB)\n```\n##### netstat命令\n+ 其实这个命令的功能很强，可以相互开服务端客户端通信和反向shell\n+ netstat -in\n```\nKernel Interface table\nIface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg\nenp1s0     1500 0         0      0      0 0             0      0      0      0 BMU\nlo        65536 0      1404      0      0 0          1404      0      0      0 LRU\nwlp2s0     1500 0      7257      0      0 0          4311      0      0      0 BMRU\n```\n\n```\nnetstat -rn\nKernel IP routing table\nDestination     Gateway         Genmask         Flags   MSS Window  irtt Iface\n0.0.0.0         192.168.0.1     0.0.0.0         UG        0 0          0 wlp2s0\n169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 wlp2s0\n192.168.0.0     0.0.0.0         255.255.255.0   U         0 0          0 wlp2s0\n```\n##### 初始化路由表\n+ ifconfig设置接口地址，并用route　命令添加或删除路由表项\n##### 主机可以选择转发或者不转发报文\n+ 在配置文件中配置ipfordwarding:\n+ echo 1 >> /proc/sys/net/ipv4/ip_forwardroot\n#### ICMP协议rfc792\n##### Icmp报文：\n+ ICMP：IP头(20字节）+ICMP报文\n+ IP头：\n```\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |Version|  IHL  |Type of Service|          Total Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |         Identification        |Flags|      Fragment Offset    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Time to Live |    Protocol   |         Header Checksum       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                       Source Address                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Destination Address                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Options                    |    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n其中options和padding不一定有\n+ ICMP报文：type+code共同决定ICMP类型，如回显or差错，，，\n```\n   0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |     Type      |     Code      |          Checksum             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |       different type and code has different content           |\n   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n+ 被封装于ip报文中，ip头加icmp,所有报文前四个字节都相同\n(8位类型，8位代码，16位校验和）\n+ 类型+代码决定ICMP的报文类型，种类很多，见协议卷表\n+ 下列几种不会导致icmp差错报文：\n + icmp差错报文；\n + 目的地址为广播地址\n + 作为链路层的广播地址\n + 不是ip分片第一片\n + 源地址不能为零地址，环回地址，广播地址或多播地址\n + 上述是为了防止过去允许icmp差错报文对广播分组带来的广播风暴\n+ ##### ICMP协议总结几种类型：\n + 主机不可达\n + 重定向错误\n + 路由发现报文\n + icmp地址掩码请求和应答\n + icmp时间戳请求和应答\n + icmp端口不可达\n + ping 回显请求：\n + 等等见表\n + 且类型不同发送的报文格式不同\n+ 主机不可达：当路由器收到一份ip数据报但是在路由表中搜索后找不到，不能转发时，会发送一份icmp主机不可达的差错报文\n+ 还有可能是已经经过了几个路由器后出现主机或网络不可达的情况，所以若是测试局域网，则先让路由器断开网络，ping路由器则确保问题不是在本地，而是在网络上；\n+ icmp重定向错误：  \n举个例子，主机在路由表中搜索后将数据包发给默认路由，R1路由器，接着R1路由器搜索后发送给R2路由器，并同时发现它正在发送的接口(R2)和数据报到达的接口相同，即主机和两个路由器所在lan，即在同一个lan中）此时主机可以直接发送给R2,所以R1就发送一份ICMP重定向报文给主机，这样主机下次就可以直接发给R2了\n+ 如何更新路由表?通过ICMP的路由器发现报文：\n以及利用路由器的定期广播多播它们的路由器通告报文rfc1256,而它一般是由用户守护进程来创建和处理\n+ icmp地址掩码请求和应答，发送对某个ip地址请求地址掩码，并接收到子网掩码。路由器回复或者主机回复\n+  icmp时间戳请求和应答，通过向某个IP主机发送这个，从而得到时间信息，telnet也可以进行，如NTP协议（网络时间协议）\n+ icmp端口不可达：udp报文发送给主机后，若端口不匹配，对方主机会发送端口不可达的差错报文\n+ ping回显，后面有文章记录ping程序编写\n#### 动态选路 \n##### 使用场景\n上述讲的是静态路由表的情况：适合于1网络较小，2且与其他网络只有单个连接点，3且没有多余的路由时（如主路由失败，可以选择备用路由）；\n+ 总结：一种更新路由表的动态协议，从而达到最短路径  \n+ 上述三个条件不满足时，通常使用动态选路协议\n+ 当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时出现动态选路，路由器之间必须采用选路协议进行通信；路由器上有一个称为路由守护程序的进程，它运行选路协议，并与相邻的路由器通信，根据收到的信息，更新路由表\n\n##### 分类：\nRIP ,OSPF(开放最短路径优先）,BGP\n\n##### 宏观上看\n在internet上，存在大量的主机，路由器等；并以一组自治系统(AS)的方式组织的，每个自治系统通常由单个实体管理，比如大学校园，公司，常常被定义为一个自治系统，NSFNET的internet骨干网形成一个自治系统；\n+ 自治系统中使用的选路协议，称为内部网关协议IGP或者称为域内选路协议，这些协议有RIP,OSPF\n+ 用于不同自治系统之间的路由器，称为外部网关协议EGP,常见有BGP\n+ unix选路守护程序：routed,gated等\n\n##### RIP：rfc1058\n+ rip采用udp报文，端口号位520，为一种采用距离向量的协议,易受攻击\n+ 流程：\n  + 初始化：启动一个路由守护进程时，先判断启动了哪些接口，接着在每个接口上发送请求报文，要求其他路由器发送完整的路由表，广播或点对点\n  + 接收请求：接收到上述请求后，会回复完整的路由表，否则处理请求报文每一个表项，若有链接到指明地址路由，则度量设置为我们的值，否则设置为16表示无穷大。返回响应\n  + 接收到响应后，更新路由表，如增加或修改或删除,采用Dijkstra算法得到最短路径树\n  + 定期选路更新，30s一次，进行广播发送完整路由表给相邻的路由器\n  + 触发更新：即每当度量发生变化，则对它进行更新，只需要发送度量变化的表项\n  + 定时器：3min内无更新路由，则度量设置为无穷大，标注为删除，再过60s删除并传波\n+ 注:度量就是跳数，相邻路由度量为１\n+ rip问题：无子网概念；路由器或链路故障要很久才能稳定下来，即收敛慢；易发生环回路由；跳数限制了网络大小15\n \n##### OSPF开放最短路径优先：rfc1247\n+ 是一个链路状态协议；\n+ 使用ip协议而不是udp.tcp,\n+ 不与邻站交换距离信息而是主动测试与其他邻站相连链路状态，并将这些信息发送给它的其他邻站，邻站接着广播出去，每个路由器接收到后更新路由表\n+ 收敛快\n+ 可以对每个ip服务类型计算各自的路由集，意味着对任何目的，可以有多个路由表表项，每个表项对应一个ip服务类型；\n+ 给每个接口指派一个费用，通过吞吐率，往返时间，可靠性等，可以给每个ip服务类型指派一个费用\n+ **同一个目的地址存在多个相同费用的路由时，在这些路由上平均分配流量，即流量平衡**\n+ **支持子网**\n+ 路由器之间的点对点链路不需要每端都有一个ip地址，－无编号网络，节省ip\n+ 多播而非广播\n\n##### BGP边界网关协议rfc1268\n+ 自治系统分类：\n + 残桩自治系统，他和其他自治系统只有单个连接，只有本地流量\n + 多接口自治系统，和其他多个自治系统有多个链接，但是拒绝传送流量\n + 转送自治系统，多链接且在一些策略准则下，它可以传送本地流量和通过流量\n+ 是距离向量协议，用于自治系统之间，定期发送keepalive报文，30s\n##### CIDR无类型域间选路：rfc1518,1519\n待探索","slug":"tcpip-routeicmp","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7rn003w2ujx6pg6yd5i","content":"<h3 id=\"IP选路和ICMP协议\"><a href=\"#IP选路和ICMP协议\" class=\"headerlink\" title=\"IP选路和ICMP协议\"></a>IP选路和ICMP协议</h3><h4 id=\"IP如何选路概述：\"><a href=\"#IP如何选路概述：\" class=\"headerlink\" title=\"IP如何选路概述：\"></a>IP如何选路概述：</h4><ul>\n<li>ip选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组，区别于选路策略，后者是一组决定把哪些路由放入路由表的规则；ip执行选路机制，而路由守护程序则一般提供选路策略如rip,ospf</li>\n<li>点对点时，直接送到  </li>\n<li>非点对点时，经过路由器送到  </li>\n<li>Ip层可以是配置为路由或者主机前者非则转发，后者非则丢弃</li>\n<li>路由表项：每一项为<a id=\"more\"></a><ul>\n<li>目的ip地址（网络地址指定网络中所有主机或主机地址);</li>\n<li>下一站路由器的ip地址，可能充当中继转发的，下一站非终点；</li>\n<li>标志：指明目的地址是网络还是主机，下一站是路由器还是直连的接口</li>\n<li>数据传输的网络接口如wlan0,eth0</li>\n</ul>\n</li>\n<li>ip选路是逐跳进行的，</li>\n<li>例子：<br>没连接热点前：<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\"><span class=\"number\">10.42</span><span class=\"number\">.0</span><span class=\"number\">.0</span>       *               <span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.0</span>   U     <span class=\"number\">600</span>    <span class=\"number\">0</span>        <span class=\"number\">0</span> wlp2s0</span><br><span class=\"line\">link-local      *               <span class=\"number\">255.255</span><span class=\"number\">.0</span><span class=\"number\">.0</span>     U     <span class=\"number\">1000</span>   <span class=\"number\">0</span>        <span class=\"number\">0</span> wlp2s0</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>连接热点后：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\"><span class=\"section\">default</span>         <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>     <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>         UG    <span class=\"number\">600</span>    <span class=\"number\">0</span>        <span class=\"number\">0</span> wlp2s0</span><br><span class=\"line\">link-local      *               <span class=\"number\">255.255</span><span class=\"number\">.0</span><span class=\"number\">.0</span>     U     <span class=\"number\">1000</span>   <span class=\"number\">0</span>        <span class=\"number\">0</span> wlp2s0</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.0</span>     *               <span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.0</span>   U     <span class=\"number\">600</span>    <span class=\"number\">0</span>        <span class=\"number\">0</span> wlp2s0</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Destination \t目标网段或者主机</span><br><span class=\"line\">Gateway \t网关地址，”*” 表示目标是本主机所属的网络，不需要路由</span><br><span class=\"line\">Genmask \t网络掩码</span><br><span class=\"line\">Flags \t标记。一些可能的标记如下：</span><br><span class=\"line\">  \tU — 路由是活动的</span><br><span class=\"line\">  \tH — 目标是一个主机</span><br><span class=\"line\">  \tG — 路由指向网关</span><br><span class=\"line\">  \tR — 恢复动态路由产生的表项</span><br><span class=\"line\">  \tD — 由路由的后台程序动态地安装,(由重定向报文创建）</span><br><span class=\"line\">  \tM — 由路由的后台程序修改(已被重定向报文修改）</span><br><span class=\"line\">  \t! — 拒绝路由</span><br><span class=\"line\">Metric \t路由距离，到达指定网络所需的中转数（linux 内核中没有使用）</span><br><span class=\"line\">Ref \t路由项引用次数（linux 内核中没有使用）</span><br><span class=\"line\"><span class=\"keyword\">Use</span> \t此路由项被路由软件查找的次数</span><br><span class=\"line\">Iface \t该路由表项对应的输出接口</span><br></pre></td></tr></table></figure>\n<h5 id=\"如何搜索路由表\"><a href=\"#如何搜索路由表\" class=\"headerlink\" title=\"如何搜索路由表\"></a>如何搜索路由表</h5><ul>\n<li>搜索路由表，目的ip地址匹配条母时，送到该条目的下一站，否则下一步：</li>\n<li>搜索路由表，寻找与目的网络相匹配的条目，找到则送到下一站，如本地局域网；否则下一步：</li>\n<li>搜索路由表，寻找标为默认的条目，有则使用它</li>\n<li>若走完最后一步都没有，则数据包无法被传送，会向生成数据包的程序返回主机不可达或者网络不可达的错误</li>\n<li>详细例子见卷１，这里较清楚了</li>\n</ul>\n<h5 id=\"子网寻址rfc950\"><a href=\"#子网寻址rfc950\" class=\"headerlink\" title=\"子网寻址rfc950\"></a>子网寻址rfc950</h5><ul>\n<li>主机号再分为子网号和主机号，子网掩码也跟着变化；这样可以缩小路由表规模，想象一个包含30个子网的B类地址和30个C类地址相比</li>\n<li>此时，外网–&gt;网关–&gt;局域网１–&gt;局域网１中的子网（局域网）10–&gt;子网11。。。</li>\n<li>所以此时网关并非就是其直接路由器，若主机在子网11,10中，路由器需要知道发往哪个子网，通过子网掩码</li>\n<li>给定ip地址和子网掩码后能知道什么：<br>知道该主机所在的子网；路由器可以知道是本子网的主机还是本网络中其他子网的主机还是其他网络的主机。。。路由进行的比较不需要比较到主机，如先比较类别网络地址如A,B,C:<br>如我们主机为140.252.1.1,子掩码为255.255.255.0,则与目的ip地址比较：140.252.4.5,可以知道B类网络地址相同但是子网不同(1,4),就不用再比较主机了，</li>\n</ul>\n<h5 id=\"特殊的网络地址\"><a href=\"#特殊的网络地址\" class=\"headerlink\" title=\"特殊的网络地址\"></a>特殊的网络地址</h5><h5 id=\"ifconfig命令\"><a href=\"#ifconfig命令\" class=\"headerlink\" title=\"ifconfig命令\"></a>ifconfig命令</h5><ul>\n<li>ifconfig -a<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">wlp2s0</span>    <span class=\"selector-tag\">Link</span> <span class=\"selector-tag\">encap</span><span class=\"selector-pseudo\">:Ethernet</span>  <span class=\"selector-tag\">HWaddr</span> <span class=\"selector-tag\">48</span><span class=\"selector-pseudo\">:5a</span><span class=\"selector-pseudo\">:b6</span><span class=\"selector-pseudo\">:6e</span><span class=\"selector-pseudo\">:c9</span><span class=\"selector-pseudo\">:5f</span>  </span><br><span class=\"line\">          <span class=\"selector-tag\">inet</span> <span class=\"selector-tag\">addr</span><span class=\"selector-pseudo\">:192.168.0.110</span>  <span class=\"selector-tag\">Bcast</span><span class=\"selector-pseudo\">:192.168.0.255</span>  <span class=\"selector-tag\">Mask</span><span class=\"selector-pseudo\">:255.255.255.0</span></span><br><span class=\"line\">          <span class=\"selector-tag\">inet6</span> <span class=\"selector-tag\">addr</span>: <span class=\"selector-tag\">fe80</span><span class=\"selector-pseudo\">::d713</span><span class=\"selector-pseudo\">:7c0f</span><span class=\"selector-pseudo\">:b40c</span><span class=\"selector-pseudo\">:c085</span>/<span class=\"selector-tag\">64</span> <span class=\"selector-tag\">Scope</span><span class=\"selector-pseudo\">:Link</span></span><br><span class=\"line\">          <span class=\"selector-tag\">UP</span> <span class=\"selector-tag\">BROADCAST</span> <span class=\"selector-tag\">RUNNING</span> <span class=\"selector-tag\">MULTICAST</span>  <span class=\"selector-tag\">MTU</span><span class=\"selector-pseudo\">:1500</span>  <span class=\"selector-tag\">Metric</span><span class=\"selector-pseudo\">:1</span></span><br><span class=\"line\">          <span class=\"selector-tag\">RX</span> <span class=\"selector-tag\">packets</span><span class=\"selector-pseudo\">:7032</span> <span class=\"selector-tag\">errors</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">dropped</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">overruns</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">frame</span><span class=\"selector-pseudo\">:0</span></span><br><span class=\"line\">          <span class=\"selector-tag\">TX</span> <span class=\"selector-tag\">packets</span><span class=\"selector-pseudo\">:4297</span> <span class=\"selector-tag\">errors</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">dropped</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">overruns</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">carrier</span><span class=\"selector-pseudo\">:0</span></span><br><span class=\"line\">          <span class=\"selector-tag\">collisions</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">txqueuelen</span><span class=\"selector-pseudo\">:1000</span> </span><br><span class=\"line\">          <span class=\"selector-tag\">RX</span> <span class=\"selector-tag\">bytes</span><span class=\"selector-pseudo\">:3668623</span> (<span class=\"number\">3.6</span> MB)  <span class=\"selector-tag\">TX</span> <span class=\"selector-tag\">bytes</span><span class=\"selector-pseudo\">:703812</span> (<span class=\"number\">703.8</span> KB)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"netstat命令\"><a href=\"#netstat命令\" class=\"headerlink\" title=\"netstat命令\"></a>netstat命令</h5><ul>\n<li>其实这个命令的功能很强，可以相互开服务端客户端通信和反向shell</li>\n<li>netstat -in<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kernel Interface table</span><br><span class=\"line\">Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class=\"line\">enp1s0     <span class=\"number\">1500</span> <span class=\"number\">0</span>         <span class=\"number\">0</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> <span class=\"number\">0</span>             <span class=\"number\">0</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> BMU</span><br><span class=\"line\">lo        <span class=\"number\">65536</span> <span class=\"number\">0</span>      <span class=\"number\">1404</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> <span class=\"number\">0</span>          <span class=\"number\">1404</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> LRU</span><br><span class=\"line\">wlp2s0     <span class=\"number\">1500</span> <span class=\"number\">0</span>      <span class=\"number\">7257</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> <span class=\"number\">0</span>          <span class=\"number\">4311</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> BMRU</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -rn</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class=\"line\"><span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>         <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>     <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>         UG        <span class=\"number\">0</span> <span class=\"number\">0</span>          <span class=\"number\">0</span> wlp2s0</span><br><span class=\"line\"><span class=\"number\">169.254</span><span class=\"number\">.0</span><span class=\"number\">.0</span>     <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>         <span class=\"number\">255.255</span><span class=\"number\">.0</span><span class=\"number\">.0</span>     U         <span class=\"number\">0</span> <span class=\"number\">0</span>          <span class=\"number\">0</span> wlp2s0</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.0</span>     <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>         <span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.0</span>   U         <span class=\"number\">0</span> <span class=\"number\">0</span>          <span class=\"number\">0</span> wlp2s0</span><br></pre></td></tr></table></figure>\n<h5 id=\"初始化路由表\"><a href=\"#初始化路由表\" class=\"headerlink\" title=\"初始化路由表\"></a>初始化路由表</h5><ul>\n<li>ifconfig设置接口地址，并用route　命令添加或删除路由表项<h5 id=\"主机可以选择转发或者不转发报文\"><a href=\"#主机可以选择转发或者不转发报文\" class=\"headerlink\" title=\"主机可以选择转发或者不转发报文\"></a>主机可以选择转发或者不转发报文</h5></li>\n<li>在配置文件中配置ipfordwarding:</li>\n<li>echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot<h4 id=\"ICMP协议rfc792\"><a href=\"#ICMP协议rfc792\" class=\"headerlink\" title=\"ICMP协议rfc792\"></a>ICMP协议rfc792</h4><h5 id=\"Icmp报文：\"><a href=\"#Icmp报文：\" class=\"headerlink\" title=\"Icmp报文：\"></a>Icmp报文：</h5></li>\n<li>ICMP：IP头(20字节）+ICMP报文</li>\n<li>IP头：<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\"> 0                   1                   2                   3</span></span><br><span class=\"line\"><span class=\"code\"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br><span class=\"line\">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br><span class=\"line\">|         Identification        |Flags|      Fragment Offset    |</span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br><span class=\"line\">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br><span class=\"line\">|                       Source Address                          |</span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br><span class=\"line\">|                    Destination Address                        |</span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br><span class=\"line\">|                    Options                    |    Padding    |</span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其中options和padding不一定有</p>\n<ul>\n<li><p>ICMP报文：type+code共同决定ICMP类型，如回显or差错，，，</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>                   <span class=\"number\">1</span>                   <span class=\"number\">2</span>                   <span class=\"number\">3</span></span><br><span class=\"line\"> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|     Type      |     Code      |          Checksum             |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|       different type and code has different content           |</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>被封装于ip报文中，ip头加icmp,所有报文前四个字节都相同<br>(8位类型，8位代码，16位校验和）</p>\n</li>\n<li>类型+代码决定ICMP的报文类型，种类很多，见协议卷表</li>\n<li>下列几种不会导致icmp差错报文：<ul>\n<li>icmp差错报文；</li>\n<li>目的地址为广播地址</li>\n<li>作为链路层的广播地址</li>\n<li>不是ip分片第一片</li>\n<li>源地址不能为零地址，环回地址，广播地址或多播地址</li>\n<li>上述是为了防止过去允许icmp差错报文对广播分组带来的广播风暴</li>\n</ul>\n</li>\n<li><h5 id=\"ICMP协议总结几种类型：\"><a href=\"#ICMP协议总结几种类型：\" class=\"headerlink\" title=\"ICMP协议总结几种类型：\"></a>ICMP协议总结几种类型：</h5><ul>\n<li>主机不可达</li>\n<li>重定向错误</li>\n<li>路由发现报文</li>\n<li>icmp地址掩码请求和应答</li>\n<li>icmp时间戳请求和应答</li>\n<li>icmp端口不可达</li>\n<li>ping 回显请求：</li>\n<li>等等见表</li>\n<li>且类型不同发送的报文格式不同</li>\n</ul>\n</li>\n<li>主机不可达：当路由器收到一份ip数据报但是在路由表中搜索后找不到，不能转发时，会发送一份icmp主机不可达的差错报文</li>\n<li>还有可能是已经经过了几个路由器后出现主机或网络不可达的情况，所以若是测试局域网，则先让路由器断开网络，ping路由器则确保问题不是在本地，而是在网络上；</li>\n<li>icmp重定向错误：<br>举个例子，主机在路由表中搜索后将数据包发给默认路由，R1路由器，接着R1路由器搜索后发送给R2路由器，并同时发现它正在发送的接口(R2)和数据报到达的接口相同，即主机和两个路由器所在lan，即在同一个lan中）此时主机可以直接发送给R2,所以R1就发送一份ICMP重定向报文给主机，这样主机下次就可以直接发给R2了</li>\n<li>如何更新路由表?通过ICMP的路由器发现报文：<br>以及利用路由器的定期广播多播它们的路由器通告报文rfc1256,而它一般是由用户守护进程来创建和处理</li>\n<li>icmp地址掩码请求和应答，发送对某个ip地址请求地址掩码，并接收到子网掩码。路由器回复或者主机回复</li>\n<li>icmp时间戳请求和应答，通过向某个IP主机发送这个，从而得到时间信息，telnet也可以进行，如NTP协议（网络时间协议）</li>\n<li>icmp端口不可达：udp报文发送给主机后，若端口不匹配，对方主机会发送端口不可达的差错报文</li>\n<li>ping回显，后面有文章记录ping程序编写<h4 id=\"动态选路\"><a href=\"#动态选路\" class=\"headerlink\" title=\"动态选路\"></a>动态选路</h4><h5 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h5>上述讲的是静态路由表的情况：适合于1网络较小，2且与其他网络只有单个连接点，3且没有多余的路由时（如主路由失败，可以选择备用路由）；</li>\n<li>总结：一种更新路由表的动态协议，从而达到最短路径  </li>\n<li>上述三个条件不满足时，通常使用动态选路协议</li>\n<li>当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时出现动态选路，路由器之间必须采用选路协议进行通信；路由器上有一个称为路由守护程序的进程，它运行选路协议，并与相邻的路由器通信，根据收到的信息，更新路由表</li>\n</ul>\n<h5 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h5><p>RIP ,OSPF(开放最短路径优先）,BGP</p>\n<h5 id=\"宏观上看\"><a href=\"#宏观上看\" class=\"headerlink\" title=\"宏观上看\"></a>宏观上看</h5><p>在internet上，存在大量的主机，路由器等；并以一组自治系统(AS)的方式组织的，每个自治系统通常由单个实体管理，比如大学校园，公司，常常被定义为一个自治系统，NSFNET的internet骨干网形成一个自治系统；</p>\n<ul>\n<li>自治系统中使用的选路协议，称为内部网关协议IGP或者称为域内选路协议，这些协议有RIP,OSPF</li>\n<li>用于不同自治系统之间的路由器，称为外部网关协议EGP,常见有BGP</li>\n<li>unix选路守护程序：routed,gated等</li>\n</ul>\n<h5 id=\"RIP：rfc1058\"><a href=\"#RIP：rfc1058\" class=\"headerlink\" title=\"RIP：rfc1058\"></a>RIP：rfc1058</h5><ul>\n<li>rip采用udp报文，端口号位520，为一种采用距离向量的协议,易受攻击</li>\n<li>流程：<ul>\n<li>初始化：启动一个路由守护进程时，先判断启动了哪些接口，接着在每个接口上发送请求报文，要求其他路由器发送完整的路由表，广播或点对点</li>\n<li>接收请求：接收到上述请求后，会回复完整的路由表，否则处理请求报文每一个表项，若有链接到指明地址路由，则度量设置为我们的值，否则设置为16表示无穷大。返回响应</li>\n<li>接收到响应后，更新路由表，如增加或修改或删除,采用Dijkstra算法得到最短路径树</li>\n<li>定期选路更新，30s一次，进行广播发送完整路由表给相邻的路由器</li>\n<li>触发更新：即每当度量发生变化，则对它进行更新，只需要发送度量变化的表项</li>\n<li>定时器：3min内无更新路由，则度量设置为无穷大，标注为删除，再过60s删除并传波</li>\n</ul>\n</li>\n<li>注:度量就是跳数，相邻路由度量为１</li>\n<li>rip问题：无子网概念；路由器或链路故障要很久才能稳定下来，即收敛慢；易发生环回路由；跳数限制了网络大小15</li>\n</ul>\n<h5 id=\"OSPF开放最短路径优先：rfc1247\"><a href=\"#OSPF开放最短路径优先：rfc1247\" class=\"headerlink\" title=\"OSPF开放最短路径优先：rfc1247\"></a>OSPF开放最短路径优先：rfc1247</h5><ul>\n<li>是一个链路状态协议；</li>\n<li>使用ip协议而不是udp.tcp,</li>\n<li>不与邻站交换距离信息而是主动测试与其他邻站相连链路状态，并将这些信息发送给它的其他邻站，邻站接着广播出去，每个路由器接收到后更新路由表</li>\n<li>收敛快</li>\n<li>可以对每个ip服务类型计算各自的路由集，意味着对任何目的，可以有多个路由表表项，每个表项对应一个ip服务类型；</li>\n<li>给每个接口指派一个费用，通过吞吐率，往返时间，可靠性等，可以给每个ip服务类型指派一个费用</li>\n<li><strong>同一个目的地址存在多个相同费用的路由时，在这些路由上平均分配流量，即流量平衡</strong></li>\n<li><strong>支持子网</strong></li>\n<li>路由器之间的点对点链路不需要每端都有一个ip地址，－无编号网络，节省ip</li>\n<li>多播而非广播</li>\n</ul>\n<h5 id=\"BGP边界网关协议rfc1268\"><a href=\"#BGP边界网关协议rfc1268\" class=\"headerlink\" title=\"BGP边界网关协议rfc1268\"></a>BGP边界网关协议rfc1268</h5><ul>\n<li>自治系统分类：<ul>\n<li>残桩自治系统，他和其他自治系统只有单个连接，只有本地流量</li>\n<li>多接口自治系统，和其他多个自治系统有多个链接，但是拒绝传送流量</li>\n<li>转送自治系统，多链接且在一些策略准则下，它可以传送本地流量和通过流量</li>\n</ul>\n</li>\n<li>是距离向量协议，用于自治系统之间，定期发送keepalive报文，30s<h5 id=\"CIDR无类型域间选路：rfc1518-1519\"><a href=\"#CIDR无类型域间选路：rfc1518-1519\" class=\"headerlink\" title=\"CIDR无类型域间选路：rfc1518,1519\"></a>CIDR无类型域间选路：rfc1518,1519</h5>待探索</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"IP选路和ICMP协议\"><a href=\"#IP选路和ICMP协议\" class=\"headerlink\" title=\"IP选路和ICMP协议\"></a>IP选路和ICMP协议</h3><h4 id=\"IP如何选路概述：\"><a href=\"#IP如何选路概述：\" class=\"headerlink\" title=\"IP如何选路概述：\"></a>IP如何选路概述：</h4><ul>\n<li>ip选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组，区别于选路策略，后者是一组决定把哪些路由放入路由表的规则；ip执行选路机制，而路由守护程序则一般提供选路策略如rip,ospf</li>\n<li>点对点时，直接送到  </li>\n<li>非点对点时，经过路由器送到  </li>\n<li>Ip层可以是配置为路由或者主机前者非则转发，后者非则丢弃</li>\n<li>路由表项：每一项为","more":"<ul>\n<li>目的ip地址（网络地址指定网络中所有主机或主机地址);</li>\n<li>下一站路由器的ip地址，可能充当中继转发的，下一站非终点；</li>\n<li>标志：指明目的地址是网络还是主机，下一站是路由器还是直连的接口</li>\n<li>数据传输的网络接口如wlan0,eth0</li>\n</ul>\n</li>\n<li>ip选路是逐跳进行的，</li>\n<li>例子：<br>没连接热点前：<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\"><span class=\"number\">10.42</span><span class=\"number\">.0</span><span class=\"number\">.0</span>       *               <span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.0</span>   U     <span class=\"number\">600</span>    <span class=\"number\">0</span>        <span class=\"number\">0</span> wlp2s0</span><br><span class=\"line\">link-local      *               <span class=\"number\">255.255</span><span class=\"number\">.0</span><span class=\"number\">.0</span>     U     <span class=\"number\">1000</span>   <span class=\"number\">0</span>        <span class=\"number\">0</span> wlp2s0</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>连接热点后：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\"><span class=\"section\">default</span>         <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>     <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>         UG    <span class=\"number\">600</span>    <span class=\"number\">0</span>        <span class=\"number\">0</span> wlp2s0</span><br><span class=\"line\">link-local      *               <span class=\"number\">255.255</span><span class=\"number\">.0</span><span class=\"number\">.0</span>     U     <span class=\"number\">1000</span>   <span class=\"number\">0</span>        <span class=\"number\">0</span> wlp2s0</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.0</span>     *               <span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.0</span>   U     <span class=\"number\">600</span>    <span class=\"number\">0</span>        <span class=\"number\">0</span> wlp2s0</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Destination \t目标网段或者主机</span><br><span class=\"line\">Gateway \t网关地址，”*” 表示目标是本主机所属的网络，不需要路由</span><br><span class=\"line\">Genmask \t网络掩码</span><br><span class=\"line\">Flags \t标记。一些可能的标记如下：</span><br><span class=\"line\">  \tU — 路由是活动的</span><br><span class=\"line\">  \tH — 目标是一个主机</span><br><span class=\"line\">  \tG — 路由指向网关</span><br><span class=\"line\">  \tR — 恢复动态路由产生的表项</span><br><span class=\"line\">  \tD — 由路由的后台程序动态地安装,(由重定向报文创建）</span><br><span class=\"line\">  \tM — 由路由的后台程序修改(已被重定向报文修改）</span><br><span class=\"line\">  \t! — 拒绝路由</span><br><span class=\"line\">Metric \t路由距离，到达指定网络所需的中转数（linux 内核中没有使用）</span><br><span class=\"line\">Ref \t路由项引用次数（linux 内核中没有使用）</span><br><span class=\"line\"><span class=\"keyword\">Use</span> \t此路由项被路由软件查找的次数</span><br><span class=\"line\">Iface \t该路由表项对应的输出接口</span><br></pre></td></tr></table></figure>\n<h5 id=\"如何搜索路由表\"><a href=\"#如何搜索路由表\" class=\"headerlink\" title=\"如何搜索路由表\"></a>如何搜索路由表</h5><ul>\n<li>搜索路由表，目的ip地址匹配条母时，送到该条目的下一站，否则下一步：</li>\n<li>搜索路由表，寻找与目的网络相匹配的条目，找到则送到下一站，如本地局域网；否则下一步：</li>\n<li>搜索路由表，寻找标为默认的条目，有则使用它</li>\n<li>若走完最后一步都没有，则数据包无法被传送，会向生成数据包的程序返回主机不可达或者网络不可达的错误</li>\n<li>详细例子见卷１，这里较清楚了</li>\n</ul>\n<h5 id=\"子网寻址rfc950\"><a href=\"#子网寻址rfc950\" class=\"headerlink\" title=\"子网寻址rfc950\"></a>子网寻址rfc950</h5><ul>\n<li>主机号再分为子网号和主机号，子网掩码也跟着变化；这样可以缩小路由表规模，想象一个包含30个子网的B类地址和30个C类地址相比</li>\n<li>此时，外网–&gt;网关–&gt;局域网１–&gt;局域网１中的子网（局域网）10–&gt;子网11。。。</li>\n<li>所以此时网关并非就是其直接路由器，若主机在子网11,10中，路由器需要知道发往哪个子网，通过子网掩码</li>\n<li>给定ip地址和子网掩码后能知道什么：<br>知道该主机所在的子网；路由器可以知道是本子网的主机还是本网络中其他子网的主机还是其他网络的主机。。。路由进行的比较不需要比较到主机，如先比较类别网络地址如A,B,C:<br>如我们主机为140.252.1.1,子掩码为255.255.255.0,则与目的ip地址比较：140.252.4.5,可以知道B类网络地址相同但是子网不同(1,4),就不用再比较主机了，</li>\n</ul>\n<h5 id=\"特殊的网络地址\"><a href=\"#特殊的网络地址\" class=\"headerlink\" title=\"特殊的网络地址\"></a>特殊的网络地址</h5><h5 id=\"ifconfig命令\"><a href=\"#ifconfig命令\" class=\"headerlink\" title=\"ifconfig命令\"></a>ifconfig命令</h5><ul>\n<li>ifconfig -a<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">wlp2s0</span>    <span class=\"selector-tag\">Link</span> <span class=\"selector-tag\">encap</span><span class=\"selector-pseudo\">:Ethernet</span>  <span class=\"selector-tag\">HWaddr</span> <span class=\"selector-tag\">48</span><span class=\"selector-pseudo\">:5a</span><span class=\"selector-pseudo\">:b6</span><span class=\"selector-pseudo\">:6e</span><span class=\"selector-pseudo\">:c9</span><span class=\"selector-pseudo\">:5f</span>  </span><br><span class=\"line\">          <span class=\"selector-tag\">inet</span> <span class=\"selector-tag\">addr</span><span class=\"selector-pseudo\">:192.168.0.110</span>  <span class=\"selector-tag\">Bcast</span><span class=\"selector-pseudo\">:192.168.0.255</span>  <span class=\"selector-tag\">Mask</span><span class=\"selector-pseudo\">:255.255.255.0</span></span><br><span class=\"line\">          <span class=\"selector-tag\">inet6</span> <span class=\"selector-tag\">addr</span>: <span class=\"selector-tag\">fe80</span><span class=\"selector-pseudo\">::d713</span><span class=\"selector-pseudo\">:7c0f</span><span class=\"selector-pseudo\">:b40c</span><span class=\"selector-pseudo\">:c085</span>/<span class=\"selector-tag\">64</span> <span class=\"selector-tag\">Scope</span><span class=\"selector-pseudo\">:Link</span></span><br><span class=\"line\">          <span class=\"selector-tag\">UP</span> <span class=\"selector-tag\">BROADCAST</span> <span class=\"selector-tag\">RUNNING</span> <span class=\"selector-tag\">MULTICAST</span>  <span class=\"selector-tag\">MTU</span><span class=\"selector-pseudo\">:1500</span>  <span class=\"selector-tag\">Metric</span><span class=\"selector-pseudo\">:1</span></span><br><span class=\"line\">          <span class=\"selector-tag\">RX</span> <span class=\"selector-tag\">packets</span><span class=\"selector-pseudo\">:7032</span> <span class=\"selector-tag\">errors</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">dropped</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">overruns</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">frame</span><span class=\"selector-pseudo\">:0</span></span><br><span class=\"line\">          <span class=\"selector-tag\">TX</span> <span class=\"selector-tag\">packets</span><span class=\"selector-pseudo\">:4297</span> <span class=\"selector-tag\">errors</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">dropped</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">overruns</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">carrier</span><span class=\"selector-pseudo\">:0</span></span><br><span class=\"line\">          <span class=\"selector-tag\">collisions</span><span class=\"selector-pseudo\">:0</span> <span class=\"selector-tag\">txqueuelen</span><span class=\"selector-pseudo\">:1000</span> </span><br><span class=\"line\">          <span class=\"selector-tag\">RX</span> <span class=\"selector-tag\">bytes</span><span class=\"selector-pseudo\">:3668623</span> (<span class=\"number\">3.6</span> MB)  <span class=\"selector-tag\">TX</span> <span class=\"selector-tag\">bytes</span><span class=\"selector-pseudo\">:703812</span> (<span class=\"number\">703.8</span> KB)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"netstat命令\"><a href=\"#netstat命令\" class=\"headerlink\" title=\"netstat命令\"></a>netstat命令</h5><ul>\n<li>其实这个命令的功能很强，可以相互开服务端客户端通信和反向shell</li>\n<li>netstat -in<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kernel Interface table</span><br><span class=\"line\">Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class=\"line\">enp1s0     <span class=\"number\">1500</span> <span class=\"number\">0</span>         <span class=\"number\">0</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> <span class=\"number\">0</span>             <span class=\"number\">0</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> BMU</span><br><span class=\"line\">lo        <span class=\"number\">65536</span> <span class=\"number\">0</span>      <span class=\"number\">1404</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> <span class=\"number\">0</span>          <span class=\"number\">1404</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> LRU</span><br><span class=\"line\">wlp2s0     <span class=\"number\">1500</span> <span class=\"number\">0</span>      <span class=\"number\">7257</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> <span class=\"number\">0</span>          <span class=\"number\">4311</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span>      <span class=\"number\">0</span> BMRU</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -rn</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class=\"line\"><span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>         <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span>     <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>         UG        <span class=\"number\">0</span> <span class=\"number\">0</span>          <span class=\"number\">0</span> wlp2s0</span><br><span class=\"line\"><span class=\"number\">169.254</span><span class=\"number\">.0</span><span class=\"number\">.0</span>     <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>         <span class=\"number\">255.255</span><span class=\"number\">.0</span><span class=\"number\">.0</span>     U         <span class=\"number\">0</span> <span class=\"number\">0</span>          <span class=\"number\">0</span> wlp2s0</span><br><span class=\"line\"><span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.0</span>     <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>         <span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.0</span>   U         <span class=\"number\">0</span> <span class=\"number\">0</span>          <span class=\"number\">0</span> wlp2s0</span><br></pre></td></tr></table></figure>\n<h5 id=\"初始化路由表\"><a href=\"#初始化路由表\" class=\"headerlink\" title=\"初始化路由表\"></a>初始化路由表</h5><ul>\n<li>ifconfig设置接口地址，并用route　命令添加或删除路由表项<h5 id=\"主机可以选择转发或者不转发报文\"><a href=\"#主机可以选择转发或者不转发报文\" class=\"headerlink\" title=\"主机可以选择转发或者不转发报文\"></a>主机可以选择转发或者不转发报文</h5></li>\n<li>在配置文件中配置ipfordwarding:</li>\n<li>echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot<h4 id=\"ICMP协议rfc792\"><a href=\"#ICMP协议rfc792\" class=\"headerlink\" title=\"ICMP协议rfc792\"></a>ICMP协议rfc792</h4><h5 id=\"Icmp报文：\"><a href=\"#Icmp报文：\" class=\"headerlink\" title=\"Icmp报文：\"></a>Icmp报文：</h5></li>\n<li>ICMP：IP头(20字节）+ICMP报文</li>\n<li>IP头：<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\"> 0                   1                   2                   3</span></span><br><span class=\"line\"><span class=\"code\"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br><span class=\"line\">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br><span class=\"line\">|         Identification        |Flags|      Fragment Offset    |</span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br><span class=\"line\">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br><span class=\"line\">|                       Source Address                          |</span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br><span class=\"line\">|                    Destination Address                        |</span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br><span class=\"line\">|                    Options                    |    Padding    |</span><br><span class=\"line\"><span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-<span class=\"code\">+-+</span>-+</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其中options和padding不一定有</p>\n<ul>\n<li><p>ICMP报文：type+code共同决定ICMP类型，如回显or差错，，，</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>                   <span class=\"number\">1</span>                   <span class=\"number\">2</span>                   <span class=\"number\">3</span></span><br><span class=\"line\"> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span> <span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|     Type      |     Code      |          Checksum             |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|       different type and code has different content           |</span><br><span class=\"line\">|                                                               |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>被封装于ip报文中，ip头加icmp,所有报文前四个字节都相同<br>(8位类型，8位代码，16位校验和）</p>\n</li>\n<li>类型+代码决定ICMP的报文类型，种类很多，见协议卷表</li>\n<li>下列几种不会导致icmp差错报文：<ul>\n<li>icmp差错报文；</li>\n<li>目的地址为广播地址</li>\n<li>作为链路层的广播地址</li>\n<li>不是ip分片第一片</li>\n<li>源地址不能为零地址，环回地址，广播地址或多播地址</li>\n<li>上述是为了防止过去允许icmp差错报文对广播分组带来的广播风暴</li>\n</ul>\n</li>\n<li><h5 id=\"ICMP协议总结几种类型：\"><a href=\"#ICMP协议总结几种类型：\" class=\"headerlink\" title=\"ICMP协议总结几种类型：\"></a>ICMP协议总结几种类型：</h5><ul>\n<li>主机不可达</li>\n<li>重定向错误</li>\n<li>路由发现报文</li>\n<li>icmp地址掩码请求和应答</li>\n<li>icmp时间戳请求和应答</li>\n<li>icmp端口不可达</li>\n<li>ping 回显请求：</li>\n<li>等等见表</li>\n<li>且类型不同发送的报文格式不同</li>\n</ul>\n</li>\n<li>主机不可达：当路由器收到一份ip数据报但是在路由表中搜索后找不到，不能转发时，会发送一份icmp主机不可达的差错报文</li>\n<li>还有可能是已经经过了几个路由器后出现主机或网络不可达的情况，所以若是测试局域网，则先让路由器断开网络，ping路由器则确保问题不是在本地，而是在网络上；</li>\n<li>icmp重定向错误：<br>举个例子，主机在路由表中搜索后将数据包发给默认路由，R1路由器，接着R1路由器搜索后发送给R2路由器，并同时发现它正在发送的接口(R2)和数据报到达的接口相同，即主机和两个路由器所在lan，即在同一个lan中）此时主机可以直接发送给R2,所以R1就发送一份ICMP重定向报文给主机，这样主机下次就可以直接发给R2了</li>\n<li>如何更新路由表?通过ICMP的路由器发现报文：<br>以及利用路由器的定期广播多播它们的路由器通告报文rfc1256,而它一般是由用户守护进程来创建和处理</li>\n<li>icmp地址掩码请求和应答，发送对某个ip地址请求地址掩码，并接收到子网掩码。路由器回复或者主机回复</li>\n<li>icmp时间戳请求和应答，通过向某个IP主机发送这个，从而得到时间信息，telnet也可以进行，如NTP协议（网络时间协议）</li>\n<li>icmp端口不可达：udp报文发送给主机后，若端口不匹配，对方主机会发送端口不可达的差错报文</li>\n<li>ping回显，后面有文章记录ping程序编写<h4 id=\"动态选路\"><a href=\"#动态选路\" class=\"headerlink\" title=\"动态选路\"></a>动态选路</h4><h5 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h5>上述讲的是静态路由表的情况：适合于1网络较小，2且与其他网络只有单个连接点，3且没有多余的路由时（如主路由失败，可以选择备用路由）；</li>\n<li>总结：一种更新路由表的动态协议，从而达到最短路径  </li>\n<li>上述三个条件不满足时，通常使用动态选路协议</li>\n<li>当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时出现动态选路，路由器之间必须采用选路协议进行通信；路由器上有一个称为路由守护程序的进程，它运行选路协议，并与相邻的路由器通信，根据收到的信息，更新路由表</li>\n</ul>\n<h5 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h5><p>RIP ,OSPF(开放最短路径优先）,BGP</p>\n<h5 id=\"宏观上看\"><a href=\"#宏观上看\" class=\"headerlink\" title=\"宏观上看\"></a>宏观上看</h5><p>在internet上，存在大量的主机，路由器等；并以一组自治系统(AS)的方式组织的，每个自治系统通常由单个实体管理，比如大学校园，公司，常常被定义为一个自治系统，NSFNET的internet骨干网形成一个自治系统；</p>\n<ul>\n<li>自治系统中使用的选路协议，称为内部网关协议IGP或者称为域内选路协议，这些协议有RIP,OSPF</li>\n<li>用于不同自治系统之间的路由器，称为外部网关协议EGP,常见有BGP</li>\n<li>unix选路守护程序：routed,gated等</li>\n</ul>\n<h5 id=\"RIP：rfc1058\"><a href=\"#RIP：rfc1058\" class=\"headerlink\" title=\"RIP：rfc1058\"></a>RIP：rfc1058</h5><ul>\n<li>rip采用udp报文，端口号位520，为一种采用距离向量的协议,易受攻击</li>\n<li>流程：<ul>\n<li>初始化：启动一个路由守护进程时，先判断启动了哪些接口，接着在每个接口上发送请求报文，要求其他路由器发送完整的路由表，广播或点对点</li>\n<li>接收请求：接收到上述请求后，会回复完整的路由表，否则处理请求报文每一个表项，若有链接到指明地址路由，则度量设置为我们的值，否则设置为16表示无穷大。返回响应</li>\n<li>接收到响应后，更新路由表，如增加或修改或删除,采用Dijkstra算法得到最短路径树</li>\n<li>定期选路更新，30s一次，进行广播发送完整路由表给相邻的路由器</li>\n<li>触发更新：即每当度量发生变化，则对它进行更新，只需要发送度量变化的表项</li>\n<li>定时器：3min内无更新路由，则度量设置为无穷大，标注为删除，再过60s删除并传波</li>\n</ul>\n</li>\n<li>注:度量就是跳数，相邻路由度量为１</li>\n<li>rip问题：无子网概念；路由器或链路故障要很久才能稳定下来，即收敛慢；易发生环回路由；跳数限制了网络大小15</li>\n</ul>\n<h5 id=\"OSPF开放最短路径优先：rfc1247\"><a href=\"#OSPF开放最短路径优先：rfc1247\" class=\"headerlink\" title=\"OSPF开放最短路径优先：rfc1247\"></a>OSPF开放最短路径优先：rfc1247</h5><ul>\n<li>是一个链路状态协议；</li>\n<li>使用ip协议而不是udp.tcp,</li>\n<li>不与邻站交换距离信息而是主动测试与其他邻站相连链路状态，并将这些信息发送给它的其他邻站，邻站接着广播出去，每个路由器接收到后更新路由表</li>\n<li>收敛快</li>\n<li>可以对每个ip服务类型计算各自的路由集，意味着对任何目的，可以有多个路由表表项，每个表项对应一个ip服务类型；</li>\n<li>给每个接口指派一个费用，通过吞吐率，往返时间，可靠性等，可以给每个ip服务类型指派一个费用</li>\n<li><strong>同一个目的地址存在多个相同费用的路由时，在这些路由上平均分配流量，即流量平衡</strong></li>\n<li><strong>支持子网</strong></li>\n<li>路由器之间的点对点链路不需要每端都有一个ip地址，－无编号网络，节省ip</li>\n<li>多播而非广播</li>\n</ul>\n<h5 id=\"BGP边界网关协议rfc1268\"><a href=\"#BGP边界网关协议rfc1268\" class=\"headerlink\" title=\"BGP边界网关协议rfc1268\"></a>BGP边界网关协议rfc1268</h5><ul>\n<li>自治系统分类：<ul>\n<li>残桩自治系统，他和其他自治系统只有单个连接，只有本地流量</li>\n<li>多接口自治系统，和其他多个自治系统有多个链接，但是拒绝传送流量</li>\n<li>转送自治系统，多链接且在一些策略准则下，它可以传送本地流量和通过流量</li>\n</ul>\n</li>\n<li>是距离向量协议，用于自治系统之间，定期发送keepalive报文，30s<h5 id=\"CIDR无类型域间选路：rfc1518-1519\"><a href=\"#CIDR无类型域间选路：rfc1518-1519\" class=\"headerlink\" title=\"CIDR无类型域间选路：rfc1518,1519\"></a>CIDR无类型域间选路：rfc1518,1519</h5>待探索</li>\n</ul>"},{"title":"leetcode_linklist2","date":"2018-06-03T13:40:41.000Z","_content":"### leetcode——单链表2\n#### partition list\n这个是快速排序中一个很重要的步骤，即比该数大于等于的放其前小的放后。在链表中，基本思路:扫描链表，比给定数字小的不处理，比给定数字大的取下并插入到末尾 <!--more-->\n```c\n/*\nGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\n\nYou should preserve the original relative order of the nodes in each of the two partitions.\n\nExample:\n\nInput: head = 1->4->3->2->5->2, x = 3\nOutput: 1->2->2->4->3->5*/\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* partition(struct ListNode* head, int x) {\n    /**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n    if(head==NULL)\n\t\t\t\treturn NULL;\n    if(head->next ==NULL)\n              return head;\n        struct ListNode *list=(struct ListNode*)malloc(sizeof(struct  ListNode));\n        list->next=head;\n\t\tstruct ListNode*head1=list;\n\t\tstruct ListNode*cur = head1->next;\n\t\tstruct ListNode*tail=head1;\n\t\tint lenoflist1=0;\n\t\twhile(tail->next!=NULL)\n\t\t{\n\t\t\t\ttail=tail->next;\n\t\t\t\tlenoflist1++;\n\t\t}\n       struct ListNode* tmp=tail;\n\t\twhile(lenoflist1>=1)\n\t\t{ \n            lenoflist1--;\n            if(tail==cur)\n                continue;\n          if(cur->val>=x)\n\t\t  {\n\t\t\t\t  head1->next=cur->next;\n\t\t\t\t  cur->next=NULL;\n\t\t          tail->next=cur;\n\t\t\t\t  tail=tail->next;//not consid at first\n\t\t\t\t  cur=head1->next;\n\n\t\t  } \n\t\t  else{\n\t\t\t\t  head1=head1->next;\n\t\t\t\t  cur=cur->next;\n\t\t  }\n\t\t \n\t\t //  printf(\"%d : \",cur->num);\n\t\t}\n    //if(head1->next==NULL)head1->next=tmp;\n         head=list->next;\n   list->next=NULL;\n    free(list);\n\t\tprintf(\"\\n\");\n    return head;\n    \n}\n```\n//此题目最终被accepted\n//应该在函数中添加头节点而不是依靠传入的链表带头节点,一开始没有考虑到传入的链表不带链表头。。，没有考虑到一个元素的情况，这个方案最终accept\n\n\n#### 链表中的子链表反转，考察头插法\n+ 头插法在链表的反转，倒序，常被用到  \n\n```c \n/* reverse a linklist from m to n\n * 1->2->4->5->null and m,n(ex:2,4)\n * return 1->5->4->2->null\n */\n\n#include<stdlib.h>\n#include<stdio.h>\ntypedef struct LinkList\n{\n\tint num;\n\tstruct LinkList  *next;\n}Linklist;\nint reverselinklist(Linklist *list1,int m,int n,Linklist **result)\n{\n\t\tif(list1==NULL)\n\t\t\t\treturn -1;\n\t\tint i=0;\n\t\tLinklist *head1,*head2,*cur,*tmp,*pre;\n\t\tcur=list1;\n\t\thead1=cur;\n\t\tpre=head1;\n\t\tif(m==1)\n\t\t{\n\t\t\t\tcur=cur->next;\n\t\t\t\tfor(i=m;i<n;i++)\n\t\t\t\t{\n\t\t\t\t  pre->next=cur->next;\n\t\t\t\t  cur->next=head1;\n\t\t\t\t  head1=cur;\n\t\t\t\t  cur=pre->next;\n\t\t\t\t}\n\t\t\t    *result=head1;\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tfor(i=1;i<m;i++)//node1->node2->node3---1->2->3--ex:m=2,list1->1\n\t\t{\n\t\t  head1=cur;\n          cur=cur->next;\n\t\t}\n\t\thead2=cur;\n\t\tcur=cur->next;\n\t\tpre=head2;\n\t\tfor(i=m;i<n;i++)\n\t\t{\n\t\t   pre->next=cur->next;\n\t\t   cur->next=head1->next;\n\t\t   head1->next=cur;\n\t\t   cur=pre->next;\n\t\t}\n      return 3;\n}\n\nint main ()\n{\n\t\tLinklist *list1=(Linklist*)malloc(sizeof(Linklist));\n\t\tLinklist *result11=list1;\n\t\tint i;\n\t\tlist1->num=4;\n\t\tprintf(\"4 \");\n       for(i=1; i<9;i++)\n\t  {\n\t\t\t\t\t\t     \n\t\t\tlist1->next = (Linklist *)malloc(sizeof(Linklist));\n\t\t\tlist1 = list1->next;\n\t\t    list1->num = i*2;\n\t\t\tprintf(\"%d \",i*2);\n\t  }\n\t   printf(\"\\n\");\n\t   Linklist *rr=(Linklist *)malloc(sizeof(Linklist));\n\t   Linklist **resull=&rr;\n\t   int rere=reverselinklist(result11,1,9,resull);\n\t   if(rere==3) {\n\t    for(i=0;result11!=NULL ;i++,result11=result11->next)\n\t\t\t\t       printf(\"%d \",result11->num); \n\t  \tfree(list1);\n\t   }\n\t  else\n\t  { \n\t    for(i=0;*resull!=NULL ;i++,*resull= (*resull)->next)\n\t\t\t\t       printf(\"%d \",(*resull)->num); \n\t  \tfree(*resull);\n\t  }\n\t\treturn 0;\n}```\n//此解法未经过leetcode检验，不过应该问题不大\n\n#### 有序链表移除重复元素\n+ 考察的是遍历链表删除链表中的元素，注意边缘条件控制如头部和尾部\n\n```c\n/**\n\n Given a sorted linked list, delete all duplicates such that each element appear only once.\n\nExample 1:\n\nInput: 1->1->2\nOutput: 1->2\n\nExample 2:\n\nInput: 1->1->2->3->3\nOutput: 1->2->3\n\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\n    if(head==NULL)return NULL;\n    if(head->next==NULL)return head;\n    struct ListNode *first=head;\n    struct ListNode  *second=head->next;\n    struct ListNode *tmp=second;\n    while(second!=NULL) \n    {\n        tmp=second;\n        if(first->val==second->val)\n        {\n            second=second->next;\n            \n        }\n        else\n        {\n            first->next=second;\n            first=first->next;\n            second=second->next;\n        }\n    }\n    if(first->val==tmp->val)\n        first->next=NULL;\n    return head;\n}```\n//此方案最后被accepted\n\n#### 删除有序链表中的有重复的node\n+ 和上一道题目类似:\n\n```c\n/**\n\n Given a sorted linked list, delete all duplicates such that each element appear only once.\n\nExample 1:\n\nInput: 1->1->2\nOutput: 1->2\n\nExample 2:\n\nInput: 1->1->2->3->3\nOutput: 1->2->3\n\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n#include<stdio.h>\n#include<stdlib.h>\nstruct ListNode {\n      int val;\n      struct ListNode *next;\n  };\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\n    if(head==NULL)return NULL;\n    if(head->next==NULL)return head;\n    struct ListNode *headnode=(struct ListNode*)malloc(sizeof(struct ListNode));\n    headnode->next=head;\n    \n    struct ListNode *first=head;\n    struct ListNode  *second=head->next;\n    int numsame=0;\n    struct ListNode *tmphead=headnode;\n    while(second!=NULL) \n    {\n        if(first->val==second->val)\n        {\n               numsame++;\n               first=first->next;\n               second=second->next;\n               \n        }\n        else if(first->val !=second->val && numsame==0)\n        {\n            tmphead->next=first;\n            tmphead=tmphead->next;\n            first=first->next;\n            second=second->next;\n        }\n        else \n        {\n            first=first->next;\n            second=second->next;\n            numsame=0;\n        }\n    }\n    if(numsame==0)tmphead->next=first;\n    else tmphead->next =NULL;\n    head=headnode->next;\n    headnode->next=NULL;\n    free(headnode);   \n    return head;\n}\n\n\nint main()\n{\n   struct ListNode *list1=(struct ListNode *)malloc(sizeof(struct ListNode));\n   struct ListNode *tmp=list1;\n   struct ListNode *freelist1=list1;\n   int i=0;\n   for(i=1;i<9;i++)\n   {\n\t\t list1->val=20-i;\n\t\t list1->next=(struct ListNode *)malloc(sizeof(struct ListNode));\n\t\t list1=list1->next;\n\t\t printf(\"%d \",20-i);\n   }\n   list1->val=12;\n   tmp=deleteDuplicates(tmp);\n   printf(\"\\n\");\n   for(i=1;tmp!=NULL;i++)\n   {\n\t\t   printf(\"%d  \",tmp->val);\n\t\t   tmp=tmp->next;\n   }\n   free(freelist1);\n   return 0;\n}\n\n\n这道题做的比较顺利，一次提交就=通过了\n注意：加头节点，由于解题的思路是两个指针的遍历，在第二个指针为空时停止，就会有尾巴为几种情况时的处理：如当尾巴为：4,4,4;4,5,5 这两种情况时，去掉尾巴，否则4,5,6.4,4,5时尾巴保留；见代码```\n","source":"_posts/leetcode-linklist2.md","raw":"---\ntitle: leetcode_linklist2\ndate: 2018-06-03 21:40:41\ntags: leetcode_linklist\ncategories: leetcode\n---\n### leetcode——单链表2\n#### partition list\n这个是快速排序中一个很重要的步骤，即比该数大于等于的放其前小的放后。在链表中，基本思路:扫描链表，比给定数字小的不处理，比给定数字大的取下并插入到末尾 <!--more-->\n```c\n/*\nGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\n\nYou should preserve the original relative order of the nodes in each of the two partitions.\n\nExample:\n\nInput: head = 1->4->3->2->5->2, x = 3\nOutput: 1->2->2->4->3->5*/\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* partition(struct ListNode* head, int x) {\n    /**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n    if(head==NULL)\n\t\t\t\treturn NULL;\n    if(head->next ==NULL)\n              return head;\n        struct ListNode *list=(struct ListNode*)malloc(sizeof(struct  ListNode));\n        list->next=head;\n\t\tstruct ListNode*head1=list;\n\t\tstruct ListNode*cur = head1->next;\n\t\tstruct ListNode*tail=head1;\n\t\tint lenoflist1=0;\n\t\twhile(tail->next!=NULL)\n\t\t{\n\t\t\t\ttail=tail->next;\n\t\t\t\tlenoflist1++;\n\t\t}\n       struct ListNode* tmp=tail;\n\t\twhile(lenoflist1>=1)\n\t\t{ \n            lenoflist1--;\n            if(tail==cur)\n                continue;\n          if(cur->val>=x)\n\t\t  {\n\t\t\t\t  head1->next=cur->next;\n\t\t\t\t  cur->next=NULL;\n\t\t          tail->next=cur;\n\t\t\t\t  tail=tail->next;//not consid at first\n\t\t\t\t  cur=head1->next;\n\n\t\t  } \n\t\t  else{\n\t\t\t\t  head1=head1->next;\n\t\t\t\t  cur=cur->next;\n\t\t  }\n\t\t \n\t\t //  printf(\"%d : \",cur->num);\n\t\t}\n    //if(head1->next==NULL)head1->next=tmp;\n         head=list->next;\n   list->next=NULL;\n    free(list);\n\t\tprintf(\"\\n\");\n    return head;\n    \n}\n```\n//此题目最终被accepted\n//应该在函数中添加头节点而不是依靠传入的链表带头节点,一开始没有考虑到传入的链表不带链表头。。，没有考虑到一个元素的情况，这个方案最终accept\n\n\n#### 链表中的子链表反转，考察头插法\n+ 头插法在链表的反转，倒序，常被用到  \n\n```c \n/* reverse a linklist from m to n\n * 1->2->4->5->null and m,n(ex:2,4)\n * return 1->5->4->2->null\n */\n\n#include<stdlib.h>\n#include<stdio.h>\ntypedef struct LinkList\n{\n\tint num;\n\tstruct LinkList  *next;\n}Linklist;\nint reverselinklist(Linklist *list1,int m,int n,Linklist **result)\n{\n\t\tif(list1==NULL)\n\t\t\t\treturn -1;\n\t\tint i=0;\n\t\tLinklist *head1,*head2,*cur,*tmp,*pre;\n\t\tcur=list1;\n\t\thead1=cur;\n\t\tpre=head1;\n\t\tif(m==1)\n\t\t{\n\t\t\t\tcur=cur->next;\n\t\t\t\tfor(i=m;i<n;i++)\n\t\t\t\t{\n\t\t\t\t  pre->next=cur->next;\n\t\t\t\t  cur->next=head1;\n\t\t\t\t  head1=cur;\n\t\t\t\t  cur=pre->next;\n\t\t\t\t}\n\t\t\t    *result=head1;\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tfor(i=1;i<m;i++)//node1->node2->node3---1->2->3--ex:m=2,list1->1\n\t\t{\n\t\t  head1=cur;\n          cur=cur->next;\n\t\t}\n\t\thead2=cur;\n\t\tcur=cur->next;\n\t\tpre=head2;\n\t\tfor(i=m;i<n;i++)\n\t\t{\n\t\t   pre->next=cur->next;\n\t\t   cur->next=head1->next;\n\t\t   head1->next=cur;\n\t\t   cur=pre->next;\n\t\t}\n      return 3;\n}\n\nint main ()\n{\n\t\tLinklist *list1=(Linklist*)malloc(sizeof(Linklist));\n\t\tLinklist *result11=list1;\n\t\tint i;\n\t\tlist1->num=4;\n\t\tprintf(\"4 \");\n       for(i=1; i<9;i++)\n\t  {\n\t\t\t\t\t\t     \n\t\t\tlist1->next = (Linklist *)malloc(sizeof(Linklist));\n\t\t\tlist1 = list1->next;\n\t\t    list1->num = i*2;\n\t\t\tprintf(\"%d \",i*2);\n\t  }\n\t   printf(\"\\n\");\n\t   Linklist *rr=(Linklist *)malloc(sizeof(Linklist));\n\t   Linklist **resull=&rr;\n\t   int rere=reverselinklist(result11,1,9,resull);\n\t   if(rere==3) {\n\t    for(i=0;result11!=NULL ;i++,result11=result11->next)\n\t\t\t\t       printf(\"%d \",result11->num); \n\t  \tfree(list1);\n\t   }\n\t  else\n\t  { \n\t    for(i=0;*resull!=NULL ;i++,*resull= (*resull)->next)\n\t\t\t\t       printf(\"%d \",(*resull)->num); \n\t  \tfree(*resull);\n\t  }\n\t\treturn 0;\n}```\n//此解法未经过leetcode检验，不过应该问题不大\n\n#### 有序链表移除重复元素\n+ 考察的是遍历链表删除链表中的元素，注意边缘条件控制如头部和尾部\n\n```c\n/**\n\n Given a sorted linked list, delete all duplicates such that each element appear only once.\n\nExample 1:\n\nInput: 1->1->2\nOutput: 1->2\n\nExample 2:\n\nInput: 1->1->2->3->3\nOutput: 1->2->3\n\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\n    if(head==NULL)return NULL;\n    if(head->next==NULL)return head;\n    struct ListNode *first=head;\n    struct ListNode  *second=head->next;\n    struct ListNode *tmp=second;\n    while(second!=NULL) \n    {\n        tmp=second;\n        if(first->val==second->val)\n        {\n            second=second->next;\n            \n        }\n        else\n        {\n            first->next=second;\n            first=first->next;\n            second=second->next;\n        }\n    }\n    if(first->val==tmp->val)\n        first->next=NULL;\n    return head;\n}```\n//此方案最后被accepted\n\n#### 删除有序链表中的有重复的node\n+ 和上一道题目类似:\n\n```c\n/**\n\n Given a sorted linked list, delete all duplicates such that each element appear only once.\n\nExample 1:\n\nInput: 1->1->2\nOutput: 1->2\n\nExample 2:\n\nInput: 1->1->2->3->3\nOutput: 1->2->3\n\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n#include<stdio.h>\n#include<stdlib.h>\nstruct ListNode {\n      int val;\n      struct ListNode *next;\n  };\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\n    if(head==NULL)return NULL;\n    if(head->next==NULL)return head;\n    struct ListNode *headnode=(struct ListNode*)malloc(sizeof(struct ListNode));\n    headnode->next=head;\n    \n    struct ListNode *first=head;\n    struct ListNode  *second=head->next;\n    int numsame=0;\n    struct ListNode *tmphead=headnode;\n    while(second!=NULL) \n    {\n        if(first->val==second->val)\n        {\n               numsame++;\n               first=first->next;\n               second=second->next;\n               \n        }\n        else if(first->val !=second->val && numsame==0)\n        {\n            tmphead->next=first;\n            tmphead=tmphead->next;\n            first=first->next;\n            second=second->next;\n        }\n        else \n        {\n            first=first->next;\n            second=second->next;\n            numsame=0;\n        }\n    }\n    if(numsame==0)tmphead->next=first;\n    else tmphead->next =NULL;\n    head=headnode->next;\n    headnode->next=NULL;\n    free(headnode);   \n    return head;\n}\n\n\nint main()\n{\n   struct ListNode *list1=(struct ListNode *)malloc(sizeof(struct ListNode));\n   struct ListNode *tmp=list1;\n   struct ListNode *freelist1=list1;\n   int i=0;\n   for(i=1;i<9;i++)\n   {\n\t\t list1->val=20-i;\n\t\t list1->next=(struct ListNode *)malloc(sizeof(struct ListNode));\n\t\t list1=list1->next;\n\t\t printf(\"%d \",20-i);\n   }\n   list1->val=12;\n   tmp=deleteDuplicates(tmp);\n   printf(\"\\n\");\n   for(i=1;tmp!=NULL;i++)\n   {\n\t\t   printf(\"%d  \",tmp->val);\n\t\t   tmp=tmp->next;\n   }\n   free(freelist1);\n   return 0;\n}\n\n\n这道题做的比较顺利，一次提交就=通过了\n注意：加头节点，由于解题的思路是两个指针的遍历，在第二个指针为空时停止，就会有尾巴为几种情况时的处理：如当尾巴为：4,4,4;4,5,5 这两种情况时，去掉尾巴，否则4,5,6.4,4,5时尾巴保留；见代码```\n","slug":"leetcode-linklist2","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7rr003z2ujxy4tgn1va","content":"<h3 id=\"leetcode——单链表2\"><a href=\"#leetcode——单链表2\" class=\"headerlink\" title=\"leetcode——单链表2\"></a>leetcode——单链表2</h3><h4 id=\"partition-list\"><a href=\"#partition-list\" class=\"headerlink\" title=\"partition list\"></a>partition list</h4><p>这个是快速排序中一个很重要的步骤，即比该数大于等于的放其前小的放后。在链表中，基本思路:扫描链表，比给定数字小的不处理，比给定数字大的取下并插入到末尾 <a id=\"more\"></a><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">You should preserve the original relative order of the nodes in each of the two partitions.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Example:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span></span><br><span class=\"line\"><span class=\"comment\">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">partition</span><span class=\"params\">(struct ListNode* head, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head-&gt;next ==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">              <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">list</span>=(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>*)<span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span>  <span class=\"title\">ListNode</span>));</span></span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;next=head;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>*<span class=\"title\">head1</span>=<span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>*<span class=\"title\">cur</span> = <span class=\"title\">head1</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>*<span class=\"title\">tail</span>=<span class=\"title\">head1</span>;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> lenoflist1=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(tail-&gt;next!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t\ttail=tail-&gt;next;</span><br><span class=\"line\">\t\t\t\tlenoflist1++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">tmp</span>=<span class=\"title\">tail</span>;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(lenoflist1&gt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">            lenoflist1--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tail==cur)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(cur-&gt;val&gt;=x)</span><br><span class=\"line\">\t\t  &#123;</span><br><span class=\"line\">\t\t\t\t  head1-&gt;next=cur-&gt;next;</span><br><span class=\"line\">\t\t\t\t  cur-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t          tail-&gt;next=cur;</span><br><span class=\"line\">\t\t\t\t  tail=tail-&gt;next;<span class=\"comment\">//not consid at first</span></span><br><span class=\"line\">\t\t\t\t  cur=head1-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t  &#125; </span><br><span class=\"line\">\t\t  <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t  head1=head1-&gt;next;</span><br><span class=\"line\">\t\t\t\t  cur=cur-&gt;next;</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t </span><br><span class=\"line\">\t\t <span class=\"comment\">//  printf(\"%d : \",cur-&gt;num);</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//if(head1-&gt;next==NULL)head1-&gt;next=tmp;</span></span><br><span class=\"line\">         head=<span class=\"built_in\">list</span>-&gt;next;</span><br><span class=\"line\">   <span class=\"built_in\">list</span>-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//此题目最终被accepted<br>//应该在函数中添加头节点而不是依靠传入的链表带头节点,一开始没有考虑到传入的链表不带链表头。。，没有考虑到一个元素的情况，这个方案最终accept</p>\n<h4 id=\"链表中的子链表反转，考察头插法\"><a href=\"#链表中的子链表反转，考察头插法\" class=\"headerlink\" title=\"链表中的子链表反转，考察头插法\"></a>链表中的子链表反转，考察头插法</h4><ul>\n<li>头插法在链表的反转，倒序，常被用到  </li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* reverse a linklist from m to n</span></span><br><span class=\"line\"><span class=\"comment\"> * 1-&gt;2-&gt;4-&gt;5-&gt;null and m,n(ex:2,4)</span></span><br><span class=\"line\"><span class=\"comment\"> * return 1-&gt;5-&gt;4-&gt;2-&gt;null</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span>  *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;Linklist;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverselinklist</span><span class=\"params\">(Linklist *list1,<span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> n,Linklist **result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(list1==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tLinklist *head1,*head2,*cur,*tmp,*pre;</span><br><span class=\"line\">\t\tcur=list1;</span><br><span class=\"line\">\t\thead1=cur;</span><br><span class=\"line\">\t\tpre=head1;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(m==<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcur=cur-&gt;next;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(i=m;i&lt;n;i++)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t  pre-&gt;next=cur-&gt;next;</span><br><span class=\"line\">\t\t\t\t  cur-&gt;next=head1;</span><br><span class=\"line\">\t\t\t\t  head1=cur;</span><br><span class=\"line\">\t\t\t\t  cur=pre-&gt;next;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t    *result=head1;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;m;i++)<span class=\"comment\">//node1-&gt;node2-&gt;node3---1-&gt;2-&gt;3--ex:m=2,list1-&gt;1</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t  head1=cur;</span><br><span class=\"line\">          cur=cur-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\thead2=cur;</span><br><span class=\"line\">\t\tcur=cur-&gt;next;</span><br><span class=\"line\">\t\tpre=head2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(i=m;i&lt;n;i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t   pre-&gt;next=cur-&gt;next;</span><br><span class=\"line\">\t\t   cur-&gt;next=head1-&gt;next;</span><br><span class=\"line\">\t\t   head1-&gt;next=cur;</span><br><span class=\"line\">\t\t   cur=pre-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\tLinklist *list1=(Linklist*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Linklist));</span><br><span class=\"line\">\t\tLinklist *result11=list1;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t\tlist1-&gt;num=<span class=\"number\">4</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"4 \"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;<span class=\"number\">9</span>;i++)</span><br><span class=\"line\">\t  &#123;</span><br><span class=\"line\">\t\t\t\t\t\t     </span><br><span class=\"line\">\t\t\tlist1-&gt;next = (Linklist *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Linklist));</span><br><span class=\"line\">\t\t\tlist1 = list1-&gt;next;</span><br><span class=\"line\">\t\t    list1-&gt;num = i*<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,i*<span class=\"number\">2</span>);</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">\t   <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\t   Linklist *rr=(Linklist *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Linklist));</span><br><span class=\"line\">\t   Linklist **resull=&amp;rr;</span><br><span class=\"line\">\t   <span class=\"keyword\">int</span> rere=reverselinklist(result11,<span class=\"number\">1</span>,<span class=\"number\">9</span>,resull);</span><br><span class=\"line\">\t   <span class=\"keyword\">if</span>(rere==<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;result11!=<span class=\"literal\">NULL</span> ;i++,result11=result11-&gt;next)</span><br><span class=\"line\">\t\t\t\t       <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,result11-&gt;num); </span><br><span class=\"line\">\t  \t<span class=\"built_in\">free</span>(list1);</span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">\t  <span class=\"keyword\">else</span></span><br><span class=\"line\">\t  &#123; </span><br><span class=\"line\">\t    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;*resull!=<span class=\"literal\">NULL</span> ;i++,*resull= (*resull)-&gt;next)</span><br><span class=\"line\">\t\t\t\t       <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,(*resull)-&gt;num); </span><br><span class=\"line\">\t  \t<span class=\"built_in\">free</span>(*resull);</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>//此解法未经过leetcode检验，不过应该问题不大</p>\n<h4 id=\"有序链表移除重复元素\"><a href=\"#有序链表移除重复元素\" class=\"headerlink\" title=\"有序链表移除重复元素\"></a>有序链表移除重复元素</h4><ul>\n<li>考察的是遍历链表删除链表中的元素，注意边缘条件控制如头部和尾部</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> Given a sorted linked list, delete all duplicates such that each element appear only once.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Example 1:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Input: 1-&gt;1-&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">Output: 1-&gt;2</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Example 2:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span></span><br><span class=\"line\"><span class=\"comment\">Output: 1-&gt;2-&gt;3</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(struct ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head-&gt;next==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">first</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>  *<span class=\"title\">second</span>=<span class=\"title\">head</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">tmp</span>=<span class=\"title\">second</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(second!=<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp=second;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first-&gt;val==second-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            second=second-&gt;next;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            first-&gt;next=second;</span><br><span class=\"line\">            first=first-&gt;next;</span><br><span class=\"line\">            second=second-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(first-&gt;val==tmp-&gt;val)</span><br><span class=\"line\">        first-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>//此方案最后被accepted</p>\n<h4 id=\"删除有序链表中的有重复的node\"><a href=\"#删除有序链表中的有重复的node\" class=\"headerlink\" title=\"删除有序链表中的有重复的node\"></a>删除有序链表中的有重复的node</h4><ul>\n<li>和上一道题目类似:</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> Given a sorted linked list, delete all duplicates such that each element appear only once.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Example 1:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Input: 1-&gt;1-&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">Output: 1-&gt;2</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Example 2:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span></span><br><span class=\"line\"><span class=\"comment\">Output: 1-&gt;2-&gt;3</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> &#123;</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(struct ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head-&gt;next==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">headnode</span>=(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>*)<span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>));</span></span><br><span class=\"line\">    headnode-&gt;next=head;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">first</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>  *<span class=\"title\">second</span>=<span class=\"title\">head</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> numsame=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">tmphead</span>=<span class=\"title\">headnode</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(second!=<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first-&gt;val==second-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">               numsame++;</span><br><span class=\"line\">               first=first-&gt;next;</span><br><span class=\"line\">               second=second-&gt;next;</span><br><span class=\"line\">               </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(first-&gt;val !=second-&gt;val &amp;&amp; numsame==<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tmphead-&gt;next=first;</span><br><span class=\"line\">            tmphead=tmphead-&gt;next;</span><br><span class=\"line\">            first=first-&gt;next;</span><br><span class=\"line\">            second=second-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            first=first-&gt;next;</span><br><span class=\"line\">            second=second-&gt;next;</span><br><span class=\"line\">            numsame=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(numsame==<span class=\"number\">0</span>)tmphead-&gt;next=first;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> tmphead-&gt;next =<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    head=headnode-&gt;next;</span><br><span class=\"line\">    headnode-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(headnode);   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">list1</span>=(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span> *)<span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>));</span></span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">tmp</span>=<span class=\"title\">list1</span>;</span></span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">freelist1</span>=<span class=\"title\">list1</span>;</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">9</span>;i++)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">\t\t list1-&gt;val=<span class=\"number\">20</span>-i;</span><br><span class=\"line\">\t\t list1-&gt;next=(struct ListNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\t\t list1=list1-&gt;next;</span><br><span class=\"line\">\t\t <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,<span class=\"number\">20</span>-i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   list1-&gt;val=<span class=\"number\">12</span>;</span><br><span class=\"line\">   tmp=deleteDuplicates(tmp);</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;tmp!=<span class=\"literal\">NULL</span>;i++)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">\t\t   <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d  \"</span>,tmp-&gt;val);</span><br><span class=\"line\">\t\t   tmp=tmp-&gt;next;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">free</span>(freelist1);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">这道题做的比较顺利，一次提交就=通过了</span><br><span class=\"line\">注意：加头节点，由于解题的思路是两个指针的遍历，在第二个指针为空时停止，就会有尾巴为几种情况时的处理：如当尾巴为：<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span> 这两种情况时，去掉尾巴，否则<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6.4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>时尾巴保留；见代码</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"leetcode——单链表2\"><a href=\"#leetcode——单链表2\" class=\"headerlink\" title=\"leetcode——单链表2\"></a>leetcode——单链表2</h3><h4 id=\"partition-list\"><a href=\"#partition-list\" class=\"headerlink\" title=\"partition list\"></a>partition list</h4><p>这个是快速排序中一个很重要的步骤，即比该数大于等于的放其前小的放后。在链表中，基本思路:扫描链表，比给定数字小的不处理，比给定数字大的取下并插入到末尾","more":"<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">You should preserve the original relative order of the nodes in each of the two partitions.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Example:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span></span><br><span class=\"line\"><span class=\"comment\">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">partition</span><span class=\"params\">(struct ListNode* head, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head-&gt;next ==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">              <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">list</span>=(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>*)<span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span>  <span class=\"title\">ListNode</span>));</span></span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;next=head;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>*<span class=\"title\">head1</span>=<span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>*<span class=\"title\">cur</span> = <span class=\"title\">head1</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>*<span class=\"title\">tail</span>=<span class=\"title\">head1</span>;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> lenoflist1=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(tail-&gt;next!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t\ttail=tail-&gt;next;</span><br><span class=\"line\">\t\t\t\tlenoflist1++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">       <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">tmp</span>=<span class=\"title\">tail</span>;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(lenoflist1&gt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">            lenoflist1--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tail==cur)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(cur-&gt;val&gt;=x)</span><br><span class=\"line\">\t\t  &#123;</span><br><span class=\"line\">\t\t\t\t  head1-&gt;next=cur-&gt;next;</span><br><span class=\"line\">\t\t\t\t  cur-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t          tail-&gt;next=cur;</span><br><span class=\"line\">\t\t\t\t  tail=tail-&gt;next;<span class=\"comment\">//not consid at first</span></span><br><span class=\"line\">\t\t\t\t  cur=head1-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t  &#125; </span><br><span class=\"line\">\t\t  <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t  head1=head1-&gt;next;</span><br><span class=\"line\">\t\t\t\t  cur=cur-&gt;next;</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t </span><br><span class=\"line\">\t\t <span class=\"comment\">//  printf(\"%d : \",cur-&gt;num);</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//if(head1-&gt;next==NULL)head1-&gt;next=tmp;</span></span><br><span class=\"line\">         head=<span class=\"built_in\">list</span>-&gt;next;</span><br><span class=\"line\">   <span class=\"built_in\">list</span>-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//此题目最终被accepted<br>//应该在函数中添加头节点而不是依靠传入的链表带头节点,一开始没有考虑到传入的链表不带链表头。。，没有考虑到一个元素的情况，这个方案最终accept</p>\n<h4 id=\"链表中的子链表反转，考察头插法\"><a href=\"#链表中的子链表反转，考察头插法\" class=\"headerlink\" title=\"链表中的子链表反转，考察头插法\"></a>链表中的子链表反转，考察头插法</h4><ul>\n<li>头插法在链表的反转，倒序，常被用到  </li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* reverse a linklist from m to n</span></span><br><span class=\"line\"><span class=\"comment\"> * 1-&gt;2-&gt;4-&gt;5-&gt;null and m,n(ex:2,4)</span></span><br><span class=\"line\"><span class=\"comment\"> * return 1-&gt;5-&gt;4-&gt;2-&gt;null</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkList</span>  *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;Linklist;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverselinklist</span><span class=\"params\">(Linklist *list1,<span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> n,Linklist **result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(list1==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tLinklist *head1,*head2,*cur,*tmp,*pre;</span><br><span class=\"line\">\t\tcur=list1;</span><br><span class=\"line\">\t\thead1=cur;</span><br><span class=\"line\">\t\tpre=head1;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(m==<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcur=cur-&gt;next;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(i=m;i&lt;n;i++)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t  pre-&gt;next=cur-&gt;next;</span><br><span class=\"line\">\t\t\t\t  cur-&gt;next=head1;</span><br><span class=\"line\">\t\t\t\t  head1=cur;</span><br><span class=\"line\">\t\t\t\t  cur=pre-&gt;next;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t    *result=head1;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;m;i++)<span class=\"comment\">//node1-&gt;node2-&gt;node3---1-&gt;2-&gt;3--ex:m=2,list1-&gt;1</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t  head1=cur;</span><br><span class=\"line\">          cur=cur-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\thead2=cur;</span><br><span class=\"line\">\t\tcur=cur-&gt;next;</span><br><span class=\"line\">\t\tpre=head2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(i=m;i&lt;n;i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t   pre-&gt;next=cur-&gt;next;</span><br><span class=\"line\">\t\t   cur-&gt;next=head1-&gt;next;</span><br><span class=\"line\">\t\t   head1-&gt;next=cur;</span><br><span class=\"line\">\t\t   cur=pre-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t\tLinklist *list1=(Linklist*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Linklist));</span><br><span class=\"line\">\t\tLinklist *result11=list1;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t\tlist1-&gt;num=<span class=\"number\">4</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"4 \"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;<span class=\"number\">9</span>;i++)</span><br><span class=\"line\">\t  &#123;</span><br><span class=\"line\">\t\t\t\t\t\t     </span><br><span class=\"line\">\t\t\tlist1-&gt;next = (Linklist *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Linklist));</span><br><span class=\"line\">\t\t\tlist1 = list1-&gt;next;</span><br><span class=\"line\">\t\t    list1-&gt;num = i*<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,i*<span class=\"number\">2</span>);</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">\t   <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\t   Linklist *rr=(Linklist *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Linklist));</span><br><span class=\"line\">\t   Linklist **resull=&amp;rr;</span><br><span class=\"line\">\t   <span class=\"keyword\">int</span> rere=reverselinklist(result11,<span class=\"number\">1</span>,<span class=\"number\">9</span>,resull);</span><br><span class=\"line\">\t   <span class=\"keyword\">if</span>(rere==<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;result11!=<span class=\"literal\">NULL</span> ;i++,result11=result11-&gt;next)</span><br><span class=\"line\">\t\t\t\t       <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,result11-&gt;num); </span><br><span class=\"line\">\t  \t<span class=\"built_in\">free</span>(list1);</span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">\t  <span class=\"keyword\">else</span></span><br><span class=\"line\">\t  &#123; </span><br><span class=\"line\">\t    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;*resull!=<span class=\"literal\">NULL</span> ;i++,*resull= (*resull)-&gt;next)</span><br><span class=\"line\">\t\t\t\t       <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,(*resull)-&gt;num); </span><br><span class=\"line\">\t  \t<span class=\"built_in\">free</span>(*resull);</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>//此解法未经过leetcode检验，不过应该问题不大</p>\n<h4 id=\"有序链表移除重复元素\"><a href=\"#有序链表移除重复元素\" class=\"headerlink\" title=\"有序链表移除重复元素\"></a>有序链表移除重复元素</h4><ul>\n<li>考察的是遍历链表删除链表中的元素，注意边缘条件控制如头部和尾部</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> Given a sorted linked list, delete all duplicates such that each element appear only once.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Example 1:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Input: 1-&gt;1-&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">Output: 1-&gt;2</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Example 2:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span></span><br><span class=\"line\"><span class=\"comment\">Output: 1-&gt;2-&gt;3</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(struct ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head-&gt;next==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">first</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>  *<span class=\"title\">second</span>=<span class=\"title\">head</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">tmp</span>=<span class=\"title\">second</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(second!=<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp=second;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first-&gt;val==second-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            second=second-&gt;next;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            first-&gt;next=second;</span><br><span class=\"line\">            first=first-&gt;next;</span><br><span class=\"line\">            second=second-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(first-&gt;val==tmp-&gt;val)</span><br><span class=\"line\">        first-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>//此方案最后被accepted</p>\n<h4 id=\"删除有序链表中的有重复的node\"><a href=\"#删除有序链表中的有重复的node\" class=\"headerlink\" title=\"删除有序链表中的有重复的node\"></a>删除有序链表中的有重复的node</h4><ul>\n<li>和上一道题目类似:</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> Given a sorted linked list, delete all duplicates such that each element appear only once.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Example 1:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Input: 1-&gt;1-&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">Output: 1-&gt;2</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Example 2:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span></span><br><span class=\"line\"><span class=\"comment\">Output: 1-&gt;2-&gt;3</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> &#123;</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(struct ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(head-&gt;next==<span class=\"literal\">NULL</span>)<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">headnode</span>=(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>*)<span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>));</span></span><br><span class=\"line\">    headnode-&gt;next=head;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">first</span>=<span class=\"title\">head</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>  *<span class=\"title\">second</span>=<span class=\"title\">head</span>-&gt;<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> numsame=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">tmphead</span>=<span class=\"title\">headnode</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(second!=<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first-&gt;val==second-&gt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">               numsame++;</span><br><span class=\"line\">               first=first-&gt;next;</span><br><span class=\"line\">               second=second-&gt;next;</span><br><span class=\"line\">               </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(first-&gt;val !=second-&gt;val &amp;&amp; numsame==<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tmphead-&gt;next=first;</span><br><span class=\"line\">            tmphead=tmphead-&gt;next;</span><br><span class=\"line\">            first=first-&gt;next;</span><br><span class=\"line\">            second=second-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            first=first-&gt;next;</span><br><span class=\"line\">            second=second-&gt;next;</span><br><span class=\"line\">            numsame=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(numsame==<span class=\"number\">0</span>)tmphead-&gt;next=first;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> tmphead-&gt;next =<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    head=headnode-&gt;next;</span><br><span class=\"line\">    headnode-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(headnode);   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">list1</span>=(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span> *)<span class=\"title\">malloc</span>(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">ListNode</span>));</span></span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">tmp</span>=<span class=\"title\">list1</span>;</span></span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">freelist1</span>=<span class=\"title\">list1</span>;</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">9</span>;i++)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">\t\t list1-&gt;val=<span class=\"number\">20</span>-i;</span><br><span class=\"line\">\t\t list1-&gt;next=(struct ListNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">\t\t list1=list1-&gt;next;</span><br><span class=\"line\">\t\t <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,<span class=\"number\">20</span>-i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   list1-&gt;val=<span class=\"number\">12</span>;</span><br><span class=\"line\">   tmp=deleteDuplicates(tmp);</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;tmp!=<span class=\"literal\">NULL</span>;i++)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">\t\t   <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d  \"</span>,tmp-&gt;val);</span><br><span class=\"line\">\t\t   tmp=tmp-&gt;next;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">free</span>(freelist1);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">这道题做的比较顺利，一次提交就=通过了</span><br><span class=\"line\">注意：加头节点，由于解题的思路是两个指针的遍历，在第二个指针为空时停止，就会有尾巴为几种情况时的处理：如当尾巴为：<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span> 这两种情况时，去掉尾巴，否则<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6.4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>时尾巴保留；见代码</span><br></pre></td></tr></table></figure>"},{"title":"tcpip_PF_PACKET","date":"2018-05-27T12:28:40.000Z","_content":"{% asset_img pf_packet.jpg it just picture %}\n### PF_PACKET的使用：\n### PF_PACKET简介：\n是linux下的用于发送和接收二层(mac层)的套接字：\n<!-- more -->\n### PF_PACKET基本使用：\n+ 基本的几个操作：  \n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <linux/if.h>\n#include <sys/ioctl.h>\n#include <linux/if_packet.h>\n#include <linux/if_ether.h>```\n\n```cpp\n//获取硬件网卡的相应信息\nvoid GetEthInfor(char *name ,  char *MAC_addr , struct in_addr * IP_addr)//传入接口名，取回mac和ip\n{\n   struct ifreq  eth;  //结构用于存放最初获取的接口信息\n   //该结构存放在：/net/if.h,详细字段表示在头文件中\n   int fd;             //用于创建套接字\n   int temp=0;         //用于验证接口调用\n   int i=0;            //用于循环\n   strncpy(eth.ifr_name,name,sizeof(struct ifreq)-1);\n  // fd = socket(AF_INET,SOCK_DGRAM,0);\n  // fd=socket(AF_INET,SOCK_STREAM,0); \n    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));\n    if(fd<0)\n    {\n       printf(\"socket failed!\\n\");\n       exit(1);\n    }\n        //获取并且保存和打印指定的物理接口MAC地址信息\n     temp = ioctl(fd,SIOCGIFHWADDR,&eth);\n     if(temp<0)\n     {\n        printf(\"ioctl--get hardware addr failed!\\n\");\n        exit(1);\n     }\n      strncpy(MAC_addr,eth.ifr_hwaddr.sa_data,6);\n      printf(\"The MAC_addr is:\");\n      for(i =0 ;i<6;i++)\n          printf(\"%4X\",(unsigned char)eth.ifr_hwaddr.sa_data[i]); \n      printf(\"\\n\");\n       \n        //获取并且保存和打印指定的物理接口IP地址信息\n      temp = ioctl(fd,SIOCGIFADDR,&eth);\n      if(temp<0)\n      {\n         printf(\"ioctl--get hardware addr failed!\\n\");\n         exit(1);\n      }\n      memcpy(IP_addr ,&(((struct sockaddr_in *)(&eth.ifr_addr))->sin_addr),4);\n      //关闭套接口\n      printf(\"got ipaddr:%s\\n\",inet_ntoa(*IP_addr)); \n      close(fd);\n}\n//取得网络接口的索引：int值,传入fd和接口名\nint Get_IfaceIndex(int fd, const char* interfaceName)\n{\nstruct ifreq ifr;\nif (interfaceName == NULL)\n{\n   return -1;\n}\nmemset(&ifr, 0, sizeof(ifr));\nstrcpy(ifr.ifr_name, interfaceName);\nif (ioctl(fd, SIOCGIFINDEX, &ifr) == -1)\n{\n   printf(\"RED ioctl error\\n\");\n   return -1;\n}\nreturn ifr.ifr_ifindex;\n}\nint set_Iface_promisc(int fd, int dev_id)//传入fd和index\n{\nstruct packet_mreq mr;\nmemset(&mr,0,sizeof(mr));\nmr.mr_ifindex = dev_id;\nmr.mr_type = PACKET_MR_PROMISC;\nif(setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&mr,sizeof(mr))==-1)//退出混杂模式使用这个：PACKET_DROP_MEMBERSHIP\n{\n   fprintf(stderr,\"GREEN set promisc failed! \\n\");\n   return -1;\n}\nreturn 0;\n}```\n使用\n```cpp\nint main ()\n{\n\t unsigned char MAC_ADDR[6];\n     struct in_addr IP_ADDR;//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.\n\t //第一步：获取指定网卡的信息（MAC地址和IP地址）\n    GetEthInfor(\"wlp2s0\",MAC_ADDR,&IP_ADDR);\n    int fd;\n     fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP));\n    int index=Get_IfaceIndex(fd,\"enp1s0\");\n    printf(\"index:%d\\n\",index);\n    return 0;\n   }\n```\n\n### PF_PACKET的接收：\n简单说明：  \n创建套结字的时候，有以下的组合：更多见：man packet\n * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.\n * 第二个参数： 套接字类型：\n          SOCK_DGRAM----以太网头已经构造好了\n          SOCK_RAW------自己构造以太头 \n          * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字\n          * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），\n          * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，\n          * 而发送时也无须用户添加头部字段。\n + 第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP\n   * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：  \n   1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)\n  和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)  \n  2)  IEEE维护的注册以太网类型列表  \n  3）半官方的列表由IANA维护  \n      ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。\n      0x88b5和0x88b6是保留以太网类型，供实验或私人使用。   \n(若指定socket_type为SOCK_RAW则意味着原始数据包包含了链路层头部，若指定为SOCK_DGRAM则将做一些处理以剥掉链路层头部。链路层头部信息的通用格式是一个sockaddr_ll结构。protocol填入网络字节序的IEEE 802.3协议号。参见<linux/if_ether.h>头文件了解允许的协议。如果protocol被设置为htons(ETH_P_ALL)，则意味着接受所有协议。所有接入的协议类型为protocol的数据包将在传递给内核之前传递到PACKET套接字。)\n+ 收包可以使用的接口：\n```cpp\n  int readnum = recvfrom(rawsock, buffer,2048,0, (struct sockaddr*)(&eth_info),&leneth_info);\n  int readnum = read(rawsock, buffer,2048);\n  int readnum = recvfrom(rawsock, buffer,2048,0, NULL,NULL);```\n        \n+ 一个简单的接收包的例子：\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <stdlib.h>\n#include <linux/if_packet.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <linux/if.h>\n#include <sys/ioctl.h>\n#include <linux/if_packet.h>\n#include <linux/if_ether.h>\n#define BUFFER_MAX 2048```\n\n```c\nint main(int argc, char *argv[])\n{\n if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) < 0)\n   {\n        printf(\"error: create raw socket!!!\\n\");\n        exit(0);\n    }\n  while(1)\n   {\n        int readnum = read(rawsock, buffer,2048);// can read packet\n        //printf(\"recv buffer:%s\\n\",buffer);\n    }\n    return 0;\n   }```\n  \n+ 指定从某个接口接收数据：\n```c\nint main(int argc, char *argv[])\n{\n struct sockaddr_ll eth_info;//结构体的定义在/linux/if_packet.h中， 表示设备无关的物理层地址结构\n  eth_info.sll_family = PF_PACKET;  //PF_PACKET定义在sys/types.h中\n  eth_info.sll_ifindex = if_nametoindex(\"lo\");//返回输入的接口名称的索引值　　//次函数定义在net/if.h中\n if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) < 0)\n   {\n        printf(\"error: create raw socket!!!\\n\");\n        exit(0);\n    }\n if(bind(rawsock,(struct sockaddr *)(&eth_info),sizeof(eth_info))==-1)//绑定接口，从而只接收那个接口上的数据\n{\n       printf(\"error: bind!!\\n\");\n        exit(0);\n}\n  while(1)\n   {\n        int readnum = read(rawsock, buffer,2048);// can read packet\n        //printf(\"recv buffer:%s\\n\",buffer);\n    }\n    return 0;\n   }```\n  \n+ 接收后的包如何读取：以包括mac头的形式来看：粗暴的形式\n```c\nint main(int argc, char *argv[])\n{\n    int rawsock;\n    char buffer[BUFFER_MAX];\n    char *ethhead;\n    char *iphead;\n    char *tcphead;\n    char *udphead;\n    char *icmphead;\n    char *pHead;\n if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) < 0)\n   {\n        printf(\"error: create raw socket!!!\\n\");\n        exit(0);\n    }\n  while(1)\n   {\n        int readnum = read(rawsock, buffer,2048);// can read packet\n        //printf(\"recv buffer:%s\\n\",buffer);\n         if(readnum < 42)\n        {\n            printf(\"error: Header is incomplete!!!\\n\");\n            continue;\n        }\n      //  for(j;j<readnum;j++)\n      //     printf(\"%.2X:\",buffer[j]&0xFF);\n        ethhead = (char *)buffer;\n        pHead = ethhead;\n        int ethernetmask = 0XFF;\n        framecount++;\n        printf(\"------------------Analysis   Packet [%d]---------------------\\n\",framecount);\n       // printf(\"all:-----%s\\n\",ethhead);\n        printf(\"MAC:\");\n        \n        int i = 6;\n        for(; i <=11; i++)\n        {\n            printf(\"%.2X:\",pHead[i]&ethernetmask);\n        }\n        printf(\"---->\");\n        for(i = 0; i <=5; i++)\n        {\n            printf(\"%.2X:\",pHead[i]&ethernetmask);\n        }\n        printf(\"\\n\");\n        printf(\"proto: %.2x:\",pHead[12]&ethernetmask);\n        printf(\"proto2: %.2x:\\n\",pHead[13]&ethernetmask);        \n        iphead = ethhead + 14;\n        pHead = iphead + 14;\n        printf(\"IP:\");\n        for(i = 0; i <=3; i++)\n        {\n            printf(\"%d\",pHead[i]&ethernetmask);\n            if(i != 3)\n            printf(\".\");\n        }\n        printf(\"---->\");\n        for(i = 10; i <=13; i++)\n        {\n            printf(\"%d\",pHead[i]&ethernetmask);\n            if(i != 13)\n            printf(\".\");\n        }\n        printf(\"\\n\");\n        int prototype = (iphead + 9)[0];\n     //   printf(\"Protocol: %.2X:\",prototype);\n        //int prototype = (iphead + 9)[0];\n        pHead = iphead + 20;\n        printf(\"Protocol: \");\n        switch(prototype)\n        {\n            case IPPROTO_ICMP:\n                printf(\"ICMP\\n\");\n                break;\n            case IPPROTO_IGMP:\n                printf(\"IGMP\\n\");\n                break;\n            case IPPROTO_IPIP:\n                printf(\"IP\\n\");\n                break;\n            case IPPROTO_TCP :\n                printf(\"TCP | source port: %u | \",(pHead[0]<<8)&0XFF00 | pHead[1]&0XFF);\n                printf(\"dest port: %u\\n\", (pHead[2]<<8)&0XFF00 | pHead[3]&0XFF);\n                break;\n            case IPPROTO_UDP :\n                printf(\"UDP | source port: %u | \",(pHead[0]<<8)&0XFF00 | pHead[1]&0XFF);\n                printf(\"dest port: %u\\n\", (pHead[2]<<8)&0XFF00 | pHead[3]&0XFF);\n                break;\n            case IPPROTO_RAW :\n                printf(\"RAW\\n\");\n                break;\n            default:\n                printf(\"Unkown\\n\");\n        }\n      printf(\"-------------------------end-----------------------\\n\");\n    }\n    return 0;\n   }```\n收包处理的方式，也可以把指针赋给内核的结构：struct iphdr\n如：   \n```cpp\n struct iphdr ip;\n ip = (struct iphdr *)(buffer + sizeof(struct ethhdr));\n ```\n内核提供了很多的包结构，在发包或者收包的时候可以直接使用这些结构解析或者粗暴的用字符串解析\n\n### PF_PACKET发送包： \n+ 发包和接收包类似：  \n```cpp\nnum = sendto(rawsock, buffer,2048 , 0 ,(struct sockaddr*)(&eth_info),sizeof(eth_info));\n if(num<0)\n {\n  printf(\"sendto failed!\\n\");\n  exit(1);\n }\n printf(\"success:%d\\n\",num);```","source":"_posts/tcpip-PF-PACKET.md","raw":"---\ntitle: tcpip_PF_PACKET\ndate: 2018-05-27 20:28:40\ntags: PF_PACKET\ncategories: tcpip\n---\n{% asset_img pf_packet.jpg it just picture %}\n### PF_PACKET的使用：\n### PF_PACKET简介：\n是linux下的用于发送和接收二层(mac层)的套接字：\n<!-- more -->\n### PF_PACKET基本使用：\n+ 基本的几个操作：  \n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <linux/if.h>\n#include <sys/ioctl.h>\n#include <linux/if_packet.h>\n#include <linux/if_ether.h>```\n\n```cpp\n//获取硬件网卡的相应信息\nvoid GetEthInfor(char *name ,  char *MAC_addr , struct in_addr * IP_addr)//传入接口名，取回mac和ip\n{\n   struct ifreq  eth;  //结构用于存放最初获取的接口信息\n   //该结构存放在：/net/if.h,详细字段表示在头文件中\n   int fd;             //用于创建套接字\n   int temp=0;         //用于验证接口调用\n   int i=0;            //用于循环\n   strncpy(eth.ifr_name,name,sizeof(struct ifreq)-1);\n  // fd = socket(AF_INET,SOCK_DGRAM,0);\n  // fd=socket(AF_INET,SOCK_STREAM,0); \n    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));\n    if(fd<0)\n    {\n       printf(\"socket failed!\\n\");\n       exit(1);\n    }\n        //获取并且保存和打印指定的物理接口MAC地址信息\n     temp = ioctl(fd,SIOCGIFHWADDR,&eth);\n     if(temp<0)\n     {\n        printf(\"ioctl--get hardware addr failed!\\n\");\n        exit(1);\n     }\n      strncpy(MAC_addr,eth.ifr_hwaddr.sa_data,6);\n      printf(\"The MAC_addr is:\");\n      for(i =0 ;i<6;i++)\n          printf(\"%4X\",(unsigned char)eth.ifr_hwaddr.sa_data[i]); \n      printf(\"\\n\");\n       \n        //获取并且保存和打印指定的物理接口IP地址信息\n      temp = ioctl(fd,SIOCGIFADDR,&eth);\n      if(temp<0)\n      {\n         printf(\"ioctl--get hardware addr failed!\\n\");\n         exit(1);\n      }\n      memcpy(IP_addr ,&(((struct sockaddr_in *)(&eth.ifr_addr))->sin_addr),4);\n      //关闭套接口\n      printf(\"got ipaddr:%s\\n\",inet_ntoa(*IP_addr)); \n      close(fd);\n}\n//取得网络接口的索引：int值,传入fd和接口名\nint Get_IfaceIndex(int fd, const char* interfaceName)\n{\nstruct ifreq ifr;\nif (interfaceName == NULL)\n{\n   return -1;\n}\nmemset(&ifr, 0, sizeof(ifr));\nstrcpy(ifr.ifr_name, interfaceName);\nif (ioctl(fd, SIOCGIFINDEX, &ifr) == -1)\n{\n   printf(\"RED ioctl error\\n\");\n   return -1;\n}\nreturn ifr.ifr_ifindex;\n}\nint set_Iface_promisc(int fd, int dev_id)//传入fd和index\n{\nstruct packet_mreq mr;\nmemset(&mr,0,sizeof(mr));\nmr.mr_ifindex = dev_id;\nmr.mr_type = PACKET_MR_PROMISC;\nif(setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&mr,sizeof(mr))==-1)//退出混杂模式使用这个：PACKET_DROP_MEMBERSHIP\n{\n   fprintf(stderr,\"GREEN set promisc failed! \\n\");\n   return -1;\n}\nreturn 0;\n}```\n使用\n```cpp\nint main ()\n{\n\t unsigned char MAC_ADDR[6];\n     struct in_addr IP_ADDR;//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.\n\t //第一步：获取指定网卡的信息（MAC地址和IP地址）\n    GetEthInfor(\"wlp2s0\",MAC_ADDR,&IP_ADDR);\n    int fd;\n     fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP));\n    int index=Get_IfaceIndex(fd,\"enp1s0\");\n    printf(\"index:%d\\n\",index);\n    return 0;\n   }\n```\n\n### PF_PACKET的接收：\n简单说明：  \n创建套结字的时候，有以下的组合：更多见：man packet\n * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.\n * 第二个参数： 套接字类型：\n          SOCK_DGRAM----以太网头已经构造好了\n          SOCK_RAW------自己构造以太头 \n          * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字\n          * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），\n          * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，\n          * 而发送时也无须用户添加头部字段。\n + 第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP\n   * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：  \n   1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)\n  和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)  \n  2)  IEEE维护的注册以太网类型列表  \n  3）半官方的列表由IANA维护  \n      ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。\n      0x88b5和0x88b6是保留以太网类型，供实验或私人使用。   \n(若指定socket_type为SOCK_RAW则意味着原始数据包包含了链路层头部，若指定为SOCK_DGRAM则将做一些处理以剥掉链路层头部。链路层头部信息的通用格式是一个sockaddr_ll结构。protocol填入网络字节序的IEEE 802.3协议号。参见<linux/if_ether.h>头文件了解允许的协议。如果protocol被设置为htons(ETH_P_ALL)，则意味着接受所有协议。所有接入的协议类型为protocol的数据包将在传递给内核之前传递到PACKET套接字。)\n+ 收包可以使用的接口：\n```cpp\n  int readnum = recvfrom(rawsock, buffer,2048,0, (struct sockaddr*)(&eth_info),&leneth_info);\n  int readnum = read(rawsock, buffer,2048);\n  int readnum = recvfrom(rawsock, buffer,2048,0, NULL,NULL);```\n        \n+ 一个简单的接收包的例子：\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <stdlib.h>\n#include <linux/if_packet.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <linux/if.h>\n#include <sys/ioctl.h>\n#include <linux/if_packet.h>\n#include <linux/if_ether.h>\n#define BUFFER_MAX 2048```\n\n```c\nint main(int argc, char *argv[])\n{\n if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) < 0)\n   {\n        printf(\"error: create raw socket!!!\\n\");\n        exit(0);\n    }\n  while(1)\n   {\n        int readnum = read(rawsock, buffer,2048);// can read packet\n        //printf(\"recv buffer:%s\\n\",buffer);\n    }\n    return 0;\n   }```\n  \n+ 指定从某个接口接收数据：\n```c\nint main(int argc, char *argv[])\n{\n struct sockaddr_ll eth_info;//结构体的定义在/linux/if_packet.h中， 表示设备无关的物理层地址结构\n  eth_info.sll_family = PF_PACKET;  //PF_PACKET定义在sys/types.h中\n  eth_info.sll_ifindex = if_nametoindex(\"lo\");//返回输入的接口名称的索引值　　//次函数定义在net/if.h中\n if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) < 0)\n   {\n        printf(\"error: create raw socket!!!\\n\");\n        exit(0);\n    }\n if(bind(rawsock,(struct sockaddr *)(&eth_info),sizeof(eth_info))==-1)//绑定接口，从而只接收那个接口上的数据\n{\n       printf(\"error: bind!!\\n\");\n        exit(0);\n}\n  while(1)\n   {\n        int readnum = read(rawsock, buffer,2048);// can read packet\n        //printf(\"recv buffer:%s\\n\",buffer);\n    }\n    return 0;\n   }```\n  \n+ 接收后的包如何读取：以包括mac头的形式来看：粗暴的形式\n```c\nint main(int argc, char *argv[])\n{\n    int rawsock;\n    char buffer[BUFFER_MAX];\n    char *ethhead;\n    char *iphead;\n    char *tcphead;\n    char *udphead;\n    char *icmphead;\n    char *pHead;\n if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) < 0)\n   {\n        printf(\"error: create raw socket!!!\\n\");\n        exit(0);\n    }\n  while(1)\n   {\n        int readnum = read(rawsock, buffer,2048);// can read packet\n        //printf(\"recv buffer:%s\\n\",buffer);\n         if(readnum < 42)\n        {\n            printf(\"error: Header is incomplete!!!\\n\");\n            continue;\n        }\n      //  for(j;j<readnum;j++)\n      //     printf(\"%.2X:\",buffer[j]&0xFF);\n        ethhead = (char *)buffer;\n        pHead = ethhead;\n        int ethernetmask = 0XFF;\n        framecount++;\n        printf(\"------------------Analysis   Packet [%d]---------------------\\n\",framecount);\n       // printf(\"all:-----%s\\n\",ethhead);\n        printf(\"MAC:\");\n        \n        int i = 6;\n        for(; i <=11; i++)\n        {\n            printf(\"%.2X:\",pHead[i]&ethernetmask);\n        }\n        printf(\"---->\");\n        for(i = 0; i <=5; i++)\n        {\n            printf(\"%.2X:\",pHead[i]&ethernetmask);\n        }\n        printf(\"\\n\");\n        printf(\"proto: %.2x:\",pHead[12]&ethernetmask);\n        printf(\"proto2: %.2x:\\n\",pHead[13]&ethernetmask);        \n        iphead = ethhead + 14;\n        pHead = iphead + 14;\n        printf(\"IP:\");\n        for(i = 0; i <=3; i++)\n        {\n            printf(\"%d\",pHead[i]&ethernetmask);\n            if(i != 3)\n            printf(\".\");\n        }\n        printf(\"---->\");\n        for(i = 10; i <=13; i++)\n        {\n            printf(\"%d\",pHead[i]&ethernetmask);\n            if(i != 13)\n            printf(\".\");\n        }\n        printf(\"\\n\");\n        int prototype = (iphead + 9)[0];\n     //   printf(\"Protocol: %.2X:\",prototype);\n        //int prototype = (iphead + 9)[0];\n        pHead = iphead + 20;\n        printf(\"Protocol: \");\n        switch(prototype)\n        {\n            case IPPROTO_ICMP:\n                printf(\"ICMP\\n\");\n                break;\n            case IPPROTO_IGMP:\n                printf(\"IGMP\\n\");\n                break;\n            case IPPROTO_IPIP:\n                printf(\"IP\\n\");\n                break;\n            case IPPROTO_TCP :\n                printf(\"TCP | source port: %u | \",(pHead[0]<<8)&0XFF00 | pHead[1]&0XFF);\n                printf(\"dest port: %u\\n\", (pHead[2]<<8)&0XFF00 | pHead[3]&0XFF);\n                break;\n            case IPPROTO_UDP :\n                printf(\"UDP | source port: %u | \",(pHead[0]<<8)&0XFF00 | pHead[1]&0XFF);\n                printf(\"dest port: %u\\n\", (pHead[2]<<8)&0XFF00 | pHead[3]&0XFF);\n                break;\n            case IPPROTO_RAW :\n                printf(\"RAW\\n\");\n                break;\n            default:\n                printf(\"Unkown\\n\");\n        }\n      printf(\"-------------------------end-----------------------\\n\");\n    }\n    return 0;\n   }```\n收包处理的方式，也可以把指针赋给内核的结构：struct iphdr\n如：   \n```cpp\n struct iphdr ip;\n ip = (struct iphdr *)(buffer + sizeof(struct ethhdr));\n ```\n内核提供了很多的包结构，在发包或者收包的时候可以直接使用这些结构解析或者粗暴的用字符串解析\n\n### PF_PACKET发送包： \n+ 发包和接收包类似：  \n```cpp\nnum = sendto(rawsock, buffer,2048 , 0 ,(struct sockaddr*)(&eth_info),sizeof(eth_info));\n if(num<0)\n {\n  printf(\"sendto failed!\\n\");\n  exit(1);\n }\n printf(\"success:%d\\n\",num);```","slug":"tcpip-PF-PACKET","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7rv00442ujxhah6voej","content":"<img src=\"/2018/05/27/tcpip-PF-PACKET/pf_packet.jpg\" title=\"it just picture\">\n<h3 id=\"PF-PACKET的使用：\"><a href=\"#PF-PACKET的使用：\" class=\"headerlink\" title=\"PF_PACKET的使用：\"></a>PF_PACKET的使用：</h3><h3 id=\"PF-PACKET简介：\"><a href=\"#PF-PACKET简介：\" class=\"headerlink\" title=\"PF_PACKET简介：\"></a>PF_PACKET简介：</h3><p>是linux下的用于发送和接收二层(mac层)的套接字：<br><a id=\"more\"></a></p>\n<h3 id=\"PF-PACKET基本使用：\"><a href=\"#PF-PACKET基本使用：\" class=\"headerlink\" title=\"PF_PACKET基本使用：\"></a>PF_PACKET基本使用：</h3><ul>\n<li>基本的几个操作：  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ioctl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_packet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取硬件网卡的相应信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetEthInfor</span><span class=\"params\">(<span class=\"keyword\">char</span> *name ,  <span class=\"keyword\">char</span> *MAC_addr , struct in_addr * IP_addr)</span><span class=\"comment\">//传入接口名，取回mac和ip</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ifreq</span>  <span class=\"title\">eth</span>;</span>  <span class=\"comment\">//结构用于存放最初获取的接口信息</span></span><br><span class=\"line\">   <span class=\"comment\">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> fd;             <span class=\"comment\">//用于创建套接字</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;         <span class=\"comment\">//用于验证接口调用</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;            <span class=\"comment\">//用于循环</span></span><br><span class=\"line\">   <span class=\"built_in\">strncpy</span>(eth.ifr_name,name,<span class=\"keyword\">sizeof</span>(struct ifreq)<span class=\"number\">-1</span>);</span><br><span class=\"line\">  <span class=\"comment\">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class=\"line\">  <span class=\"comment\">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class=\"line\">    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fd&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"socket failed!\\n\"</span>);</span><br><span class=\"line\">       <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class=\"line\">     temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(temp&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"ioctl--get hardware addr failed!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">      <span class=\"built_in\">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class=\"number\">6</span>);</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"The MAC_addr is:\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(i =<span class=\"number\">0</span> ;i&lt;<span class=\"number\">6</span>;i++)</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4X\"</span>,(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"comment\">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class=\"line\">      temp = ioctl(fd,SIOCGIFADDR,&amp;eth);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(temp&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(<span class=\"string\">\"ioctl--get hardware addr failed!\\n\"</span>);</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">memcpy</span>(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class=\"number\">4</span>);</span><br><span class=\"line\">      <span class=\"comment\">//关闭套接口</span></span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"got ipaddr:%s\\n\"</span>,inet_ntoa(*IP_addr)); </span><br><span class=\"line\">      close(fd);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//取得网络接口的索引：int值,传入fd和接口名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Get_IfaceIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* interfaceName)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ifreq</span> <span class=\"title\">ifr</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (interfaceName == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(&amp;ifr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(ifr));</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(ifr.ifr_name, interfaceName);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (ioctl(fd, SIOCGIFINDEX, &amp;ifr) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"RED ioctl error\\n\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ifr.ifr_ifindex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">set_Iface_promisc</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> dev_id)</span><span class=\"comment\">//传入fd和index</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">packet_mreq</span> <span class=\"title\">mr</span>;</span></span><br><span class=\"line\"><span class=\"built_in\">memset</span>(&amp;mr,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(mr));</span><br><span class=\"line\">mr.mr_ifindex = dev_id;</span><br><span class=\"line\">mr.mr_type = PACKET_MR_PROMISC;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&amp;mr,<span class=\"keyword\">sizeof</span>(mr))==<span class=\"number\">-1</span>)<span class=\"comment\">//退出混杂模式使用这个：PACKET_DROP_MEMBERSHIP</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>,<span class=\"string\">\"GREEN set promisc failed! \\n\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> MAC_ADDR[<span class=\"number\">6</span>];</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">in_addr</span> <span class=\"title\">IP_ADDR</span>;</span><span class=\"comment\">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class=\"line\">\t <span class=\"comment\">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class=\"line\">    GetEthInfor(<span class=\"string\">\"wlp2s0\"</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">     fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index=Get_IfaceIndex(fd,<span class=\"string\">\"enp1s0\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"index:%d\\n\"</span>,index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"PF-PACKET的接收：\"><a href=\"#PF-PACKET的接收：\" class=\"headerlink\" title=\"PF_PACKET的接收：\"></a>PF_PACKET的接收：</h3><p>简单说明：<br>创建套结字的时候，有以下的组合：更多见：man packet</p>\n<ul>\n<li>利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</li>\n<li>第二个参数： 套接字类型：<pre><code>SOCK_DGRAM----以太网头已经构造好了\nSOCK_RAW------自己构造以太头 \n* 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字\n* 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），\n* 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，\n* 而发送时也无须用户添加头部字段。\n</code></pre></li>\n</ul>\n<ul>\n<li>第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP<ul>\n<li>以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：<br>1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)<br>和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)<br>2)  IEEE维护的注册以太网类型列表<br>3）半官方的列表由IANA维护<br> ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。<br> 0x88b5和0x88b6是保留以太网类型，供实验或私人使用。<br>(若指定socket_type为SOCK_RAW则意味着原始数据包包含了链路层头部，若指定为SOCK_DGRAM则将做一些处理以剥掉链路层头部。链路层头部信息的通用格式是一个sockaddr_ll结构。protocol填入网络字节序的IEEE 802.3协议号。参见&lt;linux/if_ether.h&gt;头文件了解允许的协议。如果protocol被设置为htons(ETH_P_ALL)，则意味着接受所有协议。所有接入的协议类型为protocol的数据包将在传递给内核之前传递到PACKET套接字。)</li>\n</ul>\n<ul>\n<li>收包可以使用的接口：<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> readnum = recvfrom(rawsock, buffer,<span class=\"number\">2048</span>,<span class=\"number\">0</span>, (struct sockaddr*)(&amp;eth_info),&amp;leneth_info);</span><br><span class=\"line\"><span class=\"keyword\">int</span> readnum = read(rawsock, buffer,<span class=\"number\">2048</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> readnum = recvfrom(rawsock, buffer,<span class=\"number\">2048</span>,<span class=\"number\">0</span>, <span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>一个简单的接收包的例子：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_ether.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_packet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ioctl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_packet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_ether.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFFER_MAX 2048</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"error: create raw socket!!!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> readnum = read(rawsock, buffer,<span class=\"number\">2048</span>);<span class=\"comment\">// can read packet</span></span><br><span class=\"line\">        <span class=\"comment\">//printf(\"recv buffer:%s\\n\",buffer);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>指定从某个接口接收数据：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_ll</span> <span class=\"title\">eth_info</span>;</span><span class=\"comment\">//结构体的定义在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class=\"line\">  eth_info.sll_family = PF_PACKET;  <span class=\"comment\">//PF_PACKET定义在sys/types.h中</span></span><br><span class=\"line\">  eth_info.sll_ifindex = if_nametoindex(<span class=\"string\">\"lo\"</span>);<span class=\"comment\">//返回输入的接口名称的索引值　　//次函数定义在net/if.h中</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"error: create raw socket!!!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(bind(rawsock,(struct sockaddr *)(&amp;eth_info),<span class=\"keyword\">sizeof</span>(eth_info))==<span class=\"number\">-1</span>)<span class=\"comment\">//绑定接口，从而只接收那个接口上的数据</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"error: bind!!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> readnum = read(rawsock, buffer,<span class=\"number\">2048</span>);<span class=\"comment\">// can read packet</span></span><br><span class=\"line\">        <span class=\"comment\">//printf(\"recv buffer:%s\\n\",buffer);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>接收后的包如何读取：以包括mac头的形式来看：粗暴的形式<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rawsock;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[BUFFER_MAX];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ethhead;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *iphead;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *tcphead;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *udphead;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *icmphead;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *pHead;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"error: create raw socket!!!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> readnum = read(rawsock, buffer,<span class=\"number\">2048</span>);<span class=\"comment\">// can read packet</span></span><br><span class=\"line\">        <span class=\"comment\">//printf(\"recv buffer:%s\\n\",buffer);</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span>(readnum &lt; <span class=\"number\">42</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"error: Header is incomplete!!!\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">//  for(j;j&lt;readnum;j++)</span></span><br><span class=\"line\">      <span class=\"comment\">//     printf(\"%.2X:\",buffer[j]&amp;0xFF);</span></span><br><span class=\"line\">        ethhead = (<span class=\"keyword\">char</span> *)buffer;</span><br><span class=\"line\">        pHead = ethhead;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ethernetmask = <span class=\"number\">0XFF</span>;</span><br><span class=\"line\">        framecount++;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"------------------Analysis   Packet [%d]---------------------\\n\"</span>,framecount);</span><br><span class=\"line\">       <span class=\"comment\">// printf(\"all:-----%s\\n\",ethhead);</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"MAC:\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">6</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; i &lt;=<span class=\"number\">11</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.2X:\"</span>,pHead[i]&amp;ethernetmask);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"----&gt;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt;=<span class=\"number\">5</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.2X:\"</span>,pHead[i]&amp;ethernetmask);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"proto: %.2x:\"</span>,pHead[<span class=\"number\">12</span>]&amp;ethernetmask);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"proto2: %.2x:\\n\"</span>,pHead[<span class=\"number\">13</span>]&amp;ethernetmask);        </span><br><span class=\"line\">        iphead = ethhead + <span class=\"number\">14</span>;</span><br><span class=\"line\">        pHead = iphead + <span class=\"number\">14</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"IP:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt;=<span class=\"number\">3</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,pHead[i]&amp;ethernetmask);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i != <span class=\"number\">3</span>)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"----&gt;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">10</span>; i &lt;=<span class=\"number\">13</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,pHead[i]&amp;ethernetmask);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i != <span class=\"number\">13</span>)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> prototype = (iphead + <span class=\"number\">9</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">     <span class=\"comment\">//   printf(\"Protocol: %.2X:\",prototype);</span></span><br><span class=\"line\">        <span class=\"comment\">//int prototype = (iphead + 9)[0];</span></span><br><span class=\"line\">        pHead = iphead + <span class=\"number\">20</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Protocol: \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(prototype)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IPPROTO_ICMP:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"ICMP\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IPPROTO_IGMP:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"IGMP\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IPPROTO_IPIP:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"IP\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IPPROTO_TCP :</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"TCP | source port: %u | \"</span>,(pHead[<span class=\"number\">0</span>]&lt;&lt;<span class=\"number\">8</span>)&amp;<span class=\"number\">0XFF00</span> | pHead[<span class=\"number\">1</span>]&amp;<span class=\"number\">0XFF</span>);</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"dest port: %u\\n\"</span>, (pHead[<span class=\"number\">2</span>]&lt;&lt;<span class=\"number\">8</span>)&amp;<span class=\"number\">0XFF00</span> | pHead[<span class=\"number\">3</span>]&amp;<span class=\"number\">0XFF</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IPPROTO_UDP :</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"UDP | source port: %u | \"</span>,(pHead[<span class=\"number\">0</span>]&lt;&lt;<span class=\"number\">8</span>)&amp;<span class=\"number\">0XFF00</span> | pHead[<span class=\"number\">1</span>]&amp;<span class=\"number\">0XFF</span>);</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"dest port: %u\\n\"</span>, (pHead[<span class=\"number\">2</span>]&lt;&lt;<span class=\"number\">8</span>)&amp;<span class=\"number\">0XFF00</span> | pHead[<span class=\"number\">3</span>]&amp;<span class=\"number\">0XFF</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IPPROTO_RAW :</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"RAW\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"Unkown\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"-------------------------end-----------------------\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>收包处理的方式，也可以把指针赋给内核的结构：struct iphdr<br>如：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iphdr</span> <span class=\"title\">ip</span>;</span></span><br><span class=\"line\">ip = (struct iphdr *)(buffer + <span class=\"keyword\">sizeof</span>(struct ethhdr));</span><br></pre></td></tr></table></figure></p>\n<p>内核提供了很多的包结构，在发包或者收包的时候可以直接使用这些结构解析或者粗暴的用字符串解析</p>\n<h3 id=\"PF-PACKET发送包：\"><a href=\"#PF-PACKET发送包：\" class=\"headerlink\" title=\"PF_PACKET发送包：\"></a>PF_PACKET发送包：</h3><ul>\n<li>发包和接收包类似：  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num = sendto(rawsock, buffer,<span class=\"number\">2048</span> , <span class=\"number\">0</span> ,(struct sockaddr*)(&amp;eth_info),<span class=\"keyword\">sizeof</span>(eth_info));</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(num&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"sendto failed!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"success:%d\\n\"</span>,num);</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<img src=\"/2018/05/27/tcpip-PF-PACKET/pf_packet.jpg\" title=\"it just picture\">\n<h3 id=\"PF-PACKET的使用：\"><a href=\"#PF-PACKET的使用：\" class=\"headerlink\" title=\"PF_PACKET的使用：\"></a>PF_PACKET的使用：</h3><h3 id=\"PF-PACKET简介：\"><a href=\"#PF-PACKET简介：\" class=\"headerlink\" title=\"PF_PACKET简介：\"></a>PF_PACKET简介：</h3><p>是linux下的用于发送和接收二层(mac层)的套接字：<br>","more":"</p>\n<h3 id=\"PF-PACKET基本使用：\"><a href=\"#PF-PACKET基本使用：\" class=\"headerlink\" title=\"PF_PACKET基本使用：\"></a>PF_PACKET基本使用：</h3><ul>\n<li>基本的几个操作：  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ioctl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_packet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取硬件网卡的相应信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetEthInfor</span><span class=\"params\">(<span class=\"keyword\">char</span> *name ,  <span class=\"keyword\">char</span> *MAC_addr , struct in_addr * IP_addr)</span><span class=\"comment\">//传入接口名，取回mac和ip</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ifreq</span>  <span class=\"title\">eth</span>;</span>  <span class=\"comment\">//结构用于存放最初获取的接口信息</span></span><br><span class=\"line\">   <span class=\"comment\">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> fd;             <span class=\"comment\">//用于创建套接字</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;         <span class=\"comment\">//用于验证接口调用</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;            <span class=\"comment\">//用于循环</span></span><br><span class=\"line\">   <span class=\"built_in\">strncpy</span>(eth.ifr_name,name,<span class=\"keyword\">sizeof</span>(struct ifreq)<span class=\"number\">-1</span>);</span><br><span class=\"line\">  <span class=\"comment\">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class=\"line\">  <span class=\"comment\">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class=\"line\">    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fd&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"socket failed!\\n\"</span>);</span><br><span class=\"line\">       <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class=\"line\">     temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(temp&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"ioctl--get hardware addr failed!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">      <span class=\"built_in\">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class=\"number\">6</span>);</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"The MAC_addr is:\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(i =<span class=\"number\">0</span> ;i&lt;<span class=\"number\">6</span>;i++)</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4X\"</span>,(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"comment\">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class=\"line\">      temp = ioctl(fd,SIOCGIFADDR,&amp;eth);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(temp&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(<span class=\"string\">\"ioctl--get hardware addr failed!\\n\"</span>);</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">memcpy</span>(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class=\"number\">4</span>);</span><br><span class=\"line\">      <span class=\"comment\">//关闭套接口</span></span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"got ipaddr:%s\\n\"</span>,inet_ntoa(*IP_addr)); </span><br><span class=\"line\">      close(fd);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//取得网络接口的索引：int值,传入fd和接口名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Get_IfaceIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* interfaceName)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ifreq</span> <span class=\"title\">ifr</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (interfaceName == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(&amp;ifr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(ifr));</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(ifr.ifr_name, interfaceName);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (ioctl(fd, SIOCGIFINDEX, &amp;ifr) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"RED ioctl error\\n\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ifr.ifr_ifindex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">set_Iface_promisc</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> dev_id)</span><span class=\"comment\">//传入fd和index</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">packet_mreq</span> <span class=\"title\">mr</span>;</span></span><br><span class=\"line\"><span class=\"built_in\">memset</span>(&amp;mr,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(mr));</span><br><span class=\"line\">mr.mr_ifindex = dev_id;</span><br><span class=\"line\">mr.mr_type = PACKET_MR_PROMISC;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&amp;mr,<span class=\"keyword\">sizeof</span>(mr))==<span class=\"number\">-1</span>)<span class=\"comment\">//退出混杂模式使用这个：PACKET_DROP_MEMBERSHIP</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>,<span class=\"string\">\"GREEN set promisc failed! \\n\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> MAC_ADDR[<span class=\"number\">6</span>];</span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">in_addr</span> <span class=\"title\">IP_ADDR</span>;</span><span class=\"comment\">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class=\"line\">\t <span class=\"comment\">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class=\"line\">    GetEthInfor(<span class=\"string\">\"wlp2s0\"</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">     fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index=Get_IfaceIndex(fd,<span class=\"string\">\"enp1s0\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"index:%d\\n\"</span>,index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"PF-PACKET的接收：\"><a href=\"#PF-PACKET的接收：\" class=\"headerlink\" title=\"PF_PACKET的接收：\"></a>PF_PACKET的接收：</h3><p>简单说明：<br>创建套结字的时候，有以下的组合：更多见：man packet</p>\n<ul>\n<li>利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</li>\n<li>第二个参数： 套接字类型：<pre><code>SOCK_DGRAM----以太网头已经构造好了\nSOCK_RAW------自己构造以太头 \n* 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字\n* 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），\n* 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，\n* 而发送时也无须用户添加头部字段。\n</code></pre></li>\n</ul>\n<ul>\n<li>第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP<ul>\n<li>以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：<br>1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)<br>和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)<br>2)  IEEE维护的注册以太网类型列表<br>3）半官方的列表由IANA维护<br> ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。<br> 0x88b5和0x88b6是保留以太网类型，供实验或私人使用。<br>(若指定socket_type为SOCK_RAW则意味着原始数据包包含了链路层头部，若指定为SOCK_DGRAM则将做一些处理以剥掉链路层头部。链路层头部信息的通用格式是一个sockaddr_ll结构。protocol填入网络字节序的IEEE 802.3协议号。参见&lt;linux/if_ether.h&gt;头文件了解允许的协议。如果protocol被设置为htons(ETH_P_ALL)，则意味着接受所有协议。所有接入的协议类型为protocol的数据包将在传递给内核之前传递到PACKET套接字。)</li>\n</ul>\n<ul>\n<li>收包可以使用的接口：<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> readnum = recvfrom(rawsock, buffer,<span class=\"number\">2048</span>,<span class=\"number\">0</span>, (struct sockaddr*)(&amp;eth_info),&amp;leneth_info);</span><br><span class=\"line\"><span class=\"keyword\">int</span> readnum = read(rawsock, buffer,<span class=\"number\">2048</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> readnum = recvfrom(rawsock, buffer,<span class=\"number\">2048</span>,<span class=\"number\">0</span>, <span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>一个简单的接收包的例子：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_ether.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_packet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ioctl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_packet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;linux/if_ether.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFFER_MAX 2048</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"error: create raw socket!!!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> readnum = read(rawsock, buffer,<span class=\"number\">2048</span>);<span class=\"comment\">// can read packet</span></span><br><span class=\"line\">        <span class=\"comment\">//printf(\"recv buffer:%s\\n\",buffer);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>指定从某个接口接收数据：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_ll</span> <span class=\"title\">eth_info</span>;</span><span class=\"comment\">//结构体的定义在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class=\"line\">  eth_info.sll_family = PF_PACKET;  <span class=\"comment\">//PF_PACKET定义在sys/types.h中</span></span><br><span class=\"line\">  eth_info.sll_ifindex = if_nametoindex(<span class=\"string\">\"lo\"</span>);<span class=\"comment\">//返回输入的接口名称的索引值　　//次函数定义在net/if.h中</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"error: create raw socket!!!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(bind(rawsock,(struct sockaddr *)(&amp;eth_info),<span class=\"keyword\">sizeof</span>(eth_info))==<span class=\"number\">-1</span>)<span class=\"comment\">//绑定接口，从而只接收那个接口上的数据</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"error: bind!!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> readnum = read(rawsock, buffer,<span class=\"number\">2048</span>);<span class=\"comment\">// can read packet</span></span><br><span class=\"line\">        <span class=\"comment\">//printf(\"recv buffer:%s\\n\",buffer);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>接收后的包如何读取：以包括mac头的形式来看：粗暴的形式<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rawsock;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[BUFFER_MAX];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ethhead;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *iphead;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *tcphead;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *udphead;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *icmphead;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *pHead;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"error: create raw socket!!!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> readnum = read(rawsock, buffer,<span class=\"number\">2048</span>);<span class=\"comment\">// can read packet</span></span><br><span class=\"line\">        <span class=\"comment\">//printf(\"recv buffer:%s\\n\",buffer);</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span>(readnum &lt; <span class=\"number\">42</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"error: Header is incomplete!!!\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">//  for(j;j&lt;readnum;j++)</span></span><br><span class=\"line\">      <span class=\"comment\">//     printf(\"%.2X:\",buffer[j]&amp;0xFF);</span></span><br><span class=\"line\">        ethhead = (<span class=\"keyword\">char</span> *)buffer;</span><br><span class=\"line\">        pHead = ethhead;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ethernetmask = <span class=\"number\">0XFF</span>;</span><br><span class=\"line\">        framecount++;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"------------------Analysis   Packet [%d]---------------------\\n\"</span>,framecount);</span><br><span class=\"line\">       <span class=\"comment\">// printf(\"all:-----%s\\n\",ethhead);</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"MAC:\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">6</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; i &lt;=<span class=\"number\">11</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.2X:\"</span>,pHead[i]&amp;ethernetmask);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"----&gt;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt;=<span class=\"number\">5</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.2X:\"</span>,pHead[i]&amp;ethernetmask);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"proto: %.2x:\"</span>,pHead[<span class=\"number\">12</span>]&amp;ethernetmask);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"proto2: %.2x:\\n\"</span>,pHead[<span class=\"number\">13</span>]&amp;ethernetmask);        </span><br><span class=\"line\">        iphead = ethhead + <span class=\"number\">14</span>;</span><br><span class=\"line\">        pHead = iphead + <span class=\"number\">14</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"IP:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt;=<span class=\"number\">3</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,pHead[i]&amp;ethernetmask);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i != <span class=\"number\">3</span>)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"----&gt;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">10</span>; i &lt;=<span class=\"number\">13</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,pHead[i]&amp;ethernetmask);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i != <span class=\"number\">13</span>)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> prototype = (iphead + <span class=\"number\">9</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">     <span class=\"comment\">//   printf(\"Protocol: %.2X:\",prototype);</span></span><br><span class=\"line\">        <span class=\"comment\">//int prototype = (iphead + 9)[0];</span></span><br><span class=\"line\">        pHead = iphead + <span class=\"number\">20</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Protocol: \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(prototype)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IPPROTO_ICMP:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"ICMP\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IPPROTO_IGMP:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"IGMP\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IPPROTO_IPIP:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"IP\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IPPROTO_TCP :</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"TCP | source port: %u | \"</span>,(pHead[<span class=\"number\">0</span>]&lt;&lt;<span class=\"number\">8</span>)&amp;<span class=\"number\">0XFF00</span> | pHead[<span class=\"number\">1</span>]&amp;<span class=\"number\">0XFF</span>);</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"dest port: %u\\n\"</span>, (pHead[<span class=\"number\">2</span>]&lt;&lt;<span class=\"number\">8</span>)&amp;<span class=\"number\">0XFF00</span> | pHead[<span class=\"number\">3</span>]&amp;<span class=\"number\">0XFF</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IPPROTO_UDP :</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"UDP | source port: %u | \"</span>,(pHead[<span class=\"number\">0</span>]&lt;&lt;<span class=\"number\">8</span>)&amp;<span class=\"number\">0XFF00</span> | pHead[<span class=\"number\">1</span>]&amp;<span class=\"number\">0XFF</span>);</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"dest port: %u\\n\"</span>, (pHead[<span class=\"number\">2</span>]&lt;&lt;<span class=\"number\">8</span>)&amp;<span class=\"number\">0XFF00</span> | pHead[<span class=\"number\">3</span>]&amp;<span class=\"number\">0XFF</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> IPPROTO_RAW :</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"RAW\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"Unkown\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"-------------------------end-----------------------\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>收包处理的方式，也可以把指针赋给内核的结构：struct iphdr<br>如：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iphdr</span> <span class=\"title\">ip</span>;</span></span><br><span class=\"line\">ip = (struct iphdr *)(buffer + <span class=\"keyword\">sizeof</span>(struct ethhdr));</span><br></pre></td></tr></table></figure></p>\n<p>内核提供了很多的包结构，在发包或者收包的时候可以直接使用这些结构解析或者粗暴的用字符串解析</p>\n<h3 id=\"PF-PACKET发送包：\"><a href=\"#PF-PACKET发送包：\" class=\"headerlink\" title=\"PF_PACKET发送包：\"></a>PF_PACKET发送包：</h3><ul>\n<li>发包和接收包类似：  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num = sendto(rawsock, buffer,<span class=\"number\">2048</span> , <span class=\"number\">0</span> ,(struct sockaddr*)(&amp;eth_info),<span class=\"keyword\">sizeof</span>(eth_info));</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(num&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"sendto failed!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"built_in\">printf</span>(<span class=\"string\">\"success:%d\\n\"</span>,num);</span><br></pre></td></tr></table></figure></li>\n</ul>"},{"title":"test_article_picture","date":"2018-05-20T07:46:24.000Z","_content":"##this is a test of picture with test again in 2019\n{% asset_img example.jpg This is an example image %}\nend\n","source":"_posts/test-article-picture.md","raw":"---\ntitle: test_article_picture\ndate: 2018-05-20 15:46:24\ntags: test\n---\n##this is a test of picture with test again in 2019\n{% asset_img example.jpg This is an example image %}\nend\n","slug":"test-article-picture","published":1,"updated":"2020-03-21T07:30:55.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7ry00472ujx16lrk3f7","content":"<p>##this is a test of picture with test again in 2019<br><img src=\"/2018/05/20/test-article-picture/example.jpg\" title=\"This is an example image\"><br>end</p>\n","site":{"data":{}},"excerpt":"","more":"<p>##this is a test of picture with test again in 2019<br><img src=\"/2018/05/20/test-article-picture/example.jpg\" title=\"This is an example image\"><br>end</p>\n"},{"title":"我理解的心理模型","date":"2020-04-03T21:44:04.000Z","_content":"\n以下内容均为本人构想理解提出，如有雷同纯属巧合，仅为本人粗略观点，不期赞同；\n\n### 一、模型概念\n\n#### 1）模型的广义解释\n\n模型用于抽象化一类事物的特点和规律，甚至是发展周期；模型常见有数学模型，物理模型，工业模型等等；<!--more-->\n如数学模型，是用来处理一类问题，通过输入，模型处理，得到想要的预测输出，模型常用来预测和计算问题的结果和答案；逼近结果甚至计算出结果本身；最简单如: 1天卖10斤菜，预测10天卖多少斤这种简单问题，则模型就是10*天数；输入就是天数，输出就是卖了多少斤；复杂一点可以加上条件，阴天卖多少斤，晴天卖多少斤，阴天有几天，或者甚至让你预测天气等等；\n\n#### 2）复杂的模型\n\n用于解释数学的模型，还可以用来解释更多内容，并归结升级到当下流行的人工智能中的机器学习模型和深度学习等等；这些大部分也是通过输入和模型获得输出；而模型的建立将是一个很复杂繁琐的过程；模型的正确性也是个重要因素；\n\n### 二、心理模型\n\n#### 1）起源\n\nPS: 博主其实从初中就开始关注心理学，不过没有深入了解；最初想探寻人的心理模型，是在博主遇到19年创伤事件后，不明白心理为什么会出现如此变化；且还没有去借助外在心理学知识来解释，尝试自己去理解时，总结出来的；\n\n##### （1）动物行为基本分析：\n\n​       动物通过感知周围的环境刺激如食物，猎食者等，和自身的内在刺激如饥饿等，输入，进入到自己的简单模型，处理后进行反应即输出，比如见到猎食者，输入刺激，模型处理的结果是要逃跑，于是反应为逃跑等等；而动物的几乎一切的行为活动，贯穿一生，都是这样度过的；所以动物的本质，是个输入输出模型；从这个角度理解的话。\n\n##### （2）人类\n\n​       人类其实也是动物，只是因为人类有高级的模型，所以能使得有控制输入输出，以及控制模型的能力；但因为基因和自身的认知等影响，导致不同的人对这些控制能力不同，就算是最强的人，对这些控制也不是100%的；\n\n​        人的模型很复杂，人需要适应多变的环境，并安稳的生存下来，需要得到更多的信息，来应对种种危险等等；所以人类进化出了各种感官器，处理器如最强的大脑；内在神经感受器等等；\n\n#### 2）模型基本框架\n\n人的心理模型在：\n\n外界的输入-->人对应的感受器-->进入处理器模型-->决策后输出；\n\n以下是处理器模型，优先从第一层传递到第五层；\n\n```\n第五层:---------自我意识：理性思考(一般有多个)------------\n第四层:-------受限的自我意识：感受----------------------\n第三层：------受约束的自我意识：道德，法律-----------------\n第二层：------潜意识，习惯-----------------------------\n第一层：------身体，物理感受和直接处理------------------\n```\n\n身体：比如膝跳反应等；\n\n潜意识习惯：比如交流中的口头禅等；\n\n其他类似；总是先经过第一层，第一层处理不了或者不需要则往上传递；严格来说也不是层级关系，是一种分类的处理；\n\n输入输出方式：\n\n可以分为两种：\n\n1、接收输入，处理(处理包括思维层面，感受等等)，表现出来输出(可能是行为或者单纯的感受并会存储记忆，内反馈形成下次处理同类型问题的经验或者进步)；\n\n2、进行输出(可能之前得到输入或单纯想输出)，得到输入，处理，感受；\n\n#### 3）人心理模型的基本组成分析\n\n##### （1） 组成：输入源，感受器，处理器，输出器\n\n##### （2）各个组成分析：\n\n######     A 输入源：\n\n​    一个是外部输入源，对应于第一种方式：输入->处理->输出的方式：很多，几乎是无限的，而感受器却只有有限种类型，而为了缔结输入源，感受器和输出等的联系，所建立的缔结关系，也是无限的；即体现为知识，能力等等；输入源举例：不同的食物，不同的感受刺激如漂亮的花朵等等；深层的如赞美的话，得到礼物等等，其他人也是一种输入源；\n\n​     一个是内部的输入源：对应于第二种方式：输出->输入->处理的方式：很多，推理，瞎想，想象，创作等等；甚至简单如思考后的说话等等；\n\n######    B 感受器：\n\n   感受器目前我了解到的有：\n\n外在实体：触觉，嗅觉，味觉，听觉，视觉，痛觉，温觉；\n\n######   C 处理器：\n\n 见上图；最低层次为身体，这个和动物也类似，即本能，人会本能的躲避危险，碰到烫的东西会自动收回；这些是不经过大脑的；\n\n接着是潜意识和习惯等，大部分没有被大脑意识到；这个层面反应很快；类似口头禅，可以理解为一个map,针对某个输入，有确定的输出；所以往往直接表现出来；\n\n接着是感受和道德层面：某个事物让自己感受到开心或伤心，可能还来不及去考虑，就直接反应，而道德法律也是，即自己的底线；这种一般不用思考；这个其实也是意识层面，只是是较浅的意识；当然有些人是感受强势些，有些人是理性意识强势些；\n\n意识层面：即在感受和道德无法做决定时，则到了意识层面，经过处理后得到反应；而这个层面的思考，取决于人的认知，学识，智慧，即智商，情商等等；更多的是：涉及计算，规律，预测，分析问题本质，多因素考虑等等；\n\n######   D 输出器\n\n​    内在感受：快乐感受器，悲伤感受器，愤怒感受器，害怕感受器等自尊感受器，安全感受器，归属感，等等；基本感受表现器，这个和输入其实息息相关；只有很少的处理过程；比如快乐往往很简单；不用经过太多的思考；偏向于对应于输入输出方式\n\n输出方式也有：行为，选择决策，语言等等；\n\n#### 4）人类模型的复杂度分析\n\n(1)  人的感受器丰富，不仅有外在感受器如：视觉，听觉，触觉，嗅觉，味觉，还有如痛觉等内在感受器，甚至高级的自尊感，安全感，归属感等等一些进化的非显性但是实际存在的感觉器；（这些感受器大多是因为社交体系，和他人的情感体系环境下产生的，和等级等观念也相关）\n\n(2)  人的感受器特性：感受器有个特点，对初次刺激记忆最深，敏感度最高，对之后的相同刺激习惯了，就显得表现的不是很强烈，可能是因为进化的原因，第一次不知道是不是危险，所以显得最警惕，之后熟悉了便失去了焦点；所以才会有腻了，味觉疲劳等现象；而对于隔了很久的没有的刺激，再次刺激也会有比较大的反应，这个也是很容易理解的；也就是边际递减效应；\n\n(3)  外界输入类型的多样性，有些输入是人类自身创造的；而这个太多了；比如游戏；\n\n(4)  人的处理器复杂度高：正常处理：输入到达身体层面能处理则不会传递上去：如人碰到烫的东西自动收回等等；若能传递，则到潜意识，接着到意识进行逻辑等处理，而意识层面的处理是最复杂的；\n\n(5)  人的感受器对应的是输入，而人的一部分感受器可以作为输出，而输出同样也是复杂，不同类型的人不同环境下等等输出的效果可能类似，但是输出方式不同；\n\n### 三、详解输入源等\n\n输入源分为外部输入源和内部输入源：当你的输入源能量大，形成一个能量场，别人也会被你吸引，到你的能量场，于是你可能成为别人眼中的有趣的人；而最好这些不要太过依赖外部能量的提供；生活的品质和热爱表现于此；\n\n1） 外部输入源：\n\n划分方式1：根据特性划分\n\n人或其他活物：亲人朋友爱人，崇拜对象，宠物等等，这种可以提供长期的源，和刺激；\n\n一次性物：食物，视频等等\n\n游戏/竞技/运动：同时刺激多个感官，而且高反馈即时反馈的特性让人享受其中；\n\n…\n\n划分方式2：根据归属划分：\n\n现实物理世界日常活动：\n\n吃-食物和怎样获取食物：自己下厨，外卖刷剧，堂食探索，各种体验不同；\n\n穿-衣服化妆护肤等颜值相关，保暖舒适好看漂亮气质吸引别人等等；\n\n住-居家环境宜家家居：居住环境构成和特点：干净整洁安全安静床舒适度气味等等；\n\n行-交通工具：汽车高铁公交飞机走路自行车跑步平衡车轮滑等不同体验；空间方位认路等体验；”\n\n健康-健身等；喝茶泡脚吃等等，\n\n纯玩：打球游戏等等；\n\n工作-知识技能解决问题需求，\n\n社交-人\n\n网络世界：游戏，视频媒体，文字信息，虚拟化，创作编程等，社交购物等和现实挂钩的，统称信息；而媒介可以是手机，平板，电脑，手表，智能硬件等等；\n\n \n\n2） 内部输入源：\n\n内心世界：\n\n关系情感：友情爱情亲情等；\n\n欲望：性，贪，懒\n\n自尊自信等需求；\n\n### 四、心理模型的影响因素和发展周期\n\n1)   模型的影响因素：基因，家庭环境，学校环境，社会环境；环境包括人；\n\n2)   模型的变化特性：人格，气质，性格，等是不容易变化的，可以理解为硬编码，强缔结；而意识层面涉及情商，智商等认知是容易改变的，而道德，感受涉及三观等等，也是能改变的，不过比意识层面更难；\n\n3)   模型的发展周期：\n\n人诞生时，是婴儿时期，此时还未被环境影响，各个感受器处于初始状态；模型原始由基因决定；婴儿期性本善，性本偏外向\n\n孩童时期：在接受家庭环境影响，父母等影响后，感受器特质发生改变，此时比如接收到的某种刺激较少，比如爱，则缺爱，则长大后，第一次感受到爱后，会比别人表现更强烈；内向或者外向：一开始是外向的，通过输出能量，但是得到的反馈，输入进来的时候被判断为不好的感受，即负能量，则长此以往，则不愿意再去输出，形成内向的性格，即只喜欢输出到内部环境；\n\n 青少年：开始受到身体激素影响，并开始更理性的关注周围的事物，受到学校影响较大；\n\n 成年期：模型基本稳定，会轻微调整，不过受到创伤等大事会重新建立等；\n\nPS:模型的影响，包括模型的感受器，处理器和表现(输出);感受器的特质:敏感度等是能被随着发展周期改变的；\n\n学校环境：更多的是改变道德，感受和意识层面，少量的改变潜意识和习惯；\n\n### 五、用此心理模型来解释一些心理现象\n\n1） 人格：人格指一个人在一定情况下所作行为反应的特质，即人们在生活、工作中独特的行为表现，包括思考方式、决策方式等；包括了内向外向，感觉直觉，思考情感，判断知觉；\n\n内向外向：内向的人偏向于第一种方式：即输入->处理->输出；而外向的人偏向于输出->处理->输入的方式；和小时候的经历等有关；\n\n感觉直觉：获取信息的方式：是感官获取听到看到还是自己推理瞎想；模型解释：感官感觉针对第一种输入输出方式:即输入->处理->输出，而直觉：第二种：输出->输入->处理，而输入往往作为一种验证的方式；\n\n思考情感：决策方式：对应于模型中的处理器中的意识层面中哪个占主导，是感受还是理性；而这其中其实还有道德在作用；\n\n判断还是知觉：喜欢做计划还是灵活处理适应环境？做计划其实是由内而外，因为计划是偏向于自己做的，且更容易控制，而适应环境则是针对环境的输入，来做对应的输出，针对的是第一种输入输出方式，所以和内向外向有关；可能还涉及到安全感等；\n\n2） 气质：其实是一个人的输出，表现，这个多是自我的主动输出，少部分是针对输入做的输出；气质，这个词太虚：\n\n来看普世解释：气质是人的个性心理特征之一，它是指在人的认识、情感、言语、行动中，心理活动发生时力量的强弱、变化的快慢和均衡程度等稳定的动力特征。主要表现在情绪体验的快慢、强弱、表现的隐显以及动作的灵敏或迟钝方面，因而它为人的全部心理活动表现染上了一层浓厚的色彩。\n\n可以理解为感受器，表现器的特质吧；\n\n### 六、马斯洛需求解释\n\n最高层面的即价值，自我实现，创造等等，即对应了模型类别中的输出类模型，即模型本身偏向于输出源，能源源不断的给其他人(模型)提供输入，所以其他模型在感兴趣的情况下，被吸引，建立缔结，从而记得记住这个人；所以这个人的价值被体现出来；\n\n尊重需要：更深层次的内在感受器，凌驾于开心等之上，表现为舒适，满足，安全，信心等等；\n\n社会需要：亲情，爱情，友情：实际上是和某个输入源(包括方式1和2)，缔结了强烈的关系，这个源能提供源源不断的输入，好的或不好的，但是缔结的联系深深的印在脑子里了；所以一旦这个源不存在了，就体现为难受，其实这是一种上瘾；所以这种情况可以是建立一个相似的输入源不同的缔结；或者等自己适应了这种缔结的消失，而不再需要这种缔结；类似的还有和动物的情感，特殊物品的情感等等；\n\n安全需要：安全感：财产人身等安全，工作等：这个是属于内在高级的感受器：但是它可能依赖的东西并不高级，因人而异，比如在一间新房子还是旧房子里；\n\n生理需求：吃喝拉撒睡性穿住行；身体需求层面，本能，低级感受器；\n\n没有了身体，就没有大脑，所以身体的感受是最强烈的但是短暂，而越靠近上层，感觉越不强烈但是可能长远；除非，和身体的感受形成了缔结；\n\n预测行为；了解自己行动原因，深层原因，从而改变自己，完善自己，善待自己；\n\n### 七、模型和现代互联网AI\n\n模型编程和如何塑造一个你，TODO\n\n","source":"_posts/我理解的心理模型.md","raw":"---\ntitle: 我理解的心理模型\ndate: 2020-04-04 05:44:04\ntags:\ncategories: 心理\n---\n\n以下内容均为本人构想理解提出，如有雷同纯属巧合，仅为本人粗略观点，不期赞同；\n\n### 一、模型概念\n\n#### 1）模型的广义解释\n\n模型用于抽象化一类事物的特点和规律，甚至是发展周期；模型常见有数学模型，物理模型，工业模型等等；<!--more-->\n如数学模型，是用来处理一类问题，通过输入，模型处理，得到想要的预测输出，模型常用来预测和计算问题的结果和答案；逼近结果甚至计算出结果本身；最简单如: 1天卖10斤菜，预测10天卖多少斤这种简单问题，则模型就是10*天数；输入就是天数，输出就是卖了多少斤；复杂一点可以加上条件，阴天卖多少斤，晴天卖多少斤，阴天有几天，或者甚至让你预测天气等等；\n\n#### 2）复杂的模型\n\n用于解释数学的模型，还可以用来解释更多内容，并归结升级到当下流行的人工智能中的机器学习模型和深度学习等等；这些大部分也是通过输入和模型获得输出；而模型的建立将是一个很复杂繁琐的过程；模型的正确性也是个重要因素；\n\n### 二、心理模型\n\n#### 1）起源\n\nPS: 博主其实从初中就开始关注心理学，不过没有深入了解；最初想探寻人的心理模型，是在博主遇到19年创伤事件后，不明白心理为什么会出现如此变化；且还没有去借助外在心理学知识来解释，尝试自己去理解时，总结出来的；\n\n##### （1）动物行为基本分析：\n\n​       动物通过感知周围的环境刺激如食物，猎食者等，和自身的内在刺激如饥饿等，输入，进入到自己的简单模型，处理后进行反应即输出，比如见到猎食者，输入刺激，模型处理的结果是要逃跑，于是反应为逃跑等等；而动物的几乎一切的行为活动，贯穿一生，都是这样度过的；所以动物的本质，是个输入输出模型；从这个角度理解的话。\n\n##### （2）人类\n\n​       人类其实也是动物，只是因为人类有高级的模型，所以能使得有控制输入输出，以及控制模型的能力；但因为基因和自身的认知等影响，导致不同的人对这些控制能力不同，就算是最强的人，对这些控制也不是100%的；\n\n​        人的模型很复杂，人需要适应多变的环境，并安稳的生存下来，需要得到更多的信息，来应对种种危险等等；所以人类进化出了各种感官器，处理器如最强的大脑；内在神经感受器等等；\n\n#### 2）模型基本框架\n\n人的心理模型在：\n\n外界的输入-->人对应的感受器-->进入处理器模型-->决策后输出；\n\n以下是处理器模型，优先从第一层传递到第五层；\n\n```\n第五层:---------自我意识：理性思考(一般有多个)------------\n第四层:-------受限的自我意识：感受----------------------\n第三层：------受约束的自我意识：道德，法律-----------------\n第二层：------潜意识，习惯-----------------------------\n第一层：------身体，物理感受和直接处理------------------\n```\n\n身体：比如膝跳反应等；\n\n潜意识习惯：比如交流中的口头禅等；\n\n其他类似；总是先经过第一层，第一层处理不了或者不需要则往上传递；严格来说也不是层级关系，是一种分类的处理；\n\n输入输出方式：\n\n可以分为两种：\n\n1、接收输入，处理(处理包括思维层面，感受等等)，表现出来输出(可能是行为或者单纯的感受并会存储记忆，内反馈形成下次处理同类型问题的经验或者进步)；\n\n2、进行输出(可能之前得到输入或单纯想输出)，得到输入，处理，感受；\n\n#### 3）人心理模型的基本组成分析\n\n##### （1） 组成：输入源，感受器，处理器，输出器\n\n##### （2）各个组成分析：\n\n######     A 输入源：\n\n​    一个是外部输入源，对应于第一种方式：输入->处理->输出的方式：很多，几乎是无限的，而感受器却只有有限种类型，而为了缔结输入源，感受器和输出等的联系，所建立的缔结关系，也是无限的；即体现为知识，能力等等；输入源举例：不同的食物，不同的感受刺激如漂亮的花朵等等；深层的如赞美的话，得到礼物等等，其他人也是一种输入源；\n\n​     一个是内部的输入源：对应于第二种方式：输出->输入->处理的方式：很多，推理，瞎想，想象，创作等等；甚至简单如思考后的说话等等；\n\n######    B 感受器：\n\n   感受器目前我了解到的有：\n\n外在实体：触觉，嗅觉，味觉，听觉，视觉，痛觉，温觉；\n\n######   C 处理器：\n\n 见上图；最低层次为身体，这个和动物也类似，即本能，人会本能的躲避危险，碰到烫的东西会自动收回；这些是不经过大脑的；\n\n接着是潜意识和习惯等，大部分没有被大脑意识到；这个层面反应很快；类似口头禅，可以理解为一个map,针对某个输入，有确定的输出；所以往往直接表现出来；\n\n接着是感受和道德层面：某个事物让自己感受到开心或伤心，可能还来不及去考虑，就直接反应，而道德法律也是，即自己的底线；这种一般不用思考；这个其实也是意识层面，只是是较浅的意识；当然有些人是感受强势些，有些人是理性意识强势些；\n\n意识层面：即在感受和道德无法做决定时，则到了意识层面，经过处理后得到反应；而这个层面的思考，取决于人的认知，学识，智慧，即智商，情商等等；更多的是：涉及计算，规律，预测，分析问题本质，多因素考虑等等；\n\n######   D 输出器\n\n​    内在感受：快乐感受器，悲伤感受器，愤怒感受器，害怕感受器等自尊感受器，安全感受器，归属感，等等；基本感受表现器，这个和输入其实息息相关；只有很少的处理过程；比如快乐往往很简单；不用经过太多的思考；偏向于对应于输入输出方式\n\n输出方式也有：行为，选择决策，语言等等；\n\n#### 4）人类模型的复杂度分析\n\n(1)  人的感受器丰富，不仅有外在感受器如：视觉，听觉，触觉，嗅觉，味觉，还有如痛觉等内在感受器，甚至高级的自尊感，安全感，归属感等等一些进化的非显性但是实际存在的感觉器；（这些感受器大多是因为社交体系，和他人的情感体系环境下产生的，和等级等观念也相关）\n\n(2)  人的感受器特性：感受器有个特点，对初次刺激记忆最深，敏感度最高，对之后的相同刺激习惯了，就显得表现的不是很强烈，可能是因为进化的原因，第一次不知道是不是危险，所以显得最警惕，之后熟悉了便失去了焦点；所以才会有腻了，味觉疲劳等现象；而对于隔了很久的没有的刺激，再次刺激也会有比较大的反应，这个也是很容易理解的；也就是边际递减效应；\n\n(3)  外界输入类型的多样性，有些输入是人类自身创造的；而这个太多了；比如游戏；\n\n(4)  人的处理器复杂度高：正常处理：输入到达身体层面能处理则不会传递上去：如人碰到烫的东西自动收回等等；若能传递，则到潜意识，接着到意识进行逻辑等处理，而意识层面的处理是最复杂的；\n\n(5)  人的感受器对应的是输入，而人的一部分感受器可以作为输出，而输出同样也是复杂，不同类型的人不同环境下等等输出的效果可能类似，但是输出方式不同；\n\n### 三、详解输入源等\n\n输入源分为外部输入源和内部输入源：当你的输入源能量大，形成一个能量场，别人也会被你吸引，到你的能量场，于是你可能成为别人眼中的有趣的人；而最好这些不要太过依赖外部能量的提供；生活的品质和热爱表现于此；\n\n1） 外部输入源：\n\n划分方式1：根据特性划分\n\n人或其他活物：亲人朋友爱人，崇拜对象，宠物等等，这种可以提供长期的源，和刺激；\n\n一次性物：食物，视频等等\n\n游戏/竞技/运动：同时刺激多个感官，而且高反馈即时反馈的特性让人享受其中；\n\n…\n\n划分方式2：根据归属划分：\n\n现实物理世界日常活动：\n\n吃-食物和怎样获取食物：自己下厨，外卖刷剧，堂食探索，各种体验不同；\n\n穿-衣服化妆护肤等颜值相关，保暖舒适好看漂亮气质吸引别人等等；\n\n住-居家环境宜家家居：居住环境构成和特点：干净整洁安全安静床舒适度气味等等；\n\n行-交通工具：汽车高铁公交飞机走路自行车跑步平衡车轮滑等不同体验；空间方位认路等体验；”\n\n健康-健身等；喝茶泡脚吃等等，\n\n纯玩：打球游戏等等；\n\n工作-知识技能解决问题需求，\n\n社交-人\n\n网络世界：游戏，视频媒体，文字信息，虚拟化，创作编程等，社交购物等和现实挂钩的，统称信息；而媒介可以是手机，平板，电脑，手表，智能硬件等等；\n\n \n\n2） 内部输入源：\n\n内心世界：\n\n关系情感：友情爱情亲情等；\n\n欲望：性，贪，懒\n\n自尊自信等需求；\n\n### 四、心理模型的影响因素和发展周期\n\n1)   模型的影响因素：基因，家庭环境，学校环境，社会环境；环境包括人；\n\n2)   模型的变化特性：人格，气质，性格，等是不容易变化的，可以理解为硬编码，强缔结；而意识层面涉及情商，智商等认知是容易改变的，而道德，感受涉及三观等等，也是能改变的，不过比意识层面更难；\n\n3)   模型的发展周期：\n\n人诞生时，是婴儿时期，此时还未被环境影响，各个感受器处于初始状态；模型原始由基因决定；婴儿期性本善，性本偏外向\n\n孩童时期：在接受家庭环境影响，父母等影响后，感受器特质发生改变，此时比如接收到的某种刺激较少，比如爱，则缺爱，则长大后，第一次感受到爱后，会比别人表现更强烈；内向或者外向：一开始是外向的，通过输出能量，但是得到的反馈，输入进来的时候被判断为不好的感受，即负能量，则长此以往，则不愿意再去输出，形成内向的性格，即只喜欢输出到内部环境；\n\n 青少年：开始受到身体激素影响，并开始更理性的关注周围的事物，受到学校影响较大；\n\n 成年期：模型基本稳定，会轻微调整，不过受到创伤等大事会重新建立等；\n\nPS:模型的影响，包括模型的感受器，处理器和表现(输出);感受器的特质:敏感度等是能被随着发展周期改变的；\n\n学校环境：更多的是改变道德，感受和意识层面，少量的改变潜意识和习惯；\n\n### 五、用此心理模型来解释一些心理现象\n\n1） 人格：人格指一个人在一定情况下所作行为反应的特质，即人们在生活、工作中独特的行为表现，包括思考方式、决策方式等；包括了内向外向，感觉直觉，思考情感，判断知觉；\n\n内向外向：内向的人偏向于第一种方式：即输入->处理->输出；而外向的人偏向于输出->处理->输入的方式；和小时候的经历等有关；\n\n感觉直觉：获取信息的方式：是感官获取听到看到还是自己推理瞎想；模型解释：感官感觉针对第一种输入输出方式:即输入->处理->输出，而直觉：第二种：输出->输入->处理，而输入往往作为一种验证的方式；\n\n思考情感：决策方式：对应于模型中的处理器中的意识层面中哪个占主导，是感受还是理性；而这其中其实还有道德在作用；\n\n判断还是知觉：喜欢做计划还是灵活处理适应环境？做计划其实是由内而外，因为计划是偏向于自己做的，且更容易控制，而适应环境则是针对环境的输入，来做对应的输出，针对的是第一种输入输出方式，所以和内向外向有关；可能还涉及到安全感等；\n\n2） 气质：其实是一个人的输出，表现，这个多是自我的主动输出，少部分是针对输入做的输出；气质，这个词太虚：\n\n来看普世解释：气质是人的个性心理特征之一，它是指在人的认识、情感、言语、行动中，心理活动发生时力量的强弱、变化的快慢和均衡程度等稳定的动力特征。主要表现在情绪体验的快慢、强弱、表现的隐显以及动作的灵敏或迟钝方面，因而它为人的全部心理活动表现染上了一层浓厚的色彩。\n\n可以理解为感受器，表现器的特质吧；\n\n### 六、马斯洛需求解释\n\n最高层面的即价值，自我实现，创造等等，即对应了模型类别中的输出类模型，即模型本身偏向于输出源，能源源不断的给其他人(模型)提供输入，所以其他模型在感兴趣的情况下，被吸引，建立缔结，从而记得记住这个人；所以这个人的价值被体现出来；\n\n尊重需要：更深层次的内在感受器，凌驾于开心等之上，表现为舒适，满足，安全，信心等等；\n\n社会需要：亲情，爱情，友情：实际上是和某个输入源(包括方式1和2)，缔结了强烈的关系，这个源能提供源源不断的输入，好的或不好的，但是缔结的联系深深的印在脑子里了；所以一旦这个源不存在了，就体现为难受，其实这是一种上瘾；所以这种情况可以是建立一个相似的输入源不同的缔结；或者等自己适应了这种缔结的消失，而不再需要这种缔结；类似的还有和动物的情感，特殊物品的情感等等；\n\n安全需要：安全感：财产人身等安全，工作等：这个是属于内在高级的感受器：但是它可能依赖的东西并不高级，因人而异，比如在一间新房子还是旧房子里；\n\n生理需求：吃喝拉撒睡性穿住行；身体需求层面，本能，低级感受器；\n\n没有了身体，就没有大脑，所以身体的感受是最强烈的但是短暂，而越靠近上层，感觉越不强烈但是可能长远；除非，和身体的感受形成了缔结；\n\n预测行为；了解自己行动原因，深层原因，从而改变自己，完善自己，善待自己；\n\n### 七、模型和现代互联网AI\n\n模型编程和如何塑造一个你，TODO\n\n","slug":"我理解的心理模型","published":1,"updated":"2020-06-07T05:08:02.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjqsu7t0004b2ujxsxi5j946","content":"<p>以下内容均为本人构想理解提出，如有雷同纯属巧合，仅为本人粗略观点，不期赞同；</p>\n<h3 id=\"一、模型概念\"><a href=\"#一、模型概念\" class=\"headerlink\" title=\"一、模型概念\"></a>一、模型概念</h3><h4 id=\"1）模型的广义解释\"><a href=\"#1）模型的广义解释\" class=\"headerlink\" title=\"1）模型的广义解释\"></a>1）模型的广义解释</h4><p>模型用于抽象化一类事物的特点和规律，甚至是发展周期；模型常见有数学模型，物理模型，工业模型等等；<a id=\"more\"></a><br>如数学模型，是用来处理一类问题，通过输入，模型处理，得到想要的预测输出，模型常用来预测和计算问题的结果和答案；逼近结果甚至计算出结果本身；最简单如: 1天卖10斤菜，预测10天卖多少斤这种简单问题，则模型就是10*天数；输入就是天数，输出就是卖了多少斤；复杂一点可以加上条件，阴天卖多少斤，晴天卖多少斤，阴天有几天，或者甚至让你预测天气等等；</p>\n<h4 id=\"2）复杂的模型\"><a href=\"#2）复杂的模型\" class=\"headerlink\" title=\"2）复杂的模型\"></a>2）复杂的模型</h4><p>用于解释数学的模型，还可以用来解释更多内容，并归结升级到当下流行的人工智能中的机器学习模型和深度学习等等；这些大部分也是通过输入和模型获得输出；而模型的建立将是一个很复杂繁琐的过程；模型的正确性也是个重要因素；</p>\n<h3 id=\"二、心理模型\"><a href=\"#二、心理模型\" class=\"headerlink\" title=\"二、心理模型\"></a>二、心理模型</h3><h4 id=\"1）起源\"><a href=\"#1）起源\" class=\"headerlink\" title=\"1）起源\"></a>1）起源</h4><p>PS: 博主其实从初中就开始关注心理学，不过没有深入了解；最初想探寻人的心理模型，是在博主遇到19年创伤事件后，不明白心理为什么会出现如此变化；且还没有去借助外在心理学知识来解释，尝试自己去理解时，总结出来的；</p>\n<h5 id=\"（1）动物行为基本分析：\"><a href=\"#（1）动物行为基本分析：\" class=\"headerlink\" title=\"（1）动物行为基本分析：\"></a>（1）动物行为基本分析：</h5><p>​       动物通过感知周围的环境刺激如食物，猎食者等，和自身的内在刺激如饥饿等，输入，进入到自己的简单模型，处理后进行反应即输出，比如见到猎食者，输入刺激，模型处理的结果是要逃跑，于是反应为逃跑等等；而动物的几乎一切的行为活动，贯穿一生，都是这样度过的；所以动物的本质，是个输入输出模型；从这个角度理解的话。</p>\n<h5 id=\"（2）人类\"><a href=\"#（2）人类\" class=\"headerlink\" title=\"（2）人类\"></a>（2）人类</h5><p>​       人类其实也是动物，只是因为人类有高级的模型，所以能使得有控制输入输出，以及控制模型的能力；但因为基因和自身的认知等影响，导致不同的人对这些控制能力不同，就算是最强的人，对这些控制也不是100%的；</p>\n<p>​        人的模型很复杂，人需要适应多变的环境，并安稳的生存下来，需要得到更多的信息，来应对种种危险等等；所以人类进化出了各种感官器，处理器如最强的大脑；内在神经感受器等等；</p>\n<h4 id=\"2）模型基本框架\"><a href=\"#2）模型基本框架\" class=\"headerlink\" title=\"2）模型基本框架\"></a>2）模型基本框架</h4><p>人的心理模型在：</p>\n<p>外界的输入–&gt;人对应的感受器–&gt;进入处理器模型–&gt;决策后输出；</p>\n<p>以下是处理器模型，优先从第一层传递到第五层；</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第五层<span class=\"symbol\">:---------</span>自我意识：理性思考(一般有多个)------------</span><br><span class=\"line\">第四层<span class=\"symbol\">:-------</span>受限的自我意识：感受----------------------</span><br><span class=\"line\">第三层：------受约束的自我意识：道德，法律-----------------</span><br><span class=\"line\">第二层：------潜意识，习惯-----------------------------</span><br><span class=\"line\">第一层：------身体，物理感受和直接处理------------------</span><br></pre></td></tr></table></figure>\n<p>身体：比如膝跳反应等；</p>\n<p>潜意识习惯：比如交流中的口头禅等；</p>\n<p>其他类似；总是先经过第一层，第一层处理不了或者不需要则往上传递；严格来说也不是层级关系，是一种分类的处理；</p>\n<p>输入输出方式：</p>\n<p>可以分为两种：</p>\n<p>1、接收输入，处理(处理包括思维层面，感受等等)，表现出来输出(可能是行为或者单纯的感受并会存储记忆，内反馈形成下次处理同类型问题的经验或者进步)；</p>\n<p>2、进行输出(可能之前得到输入或单纯想输出)，得到输入，处理，感受；</p>\n<h4 id=\"3）人心理模型的基本组成分析\"><a href=\"#3）人心理模型的基本组成分析\" class=\"headerlink\" title=\"3）人心理模型的基本组成分析\"></a>3）人心理模型的基本组成分析</h4><h5 id=\"（1）-组成：输入源，感受器，处理器，输出器\"><a href=\"#（1）-组成：输入源，感受器，处理器，输出器\" class=\"headerlink\" title=\"（1） 组成：输入源，感受器，处理器，输出器\"></a>（1） 组成：输入源，感受器，处理器，输出器</h5><h5 id=\"（2）各个组成分析：\"><a href=\"#（2）各个组成分析：\" class=\"headerlink\" title=\"（2）各个组成分析：\"></a>（2）各个组成分析：</h5><h6 id=\"A-输入源：\"><a href=\"#A-输入源：\" class=\"headerlink\" title=\"A 输入源：\"></a>A 输入源：</h6><p>​    一个是外部输入源，对应于第一种方式：输入-&gt;处理-&gt;输出的方式：很多，几乎是无限的，而感受器却只有有限种类型，而为了缔结输入源，感受器和输出等的联系，所建立的缔结关系，也是无限的；即体现为知识，能力等等；输入源举例：不同的食物，不同的感受刺激如漂亮的花朵等等；深层的如赞美的话，得到礼物等等，其他人也是一种输入源；</p>\n<p>​     一个是内部的输入源：对应于第二种方式：输出-&gt;输入-&gt;处理的方式：很多，推理，瞎想，想象，创作等等；甚至简单如思考后的说话等等；</p>\n<h6 id=\"B-感受器：\"><a href=\"#B-感受器：\" class=\"headerlink\" title=\"B 感受器：\"></a>B 感受器：</h6><p>   感受器目前我了解到的有：</p>\n<p>外在实体：触觉，嗅觉，味觉，听觉，视觉，痛觉，温觉；</p>\n<h6 id=\"C-处理器：\"><a href=\"#C-处理器：\" class=\"headerlink\" title=\"C 处理器：\"></a>C 处理器：</h6><p> 见上图；最低层次为身体，这个和动物也类似，即本能，人会本能的躲避危险，碰到烫的东西会自动收回；这些是不经过大脑的；</p>\n<p>接着是潜意识和习惯等，大部分没有被大脑意识到；这个层面反应很快；类似口头禅，可以理解为一个map,针对某个输入，有确定的输出；所以往往直接表现出来；</p>\n<p>接着是感受和道德层面：某个事物让自己感受到开心或伤心，可能还来不及去考虑，就直接反应，而道德法律也是，即自己的底线；这种一般不用思考；这个其实也是意识层面，只是是较浅的意识；当然有些人是感受强势些，有些人是理性意识强势些；</p>\n<p>意识层面：即在感受和道德无法做决定时，则到了意识层面，经过处理后得到反应；而这个层面的思考，取决于人的认知，学识，智慧，即智商，情商等等；更多的是：涉及计算，规律，预测，分析问题本质，多因素考虑等等；</p>\n<h6 id=\"D-输出器\"><a href=\"#D-输出器\" class=\"headerlink\" title=\"D 输出器\"></a>D 输出器</h6><p>​    内在感受：快乐感受器，悲伤感受器，愤怒感受器，害怕感受器等自尊感受器，安全感受器，归属感，等等；基本感受表现器，这个和输入其实息息相关；只有很少的处理过程；比如快乐往往很简单；不用经过太多的思考；偏向于对应于输入输出方式</p>\n<p>输出方式也有：行为，选择决策，语言等等；</p>\n<h4 id=\"4）人类模型的复杂度分析\"><a href=\"#4）人类模型的复杂度分析\" class=\"headerlink\" title=\"4）人类模型的复杂度分析\"></a>4）人类模型的复杂度分析</h4><p>(1)  人的感受器丰富，不仅有外在感受器如：视觉，听觉，触觉，嗅觉，味觉，还有如痛觉等内在感受器，甚至高级的自尊感，安全感，归属感等等一些进化的非显性但是实际存在的感觉器；（这些感受器大多是因为社交体系，和他人的情感体系环境下产生的，和等级等观念也相关）</p>\n<p>(2)  人的感受器特性：感受器有个特点，对初次刺激记忆最深，敏感度最高，对之后的相同刺激习惯了，就显得表现的不是很强烈，可能是因为进化的原因，第一次不知道是不是危险，所以显得最警惕，之后熟悉了便失去了焦点；所以才会有腻了，味觉疲劳等现象；而对于隔了很久的没有的刺激，再次刺激也会有比较大的反应，这个也是很容易理解的；也就是边际递减效应；</p>\n<p>(3)  外界输入类型的多样性，有些输入是人类自身创造的；而这个太多了；比如游戏；</p>\n<p>(4)  人的处理器复杂度高：正常处理：输入到达身体层面能处理则不会传递上去：如人碰到烫的东西自动收回等等；若能传递，则到潜意识，接着到意识进行逻辑等处理，而意识层面的处理是最复杂的；</p>\n<p>(5)  人的感受器对应的是输入，而人的一部分感受器可以作为输出，而输出同样也是复杂，不同类型的人不同环境下等等输出的效果可能类似，但是输出方式不同；</p>\n<h3 id=\"三、详解输入源等\"><a href=\"#三、详解输入源等\" class=\"headerlink\" title=\"三、详解输入源等\"></a>三、详解输入源等</h3><p>输入源分为外部输入源和内部输入源：当你的输入源能量大，形成一个能量场，别人也会被你吸引，到你的能量场，于是你可能成为别人眼中的有趣的人；而最好这些不要太过依赖外部能量的提供；生活的品质和热爱表现于此；</p>\n<p>1） 外部输入源：</p>\n<p>划分方式1：根据特性划分</p>\n<p>人或其他活物：亲人朋友爱人，崇拜对象，宠物等等，这种可以提供长期的源，和刺激；</p>\n<p>一次性物：食物，视频等等</p>\n<p>游戏/竞技/运动：同时刺激多个感官，而且高反馈即时反馈的特性让人享受其中；</p>\n<p>…</p>\n<p>划分方式2：根据归属划分：</p>\n<p>现实物理世界日常活动：</p>\n<p>吃-食物和怎样获取食物：自己下厨，外卖刷剧，堂食探索，各种体验不同；</p>\n<p>穿-衣服化妆护肤等颜值相关，保暖舒适好看漂亮气质吸引别人等等；</p>\n<p>住-居家环境宜家家居：居住环境构成和特点：干净整洁安全安静床舒适度气味等等；</p>\n<p>行-交通工具：汽车高铁公交飞机走路自行车跑步平衡车轮滑等不同体验；空间方位认路等体验；”</p>\n<p>健康-健身等；喝茶泡脚吃等等，</p>\n<p>纯玩：打球游戏等等；</p>\n<p>工作-知识技能解决问题需求，</p>\n<p>社交-人</p>\n<p>网络世界：游戏，视频媒体，文字信息，虚拟化，创作编程等，社交购物等和现实挂钩的，统称信息；而媒介可以是手机，平板，电脑，手表，智能硬件等等；</p>\n<p>2） 内部输入源：</p>\n<p>内心世界：</p>\n<p>关系情感：友情爱情亲情等；</p>\n<p>欲望：性，贪，懒</p>\n<p>自尊自信等需求；</p>\n<h3 id=\"四、心理模型的影响因素和发展周期\"><a href=\"#四、心理模型的影响因素和发展周期\" class=\"headerlink\" title=\"四、心理模型的影响因素和发展周期\"></a>四、心理模型的影响因素和发展周期</h3><p>1)   模型的影响因素：基因，家庭环境，学校环境，社会环境；环境包括人；</p>\n<p>2)   模型的变化特性：人格，气质，性格，等是不容易变化的，可以理解为硬编码，强缔结；而意识层面涉及情商，智商等认知是容易改变的，而道德，感受涉及三观等等，也是能改变的，不过比意识层面更难；</p>\n<p>3)   模型的发展周期：</p>\n<p>人诞生时，是婴儿时期，此时还未被环境影响，各个感受器处于初始状态；模型原始由基因决定；婴儿期性本善，性本偏外向</p>\n<p>孩童时期：在接受家庭环境影响，父母等影响后，感受器特质发生改变，此时比如接收到的某种刺激较少，比如爱，则缺爱，则长大后，第一次感受到爱后，会比别人表现更强烈；内向或者外向：一开始是外向的，通过输出能量，但是得到的反馈，输入进来的时候被判断为不好的感受，即负能量，则长此以往，则不愿意再去输出，形成内向的性格，即只喜欢输出到内部环境；</p>\n<p> 青少年：开始受到身体激素影响，并开始更理性的关注周围的事物，受到学校影响较大；</p>\n<p> 成年期：模型基本稳定，会轻微调整，不过受到创伤等大事会重新建立等；</p>\n<p>PS:模型的影响，包括模型的感受器，处理器和表现(输出);感受器的特质:敏感度等是能被随着发展周期改变的；</p>\n<p>学校环境：更多的是改变道德，感受和意识层面，少量的改变潜意识和习惯；</p>\n<h3 id=\"五、用此心理模型来解释一些心理现象\"><a href=\"#五、用此心理模型来解释一些心理现象\" class=\"headerlink\" title=\"五、用此心理模型来解释一些心理现象\"></a>五、用此心理模型来解释一些心理现象</h3><p>1） 人格：人格指一个人在一定情况下所作行为反应的特质，即人们在生活、工作中独特的行为表现，包括思考方式、决策方式等；包括了内向外向，感觉直觉，思考情感，判断知觉；</p>\n<p>内向外向：内向的人偏向于第一种方式：即输入-&gt;处理-&gt;输出；而外向的人偏向于输出-&gt;处理-&gt;输入的方式；和小时候的经历等有关；</p>\n<p>感觉直觉：获取信息的方式：是感官获取听到看到还是自己推理瞎想；模型解释：感官感觉针对第一种输入输出方式:即输入-&gt;处理-&gt;输出，而直觉：第二种：输出-&gt;输入-&gt;处理，而输入往往作为一种验证的方式；</p>\n<p>思考情感：决策方式：对应于模型中的处理器中的意识层面中哪个占主导，是感受还是理性；而这其中其实还有道德在作用；</p>\n<p>判断还是知觉：喜欢做计划还是灵活处理适应环境？做计划其实是由内而外，因为计划是偏向于自己做的，且更容易控制，而适应环境则是针对环境的输入，来做对应的输出，针对的是第一种输入输出方式，所以和内向外向有关；可能还涉及到安全感等；</p>\n<p>2） 气质：其实是一个人的输出，表现，这个多是自我的主动输出，少部分是针对输入做的输出；气质，这个词太虚：</p>\n<p>来看普世解释：气质是人的个性心理特征之一，它是指在人的认识、情感、言语、行动中，心理活动发生时力量的强弱、变化的快慢和均衡程度等稳定的动力特征。主要表现在情绪体验的快慢、强弱、表现的隐显以及动作的灵敏或迟钝方面，因而它为人的全部心理活动表现染上了一层浓厚的色彩。</p>\n<p>可以理解为感受器，表现器的特质吧；</p>\n<h3 id=\"六、马斯洛需求解释\"><a href=\"#六、马斯洛需求解释\" class=\"headerlink\" title=\"六、马斯洛需求解释\"></a>六、马斯洛需求解释</h3><p>最高层面的即价值，自我实现，创造等等，即对应了模型类别中的输出类模型，即模型本身偏向于输出源，能源源不断的给其他人(模型)提供输入，所以其他模型在感兴趣的情况下，被吸引，建立缔结，从而记得记住这个人；所以这个人的价值被体现出来；</p>\n<p>尊重需要：更深层次的内在感受器，凌驾于开心等之上，表现为舒适，满足，安全，信心等等；</p>\n<p>社会需要：亲情，爱情，友情：实际上是和某个输入源(包括方式1和2)，缔结了强烈的关系，这个源能提供源源不断的输入，好的或不好的，但是缔结的联系深深的印在脑子里了；所以一旦这个源不存在了，就体现为难受，其实这是一种上瘾；所以这种情况可以是建立一个相似的输入源不同的缔结；或者等自己适应了这种缔结的消失，而不再需要这种缔结；类似的还有和动物的情感，特殊物品的情感等等；</p>\n<p>安全需要：安全感：财产人身等安全，工作等：这个是属于内在高级的感受器：但是它可能依赖的东西并不高级，因人而异，比如在一间新房子还是旧房子里；</p>\n<p>生理需求：吃喝拉撒睡性穿住行；身体需求层面，本能，低级感受器；</p>\n<p>没有了身体，就没有大脑，所以身体的感受是最强烈的但是短暂，而越靠近上层，感觉越不强烈但是可能长远；除非，和身体的感受形成了缔结；</p>\n<p>预测行为；了解自己行动原因，深层原因，从而改变自己，完善自己，善待自己；</p>\n<h3 id=\"七、模型和现代互联网AI\"><a href=\"#七、模型和现代互联网AI\" class=\"headerlink\" title=\"七、模型和现代互联网AI\"></a>七、模型和现代互联网AI</h3><p>模型编程和如何塑造一个你，TODO</p>\n","site":{"data":{}},"excerpt":"<p>以下内容均为本人构想理解提出，如有雷同纯属巧合，仅为本人粗略观点，不期赞同；</p>\n<h3 id=\"一、模型概念\"><a href=\"#一、模型概念\" class=\"headerlink\" title=\"一、模型概念\"></a>一、模型概念</h3><h4 id=\"1）模型的广义解释\"><a href=\"#1）模型的广义解释\" class=\"headerlink\" title=\"1）模型的广义解释\"></a>1）模型的广义解释</h4><p>模型用于抽象化一类事物的特点和规律，甚至是发展周期；模型常见有数学模型，物理模型，工业模型等等；","more":"<br>如数学模型，是用来处理一类问题，通过输入，模型处理，得到想要的预测输出，模型常用来预测和计算问题的结果和答案；逼近结果甚至计算出结果本身；最简单如: 1天卖10斤菜，预测10天卖多少斤这种简单问题，则模型就是10*天数；输入就是天数，输出就是卖了多少斤；复杂一点可以加上条件，阴天卖多少斤，晴天卖多少斤，阴天有几天，或者甚至让你预测天气等等；</p>\n<h4 id=\"2）复杂的模型\"><a href=\"#2）复杂的模型\" class=\"headerlink\" title=\"2）复杂的模型\"></a>2）复杂的模型</h4><p>用于解释数学的模型，还可以用来解释更多内容，并归结升级到当下流行的人工智能中的机器学习模型和深度学习等等；这些大部分也是通过输入和模型获得输出；而模型的建立将是一个很复杂繁琐的过程；模型的正确性也是个重要因素；</p>\n<h3 id=\"二、心理模型\"><a href=\"#二、心理模型\" class=\"headerlink\" title=\"二、心理模型\"></a>二、心理模型</h3><h4 id=\"1）起源\"><a href=\"#1）起源\" class=\"headerlink\" title=\"1）起源\"></a>1）起源</h4><p>PS: 博主其实从初中就开始关注心理学，不过没有深入了解；最初想探寻人的心理模型，是在博主遇到19年创伤事件后，不明白心理为什么会出现如此变化；且还没有去借助外在心理学知识来解释，尝试自己去理解时，总结出来的；</p>\n<h5 id=\"（1）动物行为基本分析：\"><a href=\"#（1）动物行为基本分析：\" class=\"headerlink\" title=\"（1）动物行为基本分析：\"></a>（1）动物行为基本分析：</h5><p>​       动物通过感知周围的环境刺激如食物，猎食者等，和自身的内在刺激如饥饿等，输入，进入到自己的简单模型，处理后进行反应即输出，比如见到猎食者，输入刺激，模型处理的结果是要逃跑，于是反应为逃跑等等；而动物的几乎一切的行为活动，贯穿一生，都是这样度过的；所以动物的本质，是个输入输出模型；从这个角度理解的话。</p>\n<h5 id=\"（2）人类\"><a href=\"#（2）人类\" class=\"headerlink\" title=\"（2）人类\"></a>（2）人类</h5><p>​       人类其实也是动物，只是因为人类有高级的模型，所以能使得有控制输入输出，以及控制模型的能力；但因为基因和自身的认知等影响，导致不同的人对这些控制能力不同，就算是最强的人，对这些控制也不是100%的；</p>\n<p>​        人的模型很复杂，人需要适应多变的环境，并安稳的生存下来，需要得到更多的信息，来应对种种危险等等；所以人类进化出了各种感官器，处理器如最强的大脑；内在神经感受器等等；</p>\n<h4 id=\"2）模型基本框架\"><a href=\"#2）模型基本框架\" class=\"headerlink\" title=\"2）模型基本框架\"></a>2）模型基本框架</h4><p>人的心理模型在：</p>\n<p>外界的输入–&gt;人对应的感受器–&gt;进入处理器模型–&gt;决策后输出；</p>\n<p>以下是处理器模型，优先从第一层传递到第五层；</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第五层<span class=\"symbol\">:---------</span>自我意识：理性思考(一般有多个)------------</span><br><span class=\"line\">第四层<span class=\"symbol\">:-------</span>受限的自我意识：感受----------------------</span><br><span class=\"line\">第三层：------受约束的自我意识：道德，法律-----------------</span><br><span class=\"line\">第二层：------潜意识，习惯-----------------------------</span><br><span class=\"line\">第一层：------身体，物理感受和直接处理------------------</span><br></pre></td></tr></table></figure>\n<p>身体：比如膝跳反应等；</p>\n<p>潜意识习惯：比如交流中的口头禅等；</p>\n<p>其他类似；总是先经过第一层，第一层处理不了或者不需要则往上传递；严格来说也不是层级关系，是一种分类的处理；</p>\n<p>输入输出方式：</p>\n<p>可以分为两种：</p>\n<p>1、接收输入，处理(处理包括思维层面，感受等等)，表现出来输出(可能是行为或者单纯的感受并会存储记忆，内反馈形成下次处理同类型问题的经验或者进步)；</p>\n<p>2、进行输出(可能之前得到输入或单纯想输出)，得到输入，处理，感受；</p>\n<h4 id=\"3）人心理模型的基本组成分析\"><a href=\"#3）人心理模型的基本组成分析\" class=\"headerlink\" title=\"3）人心理模型的基本组成分析\"></a>3）人心理模型的基本组成分析</h4><h5 id=\"（1）-组成：输入源，感受器，处理器，输出器\"><a href=\"#（1）-组成：输入源，感受器，处理器，输出器\" class=\"headerlink\" title=\"（1） 组成：输入源，感受器，处理器，输出器\"></a>（1） 组成：输入源，感受器，处理器，输出器</h5><h5 id=\"（2）各个组成分析：\"><a href=\"#（2）各个组成分析：\" class=\"headerlink\" title=\"（2）各个组成分析：\"></a>（2）各个组成分析：</h5><h6 id=\"A-输入源：\"><a href=\"#A-输入源：\" class=\"headerlink\" title=\"A 输入源：\"></a>A 输入源：</h6><p>​    一个是外部输入源，对应于第一种方式：输入-&gt;处理-&gt;输出的方式：很多，几乎是无限的，而感受器却只有有限种类型，而为了缔结输入源，感受器和输出等的联系，所建立的缔结关系，也是无限的；即体现为知识，能力等等；输入源举例：不同的食物，不同的感受刺激如漂亮的花朵等等；深层的如赞美的话，得到礼物等等，其他人也是一种输入源；</p>\n<p>​     一个是内部的输入源：对应于第二种方式：输出-&gt;输入-&gt;处理的方式：很多，推理，瞎想，想象，创作等等；甚至简单如思考后的说话等等；</p>\n<h6 id=\"B-感受器：\"><a href=\"#B-感受器：\" class=\"headerlink\" title=\"B 感受器：\"></a>B 感受器：</h6><p>   感受器目前我了解到的有：</p>\n<p>外在实体：触觉，嗅觉，味觉，听觉，视觉，痛觉，温觉；</p>\n<h6 id=\"C-处理器：\"><a href=\"#C-处理器：\" class=\"headerlink\" title=\"C 处理器：\"></a>C 处理器：</h6><p> 见上图；最低层次为身体，这个和动物也类似，即本能，人会本能的躲避危险，碰到烫的东西会自动收回；这些是不经过大脑的；</p>\n<p>接着是潜意识和习惯等，大部分没有被大脑意识到；这个层面反应很快；类似口头禅，可以理解为一个map,针对某个输入，有确定的输出；所以往往直接表现出来；</p>\n<p>接着是感受和道德层面：某个事物让自己感受到开心或伤心，可能还来不及去考虑，就直接反应，而道德法律也是，即自己的底线；这种一般不用思考；这个其实也是意识层面，只是是较浅的意识；当然有些人是感受强势些，有些人是理性意识强势些；</p>\n<p>意识层面：即在感受和道德无法做决定时，则到了意识层面，经过处理后得到反应；而这个层面的思考，取决于人的认知，学识，智慧，即智商，情商等等；更多的是：涉及计算，规律，预测，分析问题本质，多因素考虑等等；</p>\n<h6 id=\"D-输出器\"><a href=\"#D-输出器\" class=\"headerlink\" title=\"D 输出器\"></a>D 输出器</h6><p>​    内在感受：快乐感受器，悲伤感受器，愤怒感受器，害怕感受器等自尊感受器，安全感受器，归属感，等等；基本感受表现器，这个和输入其实息息相关；只有很少的处理过程；比如快乐往往很简单；不用经过太多的思考；偏向于对应于输入输出方式</p>\n<p>输出方式也有：行为，选择决策，语言等等；</p>\n<h4 id=\"4）人类模型的复杂度分析\"><a href=\"#4）人类模型的复杂度分析\" class=\"headerlink\" title=\"4）人类模型的复杂度分析\"></a>4）人类模型的复杂度分析</h4><p>(1)  人的感受器丰富，不仅有外在感受器如：视觉，听觉，触觉，嗅觉，味觉，还有如痛觉等内在感受器，甚至高级的自尊感，安全感，归属感等等一些进化的非显性但是实际存在的感觉器；（这些感受器大多是因为社交体系，和他人的情感体系环境下产生的，和等级等观念也相关）</p>\n<p>(2)  人的感受器特性：感受器有个特点，对初次刺激记忆最深，敏感度最高，对之后的相同刺激习惯了，就显得表现的不是很强烈，可能是因为进化的原因，第一次不知道是不是危险，所以显得最警惕，之后熟悉了便失去了焦点；所以才会有腻了，味觉疲劳等现象；而对于隔了很久的没有的刺激，再次刺激也会有比较大的反应，这个也是很容易理解的；也就是边际递减效应；</p>\n<p>(3)  外界输入类型的多样性，有些输入是人类自身创造的；而这个太多了；比如游戏；</p>\n<p>(4)  人的处理器复杂度高：正常处理：输入到达身体层面能处理则不会传递上去：如人碰到烫的东西自动收回等等；若能传递，则到潜意识，接着到意识进行逻辑等处理，而意识层面的处理是最复杂的；</p>\n<p>(5)  人的感受器对应的是输入，而人的一部分感受器可以作为输出，而输出同样也是复杂，不同类型的人不同环境下等等输出的效果可能类似，但是输出方式不同；</p>\n<h3 id=\"三、详解输入源等\"><a href=\"#三、详解输入源等\" class=\"headerlink\" title=\"三、详解输入源等\"></a>三、详解输入源等</h3><p>输入源分为外部输入源和内部输入源：当你的输入源能量大，形成一个能量场，别人也会被你吸引，到你的能量场，于是你可能成为别人眼中的有趣的人；而最好这些不要太过依赖外部能量的提供；生活的品质和热爱表现于此；</p>\n<p>1） 外部输入源：</p>\n<p>划分方式1：根据特性划分</p>\n<p>人或其他活物：亲人朋友爱人，崇拜对象，宠物等等，这种可以提供长期的源，和刺激；</p>\n<p>一次性物：食物，视频等等</p>\n<p>游戏/竞技/运动：同时刺激多个感官，而且高反馈即时反馈的特性让人享受其中；</p>\n<p>…</p>\n<p>划分方式2：根据归属划分：</p>\n<p>现实物理世界日常活动：</p>\n<p>吃-食物和怎样获取食物：自己下厨，外卖刷剧，堂食探索，各种体验不同；</p>\n<p>穿-衣服化妆护肤等颜值相关，保暖舒适好看漂亮气质吸引别人等等；</p>\n<p>住-居家环境宜家家居：居住环境构成和特点：干净整洁安全安静床舒适度气味等等；</p>\n<p>行-交通工具：汽车高铁公交飞机走路自行车跑步平衡车轮滑等不同体验；空间方位认路等体验；”</p>\n<p>健康-健身等；喝茶泡脚吃等等，</p>\n<p>纯玩：打球游戏等等；</p>\n<p>工作-知识技能解决问题需求，</p>\n<p>社交-人</p>\n<p>网络世界：游戏，视频媒体，文字信息，虚拟化，创作编程等，社交购物等和现实挂钩的，统称信息；而媒介可以是手机，平板，电脑，手表，智能硬件等等；</p>\n<p>2） 内部输入源：</p>\n<p>内心世界：</p>\n<p>关系情感：友情爱情亲情等；</p>\n<p>欲望：性，贪，懒</p>\n<p>自尊自信等需求；</p>\n<h3 id=\"四、心理模型的影响因素和发展周期\"><a href=\"#四、心理模型的影响因素和发展周期\" class=\"headerlink\" title=\"四、心理模型的影响因素和发展周期\"></a>四、心理模型的影响因素和发展周期</h3><p>1)   模型的影响因素：基因，家庭环境，学校环境，社会环境；环境包括人；</p>\n<p>2)   模型的变化特性：人格，气质，性格，等是不容易变化的，可以理解为硬编码，强缔结；而意识层面涉及情商，智商等认知是容易改变的，而道德，感受涉及三观等等，也是能改变的，不过比意识层面更难；</p>\n<p>3)   模型的发展周期：</p>\n<p>人诞生时，是婴儿时期，此时还未被环境影响，各个感受器处于初始状态；模型原始由基因决定；婴儿期性本善，性本偏外向</p>\n<p>孩童时期：在接受家庭环境影响，父母等影响后，感受器特质发生改变，此时比如接收到的某种刺激较少，比如爱，则缺爱，则长大后，第一次感受到爱后，会比别人表现更强烈；内向或者外向：一开始是外向的，通过输出能量，但是得到的反馈，输入进来的时候被判断为不好的感受，即负能量，则长此以往，则不愿意再去输出，形成内向的性格，即只喜欢输出到内部环境；</p>\n<p> 青少年：开始受到身体激素影响，并开始更理性的关注周围的事物，受到学校影响较大；</p>\n<p> 成年期：模型基本稳定，会轻微调整，不过受到创伤等大事会重新建立等；</p>\n<p>PS:模型的影响，包括模型的感受器，处理器和表现(输出);感受器的特质:敏感度等是能被随着发展周期改变的；</p>\n<p>学校环境：更多的是改变道德，感受和意识层面，少量的改变潜意识和习惯；</p>\n<h3 id=\"五、用此心理模型来解释一些心理现象\"><a href=\"#五、用此心理模型来解释一些心理现象\" class=\"headerlink\" title=\"五、用此心理模型来解释一些心理现象\"></a>五、用此心理模型来解释一些心理现象</h3><p>1） 人格：人格指一个人在一定情况下所作行为反应的特质，即人们在生活、工作中独特的行为表现，包括思考方式、决策方式等；包括了内向外向，感觉直觉，思考情感，判断知觉；</p>\n<p>内向外向：内向的人偏向于第一种方式：即输入-&gt;处理-&gt;输出；而外向的人偏向于输出-&gt;处理-&gt;输入的方式；和小时候的经历等有关；</p>\n<p>感觉直觉：获取信息的方式：是感官获取听到看到还是自己推理瞎想；模型解释：感官感觉针对第一种输入输出方式:即输入-&gt;处理-&gt;输出，而直觉：第二种：输出-&gt;输入-&gt;处理，而输入往往作为一种验证的方式；</p>\n<p>思考情感：决策方式：对应于模型中的处理器中的意识层面中哪个占主导，是感受还是理性；而这其中其实还有道德在作用；</p>\n<p>判断还是知觉：喜欢做计划还是灵活处理适应环境？做计划其实是由内而外，因为计划是偏向于自己做的，且更容易控制，而适应环境则是针对环境的输入，来做对应的输出，针对的是第一种输入输出方式，所以和内向外向有关；可能还涉及到安全感等；</p>\n<p>2） 气质：其实是一个人的输出，表现，这个多是自我的主动输出，少部分是针对输入做的输出；气质，这个词太虚：</p>\n<p>来看普世解释：气质是人的个性心理特征之一，它是指在人的认识、情感、言语、行动中，心理活动发生时力量的强弱、变化的快慢和均衡程度等稳定的动力特征。主要表现在情绪体验的快慢、强弱、表现的隐显以及动作的灵敏或迟钝方面，因而它为人的全部心理活动表现染上了一层浓厚的色彩。</p>\n<p>可以理解为感受器，表现器的特质吧；</p>\n<h3 id=\"六、马斯洛需求解释\"><a href=\"#六、马斯洛需求解释\" class=\"headerlink\" title=\"六、马斯洛需求解释\"></a>六、马斯洛需求解释</h3><p>最高层面的即价值，自我实现，创造等等，即对应了模型类别中的输出类模型，即模型本身偏向于输出源，能源源不断的给其他人(模型)提供输入，所以其他模型在感兴趣的情况下，被吸引，建立缔结，从而记得记住这个人；所以这个人的价值被体现出来；</p>\n<p>尊重需要：更深层次的内在感受器，凌驾于开心等之上，表现为舒适，满足，安全，信心等等；</p>\n<p>社会需要：亲情，爱情，友情：实际上是和某个输入源(包括方式1和2)，缔结了强烈的关系，这个源能提供源源不断的输入，好的或不好的，但是缔结的联系深深的印在脑子里了；所以一旦这个源不存在了，就体现为难受，其实这是一种上瘾；所以这种情况可以是建立一个相似的输入源不同的缔结；或者等自己适应了这种缔结的消失，而不再需要这种缔结；类似的还有和动物的情感，特殊物品的情感等等；</p>\n<p>安全需要：安全感：财产人身等安全，工作等：这个是属于内在高级的感受器：但是它可能依赖的东西并不高级，因人而异，比如在一间新房子还是旧房子里；</p>\n<p>生理需求：吃喝拉撒睡性穿住行；身体需求层面，本能，低级感受器；</p>\n<p>没有了身体，就没有大脑，所以身体的感受是最强烈的但是短暂，而越靠近上层，感觉越不强烈但是可能长远；除非，和身体的感受形成了缔结；</p>\n<p>预测行为；了解自己行动原因，深层原因，从而改变自己，完善自己，善待自己；</p>\n<h3 id=\"七、模型和现代互联网AI\"><a href=\"#七、模型和现代互联网AI\" class=\"headerlink\" title=\"七、模型和现代互联网AI\"></a>七、模型和现代互联网AI</h3><p>模型编程和如何塑造一个你，TODO</p>"}],"PostAsset":[{"_id":"source/_posts/DS-linklist/buildlinklist.png","post":"ckjqsu7mk00002ujxp2palg0o","slug":"buildlinklist.png","modified":1,"renderable":1},{"_id":"source/_posts/DS-linklist/delete.png","post":"ckjqsu7mk00002ujxp2palg0o","slug":"delete.png","modified":1,"renderable":1},{"_id":"source/_posts/DS-linklist/headbuild.png","post":"ckjqsu7mk00002ujxp2palg0o","slug":"headbuild.png","modified":1,"renderable":1},{"_id":"source/_posts/DS-linklist/headnode.png","post":"ckjqsu7mk00002ujxp2palg0o","slug":"headnode.png","modified":1,"renderable":1},{"_id":"source/_posts/DS-linklist/insert.png","post":"ckjqsu7mk00002ujxp2palg0o","slug":"insert.png","modified":1,"renderable":1},{"_id":"source/_posts/DS-linklist/linklist.png","post":"ckjqsu7mk00002ujxp2palg0o","slug":"linklist.png","modified":1,"renderable":1},{"_id":"source/_posts/DS-linklist/mergerecycle.png","post":"ckjqsu7mk00002ujxp2palg0o","slug":"mergerecycle.png","modified":1,"renderable":1},{"_id":"source/_posts/DS-linklist/sigrecyclelink.png","post":"ckjqsu7mk00002ujxp2palg0o","slug":"sigrecyclelink.png","modified":1,"renderable":1},{"_id":"source/_posts/DS-linklist/tailbuile.png","post":"ckjqsu7mk00002ujxp2palg0o","slug":"tailbuile.png","modified":1,"renderable":1},{"_id":"source/_posts/tcpip-PF-PACKET/pf_packet.jpg","post":"ckjqsu7rv00442ujxhah6voej","slug":"pf_packet.jpg","modified":1,"renderable":1},{"_id":"source/_posts/test-article-picture/example.jpg","post":"ckjqsu7ry00472ujx16lrk3f7","slug":"example.jpg","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckjqsu7mk00002ujxp2palg0o","category_id":"ckjqsu7mt00022ujxgw01gnkr","_id":"ckjqsu7na000d2ujx591cfabp"},{"post_id":"ckjqsu7mq00012ujxe5b46m9o","category_id":"ckjqsu7mt00022ujxgw01gnkr","_id":"ckjqsu7ng000i2ujx5c4arl1t"},{"post_id":"ckjqsu7nb000g2ujxl1nal3kz","category_id":"ckjqsu7n9000c2ujxdwunp0wq","_id":"ckjqsu7nl000o2ujxyvztz339"},{"post_id":"ckjqsu7mv00042ujx67o5221o","category_id":"ckjqsu7n9000c2ujxdwunp0wq","_id":"ckjqsu7np000s2ujxflmficsj"},{"post_id":"ckjqsu7mz00052ujxstil4pvd","category_id":"ckjqsu7n9000c2ujxdwunp0wq","_id":"ckjqsu7nr000w2ujxujvkv7bj"},{"post_id":"ckjqsu7n100062ujxrfd5w6tx","category_id":"ckjqsu7n9000c2ujxdwunp0wq","_id":"ckjqsu7nx00122ujxlwqb469x"},{"post_id":"ckjqsu7n5000a2ujx3ofc89c1","category_id":"ckjqsu7n9000c2ujxdwunp0wq","_id":"ckjqsu7o100182ujxdkih2rmz"},{"post_id":"ckjqsu7n7000b2ujxhmoo426r","category_id":"ckjqsu7n9000c2ujxdwunp0wq","_id":"ckjqsu7o6001d2ujx2hw1es25"},{"post_id":"ckjqsu7ne000h2ujxwhlz3vpj","category_id":"ckjqsu7o100172ujxdve060dy","_id":"ckjqsu7oa001j2ujx5q4fun0h"},{"post_id":"ckjqsu7o6001g2ujxkywxhbfj","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7og001p2ujxwgqq7o2g"},{"post_id":"ckjqsu7ni000l2ujxoyoqrh80","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7oi001s2ujx1f8vi4cc"},{"post_id":"ckjqsu7o8001i2ujx8jwcjp95","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7ol001v2ujx1p2whwsl"},{"post_id":"ckjqsu7nk000n2ujxh9sn7cxj","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7on001z2ujxmfqo1su5"},{"post_id":"ckjqsu7no000r2ujxzuouctk6","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7op00232ujxef0o2i1b"},{"post_id":"ckjqsu7om001y2ujxqt2xj8qf","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7oq00262ujxjq31frv6"},{"post_id":"ckjqsu7np000u2ujxdd05ovx5","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7or00292ujxq7nm2hni"},{"post_id":"ckjqsu7nt000y2ujxbw1xpv9a","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7ot002d2ujxs2d6e8lv"},{"post_id":"ckjqsu7nu00102ujxrgfgldw1","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7ow002h2ujxpbihgbvf"},{"post_id":"ckjqsu7ny00142ujxpnj3jqu0","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7oy002l2ujxql0toekh"},{"post_id":"ckjqsu7o000162ujx1hbvfkbj","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7p0002p2ujxz692w47x"},{"post_id":"ckjqsu7o2001a2ujxjm7zp917","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7p2002t2ujxk0v7relf"},{"post_id":"ckjqsu7o4001c2ujx80emwil7","category_id":"ckjqsu7o6001e2ujxzkumnebd","_id":"ckjqsu7p4002w2ujxenzzo3n8"},{"post_id":"ckjqsu7oa001l2ujxracpurpm","category_id":"ckjqsu7p2002s2ujxi5bwelsc","_id":"ckjqsu7p600302ujxdhho1eca"},{"post_id":"ckjqsu7oe001o2ujx3rvea9w3","category_id":"ckjqsu7p4002x2ujxxxkp7qv5","_id":"ckjqsu7p800352ujxiff52efp"},{"post_id":"ckjqsu7oh001r2ujx7zcz6k1p","category_id":"ckjqsu7p4002x2ujxxxkp7qv5","_id":"ckjqsu7pa00382ujxh53certa"},{"post_id":"ckjqsu7ok001u2ujxv8zgm75a","category_id":"ckjqsu7p4002x2ujxxxkp7qv5","_id":"ckjqsu7pb003b2ujxnh32xi5n"},{"post_id":"ckjqsu7re003p2ujxdbzsyoly","category_id":"ckjqsu7rc003l2ujxztm5c34i","_id":"ckjqsu7rt00402ujxk2uztcyu"},{"post_id":"ckjqsu7r2003h2ujx814tb19f","category_id":"ckjqsu7rc003l2ujxztm5c34i","_id":"ckjqsu7rx00452ujxwh79qehw"},{"post_id":"ckjqsu7rj003r2ujxy540esgu","category_id":"ckjqsu7rc003l2ujxztm5c34i","_id":"ckjqsu7s000482ujx6upn5cy3"},{"post_id":"ckjqsu7rn003w2ujx6pg6yd5i","category_id":"ckjqsu7rc003l2ujxztm5c34i","_id":"ckjqsu7t1004c2ujxd1ypqhnh"},{"post_id":"ckjqsu7r9003j2ujx6ecxnbgb","category_id":"ckjqsu7rc003l2ujxztm5c34i","_id":"ckjqsu7t2004e2ujx47dbr788"},{"post_id":"ckjqsu7rr003z2ujxy4tgn1va","category_id":"ckjqsu7p4002x2ujxxxkp7qv5","_id":"ckjqsu7t4004h2ujxn9afjhlq"},{"post_id":"ckjqsu7rv00442ujxhah6voej","category_id":"ckjqsu7rc003l2ujxztm5c34i","_id":"ckjqsu7t4004j2ujx7ov4b2eh"},{"post_id":"ckjqsu7rc003n2ujxgy3aikpg","category_id":"ckjqsu7rc003l2ujxztm5c34i","_id":"ckjqsu7t4004l2ujxmn6pnazx"},{"post_id":"ckjqsu7t0004b2ujxsxi5j946","category_id":"ckjqsu7t3004g2ujxra9cdjun","_id":"ckjqsu7t4004n2ujxxnii7nyw"}],"PostTag":[{"post_id":"ckjqsu7mk00002ujxp2palg0o","tag_id":"ckjqsu7mv00032ujxi38y39tf","_id":"ckjqsu7n400092ujxlvoo7nal"},{"post_id":"ckjqsu7mq00012ujxe5b46m9o","tag_id":"ckjqsu7mv00032ujxi38y39tf","_id":"ckjqsu7nb000f2ujx772k96cz"},{"post_id":"ckjqsu7mv00042ujx67o5221o","tag_id":"ckjqsu7na000e2ujxikv4eajd","_id":"ckjqsu7nj000m2ujx4bmg034n"},{"post_id":"ckjqsu7mz00052ujxstil4pvd","tag_id":"ckjqsu7nh000k2ujx8rpzh3ru","_id":"ckjqsu7np000t2ujxe8q6zoea"},{"post_id":"ckjqsu7n100062ujxrfd5w6tx","tag_id":"ckjqsu7nh000k2ujx8rpzh3ru","_id":"ckjqsu7nu000z2ujxlqwjit0j"},{"post_id":"ckjqsu7n5000a2ujx3ofc89c1","tag_id":"ckjqsu7na000e2ujxikv4eajd","_id":"ckjqsu7nz00152ujx5touopnh"},{"post_id":"ckjqsu7n7000b2ujxhmoo426r","tag_id":"ckjqsu7nh000k2ujx8rpzh3ru","_id":"ckjqsu7o3001b2ujxr4py78v0"},{"post_id":"ckjqsu7nb000g2ujxl1nal3kz","tag_id":"ckjqsu7o200192ujxuq3809mt","_id":"ckjqsu7o8001h2ujx74zie6li"},{"post_id":"ckjqsu7ne000h2ujxwhlz3vpj","tag_id":"ckjqsu7o6001f2ujxm1s8kjlz","_id":"ckjqsu7oe001n2ujxvrpv9xbo"},{"post_id":"ckjqsu7ni000l2ujxoyoqrh80","tag_id":"ckjqsu7od001m2ujx8m60b766","_id":"ckjqsu7ol001w2ujx86qpwluh"},{"post_id":"ckjqsu7nk000n2ujxh9sn7cxj","tag_id":"ckjqsu7oj001t2ujxbewhw7u3","_id":"ckjqsu7op00212ujxd3b8d0jh"},{"post_id":"ckjqsu7om001y2ujxqt2xj8qf","tag_id":"ckjqsu7oj001t2ujxbewhw7u3","_id":"ckjqsu7op00242ujxih9eugmz"},{"post_id":"ckjqsu7no000r2ujxzuouctk6","tag_id":"ckjqsu7on00202ujxktqcxyfh","_id":"ckjqsu7oq00272ujxztzgrwl9"},{"post_id":"ckjqsu7np000u2ujxdd05ovx5","tag_id":"ckjqsu7od001m2ujx8m60b766","_id":"ckjqsu7os002b2ujxyrdrx4vo"},{"post_id":"ckjqsu7nt000y2ujxbw1xpv9a","tag_id":"ckjqsu7oj001t2ujxbewhw7u3","_id":"ckjqsu7ow002f2ujx025fmaun"},{"post_id":"ckjqsu7nu00102ujxrgfgldw1","tag_id":"ckjqsu7oj001t2ujxbewhw7u3","_id":"ckjqsu7oy002j2ujx5zew9x8c"},{"post_id":"ckjqsu7ny00142ujxpnj3jqu0","tag_id":"ckjqsu7od001m2ujx8m60b766","_id":"ckjqsu7p0002n2ujxymr3j81j"},{"post_id":"ckjqsu7o000162ujx1hbvfkbj","tag_id":"ckjqsu7oj001t2ujxbewhw7u3","_id":"ckjqsu7p2002r2ujx5hmd07rn"},{"post_id":"ckjqsu7o2001a2ujxjm7zp917","tag_id":"ckjqsu7oj001t2ujxbewhw7u3","_id":"ckjqsu7p4002v2ujx40d7899d"},{"post_id":"ckjqsu7o4001c2ujx80emwil7","tag_id":"ckjqsu7oj001t2ujxbewhw7u3","_id":"ckjqsu7p6002z2ujxdn07tp6p"},{"post_id":"ckjqsu7o6001g2ujxkywxhbfj","tag_id":"ckjqsu7on00202ujxktqcxyfh","_id":"ckjqsu7p700332ujx4zl8aqd8"},{"post_id":"ckjqsu7o8001i2ujx8jwcjp95","tag_id":"ckjqsu7on00202ujxktqcxyfh","_id":"ckjqsu7p900372ujxkkqo4giv"},{"post_id":"ckjqsu7oa001l2ujxracpurpm","tag_id":"ckjqsu7p800362ujxyx4v01wi","_id":"ckjqsu7pa003a2ujxg6qkt214"},{"post_id":"ckjqsu7oe001o2ujx3rvea9w3","tag_id":"ckjqsu7pa00392ujxhklp6ft2","_id":"ckjqsu7pc003d2ujxc1z1ibqj"},{"post_id":"ckjqsu7oh001r2ujx7zcz6k1p","tag_id":"ckjqsu7pa00392ujxhklp6ft2","_id":"ckjqsu7pd003f2ujx2gwvkal2"},{"post_id":"ckjqsu7ok001u2ujxv8zgm75a","tag_id":"ckjqsu7pc003e2ujxq7u1hwl8","_id":"ckjqsu7pd003g2ujx9y58tzib"},{"post_id":"ckjqsu7r2003h2ujx814tb19f","tag_id":"ckjqsu7rc003m2ujxse3l1jp1","_id":"ckjqsu7rm003v2ujxjjvn2dea"},{"post_id":"ckjqsu7rj003r2ujxy540esgu","tag_id":"ckjqsu7rc003m2ujxse3l1jp1","_id":"ckjqsu7rr003y2ujxbmhu8to0"},{"post_id":"ckjqsu7rn003w2ujx6pg6yd5i","tag_id":"ckjqsu7rc003m2ujxse3l1jp1","_id":"ckjqsu7rv00432ujxtqymddt9"},{"post_id":"ckjqsu7r9003j2ujx6ecxnbgb","tag_id":"ckjqsu7rl003t2ujxq80npgei","_id":"ckjqsu7ry00462ujxdq78eup0"},{"post_id":"ckjqsu7rr003z2ujxy4tgn1va","tag_id":"ckjqsu7pa00392ujxhklp6ft2","_id":"ckjqsu7sz004a2ujxdmgy0lhl"},{"post_id":"ckjqsu7rc003n2ujxgy3aikpg","tag_id":"ckjqsu7rl003t2ujxq80npgei","_id":"ckjqsu7t2004d2ujx5zvjs5nu"},{"post_id":"ckjqsu7re003p2ujxdbzsyoly","tag_id":"ckjqsu7rl003t2ujxq80npgei","_id":"ckjqsu7t4004i2ujxrwfhsq42"},{"post_id":"ckjqsu7rv00442ujxhah6voej","tag_id":"ckjqsu7t2004f2ujxlw60j768","_id":"ckjqsu7t4004m2ujx4ndom9zg"},{"post_id":"ckjqsu7ry00472ujx16lrk3f7","tag_id":"ckjqsu7t4004k2ujx3je1ov0c","_id":"ckjqsu7t5004o2ujxl3x16esc"}],"Tag":[{"name":"数据结构","_id":"ckjqsu7mv00032ujxi38y39tf"},{"name":"android_coding","_id":"ckjqsu7na000e2ujxikv4eajd"},{"name":"android_make","_id":"ckjqsu7nh000k2ujx8rpzh3ru"},{"name":"android_activity","_id":"ckjqsu7o200192ujxuq3809mt"},{"name":"代码可读性","_id":"ckjqsu7o6001f2ujxm1s8kjlz"},{"name":"cpp_memory","_id":"ckjqsu7od001m2ujx8m60b766"},{"name":"cpp_class","_id":"ckjqsu7oj001t2ujxbewhw7u3"},{"name":"cpp_keyword","_id":"ckjqsu7on00202ujxktqcxyfh"},{"name":"gdb","_id":"ckjqsu7p800362ujxyx4v01wi"},{"name":"leetcode_linklist","_id":"ckjqsu7pa00392ujxhklp6ft2"},{"name":"leetcode_string","_id":"ckjqsu7pc003e2ujxq7u1hwl8"},{"name":"tcpip_ip","_id":"ckjqsu7rc003m2ujxse3l1jp1"},{"name":"tcpip_mac","_id":"ckjqsu7rl003t2ujxq80npgei"},{"name":"PF_PACKET","_id":"ckjqsu7t2004f2ujxlw60j768"},{"name":"test","_id":"ckjqsu7t4004k2ujx3je1ov0c"}]}}