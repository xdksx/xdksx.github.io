<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xdksx.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="linux tcp数据发送框架 linux协议栈tcp发送流程：  tcp.c: tcp_sendmsg()函数分析：">
<meta property="og:type" content="article">
<meta property="og:title" content="tcpip_congestion">
<meta property="og:url" content="https://xdksx.github.io/2022/07/03/tcpip-congestion/index.html">
<meta property="og:site_name" content="追光者">
<meta property="og:description" content="linux tcp数据发送框架 linux协议栈tcp发送流程：  tcp.c: tcp_sendmsg()函数分析：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xdksx.github.io/2022/07/03/tcpip-congestion/tcpsend.png">
<meta property="og:image" content="https://xdksx.github.io/2022/07/03/tcpip-congestion/wind1.png">
<meta property="og:image" content="https://xdksx.github.io/2022/07/03/tcpip-congestion/wind2.png">
<meta property="og:image" content="https://xdksx.github.io/2022/07/03/tcpip-congestion/bbrmodel.png">
<meta property="og:image" content="https://xdksx.github.io/2022/07/03/tcpip-congestion/bbrstatemachine.png">
<meta property="article:published_time" content="2022-07-03T04:06:05.000Z">
<meta property="article:modified_time" content="2022-07-09T13:39:02.410Z">
<meta property="article:author" content="小兴">
<meta property="article:tag" content="congestion">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xdksx.github.io/2022/07/03/tcpip-congestion/tcpsend.png">

<link rel="canonical" href="https://xdksx.github.io/2022/07/03/tcpip-congestion/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>tcpip_congestion | 追光者</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">追光者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小兴的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-观影">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-阅读">

    <a href="/read/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-心理">

    <a href="/categories/%E5%BF%83%E7%90%86/" rel="section"><i class="fa fa-fw fa-heart"></i>心理</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xdksx.github.io/2022/07/03/tcpip-congestion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headicon2.jpg">
      <meta itemprop="name" content="小兴">
      <meta itemprop="description" content="始于歧路，愿归于征途">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="追光者">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          tcpip_congestion
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-03 12:06:05" itemprop="dateCreated datePublished" datetime="2022-07-03T12:06:05+08:00">2022-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-09 21:39:02" itemprop="dateModified" datetime="2022-07-09T21:39:02+08:00">2022-07-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tcpip/" itemprop="url" rel="index"><span itemprop="name">tcpip</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="linux-tcp数据发送框架"><a href="#linux-tcp数据发送框架" class="headerlink" title="linux tcp数据发送框架"></a>linux tcp数据发送框架</h3><ul>
<li>linux协议栈tcp发送流程：<img src="/2022/07/03/tcpip-congestion/tcpsend.png" class="" title="This is an example image"></li>
</ul>
<p>tcp.c: tcp_sendmsg()函数分析：<span id="more"></span></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> 处理tcp的一些特性的:fastopen,repair(连接迁移收尾),等</span><br><span class="line"><span class="number">1</span> sock<span class="constructor">_sndtimeo()</span> 发送阻塞超时时间处理，根据flag- block</span><br><span class="line"><span class="number">2</span> 获取MSS值，并对数据进行切割（需要判断gso,tso支持情况) --skb，</span><br><span class="line">非gso时，xmit_size_goal就等于MSS,若支持gso,则为MSS的整数倍,此时数据报发送到网络设备后再由网络设备根据MSS进行分割。</span><br><span class="line">size_goal = xmit_size_goal</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 循环取用户传递的msg(msghdr)：</span><br><span class="line"><span class="number">1</span>) 获取队列最后一个skb,看大小是否&lt;size_goal，是则拷贝部分数据填充skb到size_goal,期间根据skb特性进行处理。</span><br><span class="line">否则==size_goal,则分配新的skb,添加到sk_write_queue队列后，并填充用户数据到skb中。</span><br><span class="line"><span class="number">2</span>) <span class="keyword">if</span>(forced<span class="constructor">_push(<span class="params">tp</span>)</span>) 若自上次发送后产生的数据已超过对方曾经告知的最大通知窗口值的一半，则需要立即发送。</span><br><span class="line"><span class="constructor">__tcp_push_pending_frames(<span class="params">sk</span>, <span class="params">mss_now</span>, TCP_NAGLE_PUSH)</span>;</span><br><span class="line">否则，且队列只有这个段，则发送这个段tcp_push_one</span><br><span class="line"> 两者都会调用tcp_write_xmit进行发送，发送失败会后面由tcp_check_probe_timer检查重试。</span><br><span class="line"><span class="number">4</span> 调用tcp<span class="constructor">_write_xmit()</span>，循环从队列中拿skb：</span><br><span class="line"><span class="number">1</span>） 拥塞窗口大小检测：tcp<span class="constructor">_cwnd_test(<span class="params">tp</span>,<span class="params">skb</span>)</span></span><br><span class="line"><span class="number">2</span>) 判断当前段是否在发送窗口中：tcp<span class="constructor">_snd_wnd_test(<span class="params">tp</span>,<span class="params">skb</span>,<span class="params">mss_now</span>)</span></span><br><span class="line"><span class="number">3</span>) tso,nagle的检测和处理。</span><br><span class="line"><span class="number">4</span>) 调用tcp_transmit_skb发送。</span><br><span class="line"><span class="number">5</span> 输出到网络层：tcp<span class="constructor">_transmit_skb()</span></span><br><span class="line">构造tcp协议包，如头，option等，调用ip<span class="constructor">_queue_xmit()</span> - tcp_ipv4.c</span><br></pre></td></tr></table></figure>

<ul>
<li>几个关键概念：</li>
</ul>
<ol>
<li>链路mtu:mtu是链路以太网包载荷大小，一般和路由器相关，一般是1500，所以除开ip头20B,tcp头20B,tcp payload一般为1460</li>
<li>tcp的mss：因为app一般不支持分片，所以最好不要超mtu下发，但上层可能超额带下来，这个时候需要tcp seg不要超过一定值，但不是一直都是1460，对隧道或其他技术，会占用一些字节，导致tcp payload&lt;1460,即tcp mss</li>
<li>tcp mss可以通过三次握手得到：如client: syn–&gt;1460,但server返回的syn ack带的mss是1420如此，client调整自己的mss<br><a target="_blank" rel="noopener" href="https://www.imperva.com/blog/mtu-mss-explained/">https://www.imperva.com/blog/mtu-mss-explained/</a><br>注意：tcp mss是放在tcp option内。上层可以通过ioctl等设置</li>
</ol>
<h4 id="linux内核发送数据和窗口的关系，窗口如何影响数据发送"><a href="#linux内核发送数据和窗口的关系，窗口如何影响数据发送" class="headerlink" title="linux内核发送数据和窗口的关系，窗口如何影响数据发送"></a>linux内核发送数据和窗口的关系，窗口如何影响数据发送</h4><ul>
<li><p>先来看看滑动窗口：</p>
<img src="/2022/07/03/tcpip-congestion/wind1.png" class="" title="This is an example image">
</li>
<li><p>结合代码里一些变量的窗口</p>
<img src="/2022/07/03/tcpip-congestion/wind2.png" class="" title="This is an example image"></li>
</ul>
<p>可以看到，当snd_una+snd_wnd即窗口&gt;snd_nxt时，可以继续发送数据，否则此时不能继续发。<br>那snd_wnd的大小怎么确定？ 单位是什么？<br>snd_una是窗口左边界，是一个sequence，表示在输出的段中，最早一个未确认段的序号。一般为窗口的左边界<br>snd_nxt 等待发送的下一个tcp段的序号。<br>snd_wnd 接收方提供的接收窗口大小，即发送方发送窗口大小。其值来自ack所带的接收方窗口大小*opt中的窗口扩大因子，算出来也是一个序号值。<br>snd_cwnd 拥塞窗口大小，是此时可以在空中存在的段数量。</p>
<p>来看看拥塞窗口和发送窗口怎么限制发送：<br>在一次sendMsg调用中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">基于<span class="number">5.13</span>.<span class="number">1</span>：</span><br><span class="line">int <span class="title function_ invoke__">tcp_sendmsg_locked</span>(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk, <span class="keyword">struct</span> <span class="title class_">msghdr</span> *msg, size_t size)</span><br><span class="line">前面分析了流程：</span><br><span class="line"><span class="number">4</span> 调用<span class="title function_ invoke__">tcp_write_xmit</span>()，循环从队列中拿skb：</span><br><span class="line">中：</span><br><span class="line">        <span class="comment">//先检查拥塞窗口</span></span><br><span class="line">        cwnd_quota = <span class="title function_ invoke__">tcp_cwnd_test</span>(tp, skb);</span><br><span class="line">		<span class="title function_ invoke__">if</span> (!cwnd_quota) &#123;</span><br><span class="line">			<span class="title function_ invoke__">if</span> (push_one == <span class="number">2</span>)</span><br><span class="line">				<span class="comment">/* Force out a loss probe pkt. */</span></span><br><span class="line">				cwnd_quota = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//拥塞窗口检查返回不能发送+push_one不为2</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//接着检查发送窗口(对端接收窗口)</span></span><br><span class="line">		<span class="title function_ invoke__">if</span> (<span class="title function_ invoke__">unlikely</span>(!<span class="title function_ invoke__">tcp_snd_wnd_test</span>(tp, skb, mss_now))) &#123;</span><br><span class="line">			is_rwnd_limited = <span class="literal">true</span>;<span class="comment">//发送窗口限制</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">具体检查：</span><br><span class="line"><span class="comment">/* Can at least one segment of SKB be sent right now, according to the</span></span><br><span class="line"><span class="comment"> * congestion window rules?  If so, return how many segments are allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> inline unsigned int <span class="title function_ invoke__">tcp_cwnd_test</span>(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">tcp_sock</span> *tp,</span><br><span class="line">					 <span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">sk_buff</span> *skb)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">u32</span> in_flight, cwnd, halfcwnd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don&#x27;t be strict about the congestion window for the final FIN.  */</span></span><br><span class="line">	<span class="title function_ invoke__">if</span> ((<span class="title function_ invoke__">TCP_SKB_CB</span>(skb)<span class="punctuation">-&gt;</span>tcp_flags &amp; TCPHDR_FIN) &amp;&amp;</span><br><span class="line">	    <span class="title function_ invoke__">tcp_skb_pcount</span>(skb) == <span class="number">1</span>) <span class="comment">//对fin包且是gso段，不检查返回可发送</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	in_flight = <span class="title function_ invoke__">tcp_packets_in_flight</span>(tp);<span class="comment">//在空中的tcp包数</span></span><br><span class="line">	cwnd = tp<span class="punctuation">-&gt;</span>snd_cwnd; <span class="comment">//获取当前拥塞窗口大小</span></span><br><span class="line">	<span class="title function_ invoke__">if</span> (in_flight &gt;= cwnd) <span class="comment">//如果当前在网络上的&gt;=拥塞控制窗口大小</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//不能发送了</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For better scheduling, ensure we have at least</span></span><br><span class="line"><span class="comment">	 * 2 GSO packets in flight.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	halfcwnd = <span class="title function_ invoke__">max</span>(cwnd &gt;&gt; <span class="number">1</span>, <span class="number">1</span>U);<span class="comment">//否则，先取得拥塞窗口一半大小</span></span><br><span class="line">	<span class="keyword">return</span> <span class="title function_ invoke__">min</span>(halfcwnd, cwnd - in_flight);<span class="comment">//返回一半大小和拥塞窗口-空中包数之间的最小值。作为现在能立刻发送的段数量。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">涉及的函数解释：</span><br><span class="line"><span class="comment">/* This determines how many packets are &quot;in the network&quot; to the best</span></span><br><span class="line"><span class="comment"> * of our knowledge.  In many cases it is conservative, but where</span></span><br><span class="line"><span class="comment"> * detailed information is available from the receiver (via SACK</span></span><br><span class="line"><span class="comment"> * blocks etc.) we can make more aggressive calculations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this for decisions involving congestion control, use just</span></span><br><span class="line"><span class="comment"> * tp-&gt;packets_out to determine if the send queue is empty or not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Read this equation as:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	&quot;Packets sent once on transmission queue&quot; MINUS  从发送队列发出但还没得到确认的tcp段数量-</span></span><br><span class="line"><span class="comment"> *	&quot;Packets left network, but not honestly ACKed yet&quot; PLUS  已经发送，但至今还没确认的(表明丢失的)段数量+</span></span><br><span class="line"><span class="comment"> *	&quot;Packets fast retransmitted&quot;    已被快速重传的段数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> inline unsigned int <span class="title function_ invoke__">tcp_packets_in_flight</span>(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">tcp_sock</span> *tp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> tp<span class="punctuation">-&gt;</span>packets_out - <span class="title function_ invoke__">tcp_left_out</span>(tp) + tp<span class="punctuation">-&gt;</span>retrans_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接收方窗口限制检查：</span><br><span class="line"><span class="comment">/* Does at least the first segment of SKB fit into the send window? */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">bool</span> <span class="title function_ invoke__">tcp_snd_wnd_test</span>(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">tcp_sock</span> *tp,</span><br><span class="line">			     <span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">sk_buff</span> *skb,</span><br><span class="line">			     unsigned int cur_mss)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">u32</span> end_seq = <span class="title function_ invoke__">TCP_SKB_CB</span>(skb)<span class="punctuation">-&gt;</span>end_seq;</span><br><span class="line"></span><br><span class="line">	<span class="title function_ invoke__">if</span> (skb<span class="punctuation">-&gt;</span>len &gt; cur_mss)</span><br><span class="line">		end_seq = <span class="title function_ invoke__">TCP_SKB_CB</span>(skb)<span class="punctuation">-&gt;</span>seq + cur_mss;<span class="comment">//注意这里是加了cur_mss</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !<span class="title function_ invoke__">after</span>(end_seq, <span class="title function_ invoke__">tcp_wnd_end</span>(tp));<span class="comment">//且是和end_seq做对比，说明它的单位是seqnum,和拥塞控制窗口意义不同。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns end sequence number of the receiver&#x27;s advertised window */</span></span><br><span class="line"><span class="keyword">static</span> inline <span class="type">u32</span> <span class="title function_ invoke__">tcp_wnd_end</span>(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">tcp_sock</span> *tp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> tp<span class="punctuation">-&gt;</span>snd_una + tp<span class="punctuation">-&gt;</span>snd_wnd;<span class="comment">//在收到ack确认后，snd_una会递增，所以这个值在snd_wnd</span></span><br><span class="line">    <span class="comment">//保持不变时会一直增长。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，知道了拥塞窗口和接收窗口如何影响当次sendmsg的数据发送量，有个疑问，如果是依赖上层调用sendMsg来驱动发送，那会有一些包遗留着一直进不去窗口来发送如果<br>上层之后不再调用sendMsg, 故，这里sendMsg会把包放到发送队列，在收到ack后，会驱动去判断队列是否还有包，有则发送。</p>
<p>详细看这个函数的调用流程：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void tcp<span class="constructor">_data_snd_check(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	tcp<span class="constructor">_push_pending_frames(<span class="params">sk</span>)</span>;</span><br><span class="line">	tcp<span class="constructor">_check_space(<span class="params">sk</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="接收方窗口更新"><a href="#接收方窗口更新" class="headerlink" title="接收方窗口更新"></a>接收方窗口更新</h4><p>简略介绍：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> tcp<span class="constructor">_ack(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">sk_buff</span> <span class="operator">*</span><span class="params">skb</span>, <span class="params">int</span> <span class="params">flag</span>)</span></span><br><span class="line">   --&gt; 慢速路径下；</span><br><span class="line">   flag <span class="pattern-match">|= tcp<span class="constructor">_ack_update_window(<span class="params">sk</span>, <span class="params">skb</span>, <span class="params">ack</span>, <span class="params">ack_seq</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">   u32 nwin = ntohs(tcp<span class="constructor">_hdr(<span class="params">skb</span>)</span>-&gt;window);<span class="operator">/</span><span class="operator">/</span>ack是携带接收方窗口的</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">if</span> (likely(!tcp<span class="constructor">_hdr(<span class="params">skb</span>)</span>-&gt;syn))</span></span><br><span class="line"><span class="pattern-match">		nwin &lt;&lt;= tp-&gt;rx<span class="constructor">_opt</span>.snd<span class="constructor">_wscale</span>;<span class="operator">/</span><span class="operator">/</span>不是syn段，由窗口扩大因子计算出接收窗口的字节数</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span>满足三个条件之一可以更新发送窗口：1)确认的序号在snd<span class="constructor">_una</span>-&gt;snd<span class="constructor">_nxt</span>之间，</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span>2)ack段的seq是最新的 3) 收到重复的ack且接收方窗口大于发送方窗口</span></span><br><span class="line"><span class="pattern-match">	<span class="keyword">if</span> (tcp<span class="constructor">_may_update_window(<span class="params">tp</span>, <span class="params">ack</span>, <span class="params">ack_seq</span>, <span class="params">nwin</span>)</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">		flag |= <span class="constructor">FLAG_WIN_UPDATE</span>;<span class="operator">/</span><span class="operator">/</span>标记为更新窗口了</span></span><br><span class="line"><span class="pattern-match">		tcp<span class="constructor">_update_wl(<span class="params">tp</span>, <span class="params">ack_seq</span>)</span>;<span class="operator">/</span><span class="operator">/</span>记录当前收到的ack的seq</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">		<span class="keyword">if</span> (tp-&gt;snd<span class="constructor">_wnd</span> != nwin) &#123;<span class="operator">/</span><span class="operator">/</span>和接收方窗口不同，更新发送方窗口</span></span><br><span class="line"><span class="pattern-match">			tp-&gt;snd<span class="constructor">_wnd</span> = nwin;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">        所以可以看出，snd<span class="constructor">_wnd</span>是seq维度的。</span></span><br></pre></td></tr></table></figure>


<h4 id="拥塞算法和拥塞窗口简介"><a href="#拥塞算法和拥塞窗口简介" class="headerlink" title="拥塞算法和拥塞窗口简介"></a>拥塞算法和拥塞窗口简介</h4><p>拥塞算法是通过ack等机制间接了解网络状态后，通过调整拥塞控制窗口，进而调整输出到网络上的流量，来达到尝试减少网络拥塞程度的目的的算法。</p>
<h4 id="linux5-13-1拥塞控制框架"><a href="#linux5-13-1拥塞控制框架" class="headerlink" title="linux5.13.1拥塞控制框架"></a>linux5.13.1拥塞控制框架</h4><ul>
<li>拥塞算法注册和初始化</li>
</ul>
<ol>
<li>模块生成和注册，每个拥塞控制算法都是一个模块的形式，内核进行模块注册和卸载;<br>例如cubic:<br>module_init(cubictcp_register);<br>module_exit(cubictcp_unregister);<br>bbr:<br>module_init(bbr_register);<br>module_exit(bbr_unregister);</li>
<li>在初始化或程序调用setopt接口后，选择某一种拥塞控制算法，会进而进行初始化：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">do_tcp_setsockopt</span>(<span class="params"><span class="keyword">struct</span> sock *sk, <span class="built_in">int</span> level, <span class="built_in">int</span> optname,</span></span></span><br><span class="line"><span class="params"><span class="function">		sockptr_t optval, unsigned <span class="built_in">int</span> optlen</span>)</span></span><br><span class="line"><span class="function">      err</span> = tcp_set_congestion_control(sk, name, <span class="literal">true</span>,ns_capable(sock_net(sk)-&gt;user_ns)</span><br><span class="line">是在setopt调用下来后，将选择的拥塞控制挂载上去，然后调用<span class="keyword">init</span>函数</span><br><span class="line">tcp_cong.c:</span><br><span class="line">       tcp_set_congestion_control-&gt;</span><br><span class="line">            tcp_reinit_congestion_control-&gt;</span><br><span class="line">               tcp_init_congestion_control-&gt;</span><br><span class="line">                    icsk-&gt;icsk_ca_ops-&gt;<span class="keyword">init</span>(sk);--进而调用到具体拥塞控制算法的初始化函数</span><br><span class="line"> 如：cubic</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">struct</span> tcp_congestion_ops cubictcp __read_mostly = &#123;</span><br><span class="line">	.<span class="keyword">init</span>		= cubictcp_init,</span><br><span class="line">	.ssthresh	= cubictcp_recalc_ssthresh,</span><br><span class="line">	.cong_avoid	= cubictcp_cong_avoid,</span><br><span class="line">	.set_state	= cubictcp_state,</span><br><span class="line">	.undo_cwnd	= tcp_reno_undo_cwnd,</span><br><span class="line">	.cwnd_event	= cubictcp_cwnd_event,</span><br><span class="line">	.pkts_acked     = cubictcp_acked,</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.name		= <span class="string">&quot;cubic&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cubictcp_init</span>(<span class="params"><span class="keyword">struct</span> sock *sk</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> bictcp *ca = inet_csk_ca(sk);<span class="comment">//这个结构放在sock中，通过这样获取到</span></span><br><span class="line"></span><br><span class="line">	bictcp_reset(ca);<span class="comment">//全部置为0：memset(ca, 0, offsetof(struct bictcp, unused)); ca-&gt;found = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hystart)<span class="comment">//默认为1</span></span><br><span class="line">		bictcp_hystart_reset(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!hystart &amp;&amp; initial_ssthresh)</span><br><span class="line">		tcp_sk(sk)-&gt;snd_ssthresh = initial_ssthresh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>拥塞算法整体流程和驱动<br>虽然内核支持多种拥塞控制算法，但却受到协议栈调用的诸多限制，导致算法本身不是很灵活，也难以合适的接入，依赖外部流程从多个地方调用拥塞<br>控制算法模块，拥塞控制状态也是外部控制，耦合性太强，这里的外部是相对于拥塞控制模块而言，即协议栈；</li>
</ul>
<p>而且拥塞窗口不完全由拥塞控制算法控制，如在丢包状态下，协议栈也会更新拥塞控制窗口。</p>
<p>就驱动拥塞控制算法即，什么时候调用拥塞控制算法相关函数：</p>
<ol>
<li>收到ack，走tcp_ack</li>
<li>timer 触发重传，进入loss状态处理时；</li>
</ol>
<ul>
<li>拥塞算法的各个阶段解释：</li>
</ul>
<ol>
<li>慢启动：对应状态：TCP_CA_Open</li>
<li>拥塞避免：对应状态：TCP_CA_Open，当慢启动阶段的拥塞窗口到达慢启动阈值，ssthresh,此时进入拥塞避免阶段，增长速度放缓；</li>
<li>超时或异常,和在恢复中的阶段：对应状态：<br>TCP_CA_Disorder &#x3D; 1,<br>TCP_CA_CWR &#x3D; 2,<br>TCP_CA_Recovery &#x3D; 3,<br>TCP_CA_Loss &#x3D; 4<br>这几个阶段的代码解释：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sender&#x27;s congestion state indicating normal or abnormal situations</span></span><br><span class="line"><span class="comment"> * in the last round of packets sent. The state is driven by the ACK</span></span><br><span class="line"><span class="comment"> * information and timer events.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">tcp_ca_state</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Nothing bad has been observed recently.</span></span><br><span class="line"><span class="comment">	 * No apparent reordering, packet loss, or ECN marks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	TCP_CA_Open = <span class="number">0</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCPF_CA_Open	(1&lt;&lt;TCP_CA_Open) --0</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The sender enters disordered state when it has received DUPACKs or</span></span><br><span class="line"><span class="comment">	 * SACKs in the last round of packets sent. This could be due to packet</span></span><br><span class="line"><span class="comment">	 * loss or reordering but needs further information to confirm packets</span></span><br><span class="line"><span class="comment">	 * have been lost.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	TCP_CA_Disorder = <span class="number">1</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCPF_CA_Disorder (1<span class="string">&lt;&lt;TCP_CA_Disorder) --&gt;</span>10</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The sender enters Congestion Window Reduction (CWR) state when it</span></span><br><span class="line"><span class="comment">	 * has received ACKs with ECN-ECE marks, or has experienced congestion</span></span><br><span class="line"><span class="comment">	 * or packet discard on the sender host (e.g. qdisc).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	TCP_CA_CWR = <span class="number">2</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCPF_CA_CWR	(1<span class="string">&lt;&lt;TCP_CA_CWR) --&gt;</span> 100</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The sender is in fast recovery and retransmitting lost packets,</span></span><br><span class="line"><span class="comment">	 * typically triggered by ACK events.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	TCP_CA_Recovery = <span class="number">3</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCPF_CA_Recovery (1<span class="string">&lt;&lt;TCP_CA_Recovery) --&gt;</span>110</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The sender is in loss recovery triggered by retransmission timeout.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	TCP_CA_Loss = <span class="number">4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCPF_CA_Loss	(1<span class="string">&lt;&lt;TCP_CA_Loss) --&gt;</span> 1000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这几个状态下拥塞控制窗口基本不增长甚至减小，具体见下分析。但个人感觉这几个状态的处理和之间的转换界限不够清晰，所以我统一归到超时异常阶段的处理。</li>
</ol>
<ul>
<li>拥塞控制模块提供了哪些可实现控制的接口：<br>基于5.13.1,英文注释很清晰；<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tcp_congestion_ops</span> &#123;</span><br><span class="line"><span class="comment">/* fast path fields are put first to fill one cache line */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* return slow start threshold (required) */</span></span><br><span class="line">	<span class="title function_ invoke__">u32</span> (*ssthresh)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do new cwnd calculation (required) */</span></span><br><span class="line">	<span class="title function_ invoke__">void</span> (*cong_avoid)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk, <span class="type">u32</span> ack, <span class="type">u32</span> acked);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* call before changing ca_state (optional) */</span></span><br><span class="line">	<span class="title function_ invoke__">void</span> (*set_state)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk, <span class="type">u8</span> new_state);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* call when cwnd event occurs (optional) */</span></span><br><span class="line">	<span class="title function_ invoke__">void</span> (*cwnd_event)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk, <span class="keyword">enum</span> <span class="title class_">tcp_ca_event</span> ev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* call when ack arrives (optional) */</span></span><br><span class="line">	<span class="title function_ invoke__">void</span> (*in_ack_event)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk, <span class="type">u32</span> flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* hook for packet ack accounting (optional) */</span></span><br><span class="line">	<span class="title function_ invoke__">void</span> (*pkts_acked)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk, <span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">ack_sample</span> *sample);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* override sysctl_tcp_min_tso_segs */</span></span><br><span class="line">	<span class="title function_ invoke__">u32</span> (*min_tso_segs)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* call when packets are delivered to update cwnd and pacing rate,</span></span><br><span class="line"><span class="comment">	 * after all the ca_state processing. (optional)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="title function_ invoke__">void</span> (*cong_control)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk, <span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">rate_sample</span> *rs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* new value of cwnd after loss (required) */</span></span><br><span class="line">	<span class="title function_ invoke__">u32</span>  (*undo_cwnd)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk);</span><br><span class="line">	<span class="comment">/* returns the multiplier used in tcp_sndbuf_expand (optional) */</span></span><br><span class="line">	<span class="title function_ invoke__">u32</span> (*sndbuf_expand)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* control/slow paths put last */</span></span><br><span class="line">	<span class="comment">/* get info for inet_diag (optional) */</span></span><br><span class="line">	<span class="title function_ invoke__">size_t</span> (*get_info)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk, <span class="type">u32</span> ext, int *attr,</span><br><span class="line">			   <span class="keyword">union</span> <span class="title class_">tcp_cc_info</span> *info);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> 			name[TCP_CA_NAME_MAX];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">module</span>		*owner;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	list;</span><br><span class="line">	<span class="type">u32</span>			key;</span><br><span class="line">	<span class="type">u32</span>			flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize private data (optional) */</span></span><br><span class="line">	<span class="title function_ invoke__">void</span> (*init)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk);</span><br><span class="line">	<span class="comment">/* cleanup private data  (optional) */</span></span><br><span class="line">	<span class="title function_ invoke__">void</span> (*release)(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk);</span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br></pre></td></tr></table></figure></li>
<li>拥塞控制各个阶段代码简要分析：</li>
</ul>
<ol>
<li><p>慢启动：<br>最开始的时候是TCP_CA_Open，虽然后面的状态也会调用这个接口，但是判断后实际不会去增长拥塞窗口。<br>由ack驱动：在ack对seq和ack_seq检查以及其他检查通过后，调用<br>tcp_cong_control(sk, ack, delivered, flag, sack_state.rate);&#x2F;&#x2F;拥塞控制处理</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The &quot;ultimate&quot; congestion control function that aims to replace the rigid</span></span><br><span class="line"><span class="comment"> * cwnd increase and decrease control (tcp_cong_avoid,tcp_*cwnd_reduction).</span></span><br><span class="line"><span class="comment"> * It&#x27;s called toward the end of processing an ACK with precise rate</span></span><br><span class="line"><span class="comment"> * information. All transmission or retransmission are delayed afterwards.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> void <span class="title function_ invoke__">tcp_cong_control</span>(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk, <span class="type">u32</span> ack, <span class="type">u32</span> acked_sacked,</span><br><span class="line">			     int flag, <span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">rate_sample</span> *rs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">inet_connection_sock</span> *icsk = <span class="title function_ invoke__">inet_csk</span>(sk);</span><br><span class="line"></span><br><span class="line">	<span class="title function_ invoke__">if</span> (icsk<span class="punctuation">-&gt;</span>icsk_ca_ops<span class="punctuation">-&gt;</span>cong_control) &#123;</span><br><span class="line">		icsk<span class="punctuation">-&gt;</span>icsk_ca_ops<span class="punctuation">-&gt;</span><span class="title function_ invoke__">cong_control</span>(sk, rs);<span class="comment">//有些拥塞算法实现了这个接口，接管更多控制</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_ invoke__">if</span> (<span class="title function_ invoke__">tcp_in_cwnd_reduction</span>(sk)) &#123; <span class="comment">//减小拥塞控制窗口</span></span><br><span class="line">		<span class="comment">/* Reduce cwnd if state mandates */</span></span><br><span class="line">		<span class="title function_ invoke__">tcp_cwnd_reduction</span>(sk, acked_sacked, rs<span class="punctuation">-&gt;</span>losses, flag);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="title function_ invoke__">if</span> (<span class="title function_ invoke__">tcp_may_raise_cwnd</span>(sk, flag)) &#123; <span class="comment">//增大拥塞控制窗口</span></span><br><span class="line">		<span class="comment">/* Advance cwnd if state allows */</span></span><br><span class="line">		<span class="title function_ invoke__">tcp_cong_avoid</span>(sk, ack, acked_sacked);<span class="comment">//会进一步调用拥塞控制算法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_ invoke__">tcp_update_pacing_rate</span>(sk);<span class="comment">//这个应该bbr用的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> inline <span class="type">bool</span> <span class="title function_ invoke__">tcp_in_cwnd_reduction</span>(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">sock</span> *sk)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="title function_ invoke__">return</span> (TCPF_CA_CWR | TCPF_CA_Recovery) &amp; </span><br><span class="line">	       (<span class="number">1</span> &lt;&lt; <span class="title function_ invoke__">inet_csk</span>(sk)<span class="punctuation">-&gt;</span>icsk_ca_state);<span class="comment">//(0b100 | 0b110) &amp; (1&lt;&lt;state),即为 0b110 &amp; (1&lt;&lt;state)由上分析只有</span></span><br><span class="line">           (disorder,cwr,recovery)会返回<span class="literal">true</span>，open和loss返回<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void <span class="title function_ invoke__">tcp_cong_avoid</span>(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk, <span class="type">u32</span> ack, <span class="type">u32</span> acked)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">inet_connection_sock</span> *icsk = <span class="title function_ invoke__">inet_csk</span>(sk);</span><br><span class="line"></span><br><span class="line">	icsk<span class="punctuation">-&gt;</span>icsk_ca_ops<span class="punctuation">-&gt;</span><span class="title function_ invoke__">cong_avoid</span>(sk, ack, acked);<span class="comment">//拥塞控制算法模块的慢启动和拥塞避免函数</span></span><br><span class="line">	<span class="title function_ invoke__">tcp_sk</span>(sk)<span class="punctuation">-&gt;</span>snd_cwnd_stamp = tcp_jiffies32;<span class="comment">//记下时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拥塞避免：调用的接口和时机同上;<br>但有个阈值更新的函数，会影响进入拥塞避免的时机：<br>例如，在进入丢包状态：<br>void tcp_enter_loss(struct sock *sk)</p>
</li>
</ol>
<p>–&gt;tp-&gt;snd_ssthresh &#x3D; icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk);&#x2F;&#x2F;这里会调用拥塞控制模块实现的接口，一般会去更新慢启动阈值。</p>
<ol start="3">
<li>超时或异常,和在恢复中的阶段：对应状态：<br>a: TCP_CA_Disorder &#x3D; 1<br>如何进入：在即将恢复进入TCP_CA_Open状态前，会可能进入Disorder;<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">tcp_try_to_open</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">case TCP_CA_Recovery:</span><br><span class="line">    tcp_try_keep_open</span><br><span class="line">static void tcp<span class="constructor">_try_keep_open(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> tcp_sock *tp = tcp<span class="constructor">_sk(<span class="params">sk</span>)</span>;</span><br><span class="line">	<span class="built_in">int</span> state = TCP_CA_Open;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcp<span class="constructor">_left_out(<span class="params">tp</span>)</span><span class="operator"> || </span>tcp<span class="constructor">_any_retrans_done(<span class="params">sk</span>)</span>)</span><br><span class="line">		state = TCP_CA_Disorder;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (inet<span class="constructor">_csk(<span class="params">sk</span>)</span>-&gt;icsk_ca_state != state) &#123;</span><br><span class="line">		tcp<span class="constructor">_set_ca_state(<span class="params">sk</span>, <span class="params">state</span>)</span>;</span><br><span class="line">		tp-&gt;high_seq = tp-&gt;snd_nxt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在这个状态下处理走default,会尝试进入Open或recovery:</span><br><span class="line">tcp_ack-&gt;</span><br><span class="line">  static void tcp_fastretrans_alert</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* E. Process state. */</span><span class="comment">//处理拥塞控制的各个状态;</span></span><br><span class="line">	switch (icsk-&gt;icsk_ca_state) &#123;</span><br><span class="line">    default:</span><br><span class="line">		<span class="keyword">if</span> (tcp<span class="constructor">_is_reno(<span class="params">tp</span>)</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag &amp; FLAG_SND_UNA_ADVANCED)</span><br><span class="line">				tcp<span class="constructor">_reset_reno_sack(<span class="params">tp</span>)</span>;</span><br><span class="line">			tcp<span class="constructor">_add_reno_sack(<span class="params">sk</span>, <span class="params">num_dupack</span>, <span class="params">ece_ack</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (icsk-&gt;icsk_ca_state &lt;= TCP_CA_Disorder)</span><br><span class="line">			tcp<span class="constructor">_try_undo_dsack(<span class="params">sk</span>)</span>;</span><br><span class="line"></span><br><span class="line">		tcp<span class="constructor">_identify_packet_loss(<span class="params">sk</span>, <span class="params">ack_flag</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (!tcp<span class="constructor">_time_to_recover(<span class="params">sk</span>, <span class="params">flag</span>)</span>) &#123;</span><br><span class="line">			tcp<span class="constructor">_try_to_open(<span class="params">sk</span>, <span class="params">flag</span>)</span>;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* MTU probe failure: don&#x27;t reduce cwnd */</span></span><br><span class="line">		<span class="keyword">if</span> (icsk-&gt;icsk_ca_state &lt; TCP_CA_CWR<span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">		    </span>icsk-&gt;icsk_mtup.probe_size<span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">		    </span>tp-&gt;snd_una<span class="operator"> == </span>tp-&gt;mtu_probe.probe_seq_start) &#123;</span><br><span class="line">			tcp<span class="constructor">_mtup_probe_failed(<span class="params">sk</span>)</span>;</span><br><span class="line">			<span class="comment">/* Restores the reduction we did in tcp_mtup_probe() */</span></span><br><span class="line">			tp-&gt;snd_cwnd++;</span><br><span class="line">			tcp<span class="constructor">_simple_retransmit(<span class="params">sk</span>)</span>;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Otherwise enter Recovery state */</span></span><br><span class="line">		tcp<span class="constructor">_enter_recovery(<span class="params">sk</span>, <span class="params">ece_ack</span>)</span>;</span><br><span class="line">		fast_rexmit = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>b TCP_CA_CWR &#x3D; 2<br>什么时候进入cwr状态：<br>发送失败或者收到显示ecn ，进入cwr拥塞控制窗口减少的状态； </p>
<ol>
<li>tcp_transmit_skb-&gt;若发送失败&gt;0 tcp_enter_cwr(); </li>
<li>tcp_ack-&gt;tcp_fastretrans_alert()-&gt;tcp_try_to_open当flag带ecn时-&gt;tcp_enter_cwr <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Enter CWR state. Disable cwnd undo since congestion is proven with ECN */</span></span><br><span class="line">void tcp<span class="constructor">_enter_cwr(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> tcp_sock *tp = tcp<span class="constructor">_sk(<span class="params">sk</span>)</span>;</span><br><span class="line"></span><br><span class="line">	tp-&gt;prior_ssthresh = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (inet<span class="constructor">_csk(<span class="params">sk</span>)</span>-&gt;icsk_ca_state &lt; TCP_CA_CWR) &#123;</span><br><span class="line">		tp-&gt;undo_marker = <span class="number">0</span>;</span><br><span class="line">		tcp<span class="constructor">_init_cwnd_reduction(<span class="params">sk</span>)</span>;</span><br><span class="line">		tcp<span class="constructor">_set_ca_state(<span class="params">sk</span>, TCP_CA_CWR)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">在这个状态下的处理：</span><br><span class="line"><span class="number">1</span>) 尝试状态终结：</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!before(tp-&gt;snd_una, tp-&gt;high_seq)) &#123;<span class="comment">//high_seq是拥塞时的snd_nxt即最后一个发送未确认</span></span><br><span class="line">	<span class="comment">//标识重传队列结尾，这个条件时snd_una&gt;tp-&gt;hith_seq</span></span><br><span class="line">		switch (icsk-&gt;icsk_ca_state) &#123;</span><br><span class="line">		case TCP_CA_CWR:</span><br><span class="line">			<span class="comment">/* CWR is to be held something *above* high_seq</span></span><br><span class="line"><span class="comment">			 * is ACKed for CWR bit to reach receiver. */</span></span><br><span class="line">			<span class="keyword">if</span> (tp-&gt;snd_una != tp-&gt;high_seq) &#123;<span class="comment">//都ack了，可以重入open</span></span><br><span class="line">				tcp<span class="constructor">_end_cwnd_reduction(<span class="params">sk</span>)</span>;<span class="comment">//重置慢启动阈值等</span></span><br><span class="line">				tcp<span class="constructor">_set_ca_state(<span class="params">sk</span>, TCP_CA_Open)</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line"><span class="number">2</span>) 状态处理：</span><br><span class="line">switch (icsk-&gt;icsk_ca_state) &#123;</span><br><span class="line">  default:同上个状态的处理</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">这个状态下对拥塞窗口的处理见tcp_cwnd_reduction</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>c TCP_CA_Recovery &#x3D; 3:<br>如何进入：不考虑rack的话，从其他状态转换而来：<br>tcp_enter_recovery</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp_fastretrans_alert-&gt;</span><br><span class="line">  default:</span><br><span class="line">   tcp<span class="constructor">_enter_recovery(<span class="params">sk</span>, <span class="params">ece_ack</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>状态处理：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 尝试终结：</span><br><span class="line">case TCP_CA_Recovery:<span class="comment">//正常会重入open，在reno且snd_una==high_seq下会再等，high_seq即snd_nxt所在seq</span></span><br><span class="line">			<span class="keyword">if</span> (tcp<span class="constructor">_is_reno(<span class="params">tp</span>)</span>)</span><br><span class="line">				tcp<span class="constructor">_reset_reno_sack(<span class="params">tp</span>)</span>;</span><br><span class="line">			<span class="keyword">if</span> (tcp<span class="constructor">_try_undo_recovery(<span class="params">sk</span>)</span>)</span><br><span class="line">				return;</span><br><span class="line">			tcp<span class="constructor">_end_cwnd_reduction(<span class="params">sk</span>)</span>;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="number">2</span>) 状态处理：</span><br><span class="line"><span class="comment">/* E. Process state. */</span><span class="comment">//处理拥塞控制的各个状态;</span></span><br><span class="line">	switch (icsk-&gt;icsk_ca_state) &#123;</span><br><span class="line">	case TCP_CA_Recovery:</span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; FLAG_SND_UNA_ADVANCED)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tcp<span class="constructor">_is_reno(<span class="params">tp</span>)</span>)</span><br><span class="line">				tcp<span class="constructor">_add_reno_sack(<span class="params">sk</span>, <span class="params">num_dupack</span>, <span class="params">ece_ack</span>)</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (tcp<span class="constructor">_try_undo_partial(<span class="params">sk</span>, <span class="params">prior_snd_una</span>)</span>)</span><br><span class="line">				return;</span><br><span class="line">			<span class="comment">/* Partial ACK arrived. Force fast retransmit. */</span></span><br><span class="line">			do_lost = tcp<span class="constructor">_force_fast_retransmit(<span class="params">sk</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tcp<span class="constructor">_try_undo_dsack(<span class="params">sk</span>)</span>) &#123;</span><br><span class="line">			tcp<span class="constructor">_try_keep_open(<span class="params">sk</span>)</span>;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		tcp<span class="constructor">_identify_packet_loss(<span class="params">sk</span>, <span class="params">ack_flag</span>)</span>;</span><br><span class="line">		break;</span><br></pre></td></tr></table></figure>

<p>d TCP_CA_Loss &#x3D; 4<br>如何进入： 触发重传定时器时：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Enter Loss state. */</span></span><br><span class="line">void tcp_enter_loss(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">	const struct inet_connection_sock *icsk = inet_csk(sk);</span><br><span class="line">	struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	struct net *net = sock_net(sk);</span><br><span class="line">	<span class="function"><span class="title">bool</span> new_recovery = icsk-&gt;</span>icsk_ca_state &lt; TCP_CA_Recovery;</span><br><span class="line"></span><br><span class="line">	tcp_timeout_mark_lost(sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reduce ssthresh if it has not yet been made inside this window. */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (icsk-&gt;</span>icsk_ca_state &lt;= TCP_CA_Disorder ||</span><br><span class="line">	    !<span class="function"><span class="title">after</span>(tp-&gt;</span><span class="function"><span class="title">high_seq</span>, tp-&gt;</span>snd_una) ||</span><br><span class="line">	    (<span class="function"><span class="title">icsk</span>-&gt;</span><span class="function"><span class="title">icsk_ca_state</span> == TCP_CA_Loss &amp;&amp; !icsk-&gt;</span>icsk_retransmits)) &#123;</span><br><span class="line">		<span class="function"><span class="title">tp</span>-&gt;</span>prior_ssthresh = tcp_current_ssthresh(sk);</span><br><span class="line">		<span class="function"><span class="title">tp</span>-&gt;</span><span class="function"><span class="title">prior_cwnd</span> = tp-&gt;</span>snd_cwnd;</span><br><span class="line">		<span class="function"><span class="title">tp</span>-&gt;</span><span class="function"><span class="title">snd_ssthresh</span> = icsk-&gt;</span><span class="function"><span class="title">icsk_ca_ops</span>-&gt;</span>ssthresh(sk);<span class="comment">//这里</span></span><br><span class="line">		tcp_ca_event(sk, CA_EVENT_LOSS);</span><br><span class="line">		tcp_init_undo(tp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">tp</span>-&gt;</span>snd_cwnd	   = tcp_packets_in_flight(tp) + <span class="number">1</span>;<span class="comment">//输出的包-确认包+重传的包，重置拥塞窗口</span></span><br><span class="line">	<span class="function"><span class="title">tp</span>-&gt;</span>snd_cwnd_cnt   = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="title">tp</span>-&gt;</span>snd_cwnd_stamp = tcp_jiffies32;<span class="comment">//重置拥塞窗口最大值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Timeout in disordered state after receiving substantial DUPACKs</span></span><br><span class="line"><span class="comment">	 * suggests that the degree of reordering is over-estimated.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (icsk-&gt;</span>icsk_ca_state &lt;= TCP_CA_Disorder &amp;&amp;</span><br><span class="line">	    <span class="function"><span class="title">tp</span>-&gt;</span><span class="function"><span class="title">sacked_out</span> &gt;= net-&gt;</span>ipv4.sysctl_tcp_reordering)</span><br><span class="line">		<span class="function"><span class="title">tp</span>-&gt;</span><span class="function"><span class="title">reordering</span> = min_t(unsigned int, tp-&gt;</span>reordering,</span><br><span class="line">				       <span class="function"><span class="title">net</span>-&gt;</span>ipv4.sysctl_tcp_reordering);</span><br><span class="line">	tcp_set_ca_state(sk, TCP_CA_Loss);</span><br><span class="line">	<span class="function"><span class="title">tp</span>-&gt;</span><span class="function"><span class="title">high_seq</span> = tp-&gt;</span>snd_nxt;</span><br><span class="line">	tcp_ecn_queue_cwr(tp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* F-RTO RFC5682 sec 3.1 step 1: retransmit SND.UNA if no previous</span></span><br><span class="line"><span class="comment">	 * loss recovery is underway except recurring timeout(s) on</span></span><br><span class="line"><span class="comment">	 * the same SND.UNA (sec 3.2). Disable F-RTO on path MTU probing</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="title">tp</span>-&gt;</span><span class="function"><span class="title">frto</span> = net-&gt;</span>ipv4.sysctl_tcp_frto &amp;&amp;</span><br><span class="line">		   (<span class="function"><span class="title">new_recovery</span> || icsk-&gt;</span>icsk_retransmits) &amp;&amp;</span><br><span class="line">		   !<span class="function"><span class="title">inet_csk</span>(sk)-&gt;</span>icsk_mtup.probe_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>状态处理：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case TCP_CA_Loss:</span><br><span class="line">		tcp<span class="constructor">_process_loss(<span class="params">sk</span>, <span class="params">flag</span>, <span class="params">num_dupack</span>, <span class="params">rexmit</span>)</span>;</span><br><span class="line">		tcp<span class="constructor">_identify_packet_loss(<span class="params">sk</span>, <span class="params">ack_flag</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (!(icsk-&gt;icsk_ca_state<span class="operator"> == </span>TCP_CA_Open<span class="operator"> ||</span></span><br><span class="line"><span class="operator">		      </span>(*ack_flag &amp; FLAG_LOST_RETRANS)))</span><br><span class="line">			return;</span><br><span class="line">		<span class="comment">/* Change state if cwnd is undone or retransmits are lost */</span></span><br><span class="line">		fallthrough;<span class="comment">//注意这里没break,会继续处理default:</span></span><br></pre></td></tr></table></figure>
<p>PS：linux定时器机制和重传定时器简单分析：<br>实现主要在timer.c,由时钟软中断触发，检查是否超时，再调用回调；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">创建：</span><br><span class="line">void <span class="title function_ invoke__">tcp_init_xmit_timers</span>(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk)</span><br><span class="line">	<span class="title function_ invoke__">inet_csk_init_xmit_timers</span>(sk, &amp;tcp_write_timer, &amp;tcp_delack_timer,</span><br><span class="line">				  &amp;tcp_keepalive_timer);</span><br><span class="line">           <span class="title function_ invoke__">timer_setup</span>(&amp;icsk<span class="punctuation">-&gt;</span>icsk_retransmit_timer, retransmit_handler, <span class="number">0</span>);</span><br><span class="line">             __init_timer((timer), (callback), (flags))<span class="punctuation">-&gt;</span>void <span class="title function_ invoke__">init_timer_key</span>(<span class="keyword">struct</span> <span class="title class_">timer_list</span> *timer..) <span class="comment">//timer.c</span></span><br><span class="line">             </span><br><span class="line"><span class="keyword">static</span> void <span class="title function_ invoke__">do_init_timer</span>(<span class="keyword">struct</span> <span class="title class_">timer_list</span> *timer,</span><br><span class="line">			  <span class="title function_ invoke__">void</span> (*func)(<span class="keyword">struct</span> <span class="title class_">timer_list</span> *),</span><br><span class="line">			  unsigned int flags,</span><br><span class="line">			  <span class="keyword">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> <span class="title class_">lock_class_key</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">	timer<span class="punctuation">-&gt;</span>entry.pprev = NULL;</span><br><span class="line">	timer<span class="punctuation">-&gt;</span>function = func;</span><br><span class="line">	<span class="title function_ invoke__">if</span> (<span class="title function_ invoke__">WARN_ON_ONCE</span>(flags &amp; ~TIMER_INIT_FLAGS))</span><br><span class="line">		flags &amp;= TIMER_INIT_FLAGS;</span><br><span class="line">	timer<span class="punctuation">-&gt;</span>flags = flags | <span class="title function_ invoke__">raw_smp_processor_id</span>();</span><br><span class="line">	<span class="title function_ invoke__">lockdep_init_map</span>(&amp;timer<span class="punctuation">-&gt;</span>lockdep_map, name, key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">软中断到达和触发：</span><br><span class="line">在timer.c中 </span><br><span class="line"><span class="keyword">static</span> __latent_entropy void <span class="title function_ invoke__">run_timer_softirq</span>(<span class="keyword">struct</span> <span class="title class_">softirq_action</span> *h)</span><br><span class="line">   <span class="punctuation">-&gt;</span> __run_timers</span><br><span class="line">    <span class="punctuation">-&gt;</span><span class="keyword">static</span> void <span class="title function_ invoke__">expire_timers</span>(<span class="keyword">struct</span> <span class="title class_">timer_base</span> *base, <span class="keyword">struct</span> <span class="title class_">hlist_head</span> *head)</span><br><span class="line">会调用回调函数tcp_write_timer_handler: <span class="keyword">fn</span> = timer<span class="punctuation">-&gt;</span>function;<span class="punctuation">-&gt;</span><span class="title function_ invoke__">call_timer_fn</span>(timer, <span class="keyword">fn</span>, baseclk);</span><br><span class="line">如之前注册的函数：tcp_write_timer<span class="punctuation">-&gt;</span>tcp_write_timer_handler会被调用；</span><br></pre></td></tr></table></figure>

<p>至此，可以总结为：<br>在open下做慢启动和拥塞避免，此时拥塞窗口增长；<br>在disorder&#x2F;cwr&#x2F;recovery,统一tcp_cwnd_reduction进行拥塞窗口减量减少；<br>在loss，会有单独的拥塞窗口更新，见上。<br>各个状态处理对应事项，并可以重回open正常状态。 </p>
<p>而各个拥塞控制算法，控制的是：<br>1 慢启动、拥塞避免的增长逻辑<br>2 实现了cong_control接口的，可以控制拥塞窗口减小逻辑；<br>3 慢启动阈值更新逻辑；<br>对拥塞控制状态转换和处理则无法控制。</p>
<p>就着上面的分析，看看具体的拥塞控制算法；</p>
<h4 id="cubic拥塞控制算法"><a href="#cubic拥塞控制算法" class="headerlink" title="cubic拥塞控制算法"></a>cubic拥塞控制算法</h4><p>cubic相比于之前的拥塞控制算法，主要是通过更激进的拥塞窗口增长逻辑来提高拥塞下的网络利用率;<br>网上有很多文章翻译了rfc,例如<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d4db63e2b519">https://www.jianshu.com/p/d4db63e2b519</a><br>这里不再冗余；<br>直接看对应代码； tcp_cubic.c:</p>
<ul>
<li><p>cubic实现的接口：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static struct tcp_congestion_ops cubictcp __read_mostly = &#123;</span><br><span class="line">	<span class="string">.init</span>		= cubictcp_init,<span class="string">//</span>初始化</span><br><span class="line">	<span class="string">.ssthresh</span>	= cubictcp_recalc_ssthresh,<span class="string">//</span>慢启动阈值更新</span><br><span class="line">	<span class="string">.cong_avoid</span>	= cubictcp_cong_avoid, <span class="string">//</span>慢启动和拥塞避免窗口更新</span><br><span class="line">	<span class="string">.set_state</span>	= cubictcp_state,<span class="string">//</span>状态转换的调用函数</span><br><span class="line">	<span class="string">.undo_cwnd</span>	= tcp_reno_undo_cwnd,<span class="string">//</span> new value of cwnd after loss <span class="params">(required)</span> </span><br><span class="line">	<span class="string">.cwnd_event</span>	= cubictcp_cwnd_event,<span class="string">//cwnd</span> 事件发生处理函数</span><br><span class="line">	<span class="string">.pkts_acked</span>     = cubictcp_acked,<span class="string">//packet</span> ack accounting</span><br><span class="line">	<span class="string">.owner</span>		= THIS_MODULE,</span><br><span class="line">	<span class="string">.name</span>		= <span class="string">&quot;cubic&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void cubictcp<span class="constructor">_init(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> bictcp *ca = inet<span class="constructor">_csk_ca(<span class="params">sk</span>)</span>;<span class="comment">//这个结构放在sock中，通过这样获取到</span></span><br><span class="line"></span><br><span class="line">	bictcp<span class="constructor">_reset(<span class="params">ca</span>)</span>;<span class="comment">//全部置为0：memset(ca, 0, offsetof(struct bictcp, unused)); ca-&gt;found = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hystart)<span class="comment">//默认为1</span></span><br><span class="line">		bictcp<span class="constructor">_hystart_reset(<span class="params">sk</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!hystart<span class="operator"> &amp;&amp; </span>initial_ssthresh)</span><br><span class="line">		tcp<span class="constructor">_sk(<span class="params">sk</span>)</span>-&gt;snd_ssthresh = initial_ssthresh;</span><br><span class="line">&#125;</span><br><span class="line">static inline void bictcp<span class="constructor">_hystart_reset(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> tcp_sock *tp = tcp<span class="constructor">_sk(<span class="params">sk</span>)</span>;</span><br><span class="line">	<span class="keyword">struct</span> bictcp *ca = inet<span class="constructor">_csk_ca(<span class="params">sk</span>)</span>;</span><br><span class="line"></span><br><span class="line">	ca-&gt;round_start = ca-&gt;last_ack = bictcp<span class="constructor">_clock_us(<span class="params">sk</span>)</span>;<span class="comment">//tcp_sk(sk)-&gt;tcp_mstamp;//最近接收或发送的包的时间戳，用于计算rtt</span></span><br><span class="line">	ca-&gt;end_seq = tp-&gt;snd_nxt;<span class="comment">//下一个我们发送的seqnum</span></span><br><span class="line">	ca-&gt;curr_rtt = ~<span class="number">0</span>U;</span><br><span class="line">	ca-&gt;sample_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>慢启动和拥塞避免</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">每次收到ack，调用tcp_ack会进而调用这个，来更新拥塞窗口；</span><br><span class="line">static void cubictcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)<span class="comment">//acked为当前的ack包acked或sacked了多少个包。由于延迟确认机制，一个ack可以acked多个包</span></span><br><span class="line">&#123;</span><br><span class="line">	struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	struct bictcp *ca = inet_csk_ca(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tcp_is_cwnd_limited(sk))<span class="comment">//当发送速率比较慢，即当前拥塞窗口足以应对窗口滑动和包发送速率，此时没必要增大拥塞窗口；</span></span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcp_in_slow_start(tp)) &#123;</span><br><span class="line">		<span class="function"><span class="title">if</span> (hystart &amp;&amp; after(ack, ca-&gt;</span>end_seq))<span class="comment">//ack在拥塞记录的end_seq后了，重置拥塞的相关参数；</span></span><br><span class="line">			bictcp_hystart_reset(sk);</span><br><span class="line">		acked = tcp_slow_start(tp, acked);</span><br><span class="line">		<span class="keyword">if</span> (!acked) <span class="comment">//没到慢启动阈值，返回</span></span><br><span class="line">			return;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">bictcp_update</span>(ca, tp-&gt;</span>snd_cwnd, acked);<span class="comment">//拥塞避免</span></span><br><span class="line">	<span class="function"><span class="title">tcp_cong_avoid_ai</span>(tp, ca-&gt;</span>cnt, acked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We follow the spirit本意本质 of RFC2861 to validate cwnd but implement a more</span></span><br><span class="line"><span class="comment"> * flexible approach. The RFC suggests cwnd should not be raised unless</span></span><br><span class="line"><span class="comment"> * it was fully used previously. 用满了才增加窗口，And that&#x27;s exactly what we do in</span></span><br><span class="line"><span class="comment"> * congestion avoidance mode. But in slow start we allow cwnd to grow</span></span><br><span class="line"><span class="comment"> * as long as the application has used half the cwnd.//但在慢启动下，我们允许在用了窗口一半时就增长</span></span><br><span class="line"><span class="comment"> * Example :</span></span><br><span class="line"><span class="comment"> *    cwnd is 10 (IW10), but application sends 9 frames.</span></span><br><span class="line"><span class="comment"> *    We allow cwnd to reach 18 when all frames are ACKed.</span></span><br><span class="line"><span class="comment"> * This check is safe because it&#x27;s as aggressive as slow start which already</span></span><br><span class="line"><span class="comment"> * risks 100% overshoot. The advantage is that we discourage application to</span></span><br><span class="line"><span class="comment"> * either send more filler packets or data to artificially blow up the cwnd</span></span><br><span class="line"><span class="comment"> * usage, and allow application-limited process to probe bw more aggressively.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static inline bool tcp_is_cwnd_limited(const struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">	const struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If in slow start, ensure cwnd grows to twice what was ACKed. */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (tcp_in_slow_start(tp))//如何判断在慢启动：tp-&gt;</span><span class="function"><span class="title">snd_cwnd</span> &lt; tp-&gt;</span>snd_ssthresh; 拥塞窗口小于阈值</span><br><span class="line">		<span class="function"><span class="title">return</span> tp-&gt;</span><span class="function"><span class="title">snd_cwnd</span> &lt; 2 * tp-&gt;</span>max_packets_out;<span class="comment">//当窗口小于max_packets_out的两倍时，不做增长；</span></span><br><span class="line">        <span class="comment">//max_packets_out:在最后一个窗口中发送的最大包数。</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">return</span> tp-&gt;</span>is_cwnd_limited;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tcp_cong.c</span><br><span class="line"><span class="comment">/* Slow start is used when congestion window is no greater than the slow start</span></span><br><span class="line"><span class="comment"> * threshold. We base on RFC2581 and also handle stretch ACKs properly.</span></span><br><span class="line"><span class="comment"> * We do not implement RFC3465 Appropriate Byte Counting (ABC) per se but</span></span><br><span class="line"><span class="comment"> * something better;) a packet is only considered (s)acked in its entirety to</span></span><br><span class="line"><span class="comment"> * defend the ACK attacks described in the RFC. Slow start processes a stretch</span></span><br><span class="line"><span class="comment"> * ACK of degree N as if N acks of degree 1 are received back to back except</span></span><br><span class="line"><span class="comment"> * ABC caps N to 2. Slow start exits when cwnd grows over ssthresh and</span></span><br><span class="line"><span class="comment"> * returns the leftover acks to adjust cwnd in congestion avoidance mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//慢启动被用于当拥塞窗口不大于慢启动阈值时，我们基于2581 也处理，即cubic并未改变慢启动逻辑</span></span><br><span class="line">u32 tcp_slow_start(struct tcp_sock *tp, u32 acked)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="title">u32</span> cwnd = min(tp-&gt;</span><span class="function"><span class="title">snd_cwnd</span> + acked, tp-&gt;</span>snd_ssthresh);<span class="comment">//取拥塞窗口+acked，拥塞阈值的最小值作为cwnd</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">acked</span> -= cwnd - tp-&gt;</span>snd_cwnd;<span class="comment">//一般来讲是0，否则当选择阈值时，则&gt;0，即此时已经到阈值了</span></span><br><span class="line">	<span class="function"><span class="title">tp</span>-&gt;</span><span class="function"><span class="title">snd_cwnd</span> = min(cwnd, tp-&gt;</span>snd_cwnd_clamp);<span class="comment">//u32	snd_cwnd_clamp; /* Do not allow snd_cwnd to grow above this */</span></span><br><span class="line"></span><br><span class="line">	return acked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对cubic来说，进入拥塞避免阶段，会采用另一种方式去计算没收到一个acked应该增加多少大小窗口</span></span><br><span class="line"><span class="comment">//有三种情况：凹区域，凸区域，tcp友好区域；具体：https://www.jianshu.com/p/d4db63e2b519 ，以下函数就是为了计算每收到一个ACK，cwnd 必须增加的数量，</span></span><br><span class="line"><span class="comment">//通过识别是哪种情况，来增加；</span></span><br><span class="line"><span class="comment">// ca-&gt;cnt即是要求。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Compute congestion window to use.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static inline void bictcp_update(struct bictcp *ca, u32 cwnd, u32 acked)</span><br><span class="line">&#123;</span><br><span class="line">	u32 delta, bic_target, max_cnt;</span><br><span class="line">	u64 offs, t;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">ca</span>-&gt;</span>ack_cnt += acked;	<span class="comment">/* count the number of ACKed packets */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">if</span> (ca-&gt;</span>last_cwnd == cwnd &amp;&amp;</span><br><span class="line">	    (<span class="function"><span class="title">s32</span>)(tcp_jiffies32 - ca-&gt;</span>last_time) &lt;= HZ / <span class="number">32</span>)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The CUBIC function can update ca-&gt;cnt at most once per jiffy.</span></span><br><span class="line"><span class="comment">	 * On all cwnd reduction events, ca-&gt;epoch_start is set to 0,</span></span><br><span class="line"><span class="comment">	 * which will force a recalculation of ca-&gt;cnt.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (ca-&gt;</span><span class="function"><span class="title">epoch_start</span> &amp;&amp; tcp_jiffies32 == ca-&gt;</span>last_time)</span><br><span class="line">		goto tcp_friendliness;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">ca</span>-&gt;</span>last_cwnd = cwnd;</span><br><span class="line">	<span class="function"><span class="title">ca</span>-&gt;</span>last_time = tcp_jiffies32;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">if</span> (ca-&gt;</span>epoch_start == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="function"><span class="title">ca</span>-&gt;</span>epoch_start = tcp_jiffies32;	<span class="comment">/* record beginning */</span></span><br><span class="line">		<span class="function"><span class="title">ca</span>-&gt;</span>ack_cnt = acked;			<span class="comment">/* start counting */</span></span><br><span class="line">		<span class="function"><span class="title">ca</span>-&gt;</span>tcp_cwnd = cwnd;			<span class="comment">/* syn with cubic */</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">if</span> (ca-&gt;</span>last_max_cwnd &lt;= cwnd) &#123;</span><br><span class="line">			<span class="function"><span class="title">ca</span>-&gt;</span>bic_K = <span class="number">0</span>;</span><br><span class="line">			<span class="function"><span class="title">ca</span>-&gt;</span>bic_origin_point = cwnd;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Compute new K based on</span></span><br><span class="line"><span class="comment">			 * (wmax-cwnd) * (srtt&gt;&gt;3 / HZ) / c * 2^(3*bictcp_HZ)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="function"><span class="title">ca</span>-&gt;</span>bic_K = cubic_root(cube_factor</span><br><span class="line">					       * (<span class="function"><span class="title">ca</span>-&gt;</span>last_max_cwnd - cwnd));</span><br><span class="line">			<span class="function"><span class="title">ca</span>-&gt;</span><span class="function"><span class="title">bic_origin_point</span> = ca-&gt;</span>last_max_cwnd;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cubic function - calc*/</span></span><br><span class="line">	<span class="comment">/* calculate c * time^3 / rtt,</span></span><br><span class="line"><span class="comment">	 *  while considering overflow in calculation of time^3</span></span><br><span class="line"><span class="comment">	 * (so time^3 is done by using 64 bit)</span></span><br><span class="line"><span class="comment">	 * and without the support of division of 64bit numbers</span></span><br><span class="line"><span class="comment">	 * (so all divisions are done by using 32 bit)</span></span><br><span class="line"><span class="comment">	 *  also NOTE the unit of those veriables</span></span><br><span class="line"><span class="comment">	 *	  time  = (t - K) / 2^bictcp_HZ</span></span><br><span class="line"><span class="comment">	 *	  c = bic_scale &gt;&gt; 10</span></span><br><span class="line"><span class="comment">	 * rtt  = (srtt &gt;&gt; 3) / HZ</span></span><br><span class="line"><span class="comment">	 * !!! The following code does not have overflow problems,</span></span><br><span class="line"><span class="comment">	 * if the cwnd &lt; 1 million packets !!!</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">t</span> = (s32)(tcp_jiffies32 - ca-&gt;</span>epoch_start);</span><br><span class="line">	<span class="function"><span class="title">t</span> += usecs_to_jiffies(ca-&gt;</span>delay_min);</span><br><span class="line">	<span class="comment">/* change the unit from HZ to bictcp_HZ */</span></span><br><span class="line">	t <span class="string">&lt;&lt;= BICTCP_HZ;</span></span><br><span class="line"><span class="string">	do_div(t, HZ);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if (t &lt; ca-&gt;bic_K)		/* t - K */</span></span><br><span class="line"><span class="string">		offs = ca-&gt;bic_K - t;</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		offs = t - ca-&gt;bic_K;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	/* c/rtt * (t-K)^3 */</span></span><br><span class="line"><span class="string">	delta = (cube_rtt_scale * offs * offs * offs) &gt;&gt;</span> (<span class="number">10</span>+<span class="number">3</span>*BICTCP_HZ);</span><br><span class="line">	<span class="function"><span class="title">if</span> (t &lt; ca-&gt;</span>bic_K)                            <span class="comment">/* below origin*/</span></span><br><span class="line">		<span class="function"><span class="title">bic_target</span> = ca-&gt;</span>bic_origin_point - delta;</span><br><span class="line">	<span class="keyword">else</span>                                          <span class="comment">/* above origin*/</span></span><br><span class="line">		<span class="function"><span class="title">bic_target</span> = ca-&gt;</span>bic_origin_point + delta;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cubic function - calc bictcp_cnt*/</span></span><br><span class="line">	<span class="keyword">if</span> (bic_target &gt; cwnd) &#123;</span><br><span class="line">		<span class="function"><span class="title">ca</span>-&gt;</span>cnt = cwnd / (bic_target - cwnd);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="function"><span class="title">ca</span>-&gt;</span>cnt = <span class="number">100</span> * cwnd;              <span class="comment">/* very small increment*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The initial growth of cubic function may be too conservative</span></span><br><span class="line"><span class="comment">	 * when the available bandwidth is still unknown.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (ca-&gt;</span><span class="function"><span class="title">last_max_cwnd</span> == 0 &amp;&amp; ca-&gt;</span>cnt &gt; <span class="number">20</span>)</span><br><span class="line">		<span class="function"><span class="title">ca</span>-&gt;</span>cnt = <span class="number">20</span>;	<span class="comment">/* increase cwnd 5% per RTT */</span></span><br><span class="line"></span><br><span class="line">tcp_friendliness:</span><br><span class="line">	<span class="comment">/* TCP Friendly */</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_friendliness) &#123;</span><br><span class="line">		u32 scale = beta_scale;</span><br><span class="line"></span><br><span class="line">		delta = (cwnd * scale) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">		<span class="function"><span class="title">while</span> (ca-&gt;</span>ack_cnt &gt; delta) &#123;		<span class="comment">/* update tcp cwnd */</span></span><br><span class="line">			<span class="function"><span class="title">ca</span>-&gt;</span>ack_cnt -= delta;</span><br><span class="line">			<span class="function"><span class="title">ca</span>-&gt;</span>tcp_cwnd++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">if</span> (ca-&gt;</span>tcp_cwnd &gt; cwnd) &#123;	<span class="comment">/* if bic is slower than tcp */</span></span><br><span class="line">			<span class="function"><span class="title">delta</span> = ca-&gt;</span>tcp_cwnd - cwnd;</span><br><span class="line">			max_cnt = cwnd / delta;</span><br><span class="line">			<span class="function"><span class="title">if</span> (ca-&gt;</span>cnt &gt; max_cnt)</span><br><span class="line">				<span class="function"><span class="title">ca</span>-&gt;</span>cnt = max_cnt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The maximum rate of cwnd increase CUBIC allows is 1 packet per</span></span><br><span class="line"><span class="comment">	 * 2 packets ACKed, meaning cwnd grows at 1.5x per RTT.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="title">ca</span>-&gt;</span><span class="function"><span class="title">cnt</span> = max(ca-&gt;</span>cnt, <span class="number">2</span>U);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拥塞避免阶段也是要增加 cwnd，只是增加的速度问题，速度由上个函数update,这个函数用来更新cwnd，看起来加的很小。</span></span><br><span class="line"><span class="comment">/* In theory this is tp-&gt;snd_cwnd += 1 / tp-&gt;snd_cwnd (or alternative w),</span></span><br><span class="line"><span class="comment"> * for every packet that was ACKed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w, u32 acked)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* If credits accumulated at a higher w, apply them gently now. */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (tp-&gt;</span>snd_cwnd_cnt &gt;= w) &#123;</span><br><span class="line">		<span class="function"><span class="title">tp</span>-&gt;</span>snd_cwnd_cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="title">tp</span>-&gt;</span>snd_cwnd++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">tp</span>-&gt;</span>snd_cwnd_cnt += acked;</span><br><span class="line">	<span class="function"><span class="title">if</span> (tp-&gt;</span>snd_cwnd_cnt &gt;= w) &#123;</span><br><span class="line">		<span class="function"><span class="title">u32</span> delta = tp-&gt;</span>snd_cwnd_cnt / w;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">tp</span>-&gt;</span>snd_cwnd_cnt -= delta * w;</span><br><span class="line">		<span class="function"><span class="title">tp</span>-&gt;</span>snd_cwnd += delta;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">tp</span>-&gt;</span><span class="function"><span class="title">snd_cwnd</span> = min(tp-&gt;</span><span class="function"><span class="title">snd_cwnd</span>, tp-&gt;</span>snd_cwnd_clamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>窗口减小，依然使用tcp_input.c实现，即外部函数：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void tcp_cwnd_reduction(struct sock *sk, int newly_acked_sacked, int newly_lost, int flag)</span><br><span class="line">&#123;</span><br><span class="line">	struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	int sndcnt = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="title">int</span> delta = tp-&gt;</span>snd_ssthresh - tcp_packets_in_flight(tp);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">if</span> (newly_acked_sacked &lt;= 0 || WARN_ON_ONCE(!tp-&gt;</span>prior_cwnd))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">tp</span>-&gt;</span>prr_delivered += newly_acked_sacked;</span><br><span class="line">	<span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="function"><span class="title">u64</span> dividend = (u64)tp-&gt;</span><span class="function"><span class="title">snd_ssthresh</span> * tp-&gt;</span>prr_delivered +</span><br><span class="line">			       <span class="function"><span class="title">tp</span>-&gt;</span>prior_cwnd - <span class="number">1</span>;</span><br><span class="line">		<span class="function"><span class="title">sndcnt</span> = div_u64(dividend, tp-&gt;</span><span class="function"><span class="title">prior_cwnd</span>) - tp-&gt;</span>prr_out;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; FLAG_SND_UNA_ADVANCED &amp;&amp; !newly_lost) &#123;</span><br><span class="line">		sndcnt = min_t(int, delta,</span><br><span class="line">			       <span class="function"><span class="title">max_t</span>(int, tp-&gt;</span><span class="function"><span class="title">prr_delivered</span> - tp-&gt;</span>prr_out,</span><br><span class="line">				     newly_acked_sacked) + <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sndcnt = min(delta, newly_acked_sacked);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Force a fast retransmit upon entering fast recovery */</span></span><br><span class="line">	<span class="function"><span class="title">sndcnt</span> = max(sndcnt, (tp-&gt;</span>prr_out ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">	<span class="function"><span class="title">tp</span>-&gt;</span>snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>丢包窗口限制<br>同上，见tcp_enter_loss</p>
</li>
<li><p>慢启动阈值更新；<br>在进入cwr&#x2F;loss状态，会调用拥塞控制的ssthresh函数，进行慢启动阈值更新；<br>cubic:</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//做了两件事：重赋值last_max_cwnd、返回新的慢启动阈值</span></span><br><span class="line">static u32 bictcp_recalc_ssthresh(struct sock *sk)</span><br><span class="line">&#123;<span class="comment">//论文说这个函数在Packet loss时调用</span></span><br><span class="line">    const struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">    struct bictcp *ca = inet_csk_ca(sk);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ca</span>-&gt;</span>epoch_start = <span class="number">0</span>;    <span class="comment">/* 发生拥塞状态切换，标志一个epoch结束   end of epoch */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wmax and fast convergence */</span></span><br><span class="line">    <span class="comment">//当一个新的TCP流加入到网络，</span></span><br><span class="line">    <span class="comment">//网络中已有TCP流需要放弃自己带宽，</span></span><br><span class="line">    <span class="comment">//给新的TCP流提供一定的上升空间。</span></span><br><span class="line">    <span class="comment">//为提高已有TCP流所释放的带宽而引入快速收敛机制。</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (tp-&gt;</span><span class="function"><span class="title">snd_cwnd</span> &lt; ca-&gt;</span>last_max_cwnd &amp;&amp; fast_convergence)</span><br><span class="line">        <span class="comment">//snd_cwnd&lt;last_max_cwnd</span></span><br><span class="line">        <span class="comment">//表示已有TCP流所经历的饱和点因为可用带宽改变而正在降低。</span></span><br><span class="line">        <span class="comment">//然后，通过进一步降低Wmax让已有流释放更多带宽。</span></span><br><span class="line">        <span class="comment">//这种行为有效地延长已有流增大其窗口的时间，</span></span><br><span class="line">        <span class="comment">//因为降低后的Wmax强制已有流更早进入平稳状态。</span></span><br><span class="line">        <span class="comment">//这允许新流有更多的时间来赶上其窗口尺寸。</span></span><br><span class="line">        <span class="function"><span class="title">ca</span>-&gt;</span><span class="function"><span class="title">last_max_cwnd</span> = (tp-&gt;</span>snd_cwnd * (BICTCP_BETA_SCALE + beta))</span><br><span class="line">            / (<span class="number">2</span> * BICTCP_BETA_SCALE); <span class="comment">//last_max_cwnd = 0.9 * snd_cwnd</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="function"><span class="title">ca</span>-&gt;</span><span class="function"><span class="title">last_max_cwnd</span> = tp-&gt;</span>snd_cwnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">ca</span>-&gt;</span><span class="function"><span class="title">loss_cwnd</span> = tp-&gt;</span>snd_cwnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改snd_ssthresh，即max(0.7*snd_cwnd，2)</span></span><br><span class="line">    <span class="function"><span class="title">return</span> max((tp-&gt;</span>snd_cwnd * beta) / BICTCP_BETA_SCALE, <span class="number">2</span>U);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="bbr拥塞控制算法："><a href="#bbr拥塞控制算法：" class="headerlink" title="bbr拥塞控制算法："></a>bbr拥塞控制算法：</h4><ul>
<li><p>bbr实现了哪些函数：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static struct tcp_congestion_ops tcp_bbr_cong_ops __read_mostly = &#123;</span><br><span class="line">	.flags		= TCP_CONG_NON_RESTRICTED,</span><br><span class="line">	.name		= <span class="string">&quot;bbr&quot;</span>,</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.init		= bbr_init,<span class="regexp">//</span>初始化</span><br><span class="line">	.cong_control	= bbr_main,<span class="regexp">//</span>拥塞窗口增减总控</span><br><span class="line">	.sndbuf_expand	= bbr_sndbuf_expand,<span class="regexp">//</span>当前版本未实现</span><br><span class="line">	.undo_cwnd	= bbr_undo_cwnd,<span class="regexp">//</span>根据bbr理论，不需要这个</span><br><span class="line">	.cwnd_event	= bbr_cwnd_event,<span class="regexp">//</span>在开始发包且app未充分利用信道才会处理。</span><br><span class="line">	.ssthresh	= bbr_ssthresh,<span class="regexp">//</span>Entering loss recovery, so save cwnd <span class="keyword">for</span> when we <span class="keyword">exit</span> or undo recovery.</span><br><span class="line">	.min_tso_segs	= bbr_min_tso_segs,</span><br><span class="line">	.get_info	= bbr_get_info,<span class="regexp">//</span>用于获取bbr结构相关信息</span><br><span class="line">	.set_state	= bbr_set_state,<span class="regexp">//</span>设置bbr内部维护的协议栈上的拥塞状态</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bbr的四种模式(状态)</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">78</span>   <span class="comment">/* BBR has the following modes for deciding how fast to send: */</span></span><br><span class="line"> <span class="number">79</span>   <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 80       BBR 四种模式：</span></span><br><span class="line"><span class="comment"> 81       STARTUP：快速开始抢占带宽</span></span><br><span class="line"><span class="comment"> 82       DRAIN：清空启动期间创建的任何队列</span></span><br><span class="line"><span class="comment"> 83       PROBE_BW: 周期测试最佳带宽</span></span><br><span class="line"><span class="comment"> 84       PROBE_RTT:清空发出的包计算minRTT</span></span><br><span class="line"><span class="comment"> 85   */</span></span><br><span class="line"> <span class="number">86</span>   enum <span class="keyword">bbr_mode </span>&#123;</span><br><span class="line"> <span class="number">87</span>       <span class="keyword">BBR_STARTUP, </span>   <span class="comment">/* ramp up sending rate rapidly to fill pipe */</span></span><br><span class="line"> <span class="number">88</span>       <span class="keyword">BBR_DRAIN, </span>   <span class="comment">/* drain any queue created during startup */</span></span><br><span class="line"> <span class="number">89</span>       <span class="keyword">BBR_PROBE_BW, </span>   <span class="comment">/* discover, share bw: pace around estimated bw */</span></span><br><span class="line"> <span class="number">90</span>       <span class="keyword">BBR_PROBE_RTT, </span>   <span class="comment">/* cut inflight to min to probe min_rtt */</span></span><br><span class="line"> <span class="number">91</span>   &#125;;</span><br></pre></td></tr></table></figure>
<h5 id="bbr的算法过程："><a href="#bbr的算法过程：" class="headerlink" title="bbr的算法过程："></a>bbr的算法过程：</h5><p>ref:<a target="_blank" rel="noopener" href="https://switch-router.gitee.io/blog/bbr1/">https://switch-router.gitee.io/blog/bbr1/</a><br>ref: linux5.13.1源码，bbr rfc</p>
</li>
<li><p>bbr两个重要调控参数：</p>
</li>
</ul>
<ol>
<li>pacing_rate:BBR.pacing_rate: The current pacing rate for a BBR flow, which   controls inter-packet spacing.<br>BBR 流的当前行进速率，它控制数据包间的间距。</li>
<li>cwnd: cwnd: The transport sender’s congestion window, which limits the   amount of data in flight.<br>传输发送方的拥塞窗口，它限制了传输中的数据量。和bdp挂钩<br>从上面知道了cwnd如何影响发送。那pacing_rate如何影响发送速度？<br>内核在4.x后支持了pacing的功能，不记得是默认关还是，可以调节发包速度，根据sock-&gt;sk_pacing_rate的值来；<br>而bbr在计算pacing_rate后，会通过bbr_set_pacing_rate更新这个值。</li>
</ol>
<p>而如何调控，其实内核通过qdisc等机制，具体查sk_pacing_rate在哪里被使用就知道了。</p>
<ul>
<li>设计思想：<br>控制时机提前，不再等到丢包时再进行暴力限制，而是控制稳定的发包速度，尽量榨干带宽，却又不让报文在中间设备的缓存队列上累积。<br>为了得到稳定的发包速度，BBR 使用 TCP Pacing 进行发包控制，因此 BBR 的实现也需要底层支持 TCP Pacing; 为了榨干带宽，BBR 会周期性地去探测是否链路条件变好了，<br>如果是，则加大发送速率; 为了不让报文在中间设备的缓存队列上累积，BBR 会周期性地探测链路的最小 RTT，并使用该最小 RTT 计算发包速率。</li>
</ul>
<img src="/2022/07/03/tcpip-congestion/bbrmodel.png" class="" title="This is an example image">

<p>这张图分为上下两部分：上半部分的 Y 轴是 RTT，下半部分的 Y 轴则表示 delivery rate (也就是 estimated bandwidth)。特别注意的是 X 轴不是时间，而是 amount inflight，也就是在途报文的数量。</p>
<p>整个图从左到右可分为 3 个区域：1. app limited, 2. bandwidth limited, 3. buffer limited </p>
<ol>
<li><p>app limited<br>这个区域中，这条流上流量较小，没有充分利用信道，不存在阻塞的情况，delivery rate 线性增加，因此 RTT 保持不变，为链路的固有往返时延(RTprop)。 </p>
</li>
<li><p>bandwidth limited<br>这个区域表示 inflight 报文数量超过了 BDP，超过的部分是被中间设备缓存，最终表现出来就是 delivery rate 不变(只跟 bandwidth 有关)，而 RTT 由于中间设备缓存 queue 的存在而线性增加。</p>
</li>
<li><p>buffer limited<br>inflight 报文数量继续增加，超过 BDP 的部分最终也超过了中间设备的缓存极限，出现丢包。</p>
</li>
</ol>
<p>BBR 追求的目标是保持 inflight 报文数量就为 BDP，这样既充分利用了 bandwidth，每个报文又能享受到 RTprop。<br>尽管 bandwith 和 RTT 都是可测量的，但很遗憾的是它们不能被同时探测！因为rtt要测量最小值，需要用比较低的速率去测量，较大的速率可能带来高延迟。</p>
<ul>
<li>bbr状态机：<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        |<span class="string"></span></span><br><span class="line"><span class="string">         V</span></span><br><span class="line"><span class="string">+---&gt; STARTUP  ----+</span></span><br><span class="line"><span class="string"></span>|<span class="string">        </span>|<span class="string">         </span>|</span><br><span class="line">|<span class="string">        V         </span>|</span><br><span class="line">|<span class="string">      DRAIN   ----+</span></span><br><span class="line"><span class="string"></span>|<span class="string">        </span>|<span class="string">         </span>|</span><br><span class="line">|<span class="string">        V         </span>|</span><br><span class="line">+---&gt; PROBE_BW ----+</span><br><span class="line">|<span class="string">      ^    </span>|<span class="string">      </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">    </span>|<span class="string">      </span>|</span><br><span class="line">|<span class="string">      +----+      </span>|</span><br><span class="line">|<span class="string">                  </span>|</span><br><span class="line">+---- PROBE_RTT <span class="variable">&lt;--+</span></span><br></pre></td></tr></table></figure>
来自一个网站的图：</li>
</ul>
<img src="/2022/07/03/tcpip-congestion/bbrstatemachine.png" class="" title="This is an example image">

<ul>
<li><p>每次收到一个ack的处理：<br>会走遍所有流程，但是有些流程是某个状态下才会处理，所以也就包含了状态机处理过程。</p>
</li>
<li><p>延迟对bbr计算的影响<br>延迟会影响ack的统计，影响对bw的估算，从而影响了pacing_rate和cwnd, 另外接收方的延迟ack会导致ack聚集<br>也会导致带宽缺口。</p>
</li>
<li><p>丢包对bbr计算的影响<br>bbr通过检测丢包，也判断是否为中间设备限速的情况，此时要以较低的速率发送。具体见下。</p>
</li>
<li><p>每收到一个ack的处理：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void bbr<span class="constructor">_main(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">rate_sample</span> <span class="operator">*</span><span class="params">rs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> bbr *bbr = inet<span class="constructor">_csk_ca(<span class="params">sk</span>)</span>;</span><br><span class="line">	u32 bw;</span><br><span class="line"></span><br><span class="line">	bbr<span class="constructor">_update_model(<span class="params">sk</span>, <span class="params">rs</span>)</span>;</span><br><span class="line"></span><br><span class="line">	bw = bbr<span class="constructor">_bw(<span class="params">sk</span>)</span>;<span class="comment">//计算bw</span></span><br><span class="line">	bbr<span class="constructor">_set_pacing_rate(<span class="params">sk</span>, <span class="params">bw</span>, <span class="params">bbr</span>-&gt;<span class="params">pacing_gain</span>)</span>;<span class="comment">//设置速度</span></span><br><span class="line">	bbr<span class="constructor">_set_cwnd(<span class="params">sk</span>, <span class="params">rs</span>, <span class="params">rs</span>-&gt;<span class="params">acked_sacked</span>, <span class="params">bw</span>, <span class="params">bbr</span>-&gt;<span class="params">cwnd_gain</span>)</span>;<span class="comment">//设置拥塞窗口</span></span><br><span class="line">&#125;</span><br><span class="line">static void bbr<span class="constructor">_update_model(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">rate_sample</span> <span class="operator">*</span><span class="params">rs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	bbr<span class="constructor">_update_bw(<span class="params">sk</span>, <span class="params">rs</span>)</span>;<span class="comment">//估计带宽：更新rtt周期，计算带宽，将带宽和minrtt加入新的rtt,bw样本</span></span><br><span class="line">	bbr<span class="constructor">_update_ack_aggregation(<span class="params">sk</span>, <span class="params">rs</span>)</span>;<span class="comment">//计算inflight:计算预期的ack,重置ack统计周期，计算超出预期的多余数据，维护extra_acked最大值</span></span><br><span class="line">	bbr<span class="constructor">_update_cycle_phase(<span class="params">sk</span>, <span class="params">rs</span>)</span>;<span class="comment">//增益循环PROBE_BW</span></span><br><span class="line">	bbr<span class="constructor">_check_full_bw_reached(<span class="params">sk</span>, <span class="params">rs</span>)</span>;<span class="comment">//填充BDP管道</span></span><br><span class="line">	bbr<span class="constructor">_check_drain(<span class="params">sk</span>, <span class="params">rs</span>)</span>;<span class="comment">//排空队列</span></span><br><span class="line">	bbr<span class="constructor">_update_min_rtt(<span class="params">sk</span>, <span class="params">rs</span>)</span>;<span class="comment">//更新最小rtt</span></span><br><span class="line">	bbr<span class="constructor">_update_gains(<span class="params">sk</span>)</span>;<span class="comment">//更新增益</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析之前看下预备结构：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A rate sample measures the number of (original/retransmitted) data</span></span><br><span class="line"><span class="comment"> * packets delivered &quot;delivered&quot; over an interval of time &quot;interval_us&quot;.</span></span><br><span class="line"><span class="comment"> * The tcp_rate.c code fills in the rate sample, and congestion</span></span><br><span class="line"><span class="comment"> * control modules that define a cong_control function to run at the end</span></span><br><span class="line"><span class="comment"> * of ACK processing can optionally chose to consult this sample when</span></span><br><span class="line"><span class="comment"> * setting cwnd and pacing rate.</span></span><br><span class="line"><span class="comment"> * A sample is invalid if &quot;delivered&quot; or &quot;interval_us&quot; is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> rate_sample &#123;</span><br><span class="line">	u64  prior_mstamp; <span class="comment">/* starting timestamp for interval */</span></span><br><span class="line">	u32  prior_delivered;	<span class="comment">/* tp-&gt;delivered at &quot;prior_mstamp&quot; */</span></span><br><span class="line">	s32  delivered;		<span class="comment">/* number of packets delivered over interval */</span></span><br><span class="line">	long interval_us;	<span class="comment">/* time for tp-&gt;delivered to incr &quot;delivered&quot; */</span></span><br><span class="line">	u32 snd_interval_us;	<span class="comment">/* snd interval for delivered packets */</span></span><br><span class="line">	u32 rcv_interval_us;	<span class="comment">/* rcv interval for delivered packets */</span></span><br><span class="line">	long rtt_us;		<span class="comment">/* RTT of last (S)ACKed packet (or -1) */</span></span><br><span class="line">	<span class="built_in">int</span>  losses;		<span class="comment">/* number of packets marked lost upon ACK */</span></span><br><span class="line">	u32  acked_sacked;	<span class="comment">/* number of packets newly (S)ACKed upon ACK */</span></span><br><span class="line">	u32  prior_in_flight;	<span class="comment">/* in flight before this ACK */</span></span><br><span class="line">	<span class="built_in">bool</span> is_app_limited;	<span class="comment">/* is sample from packet with bubble in pipe? */</span></span><br><span class="line">	<span class="built_in">bool</span> is_retrans;	<span class="comment">/* is sample from retransmission? */</span></span><br><span class="line">	<span class="built_in">bool</span> is_ack_delayed;	<span class="comment">/* is this (likely) a delayed ACK? */</span></span><br><span class="line">&#125;;</span><br><span class="line">上面这个rate_sample是在tcp_ack 调用tcp<span class="constructor">_rate_gen(<span class="params">sk</span>, <span class="params">delivered</span>, <span class="params">lost</span>, <span class="params">is_sack_reneg</span>, <span class="params">sack_state</span>.<span class="params">rate</span>)</span>; 计算所得，具体去看源码，这里先跳过。</span><br></pre></td></tr></table></figure></li>
<li><p>分析：</p>
</li>
</ul>
<ol>
<li><p>bbr_update_bw(sk, rs);<br>这个函数用来更新带宽，从注释：<br>&#x2F;* Estimate the bandwidth based on how fast packets are delivered *&#x2F;<br>我们知道是基于包传递的多快来估计带宽，而带宽，常规来说是每秒发送的bit数，常和速度类别，但其实要考虑延迟，更好的理解是带宽容量。<br>从代码上看，其实就是依赖外部在采样时间得到的传递的包数&#x2F;采样时间us得到速率</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">对应rfc <span class="number">4.5</span>.<span class="number">2.4</span>.  Updating the BBR.max_bw Max Filter</span><br><span class="line">static void bbr_update_bw(struct sock *sk, const struct rate_sample *rs)</span><br><span class="line">&#123;</span><br><span class="line">	struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	struct bbr *bbr = inet_csk_ca(sk);</span><br><span class="line">	u64 bw;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">bbr</span>-&gt;</span>round_start = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="title">if</span> (rs-&gt;</span><span class="function"><span class="title">delivered</span> &lt; 0 || rs-&gt;</span>interval_us &lt;= <span class="number">0</span>)</span><br><span class="line">		return; <span class="comment">/* Not a valid observation */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* See if we&#x27;ve reached the next RTT */</span> <span class="comment">//收到ack调用的，所以这里可以判断rtt)</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (!before(rs-&gt;</span><span class="function"><span class="title">prior_delivered</span>, bbr-&gt;</span>next_rtt_delivered)) &#123;</span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">next_rtt_delivered</span> = tp-&gt;</span>delivered;</span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span>rtt_cnt++;<span class="comment">//更新rtt数量</span></span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">round_start</span> = 1;//标记开始一个tx-&gt;</span>ack的回合</span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span>packet_conservation = <span class="number">0</span>;<span class="comment">//保护？</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bbr_lt_bw_sampling(sk, rs);<span class="comment">//见下分析</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Divide delivered by the interval to find a (lower bound) bottleneck</span></span><br><span class="line"><span class="comment">	 * bandwidth sample. Delivered is in packets and interval_us in uS and</span></span><br><span class="line"><span class="comment">	 * ratio will be &lt;&lt;1 for most connections. So delivered is first scaled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="title">bw</span> = div64_long((u64)rs-&gt;</span><span class="function"><span class="title">delivered</span> * BW_UNIT, rs-&gt;</span>interval_us);<span class="comment">//采样时间内确认的包数/单位时间，BW_UNIT为1&lt;&lt;24，</span></span><br><span class="line">    <span class="comment">//前面是算出每us的包数,这里乘以一个系数2^24,后面要除去，注意这里没转换为bps..所以是个比较小的值。</span></span><br><span class="line">    <span class="comment">//这个采样时间是在bbr之外定的，一般大于min_rtt,这里暂时不深究。</span></span><br><span class="line">    <span class="comment">//这里为啥要乘以一个系数？来看源码解释：</span></span><br><span class="line"><span class="comment">/* Scale factor for rate in pkt/uSec unit to avoid truncation in bandwidth  pkt/uSec 单位中速率的比例因子，以避免带宽截断估计。</span></span><br><span class="line"><span class="comment"> * estimation. The rate unit ~= (1500 bytes / 1 usec / 2^24) ~= 715 bps.</span></span><br><span class="line"><span class="comment">  //即 1500*8 * 1000000(1s=1000000us) / 2^24 ~= 715bps,1500为一个mtu,这里算的是一个速率单位，即通过每us的包数，转换为每s的bit数 再/ 2^24</span></span><br><span class="line"><span class="comment"> * This handles bandwidths from 0.06pps (715bps) to 256Mpps (3Tbps) in a u32.//若0.06表示715，则可以存储更多值</span></span><br><span class="line"><span class="comment"> * Since the minimum window is &gt;=4 packets, the lower bound isn&#x27;t</span></span><br><span class="line"><span class="comment"> * an issue. The upper bound isn&#x27;t an issue with existing technologies.//因为最小窗口&gt;=4,所以下限不是问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* If this sample is application-limited, it is likely to have a very</span></span><br><span class="line"><span class="comment">	 * low delivered count that represents application behavior rather than</span></span><br><span class="line"><span class="comment">	 * the available network rate. Such a sample could drag down estimated</span></span><br><span class="line"><span class="comment">	 * bw, causing needless slow-down. Thus, to continue to send at the</span></span><br><span class="line"><span class="comment">	 * last measured network rate, we filter out app-limited samples unless</span></span><br><span class="line"><span class="comment">	 * they describe the path bw at least as well as our bw model.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So the goal during app-limited phase is to proceed with the best</span></span><br><span class="line"><span class="comment">	 * network rate no matter how long. We automatically leave this</span></span><br><span class="line"><span class="comment">	 * phase when app writes faster than the network can deliver :)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (!rs-&gt;</span>is_app_limited || bw &gt;= bbr_max_bw(sk)) &#123; <span class="comment">//和测量的最大带宽相比并更新，这里是采样的最大带宽</span></span><br><span class="line">		<span class="comment">/* Incorporate new sample into our max bw filter. */</span></span><br><span class="line">		<span class="function"><span class="title">minmax_running_max</span>(&amp;bbr-&gt;</span><span class="function"><span class="title">bw</span>, bbr_bw_rtts, bbr-&gt;</span>rtt_cnt, bw);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 处理第三类丢包：被路由器限速：<br>如果发生监管丢包，BBR会在一段比较长的周期内检测到，它发现在这个周期内持续持有比较高的丢包率(检测到的Lost计数器偏大)，且速率保持一致，那么BBR会将发送量限制在实际带宽的平均值。<br>static void bbr_lt_bw_sampling(struct sock *sk, const struct rate_sample *rs)<br>具体分析略<br>ref:<a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2016-10/136259.htm">https://www.linuxidc.com/Linux/2016-10/136259.htm</a></p>
</li>
<li><p>bbr_update_ack_aggregation(sk, rs) 计算inflight<br>Estimates the windowed max degree of ack aggregation.估计 ack 聚合的窗口最大程度。<br>这个有点不太好理解，直接看代码：<br>对应rfc: 4.5.5.  BBR.extra_acked<br>ref：关于延迟ack,ack 聚集到达：<br><a target="_blank" rel="noopener" href="https://www.shuzhiduo.com/A/WpdKnaqX5V/">https://www.shuzhiduo.com/A/WpdKnaqX5V/</a><br>简单的说，就是在某种情况下会有大量ack延迟到达，而在延迟之前，cwnd被递减<br>发送减缓，等到这些突发的ack聚集到达时，需要快速恢复，这里会出现一个<br>带宽缺口，所以bbr从cwnd递减时机 和快速恢复两点，对带宽进行补偿</p>
</li>
</ol>
<p>不仅如此，延迟到达的ack会影响delivered packet从而影响bw的计算，影响了pacing rate和cwnd,所以需要做补偿</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Estimates the windowed max degree of ack aggregation.</span></span><br><span class="line"><span class="comment"> * This is used to provision extra in-flight data to keep sending during</span></span><br><span class="line"><span class="comment"> * inter-ACK silences.这用于提供额外的飞行中数据，以在 ACK 间静默期间继续发送。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Degree of ack aggregation is estimated as extra data acked beyond expected.ack 聚合程度估计为超出预期的额外数据。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * max_extra_acked = &quot;maximum recent excess data ACKed beyond max_bw * interval&quot;</span></span><br><span class="line"><span class="comment"> * cwnd += max_extra_acked</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Max extra_acked is clamped by cwnd and bw * bbr_extra_acked_max_us (100 ms).</span></span><br><span class="line"><span class="comment"> * Max filter is an approximate sliding window of 5-10 (packet timed) round</span></span><br><span class="line"><span class="comment"> * trips.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> static void bbr_update_ack_aggregation(struct sock *sk,</span><br><span class="line">				       const struct rate_sample *rs)</span><br><span class="line">&#123;</span><br><span class="line">	u32 epoch_us, expected_acked, extra_acked;</span><br><span class="line">	struct bbr *bbr = inet_csk_ca(sk);</span><br><span class="line">	struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">if</span> (!bbr_extra_acked_gain || rs-&gt;</span>acked_sacked &lt;= <span class="number">0</span> ||</span><br><span class="line">	    <span class="function"><span class="title">rs</span>-&gt;</span><span class="function"><span class="title">delivered</span> &lt; 0 || rs-&gt;</span>interval_us &lt;= <span class="number">0</span>)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">if</span> (bbr-&gt;</span>round_start) &#123;<span class="comment">//rtt周期计算最开始</span></span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span>extra_acked_win_rtts = min(<span class="number">0</span>x1F,</span><br><span class="line">						<span class="function"><span class="title">bbr</span>-&gt;</span>extra_acked_win_rtts + <span class="number">1</span>);</span><br><span class="line">		<span class="function"><span class="title">if</span> (bbr-&gt;</span>extra_acked_win_rtts &gt;= bbr_extra_acked_win_rtts) &#123;</span><br><span class="line">			<span class="function"><span class="title">bbr</span>-&gt;</span>extra_acked_win_rtts = <span class="number">0</span>;</span><br><span class="line">			<span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">extra_acked_win_idx</span> = bbr-&gt;</span>extra_acked_win_idx ?</span><br><span class="line">						   <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">			<span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">extra_acked</span>[bbr-&gt;</span>extra_acked_win_idx] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Compute how many packets we expected to be delivered over epoch. */</span></span><br><span class="line">	<span class="function"><span class="title">epoch_us</span> = tcp_stamp_us_delta(tp-&gt;</span>delivered_mstamp,</span><br><span class="line">				      <span class="function"><span class="title">bbr</span>-&gt;</span>ack_epoch_mstamp);</span><br><span class="line">	expected_acked = ((u64)bbr_bw(sk) * epoch_us) / BW_UNIT;<span class="comment">//根据发送得到预期接收的ack</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reset the aggregation epoch if ACK rate is below expected rate or</span></span><br><span class="line"><span class="comment">	 * significantly large no. of ack received since epoch (potentially</span></span><br><span class="line"><span class="comment">	 * quite old epoch).</span></span><br><span class="line"><span class="comment">	 */</span> <span class="comment">//ack没超过预期，置位0</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (bbr-&gt;</span>ack_epoch_acked &lt;= expected_acked ||</span><br><span class="line">	    (<span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">ack_epoch_acked</span> + rs-&gt;</span>acked_sacked &gt;=</span><br><span class="line">	     bbr_ack_epoch_acked_reset_thresh)) &#123;</span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span>ack_epoch_acked = <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">ack_epoch_mstamp</span> = tp-&gt;</span>delivered_mstamp;</span><br><span class="line">		expected_acked = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Compute excess data delivered, beyond what was expected. */</span><span class="comment">//在采样周期内</span></span><br><span class="line">	<span class="function"><span class="title">bbr</span>-&gt;</span>ack_epoch_acked = min_t(u32, <span class="number">0</span>xFFFFF,</span><br><span class="line">				     <span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">ack_epoch_acked</span> + rs-&gt;</span>acked_sacked);</span><br><span class="line">	<span class="function"><span class="title">extra_acked</span> = bbr-&gt;</span>ack_epoch_acked - expected_acked;<span class="comment">//算出超过预期的ack数量</span></span><br><span class="line">	<span class="function"><span class="title">extra_acked</span> = min(extra_acked, tp-&gt;</span>snd_cwnd);<span class="comment">//和拥塞窗口比较取最小值</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (extra_acked &gt; bbr-&gt;</span><span class="function"><span class="title">extra_acked</span>[bbr-&gt;</span>extra_acked_win_idx])</span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">extra_acked</span>[bbr-&gt;</span>extra_acked_win_idx] = extra_acked;<span class="comment">//更新</span></span><br><span class="line">        </span><br><span class="line">     <span class="comment">//这个在后面算cwnd时，会用到：	target_cwnd += bbr_ack_aggregation_cwnd(sk);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3)bbr_update_cycle_phase(sk, rs);&#x2F;&#x2F;增益循环PROBE_BW<br>解释：<br>这个函数做了什么：<br>  当当前处于 ProbeBW状态时且到时间切换到下个增益，会去更新cycle_idx。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">cycle_idx</span> = (bbr-&gt;</span>cycle_idx + <span class="number">1</span>) &amp; (CYCLE_LEN - <span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">cycle_mstamp</span> = tp-&gt;</span>delivered_mstamp;</span><br></pre></td></tr></table></figure>
<p>bbr维护了一个增益列表，在过程中会去更新pacing_gain,这个<br>值会添加增益列表中对应cycle_idx索引下的值。<br>BBR 定义了一个增益循环(gain cycling)的概念，将增益系数作用到 pacing rate 上，以此控制报文发送速度。<br>ref：<br>具体的定义是，一个 cycle 包含 8 个 phase，每个 phase 的持续时间为 1 个 min RTT。8 个 phase 的 gain 分别为：1.25、0.75、1、1、1、1、1、1。当处于 gain 为 1.25 的 phase 时，意味着 pacing rate 是当前计算的合理值的 1.25 倍，此时 BBR 发送速率也会变成正常情况下的 1.25 倍(踩油门)。而当处于 gain 为 0.75 的 phase 时，相应的发送速率是正常情况的 0.75 倍(踩刹车)。而 gain 为 1 时，发送速率就是正常值(巡航).具体的定义是，一个 cycle 包含 8 个 phase，每个 phase 的持续时间为 1 个 min RTT。8 个 phase 的 gain 分别为：1.25、0.75、1、1、1、1、1、1。当处于 gain 为 1.25 的 phase 时，意味着 pacing rate 是当前计算的合理值的 1.25 倍，此时 BBR 发送速率也会变成正常情况下的 1.25 倍(踩油门)。而当处于 gain 为 0.75 的 phase 时，相应的发送速率是正常情况的 0.75 倍(踩刹车)。而 gain 为 1 时，发送速率就是正常值(巡航).<br>BBR 一脚油门一脚刹车的组合保证了当链路带宽不变时，这条流不会向链路灌入超量的报文。而 6&#x2F;8 时间段里的 gain 为 1 又使得大部分时候，采用 BBR 控制的 流发送报文的 pacing rate 是稳定的。</p>
<p>– 为什么需要这样做？什么时候加速，稳定，减速？<br>参考rfc: 4.3.3.  ProbeBW</p>
<p>static void bbr_update_gains(struct sock *sk)<br>增益列表的定义：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The pacing_gain values for the PROBE_BW gain cycle, to discover/share bw: */</span></span><br><span class="line"><span class="keyword">static</span> const <span class="keyword">int</span> bbr_pacing_gain[] = &#123;</span><br><span class="line">	BBR_UNIT * <span class="number">5</span> <span class="regexp">/ 4,	/</span>* probe <span class="keyword">for</span> more available bw */</span><br><span class="line">	BBR_UNIT * <span class="number">3</span> <span class="regexp">/ 4,	/</span>* drain queue and<span class="regexp">/or yield bw to other flows */</span></span><br><span class="line">	BBR_UNIT, BBR_UNIT, BBR_UNIT,	<span class="comment">/* cruise at 1.0*bw to utilize pipe, */</span></span><br><span class="line">	BBR_UNIT, BBR_UNIT, BBR_UNIT	<span class="comment">/* without creating excess queue... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>bbr_check_full_bw_reached 检查是否到最大带宽<br>协议描述：4.3.1.2.  Exiting Startup Based on Bandwidth Plateau <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Estimate when the pipe is full, using the change in delivery rate: BBR</span></span><br><span class="line"><span class="comment"> * estimates that STARTUP filled the pipe if the estimated bw hasn&#x27;t changed by</span></span><br><span class="line"><span class="comment"> * at least bbr_full_bw_thresh (25%) after bbr_full_bw_cnt (3) non-app-limited</span></span><br><span class="line"><span class="comment"> * rounds. Why 3 rounds: 1: rwin autotuning grows the rwin, 2: we fill the</span></span><br><span class="line"><span class="comment"> * higher rwin, 3: we get higher delivery rate samples. Or transient</span></span><br><span class="line"><span class="comment"> * cross-traffic or radio noise can go away. CUBIC Hystart shares a similar</span></span><br><span class="line"><span class="comment"> * design goal, but uses delay and inter-ACK spacing instead of bandwidth.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 使用delivery rate的变化来估计管道何时充满：BBR</span><br><span class="line">如果在 <span class="title function_ invoke__">bbr_full_bw_cnt</span> (<span class="number">3</span>次) 非应用程序限制轮次之后估计的 bw 没有改变至少 <span class="title function_ invoke__">bbr_full_bw_thresh</span> (<span class="number">25</span>%)，</span><br><span class="line">则估计 STARTUP 填充了管道。 为什么要进行 <span class="number">3</span> 轮：</span><br><span class="line"><span class="number">1</span>：rwin 自动调整使 rwin 增长，</span><br><span class="line"><span class="number">2</span>：我们填充更高的 rwin，</span><br><span class="line"><span class="number">3</span>：我们获得更高的delivery rate样本。 或者瞬态交叉流量或无线电噪声可以消失。</span><br><span class="line"><span class="number">3</span>次相当于给恢复的机会，或容错成本</span><br><span class="line"> CUBIC Hystart 具有类似的设计目标，但使用延迟和 ACK 间间隔而不是带宽。</span><br><span class="line"><span class="keyword">static</span> void <span class="title function_ invoke__">bbr_check_full_bw_reached</span>(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk,</span><br><span class="line">				      <span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">rate_sample</span> *rs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">bbr</span> *bbr = <span class="title function_ invoke__">inet_csk_ca</span>(sk);</span><br><span class="line">	<span class="type">u32</span> bw_thresh;</span><br><span class="line"></span><br><span class="line">	<span class="title function_ invoke__">if</span> (<span class="title function_ invoke__">bbr_full_bw_reached</span>(sk) || !bbr<span class="punctuation">-&gt;</span>round_start || rs<span class="punctuation">-&gt;</span>is_app_limited)<span class="comment">//如果已经达到full bw( /* reached full bw in Startup? */)</span></span><br><span class="line">    <span class="comment">//或者round 还没开始当前在app发送没充分利用信道带宽的情况下，直接返回</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* To estimate if BBR_STARTUP mode (i.e. high_gain) has filled pipe... */</span></span><br><span class="line"><span class="comment">/* If bw has increased significantly (1.25x), there may be more bw available: */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="type">u32</span> bbr_full_bw_thresh = BBR_UNIT * <span class="number">5</span> / <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">	bw_thresh = (<span class="type">u64</span>)bbr<span class="punctuation">-&gt;</span>full_bw * bbr_full_bw_thresh &gt;&gt; BBR_SCALE;<span class="comment">//注意这里用1.25倍上次的最大值。</span></span><br><span class="line">    <span class="comment">//和协议4.3.1.2. 上的算法是符合的。</span></span><br><span class="line">	<span class="title function_ invoke__">if</span> (<span class="title function_ invoke__">bbr_max_bw</span>(sk) &gt;= bw_thresh) &#123;<span class="comment">//max算出来的比上次的大，说明还在增长。</span></span><br><span class="line">		bbr<span class="punctuation">-&gt;</span>full_bw = <span class="title function_ invoke__">bbr_max_bw</span>(sk);<span class="comment">//只有这里更新&gt;0的值。</span></span><br><span class="line">		bbr<span class="punctuation">-&gt;</span>full_bw_cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	++bbr<span class="punctuation">-&gt;</span>full_bw_cnt;<span class="comment">//否则累计，三次不增长则说明到最大值了。</span></span><br><span class="line">	bbr<span class="punctuation">-&gt;</span>full_bw_reached = bbr<span class="punctuation">-&gt;</span>full_bw_cnt &gt;= bbr_full_bw_cnt;<span class="comment">//达到三次认为是达到最大值。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* But after 3 rounds w/o significant bw growth, estimate pipe is full: */</span></span><br><span class="line">     <span class="comment">//static const u32 bbr_full_bw_cnt = 3;</span></span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>5)bbr_check_drain 状态转移到drain 排空<br>这里为什么要排空？为了避免在startUp估计的速率太大，和当前的bdp不适配。<br>在 Drain 中，BBR 旨在通过切换到远低于 1.0 的 pacing_gain 来快速排空 Startup 中创建的任何队列，直到任何估计的队列被排空。<br>它使用一个 pacing_gain，它是启动期间使用的值的倒数，选择尝试在一轮中耗尽队列<br>rfc:4.3.2.  Drain  Drain状态</p>
<p>如何排空：<br>bbr_update_gains 当前是drain状态时：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case <span class="keyword">BBR_DRAIN:</span></span><br><span class="line"><span class="keyword"></span>		<span class="keyword">bbr-&gt;pacing_gain </span>= <span class="keyword">bbr_drain_gain;	</span><span class="comment">/* slow, to drain */</span></span><br><span class="line">		<span class="keyword">bbr-&gt;cwnd_gain	</span> = <span class="keyword">bbr_high_gain;	</span><span class="comment">/* keep cwnd */</span></span><br></pre></td></tr></table></figure>


<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If pipe is probably full, drain the queue and then enter steady-state. */</span></span><br><span class="line">static void bbr<span class="constructor">_check_drain(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">rate_sample</span> <span class="operator">*</span><span class="params">rs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> bbr *bbr = inet<span class="constructor">_csk_ca(<span class="params">sk</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bbr-&gt;mode<span class="operator"> == </span>BBR_STARTUP<span class="operator"> &amp;&amp; </span>bbr<span class="constructor">_full_bw_reached(<span class="params">sk</span>)</span>) &#123;<span class="comment">//如果达到full bw,则进入drain</span></span><br><span class="line">		bbr-&gt;mode = BBR_DRAIN;	<span class="comment">/* drain queue we created */</span></span><br><span class="line">		tcp<span class="constructor">_sk(<span class="params">sk</span>)</span>-&gt;snd_ssthresh =</span><br><span class="line">				bbr<span class="constructor">_inflight(<span class="params">sk</span>, <span class="params">bbr_max_bw</span>(<span class="params">sk</span>)</span>, BBR_UNIT);</span><br><span class="line">	&#125;	<span class="comment">/* fall through to check if in-flight is already small: */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里判断满足已排空时，进入PROBE_BW状态。而实际的排空是通过update_gains进行。</span></span><br><span class="line">    <span class="comment">/* from rfc:</span></span><br><span class="line"><span class="comment">    在 Drain 中，当传输中的数据量小于或等于估计的 BDP 时，意味着 BBR 估计队列已经完全排空，然后 BBR 退出 Drain 并进入 ProbeBW。</span></span><br><span class="line"><span class="comment">    为了实现这一点，在每个 ACK BBR 执行时：</span></span><br><span class="line"><span class="comment">     BBRCheckDrain():</span></span><br><span class="line"><span class="comment">       if (BBR.state == Drain and packets_in_flight &lt;= BBRInflight(1.0))</span></span><br><span class="line"><span class="comment">         BBREnterProbeBW()  /* BBR estimates the queue was drained */</span></span><br><span class="line">    */</span><br><span class="line">	<span class="keyword">if</span> (bbr-&gt;mode<span class="operator"> == </span>BBR_DRAIN<span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">	    </span>bbr<span class="constructor">_packets_in_net_at_edt(<span class="params">sk</span>, <span class="params">tcp_packets_in_flight</span>(<span class="params">tcp_sk</span>(<span class="params">sk</span>)</span>)) &lt;=</span><br><span class="line">	    bbr<span class="constructor">_inflight(<span class="params">sk</span>, <span class="params">bbr_max_bw</span>(<span class="params">sk</span>)</span>, BBR_UNIT))</span><br><span class="line">		bbr<span class="constructor">_reset_probe_bw_mode(<span class="params">sk</span>)</span>;  <span class="comment">/* we estimate queue is drained */</span> <span class="comment">//满足条件进入到PROBE_BW状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find inflight based on min RTT and the estimated bottleneck bandwidth. */</span></span><br><span class="line">static u32 bbr<span class="constructor">_inflight(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>, <span class="params">u32</span> <span class="params">bw</span>, <span class="params">int</span> <span class="params">gain</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 inflight;</span><br><span class="line"></span><br><span class="line">	inflight = bbr<span class="constructor">_bdp(<span class="params">sk</span>, <span class="params">bw</span>, <span class="params">gain</span>)</span>;<span class="comment">//通过rtt和bw算出bdp</span></span><br><span class="line">	inflight = bbr<span class="constructor">_quantization_budget(<span class="params">sk</span>, <span class="params">inflight</span>)</span>;<span class="comment">//在一些高速场景下需要补偿一点</span></span><br><span class="line"></span><br><span class="line">	return inflight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到了bdp,bdp是带宽时延积，简单理解就是在充满网络管道的大小，或者管道容量，它通过：<br>时延带宽积 &#x3D; 时延 × 带宽<br>计算出。而拥塞控制窗口，其实是在空中传输的包数，那这里需要限制在空中传输的包数不能超过bdp，也就是带宽时延积，在我们能容忍的rtt下。<br>时延通过rtt算出。</p>
<ol start="6">
<li>bbr_update_min_rtt 周期更新最小rtt,是为了计算最大的bdp。</li>
</ol>
<p>4.3.4.  ProbeRTT</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The goal of PROBE_RTT mode is to have BBR flows cooperatively and</span></span><br><span class="line"><span class="comment"> * periodically drain the bottleneck queue, to converge to measure the true</span></span><br><span class="line"><span class="comment"> * min_rtt (unloaded propagation delay). This allows the flows to keep queues</span></span><br><span class="line"><span class="comment"> * small (reducing queuing delay and packet loss) and achieve fairness among</span></span><br><span class="line"><span class="comment"> * BBR flows.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The min_rtt filter window is 10 seconds. When the min_rtt estimate expires,</span></span><br><span class="line"><span class="comment"> * we enter PROBE_RTT mode and cap the cwnd at bbr_cwnd_min_target=4 packets.</span></span><br><span class="line"><span class="comment"> * After at least bbr_probe_rtt_mode_ms=200ms and at least one packet-timed</span></span><br><span class="line"><span class="comment"> * round trip elapsed with that flight size &lt;= 4, we leave PROBE_RTT mode and</span></span><br><span class="line"><span class="comment"> * re-enter the previous mode. BBR uses 200ms to approximately bound the</span></span><br><span class="line"><span class="comment"> * performance penalty of PROBE_RTT&#x27;s cwnd capping to roughly 2% (200ms/10s).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that flows need only pay 2% if they are busy sending over the last 10</span></span><br><span class="line"><span class="comment"> * seconds. Interactive applications (e.g., Web, RPCs, video chunks) often have</span></span><br><span class="line"><span class="comment"> * natural silences or low-rate periods within 10 seconds where the rate is low</span></span><br><span class="line"><span class="comment"> * enough for long enough to drain its queue in the bottleneck. We pick up</span></span><br><span class="line"><span class="comment"> * these min RTT measurements opportunistically with our min_rtt filter. :-)</span></span><br><span class="line"><span class="comment"> PROBE_RTT 模式的目标是让 BBR 流协同并定期排空瓶颈队列，以收敛以测量真正的 min_rtt（卸载传播延迟）。</span></span><br><span class="line"><span class="comment"> 这允许流保持较小的队列（减少排队延迟和丢包）并实现 BBR 流之间的公平。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">min_rtt 过滤器窗口为 10 秒。当 min_rtt 估计过期时，我们进入 PROBE_RTT 模式并将 cwnd 限制在 bbr_cwnd_min_target=4 个数据包。</span></span><br><span class="line"><span class="comment">至少 bbr_probe_rtt_mode_ms=200ms 和至少一个数据包定时后,该空中包数大小 &lt;= 4 的往返已过去，</span></span><br><span class="line"><span class="comment">我们离开 PROBE_RTT 模式并重新进入先前的模式。 BBR 使用 200 毫秒将 PROBE_RTT 的 cwnd 上限的性能损失大致限制在大约 2%（200 毫秒/10 秒）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">请注意，如果流在过去 10 秒内忙于发送，则只需支付 2%。交互式应用程序（例如，Web、RPC、视频块）通常在 10 秒内具有自然静默或低速率周期，</span></span><br><span class="line"><span class="comment">其中速率足够低，足以耗尽瓶颈中的队列。我们使用我们的 min_rtt 过滤器机会性地获取这些最小 RTT 测量值。 :-)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static void bbr_update_min_rtt(struct sock *sk, const struct rate_sample *rs)</span><br><span class="line">&#123;</span><br><span class="line">	struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	struct bbr *bbr = inet_csk_ca(sk);</span><br><span class="line">	bool filter_expired;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Track min RTT seen in the min_rtt_win_sec filter window: */</span></span><br><span class="line">	filter_expired = after(tcp_jiffies32,</span><br><span class="line">			       <span class="function"><span class="title">bbr</span>-&gt;</span>min_rtt_stamp + bbr_min_rtt_win_sec * HZ);<span class="comment">//这里是10s</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (rs-&gt;</span>rtt_us &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">	    (<span class="function"><span class="title">rs</span>-&gt;</span><span class="function"><span class="title">rtt_us</span> &lt; bbr-&gt;</span>min_rtt_us ||</span><br><span class="line">	     (<span class="function"><span class="title">filter_expired</span> &amp;&amp; !rs-&gt;</span>is_ack_delayed))) &#123;</span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">min_rtt_us</span> = rs-&gt;</span>rtt_us;<span class="comment">//更新最小rtt，rtt通过参数代入进来</span></span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span>min_rtt_stamp = tcp_jiffies32;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bbr_probe_rtt_mode_ms &gt; <span class="number">0</span> &amp;&amp; filter_expired &amp;&amp;</span><br><span class="line">	    !<span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">idle_restart</span> &amp;&amp; bbr-&gt;</span>mode != BBR_PROBE_RTT) &#123;</span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span>mode = BBR_PROBE_RTT;  <span class="comment">/* dip, drain queue */</span> <span class="comment">//进入rtt探测阶段</span></span><br><span class="line">		bbr_save_cwnd(sk);  <span class="comment">/* note cwnd so we can restore it */</span></span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span>probe_rtt_done_stamp = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">if</span> (bbr-&gt;</span>mode == BBR_PROBE_RTT) &#123;<span class="comment">//尝试退出这个状态</span></span><br><span class="line">		<span class="comment">/* Ignore low rate samples during this mode. */</span></span><br><span class="line">		<span class="function"><span class="title">tp</span>-&gt;</span>app_limited =</span><br><span class="line">			(<span class="function"><span class="title">tp</span>-&gt;</span>delivered + tcp_packets_in_flight(tp)) ? : <span class="number">1</span>;</span><br><span class="line">		<span class="comment">/* Maintain min packets in flight for max(200 ms, 1 round). */</span></span><br><span class="line">		<span class="function"><span class="title">if</span> (!bbr-&gt;</span>probe_rtt_done_stamp &amp;&amp;</span><br><span class="line">		    tcp_packets_in_flight(tp) &lt;= bbr_cwnd_min_target) &#123;</span><br><span class="line">			<span class="function"><span class="title">bbr</span>-&gt;</span>probe_rtt_done_stamp = tcp_jiffies32 +</span><br><span class="line">				msecs_to_jiffies(bbr_probe_rtt_mode_ms);<span class="comment">//设置结束时间，只有这里更新，这里是200ms</span></span><br><span class="line">			<span class="function"><span class="title">bbr</span>-&gt;</span>probe_rtt_round_done = <span class="number">0</span>;</span><br><span class="line">			<span class="function"><span class="title">bbr</span>-&gt;</span><span class="function"><span class="title">next_rtt_delivered</span> = tp-&gt;</span>delivered;</span><br><span class="line">		&#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (bbr-&gt;</span>probe_rtt_done_stamp) &#123;</span><br><span class="line">			<span class="function"><span class="title">if</span> (bbr-&gt;</span>round_start)</span><br><span class="line">				<span class="function"><span class="title">bbr</span>-&gt;</span>probe_rtt_round_done = <span class="number">1</span>;</span><br><span class="line">			<span class="function"><span class="title">if</span> (bbr-&gt;</span>probe_rtt_round_done)</span><br><span class="line">				bbr_check_probe_rtt_done(sk);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Restart after idle ends only once we process a new S/ACK for data */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (rs-&gt;</span>delivered &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="function"><span class="title">bbr</span>-&gt;</span>idle_restart = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">static void bbr_check_probe_rtt_done(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">	struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	struct bbr *bbr = inet_csk_ca(sk);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">if</span> (!(bbr-&gt;</span>probe_rtt_done_stamp &amp;&amp;</span><br><span class="line">	      <span class="function"><span class="title">after</span>(tcp_jiffies32, bbr-&gt;</span>probe_rtt_done_stamp)))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">bbr</span>-&gt;</span>min_rtt_stamp = tcp_jiffies32;  <span class="comment">/* wait a while until PROBE_RTT */</span></span><br><span class="line">	<span class="function"><span class="title">tp</span>-&gt;</span><span class="function"><span class="title">snd_cwnd</span> = max(tp-&gt;</span><span class="function"><span class="title">snd_cwnd</span>, bbr-&gt;</span>prior_cwnd);</span><br><span class="line">	bbr_reset_mode(sk);<span class="comment">//重置回startUp或Probebw状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="7">
<li>bbr_update_gains(sk);<br>这个函数主要是更新增益，在Drain中，也是依赖这个函数的调用，达到耗尽队列的目的</li>
</ol>
<p>因为每个状态都可能更新pacing_gain和cwnd_gain,所以这里统一更新。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.3</span>.<span class="number">2.</span>  Drain  Drain状态</span><br><span class="line">[BBRDrainPacingGain]:</span><br><span class="line"></span><br><span class="line">     BBREnterDrain():</span><br><span class="line">       BBR.state = Drain</span><br><span class="line">       BBR.pacing_gain = <span class="number">1</span>/BBRStartupCwndGain  <span class="comment">/* pace slowly */</span></span><br><span class="line">       BBR.cwnd_gain = BBRStartupCwndGain      <span class="comment">/* maintain cwnd */</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">static</span> <span class="literal">void</span> bbr_update_gains(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">	struct bbr *bbr = inet_csk_ca(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (bbr-&gt;mode) &#123;</span><br><span class="line">	<span class="keyword">case</span> BBR_STARTUP:</span><br><span class="line">		bbr-&gt;pacing_gain = bbr_high_gain;</span><br><span class="line">		bbr-&gt;cwnd_gain	 = bbr_high_gain;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BBR_DRAIN:</span><br><span class="line">		bbr-&gt;pacing_gain = bbr_drain_gain;	<span class="comment">/* slow, to drain */</span></span><br><span class="line">		bbr-&gt;cwnd_gain	 = bbr_high_gain;	<span class="comment">/* keep cwnd */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BBR_PROBE_BW:</span><br><span class="line">		bbr-&gt;pacing_gain = (bbr-&gt;lt_use_bw ?</span><br><span class="line">				    BBR_UNIT :</span><br><span class="line">				    bbr_pacing_gain[bbr-&gt;cycle_idx]);</span><br><span class="line">		bbr-&gt;cwnd_gain	 = bbr_cwnd_gain;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BBR_PROBE_RTT:</span><br><span class="line">		bbr-&gt;pacing_gain = BBR_UNIT;</span><br><span class="line">		bbr-&gt;cwnd_gain	 = BBR_UNIT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	default:</span><br><span class="line">		WARN_ONCE(<span class="number">1</span>, <span class="string">&quot;BBR bad mode: %u\n&quot;</span>, bbr-&gt;mode);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>bw &#x3D; bbr_bw(sk);</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the estimated bandwidth of the path, in pkts/uS &lt;&lt; BW_SCALE. */</span></span><br><span class="line">static u32 bbr<span class="constructor">_bw(<span class="params">const</span> <span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> bbr *bbr = inet<span class="constructor">_csk_ca(<span class="params">sk</span>)</span>;</span><br><span class="line"></span><br><span class="line">	return bbr-&gt;lt_use_bw ? bbr-&gt;lt_bw : bbr<span class="constructor">_max_bw(<span class="params">sk</span>)</span>;</span><br><span class="line">    <span class="comment">//返回，如果发生路由器限速的情况，则用该情况测试出来的带宽，否则用</span></span><br><span class="line">    <span class="comment">//当前测出的最大带宽</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bbr_set_pacing_rate(sk, bw, bbr-&gt;pacing_gain);<br>这一步是更新最后参数的两个步骤之一：更新pacing_rate:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Pace using current bw estimate and a gain factor. */</span></span><br><span class="line">static void bbr<span class="constructor">_set_pacing_rate(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>, <span class="params">u32</span> <span class="params">bw</span>, <span class="params">int</span> <span class="params">gain</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> tcp_sock *tp = tcp<span class="constructor">_sk(<span class="params">sk</span>)</span>;</span><br><span class="line">	<span class="keyword">struct</span> bbr *bbr = inet<span class="constructor">_csk_ca(<span class="params">sk</span>)</span>;</span><br><span class="line">	unsigned long rate = bbr<span class="constructor">_bw_to_pacing_rate(<span class="params">sk</span>, <span class="params">bw</span>, <span class="params">gain</span>)</span>;<span class="comment">//通过bw算出pacing rate</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!bbr-&gt;has_seen_rtt<span class="operator"> &amp;&amp; </span>tp-&gt;srtt_us))<span class="comment">//如果还没采样到rtt，并且之前有测过得到平滑的</span></span><br><span class="line">    rtt了，则尝试通过平滑的rtt来算pacing_rate,并更新到sk-&gt;sk_pacing_rate中</span><br><span class="line">		bbr<span class="constructor">_init_pacing_rate_from_rtt(<span class="params">sk</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (bbr<span class="constructor">_full_bw_reached(<span class="params">sk</span>)</span><span class="operator"> || </span>rate &gt; sk-&gt;sk_pacing_rate)<span class="comment">//更新pacing rate</span></span><br><span class="line">		sk-&gt;sk_pacing_rate = rate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert a BBR bw and gain factor to a pacing rate in bytes per second. */</span></span><br><span class="line">static unsigned long bbr<span class="constructor">_bw_to_pacing_rate(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>, <span class="params">u32</span> <span class="params">bw</span>, <span class="params">int</span> <span class="params">gain</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 rate = bw;</span><br><span class="line"></span><br><span class="line">	rate = bbr<span class="constructor">_rate_bytes_per_sec(<span class="params">sk</span>, <span class="params">rate</span>, <span class="params">gain</span>)</span>;</span><br><span class="line">	rate = min<span class="constructor">_t(<span class="params">u64</span>, <span class="params">rate</span>, <span class="params">sk</span>-&gt;<span class="params">sk_max_pacing_rate</span>)</span>;</span><br><span class="line">	return rate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return rate in bytes per second, optionally with a gain.</span></span><br><span class="line"><span class="comment"> * The order here is chosen carefully to avoid overflow of u64. This should</span></span><br><span class="line"><span class="comment"> * work for input rates of up to 2.9Tbit/sec and gain of 2.89x.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static u64 bbr<span class="constructor">_rate_bytes_per_sec(<span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>, <span class="params">u64</span> <span class="params">rate</span>, <span class="params">int</span> <span class="params">gain</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	unsigned <span class="built_in">int</span> mss = tcp<span class="constructor">_sk(<span class="params">sk</span>)</span>-&gt;mss_cache;</span><br><span class="line"></span><br><span class="line">	rate *= mss;<span class="comment">//mss大小，byte</span></span><br><span class="line">	rate *= gain;<span class="comment">//这里是乘以pacing_gain,也是循环增益那里选择的倍数</span></span><br><span class="line">	rate &gt;&gt;= BBR_SCALE;<span class="comment">//右移8位,即除以2^8  256</span></span><br><span class="line">	rate *= USEC_PER_SEC<span class="operator"> / </span><span class="number">100</span><span class="operator"> * </span>(<span class="number">100</span> - bbr_pacing_margin_percent);(<span class="number">1000000L</span>/<span class="number">100</span>*(<span class="number">100</span>-<span class="number">1</span>))</span><br><span class="line">	return rate &gt;&gt; BW_SCALE;<span class="comment">//右移24位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新 cwnd<br>bbr_set_cwnd(sk, rs, rs-&gt;acked_sacked, bw, bbr-&gt;cwnd_gain);</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Slow-start up toward target cwnd (if bw estimate is growing, or packet loss</span></span><br><span class="line"><span class="comment"> * has drawn us down below target), or snap down to target if we&#x27;re above it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> void <span class="title function_ invoke__">bbr_set_cwnd</span>(<span class="keyword">struct</span> <span class="title class_">sock</span> *sk, <span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">rate_sample</span> *rs,</span><br><span class="line">			 <span class="type">u32</span> acked, <span class="type">u32</span> bw, int gain)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tcp_sock</span> *tp = <span class="title function_ invoke__">tcp_sk</span>(sk);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">bbr</span> *bbr = <span class="title function_ invoke__">inet_csk_ca</span>(sk);</span><br><span class="line">	<span class="type">u32</span> cwnd = tp<span class="punctuation">-&gt;</span>snd_cwnd, target_cwnd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="title function_ invoke__">if</span> (!acked)<span class="comment">//若当前的ack没有acked任何包，则跳过</span></span><br><span class="line">		goto done;  <span class="comment">/* no packet fully ACKed; just apply caps */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在外部拥塞控制状态为recovery或丢包等外部参数给进来判断，控制拥塞窗口大小</span></span><br><span class="line">	<span class="title function_ invoke__">if</span> (<span class="title function_ invoke__">bbr_set_cwnd_to_recover_or_restore</span>(sk, rs, acked, &amp;cwnd))</span><br><span class="line">		goto done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标拥塞窗口大小为bdp</span></span><br><span class="line">	target_cwnd = <span class="title function_ invoke__">bbr_bdp</span>(sk, bw, gain);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Increment the cwnd to account for excess ACKed data that seems</span></span><br><span class="line"><span class="comment">	 * due to aggregation (of data and/or ACKs) visible in the ACK stream.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">//加上补偿</span></span><br><span class="line">	target_cwnd += <span class="title function_ invoke__">bbr_ack_aggregation_cwnd</span>(sk);</span><br><span class="line">	target_cwnd = <span class="title function_ invoke__">bbr_quantization_budget</span>(sk, target_cwnd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we&#x27;re below target cwnd, slow start cwnd toward target cwnd. */</span><span class="comment">//若小于target,则slow start</span></span><br><span class="line">	<span class="title function_ invoke__">if</span> (<span class="title function_ invoke__">bbr_full_bw_reached</span>(sk))  <span class="comment">/* only cut cwnd if we filled the pipe */</span></span><br><span class="line">		cwnd = <span class="title function_ invoke__">min</span>(cwnd + acked, target_cwnd);</span><br><span class="line">        <span class="comment">//若当前拥塞窗口小于目标拥塞窗口或已成功传递的数量小于10，则用当前拥塞窗口+acked</span></span><br><span class="line">	<span class="keyword">else</span> <span class="title function_ invoke__">if</span> (cwnd &lt; target_cwnd || tp<span class="punctuation">-&gt;</span>delivered &lt; TCP_INIT_CWND)</span><br><span class="line">		cwnd = cwnd + acked;</span><br><span class="line">	cwnd = <span class="title function_ invoke__">max</span>(cwnd, bbr_cwnd_min_target);<span class="comment">//后者为4，至少为4</span></span><br><span class="line"><span class="comment">/* TCP initial congestion window as per rfc6928 */</span></span><br><span class="line"><span class="comment">//#define TCP_INIT_CWND		10</span></span><br><span class="line">done:</span><br><span class="line">	tp<span class="punctuation">-&gt;</span>snd_cwnd = <span class="title function_ invoke__">min</span>(cwnd, tp<span class="punctuation">-&gt;</span>snd_cwnd_clamp);	<span class="comment">/* apply global cap */</span></span><br><span class="line">	<span class="title function_ invoke__">if</span> (bbr<span class="punctuation">-&gt;</span>mode == BBR_PROBE_RTT)  <span class="comment">/* drain queue, refresh min_rtt */</span></span><br><span class="line">		tp<span class="punctuation">-&gt;</span>snd_cwnd = <span class="title function_ invoke__">min</span>(tp<span class="punctuation">-&gt;</span>snd_cwnd, bbr_cwnd_min_target);<span class="comment">//此时在探测最小rtt,应该减小</span></span><br><span class="line">        <span class="comment">//窗口值，&lt;=4,因为要探测最小rtt,发送不能过快</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>状态下的图片和速率参考：<br><a target="_blank" rel="noopener" href="https://switch-router.gitee.io/blog/bbr1/">https://switch-router.gitee.io/blog/bbr1/</a></p>
<p>TODO: startup的速率曲线为什么是线性函数？跟通过cwnd的增长是：cwnd &#x3D; cwnd + acked; 有关。</p>
<h4 id="关于sack-dack-rack"><a href="#关于sack-dack-rack" class="headerlink" title="关于sack,dack,rack"></a>关于sack,dack,rack</h4><ul>
<li><p>sack，即选择性确认，可以通过tcp option携带没有收到的seq信息，从而发送方可以选择性重传部分段而不用全部都重传；</p>
</li>
<li><p>dack: D-SACK可以在SACK选项中描述它重复收到的报文段。但是需要注意的是D-SACK只用于报告接收端收到的最后一个报文与已经接收了的报文的重复部分<br>但sack也有漏洞和风险：<br><a target="_blank" rel="noopener" href="https://www.q578.com/s-5-202844-0/">https://www.q578.com/s-5-202844-0/</a></p>
</li>
<li><p>fack:fack是sack的更进一步优化，当使用fack时，sack的数据包个数不再需要超过乱序阀值，fack只关心收到的最大的sack数据包相比snd_una的间距是否超过乱序阀值，<br>当超过时就会开始标记loss，fack标记loss时，从write队列最左侧开始标记，直至待标记的skb距离最大sack的skb的间距为reordering-1为止；</p>
</li>
<li><p>rack:基于时间的RACK:<br>rack相比fack又更进一步，rack是根据skb的发送时间来判断消息包是否丢失，tcp每发送一个skb时，都会为其分配一个时间戳信息，当sack时，rack机制判断那些在被sack的数据包之前发送的，并且相比被sack的数据包的时间间距到达一定间隔时，就判断该数据包为丢失，进而进入快恢复状态，然后重传被标记丢失的数据包。</p>
</li>
</ul>
<p>关于更多ack参考：<br><a target="_blank" rel="noopener" href="https://www.freesion.com/article/6142762829/">https://www.freesion.com/article/6142762829/</a></p>
<h4 id="tcp-ack函数分析："><a href="#tcp-ack函数分析：" class="headerlink" title="tcp_ack函数分析："></a>tcp_ack函数分析：</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This routine deals with incoming acks, but not outgoing ones. */</span></span><br><span class="line">static int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)</span><br><span class="line">&#123;</span><br><span class="line">	struct inet_connection_sock *icsk = inet_csk(sk);</span><br><span class="line">	struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	struct tcp_sacktag_state sack_state;</span><br><span class="line">	struct rate_sample rs = &#123; .prior_delivered = <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="function"><span class="title">u32</span> prior_snd_una = tp-&gt;</span>snd_una;<span class="comment">//first byte we want to ack for;滑动窗口第一个未被确认的seq</span></span><br><span class="line">	<span class="function"><span class="title">bool</span> is_sack_reneg = tp-&gt;</span>is_sack_reneg;</span><br><span class="line">	<span class="function"><span class="title">u32</span> ack_seq = TCP_SKB_CB(skb)-&gt;</span>seq;<span class="comment">//starting sequence num;? ack段中的序号，关联对端发送包seq</span></span><br><span class="line">	<span class="function"><span class="title">u32</span> ack = TCP_SKB_CB(skb)-&gt;</span>ack_seq;<span class="comment">//sequence num ack&#x27;d,关联我方包，为下一个要发送的</span></span><br><span class="line">	int num_dupack = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="title">int</span> prior_packets = tp-&gt;</span>packets_out;<span class="comment">//从发送队列发出但未被确认的tcp段数，snd.nxt-snd.una)</span></span><br><span class="line">	<span class="function"><span class="title">u32</span> delivered = tp-&gt;</span>delivered;<span class="comment">//传递的总包数，包括重传？</span></span><br><span class="line">	<span class="function"><span class="title">u32</span> lost = tp-&gt;</span>lost;<span class="comment">//总丢包数，包括重传</span></span><br><span class="line">	int rexmit = REXMIT_NONE; <span class="comment">/* Flag to (re)transmit to recover losses */</span></span><br><span class="line">	u32 prior_fack;</span><br><span class="line"></span><br><span class="line">	sack_state.first_sackt = <span class="number">0</span>;</span><br><span class="line">	sack_state.rate = &amp;rs;</span><br><span class="line">	sack_state.sack_delivered = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We very likely will need to access rtx queue. */</span></span><br><span class="line">	<span class="function"><span class="title">prefetch</span>(sk-&gt;</span>tcp_rtx_queue.rb_node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the ack is older than previous acks</span></span><br><span class="line"><span class="comment">	 * then we can probably ignore it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 如果接收报文的确认序号小于本地套接口待确认序号，表明为一个已经确认过的序号，并且其确认序号在套接口当前待确认序号减去本地发送窗口之前，内核认为此报文很可能并非对端发送，即其为攻击者构造出来的报文，合法的报文确认序号ACK的范围：((SND.UNA - MAX.SND.WND) &lt;= SEG.ACK &lt;= SND.NXT)。否则，不在此范围内认为是盲数据注入攻击Blind Data Injection Attack。但是，有可能并非攻击者发送，而是来自对端的报文，此时回复挑战ACK报文，使对端有机会修正其确认序号ACK。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">按照RFC5961的描述，为应对数据注入攻击，进一步缩小合法确认序号ACK的范围，要求报文中的确认序号大于套接口第一个待确认序号。合法的报文确认序号范围：(SND.UNA &lt;= SEG.ACK &lt;= SND.NXT)。内核不处理无效确认序号的报文，避免注入非法数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">if</span> (before(ack, prior_snd_una)) &#123;<span class="comment">//ack若在窗口左边界前</span></span><br><span class="line">		<span class="comment">/* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */</span></span><br><span class="line">		<span class="function"><span class="title">if</span> (before(ack, prior_snd_una - tp-&gt;</span>max_window)) &#123;<span class="comment">//在更前</span></span><br><span class="line">			<span class="keyword">if</span> (!(flag &amp; FLAG_NO_CHALLENGE_ACK))</span><br><span class="line">				tcp_send_challenge_ack(sk, skb);</span><br><span class="line">			return -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		goto old_ack;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the ack includes data we haven&#x27;t sent yet, discard</span></span><br><span class="line"><span class="comment">	 * this segment (RFC793 Section 3.9).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (after(ack, tp-&gt;</span>snd_nxt))<span class="comment">//ack在未发送的seq后，认为没发送的ack是错误的</span></span><br><span class="line">		return -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (after(ack, prior_snd_una)) &#123;<span class="comment">//否则</span></span><br><span class="line">		flag |= FLAG_SND_UNA_ADVANCED;<span class="comment">//标记要改变snd_una，因为此时有确认的包</span></span><br><span class="line">		<span class="function"><span class="title">icsk</span>-&gt;</span>icsk_retransmits = <span class="number">0</span>;<span class="comment">//记录超时重传次数，置位0</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> IS_ENABLED(CONFIG_TLS_DEVICE)</span><br><span class="line">		<span class="keyword">if</span> (static_branch_unlikely(&amp;clean_acked_data_enabled.key))</span><br><span class="line">			<span class="function"><span class="title">if</span> (icsk-&gt;</span>icsk_clean_acked)</span><br><span class="line">				<span class="function"><span class="title">icsk</span>-&gt;</span>icsk_clean_acked(sk, ack);</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">prior_fack</span> = tcp_is_sack(tp) ? tcp_highest_sack_seq(tp) : tp-&gt;</span>snd_una;</span><br><span class="line">	rs.prior_in_flight = tcp_packets_in_flight(tp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ts_recent update must be made after we are sure that the packet</span></span><br><span class="line"><span class="comment">	 * is in window.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; FLAG_UPDATE_TS_RECENT)</span><br><span class="line">		<span class="function"><span class="title">tcp_replace_ts_recent</span>(tp, TCP_SKB_CB(skb)-&gt;</span>seq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((flag &amp; (FLAG_SLOWPATH | FLAG_SND_UNA_ADVANCED)) ==</span><br><span class="line">	    FLAG_SND_UNA_ADVANCED) &#123;<span class="comment">//快速路径，更新发送窗口，标记重传队列中各个段的记分牌</span></span><br><span class="line">		<span class="comment">/* Window is constant, pure forward advance.</span></span><br><span class="line"><span class="comment">		 * No more checks are required.</span></span><br><span class="line"><span class="comment">		 * Note, we use the fact that SND.UNA&gt;=SND.WL2.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		tcp_update_wl(tp, ack_seq);<span class="comment">//记录下snd_wl1=此ack的seq</span></span><br><span class="line">		<span class="function"><span class="title">tcp_snd_una_update</span>(tp, ack);//snd_una=ack,bytes_acked+=(ack-tp-&gt;</span>snd_una),这里有点问题</span><br><span class="line">		<span class="comment">//它把una-&gt;ack了，且认为这个ack能ack前面的段</span></span><br><span class="line">		flag |= FLAG_WIN_UPDATE;</span><br><span class="line"></span><br><span class="line">		tcp_in_ack_event(sk, CA_ACK_WIN_UPDATE);<span class="comment">//通知拥塞算法</span></span><br><span class="line"></span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPHPACKS);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//慢速路径</span></span><br><span class="line">		u32 ack_ev_flags = CA_ACK_SLOWPATH;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">if</span> (ack_seq != TCP_SKB_CB(skb)-&gt;</span>end_seq)<span class="comment">//ack携带数据</span></span><br><span class="line">			flag |= FLAG_DATA;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPPUREACKS);</span><br><span class="line"></span><br><span class="line">		flag |= tcp_ack_update_window(sk, skb, ack, ack_seq);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="title">if</span> (TCP_SKB_CB(skb)-&gt;</span>sacked)<span class="comment">//sack相关</span></span><br><span class="line">			flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,</span><br><span class="line">							&amp;sack_state);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tcp_ecn_rcv_ecn_echo(tp, tcp_hdr(skb))) &#123;<span class="comment">//ack中携带了ecn标记</span></span><br><span class="line">			flag |= FLAG_ECE;</span><br><span class="line">			ack_ev_flags |= CA_ACK_ECE;<span class="comment">//标记显示拥塞</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (sack_state.sack_delivered)</span><br><span class="line">			tcp_count_delivered(tp, sack_state.sack_delivered,</span><br><span class="line">					    flag &amp; FLAG_ECE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flag &amp; FLAG_WIN_UPDATE)</span><br><span class="line">			ack_ev_flags |= CA_ACK_WIN_UPDATE;</span><br><span class="line"></span><br><span class="line">		tcp_in_ack_event(sk, ack_ev_flags);<span class="comment">//通知拥塞控制算法窗口更新</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This is a deviation from RFC3168 since it states that:</span></span><br><span class="line"><span class="comment">	 * &quot;When the TCP data sender is ready to set the CWR bit after reducing</span></span><br><span class="line"><span class="comment">	 * the congestion window, it SHOULD set the CWR bit only on the first</span></span><br><span class="line"><span class="comment">	 * new data packet that it transmits.&quot;</span></span><br><span class="line"><span class="comment">	 * We accept CWR on pure ACKs to be more robust</span></span><br><span class="line"><span class="comment">	 * with widely-deployed TCP implementations that do this.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tcp_ecn_accept_cwr(sk, skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We passed data and got it acked, remove any soft error</span></span><br><span class="line"><span class="comment">	 * log. Something worked...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="title">sk</span>-&gt;</span>sk_err_soft = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="title">icsk</span>-&gt;</span>icsk_probes_out = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="title">tp</span>-&gt;</span>rcv_tstamp = tcp_jiffies32;<span class="comment">//标记时间戳</span></span><br><span class="line">	<span class="keyword">if</span> (!prior_packets)<span class="comment">//不需要确认</span></span><br><span class="line">		goto no_queue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* See if we can take anything off of the retransmit queue. */</span></span><br><span class="line">	flag |= tcp_clean_rtx_queue(sk, skb, prior_fack, prior_snd_una,</span><br><span class="line">				    &amp;sack_state, flag &amp; FLAG_ECE);<span class="comment">//清除重传队列中已经确认的段,更新rtt等</span></span><br><span class="line"></span><br><span class="line">	tcp_rack_update_reo_wnd(sk, &amp;rs);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">if</span> (tp-&gt;</span>tlp_high_seq)</span><br><span class="line">		tcp_process_tlp_ack(sk, ack, flag);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcp_ack_is_dubious(sk, flag)) &#123;<span class="comment">//././拥塞不是在open状态</span></span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; (FLAG_SND_UNA_ADVANCED | FLAG_NOT_DUP))) &#123;</span><br><span class="line">			num_dupack = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">/* Consider if pure acks were aggregated in tcp_add_backlog() */</span></span><br><span class="line">			<span class="keyword">if</span> (!(flag &amp; FLAG_DATA))</span><br><span class="line">				<span class="function"><span class="title">num_dupack</span> = max_t(u16, 1, skb_shinfo(skb)-&gt;</span>gso_segs);</span><br><span class="line">		&#125;</span><br><span class="line">		tcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &amp;flag,</span><br><span class="line">				      &amp;rexmit);<span class="comment">//拥塞控制相关状态处理和转移</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If needed, reset TLP/RTO timer when RACK doesn&#x27;t set. */</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; FLAG_SET_XMIT_TIMER)</span><br><span class="line">		tcp_set_xmit_timer(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((flag &amp; FLAG_FORWARD_PROGRESS) || !(flag &amp; FLAG_NOT_DUP))</span><br><span class="line">		sk_dst_confirm(sk);</span><br><span class="line"></span><br><span class="line">	delivered = tcp_newly_delivered(sk, delivered, flag);</span><br><span class="line">	<span class="function"><span class="title">lost</span> = tp-&gt;</span>lost - lost;			<span class="comment">/* freshly marked lost */</span></span><br><span class="line">	rs.is_ack_delayed = !!(flag &amp; FLAG_ACK_MAYBE_DELAYED);</span><br><span class="line">	tcp_rate_gen(sk, delivered, lost, is_sack_reneg, sack_state.rate);</span><br><span class="line">	tcp_cong_control(sk, ack, delivered, flag, sack_state.rate);<span class="comment">//拥塞控制处理</span></span><br><span class="line">	tcp_xmit_recovery(sk, rexmit);</span><br><span class="line">	return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">no_queue:</span><br><span class="line">	<span class="comment">/* If data was DSACKed, see if we can undo a cwnd reduction. */</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; FLAG_DSACKING_ACK) &#123;</span><br><span class="line">		tcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &amp;flag,</span><br><span class="line">				      &amp;rexmit);</span><br><span class="line">		tcp_newly_delivered(sk, delivered, flag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* If this ack opens up a zero window, clear backoff.  It was</span></span><br><span class="line"><span class="comment">	 * being used to time the probes, and is probably far higher than</span></span><br><span class="line"><span class="comment">	 * it needs to be for normal retransmission.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tcp_ack_probe(sk);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">if</span> (tp-&gt;</span>tlp_high_seq)</span><br><span class="line">		tcp_process_tlp_ack(sk, ack, flag);</span><br><span class="line">	return <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">old_ack:</span><br><span class="line">	<span class="comment">/* If data was SACKed, tag it and see if we should send more data.</span></span><br><span class="line"><span class="comment">	 * If data was DSACKed, see if we can undo a cwnd reduction.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="title">if</span> (TCP_SKB_CB(skb)-&gt;</span>sacked) &#123;</span><br><span class="line">		flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,</span><br><span class="line">						&amp;sack_state);</span><br><span class="line">		tcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &amp;flag,</span><br><span class="line">				      &amp;rexmit);</span><br><span class="line">		tcp_newly_delivered(sk, delivered, flag);</span><br><span class="line">		tcp_xmit_recovery(sk, rexmit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/congestion/" rel="tag"># congestion</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/01/linux-select-epoll/" rel="prev" title="linux_select_epoll">
      <i class="fa fa-chevron-left"></i> linux_select_epoll
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/10/rtprtcp-formattype/" rel="next" title="rtprtcp_formattype">
      rtprtcp_formattype <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#linux-tcp%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%A1%86%E6%9E%B6"><span class="nav-number">1.</span> <span class="nav-text">linux tcp数据发送框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#linux%E5%86%85%E6%A0%B8%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%92%8C%E7%AA%97%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E7%AA%97%E5%8F%A3%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81"><span class="nav-number">1.1.</span> <span class="nav-text">linux内核发送数据和窗口的关系，窗口如何影响数据发送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%E7%AA%97%E5%8F%A3%E6%9B%B4%E6%96%B0"><span class="nav-number">1.2.</span> <span class="nav-text">接收方窗口更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95%E5%92%8C%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="nav-number">1.3.</span> <span class="nav-text">拥塞算法和拥塞窗口简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux5-13-1%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%A1%86%E6%9E%B6"><span class="nav-number">1.4.</span> <span class="nav-text">linux5.13.1拥塞控制框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cubic%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">cubic拥塞控制算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bbr%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="nav-number">1.6.</span> <span class="nav-text">bbr拥塞控制算法：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#bbr%E7%9A%84%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">1.6.1.</span> <span class="nav-text">bbr的算法过程：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Esack-dack-rack"><span class="nav-number">1.7.</span> <span class="nav-text">关于sack,dack,rack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-ack%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">1.8.</span> <span class="nav-text">tcp_ack函数分析：</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小兴"
      src="/images/headicon2.jpg">
  <p class="site-author-name" itemprop="name">小兴</p>
  <div class="site-description" itemprop="description">始于歧路，愿归于征途</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xdksx/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xdksx&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-github-square"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/ksance@gmail.com" title="E-Mail → ksance@gmail.com"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/572897439" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;572897439" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      friendly link
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://yoursite.com/" title="http:&#x2F;&#x2F;yoursite.com" rel="noopener" target="_blank">Title</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小兴</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.1.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '06e6b70d396f6928e45a',
      clientSecret: 'cd03b7c657d50a5d76a7fa682c4f8eb48cb15fc3',
      repo        : 'xdksx.github.io',
      owner       : 'xdksx',
      admin       : ['xdksx'],
      id          : '50f30a9cf2500992eac5f8b948e4c615',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
