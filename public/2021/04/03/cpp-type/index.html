<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xdksx.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="c++数据类型： 数据类型概览1) 类型无处不在，注意表达式也有类型，一些语句本身也是某个类型的值，以下这些都有类型属性    对象的类型和基本类型    引用的类型    函数的类型(返回值类型)    函数模板特化    表达式的值类型">
<meta name="keywords" content="cpp_type">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp_type">
<meta property="og:url" content="https://xdksx.github.io/2021/04/03/cpp-type/index.html">
<meta property="og:site_name" content="追光者">
<meta property="og:description" content="c++数据类型： 数据类型概览1) 类型无处不在，注意表达式也有类型，一些语句本身也是某个类型的值，以下这些都有类型属性    对象的类型和基本类型    引用的类型    函数的类型(返回值类型)    函数模板特化    表达式的值类型">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://xdksx.github.io/2021/04/03/cpp-type/typeint.png">
<meta property="og:image" content="https://xdksx.github.io/2021/04/03/cpp-type/type1.png">
<meta property="og:updated_time" content="2021-04-04T14:10:16.423Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cpp_type">
<meta name="twitter:description" content="c++数据类型： 数据类型概览1) 类型无处不在，注意表达式也有类型，一些语句本身也是某个类型的值，以下这些都有类型属性    对象的类型和基本类型    引用的类型    函数的类型(返回值类型)    函数模板特化    表达式的值类型">
<meta name="twitter:image" content="https://xdksx.github.io/2021/04/03/cpp-type/typeint.png">

<link rel="canonical" href="https://xdksx.github.io/2021/04/03/cpp-type/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>cpp_type | 追光者</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">追光者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小兴的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-观影">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-阅读">

    <a href="/read/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-心理">

    <a href="/categories/心理/" rel="section"><i class="fa fa-fw fa-heart"></i>心理</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xdksx.github.io/2021/04/03/cpp-type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headicon2.jpg">
      <meta itemprop="name" content="小兴">
      <meta itemprop="description" content="始于歧路，愿归于征途">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="追光者">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          cpp_type
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-04 02:32:54 / 修改时间：22:10:16" itemprop="dateCreated datePublished" datetime="2021-04-04T02:32:54+08:00">2021-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-cpp/" itemprop="url" rel="index"><span itemprop="name">c&cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>c++数据类型：</p>
<h3 id="数据类型概览"><a href="#数据类型概览" class="headerlink" title="数据类型概览"></a>数据类型概览</h3><p>1) 类型无处不在，注意表达式也有类型，一些语句本身也是某个类型的值，以下这些都有类型属性<br>    对象的类型和基本类型<br>    引用的类型<br>    函数的类型(返回值类型)<br>    函数模板特化<br>    表达式的值类型<a id="more"></a><br>2) 类型如何分类以及复合类型<br>    内建类型：<br>    void,<br>    nullptr_t(c++),<br>    arithmetic 类型(整数数值)<br>    浮点数<br>    整数：<br>       bool<br>       字符<br>       有符号整数<br>       无符号整数<br>    复合类型：引用，指针，类的成员指针，数组，函数，枚举，类类型<br>3) 关于类型的命名，类型在使用时，并不是严格的按照既定名称来的，比如vector<int> 也可以作为一个类型来使用（c++)<br>    eg:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;               <span class="comment">// declaration of a pointer to int</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(p); <span class="comment">// type-id is "int*"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];   <span class="comment">// declaration of an array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">// type-id is "int[3]" (called new-type-id)</span></span><br></pre></td></tr></table></figure></int></p>
<p>4) 静态类型： 编译期确定，运行时无法改变； 动态类型：运行时动态指定，比如多态（c++）；<br>5) 未完成的类型，一些本身就是未完成的类型如void，还有是类类型中没有定义所有的函数(c++)；</p>
<h3 id="类型的分类："><a href="#类型的分类：" class="headerlink" title="类型的分类："></a>类型的分类：</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><h5 id="void"><a href="#void" class="headerlink" title="void:"></a>void:</h5><ul>
<li>1) 概念简介：void类型不能定义变量，因为是一种未完成的类型；同样不能定义数组，引用，但是可以定义void 指针以及函数返回类型也可以是void *；</li>
<li><p>2) 用法注意：<br>A: void 可以是指针类型，可以将void <em>类型的指针转换为任意类型的指针；<br>B: 既然void可以定义指针类型，也就说明这个指针是任意类型的指针，在内存中分配了8字节/4字节的地址，但是没有指定类型，也就是说其可以访问的内存范围无法确定，也就是说不能对void指针做取值操作如void </em>a; <em>a=3;/printf(</em>a);<br>void* 类型只能在转型后才能访问指向的内存地址；  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *a;</span><br><span class="line">        a=<span class="number">3</span>;<span class="comment">//这里对a赋值没问题</span></span><br><span class="line">        <span class="keyword">int</span> *b=<span class="number">0</span>;</span><br><span class="line">        a=b;<span class="comment">//这里是可以的；这样将a赋值为int 类型的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">32</span>;</span><br><span class="line">        b=&amp;c;</span><br><span class="line">        a=b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);<span class="comment">//访问a就不需要转型，毕竟指针都是固</span></span><br><span class="line">定字节的；</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*(<span class="keyword">int</span>*)a);<span class="comment">//访问*a就需要转型，即使前面</span></span><br><span class="line">赋值也没用；</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*b=3;</span></span><br><span class="line"><span class="comment">       *b=32;</span></span><br><span class="line"><span class="comment">       printf("%d\n",*b);</span></span><br><span class="line"><span class="comment">       */</span><span class="comment">//这么用回出现段错误</span></span><br><span class="line">        a = (<span class="keyword">char</span>*)a;</span><br><span class="line">        <span class="keyword">char</span> *p=<span class="string">"aaaaa"</span>;</span><br><span class="line">        a=p;</span><br><span class="line">        a=(<span class="keyword">void</span>*)a;</span><br><span class="line">        <span class="comment">//printf("%c",*a);//这里就不行，因为*操作不知道拿多</span></span><br><span class="line">少内存</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,a);<span class="comment">//这种方式倒是可以成功输出,因为不是对void *做取值，而是取其指针值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3)函数返回值void *意味着它可以接受任何类型的返回指针类型；毕竟只是返回一个指针值；</p>
</li>
<li>4)一些库函数，参数是void<em> 的，意味着可以不受限制传入任意的指定类型，但是实际上内部实现是需要做类型转换的，比如转为char</em> 除非只是对指针做透传；</li>
</ul>
<h5 id="nullptr-t"><a href="#nullptr-t" class="headerlink" title="nullptr_t"></a>nullptr_t</h5><p>std::nullptr_t (c++11)<br>Defined in header <cstddef><br>typedef decltype(nullptr) nullptr_t;<br>nullptr_t是空指针字面量nullptr的类型。它是一种特别的类型，本身不是指针类型或指向成员类型的指针。<br>nullptr_t is available in the global namespace when &lt;stddef.h&gt; is included, even if it is not a part of C.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pointer to integer overload\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pointer to double overload\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"null pointer overload\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* pi &#123;&#125;; <span class="keyword">double</span>* pd &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    f(pi);</span><br><span class="line">    f(pd);</span><br><span class="line">    f(<span class="literal">nullptr</span>); <span class="comment">// would be ambiguous without void f(nullptr_t)</span></span><br><span class="line">    <span class="comment">// f(0);    // ambiguous call: all three functions are candidates</span></span><br><span class="line">    <span class="comment">// f(NULL); // ambiguous if NULL is an integral null pointer constant </span></span><br><span class="line">                <span class="comment">// (as is the case in most implementations)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></cstddef></p>
<h4 id="数学类型：数值："><a href="#数学类型：数值：" class="headerlink" title="数学类型：数值："></a>数学类型：数值：</h4><h5 id="bool布尔类型："><a href="#bool布尔类型：" class="headerlink" title="bool布尔类型："></a>bool布尔类型：</h5><p>布尔类型只有两个值，true和false;<br>实际例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bbo = (<span class="keyword">bool</span>)<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; bbo &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> testnum = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">bool</span>)testnum &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">bool</span> tt = testnum;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; tt &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> tye = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; tye &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//true   //noboolalpha 按数值打印</span></span><br></pre></td></tr></table></figure></p>
<h5 id="字符类型-char-系列：char-signed-char-unsigned-char"><a href="#字符类型-char-系列：char-signed-char-unsigned-char" class="headerlink" title="字符类型:char 系列：char *,signed char,unsigned char"></a>字符类型:char 系列：char *,signed char,unsigned char</h5><ul>
<li><p>1) char:char是八位一个字节的类型，<br>   本身赋值可以容纳任何的八位二进制而不管符号；<br>   但是输出时则对应输出ASCII码，当不匹配任何ASCII码时，则输出乱码；<br>   内存中的值：8位值；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//实际存放的值，在小于等于2的八次方 255(全1）时，按补码方式存放，即正数时为原码，负数时为除符号位外取反加1；</span></span><br><span class="line">    <span class="keyword">char</span> a=<span class="number">-43</span>;<span class="comment">//实际存放：</span></span><br><span class="line">    <span class="keyword">char</span> b=<span class="number">0</span>;<span class="comment">//实际存放：00000000</span></span><br><span class="line">    <span class="keyword">char</span> c=<span class="number">0b11111111</span>;<span class="comment">//11111111//255</span></span><br><span class="line">    <span class="keyword">char</span> d=<span class="number">127</span>;<span class="comment">//0111 1111</span></span><br><span class="line">    <span class="keyword">char</span> e=<span class="number">0b10000000</span>;<span class="comment">//1000 0000//128</span></span><br><span class="line">    <span class="keyword">char</span> f=<span class="number">-128</span>;<span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n%c\n%c\n%c\n%c\n%c\n"</span>,a,b,c,d,e,f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------------\n"</span>);</span><br><span class="line">    <span class="comment">//读取的时候，则按补码方式读，即如10000000，则判断符号位</span></span><br><span class="line"><span class="number">1</span>，则为负数，再取反加<span class="number">1</span>则为<span class="number">-128</span>；</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n%d\n%d\n%d\n%d\n"</span>,a,b,c,d,e,f);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">-43</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">-128</span></span><br><span class="line"><span class="number">-128</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>signed和unsigned关键字含义：<br>2) signed char:其实内部存储和读取同char,可用于表示单字节有符号数；<br>3) unsigned char:即存储时还是按照补码存储，但是读取时是原码无符号取；所以存负数时，读取为正数；可用于存储单字节的无符号数；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ua=<span class="number">-21</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ub=<span class="number">23</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> uc =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ud = <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ue = <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> uf = <span class="number">128</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n%d\n%d\n%d\n%d\n"</span>,ua,ub,uc,ud,ue,uf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    输出：</span><br><span class="line">       <span class="number">235</span> (存补码：<span class="number">-23</span>-&gt;(<span class="number">1001</span> <span class="number">0101</span>-&gt;<span class="number">1110</span> <span class="number">1011</span>)-&gt;读出时按无符号：<span class="number">11101011</span>==<span class="number">235</span>）</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">255</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">128</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>4) char *:char指针若是初始化为字符串，则这个字符串是存放在常量数据区，不是在栈区，所以不能够改动，但是可以改动指针的值；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p =<span class="string">"ddd"</span>;</span><br><span class="line">*(p+<span class="number">1</span>)=<span class="string">'3'</span>;编译报错；</span><br><span class="line">      <span class="keyword">char</span> *p = <span class="string">"abcdef"</span>;</span><br><span class="line">      <span class="keyword">char</span> *p2 = p;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p2);</span><br><span class="line">      <span class="keyword">char</span> p3[]=<span class="string">"dddd"</span>;</span><br><span class="line">      p=p3;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p3);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br></pre></td></tr></table></figure>
</li>
<li><p>5）关于c++的 宽char类型： char16_t char32_t w_char</p>
</li>
</ul>
<h5 id="整数类型-short-int-long-等"><a href="#整数类型-short-int-long-等" class="headerlink" title="整数类型:short ,int ,long ,等"></a>整数类型:short ,int ,long ,等</h5><ul>
<li>short(short int)，short和short int是一样的类型，size也一样</li>
<li>short,int，long，long long 默认是有符号的，若想更清晰的使用，可以带unsigned这种；<br>不同的位数系统下，整数类型的size也不相同，有如下系统情况：<br>32 bit systems:<br>LP32 or 2/4/4 (int is 16-bit, long and pointer are 32-bit)<br>Win16 API<br>ILP32 or 4/4/4 (int, long, and pointer are 32-bit);<br>Win32 API<br>Unix and Unix-like systems (Linux, macOS)  </li>
</ul>
<p>64 bit systems:<br>LLP64 or 4/4/8 (int and long are 32-bit, pointer is 64-bit)<br>Win64 API<br>LP64 or 4/8/8 (int is 32-bit, long and pointer are 64-bit)<br>Unix and Unix-like systems (Linux, macOS)  </p>
<p>Other models are very rare. For example, ILP64 (8/8/8: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. UNICOS on Cray).</p>
<img src="/2021/04/03/cpp-type/typeint.png" title="type">
<h5 id="浮点数类型：float-double"><a href="#浮点数类型：float-double" class="headerlink" title="浮点数类型：float,double"></a>浮点数类型：float,double</h5><ul>
<li>float: 单精度浮点数</li>
<li>double :双精度浮点数</li>
<li>long double: 扩展精度的浮点数类型；<br>浮点数的一些特性：<br>1) 正数负数的无穷数<br>2) 负0.0<br>3) NaN not a number<br>数值范围表参考：</li>
</ul>
<img src="/2021/04/03/cpp-type/type1.png" title="type">
<h4 id="复合类型："><a href="#复合类型：" class="headerlink" title="复合类型："></a>复合类型：</h4><h5 id="引用类型：一个已存在的对象或函数的别名"><a href="#引用类型：一个已存在的对象或函数的别名" class="headerlink" title="引用类型：一个已存在的对象或函数的别名"></a>引用类型：一个已存在的对象或函数的别名</h5><ul>
<li>初始化：一个引用要求被一个有效的对象或函数初始化；<br>引用的存储：引用不是对象，所以没必要性占用存储，尽管编译器在必要时可以分配存储空间来实现所需的语义(例如，引用类型的非静态数据成员通常会增加类的大小，以满足存储内存地址的需要)。<br>哪些没有引用：因为引用不是对象，所以没有void的引用，也没有引用的引用，没有指向引用的指针，也没有引用的数组；  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; a[<span class="number">3</span>]; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">int</span>&amp;* p;   <span class="comment">// error</span></span><br><span class="line"><span class="keyword">int</span>&amp; &amp;r;   <span class="comment">// error</span></span><br><span class="line">这些全错；</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>引用类型不能在最高级别上符合cv要求;在声明中没有这方面的语法，如果将限定符添加到typedef-name或decltype说明符或类型模板参数中，则会忽略它</p>
<ul>
<li>引用折叠(缩写)<br>允许通过模板或typedefs中的类型操作形成对引用的引用，这种情况下引用折叠规则适用:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>&amp;  lref;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>&amp;&amp; rref;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">lref&amp;  r1 = n; <span class="comment">// type of r1 is int&amp;</span></span><br><span class="line">lref&amp;&amp; r2 = n; <span class="comment">// type of r2 is int&amp;</span></span><br><span class="line">rref&amp;  r3 = n; <span class="comment">// type of r3 is int&amp;</span></span><br><span class="line">rref&amp;&amp; r4 = <span class="number">1</span>; <span class="comment">// type of r4 is int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这一点，以及在函数模板中使用T&amp;&amp;时用于模板实参推导的特殊规则，形成了使std::forward成为可能的规则</p>
<ul>
<li>左引用<br>1） 左引用可以使用在一个已存在的对象，可选不同的cv限定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"Ex"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; r1 = s;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; r2 = s;</span><br><span class="line"> </span><br><span class="line">    r1 += <span class="string">"ample"</span>;           <span class="comment">// modifies s</span></span><br><span class="line"><span class="comment">//  r2 += "!";               // error: cannot modify through reference to const</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r2 &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints s, which now holds "Example"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2）它也可以使用在函数参数上：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_string</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    s += s; <span class="comment">// 's' is the same object as main()'s 'str'</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Test"</span>;</span><br><span class="line">    double_string(str);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3）当函数的返回值是左引用时，则函数调用表达式也可以成为表达式的左值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">char</span>&amp; <span class="title">char_number</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; s, <span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.at(n); <span class="comment">// string::at() returns a reference to char</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Test"</span>;</span><br><span class="line">    char_number(str, <span class="number">1</span>) = <span class="string">'a'</span>; <span class="comment">// the function call is lvalue, can be assigned to</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果： Tast</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>右引用<br>1) 右值引用是用来扩展临时对象的生命周期的；而const类型的左值引用也可以扩展临时对象的声明周期，但是不能被改变；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">"Test"</span>;</span><br><span class="line"><span class="comment">//  std::string&amp;&amp; r1 = s1;           // error: can't bind to lvalue</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; r2 = s1 + s1; <span class="comment">// okay: lvalue reference to const extends lifetime</span></span><br><span class="line"><span class="comment">//  r2 += "Test";                    // error: can't modify through reference to const</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; r3 = s1 + s1;      <span class="comment">// okay: rvalue reference extends lifetime</span></span><br><span class="line">    r3 += <span class="string">"Test"</span>;                    <span class="comment">// okay: can modify through reference to non-const</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r3 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2)更重要的是，当一个函数同时具有右值引用和左值引用时，右值引用重载绑定到右值(包括prvalues和xvalues)，而左值引用重载绑定到左值:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue reference overload f("</span> &lt;&lt; x &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue reference to const overload f("</span> &lt;&lt; x &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue reference overload f("</span> &lt;&lt; x &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">2</span>;</span><br><span class="line">    f(i);  <span class="comment">// calls f(int&amp;)</span></span><br><span class="line">    f(ci); <span class="comment">// calls f(const int&amp;)</span></span><br><span class="line">    f(<span class="number">3</span>);  <span class="comment">// calls f(int&amp;&amp;)</span></span><br><span class="line">           <span class="comment">// would call f(const int&amp;) if f(int&amp;&amp;) overload wasn't provided</span></span><br><span class="line">    f(<span class="built_in">std</span>::move(i)); <span class="comment">// calls f(int&amp;&amp;)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// rvalue reference variables are lvalues when used in expressions</span></span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; x = <span class="number">1</span>;</span><br><span class="line">    f(x);            <span class="comment">// calls f(int&amp; x)</span></span><br><span class="line">    f(<span class="built_in">std</span>::move(x)); <span class="comment">// calls f(int&amp;&amp; x)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3）这允许在合适的时候自动选择移动构造函数、移动赋值操作符和其他支持移动的函数(例如std::vector::push_back())。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="built_in">std</span>::move(v)); <span class="comment">// binds an rvalue reference to v</span></span><br><span class="line">assert(v.empty());</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>fowarding references<br>转发引用是一种特殊类型的引用，它保留了函数参数的值类别，使得可以通过std::forward转发它。转发引用可以是:<br>1)函数模板的函数形参声明为对同一函数模板cv- qualified类型的右值引用:  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">f</span>(<span class="title">T</span>&amp;&amp; <span class="title">x</span>) &#123;</span>                    <span class="comment">// x is a forwarding reference</span></span><br><span class="line">    <span class="keyword">return</span> g(<span class="built_in">std</span>::forward&lt;T&gt;(x)); <span class="comment">// and so can be forwarded</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    f(i); <span class="comment">// argument is lvalue, calls f&lt;int&amp;&gt;(int&amp;), std::forward&lt;int&amp;&gt;(x) is lvalue</span></span><br><span class="line">    f(<span class="number">0</span>); <span class="comment">// argument is rvalue, calls f&lt;int&gt;(int&amp;&amp;), std::forward&lt;int&gt;(x) is rvalue</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">g</span>(<span class="title">const</span> <span class="title">T</span>&amp;&amp; <span class="title">x</span>);</span> <span class="comment">// x is not a forwarding reference: const T is not cv-unqualified</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">A</span>(<span class="title">T</span>&amp;&amp; <span class="title">x</span>, <span class="title">U</span>&amp;&amp; <span class="title">y</span>, <span class="title">int</span>* <span class="title">p</span>);</span> <span class="comment">// x is not a forwarding reference: T is not a</span></span><br><span class="line">                             <span class="comment">// type template parameter of the constructor,</span></span><br><span class="line">                             <span class="comment">// but y is a forwarding reference</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)<span class="keyword">auto</span>&amp;&amp; except when deduced from a brace-enclosed initializer <span class="built_in">list</span>:</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; vec = foo();       <span class="comment">// foo() may be lvalue or rvalue, vec is a forwarding reference</span></span><br><span class="line"><span class="keyword">auto</span> i = <span class="built_in">std</span>::begin(vec); <span class="comment">// works either way</span></span><br><span class="line">(*i)++;                   <span class="comment">// works either way</span></span><br><span class="line">g(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(vec)&gt;(vec)); <span class="comment">// forwards, preserving value category</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; x: f()) &#123;</span><br><span class="line">  <span class="comment">// x is a forwarding reference; this is the safest way to use range for loops</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; z = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// *not* a forwarding reference (special case for initializer lists)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Dangling references 悬挂引用：<br>尽管引用一旦初始化，总是引用有效的对象或函数，但是可以创建一个被引用对象的生命周期结束但引用仍可访问的程序(悬空)。访问这样的引用是未定义的行为。一个常见的例子是函数返回对自动变量(局部)的引用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"Example"</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// exits the scope of s:</span></span><br><span class="line">              <span class="comment">// its destructor is called and its storage deallocated</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; r = f(); <span class="comment">// dangling reference</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r;       <span class="comment">// undefined behavior: reads from a dangling reference</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = f();  <span class="comment">// undefined behavior: copy-initializes from a dangling reference</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="指针类型-32位操作系统为4字节，64位操作系统为8字节"><a href="#指针类型-32位操作系统为4字节，64位操作系统为8字节" class="headerlink" title="指针类型:32位操作系统为4字节，64位操作系统为8字节"></a>指针类型:32位操作系统为4字节，64位操作系统为8字节</h5><p>注意指针也是一个变量，那么也可以传值和返回值；<br>一个指针的值：指向对象或函数，或一个对象的结尾(即对象位置的下一个位置) ,或空指针，或一个无效指针；<br>对多字节的类型，指向它的指针，是指向它的第一个字节，即第一个字节的位置；而指向一个对象的结尾，是指指向这个对象结尾后的第一个字节；<br>Note that two pointers that represent the same address may nonetheless have different values.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">  6 &#123;</span></span><br><span class="line">  <span class="number">7</span>     <span class="keyword">int</span> x,y;</span><br><span class="line">  <span class="number">8</span> &#125; c;</span><br><span class="line">  <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 10 </span>&#123;</span><br><span class="line"> <span class="number">11</span>     <span class="keyword">int</span> *px = &amp;c.x;</span><br><span class="line"> <span class="number">12</span>     <span class="keyword">int</span> *pxe = px+<span class="number">1</span>;</span><br><span class="line"> <span class="number">13</span>     <span class="keyword">int</span> *py = &amp;c.y;</span><br><span class="line"> <span class="number">14</span>     assert(pxe == py);</span><br><span class="line"> <span class="number">15</span>     *pxe = <span class="number">1</span>;<span class="comment">//// undefined behavior even if the assertion does not fire 最好不要这么操作；</span></span><br><span class="line"> <span class="number">16</span>     <span class="built_in">cout</span>&lt;&lt; *pxe&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"> <span class="number">17</span>     <span class="built_in">cout</span> &lt;&lt; c.y &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"> <span class="number">18</span>     <span class="built_in">cout</span> &lt;&lt; c.x &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0</span></span><br><span class="line"> <span class="number">19</span>     <span class="built_in">cout</span> &lt;&lt; *(px+<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"> <span class="number">20</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">21</span> &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1) 指向普通对象的类型 ，和指针的引用：<br>(1) 语法: S* D;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>* np = &amp;n; <span class="comment">// pointer to int</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span>* npp = &amp;np; <span class="comment">// non-const pointer to const pointer to non-const int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> (*ap)[<span class="number">2</span>] = &amp;a; <span class="comment">// pointer to array of int</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span> <span class="keyword">int</span> n; &#125;;</span><br><span class="line">S s = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* sp = &amp;s.n; <span class="comment">// pointer to the int that is a member of s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;n;     <span class="comment">// pointer to n</span></span><br><span class="line"><span class="keyword">int</span>&amp; r = *p;     <span class="comment">// reference is bound to the lvalue expression that identifies n ，注意这里是p指向的值的引用</span></span><br><span class="line">r = <span class="number">7</span>;           <span class="comment">// stores the int 7 in n</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p; <span class="comment">// lvalue-to-rvalue implicit conversion reads the value from n 输出为7</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(2) 指针的引用: int n;int <em>p = &n;int </em>&amp;r = p;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="keyword">int</span> m_value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = &amp;m_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以根据你的需求分配内存</span></span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *p = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;n;</span><br><span class="line">    <span class="keyword">int</span> *&amp;r = p;</span><br><span class="line">    r=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0 </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *pn = &amp;n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    func(pn);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pn &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(3) 一些说明：<br>指向数组的第一个成员的指针可以是用数组初始化，含隐式转换；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span>* p1 = a; <span class="comment">// pointer to the first element a[0] (an int) of the array a</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> b[<span class="number">6</span>][<span class="number">3</span>][<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">3</span>][<span class="number">8</span>] = b; <span class="comment">// pointer to the first element b[0] of the array b,</span></span><br><span class="line">                     <span class="comment">// which is an array of 3 arrays of 8 ints</span></span><br><span class="line">同样的，基类和派生类也是：支持多态</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Derived d;</span><br><span class="line">Base* p = &amp;d;</span><br></pre></td></tr></table></figure></p>
<p>(4) 指向void的指针：<br>指向任何类型对象的指针都可以隐式转换为指向void的指针(可选cv限定);指针值没有改变。反向转换需要static_cast或显式类型转换，会产生原始指针值:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* p1 = &amp;n;</span><br><span class="line"><span class="keyword">void</span>* pv = p1;</span><br><span class="line"><span class="keyword">int</span>* p2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pv);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p2 &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 1</span></span><br></pre></td></tr></table></figure></p>
<p>如果原始指针指向某个多态类型对象中的基类子对象，dynamic_cast可用于获得指向派生类型的完整对象的void<em>。<br>指向void的指针用于传递未知类型的对象，这在C接口中很常见:pthread_create期望用户提供的回调函数接受并返回void</em>。在所有情况下，调用者都有责任在使用之前将指针转换为正确的类型。</p>
<ul>
<li>2) 指向函数的类型:<br>(1) 函数指针可以用非成员函数或静态成员函数的地址进行初始化。由于函数到指针的隐式转换，寻址操作符是可选的:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> (*p1)(<span class="keyword">int</span>) = &amp;f;</span><br><span class="line"><span class="keyword">void</span> (*p2)(<span class="keyword">int</span>) = f; <span class="comment">// same as &amp;f</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>不像函数和函数的引用，函数指针是对象，因此可以进行拷贝，存储在数组和分配等  </p>
<p>(2)函数指针的一些例子<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Syntax	meaning</span><br><span class="line">int (* f)()	f is a pointer to a function with prototype int func().</span><br><span class="line">int (* f())()	f is a function taking no inputs and returning a pointer to a function with prototype int func().</span><br><span class="line">int * f()	f is a function returning a pointer-to-int.</span><br><span class="line">int (* a[])()	a is an array of pointers to functions each with prototype int func().</span><br><span class="line"><span class="keyword">int</span> (* f())[]	f is a function returning a pointer to an <span class="built_in">array</span>.</span><br><span class="line"><span class="keyword">int</span> (f[])()	Not allowed. Can't have an <span class="built_in">array</span> of functions.</span><br><span class="line">int * const *(*g)(float)	g is pointer to a function with prototype int * const * func(float) where its return value int * const * is a pointer to a read-only pointer-to-int.</span><br></pre></td></tr></table></figure></p>
<p>(3)模板和函数指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">f</span><span class="params">(T n)</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*p)(<span class="keyword">int</span>) = f; <span class="comment">// instantiates and selects f&lt;int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>3) 指向类成员变量的类型<br>(1) 指向非静态成员对象m的指针是C类的成员，可以用表达式&amp;C::m进行初始化。像&amp;(C::m)或&amp;m这样的表达式在C的成员函数中不构成指向成员的指针。<br>这样的指针可以用作指针到成员访问操作符的右操作数。<em>操作符- &gt; </em>:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">语法：S C::* D; <span class="comment">//C是类类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> //<span class="title">or</span> <span class="title">struct</span> ,<span class="title">same</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">    &#125; ;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> C::* p= &amp;C::m;<span class="comment">//按照对指针的理解，初看下，是指p是int C::m 这种类型的指针，但是在使用时需要赋值</span></span><br><span class="line">        C c = &#123;<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.*p &lt;&lt; <span class="string">'\n'</span>;<span class="comment">//但是实际上不是，因为可以直接输出，而且可以用c.的形式，说明是它的成员；</span></span><br><span class="line">    </span><br><span class="line">        C b = &#123;<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; b.*p &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//而不同对象输出不同，说明这个指针是对象持有</span></span><br><span class="line">    </span><br><span class="line">        C* cp = &amp;c;</span><br><span class="line">        cp-&gt;m= <span class="number">10</span> ;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;cp-&gt;*p &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">       <span class="comment">// std::cout &lt;&lt;sizeof(struct C) &lt;&lt; endl;//4 not include *p</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="keyword">sizeof</span>(c) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//4 not include *p ,size的时候，还是4，说明这里的形式可能不是简单的塞在结构里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(2)指向可访问的无二义性非虚基类数据成员的指针可以隐式转换为指向派生类相同数据成员的指针:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span> <span class="keyword">int</span> m; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Base::* bp = &amp;Base::m;<span class="comment">//先定义一个指向Base::m的指针，这个作为了Base的"成员"</span></span><br><span class="line">    <span class="keyword">int</span> Derived::* dp = bp;<span class="comment">//赋值后，Derived的"成员"指针，也指向了bp,Base::m</span></span><br><span class="line">    Derived d;</span><br><span class="line">    d.m = <span class="number">1</span>;<span class="comment">//对m赋值后</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d.*dp &lt;&lt; <span class="string">' '</span> &lt;&lt; d.*bp &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 1 1 ,取出的两个都是实际值是m</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(3)在相反的方向转化,从一个指向派生类的数据成员指针明确非虚拟基类的数据成员,允许static_cast和显式类型转换,即使基类没有成员(但最终派生类,当指针用于访问):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123; <span class="keyword">int</span> m; &#125;;<span class="comment">//派生类有这个成员，但是基类没有</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Derived::* dp = &amp;Derived::m; <span class="comment">//派生类的指针</span></span><br><span class="line">    <span class="keyword">int</span> Base::* bp = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> Base::*&gt;(dp);<span class="comment">//基类上要动态转换，但是即使这样</span></span><br><span class="line"> </span><br><span class="line">    Derived d;</span><br><span class="line">    d.m = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d.*bp &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// okay: prints 7</span></span><br><span class="line"> </span><br><span class="line">    Base b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.*bp &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// undefined behavior，也无法访问到派生类"成员指针"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(4)指向成员的指针类型可以是指向成员的指针本身:指向成员的指针可以是多级的，在每一级都可以有不同的cv限定。也允许指针和指针到成员的混合多层次组合: 这代码看着贼恶心了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">// const pointer to non-const member</span></span><br><span class="line">    <span class="keyword">int</span> A::* <span class="keyword">const</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// non-const pointer to data member which is a const pointer to non-const member</span></span><br><span class="line">    <span class="keyword">int</span> A::* <span class="keyword">const</span> A::* p1 = &amp;A::p;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> A a = &#123;<span class="number">1</span>, &amp;A::m&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.*(a.*p1) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// regular non-const pointer to a const pointer-to-member</span></span><br><span class="line">    <span class="keyword">int</span> A::* <span class="keyword">const</span>* p2 = &amp;a.p;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.**p2 &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>4) 指向类成员函数的类型：<br>指向非静态成员函数f的指针是类C的成员，可以完全用表达式&amp;C::f进行初始化。C成员函数中的&amp;(C::f)或&amp;f这样的表达式不构成指向成员函数的指针。<br>这样的指针可以用作指针到成员访问操作符的右操作数。- &gt; <em>和. </em>。结果表达式只能用作函数调用操作符的左操作数:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (C::* p)(<span class="keyword">int</span>) = &amp;C::f; <span class="comment">// pointer to member function f of class C</span></span><br><span class="line">    C c;</span><br><span class="line">    (c.*p)(<span class="number">1</span>);                  <span class="comment">// prints 1</span></span><br><span class="line">    C* cp = &amp;c;</span><br><span class="line">    (cp-&gt;*p)(<span class="number">2</span>);                <span class="comment">// prints 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>指向基类成员函数的指针可以隐式转换为指向派生类相同成员函数的指针:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (Base::* bp)(<span class="keyword">int</span>) = &amp;Base::f;</span><br><span class="line">    <span class="keyword">void</span> (Derived::* dp)(<span class="keyword">int</span>) = bp;</span><br><span class="line">    Derived d;</span><br><span class="line">    (d.*dp)(<span class="number">1</span>);</span><br><span class="line">    (d.*bp)(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在相反的方向转化,从一个指向派生类的成员函数指针明确非虚拟基类的成员函数,允许static_cast和显式类型转换,即使基类没有成员函数(但最终派生类,当指针用于访问):就是未定义行为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (Derived::* dp)(<span class="keyword">int</span>) = &amp;Derived::f;</span><br><span class="line">    <span class="keyword">void</span> (Base::* bp)(<span class="keyword">int</span>) = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> (Base::*)(<span class="keyword">int</span>)&gt;(dp);</span><br><span class="line"> </span><br><span class="line">    Derived d;</span><br><span class="line">    (d.*bp)(<span class="number">1</span>); <span class="comment">// okay: prints 1</span></span><br><span class="line"> </span><br><span class="line">    Base b;</span><br><span class="line">    (b.*bp)(<span class="number">2</span>); <span class="comment">// undefined behavior</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>成员函数的指针可以用作回调函数或函数对象，通常在应用了std::mem_fn或std::bind之后使用。</p>
<ul>
<li><p>5) 关于空指针的值和空指针的作用<br>(1) 值和初始化：每种类型的指针都有一个特殊的值，称为该类型的空指针值。值为null的指针不指向对象或函数(对空指针进行解引用是未定义的行为)，它与值为null的所有相同类型的指针进行比较。<br> 要初始化指向null的指针或将null值赋给现有指针，可以使用空指针字面量nullptr、空指针常量null或从整数值0的隐式转换。零初始化和值初始化也初始化指向空值的指针。<br>(2) 作用：空指针可以用来表示没有对象(例如function::target())，或者作为其他错误条件指示器(例如dynamic_cast)。通常，接收指针参数的函数几乎总是需要检查值是否为空，并以不同的方式处理这种情况(例如，当传递空指针时，delete表达式不做任何操作)。</p>
</li>
<li><p>6) 关于cv修饰指针：<br>If cv appears before <em> in the pointer declaration, it is part of decl-specifier-seq and applies to the pointed-to object. 在</em>前面，则为修饰变量<br>If cv appears after <em> in the pointer declaration, it is part of declarator and applies to the pointer that’s being declared. 在</em>后面，则为修饰指针  </p>
</li>
</ul>
<p>Syntax           meaning<br>const T<em>         pointer to constant object<br>T const</em>         pointer to constant object<br>T<em> const         constant pointer to object<br>const T</em> const   constant pointer to constant object<br>T const* const   constant pointer to constant object</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="comment">// pc is a non-const pointer to const int</span></span><br><span class="line"><span class="comment">// cpc is a const pointer to const int</span></span><br><span class="line"><span class="comment">// ppc is a non-const pointer to non-const pointer to const int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">10</span>, *pc = &amp;ci, *<span class="keyword">const</span> cpc = pc, **ppc;</span><br><span class="line"><span class="comment">// p is a non-const pointer to non-const int</span></span><br><span class="line"><span class="comment">// cp is a const pointer to non-const int</span></span><br><span class="line"><span class="keyword">int</span> i, *p, *<span class="keyword">const</span> cp = &amp;i;</span><br><span class="line"> </span><br><span class="line">i = ci;    <span class="comment">// okay: value of const int copied into non-const int</span></span><br><span class="line">*cp = ci;  <span class="comment">// okay: non-const int (pointed-to by const pointer) can be changed</span></span><br><span class="line">pc++;      <span class="comment">// okay: non-const pointer (to const int) can be changed</span></span><br><span class="line">pc = cpc;  <span class="comment">// okay: non-const pointer (to const int) can be changed</span></span><br><span class="line">pc = p;    <span class="comment">// okay: non-const pointer (to const int) can be changed</span></span><br><span class="line">ppc = &amp;pc; <span class="comment">// okay: address of pointer to const int is pointer to pointer to const int</span></span><br><span class="line"> </span><br><span class="line">ci = <span class="number">1</span>;    <span class="comment">// error: const int cannot be changed</span></span><br><span class="line">ci++;      <span class="comment">// error: const int cannot be changed</span></span><br><span class="line">*pc = <span class="number">2</span>;   <span class="comment">// error: pointed-to const int cannot be changed</span></span><br><span class="line">cp = &amp;ci;  <span class="comment">// error: const pointer (to non-const int) cannot be changed</span></span><br><span class="line">cpc++;     <span class="comment">// error: const pointer (to const int) cannot be changed</span></span><br><span class="line">p = pc;    <span class="comment">// error: pointer to non-const int cannot point to const int</span></span><br><span class="line">ppc = &amp;p;  <span class="comment">// error: pointer to pointer to const int cannot point to</span></span><br><span class="line">           <span class="comment">// pointer to non-const int</span></span><br></pre></td></tr></table></figure>
<ul>
<li>7) 关于智能指针</li>
<li>8) 关于stl中的迭代器，替代指针的方案；</li>
<li>9) 扩展：关于c++的cv概念：<a href="https://en.cppreference.com/w/cpp/language/cv" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/cv</a> 即const 和volatile</li>
<li>10）为了辅助指针的类型判断，提供了这类函数：std::is_member_pointer<br><a href="https://en.cppreference.com/w/cpp/types/is_member_pointer" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/types/is_member_pointer</a></li>
</ul>
<h5 id="数组类型：-数组可以容纳所有内建类型，字符，指针，int等数字类型；"><a href="#数组类型：-数组可以容纳所有内建类型，字符，指针，int等数字类型；" class="headerlink" title="数组类型： 数组可以容纳所有内建类型，字符，指针，int等数字类型；"></a>数组类型： 数组可以容纳所有内建类型，字符，指针，int等数字类型；</h5><ul>
<li>1）数组索引，数组元素支持和不支持，cv限定，内存情况：存放内建类型，连续物理地址存放；访问时++索引或地址即可；<br>数组索引：声明的形式T [N];,声明一个数组对象,由连续N 个T类型的对象，分配一个数组的元素编号0,…,N - 1,和可能访问下标运算符[],在[0],…,(N - 1)。<br>数组元素类型：数组可以从任何基本类型(void除外)、指针、指向成员的指针、类、枚举，或者从其他已知边界的数组(在这种情况下，该数组被称为多维数组)构造。换句话说，<br>除了未知范围的数组类型之外，只有对象类型才能成为数组类型的元素类型。不完整元素类型的数组类型也是不完整类型。 不支持引用的数组和函数的数组；<br>cv限定：将cv限定符应用于数组类型(通过类型定义或模板类型操作)将限定符应用于元素类型，但是任何元素属于cv限定类型的数组类型都被认为具有相同的cv限定符  </li>
<li><p>2)  数组的赋值：<br>数组类型的对象不能作为一个整体被修改:即使它们是左值(例如数组的地址可以被取走)，它们也不能出现在赋值操作符的左边</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, b[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = &amp;a; <span class="comment">// okay: address of a can be taken</span></span><br><span class="line">a = b;            <span class="comment">// error: a is an array</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> c[<span class="number">3</span>]; &#125; s1, s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">s1 = s2; <span class="comment">// okay: implicity-defined copy assignment operator</span></span><br><span class="line">         <span class="comment">// can assign data members of array type</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3）数组和指针之间的隐式转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"> </span><br><span class="line">void g(int (&amp;a)[3])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* p = a;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> a &lt;&lt; <span class="string">'\n'</span>  <span class="comment">// prints size of array</span></span><br><span class="line">              &lt;&lt; <span class="keyword">sizeof</span> p &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints size of a pointer</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// where arrays are acceptable, but pointers aren't, only arrays may be used</span></span><br><span class="line">    g(a); <span class="comment">// okay: function takes an array by reference</span></span><br><span class="line"><span class="comment">//  g(p); // error</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n: a)              <span class="comment">// okay: arrays can be used in range-for loops</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>; <span class="comment">// prints elements of the array</span></span><br><span class="line"><span class="comment">//  for(int n: p)              // error</span></span><br><span class="line"><span class="comment">//      std::cout &lt;&lt; n &lt;&lt; ' ';</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::iota(<span class="built_in">std</span>::begin(a), <span class="built_in">std</span>::end(a), <span class="number">7</span>); <span class="comment">// okay: begin and end take arrays</span></span><br><span class="line"><span class="comment">//  std::iota(std::begin(p), std::end(p), 7); // error</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// where pointers are acceptable, but arrays aren't, both may be used:</span></span><br><span class="line">    f(a); <span class="comment">// okay: function takes a pointer</span></span><br><span class="line">    f(p); <span class="comment">// okay: function takes a pointer</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="string">'\n'</span> <span class="comment">// prints the first element</span></span><br><span class="line">              &lt;&lt; *p &lt;&lt; <span class="string">'\n'</span> <span class="comment">// same</span></span><br><span class="line">              &lt;&lt; *(a + <span class="number">1</span>) &lt;&lt; <span class="string">' '</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>  <span class="comment">// prints the second element</span></span><br><span class="line">              &lt;&lt; *(p + <span class="number">1</span>) &lt;&lt; <span class="string">' '</span> &lt;&lt; p[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// same</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4）数组的数组，数组存放struct<br>数组的数组：多维数组其实在内存中的存放也是连续的，就是数组的每个元素是一个数组，这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dualarray[<span class="number">2</span>][<span class="number">5</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> *pp=&amp;dualarray[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//指向数组元素的指针</span></span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">5</span>]=dualarray; <span class="comment">//使用行指针，指向二维数组的行；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">10</span>;n++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*pp);</span><br><span class="line">            pp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("%d \n",**p);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">数组存放的是<span class="class"><span class="keyword">struct</span>:</span>在内存中实际上也是连续存储的，但是在取值的时候，往往因为类型不同而不能直接取；</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">cc</span> <span class="title">x</span>[3];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cc</span> <span class="title">sa</span>;</span></span><br><span class="line">    sa.a=<span class="number">1</span>;</span><br><span class="line">    sa.b=<span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cc</span> <span class="title">sb</span>;</span></span><br><span class="line">    sb.a=<span class="number">3</span>;</span><br><span class="line">    sb.b=<span class="number">4</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cc</span> <span class="title">sc</span>;</span></span><br><span class="line">    sc.a=<span class="number">5</span>;</span><br><span class="line">    sc.b=<span class="number">6</span>;</span><br><span class="line">    x[<span class="number">0</span>]=sa;</span><br><span class="line">    x[<span class="number">1</span>]=sb;</span><br><span class="line">    x[<span class="number">2</span>]=sc;</span><br><span class="line">    <span class="comment">//struct cc *sp = &amp;x[0];</span></span><br><span class="line">    <span class="keyword">int</span> *sp=&amp;x[<span class="number">0</span>].a;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">7</span>;n++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*sp);</span><br><span class="line">            sp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        输出：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>5) 未知边界的数组：<br>如果在数组的声明中省略了维度值，则声明的类型为“未知维度T的数组”，这是一种不完全类型，除非在带有初始化式的声明中使用 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x[];      <span class="comment">// the type of x is "array of unknown bound of int"</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// the type of a is "array of 3 int"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因为数组元素不能是未知边界的数组，所以多维数组除了第一个维度之外，不能有未知边界:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a[][<span class="number">2</span>]; <span class="comment">// okay: array of unknown bound of arrays of 2 int</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b[<span class="number">2</span>][]; <span class="comment">// error: array has incomplete element type</span></span><br></pre></td></tr></table></figure></p>
<p>指向未知边界数组的指针不能参与指针算术，也不能在下标操作符的左侧使用，但可以解引用。指向未知边界数组的指针和引用不能用于函数形参。<br>数组和指针，引用的隐式转换：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a1[];</span><br><span class="line"><span class="keyword">int</span> (&amp;r1)[] = a1;  <span class="comment">// okay</span></span><br><span class="line"><span class="keyword">int</span> (*p1)[] = &amp;a1; <span class="comment">// okay</span></span><br><span class="line"><span class="keyword">int</span> (*q)[<span class="number">2</span>] = &amp;a1; <span class="comment">// error (but okay in C)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;r2)[] = a2;  <span class="comment">// error</span></span><br><span class="line"><span class="keyword">int</span> (*p2)[] = &amp;a2; <span class="comment">// error (but okay in C)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>6)  指针数组：数组元素是指针</li>
<li>7)  数组和右值：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"> </span><br><span class="line">void f(int (&amp;&amp;x)[2][3])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">&#125; x;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> identity = T;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; sizeof X().i &lt;&lt; '\n';           // size of the array</span><br><span class="line">    f(X().i);                                    <span class="comment">// okay: binds to xvalue</span></span><br><span class="line"><span class="comment">//  f(x.i);                                      // error: cannot bind to lvalue</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    f(<span class="built_in">std</span>::move(a));                             <span class="comment">// okay: binds to xvalue</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">arr_t</span> = <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    f(<span class="keyword">arr_t</span>&#123;&#125;);                                  <span class="comment">// okay: binds to prvalue</span></span><br><span class="line">    f(identity&lt;<span class="keyword">int</span>[][<span class="number">3</span>]&gt;&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;); <span class="comment">// okay: binds to prvalue</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="函数类型："><a href="#函数类型：" class="headerlink" title="函数类型："></a>函数类型：</h5><ul>
<li>1) 函数的声明语法<br>一个函数的声明是介绍函数的名字和类型；函数声明可能出现在任何的scope.在类中的声明是表明一个类成员函数(友元函数除外);<br>函数的类型由返回值类型表明；<br>c++或高版本的c在传统的函数声明上加了其他语法，所以对c++ 来说：<br>(1)传统的函数声明语法<br>(2)扩展的返回值声明：这个字段被放在最外面在这种情况下，decl-specifier-seq必须包含关键字auto  </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">noptr-declarator ( parameter-<span class="built_in">list</span> ) cv(optional) ref(optional) except(optional) attr(optional)	(<span class="number">1</span>)	</span><br><span class="line">noptr-declarator ( parameter-<span class="built_in">list</span> ) cv(optional) ref(optional) except(optional) attr(optional) -&gt; trailing	(<span class="number">2</span>)	(since C++<span class="number">11</span>)</span><br><span class="line">一个函数声明由以下几部分组成：</span><br><span class="line">noptr-declarator - 任何有效的声明，但是若开始于*,&amp;,或&amp;&amp; ,则必须用小括号括起来：<span class="keyword">int</span>（*pf)(<span class="keyword">double</span> x); /<span class="keyword">int</span> (*pf)(<span class="keyword">double</span>); --这里应该指的是函数指针的声明，因为其他带&amp;这几个符号的没见需要小括号的；TODO;</span><br><span class="line">parameter-<span class="built_in">list</span>:  - 参数列表，可能为空；</span><br><span class="line">attr(c++<span class="number">11</span>): 可选的属性列表，它作用于函数的类型而不是函数本身，它标识于函数声明的最后，和函数声明的开头相关联；</span><br><span class="line">cv: --<span class="keyword">const</span>/<span class="keyword">volatile</span>: 只作用于非静态成员函数的声明；</span><br><span class="line">ref:-- 引用声明，只作用于非静态成员函数的声明；</span><br><span class="line">eg:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> &amp;</span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue object\n"</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> &amp;&amp;</span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue object\n"</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> &amp;&amp;</span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"g rvalue  boject\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">except:不属于函数类型的一部分，是异常抛出相关字段；</span><br><span class="line">trailing(c++<span class="number">11</span>): 扩展的返回类型：当返回类型依赖于参数名时很有用：eg:<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">U</span>&gt; <span class="title">auto</span> <span class="title">add</span>(<span class="title">T</span> <span class="title">t</span>, <span class="title">U</span> <span class="title">u</span>) -&gt; <span class="title">decltype</span>(<span class="title">t</span> + <span class="title">u</span>);</span></span><br><span class="line">(PS: c++<span class="number">20</span> 中还支持： requires <span class="literal">true</span>在后面，具体见参考文档)</span><br></pre></td></tr></table></figure>
<p>用法：函数的声明可以和其他声明混合在一起如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declares an int, an int*, a function, and a pointer to a function</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, *p = <span class="literal">NULL</span>, f(), (*pf)(<span class="keyword">double</span>);</span><br><span class="line"><span class="comment">// decl-specifier-seq is int</span></span><br><span class="line"><span class="comment">// declarator f() declares (but doesn't define)</span></span><br><span class="line"><span class="comment">//                a function taking no arguments and returning int</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    virtual int f(char) const, g(int) &amp;&amp;; // declares two non-static member functions</span><br><span class="line">    virtual int f(char), x; // compile-time error: virtual (in decl-specifier-seq)</span><br><span class="line">                            <span class="comment">// is only allowed in declarations of non-static</span></span><br><span class="line">                            <span class="comment">// member functions</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>2) 函数的返回值<br>函数的返回值不能是一个函数或者数组，但是可以是一个指针或者引用指向他们<br>(1) 使用auto c++11 类型推论<br>文档描述：<br>If the decl-specifier-seq of the function declaration contains the keyword auto, trailing return type may be omitted, and will be deduced by the compiler from the type of the expression used in the return statement. If the return type does not use decltype(auto), the deduction follows the rules of template argument deduction.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;        <span class="comment">// return type is int</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125; <span class="comment">// return type is const int&amp;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当返回值类型有多种情况时，会被归结为一种类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val) <span class="keyword">return</span> <span class="number">123</span>; <span class="comment">// deduces return type int</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3.14f</span>;   <span class="comment">// error: deduces return type float 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当返回值无类型，即为void时，则auto也可以用，decltype(auto)也可以用，但是注意以下情况：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;              <span class="comment">// returns void</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f(); &#125; <span class="comment">// returns void</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span>* <span class="title">x</span><span class="params">()</span> </span>&#123;&#125;             <span class="comment">// error: cannot deduce auto* from void</span></span><br></pre></td></tr></table></figure></p>
<p>当返回值能被推算是归结到相同类型，则允许：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> i;              <span class="comment">// sum’s return type is int</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> sum(i - <span class="number">1</span>) + i; <span class="comment">// okay: sum’s return type is already known</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当返回值类型是初始化列表时，不允许：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125; <span class="comment">// error</span></span><br><span class="line">虚函数和协程不允许使用<span class="keyword">auto</span>推论( c++<span class="number">14</span>/c++<span class="number">20</span>)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125; <span class="comment">// error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当一个函数已经使用auto 类型推论，则不能使用确定类型的声明和decltype，即使是相同类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span></span>;               <span class="comment">// declared, not yet defined</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125; <span class="comment">// defined, return type is int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;                <span class="comment">// error: cannot use the deduced type</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) f();     <span class="comment">// error: different kind of deduction</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span></span>;               <span class="comment">// okay: re-declared</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="function"><span class="keyword">friend</span> T <span class="title">frf</span><span class="params">(T)</span></span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">frf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i; &#125; <span class="comment">// not a friend of A&lt;int&gt;</span></span><br><span class="line">                当函数模板使用时：</span><br><span class="line">                <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">auto</span> <span class="title">f</span>(<span class="title">T</span> <span class="title">t</span>) &#123;</span> <span class="keyword">return</span> t; &#125;</span><br><span class="line">typedef decltype(f(1)) fint_t;    // instantiates f&lt;int&gt; to deduce return type</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">auto</span> <span class="title">f</span>(<span class="title">T</span>* <span class="title">t</span>) &#123;</span> <span class="keyword">return</span> *t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> (*p)(<span class="keyword">int</span>*) = &amp;f; &#125; <span class="comment">// instantiates both fs to determine return types,</span></span><br><span class="line">                                  <span class="comment">// chooses second template overload</span></span><br></pre></td></tr></table></figure></p>
<p>当函数模板的特化使用时，必须和返回值相同类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">return</span> t; &#125; <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>)</span></span>;      <span class="comment">// okay: return type is int</span></span><br><span class="line"><span class="comment">//template char g(char);     // error: no matching template</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// okay: forward declaration with unknown return type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">g</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">return</span> t; &#125; <span class="comment">// okay: not equivalent to #1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">char</span> <span class="title">g</span><span class="params">(<span class="keyword">char</span>)</span></span>;     <span class="comment">// okay: now there is a matching template</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span>)</span></span>;    <span class="comment">// still matches #1</span></span><br><span class="line"><span class="comment">//void h() &#123; return g(42); &#125; // error: ambiguous</span></span><br></pre></td></tr></table></figure></p>
<p>(2) 使用decltype c++11  用于从参数判断类型<br>int x = 1;<br>decltype(auto) f() { return x; }  // return type is int, same as decltype(x)<br>decltype(auto) f() { return(x); } // return type is int&amp;, same as decltype((x))</p>
<ul>
<li>3) 函数的参数列表<br>(1) 有如下5种语法情况：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">attr(optional) decl-specifier-seq declarator	(1)	int f(int a, int *p, int (*(*x)(double))[3]);</span><br><span class="line">attr(optional) decl-specifier-seq declarator = initializer	(<span class="number">2</span>)	<span class="keyword">int</span> f(<span class="keyword">int</span> a = <span class="number">7</span>, <span class="keyword">int</span> *p = <span class="literal">nullptr</span>, <span class="keyword">int</span> (*(*x)(<span class="keyword">double</span>))[<span class="number">3</span>] = <span class="literal">nullptr</span>);</span><br><span class="line">attr(optional) decl-specifier-seq abstract-declarator(optional)	(3)	int f(int, int *, int (*(*)(double))[3]);</span><br><span class="line">attr(optional) decl-specifier-seq abstract-declarator(optional) = initializer	(<span class="number">4</span>)	<span class="keyword">int</span> f(<span class="keyword">int</span> = <span class="number">7</span>, <span class="keyword">int</span> * = <span class="literal">nullptr</span>, <span class="keyword">int</span> (*(*)(<span class="keyword">double</span>))[<span class="number">3</span>] = <span class="literal">nullptr</span>);</span><br><span class="line">void	(5)	空参数，int f(void)和int f()一样，但是不能用cv描述，</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>, <span class="keyword">int</span>)</span></span>;(不应该只有<span class="keyword">int</span>吗) <span class="function"><span class="keyword">and</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>)</span></span>; 都是错误的,<span class="keyword">void</span>*则可以，在函数模板中，则不能被实例为T=<span class="keyword">void</span></span><br><span class="line">函数可选参数列表可以看：variadic function:手册有实例；</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(2) 关于新特性<br>c++20：如果函数的任何形参使用了占位符(auto或概念类型)，则函数声明将改为缩写的函数模板声明:</p>
<p>(3) 关于函数参数名：仅仅是为了文档化，自我说明；参数被这样解析：<br>首先，类型确定：若是T数组或未只边界的T，则被指向T的指针替代，若是函数类型F，则被指向函数F的指针替代；而对于CV限定，则只会影响函数类型，不会影响参数类型(因为函数只是传递值)：<br>因此： int f(const int p,decltype(p)<em>);和int f(int,const int</em>);是相同的声明；<br>以下声明是一样的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> s[<span class="number">3</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>* s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">volatile</span> s)</span></span>;</span><br><span class="line">这两个也一样：</span><br><span class="line">int f(int());</span><br><span class="line">int f(int (*g)());</span><br></pre></td></tr></table></figure></p>
<p>形参类型不能是包含引用或指向未知绑定数组的指针(包括此类类型的多层次指针/数组)的类型，也不能是指向形参为此类类型的函数的指针。</p>
<p>而指示可变参数的省略号不必在前面加逗号，即使它跟在指示参数包扩展的省略号后面，因此以下函数模板是完全相同的:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Args..., ...)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Args... ...)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Args......)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>使用这种声明的一个例子是std::is_function的实现</p>
<ul>
<li>4) 函数的定义<br>非成员函数定义只能出现在命名空间作用域中(没有嵌套函数)。成员函数定义也可以出现在类定义体中。它们的语法如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">attr(optional) decl-specifier-seq(optional) declarator virt-specifier-seq(optional) function-body</span><br><span class="line">where function-body is one of the following</span><br><span class="line"></span><br><span class="line">ctor-initializer(optional) compound-statement	(<span class="number">1</span>)(初始化式）	</span><br><span class="line">function-<span class="keyword">try</span>-block	(<span class="number">2</span>)	</span><br><span class="line">= <span class="keyword">delete</span> ;	(<span class="number">3</span>)	(since C++<span class="number">11</span>)</span><br><span class="line">= <span class="keyword">default</span> ;	(<span class="number">4</span>)	(since C++<span class="number">11</span>)</span><br><span class="line">即：</span><br><span class="line"><span class="number">1</span>) regular function body</span><br><span class="line"><span class="number">2</span>) function-<span class="keyword">try</span>-block (which is a regular function body wrapped in a <span class="keyword">try</span>/<span class="keyword">catch</span> block)</span><br><span class="line"><span class="number">3</span>) explicitly deleted function definition</span><br><span class="line"><span class="number">4</span>) explicitly defaulted function definition, <span class="function">only allowed <span class="keyword">for</span> special member functions <span class="keyword">and</span> comparison <span class="keyword">operator</span> <span class="title">functions</span> <span class="params">(since C++<span class="number">20</span>)</span></span></span><br><span class="line">attr(C++11)	-	optional list of attributes. These attributes are combined with the attributes after the identifier in the declarator (see top of this page), if any.</span><br><span class="line">decl-specifier-seq	-	the <span class="keyword">return</span> type with specifiers, as in the declaration grammar</span><br><span class="line">declarator	-	function declarator, same as in the function declaration grammar above. as with function declaration, it may be followed by a requires-clause (since C++<span class="number">20</span>)</span><br><span class="line">virt-specifier-seq(C++<span class="number">11</span>)	-	override, final, <span class="keyword">or</span> their combination in any order (only allowed <span class="keyword">for</span> non-<span class="keyword">static</span> member functions)  notice</span><br><span class="line">ctor-initializer	-	member initializer <span class="built_in">list</span>, only allowed in constructors</span><br><span class="line">compound-statement	-	the brace-enclosed sequence of statements that constututes the body of a function</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>eg:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (a &gt; b)? a : b;</span><br><span class="line">    <span class="keyword">return</span> (m &gt; c)? m : c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// decl-specifier-seq is "int"</span></span><br><span class="line"><span class="comment">// declarator is "max(int a, int b, int c)"</span></span><br><span class="line"><span class="comment">// body is &#123; ... &#125;函数体是一个复合语句(由0条或多条语句组成的由一对花括号括起来的序列)，在进行函数调用时执行。</span></span><br><span class="line">说明：</span><br><span class="line">形参类型以及函数定义的返回类型不能是不完整的类类型，除非函数定义为deleted(自c++ <span class="number">11</span>以来)。完整性检查是在函数体的上下文中进行的，这允许成员函数返回定义它们的类(或其外围类)，即使它在定义点是不完整的(在函数体中是完整的)。在函数定义的声明符中声明的参数在函数体的作用域中。如果在函数体中没有使用参数，则不需要对其命名(使用抽象声明符就足够了)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span> <span class="comment">// second parameter is not used</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line">尽管形参上的顶级cv限定符在函数声明中被丢弃，但它们将形参的类型修改为函数体中可见的类型:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> <span class="comment">// declares function of type void(int)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// but in the body, the type of n is const int</span></span><br><span class="line">&#125;这样就防止一些函数体内的修改(主要是引用等时，定义者来根据这个判断)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>5) 删除的函数：<br>If, instead of a function body, the special syntax = delete ; is used, the function is defined as deleted. Any use of a deleted function is ill-formed (the program will not compile). This includes calls, both explicit (with a function call operator) and implicit (a call to deleted overloaded operator, special member function, allocation function etc), constructing a pointer or pointer-to-member to a deleted function, and even the use of a deleted function in an unevaluated expression. However, implicit ODR-use of a non-pure virtual member function that happens to be deleted is allowed.</li>
</ul>
<p>If the function is overloaded, overload resolution takes place first, and the program is only ill-formed if the deleted function was selected.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sometype</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line">sometype* p = <span class="keyword">new</span> sometype; <span class="comment">// error: attempts to call deleted sometype::operator new</span></span><br><span class="line"></span><br><span class="line">删除的函数定义必须是翻译单元中的第一个声明:之前声明的函数不能被重新声明为已删除:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sometype</span> &#123;</span> sometype(); &#125;;</span><br><span class="line">sometype::sometype() = <span class="keyword">delete</span>; <span class="comment">// error: must be deleted on the first declaration</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>6) <strong>func</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Within the function body, the function-local predefined variable __func__ is defined as <span class="keyword">if</span> by</span><br><span class="line">k@VM<span class="number">-180</span><span class="number">-38</span>-ubuntu:~$ g++ -o test test.cpp </span><br><span class="line">test.cpp:<span class="number">8</span>:<span class="number">22</span>: warning: ‘__func__’ is <span class="keyword">not</span> defined outside of function scope</span><br><span class="line">    <span class="number">8</span> | <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s=__func__)</span></span>;</span><br><span class="line">      |                      ^~~~~~~~</span><br><span class="line">k@VM<span class="number">-180</span><span class="number">-38</span>-ubuntu:~$ ./test </span><br><span class="line">s:top level</span><br><span class="line">k@VM<span class="number">-180</span><span class="number">-38</span>-ubuntu:~$ cat test.cpp </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static const char __func__[]="functime name";</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s=__func__)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"s:%s\n"</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="枚举类型："><a href="#枚举类型：" class="headerlink" title="枚举类型："></a>枚举类型：</h5><p>枚举类型是一种特殊的类型，他的值被限定在一个范围内，可能会包含几个显示的命名常量表，常量的值是整数的类型<br>定义语法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum-key attr(optional) enum-name(optional) enum-base(optional)(C++11) &#123; enumerator-list(optional) &#125;</span><br><span class="line">enum-key attr(optional) enum-name enum-base(optional) ; since c++11</span><br><span class="line"><span class="keyword">enum</span>-key: 枚举关键字： <span class="keyword">enum</span> ,<span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> 或 <span class="title">enum</span> <span class="title">struct</span>其中的一个，后两者<span class="title">since</span> <span class="title">c</span>++11</span></span><br><span class="line"><span class="class"><span class="title">attr</span>(<span class="title">c</span>++11) :</span> 可选，任意数量属性的序列号</span><br><span class="line"><span class="keyword">enum</span>-name: 枚举名称，</span><br><span class="line"></span><br><span class="line">+ 大类型<span class="number">1</span>：unscoped <span class="keyword">enum</span>: 即是<span class="keyword">enum</span>修饰的<span class="keyword">enum</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>1）语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> <span class="title">name</span><span class="params">(optional)</span> </span>&#123; enumerator = <span class="keyword">constexpr</span> , enumerator = <span class="keyword">constexpr</span> , ... &#125;	(<span class="number">1</span>)	</span><br><span class="line"><span class="keyword">enum</span> name(optional) : type &#123; enumerator = <span class="keyword">constexpr</span> , enumerator = <span class="keyword">constexpr</span> , ... &#125;	(<span class="number">2</span>)	(since C++<span class="number">11</span>)</span><br><span class="line"><span class="keyword">enum</span> name : type ;	(<span class="number">3</span>)	(since C++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color &#123; red, green, blue &#125;;</span><br><span class="line">Color r = red;</span><br><span class="line"><span class="keyword">switch</span>(r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> red  : <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"red\n"</span>;   <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> green: <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"green\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> blue : <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"blue\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2)  枚举中的值，隐式和显式指定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Foo &#123; a, b, c = <span class="number">10</span>, d, e = <span class="number">1</span>, f, g = f + c &#125;;</span><br><span class="line"><span class="comment">//a = 0, b = 1, c = 10, d = 11, e = 1, f = 2, g = 12</span></span><br><span class="line">而且名字可以省略：</span><br><span class="line"><span class="keyword">enum</span> &#123; a, b, c = <span class="number">0</span>, d = a + <span class="number">2</span> &#125;; <span class="comment">// defines a = 0, b = 1, c = 0, d = 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3)  和int的隐试转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123; red, yellow, green = <span class="number">20</span>, blue &#125;;</span><br><span class="line">color col = red;</span><br><span class="line"><span class="keyword">int</span> n = blue; <span class="comment">// n == 21</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>4）枚举和其他类型的显示转换：<br>整型、浮点型和枚举类型的值可以通过static_cast或显式cast转换为任何枚举类型。如果基础类型不是固定的，并且源值超出范围，则结果是未指定的(直到c++ 17)undefined(因为c++ 17)。(如果源值能够容纳足够容纳目标枚举的所有枚举数的最小位字段，则源值在范围内，如果源值为浮点数则转换为枚举的基础类型。)否则，其结果与隐式转换到底层类型的结果相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">access_t</span> &#123; read = <span class="number">1</span>, write = <span class="number">2</span>, exec = <span class="number">4</span> &#125;; <span class="comment">// enumerators: 1, 2, 4 range: 0..7</span></span><br><span class="line"><span class="keyword">access_t</span> rwe = <span class="keyword">static_cast</span>&lt;<span class="keyword">access_t</span>&gt;(<span class="number">7</span>);</span><br><span class="line">assert((rwe &amp; read) &amp;&amp; (rwe &amp; write) &amp;&amp; (rwe &amp; exec));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">access_t</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">access_t</span>&gt;(<span class="number">8.0</span>); <span class="comment">// undefined behavior since C++17</span></span><br><span class="line"><span class="keyword">access_t</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">access_t</span>&gt;(<span class="number">8</span>); <span class="comment">// undefined behavior since C++17</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> foo &#123; a = <span class="number">0</span>, b = UINT_MAX &#125;; <span class="comment">// range: [0, UINT_MAX]</span></span><br><span class="line">foo x= foo(<span class="number">-1</span>); <span class="comment">// undefined behavior since C++17, even if foo's underlying type is unsigned int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>5)  类中枚举的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> direction &#123; left = <span class="string">'l'</span>, right = <span class="string">'r'</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line">X* p = &amp;x;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a = X::direction::left; <span class="comment">// allowed only in C++11 and later</span></span><br><span class="line"><span class="keyword">int</span> b = X::left;</span><br><span class="line"><span class="keyword">int</span> c = x.left;</span><br><span class="line"><span class="keyword">int</span> d = p-&gt;left;</span><br></pre></td></tr></table></figure>
</li>
<li><p>大类型2：scoped enum:即是enum class 或enum struct修饰的enum<br>和unscoped enum的区别在于，修饰符号不同+不能和int做隐试转换+可以使用类的一些用法：</p>
</li>
<li><p>1) 语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">struct</span>|<span class="title">class</span> <span class="title">name</span> &#123;</span> enumerator = <span class="keyword">constexpr</span> , enumerator = <span class="keyword">constexpr</span> , ... &#125;	(<span class="number">1</span>)	</span><br><span class="line"><span class="keyword">enum</span> struct|class name : type &#123; enumerator = <span class="keyword">constexpr</span> , enumerator = <span class="keyword">constexpr</span> , ... &#125;	(<span class="number">2</span>)	</span><br><span class="line"><span class="keyword">enum</span> struct|class name ;	(<span class="number">3</span>)	</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">struct</span>|<span class="title">class</span> <span class="title">name</span> :</span> type ;	(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2) 不能和int做隐式转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span> red, green = <span class="number">20</span>, blue &#125;;</span><br><span class="line">Color r = Color::blue;</span><br><span class="line"><span class="keyword">switch</span>(r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> Color::red  : <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"red\n"</span>;   <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Color::green: <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"green\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Color::blue : <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"blue\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int n = r; // error: no scoped enum to int conversion</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(r); <span class="comment">// OK, n = 21</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3) 如果满足以下条件，则unscoped和scoped都可以用以下初始化式：<br>初始化是直接列表初始化，<br>初始化器列表只有一个元素，<br>unscoped或scoped的枚举是固定的基础类型，<br>转换是非缩小的  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> byte : <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123;&#125;; <span class="comment">// byte is a new integer type</span></span><br><span class="line">byte b &#123; <span class="number">42</span> &#125;; <span class="comment">// OK as of C++17 (direct-list-initialization)</span></span><br><span class="line">byte c = &#123; <span class="number">42</span> &#125;; <span class="comment">// error</span></span><br><span class="line">byte d = byte&#123; <span class="number">42</span> &#125;; <span class="comment">// OK as of C++17; same value as b</span></span><br><span class="line">byte e &#123; <span class="number">-1</span> &#125;; <span class="comment">// error</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> byte b; &#125;;</span><br><span class="line">A a1 = &#123; &#123; <span class="number">42</span> &#125; &#125;; <span class="comment">// error (copy-list-initialization of a constructor parameter)</span></span><br><span class="line">A a2 = &#123; byte&#123; <span class="number">42</span> &#125; &#125;; <span class="comment">// OK as of C++17</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(byte)</span></span>;</span><br><span class="line">f(&#123; <span class="number">42</span> &#125;); <span class="comment">// error (copy-list-initialization of a function parameter)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Handle</span> :</span> <span class="built_in">std</span>::<span class="keyword">uint32_t</span> &#123; Invalid = <span class="number">0</span> &#125;;</span><br><span class="line">Handle h &#123; <span class="number">42</span> &#125;; <span class="comment">// OK as of C++17</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>4) 作为一种类型，它也可以这样使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> Direction&amp; rhs) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> dir;</span><br><span class="line">  <span class="keyword">switch</span> (rhs) &#123;</span><br><span class="line">    <span class="keyword">case</span> Direction::NORTH: dir = <span class="string">"NORTH"</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Direction::EAST:  dir = <span class="string">"EAST"</span>;  <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Direction::SOUTH: dir = <span class="string">"SOUTH"</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Direction::WEST:  dir = <span class="string">"WEST"</span>;  <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>c++20开始，可以用using-enum-declaration:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">enum</span> nested-name-specifier(optional) name ;</span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">fruit</span> &#123;</span> orange, apple &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">enum</span> fruit; <span class="comment">// OK: introduces orange and apple into S</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    s.orange;  <span class="comment">// OK: names fruit::orange</span></span><br><span class="line">    S::orange; <span class="comment">// OK: names fruit::orange</span></span><br><span class="line">&#125;</span><br><span class="line">名字冲突导致无法使用：</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">fruit</span> &#123;</span> orange, apple &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">color</span> &#123;</span> red, orange &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">enum</span> fruit; <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// using enum color; // error: color::orange and fruit::orange conflict</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="联合："><a href="#联合：" class="headerlink" title="联合："></a>联合：</h5><p>共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。<br>eg:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="keyword">union</span> S</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int32_t</span> n;     <span class="comment">// occupies 4 bytes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">uint16_t</span> s[<span class="number">2</span>]; <span class="comment">// occupies 4 bytes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">uint8_t</span> c;     <span class="comment">// occupies 1 byte</span></span><br><span class="line">&#125;;                      <span class="comment">// the whole union occupies 4 bytes</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s = &#123;<span class="number">0x12345678</span>&#125;; <span class="comment">// initializes the first member, s.n is now the active member</span></span><br><span class="line">    <span class="comment">// at this point, reading from s.s or s.c is undefined behavior</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; <span class="string">"s.n = "</span> &lt;&lt; s.n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    s.s[<span class="number">0</span>] = <span class="number">0x0011</span>; <span class="comment">// s.s is now the active member</span></span><br><span class="line">    <span class="comment">// at this point, reading from n or c is UB but most compilers define it</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"s.c is now "</span> &lt;&lt; +s.c &lt;&lt; <span class="string">'\n'</span> <span class="comment">// 11 or 00, depending on platform</span></span><br><span class="line">              &lt;&lt; <span class="string">"s.n is now "</span> &lt;&lt; s.n &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 12340011 or 00115678</span></span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">s.n = <span class="number">12345678</span></span><br><span class="line">s.c is now <span class="number">0</span></span><br><span class="line">s.n is now <span class="number">115678</span></span><br></pre></td></tr></table></figure></p>
<p>类和结构类型struct：和类相关，初始化，位运算</p>
<h4 id="更多类型："><a href="#更多类型：" class="headerlink" title="更多类型："></a>更多类型：</h4><p>c++的类型远不止这些，c++可以允许用户定义自己的类型；以及一些声明中出现的临时类型，总的来说：<br>c++允许这样定义类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">declaration</span>;</span></span><br><span class="line"><span class="keyword">union</span> declaration;</span><br><span class="line"><span class="keyword">enum</span> declaration;</span><br><span class="line"><span class="keyword">typedef</span> declaration;</span><br><span class="line">type alias declaration.</span><br><span class="line">还有一些在声明中出现的，c++把它们称为type-id:</span><br><span class="line">在c++程序中，通常需要引用没有名称的类型;其语法称为type-id。id类型名称类型T的语法就是声明一个变量或函数的语法类型的T,标识符中,除了decl-specifier-seq type-specifier-seq声明语法的限制,并且可以定义新类型只有在id类型出现在右边non-<span class="keyword">template</span>类型别名声明。</span><br><span class="line"><span class="keyword">int</span>* p;               <span class="comment">// declaration of a pointer to int</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(p); <span class="comment">// type-id is "int*"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];   <span class="comment">// declaration of an array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">// type-id is "int[3]" (called new-type-id)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> (*(*x[<span class="number">2</span>])())[<span class="number">3</span>];      <span class="comment">// declaration of an array of 2 pointers to functions</span></span><br><span class="line">                          <span class="comment">// returning pointer to array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> (<span class="keyword">int</span> (*(*[<span class="number">2</span>])())[<span class="number">3</span>]); <span class="comment">// type-id is "int (*(*[2])())[3]"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;                    <span class="comment">// declaration of a function taking int and returning void</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; x = f; <span class="comment">// type template parameter is a type-id "void(int)"</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">auto</span>(<span class="keyword">int</span>) -&gt; <span class="keyword">void</span>&gt; y = f; <span class="comment">// same</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;       <span class="comment">// declaration of a vector of int</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;); <span class="comment">// type-id is "std::vector&lt;int&gt;"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> x; &#125; b;         <span class="comment">// creates a new type and declares an object b of that type</span></span><br><span class="line"><span class="keyword">sizeof</span>(struct&#123; <span class="keyword">int</span> x; &#125;);    <span class="comment">// error: cannot define new types in a sizeof expression</span></span><br><span class="line"><span class="keyword">using</span> t = struct &#123; <span class="keyword">int</span> x; &#125;; <span class="comment">// creates a new type and declares t as an alias of that type</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">static</span> <span class="keyword">int</span>); <span class="comment">// error: storage class specifiers not part of type-specifier-seq</span></span><br><span class="line">std::function&lt;inline void(int)&gt; f; // error: neither are function specifiers</span><br><span class="line">声明语法中删除名称的声明器部分被称为抽象声明器。</span><br><span class="line">Type-id可用于以下情况:</span><br><span class="line">to specify the target type in cast expressions;</span><br><span class="line">as arguments to <span class="keyword">sizeof</span>, <span class="keyword">alignof</span>, alignas, <span class="keyword">new</span>, <span class="keyword">and</span> <span class="keyword">typeid</span>;</span><br><span class="line">on the right-hand side of a type alias declaration;</span><br><span class="line">as the trailing <span class="keyword">return</span> type of a function declaration;</span><br><span class="line">as the <span class="keyword">default</span> argument of a <span class="keyword">template</span> type parameter;</span><br><span class="line">as the <span class="keyword">template</span> argument <span class="keyword">for</span> a <span class="keyword">template</span> type parameter;</span><br><span class="line">in dynamic exception specification.</span><br></pre></td></tr></table></figure></p>
<p>其他： 关于静态类型，动态类型和未完成的类型；</p>
<h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><p>c位段结构：<br>位段结构中位段的定义格式为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> &lt;成员名&gt;:&lt;二进制位数&gt;</span><br><span class="line">例如：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bytedata</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">unsigned</span> a:<span class="number">2</span>;   <span class="comment">/*位段a，占2位*/</span></span><br><span class="line"> <span class="keyword">unsigned</span>:<span class="number">6</span>;  <span class="comment">/*无名位段，占6位，但不能访问*/</span></span><br><span class="line"> <span class="keyword">unsigned</span>:<span class="number">0</span>;     <span class="comment">/*无名位段，占0位，表下一位段从下一字边界开始*/</span></span><br><span class="line"> <span class="keyword">unsigned</span> b:<span class="number">10</span>;  <span class="comment">/*位段b，占10位*/</span></span><br><span class="line"> <span class="keyword">int</span> i;          <span class="comment">/*成员i，从下一字边界开始*/</span></span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure></p>
<p>位段数据的引用:<br>同结构体成员中的数据引用一样，但应注意位段的最大取值范围不要超出二进制位数定的范围，否则超出部分会丢弃。<br>例如：data.a=2;   但  data.a=10;就超出范围（a占2位，最大3）<br>应用：tcpip头等的应用 </p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/cpp-type/" rel="tag"># cpp_type</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/20/tcpip-init/" rel="prev" title="tcpip_init">
      <i class="fa fa-chevron-left"></i> tcpip_init
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/03/makefile-use/" rel="next" title="makefile_use">
      makefile_use <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型概览"><span class="nav-number">1.</span> <span class="nav-text">数据类型概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型的分类："><span class="nav-number">2.</span> <span class="nav-text">类型的分类：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本类型"><span class="nav-number">2.1.</span> <span class="nav-text">基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#void"><span class="nav-number">2.1.1.</span> <span class="nav-text">void:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#nullptr-t"><span class="nav-number">2.1.2.</span> <span class="nav-text">nullptr_t</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数学类型：数值："><span class="nav-number">2.2.</span> <span class="nav-text">数学类型：数值：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#bool布尔类型："><span class="nav-number">2.2.1.</span> <span class="nav-text">bool布尔类型：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符类型-char-系列：char-signed-char-unsigned-char"><span class="nav-number">2.2.2.</span> <span class="nav-text">字符类型:char 系列：char *,signed char,unsigned char</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#整数类型-short-int-long-等"><span class="nav-number">2.2.3.</span> <span class="nav-text">整数类型:short ,int ,long ,等</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#浮点数类型：float-double"><span class="nav-number">2.2.4.</span> <span class="nav-text">浮点数类型：float,double</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复合类型："><span class="nav-number">2.3.</span> <span class="nav-text">复合类型：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#引用类型：一个已存在的对象或函数的别名"><span class="nav-number">2.3.1.</span> <span class="nav-text">引用类型：一个已存在的对象或函数的别名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#指针类型-32位操作系统为4字节，64位操作系统为8字节"><span class="nav-number">2.3.2.</span> <span class="nav-text">指针类型:32位操作系统为4字节，64位操作系统为8字节</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数组类型：-数组可以容纳所有内建类型，字符，指针，int等数字类型；"><span class="nav-number">2.3.3.</span> <span class="nav-text">数组类型： 数组可以容纳所有内建类型，字符，指针，int等数字类型；</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数类型："><span class="nav-number">2.3.4.</span> <span class="nav-text">函数类型：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#枚举类型："><span class="nav-number">2.3.5.</span> <span class="nav-text">枚举类型：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#联合："><span class="nav-number">2.3.6.</span> <span class="nav-text">联合：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更多类型："><span class="nav-number">2.4.</span> <span class="nav-text">更多类型：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他："><span class="nav-number">2.5.</span> <span class="nav-text">其他：</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小兴"
      src="/images/headicon2.jpg">
  <p class="site-author-name" itemprop="name">小兴</p>
  <div class="site-description" itemprop="description">始于歧路，愿归于征途</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xdksx/" title="GitHub → https://github.com/xdksx/" rel="noopener" target="_blank"><i class="fa fa-fw fa-github-square"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/ksance@gmail.com" title="E-Mail → ksance@gmail.com"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/572897439" title="FB Page → https://www.facebook.com/572897439" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      friendly link
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://yoursite.com" title="http://yoursite.com" rel="noopener" target="_blank">Title</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小兴</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '06e6b70d396f6928e45a',
      clientSecret: 'cd03b7c657d50a5d76a7fa682c4f8eb48cb15fc3',
      repo        : 'xdksx.github.io',
      owner       : 'xdksx',
      admin       : ['xdksx'],
      id          : 'f86ed970b21709a90375b8816a66936e',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
