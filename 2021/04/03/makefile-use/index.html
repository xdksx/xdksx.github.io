<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xdksx.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言：以下文档参考：https://www.gnu.org/software/make/manual/make.html#toc-Overview-of-makehttps://seisman.github.io/how-to-write-makefile/introduction.html 这个文件记录了GNU make实用程序，它自动地确定一个大型程序的哪些部分需要重新编译，并发出重新编译它们">
<meta name="keywords" content="makefile">
<meta property="og:type" content="article">
<meta property="og:title" content="makefile_use">
<meta property="og:url" content="https://xdksx.github.io/2021/04/03/makefile-use/index.html">
<meta property="og:site_name" content="追光者">
<meta property="og:description" content="前言：以下文档参考：https://www.gnu.org/software/make/manual/make.html#toc-Overview-of-makehttps://seisman.github.io/how-to-write-makefile/introduction.html 这个文件记录了GNU make实用程序，它自动地确定一个大型程序的哪些部分需要重新编译，并发出重新编译它们">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-04-04T14:24:27.298Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="makefile_use">
<meta name="twitter:description" content="前言：以下文档参考：https://www.gnu.org/software/make/manual/make.html#toc-Overview-of-makehttps://seisman.github.io/how-to-write-makefile/introduction.html 这个文件记录了GNU make实用程序，它自动地确定一个大型程序的哪些部分需要重新编译，并发出重新编译它们">

<link rel="canonical" href="https://xdksx.github.io/2021/04/03/makefile-use/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>makefile_use | 追光者</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">追光者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小兴的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-观影">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-阅读">

    <a href="/read/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-心理">

    <a href="/categories/心理/" rel="section"><i class="fa fa-fw fa-heart"></i>心理</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xdksx.github.io/2021/04/03/makefile-use/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headicon2.jpg">
      <meta itemprop="name" content="小兴">
      <meta itemprop="description" content="始于歧路，愿归于征途">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="追光者">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          makefile_use
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-04 06:59:53 / 修改时间：22:24:27" itemprop="dateCreated datePublished" datetime="2021-04-04T06:59:53+08:00">2021-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>以下文档参考：<br><a href="https://www.gnu.org/software/make/manual/make.html#toc-Overview-of-make" target="_blank" rel="noopener">https://www.gnu.org/software/make/manual/make.html#toc-Overview-of-make</a><br><a href="https://seisman.github.io/how-to-write-makefile/introduction.html" target="_blank" rel="noopener">https://seisman.github.io/how-to-write-makefile/introduction.html</a></p>
<p>这个文件记录了GNU make实用程序，它自动地确定一个大型程序的哪些部分需要重新编译，并发出重新编译它们的命令<br>适用版本：<br>This is Edition 0.75, last updated 17 January 2020, of The GNU Make Manual, for GNU make version 4.3.</p>
<h3 id="make的基本功能和使用简介："><a href="#make的基本功能和使用简介：" class="headerlink" title="make的基本功能和使用简介："></a>make的基本功能和使用简介：<a id="more"></a></h3><p>make实用程序自动确定大型程序的哪些部分需要重新编译，并发出命令重新编译它们。本手册描述了由Richard Stallman和Roland McGrath实现的GNU make。从3.76版本开始的开发由Paul D. Smith负责</p>
<p>GNU make符合IEEE标准1003.2-1992 (POSIX.2)第6.2节。<br>我们的例子展示了C程序，因为它们是最常见的，但是您可以使用make与任何可以用shell命令运行编译器的编程语言一起使用。事实上，make并不局限于程序。您可以使用它来描述任何任务，其中一些文件必须在其他文件发生更改时自动更新其他文件。</p>
<h4 id="makefile是什么样的文件："><a href="#makefile是什么样的文件：" class="headerlink" title="makefile是什么样的文件："></a>makefile是什么样的文件：</h4><p>make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。</p>
<p>要准备使用make，您必须编写一个名为makefile的文件，该文件描述程序中文件之间的关系，并提供用于更新每个文件的命令。通常，在一个程序中，可执行文件从目标文件中更新，而目标文件又通过编译源文件而生成。</p>
<p>一旦有了合适的makefile，每次你修改一些源文件时，这个简单的shell命令: make<br>足够执行所有必要的重新编译。make程序使用makefile数据库和文件的最后修改时间来决定哪些文件需要更新。对于这些文件中的每一个，它都会发出在数据库中记录的recipes</p>
<h4 id="makefiles介绍："><a href="#makefiles介绍：" class="headerlink" title="makefiles介绍："></a>makefiles介绍：</h4><p>您需要一个名为makefile的文件来告诉make做什么。通常，makefile告诉make如何编译和链接程序。<br>1  若一个头文件变了，那每个包含该头文件的c源文件必须被重新编译<br>2  当make开始重新编译时，每个改变过的c源文件必须被重新编译；<br>3  每个编译过程产生一个目标文件关联源文件；<br>4  最后，若任一源文件发生重编，全部目标文件，必须重新连接产生新的可执行目标程序，不管这个时候是新产生还是覆盖之前的编译保存的；  </p>
<h4 id="makefile中的规则："><a href="#makefile中的规则：" class="headerlink" title="makefile中的规则："></a>makefile中的规则：</h4><p>每个规则由以下三部分组成：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">target … : prerequisites …</span><br><span class="line">        recipe</span><br><span class="line">        …</span><br><span class="line">        …</span><br><span class="line">目标：</span><br><span class="line">A target is usually <span class="keyword">the</span> name <span class="keyword">of</span> <span class="keyword">a</span> <span class="built_in">file</span> that is generated <span class="keyword">by</span> <span class="keyword">a</span> program;examples <span class="keyword">of</span> targets are executable <span class="keyword">or</span> object <span class="built_in">files</span>.</span><br><span class="line">A target can also be <span class="keyword">the</span> name <span class="keyword">of</span> <span class="keyword">an</span> action <span class="built_in">to</span> carry out, such <span class="keyword">as</span> ‘clean’ (see Phony Targets).</span><br><span class="line">A target depends <span class="keyword">on</span> <span class="title">several</span> <span class="title">files</span>.</span><br><span class="line">命令：</span><br><span class="line">A recipe may have more than <span class="literal">one</span> <span class="keyword">command</span>, <span class="title">either</span> <span class="title">on</span> <span class="title">the</span> <span class="title">same</span> <span class="title">line</span> <span class="title">or</span> <span class="title">each</span> <span class="title">on</span> <span class="title">its</span> <span class="title">own</span> <span class="title">line</span>.</span><br><span class="line"><span class="built_in">put</span> <span class="keyword">a</span> <span class="literal">tab</span> <span class="keyword">character</span> <span class="keyword">at</span> <span class="keyword">the</span> beginning <span class="keyword">of</span> every recipe <span class="built_in">line</span>!</span><br><span class="line">RECIPEPREFIX 用于设置不用<span class="literal">tab</span>而用别的字符</span><br><span class="line">依赖文件：</span><br><span class="line">prerequisites:是依赖的文件，它存在是为了在文件更新时，重新执行recipe以重新生成目标的作用；</span><br><span class="line"> 因为若是不需要：则直接类似clean， </span><br><span class="line"> clean： </span><br><span class="line">    rm -rf main 类似这样的写法； </span><br><span class="line">main: </span><br><span class="line">    gcc -o main main.cpp 就可以，</span><br><span class="line">    但是这样main.cpp更新的时候，make不会重新生成 </span><br><span class="line">main: main.cpp </span><br><span class="line">    gcc -o main main.cpp hh.cpp </span><br><span class="line">    这样hh.cpp变更的时候，make也是不会更新的，必须也把hh.cpp写到prerequisites 中</span><br><span class="line"></span><br><span class="line">clean’ does <span class="keyword">not</span> have prerequisites.</span><br><span class="line">总的来讲，规则：</span><br><span class="line">A rule, <span class="keyword">then</span>,  explains how <span class="keyword">and</span> when <span class="built_in">to</span> remake certain <span class="built_in">files</span> which are <span class="keyword">the</span> targets <span class="keyword">of</span> <span class="keyword">the</span> particular rule</span><br><span class="line">A rule can also explain how <span class="keyword">and</span> when <span class="built_in">to</span> carry out <span class="keyword">an</span> action.</span><br><span class="line">A makefile may contain other <span class="keyword">text</span> besides rules</span><br></pre></td></tr></table></figure></p>
<h4 id="一个简单的例子："><a href="#一个简单的例子：" class="headerlink" title="一个简单的例子："></a>一个简单的例子：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">edit</span> : <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">kbd</span><span class="selector-class">.o</span> <span class="selector-tag">command</span><span class="selector-class">.o</span> <span class="selector-tag">display</span><span class="selector-class">.o</span> \</span><br><span class="line">       <span class="selector-tag">insert</span><span class="selector-class">.o</span> <span class="selector-tag">search</span><span class="selector-class">.o</span> <span class="selector-tag">files</span><span class="selector-class">.o</span> <span class="selector-tag">utils</span><span class="selector-class">.o</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-o</span> <span class="selector-tag">edit</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">kbd</span><span class="selector-class">.o</span> <span class="selector-tag">command</span><span class="selector-class">.o</span> <span class="selector-tag">display</span><span class="selector-class">.o</span> \</span><br><span class="line">                   <span class="selector-tag">insert</span><span class="selector-class">.o</span> <span class="selector-tag">search</span><span class="selector-class">.o</span> <span class="selector-tag">files</span><span class="selector-class">.o</span> <span class="selector-tag">utils</span><span class="selector-class">.o</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.o</span> : <span class="selector-tag">main</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">main</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">kbd</span><span class="selector-class">.o</span> : <span class="selector-tag">kbd</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span> <span class="selector-tag">command</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">kbd</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">command</span><span class="selector-class">.o</span> : <span class="selector-tag">command</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span> <span class="selector-tag">command</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">command</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">display</span><span class="selector-class">.o</span> : <span class="selector-tag">display</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span> <span class="selector-tag">buffer</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">display</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">insert</span><span class="selector-class">.o</span> : <span class="selector-tag">insert</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span> <span class="selector-tag">buffer</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">insert</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">search</span><span class="selector-class">.o</span> : <span class="selector-tag">search</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span> <span class="selector-tag">buffer</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">search</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">files</span><span class="selector-class">.o</span> : <span class="selector-tag">files</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span> <span class="selector-tag">buffer</span><span class="selector-class">.h</span> <span class="selector-tag">command</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">files</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">utils</span><span class="selector-class">.o</span> : <span class="selector-tag">utils</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">utils</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">clean</span> :</span><br><span class="line">        <span class="selector-tag">rm</span> <span class="selector-tag">edit</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">kbd</span><span class="selector-class">.o</span> <span class="selector-tag">command</span><span class="selector-class">.o</span> <span class="selector-tag">display</span><span class="selector-class">.o</span> \</span><br><span class="line">           <span class="selector-tag">insert</span><span class="selector-class">.o</span> <span class="selector-tag">search</span><span class="selector-class">.o</span> <span class="selector-tag">files</span><span class="selector-class">.o</span> <span class="selector-tag">utils</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>In fact, each ‘.o’ file is both a target and a prerequisite.<br>Recipes include ‘cc -c main.c’ and ‘cc -c kbd.c’.<br>main.o 也可以通过make main.o生成<br>什么时候会真的重编译链接：注意当一个目标是文件时，若任何它的依赖改变，它需要被重新编译或链接；<br>并且：任何依赖自身也应该先被自动更新再生成；<br>When a target is a file, it needs to be recompiled or relinked if any of its prerequisites change<br>In addition, any prerequisites that are themselves automatically generated should be updated first.  </p>
<p>生成规则是由使用者定的，make会执行给定的规则中的每一行：<br>比如下面给了两行，当main.o发生改变时，make的时候就会执行下面两个gcc   </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main: main<span class="selector-class">.o</span> </span><br><span class="line">    gcc -c main<span class="selector-class">.cpp</span> </span><br><span class="line">    gcc -o main main.o</span><br></pre></td></tr></table></figure>
<p>phony targets<br>虚假目标的概念，不依赖其他文件，执行时需要明确指出目标如： make clean </p>
<p>default goal.<br>make会把第一个目标当成默认目标，则 注意位置：  </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hh<span class="selector-class">.o</span>: hh<span class="selector-class">.cpp</span> hh<span class="selector-class">.h</span> </span><br><span class="line">    gcc -c hh<span class="selector-class">.cpp</span> </span><br><span class="line">main: main<span class="selector-class">.cpp</span> hh<span class="selector-class">.cpp</span> </span><br><span class="line">    gcc -o main main<span class="selector-class">.cpp</span> hh.cpp</span><br></pre></td></tr></table></figure>
<p>这样make的时候，是只会执行gcc -c hh.cpp 注意这里hh.o不依赖main </p>
<ul>
<li>规则的递归依赖重生成 解释下：makefile如下 重要！！！<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">think@think-VirtualBox:~/c++$ cat makefile </span><br><span class="line">main: hh<span class="selector-class">.o</span> main.o</span><br><span class="line">	gcc -o main main<span class="selector-class">.o</span> hh.o</span><br><span class="line">hh<span class="selector-class">.o</span>: hh<span class="selector-class">.cpp</span> hh.h</span><br><span class="line">	gcc -c hh.cpp</span><br><span class="line">main<span class="selector-class">.o</span>: main.cpp</span><br><span class="line">	gcc -c main.cpp</span><br><span class="line">首次make</span><br><span class="line">think@think-VirtualBox:~/c++$ make </span><br><span class="line">gcc -c main.cpp</span><br><span class="line">gcc -o main main<span class="selector-class">.o</span> hh.o</span><br><span class="line">改变hh<span class="selector-class">.h</span>,重新生成hh.o和main</span><br><span class="line">think@think-VirtualBox:~/c++$ vim hh.h</span><br><span class="line">think@think-VirtualBox:~/c++$ make </span><br><span class="line">gcc -c hh.cpp</span><br><span class="line">gcc -o main main<span class="selector-class">.o</span> hh.o</span><br><span class="line">删除main<span class="selector-class">.o</span> make重新生成main.o和main，不改变hh.o</span><br><span class="line">think@think-VirtualBox:~/c++$ rm -rf main.o</span><br><span class="line">think@think-VirtualBox:~/c++$ make </span><br><span class="line">gcc -c main.cpp</span><br><span class="line">gcc -o main main<span class="selector-class">.o</span> hh.o</span><br><span class="line">修改main.cpp，重新生成main.o和main</span><br><span class="line">think@think-VirtualBox:~/c++$ vim main<span class="selector-class">.cpp</span> </span><br><span class="line">think@think-VirtualBox:~/c++$ make </span><br><span class="line">gcc -c main.cpp</span><br><span class="line">gcc -o main main<span class="selector-class">.o</span> hh.o</span><br><span class="line">think@think-VirtualBox:~/c++$</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>But make would update automatically generated C programs, such as those made by Bison or Yacc, by their own rules at this time.<br>特例，暂时没用上<br>Thus, if we change the file insert.c and run make, make will compile that file to update insert.o, and then link edit. If we change the file<br>command.h and run make, make will recompile the object files kbd.o, command.o and files.o and then link the file edit.</p>
<h4 id="makefile中的变量使用："><a href="#makefile中的变量使用：" class="headerlink" title="makefile中的变量使用："></a>makefile中的变量使用：</h4><p>We would define such a variable objects with a line like this in the makefile:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objects = main.<span class="keyword">o</span> kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">display</span>.<span class="keyword">o</span> \</span><br><span class="line">          <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> utils.<span class="keyword">o</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">edit</span> : $(objects)</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">o</span> <span class="keyword">edit</span> $(objects)</span><br><span class="line">main.<span class="keyword">o</span> : main.<span class="keyword">c</span> defs.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> main.<span class="keyword">c</span></span><br><span class="line">kbd.<span class="keyword">o</span> : kbd.<span class="keyword">c</span> defs.h <span class="keyword">command</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> kbd.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">command</span>.<span class="keyword">o</span> : <span class="keyword">command</span>.<span class="keyword">c</span> defs.h <span class="keyword">command</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">command</span>.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">display</span>.<span class="keyword">o</span> : <span class="keyword">display</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">display</span>.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">insert</span>.<span class="keyword">o</span> : <span class="keyword">insert</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">insert</span>.<span class="keyword">c</span></span><br><span class="line"><span class="built_in">search</span>.<span class="keyword">o</span> : <span class="built_in">search</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="built_in">search</span>.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">files</span>.<span class="keyword">o</span> : <span class="keyword">files</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h <span class="keyword">command</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">files</span>.<span class="keyword">c</span></span><br><span class="line">utils.<span class="keyword">o</span> : utils.<span class="keyword">c</span> defs.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> utils.<span class="keyword">c</span></span><br><span class="line">clean :</span><br><span class="line">        rm <span class="keyword">edit</span> $(objects)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>makefile中的隐式规则：<br>上述的可以简化为：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">implicit rule <span class="keyword">for</span> updating <span class="keyword">a</span> ‘.<span class="keyword">o</span>’ <span class="keyword">file</span> from <span class="keyword">a</span> correspondingly named ‘.<span class="keyword">c</span>’ <span class="keyword">file</span> using <span class="keyword">a</span> ‘<span class="keyword">cc</span> -<span class="keyword">c</span>’ <span class="keyword">command</span>.</span><br><span class="line">objects = main.<span class="keyword">o</span> kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">display</span>.<span class="keyword">o</span> \</span><br><span class="line">          <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> utils.<span class="keyword">o</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">edit</span> : $(objects)</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">o</span> <span class="keyword">edit</span> $(objects)</span><br><span class="line"></span><br><span class="line">main.<span class="keyword">o</span> : defs.h</span><br><span class="line">kbd.<span class="keyword">o</span> : defs.h <span class="keyword">command</span>.h</span><br><span class="line"><span class="keyword">command</span>.<span class="keyword">o</span> : defs.h <span class="keyword">command</span>.h</span><br><span class="line"><span class="keyword">display</span>.<span class="keyword">o</span> : defs.h <span class="keyword">buffer</span>.h</span><br><span class="line"><span class="keyword">insert</span>.<span class="keyword">o</span> : defs.h <span class="keyword">buffer</span>.h</span><br><span class="line"><span class="built_in">search</span>.<span class="keyword">o</span> : defs.h <span class="keyword">buffer</span>.h</span><br><span class="line"><span class="keyword">files</span>.<span class="keyword">o</span> : defs.h <span class="keyword">buffer</span>.h <span class="keyword">command</span>.h</span><br><span class="line">utils.<span class="keyword">o</span> : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">        rm <span class="keyword">edit</span> $(objects)</span><br></pre></td></tr></table></figure>
</li>
<li><p>继续简化：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">objects = main.<span class="keyword">o</span> kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">display</span>.<span class="keyword">o</span> \</span><br><span class="line">          <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> utils.<span class="keyword">o</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">edit</span> : $(objects)</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">o</span> <span class="keyword">edit</span> $(objects)</span><br><span class="line"></span><br><span class="line">$(objects) : defs.h</span><br><span class="line">kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> : <span class="keyword">command</span>.h</span><br><span class="line"><span class="keyword">display</span>.<span class="keyword">o</span> <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> : <span class="keyword">buffer</span>.h</span><br></pre></td></tr></table></figure>
</li>
<li><p>伪目标的意义：<br>.PHONY : clean<br>声明clean是伪目标<br>This prevents make from getting confused by an actual file called clean and causes it to continue in spite of errors from rm.<br>(See Phony Targets, and Errors in Recipes.)  </p>
</li>
</ul>
<h3 id="如何写makefile？"><a href="#如何写makefile？" class="headerlink" title="如何写makefile？"></a>如何写makefile？</h3><p>make依赖读取一个叫makefile的数据库中的信息来知道怎么重新编译一个系统</p>
<h4 id="makefile文件包含什么："><a href="#makefile文件包含什么：" class="headerlink" title="makefile文件包含什么："></a>makefile文件包含什么：</h4><ul>
<li>组成：显示规则，隐式规则，变量定义，指令和注释<br>显示规则：说明什么时候和怎么去重新make一个或多个称为目标的文件；它列出了目标依赖的所有文件，即prerequisites，它也给出怎么创建和更新目标的指令如gcc<br>隐式规则：说明什么时候和怎么去重新make一类文件基于他们的名字，它描述了目标如何依赖于名称与目标类似的文件，并给出了创建或更新这样一个目标的方法。<br>变量：是为以后可以替换到文本中的变量指定文本字符串值的一行。<br>指令是哪些呢？  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读取另一个makefile  </span><br><span class="line">类似条件判断，忽略一部分逻辑  </span><br><span class="line">从包含多行的逐字字符串定义变量</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>关于注释： # 开头，\ 可以跨行注释，不能在变量中用#，# 可以起到在字符中转义的作用；</p>
<ul>
<li>makefile对行的处理：<br>makefile使用一种“基于行”的语法，其中换行符是特殊的，并标记语句的结束。GNU make对语句行的长度没有限制，直到您计算机中的内存大小。<br>通过\反斜杠转义内部的换行符，从而延长一个行；以换行符结束(不管是否转义)作为物理行，以完整语句直到非转义换行符作为逻辑行；<br>eg:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    main: edit.o main.o \  物理行</span><br><span class="line">        k.o   # 逻辑行</span><br><span class="line">        gcc -o main main.o k.o edit.o</span><br><span class="line"></span><br><span class="line">注意：指令行：recipe行可能处理有点不同，对非指令行来讲，换行时多个连续的空格会被压缩成一个；</span><br><span class="line">一个小技巧：</span><br><span class="line">若你不想在通过\续行后，出现空格，比如：</span><br><span class="line">var := one\</span><br><span class="line">       word</span><br><span class="line">后解析为：</span><br><span class="line">var := one word</span><br><span class="line">则可以写成这样：</span><br><span class="line">var := one$\</span><br><span class="line">       word</span><br><span class="line">这样会得到：</span><br><span class="line">var := oneword</span><br><span class="line">原因：美元符号加\ 在make将\和前面的空格压缩为一个空格后为： one$ word， 而之后，'$ '会被make识别为' '为名的变量，而这个变量不存在，就会用空字符串替代</span><br><span class="line">变成 var := oneword</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="makefile文件的命名；"><a href="#makefile文件的命名；" class="headerlink" title="makefile文件的命名；"></a>makefile文件的命名；</h4><p>makefile文件可以命名为：makefile/Makefile/GNUmakefile,推荐第二种；不推荐第三种，因为其他make程序不认；<br>如果不想用默认的，即make时会默认找上面的三种文件，找不到又没有指定，则无法make，可以通过-f /–file 来指定make的文件；<br>如make -f mymakefile;还可以指定多个： make -f mymakefile -f yourmakefile;  </p>
<h4 id="一个makefile文件如何使用其他makefile文件"><a href="#一个makefile文件如何使用其他makefile文件" class="headerlink" title="一个makefile文件如何使用其他makefile文件"></a>一个makefile文件如何使用其他makefile文件</h4><p>语法：<br>include filename…<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">include foo *<span class="selector-class">.mk</span> $(bar)</span><br><span class="line">include aa<span class="selector-class">.mk</span> bish bash</span><br><span class="line">include aa<span class="selector-class">.mk</span> bb.mk</span><br><span class="line">include /user/local/m.mk</span><br></pre></td></tr></table></figure></p>
<p>如果指定的名称不以斜杠开头，并且在当前目录中找不到该文件，则会搜索其他几个目录。<br>首先，搜索使用’ -I ‘或’——include-dir ‘选项指定的任何目录。<br>然后搜索以下目录(如果它们存在的话)，顺序如下:prefix/include(通常是/usr/local/include 1) /usr/gnu/include， /usr/local/include， 找不到则警告，若不想要警告信息，可以用这个语法：<br>-include filenames…  </p>
<h4 id="MAKEFILES变量；类似于include"><a href="#MAKEFILES变量；类似于include" class="headerlink" title="MAKEFILES变量；类似于include"></a>MAKEFILES变量；类似于include</h4><p>如果你的当前环境中定义了环境变量 MAKEFILES ，那么，make会把这个变量中的值做一个类似于 include 的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和 include 不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>
<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。<br>在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<h4 id="overrding-makefiles"><a href="#overrding-makefiles" class="headerlink" title="overrding makefiles"></a>overrding makefiles</h4><p>有时，拥有一个与另一个makefile基本相同的makefile是很有用的。<br>你可以经常使用’ include ‘指令将一个包含到另一个中，并添加更多的目标或变量定义。但是，两个makefile为同一个目标提供不同的recipes(指令)是无效的。但还有另一种方法。</p>
<h4 id="make如何读取makefile"><a href="#make如何读取makefile" class="headerlink" title="make如何读取makefile"></a>make如何读取makefile</h4><p>GNU的make工作时的执行步骤如下：（想来其它的make也是类似）  </p>
<p>1 读入所有的Makefile。<br>2 读入被include的其它Makefile。<br>3 初始化文件中的变量。<br>4 推导隐晦规则，并分析所有规则。<br>5 为所有的目标文件创建依赖关系链。<br>6 根据依赖关系，决定哪些目标要重新生成。<br>7 执行生成命令。<br>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。  </p>
<p>当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>
<h4 id="make如何解析makefile"><a href="#make如何解析makefile" class="headerlink" title="make如何解析makefile"></a>make如何解析makefile</h4><h4 id="How-and-when-secondary-expansion-is-performed"><a href="#How-and-when-secondary-expansion-is-performed" class="headerlink" title="How and when secondary expansion is performed."></a>How and when secondary expansion is performed.</h4><h3 id="makefile的规则书写"><a href="#makefile的规则书写" class="headerlink" title="makefile的规则书写"></a>makefile的规则书写</h3><p>如果默认目标没有指定，则默认第一个规则的第一个目标为默认目标，有两个例外，以句号开头的目标除非包含/ ;<br>所以我们经常用第一个规则来编整个程序或者以all: 描述整个程序；</p>
<h4 id="Rule的例子"><a href="#Rule的例子" class="headerlink" title="Rule的例子"></a>Rule的例子</h4><p>一个例子和解释：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.<span class="keyword">c</span> defs.h       # <span class="keyword">module</span> for twiddling the frobs</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> -g foo.<span class="keyword">c</span></span><br></pre></td></tr></table></figure></p>
<p>这个规则说明：<br>1) 如何确定foo.o过期了： 它不存在或者foo.c/defs.h 比它更新<br>2) 如何更新foo.o: 通过运行cc，这个规则没有显示指定defs.h,但是c文件肯定包含，需要加到依赖；  </p>
<h4 id="Rule语法"><a href="#Rule语法" class="headerlink" title="Rule语法"></a>Rule语法</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">targets : <span class="type">prerequisites</span></span><br><span class="line">        recipe</span><br><span class="line">        …</span><br><span class="line"><span class="keyword">or</span> like:</span><br><span class="line">targets : <span class="type">prerequisites</span> ; recipe</span><br><span class="line">        recipe</span><br><span class="line">        …</span><br></pre></td></tr></table></figure>
<ul>
<li>目标: 一般是文件名，由空格分割，可以使用通配符，并且a(m)代表归档文件中a中的成员m,通常一个规则一个目标，也可能有多个；  </li>
<li>规则: 以tab开头，可以是上面的两种方式，注意分号；  </li>
<li>变量：因为变量是以美元符号$开头的，所以若要在目标和依赖中写$,则必须用两个$,如$$.若已经使用了二次扩展，且想在其中放$,则要用四个$  </li>
<li>反斜杠用来延长行；  </li>
<li>指令其实不止是gcc,还可以是其他shell指令  </li>
</ul>
<h4 id="依赖文件的类型"><a href="#依赖文件的类型" class="headerlink" title="依赖文件的类型"></a>依赖文件的类型</h4><p>一般的任何依赖更新了，目标都要更新；</p>
<h4 id="Wildcards-通配符-用法"><a href="#Wildcards-通配符-用法" class="headerlink" title="Wildcards(通配符)用法"></a>Wildcards(通配符)用法</h4><p>单个文件名可以使用通配符匹配多个文件,在make中，通配符有：<em>,?,[…]等，和shell相同，如</em>.c表示所有.c结尾的文件；<br>文件名开头的“~”字符也具有特殊意义，~/bin表示主目录下的bin,~joh/bin表示/home/joh/bin，即主目录名为joh<br>通配符扩展由make在目标和先决条件中自动执行。在recipes中，shell负责通配符扩展。在其他情况下，通配符扩展只有在使用通配符函数显式请求时才会发生<br>可以通过反斜杠来转义通配符；<br>这里用的是os中的shell所支持的通配符；</p>
<h5 id="通配符的例子："><a href="#通配符的例子：" class="headerlink" title="通配符的例子："></a>通配符的例子：</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在指令中使用，由shell扩展：</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -f *.o</span><br><span class="line">在依赖中：</span><br><span class="line"><span class="section">print: *.c</span></span><br><span class="line">        lpr -p <span class="variable">$?</span>  </span><br><span class="line">        touch print</span><br><span class="line">定义变量，变量中使用比较特殊：</span><br><span class="line">objects = *.o 这个是错误的，需要用：objects := <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br></pre></td></tr></table></figure>
<h5 id="通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；"><a href="#通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；" class="headerlink" title="通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；"></a>通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；</h5><h5 id="通配符函数："><a href="#通配符函数：" class="headerlink" title="通配符函数："></a>通配符函数：</h5><p>通配符扩展在规则中自动发生。但是，当设置了变量或函数的参数时，通配符展开通常不会发生。如果你想在这些地方进行通配符扩展，你需要使用通配符函数，像这样:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern…)</span></span><br></pre></td></tr></table></figure></p>
<p>一般我们可以使用“$(wildcard <em>.c)”来获取工作目录下的所有的.c文件列表。复杂一些用法；可以使用“$(patsubst %.c,%.o,$(wildcard </em>.c))”，<br>首先使用“wildcard”函数获取工作目录下的.c文件列表；之后将列表中所有文件名的后缀.c替换为.o。这样我们就可以得到在当前目录可生成的.o文件列表。<br>因此在一个目录下可以使用如下内容的Makefile来将工作目录下的所有的.c文件进行编译并最后连接成为一个可执行文件：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objects := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line"> </span><br><span class="line">foo : <span class="variable">$(objects)</span></span><br><span class="line">cc -o foo <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="目录搜索，为源文件搜索其他路径"><a href="#目录搜索，为源文件搜索其他路径" class="headerlink" title="目录搜索，为源文件搜索其他路径"></a>目录搜索，为源文件搜索其他路径</h4><p>对一些大型系统，常常将源文件放在各种分离的目录下，则目录搜索作为make的一个有用特性，可以轻易搜索一些目录，自动找到依赖；当在这些目录中重新分配文件时，不需要改规则，只需要改搜索路径；<br>需要注意的是，make的搜索，和指令中的编译器等搜索不同，虽然你在make中指定了，但是如果头文件在不同的目录，使用gcc时，<br>或者通过#include的时候，协商所有路径，否则，需要指定-I gcc -I dir  </p>
<p>make这里的搜索，更多的体现在依赖文件，指令中指定的文件等</p>
<h5 id="整体搜索"><a href="#整体搜索" class="headerlink" title="整体搜索"></a>整体搜索</h5><p>具体化一个搜索路径应用到所有依赖；<br>make uses VPATH as a search list for both prerequisites and targets of rules.<br>所以，如果列在目标或依赖中的文件不在当前的目录，make会在VPATH定义的目录里面找文件名，找到就算；仿佛它们存在当前的目录一样；<br>VPATH定义的目录，由空格或冒号隔开：<br>eg: VPATH = src:../headers<br>所以假设没有在当前目录找到，在src中找到，则：这样的规则：<br> foo.o:foo.c ===&gt; foo.o:src/foo.c<br>注意顺序，即会先从本地找，没有再src找，没有再../headers中找；</p>
<h5 id="选择性搜索"><a href="#选择性搜索" class="headerlink" title="选择性搜索"></a>选择性搜索</h5><p>为一类名字具体化一个搜索路径<br>使用vpath，注意是小写，允许你具体化一类文件名，只要匹配上具体的模式；因此你可以指定一类名字匹配这个目录，其他名字匹配其他目录：<br>有三种组成：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="keyword">vpath</span> pattern directories : 具体化搜索目录为那些匹配上这个pattern的文件名；注意目录间隔是冒号</span><br><span class="line">2) <span class="keyword">vpath</span> pattern : 清除这个pattern的搜索路径关联</span><br><span class="line">3) <span class="keyword">vpath</span> :清除所有的<span class="keyword">vpath</span> 指定</span><br><span class="line">一个<span class="keyword">vpath</span>是一个包含%的字符串，字符串必须匹配正在搜索的先决条件的文件名，' % '字符匹配任何0个或多个字符的序列(如模式规则;参见定义和重新定义模式规则)</span><br><span class="line">例如，%.h匹配以.h结尾的文件。(如果没有' % '，则模式必须完全匹配先决条件，这通常是不太有用的</span><br><span class="line">作用： 当一个依赖中的文件在当前目录不存在时，并且文件名匹配上面的模式时，就会去搜索被<span class="keyword">vpath</span>指定的目录；</span><br><span class="line"><span class="section">eg:</span></span><br><span class="line">    <span class="keyword">vpath</span> %.h ../headers</span><br><span class="line">如果有多个目录，则一个接一个进行搜索：</span><br><span class="line"><span class="keyword">vpath</span> %.c foo</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br><span class="line"><span class="keyword">vpath</span> %.c bar</span><br><span class="line">先foo，再blish，再bar</span><br><span class="line"><span class="keyword">vpath</span> %.c foo:bar</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br><span class="line">先foo,再bar,再blish</span><br></pre></td></tr></table></figure></p>
<h5 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h5><p>搜索路径什么时候，如何被应用；<br>当通过目录搜索找到先决条件时，不管类型是什么(通用的还是选择性的)，所找到的路径名可能不是make在先决条件列表中实际提供给您的路径名。有时，通过目录搜索发现的路径被丢弃。<br>make通过如下的信息来决定是否保持和丢弃一个路径：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)如果在makefile中指定的路径上不存在目标文件，则执行目录搜索。</span><br><span class="line"><span class="number">2</span>)如果目录搜索成功，则保留该路径，并暂时将该文件存储为目标。</span><br><span class="line"><span class="number">3</span>)使用相同的方法检查此目标的所有先决条件。</span><br><span class="line"><span class="number">4</span>)处理完先决条件后，可能需要也可能不需要重建目标</span><br><span class="line">   a 如果不需要重新构建目标，在目录搜索期间找到的文件的路径将用于包含该目标的任何先决条件列表。简而言之，如果make不需要重新构建目标，那么您可以使用通过目录搜索找到的路径。</span><br><span class="line">   b 如果目标确实需要重新构建(已过期)，则丢弃在目录搜索期间找到的路径名，并使用makefile中指定的文件名重新构建目标。简而言之，如果make必须重新生成，则在本地重新生成目标，而不是在通过目录搜索找到的目录中。</span><br></pre></td></tr></table></figure></p>
<p>对其他版本的make也是类似的，如果想要做到在搜索到的路径下生成目标：如：<br>如果文件不存在，并且通过目录搜索找到了它，那么无论是否需要构建目标，都会使用该路径名。因此，如果重新构建目标，则在目录搜索期间发现的路径名处创建目标。<br>则使用GPATH:<br>具有与VPATH相同的语法和格式(即以空格或冒号分隔的路径名列表)。如果通过目录搜索在GPATH中也出现的目录中找到一个过期的目标，那么该路径名不会被丢弃。使用扩展的路径重新生成目标。  </p>
<h5 id="指令搜索：-如何写一个指令能和搜索路径一起工作"><a href="#指令搜索：-如何写一个指令能和搜索路径一起工作" class="headerlink" title="指令搜索： 如何写一个指令能和搜索路径一起工作"></a>指令搜索： 如何写一个指令能和搜索路径一起工作</h5><p>比如：你的依赖通过目录搜索在其他路径中被找到，但是在指令中，写的依赖文件的路径还是原来的，那么如何改变使得make可以在指令执行时找到正确的依赖呢？<br>这是通过自动变量完成的，比如’ $^ ‘(参见自动变量)。例如，’ $^ ‘的值是规则的所有先决条件的列表，包括在其中找到它们的目录名，’ $@ ‘的值是目标<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">        cc -c $(CFLAGS) $^ -o $@</span><br></pre></td></tr></table></figure></p>
<p>如果你只想要依赖中的第一个文件，比如下面的不要依赖头文件，则：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VPATH = src:../headers</span><br><span class="line">foo.o : foo.c defs.h hack.h</span><br><span class="line">        cc -c $(CFLAGS) $&lt; -o $@</span><br></pre></td></tr></table></figure></p>
<h5 id="隐式规则索索；"><a href="#隐式规则索索；" class="headerlink" title="隐式规则索索；"></a>隐式规则索索；</h5><p>搜索路径如何影响隐式规则，如果没有声明显示规则，那make会使用隐式规则，若在当前目录找不到，则会去VPATH/vpath指定的路径搜索，找到则会被应用；</p>
<h5 id="链接库搜索；"><a href="#链接库搜索；" class="headerlink" title="链接库搜索；"></a>链接库搜索；</h5><p>链接库的目录搜索，当依赖中有库文件时，可以使用-lname的方式来指定依赖：<br>当依赖中的名字有类似 ‘-lname’,则make会在特别的在当前目录搜索文件libname.so,如果找不到，就在当前目录找libname.a；然后找不到继续在VPATH/vpath/ /usr/lib等找；<br>比如：有文件/usr/lib/libcurses.a ，但是没有so则<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo : foo.c -lcurses</span><br><span class="line">        cc $^ -o $@</span><br></pre></td></tr></table></figure></p>
<p>会找到.a ,执行‘cc foo.c /usr/lib/libcurses.a -o foo’<br>解释下：尽管要搜索的默认文件集是libname。所以,库名.a，这是通过. libpatterns变量定制的。这个变量值中的每个单词都是一个模式字符串。<br>当看到像’ -lname ‘这样的先决条件时，make将用name替换列表中每个模式中的百分比，并使用每个库文件名执行上述目录搜索。<br>.LIBPATTERNS is ‘lib%.so lib%.a’</p>
<h4 id="伪目标，强制目标-空目标-特殊目标，多目标"><a href="#伪目标，强制目标-空目标-特殊目标，多目标" class="headerlink" title="伪目标，强制目标 空目标 特殊目标，多目标"></a>伪目标，强制目标 空目标 特殊目标，多目标</h4><h5 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h5><p>虚假目标不是真正的文件名;相反，它只是在发出显式请求时要执行的配方的名称。使用假目标有两个原因:避免与同名文件的冲突，以及提高性能。<br>因为rm命令不会创建一个名为clean的文件，所以可能永远不会存在这样的文件。因此，每当您说“make clean”时，rm命令将被执行。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">        rm *<span class="selector-class">.o</span> temp</span><br></pre></td></tr></table></figure></p>
<p>在本例中，如果在此目录中创建了一个名为clean的文件，则clean目标将不能正常工作。因为它没有先决条件，<br>所以clean总是被认为是最新的，它的指令不会被执行。为了避免这个问题，您可以显式地声明目标为假的，方法是将它作为特殊目标.PHONY的依赖，如下所示:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.PHONY</span>: clean</span><br><span class="line">clean:</span><br><span class="line">        rm *<span class="selector-class">.o</span> temp</span><br></pre></td></tr></table></figure></p>
<p>一旦完成，’ make clean ‘将运行指令，而不管是否有一个名为clean的文件<br>假目标在与make的递归调用结合使用时也很有用(请参阅make的递归使用)。在这种情况下，<br>makefile通常会包含一个变量，其中列出了许多要构建的子目录。用一个循环来处理，像这样:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SUBDIRS = foo bar baz</span><br><span class="line"></span><br><span class="line"><span class="symbol">subdirs:</span></span><br><span class="line">        <span class="keyword">for</span> dir <span class="keyword">in</span> <span class="variable">$(</span>SUBDIRS); <span class="keyword">do</span> \</span><br><span class="line">          <span class="variable">$(</span>MAKE) -C <span class="variable">$$</span>dir; \</span><br><span class="line">        done</span><br></pre></td></tr></table></figure></p>
<p>然而，这种方法存在一些问题。首先，在子make中检测到的任何错误都会被该规则忽略，所以即使有一个失败了，它也会继续构建其余的目录。这可以通过添加shell命令来注意错误和退出来克服，<br>但是即使使用-k选项调用make，它也会这样做，这是不幸的。其次，也许是更重要的一点，您不能利用make的能力并行构建目标(请参阅并行执行)，因为只有一条规则。<br>通过声明子目录为.PHONY目标(你必须这样做，因为子目录显然总是存在的;否则它不会被建立)你可以移除上述问题:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SUBDIRS = foo bar baz</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: subdirs $(SUBDIRS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">subdirs: <span class="variable">$(SUBDIRS)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(SUBDIRS)</span>:</span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: baz</span></span><br></pre></td></tr></table></figure></p>
<p>这样的话，就需要baz先完成，才能完成foo;<br>以上也可以用伪目标来实现：<br>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，<br>但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">all : prog1 prog2 prog3</span><br><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">    cc -o prog1 prog1.o utils.o</span><br><span class="line"></span><br><span class="line">prog2 : prog2.o</span><br><span class="line">    cc -o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">    cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure></p>
<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于默认目标的特性是，总是被执行的，但由于“all”又是一个伪目标，<br>伪目标只是一个标签不会生成文件，所以不会有“all”文件产生。于是，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。 .PHONY :<br>all 声明了“all”这个目标为“伪目标”。（注：这里的显式“.PHONY : all” 不写的话一般情况也可以正确的执行，这样make可通过隐式规则推导出， “all” 是一个伪目标，<br>执行make不会生成“all”文件，而执行后面的多个目标。建议：显式写出是一个好习惯。）</p>
<p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">    rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">    rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">    rm *.diff</span><br></pre></td></tr></table></figure></p>
<p>“make cleanall”将清除所有要被清除的文件。<br>“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。</p>
<h5 id="强制目标：没有依赖或规则的目标："><a href="#强制目标：没有依赖或规则的目标：" class="headerlink" title="强制目标：没有依赖或规则的目标："></a>强制目标：没有依赖或规则的目标：</h5><p>如果一个规则没有依赖或指令，并且规则的目标是一个不存在的文件，那么make就假设这个目标在其规则运行时已被更新。这意味着依赖于此的所有目标都将始终运行它们的指令。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean: FORCE</span></span><br><span class="line">        rm <span class="variable">$(objects)</span></span><br><span class="line"><span class="section">FORCE:</span></span><br></pre></td></tr></table></figure>
<p>在这里，目标“FORCE”满足了特殊条件，所以依赖于它的目标clean将被迫运行其指令。“FORCE”这个名称并没有什么特别之处，但这是一个常用的名称。</p>
<h5 id="空目标文件用来记录事件"><a href="#空目标文件用来记录事件" class="headerlink" title="空目标文件用来记录事件"></a>空目标文件用来记录事件</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>: foo.<span class="built_in">c</span> bar.<span class="built_in">c</span></span><br><span class="line">        lpr -p $?</span><br><span class="line">        touch <span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<p>有了这个规则，如果任何一个源文件在上次’ make print ‘之后发生了变化，’ make print ‘将执行lpr命令。自动变量’ $?’仅用于打印那些已更改的文件</p>
<h5 id="具体的内建目标名"><a href="#具体的内建目标名" class="headerlink" title="具体的内建目标名"></a>具体的内建目标名</h5><p>.PHONY/.SUFFIXES/.DEFAULT/.PRECIOUS/.INTERMEDIATE/.SECONDARY/.SECONDEXPANSION/…</p>
<h5 id="一个规则中的多个目标"><a href="#一个规则中的多个目标" class="headerlink" title="一个规则中的多个目标"></a>一个规则中的多个目标</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line">bigoutput littleoutput : text<span class="variable">.g</span></span><br><span class="line">        <span class="keyword">generate</span> text<span class="variable">.g</span> -$(subst <span class="keyword">output</span>,,$@) &gt; $@</span><br><span class="line">和下面的相同</span><br><span class="line">bigoutput : text<span class="variable">.g</span></span><br><span class="line">        <span class="keyword">generate</span> text<span class="variable">.g</span> -big &gt; bigoutput</span><br><span class="line">littleoutput : text<span class="variable">.g</span></span><br><span class="line">        <span class="keyword">generate</span> text<span class="variable">.g</span> -little &gt; littleoutput</span><br></pre></td></tr></table></figure>
<h4 id="多个规则"><a href="#多个规则" class="headerlink" title="多个规则"></a>多个规则</h4><p>一个目标，多个规则；<br>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，<br>多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个自动化变量 $@ （关于自动化变量，将在后面讲述），<br>这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bigoutput littleoutput : text<span class="variable">.g</span></span><br><span class="line">    <span class="keyword">generate</span> text<span class="variable">.g</span> -$(subst <span class="keyword">output</span>,,$@) &gt; $@</span><br><span class="line">上述规则等价于：</span><br><span class="line"></span><br><span class="line">bigoutput : text<span class="variable">.g</span></span><br><span class="line">    <span class="keyword">generate</span> text<span class="variable">.g</span> -big &gt; bigoutput</span><br><span class="line">littleoutput : text<span class="variable">.g</span></span><br><span class="line">    <span class="keyword">generate</span> text<span class="variable">.g</span> -little &gt; littleoutput</span><br><span class="line"></span><br><span class="line">其中， -$(subst <span class="keyword">output</span>,,$@) 中的 $ 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思，</span><br><span class="line"> $@ 表示目标的集合，就像一个数组， $@ 依次取出目标，并执于命令。</span><br></pre></td></tr></table></figure></p>
<h4 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h4><h5 id="静态模式规则的语法："><a href="#静态模式规则的语法：" class="headerlink" title="静态模式规则的语法："></a>静态模式规则的语法：</h5><p>当需要定义多个目标规则，且他们都类似时，可以用静态模式避免写很多规则，就像正则表达式一样;<br>它的语法：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;targets ...&gt;</span> : <span class="params">&lt;target-pattern&gt;</span> : <span class="params">&lt;prereq-patterns ...&gt;</span></span><br><span class="line">    <span class="params">&lt;commands&gt;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="symbol">targets:</span> 定义了一系列的目标文件，可以有通配符。是目标的一个集合。</span><br><span class="line">target-pattern: 是指明了targets的模式，也就是的目标集模式。</span><br><span class="line">prereq-patterns : 是目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。</span><br><span class="line">解释下：如果我们的<span class="params">&lt;target-pattern&gt;</span>定义成 %.o ，意思是我们的<span class="params">&lt;target&gt;</span>;集合中都是以 .o 结尾的，而如果我们的<span class="params">&lt;prereq-patterns&gt;</span>定义成 %.c ，</span><br><span class="line">意思是对<span class="params">&lt;target-pattern&gt;</span>所形成的目标集进行二次定义，其计算方法是，取<span class="params">&lt;target-pattern&gt;</span>模式中的 % （也就是去掉了 .o 这个结尾），并为其加上 .c 这个结尾，形成的新集合。</span><br><span class="line">所以，我们的“目标模式”或是“依赖模式”中都应该有 % 这个字符，如果你的文件名中有 % 那么你可以使用反斜杠 \ 进行转义，来标明真实的 % 字符。</span><br></pre></td></tr></table></figure></p>
<p>eg:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure></p>
<p>上面的例子中，指明了我们的目标从$object中获取， %.o 表明要所有以 .o 结尾的目标，也就是 foo.o bar.o ，也就是变量 $object 集合的模式，而依赖模式 %.c 则取模式 %.o 的 % ，<br>也就是 foo bar ，并为其加下 .c 的后缀，于是，我们的依赖目标就是 foo.c bar.c 。而命令中的 $&lt; 和 $@ 则是自动化变量， $&lt; 表示第一个依赖文件， $@ 表示目标集（也就是“foo.o bar.o”）。<br>于是，上面的规则展开后等价于下面的规则：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo<span class="selector-class">.o</span> : foo.c</span><br><span class="line">    $(CC) -c $(CFLAGS) foo<span class="selector-class">.c</span> -o foo.o</span><br><span class="line">bar<span class="selector-class">.o</span> : bar.c</span><br><span class="line">    $(CC) -c $(CFLAGS) bar<span class="selector-class">.c</span> -o bar.o</span><br></pre></td></tr></table></figure></p>
<p>所以对于很多需要这样生成的，可以省去很多，提高效率<br>另一个例子：eg:<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line">$(<span class="keyword">filter</span> %.o,$(files)): %.o: %.c</span><br><span class="line">    $(CC) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line">$(<span class="keyword">filter</span> %.elc,$(files)): %.elc: %.el</span><br><span class="line">    emacs -f batch-byte-compile $&lt;</span><br></pre></td></tr></table></figure></p>
<p>$(filter %.o,$(files))表示调用Makefile的filter函数，过滤“$files”集，只要其中模式为“%.o”的内容。</p>
<h4 id="自动化生成先决条件：How-to-automatically-generate-rules-giving-prerequisites-from-source-files-themselves"><a href="#自动化生成先决条件：How-to-automatically-generate-rules-giving-prerequisites-from-source-files-themselves" class="headerlink" title="自动化生成先决条件：How to automatically generate rules giving prerequisites from source files themselves."></a>自动化生成先决条件：How to automatically generate rules giving prerequisites from source files themselves.</h4><p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句 #include “defs.h” ，那么我们的依赖关系应该是：<br>main.o : main.c defs.h<br>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。<br>为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。<br>例如，如果我们执行下面的命令:<br>cc -M main.c<br>输出：<br>main.o : main.c defs.h<br>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用 -MM 参数，不然，<br> -M 参数会把一些标准库的头文件也包含进来。<br>gcc -M main.c的输出是:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="symbol">o:</span> main.c defs.h /usr/<span class="keyword">include</span>/stdio.h /usr/<span class="keyword">include</span>/features.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/sys/cdefs.h /usr/<span class="keyword">include</span>/gnu/stubs.h \</span><br><span class="line">    /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>-<span class="title">lib</span>/<span class="title">i486</span>-<span class="title">suse</span>-<span class="title">linux</span>/2.95.3/<span class="title">include</span>/<span class="title">stddef</span>.<span class="title">h</span> \</span></span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/types.h /usr/<span class="keyword">include</span>/bits/pthreadtypes.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/sched.h /usr/<span class="keyword">include</span>/libio.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/_G_config.h /usr/<span class="keyword">include</span>/wchar.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/wchar.h /usr/<span class="keyword">include</span>/gconv.h \</span><br><span class="line">    /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>-<span class="title">lib</span>/<span class="title">i486</span>-<span class="title">suse</span>-<span class="title">linux</span>/2.95.3/<span class="title">include</span>/<span class="title">stdarg</span>.<span class="title">h</span> \</span></span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/stdio_lim.h</span><br></pre></td></tr></table></figure></p>
<p>gcc -MM main.c的输出则是:main.o: main.c defs.h<br>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让 Makefile自已依赖于源文件？这个功能并不现实，<br>不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 name.c 的文件都生成一个 name.d 的Makefile文件，<br>.d 文件中就存放对应 .c 文件的依赖关系。</p>
<p>于是，我们可以写出 .c 文件和 .d 文件的依赖关系，并让make自动更新或生成 .d 文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。<br>这里，我们给出了一个模式规则来产生 .d 文件：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%.d: %.c</span><br><span class="line">    @<span class="keyword">set</span> -e; rm -f <span class="symbol">$</span>@; \</span><br><span class="line">    <span class="symbol">$</span>(CC) -M <span class="symbol">$</span>(CPPFLAGS) <span class="symbol">$</span>&lt; &gt; <span class="symbol">$</span>@.<span class="symbol">$</span><span class="symbol">$</span><span class="symbol">$</span><span class="symbol">$</span>; \</span><br><span class="line">    sed <span class="string">'s,\($*\)\.o[ :]*,\1.o $@ : ,g'</span> &lt; <span class="symbol">$</span>@.<span class="symbol">$</span><span class="symbol">$</span><span class="symbol">$</span><span class="symbol">$</span> &gt; <span class="symbol">$</span>@; \</span><br><span class="line">    rm -f <span class="symbol">$</span>@.<span class="symbol">$</span><span class="symbol">$</span><span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></p>
<p>这个规则的意思是，所有的 .d 文件依赖于 .c 文件， rm -f $@ 的意思是删除所有的目标，也就是 .d 文件，第二行的意思是，为每个依赖文件 $&lt; ，也就是 .c 文件生成依赖文件，<br>$@ 表示模式 %.d 文件，如果有一个C文件是name.c，那么 % 就是 name ， $$$$ 意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，<br>关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。<br>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入 .d 文件的依赖，即把依赖关系：<br>main.o : main.c defs.h<br>转成<br>main.o main.d : main.c defs.h<br>于是，我们的 .d 文件也会自动更新了，并会自动生成了，当然，你还可以在这个 .d 文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 .d 文件都包含一个完赖的规则。<br>一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sources = foo<span class="selector-class">.c</span> bar.c</span><br><span class="line"></span><br><span class="line">include $(sources:.c=.d)</span><br></pre></td></tr></table></figure></p>
<p>上述语句中的 $(sources:.c=.d) 中的 .c=.d 的意思是做一个替换，把变量 $(sources) 所有 .c 的字串都替换成 .d ，关于这个“替换”的内容，在后面我会有更为详细的讲述。<br>当然，你得注意次序，因为include是按次序来载入文件，最先载入的 .d 文件中的目标会成为默认目标。</p>
<p>一个综合的例子：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#VPATH =</span></span><br><span class="line"><span class="keyword">vpath</span> %.h .:../commonlib/huyacommon:../commonlib/log4cplus/<span class="keyword">include</span>:srt/<span class="keyword">include</span>/srt/</span><br><span class="line"><span class="keyword">vpath</span> %.cpp .:../commonlib/huyacommon</span><br><span class="line"><span class="keyword">vpath</span> %.c .:../commonlib/huyacommon</span><br><span class="line"></span><br><span class="line">INCLUDE_DIR	+= -I . -I ../commonlib/huyacommon/ -I ../commonlib/log4cplus/<span class="keyword">include</span>/ -I srt/<span class="keyword">include</span>/srt/</span><br><span class="line">LIB_DIR += ../commonlib/json/libjson.a ../commonlib/huyacommon/common.a</span><br><span class="line"></span><br><span class="line">CC	= gcc</span><br><span class="line">CPP = g++</span><br><span class="line">CFLAGS = -g -Wall -fPIC -c</span><br><span class="line">CPPFLAGS = -g -Wall -fPIC  -c -std=c++0x -Wno-invalid-offsetof -Wextra -Wno-reorder -Wno-strict-aliasing -std=c++0x -Wno-sign-compare </span><br><span class="line"></span><br><span class="line">SOURCES += <span class="variable">$(<span class="built_in">wildcard</span> ./*.cpp)</span></span><br><span class="line"><span class="comment">#SOURCES += $(wildcard ../commonlib/*.cpp)</span></span><br><span class="line"><span class="comment">#SOURCES += $(wildcard ../netlayer/*.cpp)</span></span><br><span class="line"><span class="comment">#SOURCES += $(wildcard yyprotocol/*.cpp)</span></span><br><span class="line"></span><br><span class="line">objects = <span class="variable">$(<span class="built_in">patsubst</span> ./%.cpp,%.o,<span class="variable">$(SOURCES)</span>)</span></span><br><span class="line">objectsd = <span class="variable">$(<span class="built_in">patsubst</span> ./%.cpp,%.d,<span class="variable">$(SOURCES)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:dfiles afiles</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="comment">#先更新d文件，即可能依赖改变了</span></span><br><span class="line">dfiles : <span class="variable">$(objectsd)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成.d文件,到.d的目录下</span></span><br><span class="line"><span class="variable">$(objectsd)</span>:%.d:%.cpp</span><br><span class="line">	<span class="variable">$(CPP)</span> -MM -w --std=c++0x  -fpermissive  <span class="variable">$&lt;</span> <span class="variable">$(INCLUDE_DIR)</span>  &gt; dfile/<span class="variable">$@</span></span><br><span class="line">	@echo <span class="variable">$(objectsd)</span></span><br><span class="line">	@echo <span class="string">"	<span class="variable">$(CPP)</span> -c <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(INCLUDE_DIR)</span> <span class="variable">$&lt;</span>"</span> &gt;&gt; dfile/<span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行依赖文件指令，这样保证依赖的头文件和实现文件只要改变，就能重新生成</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(<span class="built_in">patsubst</span> %.d,dfile/%.d,<span class="variable">$(objectsd)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后在生成o最新文件的基础上封装为a库</span></span><br><span class="line">afiles : netlayer.a</span><br><span class="line"></span><br><span class="line"><span class="section">netlayer.a:<span class="variable">$(objects)</span></span></span><br><span class="line">	ar rvs netlayer.a <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf netlayer.a *.o</span><br></pre></td></tr></table></figure></p>
<h3 id="规则中指令如何写？"><a href="#规则中指令如何写？" class="headerlink" title="规则中指令如何写？"></a>规则中指令如何写？</h3><p>指令是一个或多个可以执行的shell命令行组成，按顺序执行。而执行的结果，一般就是更新目标文件；<br>使用者使用很多不同的shell指令，但在makefile中总是被/bin/sh解释，除非被配置其他；</p>
<h4 id="指令语法–指令语法特性和陷阱"><a href="#指令语法–指令语法特性和陷阱" class="headerlink" title="指令语法–指令语法特性和陷阱"></a>指令语法–指令语法特性和陷阱</h4><p>tab开头(或者由.RECIPEPREFIX 定义的字符，#开头为注释<br>makefiles中其实有两个不同的语法，一个是make自己的，一个是shell,其实只会在解释指令时，make做很小的解释后，交给shell</p>
<ul>
<li><p>有几个个共同的特性：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 空格开头的空白行，不是一个空行，是一个空指令</span><br><span class="line"><span class="number">2</span>) 一个注释不是make的注释，是make传递给<span class="keyword">shell</span><span class="bash">，shell会根据自己的语法，来判断它是不是注释</span></span><br><span class="line"><span class="bash">3) 在指令中(rule context)中定义的变量，不是make的变量，是被当做rule的一部分，被传递到shell中；</span></span><br><span class="line"><span class="bash">4) 条件表达式表现也和3)一样</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如何换行(同个逻辑行物理行换行)<br>在makefile中，反斜杠也可以在指令中使用，但是是传递给shell去判断的，所以支持与否取决于你的shell工具<br>一个例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ksance<span class="number">0</span><span class="variable">@ubuntu</span><span class="symbol">:~/makefiletest</span><span class="variable">$ </span>make </span><br><span class="line">no hspace</span><br><span class="line">notother</span><br><span class="line">ksance<span class="number">0</span><span class="variable">@ubuntu</span><span class="symbol">:~/makefiletest</span><span class="variable">$ </span>cat makefile </span><br><span class="line"><span class="symbol">all:</span></span><br><span class="line">	<span class="variable">@echo</span> no h\</span><br><span class="line">space</span><br><span class="line">	<span class="variable">@echo</span> <span class="keyword">not</span>\</span><br><span class="line">other</span><br><span class="line">ksance<span class="number">0</span><span class="variable">@ubuntu</span><span class="symbol">:~/makefiletest</span>$</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意如果反斜杠在字符串中，则可能会被忽略；</p>
<ul>
<li>如何在指令中使用变量：<br>指令中的变量和函数引用与makefile中其他地方的引用具有相同的语法和语义。他们也有相同的引用规则，如果你想在指令中使用$符号，你需要使用双$如下，<br>因为在make中引用要用$,在传递给shell前剥离$，但在shell中引用也需要$,所以这里要用双$<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIST</span> = <span class="keyword">one</span> <span class="keyword">two</span> three</span><br><span class="line">all:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="keyword">LIST</span>); <span class="keyword">do</span> \</span><br><span class="line">            echo $<span class="variable">$i</span>; \</span><br><span class="line">        done</span><br><span class="line">解释后；</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">one</span> <span class="keyword">two</span> three; <span class="keyword">do</span> \</span><br><span class="line">    echo <span class="variable">$i</span>; \</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"><span class="keyword">one</span></span><br><span class="line"><span class="keyword">two</span></span><br><span class="line">three</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="如何控制什么时候指令回显"><a href="#如何控制什么时候指令回显" class="headerlink" title="如何控制什么时候指令回显"></a>如何控制什么时候指令回显</h4><ul>
<li><p>make中可以使用echo指令，默认情况下，make会把要执行的指令打印到屏幕上，但当使用@echo时，只会显示echo后面的字符如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@echo</span> xxxx</span><br><span class="line">make执行时： 输出：xxxx</span><br><span class="line">而当去掉<span class="variable">@echo</span>时，则输出：</span><br><span class="line">echo xxxx</span><br><span class="line">xxxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>-n和–just-print参数：使用时不会执行命令而是只显示命令</p>
</li>
<li>-s或–silent或–quiet，则是全面禁止指令的显示；</li>
</ul>
<h4 id="指令是如何执行的"><a href="#指令是如何执行的" class="headerlink" title="指令是如何执行的"></a>指令是如何执行的</h4><p>当更新目标时，会执行指令，指令是由shell指令构成的，会执行指令中的每个子shell;.ONESHELL会影响具体的目标;<br>而一个注意的是： cd ,会影响指令的运行环境，比如cd到别的目录执行；不过若想要cd影响到下个指令，需要将下个指令和cd放在同一行;<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">foo:</span> bar/lose</span><br><span class="line">        cd  <span class="variable">$(</span>&lt;D) &amp;&amp; gobble <span class="variable">$(</span>&lt;F) &gt; ../<span class="variable">$@</span></span><br></pre></td></tr></table></figure></p>
<p>这里使用的&amp;&amp; ，所以当cd失败时，整个指令会失败；注意不会执行&amp;&amp;后面的指令；<br>关于.ONESHELL：<br>声明这个后，指令中的多行指令会按单行指令执行，会有以上cd的影响；同时 特殊字符只会在第一行被去掉；比如 @,这可能造成影响，详细见文档；<br>eg:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.<span class="string">ONESHELL:</span></span><br><span class="line">SHELL = <span class="regexp">/usr/</span>bin/perl</span><br><span class="line">.SHELLFLAGS = -e</span><br><span class="line"><span class="string">show :</span></span><br><span class="line">        my <span class="meta">@f</span> = qw(a b c);</span><br><span class="line">        print <span class="string">"@f\n"</span>;</span><br></pre></td></tr></table></figure></p>
<p>关于Choosing the Shell选择shell:<br>默认使用/bin/sh ，如果.SHELL没被设置的话；<br>而.SHELLFLAGS默认是-c或-ec<br>这个在DOS和win下比较常见；  </p>
<h4 id="指令如何同时执行"><a href="#指令如何同时执行" class="headerlink" title="指令如何同时执行"></a>指令如何同时执行</h4><p>通常make是顺序执行一条一条指令的，当make -j时，会同时并行执行多个指令；所以为了make更快，可以采用这种形式；若-j后是一个整数，则按整数个同时执行的job来运行，<br>否是是1，串行执行；  </p>
<p>如果一个指令失败(被一个信号杀死或以非零状态退出)，并且不会忽略该指令的错误(请参阅配方中的错误)，那么重新构建同一目标的剩余配方行将不会运行。<br>如果指令失败，并且没有给出’ -k ‘或’——keep-going ‘选项(参见选项摘要)，则make aborts执行。如果make由于任何原因(包括信号)终止了子进程，它会在实际退出之前等待子进程结束。  </p>
<p>当系统负载较重时，您可能希望比负载较轻时运行更少的作业。您可以使用’ -l ‘选项告诉make根据平均负载限制一次运行的作业数量。选项’ -l ‘或’——max-load ‘后面跟着一个浮点数。例如, -l 2.5  </p>
<p>如果平均负载超过2.5，将不会让make启动一个以上的作业。-l后面无数字指定则无效<br>更准确地说，当make启动一个作业时，并且它已经有至少一个作业在运行时，它会检查当前的平均负载;如果它不低于’ -l ‘所给出的极限，则make等待，直到平均负载低于该极限，或直到所有其他作业完成。</p>
<p>默认的，是没有负载限制的；</p>
<ul>
<li>关于并行执行的输出<br>当并行执行的时候，输出信息很难读；为了避免这个，可以用–output-sync选项；该选项指示make保存它调用的命令的输出，并在命令完成后全部打印输出。<br>此外，如果有多个递归make调用并行运行，它们将进行通信，以便每次只生成其中一个输出。  </li>
</ul>
<p>如果启用了工作目录打印(参见’——print-directory ‘选项)，enter/leave消息将围绕每个输出分组打印。如果不希望看到这些消息，可以在MAKEFLAGS中添加’——no-print-directory ‘选项。  </p>
<p>在同步输出时，有四种级别的粒度，通过给选项一个参数来指定(例如，’ -Oline ‘或’——output-sync=recurse ‘)。<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">none:</span>默认的，不同步直接输出  </span><br><span class="line"><span class="symbol">line:</span>每行指令单独分组和打印，当这行指令完成；若一个指令包含多行，可能混合；</span><br><span class="line"><span class="symbol">target:</span>按照每个目标分组打印，和--output-sync/-O效果相同</span><br><span class="line"><span class="symbol">recurse:</span>每次递归调用make的输出都会分组并在递归调用完成后打印</span><br></pre></td></tr></table></figure></p>
<ul>
<li>关于并行执行的输入<br>两个进程不能同时从同一设备获取输入。为了确保一次只有一个配方尝试从终端获取输入，make将使所有正在运行的配方的标准输入流失效。如果另一个配方试图从标准输入读取，它通常会导致一个致命的错误(“断管道”信号)。</li>
</ul>
<h4 id="指令执行失败后会怎么样；"><a href="#指令执行失败后会怎么样；" class="headerlink" title="指令执行失败后会怎么样；"></a>指令执行失败后会怎么样；</h4><p>每行指令会返回成功与否的状态值，成功为0 ，成功时会自动执行下一行，直到规则结束；，若碰到异常，非0值，则make会放弃当前的规则，或者可能所有的规则；<br>有时候指令的失败不代表是一个问题，例如mkdir;目录已存在；为了忽略这行指令的错误，则使用-，如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">clean</span>： </span><br><span class="line">        <span class="selector-tag">-rm</span> <span class="selector-tag">-f</span> *<span class="selector-class">.o</span></span><br></pre></td></tr></table></figure></p>
<p>这样即使这行rm失败也能继续执行；<br>如果执行make的时候指定-i,或者–ignore-errors,则会忽略全部的异常，和在makefile中声明.IGNORE效果类似；当用在无依赖的规则下比较有用；<br>上述情况下，虽然返回成功，但它会打印出一条消息，告诉您shell退出时使用的状态代码，并告诉您该错误已被忽略。<br>当错误发生时，make没有被告知要忽略它，这意味着当前目标不能被正确地重新创建，任何直接或间接依赖于它的其他目标也不能正确地重新创建。不会对这些目标执行进一步的配方，因为它们的先决条件还没有实现。<br>通常make在这种情况下立即放弃，返回一个非零状态。但是，如果指定了’ -k ‘或’——keep-going ‘标志，make将继续考虑挂起目标的其他先决条件，并在必要时重新生成它们，然后放弃并返回非零状态。<br>例如，在编译一个目标文件时出现错误后，’ make -k ‘将继续编译其他目标文件，即使它已经知道不可能链接它们。  </p>
<h4 id="指令被中断会怎么样"><a href="#指令被中断会怎么样" class="headerlink" title="指令被中断会怎么样"></a>指令被中断会怎么样</h4><p>如果make在shell执行时获得一个致命信号，它可能会删除配方要更新的目标文件。如果目标文件的最后一次修改时间在第一次检查之后发生了改变，就会这样做。</p>
<ul>
<li><p>为什么呢：<br>删除目标的目的是确保在下一次运行make时从头重新创建目标。这是为什么呢?假设您在编译器运行时输入Ctrl-c，并且编译器已经开始编写一个对象文件foo.o。Ctrl-c杀死编译器，导致一个不完整的文件，<br>它的最后修改时间比源文件foo.c更新。但是make也会接收Ctrl-c信号并删除这个不完整的文件。如果make没有这样做，下一次调用make时会认为foo.o不需要更新—当链接器试图链接一个文件时，会产生一个奇怪的错误消息  </p>
</li>
<li><p>如何设置例外？<br>您可以通过使特殊的目标.PRECIOUS 依赖于它来防止以这种方式删除目标文件。在重新创建目标之前，检查它是否在. precious的先决条件下出现，从而决定在信号发生时是否应该删除目标。<br>这样做的一些原因是，目标是以某种原子方式更新的，或者目标的存在只是为了记录修改时间(其内容并不重要)，或者目标必须一直存在以防止其他类型的麻烦</p>
</li>
<li><p>无法覆盖全部：<br>尽管make尽力清理，但在某些情况下，清理是不可能的。例如，make可能会被一个无法捕获的信号杀死。或者，某个程序make调用可能被杀死或崩溃，留下一个最新的但已损坏的目标文件:make不会意识到这个故障需要清除目标文件。或者使自己可能遇到bug而崩溃。</p>
</li>
<li><p>防御：<br>由于这些原因，最好编写防御性指令，这样即使失败了，也不会留下损坏的目标。通常，这些指令会创建临时文件，而不是直接更新目标，然后将临时文件重命名为最终的目标名称。有些编译器已经采用了这种方式，因此您不需要编写防御性指令。</p>
</li>
</ul>
<h4 id="递归；指令中调用makefiles-通过make"><a href="#递归；指令中调用makefiles-通过make" class="headerlink" title="递归；指令中调用makefiles 通过make"></a>递归；指令中调用makefiles 通过make</h4><p>有时候，我们在一个makefile中，编译后，想接着编译其他目录的内容，但是又不想退出重新make，这个时候可以利用makefile中调用make的功能；也叫递归<br>make的递归使用意味着将make作为makefile中的命令使用。当您需要为组成较大系统的各种子系统单独生成文件时，这种技术非常有用。<br>例如，假设您有一个子目录subdir，它有自己的makefile，并且您希望包含目录的makefile在子目录上运行make。你可以这样写<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">        cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br><span class="line">等同于：</span><br><span class="line"><span class="section">subsystem:</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure></p>
<p>结合将目标声明为.PHONY会更有效；<br>为方便起见，当GNU make启动时(在它处理了任何-C选项之后)，它将变量CURDIR设置为当前工作目录的路径名。make不会再碰这个值:<br>特别要注意，如果包含其他目录的文件，CURDIR的值不会改变。<br>这个值与在makefile中设置的值具有相同的优先级(默认情况下，环境变量CURDIR不会覆盖这个值)。注意，设置这个变量对make的操作没有影响(例如，它不会导致make更改其工作目录)。</p>
<ul>
<li>make指令变量如何工作<br>递归的make命令应该总是使用变量make，而不是显式的命令名’ make ‘，如下所示<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subsystem:</span></span><br><span class="line"><span class="keyword"> </span>       cd <span class="keyword">subdir </span>&amp;&amp; $(MAKE)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该变量的值是调用make时使用的文件名，如果这个文件名是/bin/make，那么执行的配方是’ cd subdir &amp;&amp; /bin/make ‘。如果使用make的特殊版本来运行顶级makefile，则对于递归调用将执行相同的特殊版本。<br>作为一个特殊特性，在规则的指令中使用变量MAKE会改变’ -t ‘(‘——touch ‘)、’ -n ‘(‘——just-print ‘)或’ -q ‘(‘——question ‘)选项的效果。<br>使用MAKE变量的效果与在recipe行开头使用“+”字符的效果相同<br>只有当MAKE变量直接出现在指令中时才启用此特殊特性:如果通过展开另一个变量引用MAKE变量，则不适用此特性。在后一种情况下，您必须使用“+”标记来获得这些特殊效果。</p>
<p>考虑上面示例中的命令’ make -t ‘。(“-t”选项将目标标记为最新，无需实际运行任何指令;看，而不是执行。)遵循’ -t ‘的通常定义，<br>示例中的’ make -t ‘命令将创建一个名为subsystem的文件，不做其他事情。你真正想要做的是运行’ cd subdir &amp;&amp; make -t ‘;但这需要执行指令，而“-t”表示不执行指令。</p>
<p>所以在这种情况下，make做了特殊处理，即在指令中若存在MAKE变量，则，当外部make时传入 -t/ -n/-q时，不传到这里的make ,这样对指令中的make可以正常运行；<br>而其实通常情况下，外部的make带的参数是会传递到这里的；</p>
<ul>
<li>子make之间如何交互 export unexport<br>顶级make的变量值可以通过显式请求通过环境传递给子make，这些变量在子make中定义为默认值，但它们不会覆盖子make使用的makefile中定义的变量，除非你使用’ -e ‘开关。<br>为了传递或导出变量，make将变量及其值添加到环境中，以便运行指令的每一行。子make依次使用环境来初始化其变量值表。<br>除非是通过显式请求，否则只有在环境中初始定义或在命令行中设置了导出变量，并且它的名称仅由字母、数字和下划线组成时，才可以将导出设置为变量。有些shell不能处理由字母、数字和下划线以外的字符组成的环境变量名。</li>
</ul>
<p>不导出make变量SHELL的值。相反，调用环境中的SHELL变量的值被传递给子make。您可以使用下面描述的export指令强制make为SHELL导出它的值。<br>特殊变量MAKEFLAGS总是被导出(除非您反导出它)。如果您将其设置为任何内容，则会导出MAKEFILES。<br>make通过将在命令行中定义的变量值放入MAKEFLAGS变量中，自动传递这些值。</p>
<p>如果变量是由make默认创建的，那么它们通常不会被传递(参见隐式规则使用的变量)。子make将为自己定义这些。<br>如果你想导出特定的变量到子make中，使用export指令，像这样:<br>export variable …<br>如果你想阻止一个变量被导出，使用unexport指令，像这样<br>unexport variable …<br>在这两种形式中，export和unexport的参数都是展开的，因此可以是展开为要(un)导出的变量名(列表)的变量或函数。<br>为了方便，你可以定义一个变量并同时导出它，方法如下:<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">variable</span> = <span class="keyword">value</span></span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">variable</span> = <span class="keyword">value</span></span><br><span class="line">export <span class="keyword">variable</span></span><br><span class="line">相当于</span><br><span class="line">export <span class="keyword">variable</span> := <span class="keyword">value</span></span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">variable</span> := <span class="keyword">value</span></span><br><span class="line">export <span class="keyword">variable</span></span><br><span class="line">相当于</span><br><span class="line">export <span class="keyword">variable</span> += <span class="keyword">value</span></span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">variable</span> += <span class="keyword">value</span></span><br><span class="line">export <span class="keyword">variable</span></span><br></pre></td></tr></table></figure></p>
<p>您可能会注意到，export和unexport指令在make中的工作方式与它们在shell sh中的工作方式相同。<br>如果你想在默认情况下导出所有变量，你可以单独使用export:<br>export<br>unexport也是类似的效果</p>
<p>关于MAKELEVEL变量:<br>作为一个特殊的特性，变量MAKELEVEL在从一个级别传递到另一个级别时发生了变化。这个变量的值是一个字符串，它以十进制数字表示级别的深度。<br>顶级make的值是’ 0 ‘;sub-make是’ 1 ‘，sub-sub-make是’ 2 ‘，以此类推。当make为配方设置环境时发生增量<br>MAKELEVEL的主要用途是在一个条件指令中测试它(参见Makefiles的条件部分);通过这种方式，您可以编写一个makefile，递归运行时采用一种方式，直接运行时采用另一种方式。</p>
<p>关于MAKEFILES变量<br>您可以使用变量MAKEFILES使所有子make命令使用额外的makefile。MAKEFILES的值是一个以空格分隔的文件名列表。这个变量，如果定义在外部的makefile中，将通过环境传递;然后，它作为额外makefile的列表，供子make在通常的或指定的makefile之前读取。</p>
<ul>
<li>将选项传递给子make<br>像-s,-k这种会直接通过变量MAKEFLAGS传递给子make. 这个变量由make自动设置，以包含make received的标志字母。因此，如果您使用’ make -ks ‘，那么MAKEFLAGS将获得值’ ks ‘。<br>因此，每个子make在它的环境中都会得到MAKEFLAGS的值。作为响应，它从该值中获取标记并处理它们，就像它们被作为参数给出一样。</li>
</ul>
<p>同样，在命令行中定义的变量也通过MAKEFLAGS传递给子make。包含’ = ‘的MAKEFLAGS值中的单词，将处理作为变量定义，就像它们出现在命令行中一样。<br>选项’ -C ‘， ‘ -f ‘， ‘ -o ‘和’ -W ‘不会被放入MAKEFLAGS中;这些选项没有传递下去。<br>‘ -j ‘选项是一种特殊情况(参见并行执行)。如果你将它设置为一些数值’ N ‘并且你的操作系统支持它(大多数UNIX系统都会支持;其他的通常不会)，父make和所有子make将进行通信，以确保它们之间只有“N”个作业同时运行。</p>
<p>如果您的操作系统不支持上述通信，那么没有’ -j ‘添加到MAKEFLAGS，以便子make运行在非并行模式<br>如果你不想传递其他标志，你必须改变MAKEFLAGS的值，像这样:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subsystem:</span></span><br><span class="line"><span class="keyword"> </span>       cd <span class="keyword">subdir </span>&amp;&amp; $(MAKE) MAKEFLAGS=</span><br></pre></td></tr></table></figure></p>
<p>命令行变量定义实际出现在变量MAKEOVERRIDES中，并且MAKEFLAGS包含对该变量的引用。如果你想正常传递标志，但不想传递命令行变量定义，你可以重置MAKEOVERRIDES为空，像这样:<br>MAKEOVERRIDES =<br>这样做通常是没有用的。然而，一些系统对环境的大小有一个很小的固定限制，将如此多的信息放入MAKEFLAGS的值中可能会超过这个限制。</p>
<p>为了历史兼容性，也存在一个类似的变量MFLAGS。它有相同的值作为MAKEFLAGS除了它不包含命令行变量定义,它总是开始于一个连字符,除非它是空的(MAKEFLAGS以连字符开始只有当它开始于一个选项,<br>没有单字符版本,如“——warn-undefined-variables”)。MFLAGS传统上是在递归的make命令中显式使用的，像这样:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">        cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> <span class="variable">$(MFLAGS)</span></span><br></pre></td></tr></table></figure></p>
<p>如果您希望拥有某些选项，比如在每次运行make时设置’ -k ‘(请参阅选项摘要)，那么MAKEFLAGS变量也很有用。您只需将MAKEFLAGS的值放入您的环境中。您还可以在makefile中设置MAKEFLAGS，<br>以指定对该makefile也有效的附加标志。(注意你不能这样使用MFLAGS。设置该变量只是为了兼容;make不会以任何方式解释你为它设置的值。)<br>…</p>
<ul>
<li>打印目录的指令<br>如果您使用多个层次的递归make调用，则’ -w ‘或’——print-directory ‘选项可以使输出更容易理解，<br>因为它将每个目录显示为make开始处理它和make完成处理它。例如，如果’ make -w ‘在目录/u/gnu/make中运行，make将打印下面的一行:<br>make: Entering directory `/u/gnu/make’.<br>before doing anything else, and a line of the form:</li>
</ul>
<p>make: Leaving directory `/u/gnu/make’.<br>when processing is completed.<br>通常，你不需要指定这个选项，因为’ make ‘会替你指定:当你使用’ -C ‘选项时，’ -w ‘会自动打开，在子make中也是如此。make不会自动打开’ -w ‘，如果你也使用’ -s ‘，它表示静默，或者如果你使用’——no-print-directory ‘来显式禁用它。</p>
<h4 id="定义指令集"><a href="#定义指令集" class="headerlink" title="定义指令集"></a>定义指令集</h4><p>当相同的命令序列在创建各种目标时有用时，可以使用define指令将其定义为固定序列，并从这些目标的配方中引用固定序列。这个固定序列实际上是一个变量，所以这个名称不能与其他变量名称冲突。<br>例如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc =</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure></p>
<p>这里，run-yacc是被定义的变量的名称;endef表示定义的结束;中间的行是命令。define指令不会以固定的顺序展开变量引用和函数调用;’ $ ‘字符、圆括号、变量名等等都成为要定义的变量值的一部分。<br>要使用固定序列，请将变量替换到规则的指令中。您可以像替换其他变量一样替换它(。因为define定义的变量是递归展开的变量，所以在define中编写的所有变量引用现在都展开了。例如:<br>foo.c : foo.y<br>        $(run-yacc)<br>当变量“ $ ^”以run-yacc的值出现时，“ foo.y”将被替换，变量“ $ @”将被“ foo.c”替换。</p>
<h4 id="定义有用的没，没做任何事的指令；"><a href="#定义有用的没，没做任何事的指令；" class="headerlink" title="定义有用的没，没做任何事的指令；"></a>定义有用的没，没做任何事的指令；</h4><p>有时定义不做任何事情的指令是很有用的。这可以通过提供一个只包含空格的指令来实现。例如:<br>target: ;<br>这样做的一个原因是防止目标获取隐式指令规则<br>空的指令也可以用来避免错误为目标创建另一个指令的副作用:如果目标不存在空配方确保让不会抱怨不知道如何建立目标,并使假设目标是过时了。</p>
<h3 id="如何使用变量"><a href="#如何使用变量" class="headerlink" title="如何使用变量"></a>如何使用变量</h3><p>一个变量是一个定义在makefile中用来表示一个文本中的字符串的名字，这个字符串是变量的值；<br>这些变量是可以被显示替换目标，依赖和指令，以及makefile中的其他部分；在其他版本的makefile中也叫宏；<br>makefile中所有部分的变量和函数在读取时都是展开的，除了在recipes中，变量定义的右边使用’ = ‘，变量定义的主体使用define指令。<br>变量可以表示文件名列表、传递给编译器的选项、要运行的程序、要查找源文件的目录、要写入输出的目录，或者您可以想象的任何其他内容。</p>
<p>变量名可以是不包含’:’、’ # ‘、’ = ‘或空格的任意字符序列。然而，包含字母、数字和下划线以外的字符的变量名应该仔细考虑，因为在某些shell中，它们不能通过环境传递给子make(请参阅通信变量到子make)。<br>变量名以`开头。在未来的make版本中，大写字母可能会被赋予特殊的含义。<br>变量名区分大小写。名字’ foo ‘， ‘ foo ‘和’ foo ‘都指不同的变量。<br>传统使用大写字母的变量名,但我们建议使用小写字母的变量名内部用途的makefile,并保留大写参数控制隐性规则或命令选项的参数,用户应该覆盖(见最重要的变量)。<br>一些变量的名称可以是单个标点字符，也可以是几个字符。这些是自动变量，它们有特殊的用途。看到自动变量。</p>
<h4 id="如何使用变量的值"><a href="#如何使用变量的值" class="headerlink" title="如何使用变量的值"></a>如何使用变量的值</h4><p>通过$符号可以引用变量的值，用两种方式： $(foo)或${foo},如果要用包含$字符，需要用两个$;<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objects = <span class="function"><span class="keyword">program</span>.<span class="title">o</span></span> foo.o utils.o</span><br><span class="line"><span class="function"><span class="keyword">program</span></span> : $(objects)</span><br><span class="line">        cc -o <span class="function"><span class="keyword">program</span></span> $(objects)</span><br><span class="line"></span><br><span class="line">$(objects) : defs.h</span><br></pre></td></tr></table></figure></p>
<p>变量按严格的文本替换：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo = c</span><br><span class="line">prog.o : prog.$<span class="comment">(foo)</span></span><br><span class="line">        $<span class="comment">(foo)</span>$<span class="comment">(foo)</span> -$<span class="comment">(foo)</span> prog.$<span class="comment">(foo)</span></span><br><span class="line">可以用来编译一个C程序。因为在变量赋值时变量值前面的空格会被忽略，所以foo的值就是<span class="string">' c '</span>。<span class="comment">(不要这样写你的makefile !)</span></span><br></pre></td></tr></table></figure></p>
<p>一个美元符号后面跟着一个不是美元符号、开括号或开括号的字符作为变量名。因此，你可以用’ $x ‘引用变量x。然而，这种做法可能会导致混淆(例如，’ $foo ‘指的是变量f后面跟着字符串oo)，所以我们建议在所有变量周围使用圆括号或大括号，<br>即使是单字母的变量，除非省略它们可以显著提高可读性。可读性经常得到提高的一个地方是自动变量(参见自动变量)。</p>
<h4 id="两种赋值变量的方式："><a href="#两种赋值变量的方式：" class="headerlink" title="两种赋值变量的方式： = /:="></a>两种赋值变量的方式： = /:=</h4><p>= 原封不动的拷贝，可以进行递归赋值，如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:;echo <span class="variable">$(foo)</span></span></span><br></pre></td></tr></table></figure></p>
<p>所以可以这样使用：这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS = <span class="variable">$(include_dirs)</span> -O</span><br><span class="line">include_dirs = -Ifoo -Ibar</span><br><span class="line">但是一下这种方式会导致无穷递归：</span><br><span class="line">CFLAGS = <span class="variable">$(CFLAGS)</span> -O </span><br><span class="line">make会上报错误</span><br><span class="line">另一个缺点是，另一个缺点是，定义中引用的任何函数都将在每次扩展变量时执行。</span><br><span class="line">这使得make跑得更慢;更糟糕的是，它会导致通配符和shell函数给出不可预知的结果，因为您无法轻松控制何时调用它们，甚至调用多少次。所以不要这么做；</span><br></pre></td></tr></table></figure></p>
<ul>
<li>另一种：”:=”<br>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是 := 操作符，如：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br><span class="line">其等价于：</span><br><span class="line"></span><br><span class="line">y := foo bar</span><br><span class="line">x := later</span><br><span class="line">值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：</span><br><span class="line"></span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := foo</span><br><span class="line">那么，y的值是“bar”，而不是“foo bar”。</span><br><span class="line">下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</span><br><span class="line"></span><br><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br><span class="line">nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“<span class="comment">#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</span></span><br><span class="line"></span><br><span class="line">dir := /foo/bar    <span class="comment"># directory to put the frobs in</span></span><br><span class="line">dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“<span class="variable">$(dir)</span>/file”那么就完蛋了。</span><br><span class="line"></span><br><span class="line">还有一个比较有用的操作符是 ?= ，先看示例：</span><br><span class="line"></span><br><span class="line">FOO ?= bar</span><br><span class="line">其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> FOO)</span>, undefined)</span><br><span class="line">    FOO = bar</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="引用一个变量的高级特性"><a href="#引用一个变量的高级特性" class="headerlink" title="引用一个变量的高级特性"></a>引用一个变量的高级特性</h4><h5 id="变量值的替换"><a href="#变量值的替换" class="headerlink" title="变量值的替换"></a>变量值的替换</h5><p>们可以替换变量中的共有的部分，其格式是 $(var:a=b) 或是 ${var:a=b} ，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</p>
<p>还是看一个示例吧：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o <span class="keyword">c</span>.o</span><br><span class="line">bar := $(foo:.o=.<span class="keyword">c</span>)</span><br><span class="line">这个示例中，我们先定义了一个 $(foo) 变量，而第二行的意思是把 $(foo) 中所有以 .o 字串“结尾”全部替换成 .<span class="keyword">c</span> ，所以我们的 $(bar) 的值就是“a.<span class="keyword">c</span> b.<span class="keyword">c</span> <span class="keyword">c</span>.<span class="keyword">c</span>”。</span><br><span class="line"></span><br><span class="line">另外一种变量替换的技术是以“静态模式”，如：</span><br><span class="line"></span><br><span class="line">foo := a.o b.o <span class="keyword">c</span>.o</span><br><span class="line">bar := $(foo:<span class="symbol">%.o</span>=<span class="symbol">%.c</span>)</span><br><span class="line">这依赖于被替换字串中的有相同的模式，模式中必须包含一个 % 字符，这个例子同样让 $(bar) 变量的值为“a.<span class="keyword">c</span> b.<span class="keyword">c</span> <span class="keyword">c</span>.<span class="keyword">c</span>”。</span><br></pre></td></tr></table></figure></p>
<h5 id="把变量的值再当成变量"><a href="#把变量的值再当成变量" class="headerlink" title="把变量的值再当成变量"></a>把变量的值再当成变量</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br><span class="line">在这个例子中，<span class="variable">$(x)</span>的值是“y”，所以$(<span class="variable">$(x)</span>)就是<span class="variable">$(y)</span>，于是<span class="variable">$(a)</span>的值就是“z”。（注意，是“x=y”，而不是“x=<span class="variable">$(y)</span>”）</span><br><span class="line"></span><br><span class="line">我们还可以使用更多的层次：</span><br><span class="line"></span><br><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">z = u</span><br><span class="line">a := $($(<span class="variable">$(x)</span>))</span><br><span class="line">这里的 <span class="variable">$(a)</span> 的值是“u”，相关的推导留给读者自己去做吧。</span><br><span class="line"></span><br><span class="line">让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：</span><br><span class="line"></span><br><span class="line">x = <span class="variable">$(y)</span></span><br><span class="line">y = z</span><br><span class="line">z = Hello</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br><span class="line">这里的 $(<span class="variable">$(x)</span>) 被替换成了 $(<span class="variable">$(y)</span>) ，因为 <span class="variable">$(y)</span> 值是“z”，所以，最终结果是： a:=<span class="variable">$(z)</span> ，也就是“Hello”。</span><br><span class="line"></span><br><span class="line">再复杂一点，我们再加上函数：</span><br><span class="line"></span><br><span class="line">x = variable1</span><br><span class="line">variable2 := Hello</span><br><span class="line">y = <span class="variable">$(<span class="built_in">subst</span> 1,2,<span class="variable">$(x)</span>)</span></span><br><span class="line">z = y</span><br><span class="line">a := $($(<span class="variable">$(z)</span>))</span><br><span class="line">这个例子中， $($(<span class="variable">$(z)</span>)) 扩展为 $(<span class="variable">$(y)</span>) ，而其再次被扩展为 $(<span class="variable">$(<span class="built_in">subst</span> 1,2,<span class="variable">$(x)</span>)</span>) 。 <span class="variable">$(x)</span> 的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成 “variable2”，再取其值，所以，最终， <span class="variable">$(a)</span> 的值就是 <span class="variable">$(variable2)</span> 的值——“Hello”。（喔，好不容易）</span><br><span class="line"></span><br><span class="line">在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：</span><br><span class="line"></span><br><span class="line">first_second = Hello</span><br><span class="line">a = first</span><br><span class="line">b = second</span><br><span class="line">all = $($a_$b)</span><br><span class="line">这里的 $a_$b 组成了“first_second”，于是， <span class="variable">$(all)</span> 的值就是“Hello”。</span><br><span class="line"></span><br><span class="line">再来看看结合第一种技术的例子：</span><br><span class="line"></span><br><span class="line">a_objects := a.o b.o c.o</span><br><span class="line">1_objects := 1.o 2.o 3.o</span><br><span class="line"></span><br><span class="line">sources := $(<span class="variable">$(a1)</span>_objects:.o=.c)</span><br><span class="line">这个例子中，如果 <span class="variable">$(a1)</span> 的值是“a”的话，那么， <span class="variable">$(sources)</span> 的值就是“a.c b.c c.c”；如果 <span class="variable">$(a1)</span> 的值是“1”，那么 <span class="variable">$(sources)</span> 的值是“1.c 2.c 3.c”。</span><br><span class="line"></span><br><span class="line">再来看一个这种技术和“函数”与“条件语句”一同使用的例子：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> do_sort</span><br><span class="line">    func := sort</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    func := strip</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">bar := a d b g q c</span><br><span class="line"></span><br><span class="line">foo := $(<span class="variable">$(func)</span> <span class="variable">$(bar)</span>)</span><br><span class="line">这个示例中，如果定义了“do_sort”，那么： foo := <span class="variable">$(<span class="built_in">sort</span> a d b g q c)</span> ，于是 <span class="variable">$(foo)</span> 的值就是 “a b c d g q”，而如果没有定义“do_sort”，那么： foo := <span class="variable">$(<span class="built_in">strip</span> a d b g q c)</span> ，调用的就是strip函数。</span><br><span class="line"></span><br><span class="line"><span class="section">当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边:</span></span><br><span class="line"></span><br><span class="line">dir = foo</span><br><span class="line"><span class="variable">$(dir)</span>_sources := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span></span><br><span class="line"><span class="keyword">define</span> <span class="variable">$(dir)</span>_print</span><br><span class="line">lpr $(<span class="variable">$(dir)</span>_sources)</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line">这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。</span><br></pre></td></tr></table></figure>
<h4 id="如何在一个变量中基于旧值添加更多内容–追加"><a href="#如何在一个变量中基于旧值添加更多内容–追加" class="headerlink" title="如何在一个变量中基于旧值添加更多内容–追加"></a>如何在一个变量中基于旧值添加更多内容–追加</h4><p>+=<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">objects += another.o</span><br><span class="line">一个例子： </span><br><span class="line">objects = main<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span> utils.o</span><br><span class="line">objects += another.o</span><br><span class="line">则objects为：</span><br><span class="line">main<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span> utils<span class="selector-class">.o</span> another.o</span><br><span class="line">效果相当于：</span><br><span class="line">objects = main<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span> utils.o</span><br><span class="line">objects := $(objects) another.o</span><br><span class="line">如果变量之前没有定义过，那么， += 会自动变成 = ，如果前面有变量定义，那么 += 会继承于前次操作的赋值符。如果前一次的是 := ，那么 += 会以 := 作为其赋值符，如：</span><br><span class="line"></span><br><span class="line">variable := value</span><br><span class="line">variable += more</span><br><span class="line">等价于：</span><br><span class="line"></span><br><span class="line">variable := value</span><br><span class="line">variable := $(variable) more</span><br><span class="line">但如果是这种情况：</span><br><span class="line"></span><br><span class="line">variable = value</span><br><span class="line">variable += more</span><br><span class="line">由于前次的赋值符是 = ，所以 += 也会以 = 来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</span><br></pre></td></tr></table></figure></p>
<h4 id="如何在makefile中设置一个变量，即使之前已经被设置；"><a href="#如何在makefile中设置一个变量，即使之前已经被设置；" class="headerlink" title="如何在makefile中设置一个变量，即使之前已经被设置；"></a>如何在makefile中设置一个变量，即使之前已经被设置；</h4><p>如果有变量是通过make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override <span class="tag">&lt;<span class="name">variable</span>&gt;</span>; = <span class="tag">&lt;<span class="name">value</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line">override <span class="tag">&lt;<span class="name">variable</span>&gt;</span>; := <span class="tag">&lt;<span class="name">value</span>&gt;</span>;</span><br></pre></td></tr></table></figure></p>
<p>当然，你还可以追加:</p>
<p>override <variable>; += <more text="">;<br>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用override指示符，如:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">define</span> foo</span><br><span class="line">bar</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure></more></variable></p>
<h4 id="一个设置多行字符串变量的可选方式"><a href="#一个设置多行字符串变量的可选方式" class="headerlink" title="一个设置多行字符串变量的可选方式"></a>一个设置多行字符串变量的可选方式</h4><p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。</p>
<p>define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束。其工作方式和“=”操作符一样。<br>变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以 Tab 键开头，那么make 就不会把其认为是命令。</p>
<p>下面的这个示例展示了define的用法:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define <span class="literal">two</span>-<span class="keyword">lines</span></span><br><span class="line">echo foo</span><br><span class="line">echo $(bar)</span><br><span class="line">endef</span><br><span class="line">When used <span class="keyword">in</span> <span class="keyword">a</span> recipe, <span class="keyword">the</span> previous example is functionally equivalent <span class="built_in">to</span> this:</span><br><span class="line"></span><br><span class="line"><span class="literal">two</span>-<span class="keyword">lines</span> = echo foo; echo $(bar)</span><br></pre></td></tr></table></figure></p>
<h4 id="如何去定义一个变量，使它未被赋值"><a href="#如何去定义一个变量，使它未被赋值" class="headerlink" title="如何去定义一个变量，使它未被赋值"></a>如何去定义一个变量，使它未被赋值</h4><p>如果要清除一个变量，通常将其值设置为空就足够了。展开这样的变量将产生相同的结果(空字符串)，而不管它是否被设置。但是，如果您正在使用flavor(参见flavor函数)和origin(参见origin函数)函数，<br>则从未设置的变量和空值的变量之间存在差异。在这种情况下，你可能想要使用undefine指令使一个变量看起来像从未设置过一样。例如:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo := foo</span><br><span class="line">bar = bar</span><br><span class="line"></span><br><span class="line"><span class="keyword">undefine</span> foo</span><br><span class="line"><span class="keyword">undefine</span> bar</span><br><span class="line"></span><br><span class="line"><span class="variable">$(info $(<span class="built_in">origin</span> foo)</span>)</span><br><span class="line"><span class="variable">$(info $(<span class="built_in">flavor</span> bar)</span>)</span><br><span class="line">This example will print “undefined” for both variables.</span><br><span class="line">如果你想取消命令行变量定义，你可以使用<span class="keyword">override</span>指令和<span class="keyword">undefine</span>，类似于变量定义</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">undefine</span> CFLAGS</span><br></pre></td></tr></table></figure></p>
<h4 id="来自环境的变量值；"><a href="#来自环境的变量值；" class="headerlink" title="来自环境的变量值；"></a>来自环境的变量值；</h4><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了 CFLAGS 环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。</p>
<p>当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p>
<p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>
<h4 id="变量值可以在每个目标的基础上定义"><a href="#变量值可以在每个目标的基础上定义" class="headerlink" title="变量值可以在每个目标的基础上定义"></a>变量值可以在每个目标的基础上定义</h4><p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如 $&lt; 等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我也同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;target <span class="params">...</span>&gt; : &lt;<span class="built_in">variable</span><span class="params">-assignment</span>&gt;;</span><br><span class="line"></span><br><span class="line">&lt;target <span class="params">...</span>&gt; : overide &lt;<span class="built_in">variable</span><span class="params">-assignment</span>&gt;</span><br><span class="line">&lt;<span class="built_in">variable</span><span class="params">-assignment</span>&gt;;可以是前面讲过的各种赋值表达式，如 = 、 := 、 += <span class="string">``</span> 或是 <span class="string">``</span>?= 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</span><br></pre></td></tr></table></figure></p>
<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar.o</span><br><span class="line">    $(CC) $(CFLAGS) prog<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar.o</span><br><span class="line"></span><br><span class="line">prog<span class="selector-class">.o</span> : prog.c</span><br><span class="line">    $(CC) $(CFLAGS) prog.c</span><br><span class="line"></span><br><span class="line">foo<span class="selector-class">.o</span> : foo.c</span><br><span class="line">    $(CC) $(CFLAGS) foo.c</span><br><span class="line"></span><br><span class="line">bar<span class="selector-class">.o</span> : bar.c</span><br><span class="line">    $(CC) $(CFLAGS) bar.c</span><br><span class="line">在这个示例中，不管全局的 $(CFLAGS) 的值是什么，在prog目标，以及其所引发的所有规则中（prog<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar.o的规则）， $(CFLAGS) 的值都是 -g</span><br></pre></td></tr></table></figure></p>
<h4 id="特定于目标的变量值可以应用于匹配模式的一组目标。"><a href="#特定于目标的变量值可以应用于匹配模式的一组目标。" class="headerlink" title="特定于目标的变量值可以应用于匹配模式的一组目标。"></a>特定于目标的变量值可以应用于匹配模式的一组目标。</h4><p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的“模式”一般是至少含有一个 % 的，所以，我们可以以如下方式给所有以 .o 结尾的目标定义目标变量：<br>%.o : CFLAGS = -O<br>同样，模式变量的语法和“目标变量”一样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pattern</span> <span class="attr">...</span>&gt;</span>; : <span class="tag">&lt;<span class="name">variable-assignment</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span> <span class="attr">...</span>&gt;</span>; : override <span class="tag">&lt;<span class="name">variable-assignment</span>&gt;</span>;</span><br><span class="line">override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</span><br></pre></td></tr></table></figure></p>
<h4 id="抑制变量的继承"><a href="#抑制变量的继承" class="headerlink" title="抑制变量的继承"></a>抑制变量的继承</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXTRA_CFLAGS =</span><br><span class="line"></span><br><span class="line"><span class="symbol">prog:</span> <span class="keyword">private</span> EXTRA_CFLAGS = -L/usr/local/<span class="class"><span class="keyword">lib</span></span></span><br><span class="line"><span class="symbol">prog:</span> a.o b.o</span><br></pre></td></tr></table></figure>
<p>由于private修饰符，a.o和b.o不会从prog目标继承EXTRA_CFLAGS变量赋值。</p>
<h4 id="具有特殊意义或行为的变量。"><a href="#具有特殊意义或行为的变量。" class="headerlink" title="具有特殊意义或行为的变量。"></a>具有特殊意义或行为的变量。</h4><p>.VARIABLES<br>。。。</p>
<h3 id="如何使用条件语句"><a href="#如何使用条件语句" class="headerlink" title="如何使用条件语句"></a>如何使用条件语句</h3><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h4 id="条件例子"><a href="#条件例子" class="headerlink" title="条件例子"></a>条件例子</h4><p>下面的例子，判断 $(CC) 变量是否 gcc ，如果是的话，则使用GNU函数编译目标。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<p>可见，在上面示例的这个规则中，目标 foo 可以根据变量 $(CC) 值来选取不同的函数库来编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字： ifeq 、 else 和 endif 。 ifeq 的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。 else 表示条件表达式为假的情况。 endif 表示一个条件语句的结束，任何一个条件表达式都应该以 endif 结束。</p>
<p>当我们的变量 $(CC) 值是 gcc 时，目标 foo 的规则是：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line">而当我们的变量 <span class="variable">$(CC)</span> 值不是 gcc 时（比如 cc ），目标 foo 的规则是：</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line">当然，我们还可以把上面的那个例子写得更简洁一些：</span><br><span class="line"></span><br><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="条件的语法"><a href="#条件的语法" class="headerlink" title="条件的语法"></a>条件的语法</h4><p>条件表达式的语法为:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;<span class="built_in">text</span>-<span class="keyword">if</span>-<span class="literal">true</span>&gt;</span><br><span class="line">endif</span><br><span class="line">以及:</span><br><span class="line"></span><br><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;<span class="built_in">text</span>-<span class="keyword">if</span>-<span class="literal">true</span>&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&lt;<span class="built_in">text</span>-<span class="keyword">if</span>-<span class="literal">false</span>&gt;</span><br><span class="line">endif</span><br><span class="line">其中 &lt;conditional-directive&gt; 表示条件关键字，如 ifeq 。这个关键字有四个。</span><br></pre></td></tr></table></figure></p>
<p>第一个是我们前面所见过的 ifeq<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ife<span class="string">q (&lt;arg1&gt;, &lt;arg2&gt;)</span></span><br><span class="line">ifeq <span class="string">'&lt;arg1&gt;'</span> <span class="string">'&lt;arg2&gt;'</span></span><br><span class="line">ifeq <span class="string">"&lt;arg1&gt;"</span> <span class="string">"&lt;arg2&gt;"</span></span><br><span class="line">ifeq <span class="string">"&lt;arg1&gt;"</span> <span class="string">'&lt;arg2&gt;'</span></span><br><span class="line">ifeq <span class="string">'&lt;arg1&gt;'</span> <span class="string">"&lt;arg2&gt;"</span></span><br><span class="line">比较参数 arg1 和 arg2 的值是否相同。当然，参数中我们还可以使用make的函数。如:</span><br><span class="line"></span><br><span class="line">ife<span class="string">q ($(strip $(foo)</span>),)</span><br><span class="line">&lt;text-<span class="keyword">if</span>-empty&gt;</span><br><span class="line">endif</span><br><span class="line">这个示例中使用了 strip 函数，如果这个函数的返回值是空（Empty），那么 &lt;text-<span class="keyword">if</span>-empty&gt; 就生效。</span><br></pre></td></tr></table></figure></p>
<p>第二个条件关键字是 ifneq 。语法是：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ifne<span class="string">q (&lt;arg1&gt;, &lt;arg2&gt;)</span></span><br><span class="line">ifneq <span class="string">'&lt;arg1&gt;'</span> <span class="string">'&lt;arg2&gt;'</span></span><br><span class="line">ifneq <span class="string">"&lt;arg1&gt;"</span> <span class="string">"&lt;arg2&gt;"</span></span><br><span class="line">ifneq <span class="string">"&lt;arg1&gt;"</span> <span class="string">'&lt;arg2&gt;'</span></span><br><span class="line">ifneq <span class="string">'&lt;arg1&gt;'</span> <span class="string">"&lt;arg2&gt;"</span></span><br><span class="line">其比较参数 arg1 和 arg2 的值是否相同，如果不同，则为真。和 ifeq 类似。</span><br></pre></td></tr></table></figure></p>
<p>第三个条件关键字是 ifdef 。语法是：</p>
<p>ifdef <variable-name><br>如果变量 <variable-name> 的值非空，那到表达式为真。否则，表达式为假。当然， <variable-name> 同样可以是一个函数的返回值。注意， ifdef 只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</variable-name></variable-name></variable-name></p>
<p>示例一：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">示例二：</span><br><span class="line"></span><br><span class="line">foo =</span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<p>第一个例子中， $(frobozz) 值是 yes ，第二个则是 no。</p>
<p>第四个条件关键字是 ifndef 。其语法是：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifndef <span class="params">&lt;variable-name&gt;</span></span><br><span class="line">这个我就不多说了，和 ifdef 是相反的意思。</span><br><span class="line"></span><br><span class="line">在 <span class="params">&lt;conditional-directive&gt;</span> 这一行上，多余的空格是被允许的，但是不能以 Tab 键作为开始（不然就被认为是命令）。而注释符 <span class="meta"># 同样也是安全的。 <span class="meta-keyword">else</span> 和 <span class="meta-keyword">endif</span> 也一样，只要不是以 Tab 键开始就行了。</span></span><br></pre></td></tr></table></figure></p>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如 $@ 等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<p>而且为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h4 id="测试标志"><a href="#测试标志" class="headerlink" title="测试标志"></a>测试标志</h4><p>TODO</p>
<h3 id="如何使用函数"><a href="#如何使用函数" class="headerlink" title="如何使用函数"></a>如何使用函数</h3><p>函数允许您在makefile中进行文本处理，以计算要操作的文件或在指令中使用的命令。<br>在函数调用中使用函数，其中提供函数的名称和一些文本(参数)供函数操作。函数处理的结果在调用时被替换到makefile中，就像变量可能被替换一样。</p>
<h4 id="函数的语法，如何写一个函数调用"><a href="#函数的语法，如何写一个函数调用" class="headerlink" title="函数的语法，如何写一个函数调用"></a>函数的语法，如何写一个函数调用</h4><p>函数调用类似于变量引用。它可以出现在变量引用可能出现的任何地方，并且使用与变量引用相同的规则展开它。函数调用是这样的:<br>$(function arguments)<br>或<br>${function arguments}<br>这里的function是指一个函数名，一部分是make中的，你也可以通过call关键字自己创建函数，<arguments> 为函数的参数，参数间以逗号 , 分隔，而函数名和参数之间以“空格”分隔。<br>函数调用以 $ 开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？<br>函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用 $(subst a,b,$(x)) 这样的形式，而不是 $(subst a,b, ${x}) 的形式。</arguments></p>
<p>通过替换变量和函数调用来处理为每个参数编写的文本，以生成参数值，该参数值是函数作用的文本。替换按参数出现的顺序进行。<br>逗号和不匹配的括号或大括号不能像所写的那样出现在参数的文本中;前导空格不能像所写的那样出现在第一个参数的文本中。可以通过变量替换将这些字符放入参数值中。<br>首先定义变量逗号和空格，它们的值是孤立的逗号和空格字符，然后在需要这些字符的地方替换这些变量，像这样:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br><span class="line"><span class="comment"># bar is now ‘a,b,c’.</span></span><br></pre></td></tr></table></figure></p>
<p>这里，subst函数通过foo的值用逗号替换每个空格，并替换结果</p>
<h4 id="Functions-for-String-Substitution-and-Analysis-字符串操作函数列表"><a href="#Functions-for-String-Substitution-and-Analysis-字符串操作函数列表" class="headerlink" title="Functions for String Substitution and Analysis  字符串操作函数列表"></a>Functions for String Substitution and Analysis  字符串操作函数列表</h4><p>字符串处理函数<br>subst<br>$(subst <from>,<to>,<text>)<br>名称：字符串替换函数<br>功能：把字串 <text> 中的 <from> 字符串替换成 <to> 。<br>返回：函数返回被替换过后的字符串。<br>示例：<br>$(subst ee,EE,feet on the street)<br>把 feet on the street 中的 ee 替换成 EE ，返回结果是 fEEt on the strEEt 。</to></from></text></text></to></from></p>
<p>patsubst<br>$(patsubst <pattern>,<replacement>,<text>)<br>名称：模式字符串替换函数。<br>功能：查找 <text> 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式 <pattern> ，如果匹配的话，则以 <replacement> 替换。这里， <pattern> 可以包括通配符 % ，表示任意长度的字串。如果 <replacement> 中也包含 % ，那么， <replacement> 中的这个 % 将是 <pattern> 中的那个 % 所代表的字串。（可以用 \ 来转义，以 \% 来表示真实含义的 % 字符）<br>返回：函数返回被替换过后的字符串。<br>示例：<br>$(patsubst %.c,%.o,x.c.c bar.c)<br>把字串 x.c.c bar.c 符合模式 %.c 的单词替换成 %.o ，返回结果是 x.c.o bar.o<br>备注：这和我们前面“变量章节”说过的相关知识有点相似。如 $(var:<pattern>=<replacement>;) 相当于 $(patsubst <pattern>,<replacement>,$(var)) ，而 $(var: <suffix>=<replacement>) 则相当于 $(patsubst %<suffix>,%<replacement>,$(var)) 。<br>例如有:<br>objects = foo.o bar.o baz.o，<br>那么， $(objects:.o=.c) 和 $(patsubst %.o,%.c,$(objects)) 是一样的。</replacement></suffix></replacement></suffix></replacement></pattern></replacement></pattern></pattern></replacement></replacement></pattern></replacement></pattern></text></text></replacement></pattern></p>
<p>strip<br>$(strip <string>)<br>名称：去空格函数。<br>功能：去掉 <string> 字串中开头和结尾的空字符。<br>返回：返回被去掉空格的字符串值。<br>示例：<br>$(strip a b c )<br>把字串 a b c <code>去到开头和结尾的空格，结果是</code>a b c 。</string></string></p>
<p>findstring<br>$(findstring <find>,<in>)<br>名称：查找字符串函数<br>功能：在字串 <in> 中查找 <find> 字串。<br>返回：如果找到，那么返回 <find> ，否则返回空字符串。<br>示例：<br>$(findstring a,a b c)<br>$(findstring a,b c)<br>第一个函数返回 a 字符串，第二个返回空字符串</find></find></in></in></find></p>
<p>filter<br>$(filter &lt;pattern…&gt;,<text>)<br>名称：过滤函数<br>功能：以 <pattern> 模式过滤 <text> 字符串中的单词，保留符合模式 <pattern> 的单词。可以有多个模式。<br>返回：返回符合模式 <pattern> 的字串。<br>示例：<br>sources := foo.c bar.c baz.s ugh.h<br>foo: $(sources)<br>    cc $(filter %.c %.s,$(sources)) -o foo<br>$(filter %.c %.s,$(sources)) 返回的值是 foo.c bar.c baz.s 。</pattern></pattern></text></pattern></text></p>
<p>filter-out<br>$(filter-out &lt;pattern…&gt;,<text>)<br>名称：反过滤函数<br>功能：以 <pattern> 模式过滤 <text> 字符串中的单词，去除符合模式 <pattern> 的单词。可以有多个模式。<br>返回：返回不符合模式 <pattern> 的字串。<br>示例：<br>objects=main1.o foo.o main2.o bar.o<br>mains=main1.o main2.o<br>$(filter-out $(mains),$(objects)) 返回值是 foo.o bar.o 。</pattern></pattern></text></pattern></text></p>
<p>sort<br>$(sort <list>)<br>名称：排序函数<br>功能：给字符串 <list> 中的单词排序（升序）。<br>返回：返回排序后的字符串。<br>示例： $(sort foo bar lose) 返回 bar foo lose 。<br>备注： sort 函数会去掉 <list> 中相同的单词。</list></list></list></p>
<p>word<br>$(word <n>,<text>)<br>名称：取单词函数<br>功能：取字符串 <text> 中第 <n> 个单词。（从一开始）<br>返回：返回字符串 <text> 中第 <n> 个单词。如果 <n> 比 <text> 中的单词数要大，那么返回空字符串。<br>示例： $(word 2, foo bar baz) 返回值是 bar 。</text></n></n></text></n></text></text></n></p>
<p>wordlist<br>$(wordlist <ss>,<e>,<text>)<br>名称：取单词串函数<br>功能：从字符串 <text> 中取从 <ss> 开始到 <e> 的单词串。 <ss> 和 <e> 是一个数字。<br>返回：返回字符串 <text> 中从 <ss> 到 <e> 的单词字串。如果 <ss> 比 <text> 中的单词数要大，那么返回空字符串。如果 <e> 大于 <text> 的单词数，那么返回从 <ss> 开始，到 <text> 结束的单词串。<br>示例： $(wordlist 2, 3, foo bar baz) 返回值是 bar baz 。</text></ss></text></e></text></ss></e></ss></text></e></ss></e></ss></text></text></e></ss></p>
<p>words<br>$(words <text>)<br>名称：单词个数统计函数<br>功能：统计 <text> 中字符串中的单词个数。<br>返回：返回 <text> 中的单词数。<br>示例： $(words, foo bar baz) 返回值是 3 。<br>备注：如果我们要取 <text> 中最后的一个单词，我们可以这样： $(word $(words <text>),<text>) 。</text></text></text></text></text></text></p>
<p>firstword<br>$(firstword <text>)<br>名称：首单词函数——firstword。<br>功能：取字符串 <text> 中的第一个单词。<br>返回：返回字符串 <text> 的第一个单词。<br>示例： $(firstword foo bar) 返回值是 foo。<br>备注：这个函数可以用 word 函数来实现： $(word 1,<text>) 。<br>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用 VPATH 变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 CFLAGS ，如：</text></text></text></text></p>
<p>override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))<br>如果我们的 $(VPATH) 值是 src:../headers ，那么 $(patsubst %,-I%,$(subst :, ,$(VPATH))) 将返回 -Isrc -I../headers ，这正是cc或gcc搜索头文件路径的参数。</p>
<h4 id="如何用函数操作文件名"><a href="#如何用函数操作文件名" class="headerlink" title="如何用函数操作文件名"></a>如何用函数操作文件名</h4><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p>
<p>dir<br>$(dir &lt;names…&gt;)<br>名称：取目录函数——dir。<br>功能：从文件名序列 <names> 中取出目录部分。目录部分是指最后一个反斜杠（ / ）之前的部分。如果没有反斜杠，那么返回 ./ 。<br>返回：返回文件名序列 <names> 的目录部分。<br>示例： $(dir src/foo.c hacks) 返回值是 src/ ./ 。</names></names></p>
<p>notdir<br>$(notdir &lt;names…&gt;)<br>名称：取文件函数——notdir。<br>功能：从文件名序列 <names> 中取出非目录部分。非目录部分是指最後一个反斜杠（ / ）之后的部分。<br>返回：返回文件名序列 <names> 的非目录部分。<br>示例: $(notdir src/foo.c hacks) 返回值是 foo.c hacks 。</names></names></p>
<p>suffix<br>$(suffix &lt;names…&gt;)<br>名称：取後缀函数——suffix。<br>功能：从文件名序列 <names> 中取出各个文件名的后缀。<br>返回：返回文件名序列 <names> 的后缀序列，如果文件没有后缀，则返回空字串。<br>示例： $(suffix src/foo.c src-1.0/bar.c hacks) 返回值是 .c .c。</names></names></p>
<p>basename<br>$(basename &lt;names…&gt;)<br>名称：取前缀函数——basename。<br>功能：从文件名序列 <names> 中取出各个文件名的前缀部分。<br>返回：返回文件名序列 <names> 的前缀序列，如果文件没有前缀，则返回空字串。<br>示例： $(basename src/foo.c src-1.0/bar.c hacks) 返回值是 src/foo src-1.0/bar hacks 。</names></names></p>
<p>addsuffix<br>$(addsuffix <suffix>,&lt;names…&gt;)<br>名称：加后缀函数——addsuffix。<br>功能：把后缀 <suffix> 加到 <names> 中的每个单词后面。<br>返回：返回加过后缀的文件名序列。<br>示例： $(addsuffix .c,foo bar) 返回值是 foo.c bar.c 。</names></suffix></suffix></p>
<p>addprefix<br>$(addprefix <prefix>,&lt;names…&gt;)<br>名称：加前缀函数——addprefix。<br>功能：把前缀 <prefix> 加到 <names> 中的每个单词后面。<br>返回：返回加过前缀的文件名序列。<br>示例： $(addprefix src/,foo bar) 返回值是 src/foo src/bar 。</names></prefix></prefix></p>
<p>join<br>$(join <list1>,<list2>)<br>名称：连接函数——join。<br>功能：把 <list2> 中的单词对应地加到 <list1> 的单词后面。如果 <list1> 的单词个数要比 <list2> 的多，那么， <list1> 中的多出来的单词将保持原样。如果 <list2> 的单词个数要比 <list1> 多，那么， <list2> 多出来的单词将被复制到 <list1> 中。<br>返回：返回连接过后的字符串。<br>示例： $(join aaa bbb , 111 222 333) 返回值是 aaa111 bbb222 333 。</list1></list2></list1></list2></list1></list2></list1></list1></list2></list2></list1></p>
<p>wildcard<br>$(wildcard pattern)<br>参数模式是一个文件名模式，通常包含通配符(如shell文件名模式)。通配符的结果是一个与模式匹配的现有文件名称的以空格分隔的列表。<br>eg:<br>objects := $(wildcard *.o)</p>
<p>realpath<br>$(realpath names…)<br>对于names中的每个文件名，返回规范的绝对名称。规范名称不包含任何内容。或. .组件，或任何重复路径分隔符(/)或符号链接。如果失败，则返回空字符串。</p>
<p>abspath<br>$(abspath names…)<br>对于names中的每个文件名，返回一个不包含任何内容的绝对名称。或. .组件，或任何重复路径分隔符(/)。<br>注意，与realpath函数不同，abspath不解析符号链接，也不要求文件名引用现有的文件或目录。使用通配符函数来测试是否存在。</p>
<h4 id="实现条件的函数"><a href="#实现条件的函数" class="headerlink" title="实现条件的函数"></a>实现条件的函数</h4><p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">if</span> &lt;condition&gt;,&lt;<span class="keyword">then</span>-<span class="built_in">part</span>&gt;)</span><br><span class="line">或是</span><br><span class="line"></span><br><span class="line">$(<span class="keyword">if</span> &lt;condition&gt;,&lt;<span class="keyword">then</span>-<span class="built_in">part</span>&gt;,&lt;<span class="keyword">else</span>-<span class="built_in">part</span>&gt;)</span><br><span class="line">可见，<span class="keyword">if</span>函数可以包含“<span class="keyword">else</span>”部分，或是不含。即<span class="keyword">if</span>函数的参数可以是两个，也可以是三个。 &lt;condition&gt; 参数是<span class="keyword">if</span>的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是， &lt;<span class="keyword">then</span>-<span class="built_in">part</span>&gt; 会被计算，否则 &lt;<span class="keyword">else</span>-<span class="built_in">part</span>&gt; 会被计算。</span><br></pre></td></tr></table></figure></p>
<p>而if函数的返回值是，如果 <condition> 为真（非空字符串），那个 <then-part> 会是整个函数的返回值，如果 <condition> 为假（空字符串），那么 <else-part> 会是整个函数的返回值，此时如果 <else-part> 没有被定义，那么，整个函数返回空字串。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">所以， &lt;<span class="keyword">then</span>-part&gt; 和 &lt;<span class="keyword">else</span>-part&gt; 只会有一个被计算。</span><br><span class="line">此外，还有两种形式，少用</span><br><span class="line">$(<span class="keyword">or</span> condition1[,condition2[,condition3…]])</span><br><span class="line"></span><br><span class="line">$(<span class="keyword">and</span> condition1[,condition2[,condition3…]])</span><br></pre></td></tr></table></figure></else-part></else-part></condition></then-part></condition></p>
<h4 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h4><p>foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span><br><span class="line">这个函数的意思是，把参数 &lt;list&gt; 中的单词逐一取出放到参数 &lt;var&gt; 所指定的变量中，然后再执行 &lt;text&gt; 所包含的表达式。每一次 &lt;text&gt; 会返回一个字符串，循环过程中， &lt;text&gt; 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， &lt;text&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</span><br><span class="line"></span><br><span class="line">所以， &lt;var&gt; 最好是一个变量名， &lt;list&gt; 可以是一个表达式，而 &lt;text&gt; 中一般会使用 &lt;var&gt; 这个参数来依次枚举 &lt;list&gt; 中的单词。举个例子：</span><br><span class="line"></span><br><span class="line">names := <span class="selector-tag">a</span> <span class="selector-tag">b</span> c d</span><br><span class="line">files := $(foreach n,$(names),$(n).o)</span><br><span class="line">上面的例子中， $(name) 中的单词会被挨个取出，并存到变量 n 中， $(n)<span class="selector-class">.o</span> 每次根据 $(n) 计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以， $(files) 的值是 <span class="selector-tag">a</span><span class="selector-class">.o</span> <span class="selector-tag">b</span><span class="selector-class">.o</span> c<span class="selector-class">.o</span> d<span class="selector-class">.o</span> 。</span><br></pre></td></tr></table></figure></p>
<p>注意，foreach中的 <var> 参数是一个临时的局部变量，foreach函数执行完后，参数 <var> 的变量将不在作用，其作用域只在foreach函数当中。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">eg2:</span></span><br><span class="line"></span><br><span class="line">find_files = <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*)</span></span><br><span class="line">dirs := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(dirs)</span>,<span class="variable">$(find_files)</span>)</span></span><br><span class="line">这里我们以这种方式使用变量find_files。我们使用普通的' = '来定义递归展开变量，这样它的值就包含了一个实际的函数调用，在foreach的控制下重新展开;简单展开的变量是不行的，因为通配符只在定义find_files时被调用一次。</span><br><span class="line"></span><br><span class="line">eg3：</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> Esta-escrito-en-espanol!,b c ch,<span class="variable">$(find_files)</span>)</span></span><br></pre></td></tr></table></figure></var></var></p>
<h4 id="文件相关函数：写文本到一个文件中"><a href="#文件相关函数：写文本到一个文件中" class="headerlink" title="文件相关函数：写文本到一个文件中"></a>文件相关函数：写文本到一个文件中</h4><p>file函数允许makefile写出到文件或从文件读取；支持两种模式的写入： 覆盖写，从文件的开始写，覆盖存在的内容；追加，即追加到存在文件的末尾；<br>两种模式都是文件不存在就创建，有一个致命错误就是当文件不能打开去写时，或者写操作失败；当写入文件时，file函数展开为空字符串。<br>从文件中读取时，file函数展开为文件的逐字内容，但最后的换行(如果有的话)将被删除。试图从不存在的文件中读取将展开为空字符串。<br>语法：<br>$(file op filename[,text])<br>当对文件函数求值时，首先展开它的所有参数，然后将以op描述的模式打开由filename指定的文件。<br>运算符op可以是&gt;，表示文件将被新的内容覆盖，&gt;&gt;表示文件的当前内容将被追加，或者&lt;表示文件的内容将被读入。文件名指定要写入或读取的文件。在操作符和文件名之间可以有空格。<br>读取文件时，提供text的值是错误的。<br>当写入文件时，文本text将写入文件。如果文本text还没有以换行符结束，则将写入最后的换行符(即使文本是空字符串)。如果根本没有给出text参数，则不会写入任何内容。<br>eg:<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例如，如果构建系统的命令行大小有限，并且指令运行的命令也可以接受文件中的参数，那么<span class="keyword">file</span>函数就很有用。</span><br><span class="line">许多命令都使用了这样的约定:以@作为参数前缀的参数指定一个包含更多参数的文件。那么你可以这样写你的指令:</span><br><span class="line">program: $(OBJECTS)</span><br><span class="line">        $(<span class="keyword">file</span> &gt;$@.<span class="keyword">in</span>,$^)</span><br><span class="line">        $(CMD) $(CMDFLAGS) @$@.<span class="keyword">in</span></span><br><span class="line">        @rm $@.<span class="keyword">in</span></span><br><span class="line">如果命令要求每个参数在输入文件的单独一行上，您可以这样写您的指令:</span><br><span class="line">program: $(OBJECTS)</span><br><span class="line">        $(<span class="keyword">file</span> &gt;$@.<span class="keyword">in</span>) $(foreach O,$^,$(<span class="keyword">file</span> &gt;&gt;$@.<span class="keyword">in</span>,$O))</span><br><span class="line">        $(CMD) $(CMDFLAGS) @$@.<span class="keyword">in</span></span><br><span class="line">        @rm $@.<span class="keyword">in</span></span><br></pre></td></tr></table></figure></p>
<h4 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h4><p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以call函数来向这个表达式传递参数。其语法是：</p>
<p>$(call <expression>,<parm1>,<parm2>,…,<parmn>)<br>当make执行这个函数时， <expression> 参数中的变量，如 $(1) 、 $(2) 等，会被参数 <parm1> 、 <parm2> 、 <parm3> 依次取代。而 <expression> 的返回值就是 call 函数的返回值。例如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reverse =  $(1) $(2)</span><br><span class="line"></span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br><span class="line">那么， foo 的值就是 a b 。当然，参数的次序是可以自定义的，不一定是顺序的，如：</span><br><span class="line"></span><br><span class="line">reverse =  $(2) $(1)</span><br><span class="line"></span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br><span class="line">此时的 foo 的值就是 b a 。</span><br></pre></td></tr></table></figure></expression></parm3></parm2></parm1></expression></parmn></parm2></parm1></expression></p>
<p>需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向call函数提供参数时，最安全的做法是去除所有多余的空格。</p>
<h4 id="value函数"><a href="#value函数" class="headerlink" title="value函数"></a>value函数</h4><p>alue函数提供了一种方法，可以使用变量的值，而不必将其展开。请注意，这不会撤销已经发生的展开;<br>例如，如果您创建了一个简单展开的变量，它的值会在定义过程中展开;在这种情况下，value函数将返回与直接使用变量相同的结果。<br>语法：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(value variable)</span><br><span class="line">variables是变量名，不是变量的引用；因此，在写它的时候，你通常不会使用<span class="string">' $ '</span>或圆括号。</span><br><span class="line">（但是，如果你不希望名字是常量，你可以在名字中使用变量引用。）</span><br><span class="line">这个函数的结果是一个包含variable值的字符串，不会发生任何展开。例如，在这个makefile中:</span><br><span class="line">FOO = $PATH</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        @echo $(FOO)</span><br><span class="line">        @echo $(value FOO)</span><br><span class="line">第一行输出将是ATH，因为“$P”将被展开为make变量(假设有)，而第二行输出将是$PATH环境变量的当前值，因为value函数避免了展开。</span><br><span class="line">value函数最常与<span class="keyword">eval</span>函数一起使用(请参阅<span class="keyword">eval</span>函数)。</span><br></pre></td></tr></table></figure></p>
<h4 id="eval函数：Evaluate-the-arguments-as-makefile-syntax"><a href="#eval函数：Evaluate-the-arguments-as-makefile-syntax" class="headerlink" title="eval函数：Evaluate the arguments as makefile syntax"></a>eval函数：Evaluate the arguments as makefile syntax</h4><p>eval函数非常特别，它允许你定义一个新的makefile构造非常规的；<br>这是对其他变量和函数求值的结果。eval函数的参数被展开，然后将展开的结果作为makefile语法进行解析。扩展的结果可以定义新的make变量、目标、隐式或显式规则等。<br>eval函数的结果总是空字符串;因此，它可以放在makefile中的任何位置，而不会导致语法错误。<br>重要的是要意识到eval参数被展开了两次;首先是eval函数，然后在作为makefile语法解析时再次展开该展开的结果。<br>这意味着在使用eval时，可能需要为“$”字符提供额外级别的转义。值value函数有时在这些情况下很有用，可以避免不必要的展开。</p>
<p>下面是如何使用eval的示例;这个示例结合了许多概念和其他函数。尽管在本例中使用eval似乎过于复杂，而不只是写出规则，但要考虑两件事:<br>首先，模板定义(PROGRAM_template中)可能需要比这里复杂得多;<br>其次，您可以将这个示例中复杂的“通用”部分放入另一个makefile中，然后将其包含在所有单独的makefile中。现在，您的单个makefile非常简单。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PROGRAMS    = server client</span><br><span class="line"></span><br><span class="line">server_OBJS = server.o server_priv.o server_access.o</span><br><span class="line">server_LIBS = priv protocol</span><br><span class="line"></span><br><span class="line">client_OBJS = client.o client_api.o client_mem.o</span><br><span class="line">client_LIBS = protocol</span><br><span class="line"></span><br><span class="line"><span class="comment"># Everything after this is generic</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: <span class="variable">$(PROGRAMS)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> PROGRAM_template =</span><br><span class="line"> $(1): $$($(1)_OBJS) $$($(1)_LIBS:%=-l%)</span><br><span class="line"> ALL_OBJS   += $$($(1)_OBJS)</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> prog,<span class="variable">$(PROGRAMS)</span>,$(<span class="built_in">eval</span> $(<span class="built_in">call</span> PROGRAM_template,<span class="variable">$(prog)</span>)</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable">$(PROGRAMS)</span>:</span><br><span class="line">        $(LINK.o) <span class="variable">$^</span> <span class="variable">$(LDLIBS)</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -f <span class="variable">$(ALL_OBJS)</span> <span class="variable">$(PROGRAMS)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="origin函数：寻找一个变量并拿它的值"><a href="#origin函数：寻找一个变量并拿它的值" class="headerlink" title="origin函数：寻找一个变量并拿它的值"></a>origin函数：寻找一个变量并拿它的值</h4><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span>(origin &lt;<span class="keyword">variable</span>&gt;)</span><br><span class="line">注意， &lt;<span class="keyword">variable</span>&gt; 是变量的名字，不应该是引用。所以你最好不要在 &lt;<span class="keyword">variable</span>&gt; 中使用</span><br><span class="line">$ 字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</span><br><span class="line">undefined</span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 从来没有定义过，origin函数返回这个值 undefined</span><br><span class="line">default</span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</span><br><span class="line">environment</span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 是一个环境变量，并且当Makefile被执行时， -e 参数没有被打开。</span><br><span class="line">file</span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 这个变量被定义在Makefile中。</span><br><span class="line">command <span class="comment">line</span></span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 这个变量是被命令行定义的。</span><br><span class="line">override</span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 是被override指示符重新定义的。</span><br><span class="line">automatic</span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</span><br><span class="line">这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件 Make.def，在 Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</span><br><span class="line"></span><br><span class="line">ifdef <span class="comment">bletch</span></span><br><span class="line">    ifeq <span class="comment">"$(origin bletch)"</span> <span class="comment">"environment"</span></span><br><span class="line">        bletch <span class="comment">= barf, gag, etc.</span></span><br><span class="line">    endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure></p>
<p>当然，你也许会说，使用 override 关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用 override 是可以达到这样的效果，可是 override 过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的</p>
<h4 id="flavor函数"><a href="#flavor函数" class="headerlink" title="flavor函数"></a>flavor函数</h4><p>flavor函数，像origin函数一样，不作用于变量的值而是告诉你关于变量的一些东西。具体来说，它告诉您变量的特性(<br>语法：<br>$(flavor variable)<br>注意，variable是要查询的变量的名称，而不是对该变量的引用。因此，在写它的时候，你通常不会使用’ $ ‘或圆括号。(不过，如果希望名称不是常量，也可以在名称中使用变量引用。)<br>结果是以下的形式：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">‘undefined’</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">variable</span> was never defined.</span><br><span class="line"></span><br><span class="line">‘recursive’</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">variable</span> <span class="keyword">is</span> a recursively expanded <span class="keyword">variable</span>.</span><br><span class="line"></span><br><span class="line">‘simple’</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">variable</span> <span class="keyword">is</span> a simply expanded <span class="keyword">variable</span>.</span><br></pre></td></tr></table></figure></p>
<h4 id="控制make运行的函数"><a href="#控制make运行的函数" class="headerlink" title="控制make运行的函数"></a>控制make运行的函数</h4><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> &lt;text ...&gt;)</span></span><br><span class="line">产生一个致命的错误， &lt;text ...&gt; 是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</span><br><span class="line"></span><br><span class="line">示例一：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> ERROR_001</span><br><span class="line">    <span class="variable">$(<span class="built_in">error</span> <span class="built_in">error</span> is <span class="variable">$(ERROR_001)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">示例二：</span><br><span class="line"></span><br><span class="line">ERR = <span class="variable">$(<span class="built_in">error</span> found an <span class="built_in">error</span>!)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: err</span></span><br><span class="line"></span><br><span class="line"><span class="section">err: <span class="variable">$(ERR)</span></span></span><br><span class="line">示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> &lt;text ...&gt;)</span></span><br><span class="line">这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</span><br></pre></td></tr></table></figure></p>
<h4 id="shelll函数"><a href="#shelll函数" class="headerlink" title="shelll函数"></a>shelll函数</h4><p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br><span class="line">files := <span class="variable">$(<span class="built_in">shell</span> echo *.c)</span></span><br></pre></td></tr></table></figure></p>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<h4 id="guile函数"><a href="#guile函数" class="headerlink" title="guile函数"></a>guile函数</h4><p>如果GNU make在构建时支持将GNU Guile作为嵌入式扩展语言，那么Guile函数将可用。guile函数接受一个参数，这个参数首先由make以正常方式展开，然后传递给GNU guile计算器。求值器的结果被转换成一个字符串，并在makefile中用作guile函数的展开。关于在Guile中编写扩展的详细信息，请参阅GNU Guile Integration。<br>你可以通过检查Guile这个词的. .FEATURES变量来决定是否支持GNU Guile。</p>
<h3 id="如何运行make"><a href="#如何运行make" class="headerlink" title="如何运行make"></a>如何运行make</h3><p>makefile的执行，一般是直接make就可以了；make会针对过期的文件重新编译，但是你可能想去只更新部分文件；你可能想使用不同的编译器或者<br>编译器选项；你可能只想找出过期文件而不想更新改变它们；<br>通过运行make的时候给定参数，你可以做下这些事以及许多其他：<br>make的退出状态值总是这三个：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">The <span class="keyword">exit</span> status is zero <span class="keyword">if</span> make is successful.</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line">The <span class="keyword">exit</span> status is two <span class="keyword">if</span> make encounters any errors. It will print messages describing the particular errors.</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line">The <span class="keyword">exit</span> status is one <span class="keyword">if</span> you use the ‘-q’ flag and make determines that some target is not already up to date. </span><br><span class="line">See Instead of Executing Recipes.</span><br></pre></td></tr></table></figure></p>
<h4 id="如何具体化哪个makefile被使用"><a href="#如何具体化哪个makefile被使用" class="headerlink" title="如何具体化哪个makefile被使用"></a>如何具体化哪个makefile被使用</h4><p>使用-f/–file参数：<br>make -f almake / make  –file almake<br>即以almake文件来执行make；<br>如果不指定，则使用默认的文件：GNUmakefile, makefile, and Makefile</p>
<h4 id="Golas"><a href="#Golas" class="headerlink" title="Golas"></a>Golas</h4><p>如何指定生成的目标：默认的，目标是makefile文件中的第一个目标；因此一般makefile文件总是以第一个目标来生成整个程序；<br>如果第一个规则由几个目标，只有第一个目标会是默认目标，而不是整个列表；当然你也可以使用.DEFAULT_GOAL来改变默认目标；<br>也可以通过显性指定make的目标来生成对应的目标：若你指定多个模板，则make会按序执行生成他们；<br>makefile中的任何目标都可以指定为目标(除非它以’ - ‘开头或包含’ = ‘，在这种情况下，它将分别被解析为switch或变量定义)。<br>即使目标不在makefile中也可以指定，如果make可以找到规定如何创建它们的隐式规则的话。<br>Make将特殊变量MAKECMDGOALS设置为您在命令行上指定的目标列表。如果在命令行上没有给出目标，则此变量为空。注意，这个变量应该只在特殊情况下使用。<br>一个合适的例子是，为了避免在clean的时候删除.d 文件；所以make不会仅仅为了立即删除它们而创建它们<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(MAKECMDGOALS)</span>,clean)</span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<p>指定目标的一种用法是只编译程序的一部分，或者只编译几个程序中的一个。将希望重制的每个文件指定为目标。<br>例如，考虑一个包含几个程序的目录，其makefile开头是这样的:<br>.PHONY: all<br>all: size nm ld ar as<br>若你只想生成size，你可以执行make size<br>指定目标的另一种用法可能是，不是常规的生成文件，而是一个文件用于调试信息的输出，或者一个测试版本的生成；<br>指定目标的另一种用法可能是，指定假的目标，比如make clean ;<br>有以下几种类型，直接贴原文：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">all</span><br><span class="line">Make all <span class="keyword">the</span> top-level targets <span class="keyword">the</span> makefile knows about.</span><br><span class="line"></span><br><span class="line">clean</span><br><span class="line">Delete all <span class="built_in">files</span> that are normally created <span class="keyword">by</span> running make.</span><br><span class="line"></span><br><span class="line">mostlyclean</span><br><span class="line">Like ‘clean’, but may refrain <span class="built_in">from</span> deleting <span class="keyword">a</span> few <span class="built_in">files</span> that people normally don’t want <span class="built_in">to</span> recompile. For example, <span class="keyword">the</span> ‘mostlyclean’ target <span class="keyword">for</span> GCC does <span class="keyword">not</span> <span class="built_in">delete</span> libgcc.<span class="keyword">a</span>, because recompiling <span class="keyword">it</span> is rarely necessary <span class="keyword">and</span> takes <span class="keyword">a</span> lot <span class="keyword">of</span> <span class="built_in">time</span>.</span><br><span class="line"></span><br><span class="line">distclean</span><br><span class="line">realclean</span><br><span class="line">clobber</span><br><span class="line">Any <span class="keyword">of</span> these targets might be defined <span class="built_in">to</span> <span class="built_in">delete</span> more <span class="built_in">files</span> than ‘clean’ does. For example, this would <span class="built_in">delete</span> configuration <span class="built_in">files</span> <span class="keyword">or</span> links that you would normally <span class="built_in">create</span> <span class="keyword">as</span> preparation <span class="keyword">for</span> compilation, even <span class="keyword">if</span> <span class="keyword">the</span> makefile itself cannot <span class="built_in">create</span> these <span class="built_in">files</span>.</span><br><span class="line"></span><br><span class="line">install</span><br><span class="line">Copy <span class="keyword">the</span> executable <span class="built_in">file</span> <span class="keyword">into</span> <span class="keyword">a</span> <span class="built_in">directory</span> that users typically search <span class="keyword">for</span> commands; copy <span class="keyword">any</span> auxiliary <span class="built_in">files</span> that <span class="keyword">the</span> executable uses <span class="keyword">into</span> <span class="keyword">the</span> <span class="built_in">directories</span> where <span class="keyword">it</span> will look <span class="keyword">for</span> them.</span><br><span class="line"></span><br><span class="line">print</span><br><span class="line">Print listings <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">files</span> that have changed.</span><br><span class="line"></span><br><span class="line">tar</span><br><span class="line">Create <span class="keyword">a</span> tar <span class="built_in">file</span> <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">files</span>.</span><br><span class="line"></span><br><span class="line">shar</span><br><span class="line">Create <span class="keyword">a</span> <span class="built_in">shell</span> archive (shar <span class="built_in">file</span>) <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">files</span>.</span><br><span class="line"></span><br><span class="line">dist</span><br><span class="line">Create <span class="keyword">a</span> distribution <span class="built_in">file</span> <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">files</span>. This might be <span class="keyword">a</span> tar <span class="built_in">file</span>, <span class="keyword">or</span> <span class="keyword">a</span> shar <span class="built_in">file</span>, <span class="keyword">or</span> <span class="keyword">a</span> compressed <span class="built_in">version</span> <span class="keyword">of</span> <span class="literal">one</span> <span class="keyword">of</span> <span class="keyword">the</span> above, <span class="keyword">or</span> even more than <span class="literal">one</span> <span class="keyword">of</span> <span class="keyword">the</span> above.</span><br><span class="line"></span><br><span class="line">TAGS</span><br><span class="line">Update <span class="keyword">a</span> tags table <span class="keyword">for</span> this program.</span><br><span class="line"></span><br><span class="line">check</span><br><span class="line">test</span><br><span class="line">Perform self tests <span class="keyword">on</span> <span class="title">the</span> <span class="title">program</span> <span class="title">this</span> <span class="title">makefile</span> <span class="title">builds</span>.</span><br></pre></td></tr></table></figure></p>
<h4 id="除了执行"><a href="#除了执行" class="headerlink" title="除了执行"></a>除了执行</h4><p>除了生成，更新目标文件之外，还可以有别的活动，比如打印等：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">‘-n’</span><br><span class="line">‘<span class="comment">--just-print’</span></span><br><span class="line">‘<span class="comment">--dry-run’</span></span><br><span class="line">‘<span class="comment">--recon’</span></span><br><span class="line">“No-op”. Causes make <span class="keyword">to</span> print <span class="keyword">the</span> recipes <span class="keyword">that</span> are needed <span class="keyword">to</span> make <span class="keyword">the</span> targets up <span class="keyword">to</span> <span class="built_in">date</span>, <span class="keyword">but</span> <span class="keyword">not</span> actually execute them. </span><br><span class="line">Note <span class="keyword">that</span> <span class="keyword">some</span> recipes are still executed, even <span class="keyword">with</span> this flag (see How <span class="keyword">the</span> MAKE Variable Works).</span><br><span class="line">Also any recipes needed <span class="keyword">to</span> update included makefiles are still executed (see How Makefiles Are Remade).</span><br><span class="line"></span><br><span class="line">‘-t’</span><br><span class="line">‘<span class="comment">--touch’</span></span><br><span class="line">“Touch”. Marks targets <span class="keyword">as</span> up <span class="keyword">to</span> <span class="built_in">date</span> <span class="keyword">without</span> actually changing them.</span><br><span class="line"> In other <span class="built_in">words</span>, make pretends <span class="keyword">to</span> update <span class="keyword">the</span> targets <span class="keyword">but</span> <span class="keyword">does</span> <span class="keyword">not</span> really change their <span class="built_in">contents</span>;</span><br><span class="line">  instead only their modified <span class="keyword">times</span> are updated.</span><br><span class="line"></span><br><span class="line">‘-q’</span><br><span class="line">‘<span class="comment">--question’</span></span><br><span class="line">“Question”. Silently check whether <span class="keyword">the</span> targets are up <span class="keyword">to</span> <span class="built_in">date</span>, <span class="keyword">but</span> do <span class="keyword">not</span> execute recipes;</span><br><span class="line"> <span class="keyword">the</span> <span class="keyword">exit</span> code shows whether any updates are needed.</span><br><span class="line"></span><br><span class="line">‘-W <span class="built_in">file</span>’</span><br><span class="line">‘<span class="comment">--what-if=file’</span></span><br><span class="line">‘<span class="comment">--assume-new=file’</span></span><br><span class="line">‘<span class="comment">--new-file=file’</span></span><br><span class="line"><span class="string">"what if"</span> .每个' -W '标志后面都跟着一个文件名。</span><br><span class="line">make将给定文件的修改时间记录为当前时间，但实际的修改时间保持不变。您可以将' -W '标志与' -n '标志结合使用，看看如果要修改特定的文件会发生什么。</span><br></pre></td></tr></table></figure></p>
<h4 id="避免重编译指定的文件"><a href="#避免重编译指定的文件" class="headerlink" title="避免重编译指定的文件"></a>避免重编译指定的文件</h4><p>有时候你可能已经改变了一些源文件，但是你不想重新编译依赖它的全部文件；例如：假设你添加了一个宏或者一个声明在一个头文件中，很多<br>其他文件依赖这个头文件；保守的，make假设头文件的任何改变都需要重新编译所有的依赖它的文件，但你知道他们不需要重新编译，你可能不想浪费时间等待他们的编译；</p>
<p>如果你期望上面的文件得到解决，你可以使用-t ,make -t,这个flag告诉make不要运行规则中的指令；但是改变目标文件的最后修改时间；<br>为了避免异常，你最好按一下步骤进行：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 先<span class="keyword">make</span>执行重编译你需要重编译的文件；</span><br><span class="line"><span class="number">2</span> 改变头文件</span><br><span class="line"><span class="number">3</span> 对依赖头文件的文件，你不想重编译它，就用<span class="keyword">make</span> -t</span><br><span class="line">但是如果来不及了，即你已经改了头文件，但是有部分文件需要重新编译； 这种情况下，你可以使用-<span class="keyword">o</span> <span class="keyword">file</span> ，即它会标记一个具体的文件为旧的；</span><br><span class="line">这意味着这个文件本身不会被重生成，其他任何依赖它的文件也不会被重新生成；遵循以下步骤：</span><br><span class="line"><span class="number">1</span> 使用<span class="string">' make -o headerfile '</span>重新编译那些因特定头文件之外的原因而需要编译的源文件。如果涉及多个头文件，则对每个头文件使用单独的<span class="string">' -o '</span>选项。</span><br><span class="line"><span class="number">2</span> 对所有目标文件使用<span class="keyword">make</span> -t</span><br></pre></td></tr></table></figure></p>
<h4 id="覆盖变量："><a href="#覆盖变量：" class="headerlink" title="覆盖变量："></a>覆盖变量：</h4><p>一个包含=的参数，具体化一个变量的值： v=x ,设置变量v的值是x,如果你具体化一个值，按照这种方式，makefile中相同变量的所有普通赋值都会被忽略;我们说它们已经被命令行参数覆盖了<br>最常见的方式就是传递额外的flag给编译器：例如：<br>CFLAGS<br>cc -c $(CFLAGS) foo.c<br>这个变量被包含在每个指令中，被C编译器运行采纳；因此，为CFLAGS设置的任何值都会影响每次发生的编译。makefile可能会指定常用的CFLAGS值，如下所示:<br>CFLAGS=-g<br>每次运行make时，如果愿意，可以重写这个值。例如，如果你说’ make CFLAGS=’-g -O’ “，每一次C编译都将使用’ cc -c -g -O’来完成。<br>(这也说明了在覆盖变量时，如何在shell中使用引号将空格和其他特殊字符括在变量值中。)<br>变量CFLAGS只是众多标准变量中的一个，您可以通过这种方式更改它们。请参阅隐式规则使用的变量的完整列表<br>您还可以对makefile进行编程，以查看您自己的附加变量，从而使用户能够通过更改变量来控制makefile工作方式的其他方面<br>当使用命令行参数覆盖变量时，可以定义递归展开的变量或简单展开的变量。上面的例子是递归展开的变量;要创建一个简单展开的变量，可以使用’:= ‘或’::= ‘来代替’ = ‘。<br>但是，除非您希望在指定的值中包含变量引用或函数调用，否则创建哪种类型的变量没有区别。<br>makefile有一种方法可以更改已覆盖的变量。这是使用override指令，它是这样一行:’ override variable = value ‘</p>
<h4 id="测试标志-测试一个程序的编译"><a href="#测试标志-测试一个程序的编译" class="headerlink" title="测试标志,测试一个程序的编译"></a>测试标志,测试一个程序的编译</h4><p>通常，当一个错误反生在执行shell指令时，make会立即放弃，并返回一个非0值；不会继续执行来生成任何目标；<br>这个错误，暗示着目标无法正确重新生成，make会报告它；<br>当你正在编译一个你刚刚改变过的程序时，上面的结果可能不是你想要的；相反，你可能想要make 去尝试编译每个可以尝试的文件不中断，然后尽可能多的生成编译错误；</p>
<p>在这些场景下，你应该使用-k or –keep-going 标志，这告诉make在放弃并返回非零状态之前继续考虑目标的其他先决条件，并在必要时重新生成它们<br>例如，在编译一个目标文件时出现错误后，’ make -k ‘将继续编译其他目标文件，即使它已经知道不可能链接它们。</p>
<p>除了在shell命令失败后继续执行之外，在发现不知道如何创建目标文件或先决文件时，’ make -k ‘还将尽可能地继续执行。这将总是导致一个错误消息，但如果没有’ -k ‘，它将是一个致命错误<br>make的通常行为是假定你的目的是更新目标;一旦make知道这是不可能的，它不妨立即报告失败。’ -k ‘标志表示，真正的目的是尽可能多地测试程序中所做的更改，<br>可能是找到几个独立的问题，以便在下一次尝试编译之前纠正它们。这就是Emacs的M-x编译命令在默认情况下传递’ -k ‘标志的原因。</p>
<h4 id="选项总结；"><a href="#选项总结；" class="headerlink" title="选项总结；"></a>选项总结；</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">-B / <span class="comment">--always-make: 不管先决条件是否过期，目标是否过期，总是重新生成目标；</span></span><br><span class="line">-c dir / <span class="comment">--directory=dir 改变make的工作目录；</span></span><br><span class="line">-d / <span class="comment">--debug[=options] （a/b/v/i/j/m/n:all/basic/verbose/implicit/jobs/makefile/none):(全部类型的/基本的/基本之上/包括隐式规则/包括子命令/..)</span></span><br><span class="line">    打印除正常处理外的调试信息。调试信息表明哪些文件正在考虑重做，哪些文件时间正在比较，以及与什么结果相比较，哪些文件实际上需要重做，考虑了哪些隐式规则，哪些应用了——关于make如何决定做什么的所有有趣的事情。</span><br><span class="line">    -d选项等价于'——debug=a '</span><br><span class="line">-e / ‘<span class="comment">--environment-overrides’: 让取自环境的变量优先于makefile中的变量</span></span><br><span class="line">-E string / '<span class="comment">--eval=string’:将字符串作为makefile语法计算。这是eval函数的命令行版本(请参阅eval函数)。计算是在定义了默认规则和变量之后，但在读取任何makefile之前执行的。</span></span><br><span class="line">-f file /<span class="comment">--file=file’/ ‘--makefile=file’: 指定makefile文件</span></span><br><span class="line">-h /<span class="comment">--help: 打印帮助</span></span><br><span class="line">-i /<span class="comment">--ignore-errors: 忽略重编时指令中的所有错误</span></span><br><span class="line">‘-I dir’/‘<span class="comment">--include-dir=dir’:指定一个目录dir来搜索所包含的makefile。参见包含其他makefile。如果使用多个' -I '选项指定多个目录，则按照指定的顺序搜索目录。</span></span><br><span class="line">‘-j [jobs]’/‘<span class="comment">--jobs[=jobs]’ 多少个线程多线程执行</span></span><br><span class="line">-k / <span class="comment">--keep-going :继续执行，即使发生错误</span></span><br><span class="line">‘-l [<span class="keyword">load</span>]’/‘<span class="comment">--load-average[=load]’/‘--max-load[=load]’: 指定若有其他指令在执行，且加载的平均值至少为load，则不应启动新指令，用于控制make的多线程负载</span></span><br><span class="line">‘-L’/‘<span class="comment">--check-symlink-times’:</span></span><br><span class="line">在支持符号链接的系统上，除了这些链接引用的文件上的时间戳之外，这个选项还会导致make考虑任何符号链接上的时间戳。当提供此选项时，文件和符号链接中最近的时间戳将作为此目标文件的修改时间。</span><br><span class="line">‘-n’/‘<span class="comment">--just-print’/‘--dry-run’/‘--recon’: 打印要执行的指令，但是不要执行它，即只是查看它；</span></span><br><span class="line">‘-o <span class="keyword">file</span>’/‘<span class="comment">--old-file=file’/‘--assume-old=file’</span></span><br><span class="line">不要重做文件文件，即使它比它的先决条件旧，也不要重做任何文件中的变化。本质上，该文件被视为非常老的文件，其规则被忽略。</span><br><span class="line">‘-O[<span class="keyword">type</span>]’/‘<span class="comment">--output-sync[=type]’:指示多线程执行的时候怎么打印信息，上文有，不赘述</span></span><br><span class="line">‘-p’/‘<span class="comment">--print-data-base’: </span></span><br><span class="line">打印从makefile读取的数据库：然后按照常规方式执行，要打印数据库而不重新创建任何文件，请使用<span class="string">' make -qp '</span>。要打印预定义规则和变量的数据库，</span><br><span class="line">请使用<span class="string">' make -p -f /dev/null '</span>。数据库输出包含指令和变量定义的文件名和行号信息，因此它在复杂环境中是一个有用的调试工具。</span><br><span class="line">‘-q’/‘<span class="comment">--question’:</span></span><br><span class="line">不要运行任何指令，或打印任何东西;如果指定的目标已经是最新的，则只返回一个退出状态为0;如果需要重新制作，则返回一个;如果遇到错误，则返回两个</span><br><span class="line">‘-r’/‘<span class="comment">--no-builtin-rules’:避免使用内置的隐式规则</span></span><br><span class="line">“- r”/“——no-builtin-variables”:避免使用内置的特定于规则的变量</span><br><span class="line">‘-s’/‘<span class="comment">--silent’/‘--quiet’: 静默模式，不输出任何信息，在执行的过程中；</span></span><br><span class="line">‘-S’/‘<span class="comment">--no-keep-going’/‘--stop’:</span></span><br><span class="line">取消' -k '选项的效果。这从来没有必要，除非在递归make中，' -k '可能从顶级make中继承通过MAKEFLAGS(参见递归使用make)，或者如果你在你的环境中的MAKEFLAGS中设置了' -k '。</span><br><span class="line">‘-t’/‘<span class="comment">--touch’:只是标记文件为最新，而不是真的生成目标文件</span></span><br><span class="line">‘<span class="comment">--trace’ ：显示make执行的跟踪信息。</span></span><br><span class="line">‘-v’/‘<span class="comment">--version’: 打印版本号</span></span><br><span class="line">‘-w’/‘<span class="comment">--print-directory’: 打印工作目录</span></span><br><span class="line">‘-W file’</span><br><span class="line">‘<span class="comment">--what-if=file’</span></span><br><span class="line">‘<span class="comment">--new-file=file’</span></span><br><span class="line">‘<span class="comment">--assume-new=file’</span></span><br><span class="line">假设目标文件刚刚被修改。当与' -n '标志一起使用时，这将显示如果要修改该文件会发生什么。如果没有' -n '，在运行make之前在给定的文件上运行touch命令几乎是一样的，除了修改时间只是在make的想象中改变。</span><br></pre></td></tr></table></figure>
<h3 id="如何使用隐式规则"><a href="#如何使用隐式规则" class="headerlink" title="如何使用隐式规则"></a>如何使用隐式规则</h3><p>remake目标文件的确定的标准方法经常被使用。例如，一种make目标文件的习惯方法是使用C编译器cc从C源文件中获取目标文件。<br>隐式规则，告诉make如何使用习惯的技术，以便于你不用具体化他们的细节，当你想要用他们的时候；例如：<br>这是一个为C编译使用的隐式规则：文件名决定了哪种隐式规则被运行；例如，c编译典型就是用.c文件生成.o文件; 所以make为此应用了隐式规则，当他看到这种字符结尾的文件；<br>一系列的隐式规则可以按顺序应用;例如，make将通过.c文件从.y文件重制一个.o文件。<br>内置的隐式规则在其方法中使用几个变量，因此，通过更改变量的值，可以更改隐式规则的工作方式。例如，变量CFLAGS控制C编译的隐式规则给C编译器的标志。<br>您可以通过编写模式规则来定义自己的隐式规则。</p>
<p>后缀规则是定义隐式规则的一种更有限的方式。模式规则更加通用和清晰，但后缀规则保留以保持兼容性</p>
<h4 id="使用隐式规则"><a href="#使用隐式规则" class="headerlink" title="使用隐式规则"></a>使用隐式规则</h4><p>为了让make找到更新目标文件的常用方法，您所需要做的就是避免自己指定指令。<br>要么写一个没有指令的规则，要么根本不写规则。然后，make将根据存在或可以创建哪种源文件来确定使用哪种隐式规则<br>例如，有个makefile如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo : foo<span class="selector-class">.o</span> bar.o</span><br><span class="line">        cc -o foo foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span> $(CFLAGS) $(LDFLAGS)</span><br></pre></td></tr></table></figure></p>
<p>这里因为你提到了foo.o,但是却没有给一个规则，所以make自动的寻找一个隐式规则来告知如何更新它；这个事情的发生不管当前是否有foo.o存在；</p>
<p>如果一个隐式规则被找到，它能应用到一个指令和一个或多个依赖(源文件)。如果你需要具体化格外的依赖文件比如头文件，你可以写一个只包含依赖文件的，不包含指令的<br>规则；</p>
<p>每个隐式规则由一个目标模板和一个依赖模板。可能有许多隐式规则用相同的目标模板；例如： 生成.o的，可以是.c,.p,等等，对应的c和pascal编译器。<br>这个规则实际上应用在依赖存在的目标上，或者能被生成；所以如果你有一个foo.c文件，make将运行c编译器，否则，如果有foo.p，make可能会运行pascal编译器来生成<br>;以此类推；</p>
<p>当然，当你写makefile,你得知道哪些隐式规则你想让make使用，并且你知道它会选择哪些依赖文件，那些依赖文件存在等等；<br>上面，我们说过，如果必要的先决条件“存在或可以建立”，就应用隐式规则。如果在makefile中显式地提到文件作为目标或先决条件，<br>或者可以递归地找到创建文件的隐式规则，则“可以创建”文件。当一个隐式前提是另一个隐式规则的结果时，我们说链接正在发生。</p>
<p>一般而言，make会为每个目标，每个只有冒号但是没有指令的目标寻找隐式规则；一个文件只在依赖中被提到也会被当做目标，这个时候它也没有具体化目标；<br>所以隐式规则寻找这里也会发生；</p>
<p>要注意显示规则不会影响到隐式规则的寻找：如<br>foo.o:foo.p<br>注意这里，依赖是foo.p,并不意味着make会依据隐式规则来从foo.p生成foo.o,例如，如果foo.c存在，则会从foo.c生成foo.o ,因为在<br>隐式规则列表中，c这个存在于p之前；</p>
<p>如果您不希望隐式规则用于没有指令的目标，可以通过编写分号为该目标提供一个空配方</p>
<h4 id="内建规则清单"><a href="#内建规则清单" class="headerlink" title="内建规则清单"></a>内建规则清单</h4><p>下面是一组预定义的隐式规则，它们总是可用的，除非makefile显式地覆盖或取消它们。<br>有关取消或重写隐式规则的信息，请参阅取消隐式规则。选项’ -r ‘或’——no-built -rules ‘取消所有预定义的规则。</p>
<p>本手册仅记录基于posix的操作系统上可用的默认规则。其他操作系统，如VMS、Windows、OS/2等可能有不同的默认规则集。<br>要查看您版本的GNU make中可用的默认规则和变量的完整列表，请在一个没有makefile的目录中运行’ make -p ‘。</p>
<p>当然，即使是我们指定了 -r 参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有 “后缀列表”（也就一系统定义在目标 .SUFFIXES 的依赖目标），<br>那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<p>编译C程序的隐含规则。</p>
<p><n>.o 的目标的依赖目标会自动推导为 <n>.c ，并且其生成命令是 $(CC) –c $(CPPFLAGS) $(CFLAGS)</n></n></p>
<p>编译C++程序的隐含规则。</p>
<p><n>.o 的目标的依赖目标会自动推导为 <n>.cc 或是 <n>.C ，并且其生成命令是 $(CXX) –c $(CPPFLAGS) $(CFLAGS) 。（建议使用 .cc 作为C++源文件的后缀，而不是 .C ）</n></n></n></p>
<p>编译Pascal程序的隐含规则。</p>
<p><n>.o 的目标的依赖目标会自动推导为 <n>.p ，并且其生成命令是 $(PC) –c  $(PFLAGS) 。</n></n></p>
<p>编译Fortran/Ratfor程序的隐含规则。</p>
<p><n>.o 的目标的依赖目标会自动推导为 <n>.r 或 <n>.F 或 <n>.f ，并且其生成命令是:<br>.f $(FC) –c  $(FFLAGS)<br>.F $(FC) –c  $(FFLAGS) $(CPPFLAGS)<br>.f $(FC) –c  $(FFLAGS) $(RFLAGS)<br>预处理Fortran/Ratfor程序的隐含规则。</n></n></n></n></p>
<p><n>.f 的目标的依赖目标会自动推导为 <n>.r 或 <n>.F 。这个规则只是转换Ratfor 或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：<br>.F $(FC) –F $(CPPFLAGS) $(FFLAGS)<br>.r $(FC) –F $(FFLAGS) $(RFLAGS)<br>编译Modula-2程序的隐含规则。</n></n></n></p>
<p><n>.sym 的目标的依赖目标会自动推导为 <n>.def ，并且其生成命令是： $(M2C) $(M2FLAGS) $(DEFFLAGS) 。 <n>.o 的目标的依赖目标会自动推导为 <n>.mod ，并且其生成命令是： $(M2C) $(M2FLAGS) $(MODFLAGS) 。</n></n></n></n></p>
<p>汇编和汇编预处理的隐含规则。</p>
<p><n>.o 的目标的依赖目标会自动推导为 <n>.s ，默认使用编译器 as ，并且其生成命令是： $ (AS) $(ASFLAGS) 。 <n>.s 的目标的依赖目标会自动推导为 <n>.S ，默认使用C预编译器 cpp ，并且其生成命令是： $(AS) $(ASFLAGS) 。</n></n></n></n></p>
<p>链接Object文件的隐含规则。</p>
<p><n> 目标依赖于 <n>.o ，通过运行C的编译器来运行链接程序生成（一般是 ld ），其生成命令是： $(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS) 。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:</n></n></n></p>
<p>x : y.o z.o<br>并且 x.c 、 y.c 和 z.c 都存在时，隐含规则将执行如下命令:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cc -c x<span class="selector-class">.c</span> -o x.o</span><br><span class="line">cc -c y<span class="selector-class">.c</span> -o y.o</span><br><span class="line">cc -c z<span class="selector-class">.c</span> -o z.o</span><br><span class="line">cc x<span class="selector-class">.o</span> y<span class="selector-class">.o</span> z<span class="selector-class">.o</span> -o x</span><br><span class="line">rm -f x.o</span><br><span class="line">rm -f y.o</span><br><span class="line">rm -f z.o</span><br></pre></td></tr></table></figure></p>
<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<p>Yacc C程序时的隐含规则。</p>
<p><n>.c 的依赖文件被自动推导为 n.y （Yacc生成的文件），其生成命令是： $(YACC) $(YFALGS) 。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</n></p>
<p>Lex C程序时的隐含规则。</p>
<p><n>.c 的依赖文件被自动推导为 n.l （Lex生成的文件），其生成命令是： $(LEX) $(LFALGS) 。（关于“Lex”的细节请查看相关资料）</n></p>
<p>Lex Ratfor程序时的隐含规则。</p>
<p><n>.r 的依赖文件被自动推导为 n.l （Lex生成的文件），其生成命令是： $(LEX) $(LFALGS) 。</n></p>
<p>从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</p>
<p><n>.ln （lint生成的文件）的依赖文件被自动推导为 n.c ，其生成命令是： $(LINT) $(LINTFALGS) $(CPPFLAGS) -i 。对于 <n>.y 和 <n>.l 也是同样的规则。</n></n></n></p>
<p>更多参考文档</p>
<h4 id="隐式规则中变量的使用："><a href="#隐式规则中变量的使用：" class="headerlink" title="隐式规则中变量的使用："></a>隐式规则中变量的使用：</h4><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的 -R 或 –no–builtin-variables 参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是 $(CC) –c $(CFLAGS) $(CPPFLAGS) 。Make默认的编译命令是 cc ，如果你把变量 $(CC) 重定义成 gcc ，把变量 $(CFLAGS) 重定义成 -g ，那么，隐含规则中的命令全部会以 gcc –c -g $(CPPFLAGS) 的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如 CC ；一种是参数相的关，如 CFLAGS 。下面是所有隐含规则中会用到的变量：</p>
<p>关于命令的变量。<br>AR : 函数库打包程序。默认命令是 ar<br>AS : 汇编语言编译程序。默认命令是 as<br>CC : C语言编译程序。默认命令是 cc<br>CXX : C++语言编译程序。默认命令是 g++<br>CO : 从 RCS文件中扩展文件程序。默认命令是 co<br>CPP : C程序的预处理器（输出是标准输出设备）。默认命令是 $(CC) –E<br>FC : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 f77<br>GET : 从SCCS文件中扩展文件的程序。默认命令是 get<br>LEX : Lex方法分析器程序（针对于C或Ratfor）。默认命令是 lex<br>PC : Pascal语言编译程序。默认命令是 pc<br>YACC : Yacc文法分析器（针对于C程序）。默认命令是 yacc<br>YACCR : Yacc文法分析器（针对于Ratfor程序）。默认命令是 yacc –r<br>MAKEINFO : 转换Texinfo源文件（.texi）到Info文件程序。默认命令是 makeinfo<br>TEX : 从TeX源文件创建TeX DVI文件的程序。默认命令是 tex<br>TEXI2DVI : 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是 texi2dvi<br>WEAVE : 转换Web到TeX的程序。默认命令是 weave<br>CWEAVE : 转换C Web 到 TeX的程序。默认命令是 cweave<br>TANGLE : 转换Web到Pascal语言的程序。默认命令是 tangle<br>CTANGLE : 转换C Web 到 C。默认命令是 ctangle<br>RM : 删除文件命令。默认命令是 rm –f<br>关于命令参数的变量<br>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<p>ARFLAGS : 函数库打包程序AR命令的参数。默认值是 rv<br>ASFLAGS : 汇编语言编译器参数。（当明显地调用 .s 或 .S 文件时）<br>CFLAGS : C语言编译器参数。<br>CXXFLAGS : C++语言编译器参数。<br>COFLAGS : RCS命令参数。<br>CPPFLAGS : C预处理器参数。（ C 和 Fortran 编译器也会用到）。<br>FFLAGS : Fortran语言编译器参数。<br>GFLAGS : SCCS “get”程序参数。<br>LDFLAGS : 链接器参数。（如： ld ）<br>LFLAGS : Lex文法分析器参数。<br>PFLAGS : Pascal语言编译器参数。<br>RFLAGS : Ratfor 程序的Fortran 编译器参数。<br>YFLAGS : Yacc文法分析器参数。</p>
<h4 id="隐式规则链："><a href="#隐式规则链：" class="headerlink" title="隐式规则链："></a>隐式规则链：</h4><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个 .o 的文件生成，可能会是先被 Yacc的[.y]文件先成 .c ，然后再被C的编译器生成。<br>我们把这一系列的隐含规则叫做“隐含规则链”。</p>
<p>在上面的例子中，如果文件 .c 存在，那么就直接调用C的编译器的隐含规则，如果没有 .c 文件，但有一个 .y 文件，那么Yacc的隐含规则会被调用，生成 .c 文件，<br>然后，再调用C编译的隐含规则最终由 .c 生成 .o 文件，达到目标。</p>
<p>我们把这种 .c 的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，<br>其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的 makefile发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，<br>那么，产生最终目标过程中，所产生的中间目标文件会被以 rm -f 删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标 .INTERMEDIATE 来强制声明。<br>（如： .INTERMEDIATE : mid ）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标 .SECONDARY 来强制声明（如： .SECONDARY : sec ）。你还可以把你的目标，<br>以模式的方式来指定（如： %.o ）成伪目标 .PRECIOUS 的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件 foo.c 生成目标程序 foo ，按道理，make会编译生成中间文件 foo.o ，然后链接成 foo ，<br>但在实际情况下，这一动作可以被一条 cc 的命令完成（ cc –o foo foo.c ），于是优化过的规则就不会生成中间文件。</p>
<h4 id="如何定义新的隐式规则"><a href="#如何定义新的隐式规则" class="headerlink" title="如何定义新的隐式规则"></a>如何定义新的隐式规则</h4><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有 % 字符。 % 的意思是表示一个或多个任意字符。<br>在依赖目标中同样可以使用 % ，只是依赖目标中的 % 的取值，取决于其目标。</p>
<p>有一点需要注意的是， % 的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入 Makefile时，而模式规则中的 % 则发生在运行时。</p>
<p>模式规则介绍<br>模式规则中，至少在规则的目标定义中要包含 % ，否则，就是一般的规则。目标中的 % 定义表示对文件名的匹配， % 表示长度任意的非空字符串。<br>例如： %.c 表示以 .c 结尾的文件名（文件名的长度至少为3），而 s.%.c 则表示以 s. 开头， .c 结尾的文件名（文件名的长度至少为5）。</p>
<p>如果 % 定义在目标中，那么，目标中的 % 的值决定了依赖目标中的 % 的值，也就是说，目标中的模式的 % 决定了依赖目标中 % 的样子。例如有一个模式规则如下：</p>
<p>%.o : %.c ; <command ......="">;<br>其含义是，指出了怎么从所有的 .c 文件生成相应的 .o 文件的规则。如果要生成的目标是 a.o b.o ，那么 %c 就是 a.c b.c 。</p>
<p>一旦依赖目标中的 % 模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，<br>目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>
<h5 id="模式规则示例"><a href="#模式规则示例" class="headerlink" title="模式规则示例"></a>模式规则示例</h5><p>下面这个例子表示了,把所有的 .c 文件都编译成 .o 文件.</p>
<p>%.o : %.c<br>    $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@<br>其中， $@ 表示所有的目标的挨个值， $&lt; 表示了所有依赖目标的挨个值。这些奇怪的变量我们叫“自动化变量”，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的：</p>
<p>%.tab.c %.tab.h: %.y<br>    bison -d $&lt;<br>这条规则告诉make把所有的 .y 文件都以 bison -d <n>.y 执行，然后生成 <n>.tab.c 和 <n>.tab.h 文件。（其中， <n> 表示一个任意字符串）。如果我们的执行程序 foo 依赖于文件 parse.tab.o 和 scan.o ，并且文件 scan.o 依赖于文件 parse.tab.h ，如果 parse.y 文件被更新了，那么根据上述的规则， bison -d parse.y 就会被执行一次，于是， parse.tab.o 和 scan.o 的依赖文件就齐了。（假设， parse.tab.o 由 parse.tab.c 生成，和 scan.o 由 scan.c 生成，而 foo 由 parse.tab.o 和 scan.o 链接生成，而且 foo 和其 .o 文件的依赖关系也写好，那么，所有的目标都会得到满足）</n></n></n></n></p>
<h5 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h5><p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$@ : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， $@ 就是匹配于目标中模式定义的集合。</span><br><span class="line">$% : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 foo.a(bar.o) ，那么， $% 就是 bar.o ， $@ 就是 foo.a 。如果目标不是函数库文件（Unix下是 .a ，Windows下是 .<span class="keyword">lib</span> ），那么，其值为空。</span><br><span class="line">$&lt; : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 $&lt; 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</span><br><span class="line">$? : 所有比目标新的依赖目标的集合。以空格分隔。</span><br><span class="line">$^ : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</span><br><span class="line">$+ : 这个变量很像 $^ ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</span><br><span class="line">$* : 这个变量表示目标模式中 % 及其之前的部分。如果目标是 dir/a.foo.b ，并且目标的模式是 a.%.b ，那么， $* 的值就是 dir/a.foo 。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么 $* 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 $* 就是除了后缀的那一部分。例如：如果目标是 foo.c ，因为 .c 是make所能识别的后缀名，所以， $* 的值就是 foo 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 $* ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 $* 就是空值。</span><br><span class="line">当你希望只对更新过的依赖文件进行操作时， $? 在显式规则中很有用，例如，假设有一个函数库文件叫 <span class="class"><span class="keyword">lib</span> ，其由其它几个<span class="title">object</span>文件更新。那么把<span class="title">object</span>文件打包的比较有效率的<span class="title">Makefile</span>规则是：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">lib</span> : <span class="title">foo</span>.<span class="title">o</span> <span class="title">bar</span>.<span class="title">o</span> <span class="title">lose</span>.<span class="title">o</span> <span class="title">win</span>.<span class="title">o</span></span></span><br><span class="line">    ar r <span class="class"><span class="keyword">lib</span> $?</span></span><br><span class="line">在上述所列出来的自动量变量中。四个变量（ $@ 、 $&lt; 、 $% 、 $* ）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上 D 或 F 字样。这是GNU make中老版本的特性，在新版本中，我们使用函数 dir 或 notdir 就可以做到了。 D 的含义就是Directory，就是目录， F 的含义就是File，就是文件。</span><br></pre></td></tr></table></figure></p>
<p>下面是对于上面的七个变量分别加上 D 或是 F 的含义：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(@D)</span><br><span class="line">表示 $@ 的目录部分（不以斜杠作为结尾），如果 $@ 值是 dir/foo.o ，那么 $(@D) 就是 dir ，而如果 $@ 中没有包含斜杠的话，其值就是 . （当前目录）。</span><br><span class="line">$(@F)</span><br><span class="line">表示 $@ 的文件部分，如果 $@ 值是 dir/foo.o ，那么 $(@F) 就是 foo.o ， $(@F) 相当于函数 $(notdir $@) 。</span><br><span class="line">$(*D), $(*F)</span><br><span class="line">和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， $(*D) 返回 dir ，而 $(*F) 返回 foo</span><br><span class="line">$(%D), $(%F)</span><br><span class="line">分别表示了函数包文件成员的目录部分和文件部分。这对于形同 archive(member) 形式的目标中的 member 中包含了不同的目录很有用。</span><br><span class="line">$(&lt;D), $(&lt;F)</span><br><span class="line">分别表示依赖文件的目录部分和文件部分。</span><br><span class="line">$(^D), $(^F)</span><br><span class="line">分别表示所有依赖文件的目录部分和文件部分。（无相同的）</span><br><span class="line">$(+D), $(+F)</span><br><span class="line">分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</span><br><span class="line">$(<span class="string">?D</span>), $(<span class="string">?F</span>)</span><br><span class="line">分别表示被更新的依赖文件的目录部分和文件部分。</span><br><span class="line">最后想提醒一下的是，对于 $&lt; ，为了避免产生不必要的麻烦，我们最好给 $ 后面的那个特定字符都加上圆括号，比如， $(&lt;) 就要比 $&lt; 要好一些。</span><br></pre></td></tr></table></figure></p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是“显式规则”和“静态模式规则”（参见前面“书写规则”一章）。其在隐含规则中并没有意义。</p>
<h5 id="模式的匹配"><a href="#模式的匹配" class="headerlink" title="模式的匹配"></a>模式的匹配</h5><p>一般来说，一个目标的模式有一个有前缀或是后缀的 % ，或是没有前后缀，直接就是一个 % 。因为 % 代表一个或多个字符，所以在定义好了的模式中，我们把 % 所匹配的内容叫做“茎”，例如 %.c 所匹配的文件“test.c”中“test”就是“茎”。因为在目标和依赖目标中同时有 % 时，依赖目标的“茎”会传给目标，当做目标中的“茎”。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式 e%t ，文件 src/eat 匹配于该模式，于是 src/a 就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式 c%r ，那么，目标就是 src/car 。（“茎”被传递）</p>
<h5 id="重载内建隐含规则"><a href="#重载内建隐含规则" class="headerlink" title="重载内建隐含规则"></a>重载内建隐含规则</h5><p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">    $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(<span class="keyword">date</span>)</span><br></pre></td></tr></table></figure></p>
<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>
<p>%.o : %.s<br>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h4 id="老式风格的隐式规则"><a href="#老式风格的隐式规则" class="headerlink" title="老式风格的隐式规则"></a>老式风格的隐式规则</h4><p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。<br>为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：“双后缀”和“单后缀”。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如 .c.o 相当于 %o : %c 。单后缀规则只定义一个后缀，也就是源文件的后缀。<br>如 .c 相当于 % : %.c 。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。<br>例如： .c 和 .o 都是make所知道。因而，如果你定义了一个规则是 .c.o 那么其就是双后缀规则，意义就是 .c 是源文件的后缀， .o 是目标文件的后缀。如下示例：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.c.o:</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</span><br><span class="line"></span><br><span class="line"><span class="section">.c.o: foo.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">这个例子，就是说，文件 .c.o 依赖于文件 foo.h ，而不是我们想要的这样：</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c foo.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</span><br><span class="line"></span><br><span class="line">而要让make知道一些特定的后缀，我们可以使用伪目标 .SUFFIXES 来定义或是删除，如：</span><br><span class="line"></span><br><span class="line"><span class="section">.SUFFIXES: .hack .win</span></span><br><span class="line">把后缀 .hack 和 .win 加入后缀列表中的末尾。</span><br><span class="line"></span><br><span class="line"><span class="section">.SUFFIXES:              # 删除默认的后缀</span></span><br><span class="line"><span class="section">.SUFFIXES: .c .o .h   # 定义自己的后缀</span></span><br><span class="line">先清除默认后缀，后定义自己的后缀列表。</span><br></pre></td></tr></table></figure></p>
<p>make的参数 -r 或 -no-builtin-rules 也会使用得默认的后缀列表为空。而变量 SUFFIXE 被用来定义默认的后缀列表，你可以用 .SUFFIXES 来改变后缀列表，<br>但请不要改变变量 SUFFIXE 的值。</p>
<h4 id="隐式规则的搜索算法"><a href="#隐式规则的搜索算法" class="headerlink" title="隐式规则的搜索算法"></a>隐式规则的搜索算法</h4><p>比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，<br>原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是 archive(member) 的函数库文件模式，那么这个算法会被运行两次，<br>第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把 member 当作T来搜索。</p>
<p>1 把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是 src/foo.o ，那么，D就是 src/ ，N就是 foo.o ）<br>2 创建所有匹配于T或是N的模式规则列表。<br>3 如果在模式规则列表中有匹配所有文件的模式，如 % ，那么从列表中移除其它的模式。<br>4 移除列表中没有命令的规则。<br>5 对于第一个在列表中的模式规则：<br>   1) 推导其“茎”S，S应该是T或是N匹配于模式中 % 非空的部分。<br>   2) 计算依赖文件。把依赖文件中的 % 都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。<br>   3) 测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）<br>   4) 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。<br>6 如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：<br>   1) 如果规则是终止规则，那就忽略它，继续下一条模式规则。<br>   2) 计算依赖文件。（同第5步）<br>   3) 测试所有的依赖文件是否存在或是理当存在。<br>   4) 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。<br>   5) 如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。<br>   6) 如果没有隐含规则可以使用，查看 .DEFAULT 规则，如果有，采用，把 .DEFAULT 的命令给T使用。<br>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。  </p>
<h3 id="使用make更新archive文件"><a href="#使用make更新archive文件" class="headerlink" title="使用make更新archive文件"></a>使用make更新archive文件</h3><p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令 ar 来完成打包工作。<br>Archive files are files containing named sub-files called members; they are maintained with the program ar and their main use is as subroutine libraries for linking.</p>
<h4 id="archive-members"><a href="#archive-members" class="headerlink" title="archive members"></a>archive members</h4><p>一个函数库文件由多个文件组成。你可以用如下格式指定函数库文件及其组成:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">archive</span><span class="params">(member)</span></span></span><br><span class="line">这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了 ar 命令来服务的。如:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foolib</span><span class="params">(hack.o)</span></span> : hack.o</span><br><span class="line">    ar cr foolib hack.o</span><br><span class="line">如果要指定多个member，那就以空格分开，如:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foolib</span><span class="params">(hack.o kludge.o)</span></span></span><br><span class="line">其等价于:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foolib</span><span class="params">(hack.o)</span></span> foolib(kludge.o)</span><br><span class="line">你还可以使用Shell的文件通配符来定义，如:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foolib</span><span class="params">(*.o)</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="archive后缀规则"><a href="#archive后缀规则" class="headerlink" title="archive后缀规则"></a>archive后缀规则</h4><p>函数库成员的隐含规则<br>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是 a(m) 形式的，其会把目标变成 (m) 。于是，如果我们的成员是 %.o 的模式定义，并且如果我们使用 make foo.a(bar.o) 的形式调用Makefile时，隐含规则会去找 bar.o 的规则，如果没有定义 bar.o 的规则，那么内建隐含规则生效，make会去找 bar.c 文件来生成 bar.o ，如果找得到的话，make执行的命令大致如下:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">cc</span> -c <span class="keyword">bar.c </span>-o <span class="keyword">bar.o</span></span><br><span class="line"><span class="keyword">ar </span>r foo.a <span class="keyword">bar.o</span></span><br><span class="line"><span class="keyword">rm </span>-f <span class="keyword">bar.o</span></span><br><span class="line"><span class="keyword">还有一个变量要注意的是 </span>$% ，这是专属函数库文件的自动化变量，有关其说明请参见“自动化变量”一节。</span><br></pre></td></tr></table></figure></p>
<p>函数库文件的后缀规则<br>你可以使用“后缀规则”和“隐含规则”来生成函数库打包文件，如：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.c.a:</span><br><span class="line">    $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o</span><br><span class="line">    $(AR) r $@ $*.o</span><br><span class="line">    $(RM) $*.o</span><br><span class="line">其等效于：</span><br><span class="line"></span><br><span class="line">(%.o) : %.c</span><br><span class="line">    $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o</span><br><span class="line">    $(AR) r $@ $*.o</span><br><span class="line">    $(RM) $*.o</span><br></pre></td></tr></table></figure></p>
<h4 id="陷阱："><a href="#陷阱：" class="headerlink" title="陷阱："></a>陷阱：</h4><p>在进行函数库打包文件生成时，请小心使用make的并行机制（ -j 参数）。如果多个 ar 命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。<br>所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。<br>但就目前而言，你还是应该不要尽量不要使用 -j 参数  </p>
<h3 id="如何扩展gnu-make-这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；"><a href="#如何扩展gnu-make-这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；" class="headerlink" title="如何扩展gnu make 这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；"></a>如何扩展gnu make 这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；</h3><h4 id="Guile-Integration"><a href="#Guile-Integration" class="headerlink" title="Guile Integration"></a>Guile Integration</h4><h4 id="Loading-Objects"><a href="#Loading-Objects" class="headerlink" title="Loading Objects"></a>Loading Objects</h4><h3 id="更多参考ref"><a href="#更多参考ref" class="headerlink" title="更多参考ref"></a>更多参考ref</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/makefile/" rel="tag"># makefile</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/03/cpp-type/" rel="prev" title="cpp_type">
      <i class="fa fa-chevron-left"></i> cpp_type
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/17/systemcall/" rel="next" title="systemcall">
      systemcall <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言："><span class="nav-number">1.</span> <span class="nav-text">前言：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#make的基本功能和使用简介："><span class="nav-number">2.</span> <span class="nav-text">make的基本功能和使用简介：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#makefile是什么样的文件："><span class="nav-number">2.1.</span> <span class="nav-text">makefile是什么样的文件：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#makefiles介绍："><span class="nav-number">2.2.</span> <span class="nav-text">makefiles介绍：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#makefile中的规则："><span class="nav-number">2.3.</span> <span class="nav-text">makefile中的规则：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个简单的例子："><span class="nav-number">2.4.</span> <span class="nav-text">一个简单的例子：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解释"><span class="nav-number">2.5.</span> <span class="nav-text">解释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#makefile中的变量使用："><span class="nav-number">2.6.</span> <span class="nav-text">makefile中的变量使用：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何写makefile？"><span class="nav-number">3.</span> <span class="nav-text">如何写makefile？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#makefile文件包含什么："><span class="nav-number">3.1.</span> <span class="nav-text">makefile文件包含什么：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#makefile文件的命名；"><span class="nav-number">3.2.</span> <span class="nav-text">makefile文件的命名；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个makefile文件如何使用其他makefile文件"><span class="nav-number">3.3.</span> <span class="nav-text">一个makefile文件如何使用其他makefile文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MAKEFILES变量；类似于include"><span class="nav-number">3.4.</span> <span class="nav-text">MAKEFILES变量；类似于include</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#overrding-makefiles"><span class="nav-number">3.5.</span> <span class="nav-text">overrding makefiles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#make如何读取makefile"><span class="nav-number">3.6.</span> <span class="nav-text">make如何读取makefile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#make如何解析makefile"><span class="nav-number">3.7.</span> <span class="nav-text">make如何解析makefile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-and-when-secondary-expansion-is-performed"><span class="nav-number">3.8.</span> <span class="nav-text">How and when secondary expansion is performed.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#makefile的规则书写"><span class="nav-number">4.</span> <span class="nav-text">makefile的规则书写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Rule的例子"><span class="nav-number">4.1.</span> <span class="nav-text">Rule的例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rule语法"><span class="nav-number">4.2.</span> <span class="nav-text">Rule语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依赖文件的类型"><span class="nav-number">4.3.</span> <span class="nav-text">依赖文件的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Wildcards-通配符-用法"><span class="nav-number">4.4.</span> <span class="nav-text">Wildcards(通配符)用法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#通配符的例子："><span class="nav-number">4.4.1.</span> <span class="nav-text">通配符的例子：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；"><span class="nav-number">4.4.2.</span> <span class="nav-text">通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通配符函数："><span class="nav-number">4.4.3.</span> <span class="nav-text">通配符函数：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目录搜索，为源文件搜索其他路径"><span class="nav-number">4.5.</span> <span class="nav-text">目录搜索，为源文件搜索其他路径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#整体搜索"><span class="nav-number">4.5.1.</span> <span class="nav-text">整体搜索</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选择性搜索"><span class="nav-number">4.5.2.</span> <span class="nav-text">选择性搜索</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#搜索算法"><span class="nav-number">4.5.3.</span> <span class="nav-text">搜索算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#指令搜索：-如何写一个指令能和搜索路径一起工作"><span class="nav-number">4.5.4.</span> <span class="nav-text">指令搜索： 如何写一个指令能和搜索路径一起工作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#隐式规则索索；"><span class="nav-number">4.5.5.</span> <span class="nav-text">隐式规则索索；</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#链接库搜索；"><span class="nav-number">4.5.6.</span> <span class="nav-text">链接库搜索；</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#伪目标，强制目标-空目标-特殊目标，多目标"><span class="nav-number">4.6.</span> <span class="nav-text">伪目标，强制目标 空目标 特殊目标，多目标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#伪目标"><span class="nav-number">4.6.1.</span> <span class="nav-text">伪目标</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#强制目标：没有依赖或规则的目标："><span class="nav-number">4.6.2.</span> <span class="nav-text">强制目标：没有依赖或规则的目标：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#空目标文件用来记录事件"><span class="nav-number">4.6.3.</span> <span class="nav-text">空目标文件用来记录事件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#具体的内建目标名"><span class="nav-number">4.6.4.</span> <span class="nav-text">具体的内建目标名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一个规则中的多个目标"><span class="nav-number">4.6.5.</span> <span class="nav-text">一个规则中的多个目标</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个规则"><span class="nav-number">4.7.</span> <span class="nav-text">多个规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态模式"><span class="nav-number">4.8.</span> <span class="nav-text">静态模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#静态模式规则的语法："><span class="nav-number">4.8.1.</span> <span class="nav-text">静态模式规则的语法：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动化生成先决条件：How-to-automatically-generate-rules-giving-prerequisites-from-source-files-themselves"><span class="nav-number">4.9.</span> <span class="nav-text">自动化生成先决条件：How to automatically generate rules giving prerequisites from source files themselves.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规则中指令如何写？"><span class="nav-number">5.</span> <span class="nav-text">规则中指令如何写？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指令语法–指令语法特性和陷阱"><span class="nav-number">5.1.</span> <span class="nav-text">指令语法–指令语法特性和陷阱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何控制什么时候指令回显"><span class="nav-number">5.2.</span> <span class="nav-text">如何控制什么时候指令回显</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令是如何执行的"><span class="nav-number">5.3.</span> <span class="nav-text">指令是如何执行的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令如何同时执行"><span class="nav-number">5.4.</span> <span class="nav-text">指令如何同时执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令执行失败后会怎么样；"><span class="nav-number">5.5.</span> <span class="nav-text">指令执行失败后会怎么样；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令被中断会怎么样"><span class="nav-number">5.6.</span> <span class="nav-text">指令被中断会怎么样</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归；指令中调用makefiles-通过make"><span class="nav-number">5.7.</span> <span class="nav-text">递归；指令中调用makefiles 通过make</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义指令集"><span class="nav-number">5.8.</span> <span class="nav-text">定义指令集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义有用的没，没做任何事的指令；"><span class="nav-number">5.9.</span> <span class="nav-text">定义有用的没，没做任何事的指令；</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何使用变量"><span class="nav-number">6.</span> <span class="nav-text">如何使用变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何使用变量的值"><span class="nav-number">6.1.</span> <span class="nav-text">如何使用变量的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两种赋值变量的方式："><span class="nav-number">6.2.</span> <span class="nav-text">两种赋值变量的方式： = /:=</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用一个变量的高级特性"><span class="nav-number">6.3.</span> <span class="nav-text">引用一个变量的高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#变量值的替换"><span class="nav-number">6.3.1.</span> <span class="nav-text">变量值的替换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#把变量的值再当成变量"><span class="nav-number">6.3.2.</span> <span class="nav-text">把变量的值再当成变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何在一个变量中基于旧值添加更多内容–追加"><span class="nav-number">6.4.</span> <span class="nav-text">如何在一个变量中基于旧值添加更多内容–追加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何在makefile中设置一个变量，即使之前已经被设置；"><span class="nav-number">6.5.</span> <span class="nav-text">如何在makefile中设置一个变量，即使之前已经被设置；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个设置多行字符串变量的可选方式"><span class="nav-number">6.6.</span> <span class="nav-text">一个设置多行字符串变量的可选方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何去定义一个变量，使它未被赋值"><span class="nav-number">6.7.</span> <span class="nav-text">如何去定义一个变量，使它未被赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#来自环境的变量值；"><span class="nav-number">6.8.</span> <span class="nav-text">来自环境的变量值；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量值可以在每个目标的基础上定义"><span class="nav-number">6.9.</span> <span class="nav-text">变量值可以在每个目标的基础上定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特定于目标的变量值可以应用于匹配模式的一组目标。"><span class="nav-number">6.10.</span> <span class="nav-text">特定于目标的变量值可以应用于匹配模式的一组目标。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抑制变量的继承"><span class="nav-number">6.11.</span> <span class="nav-text">抑制变量的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具有特殊意义或行为的变量。"><span class="nav-number">6.12.</span> <span class="nav-text">具有特殊意义或行为的变量。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何使用条件语句"><span class="nav-number">7.</span> <span class="nav-text">如何使用条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#条件例子"><span class="nav-number">7.1.</span> <span class="nav-text">条件例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件的语法"><span class="nav-number">7.2.</span> <span class="nav-text">条件的语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试标志"><span class="nav-number">7.3.</span> <span class="nav-text">测试标志</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何使用函数"><span class="nav-number">8.</span> <span class="nav-text">如何使用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数的语法，如何写一个函数调用"><span class="nav-number">8.1.</span> <span class="nav-text">函数的语法，如何写一个函数调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Functions-for-String-Substitution-and-Analysis-字符串操作函数列表"><span class="nav-number">8.2.</span> <span class="nav-text">Functions for String Substitution and Analysis  字符串操作函数列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何用函数操作文件名"><span class="nav-number">8.3.</span> <span class="nav-text">如何用函数操作文件名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现条件的函数"><span class="nav-number">8.4.</span> <span class="nav-text">实现条件的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#foreach函数"><span class="nav-number">8.5.</span> <span class="nav-text">foreach函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件相关函数：写文本到一个文件中"><span class="nav-number">8.6.</span> <span class="nav-text">文件相关函数：写文本到一个文件中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#call函数"><span class="nav-number">8.7.</span> <span class="nav-text">call函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#value函数"><span class="nav-number">8.8.</span> <span class="nav-text">value函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eval函数：Evaluate-the-arguments-as-makefile-syntax"><span class="nav-number">8.9.</span> <span class="nav-text">eval函数：Evaluate the arguments as makefile syntax</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#origin函数：寻找一个变量并拿它的值"><span class="nav-number">8.10.</span> <span class="nav-text">origin函数：寻找一个变量并拿它的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flavor函数"><span class="nav-number">8.11.</span> <span class="nav-text">flavor函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#控制make运行的函数"><span class="nav-number">8.12.</span> <span class="nav-text">控制make运行的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shelll函数"><span class="nav-number">8.13.</span> <span class="nav-text">shelll函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#guile函数"><span class="nav-number">8.14.</span> <span class="nav-text">guile函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何运行make"><span class="nav-number">9.</span> <span class="nav-text">如何运行make</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何具体化哪个makefile被使用"><span class="nav-number">9.1.</span> <span class="nav-text">如何具体化哪个makefile被使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Golas"><span class="nav-number">9.2.</span> <span class="nav-text">Golas</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#除了执行"><span class="nav-number">9.3.</span> <span class="nav-text">除了执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免重编译指定的文件"><span class="nav-number">9.4.</span> <span class="nav-text">避免重编译指定的文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#覆盖变量："><span class="nav-number">9.5.</span> <span class="nav-text">覆盖变量：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试标志-测试一个程序的编译"><span class="nav-number">9.6.</span> <span class="nav-text">测试标志,测试一个程序的编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选项总结；"><span class="nav-number">9.7.</span> <span class="nav-text">选项总结；</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何使用隐式规则"><span class="nav-number">10.</span> <span class="nav-text">如何使用隐式规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用隐式规则"><span class="nav-number">10.1.</span> <span class="nav-text">使用隐式规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内建规则清单"><span class="nav-number">10.2.</span> <span class="nav-text">内建规则清单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隐式规则中变量的使用："><span class="nav-number">10.3.</span> <span class="nav-text">隐式规则中变量的使用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隐式规则链："><span class="nav-number">10.4.</span> <span class="nav-text">隐式规则链：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何定义新的隐式规则"><span class="nav-number">10.5.</span> <span class="nav-text">如何定义新的隐式规则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#模式规则示例"><span class="nav-number">10.5.1.</span> <span class="nav-text">模式规则示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自动化变量"><span class="nav-number">10.5.2.</span> <span class="nav-text">自动化变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#模式的匹配"><span class="nav-number">10.5.3.</span> <span class="nav-text">模式的匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重载内建隐含规则"><span class="nav-number">10.5.4.</span> <span class="nav-text">重载内建隐含规则</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#老式风格的隐式规则"><span class="nav-number">10.6.</span> <span class="nav-text">老式风格的隐式规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隐式规则的搜索算法"><span class="nav-number">10.7.</span> <span class="nav-text">隐式规则的搜索算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用make更新archive文件"><span class="nav-number">11.</span> <span class="nav-text">使用make更新archive文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#archive-members"><span class="nav-number">11.1.</span> <span class="nav-text">archive members</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#archive后缀规则"><span class="nav-number">11.2.</span> <span class="nav-text">archive后缀规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#陷阱："><span class="nav-number">11.3.</span> <span class="nav-text">陷阱：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何扩展gnu-make-这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；"><span class="nav-number">12.</span> <span class="nav-text">如何扩展gnu make 这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Guile-Integration"><span class="nav-number">12.1.</span> <span class="nav-text">Guile Integration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Loading-Objects"><span class="nav-number">12.2.</span> <span class="nav-text">Loading Objects</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更多参考ref"><span class="nav-number">13.</span> <span class="nav-text">更多参考ref</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小兴"
      src="/images/headicon2.jpg">
  <p class="site-author-name" itemprop="name">小兴</p>
  <div class="site-description" itemprop="description">始于歧路，愿归于征途</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xdksx/" title="GitHub → https://github.com/xdksx/" rel="noopener" target="_blank"><i class="fa fa-fw fa-github-square"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/ksance@gmail.com" title="E-Mail → ksance@gmail.com"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/572897439" title="FB Page → https://www.facebook.com/572897439" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      friendly link
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://yoursite.com" title="http://yoursite.com" rel="noopener" target="_blank">Title</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小兴</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '06e6b70d396f6928e45a',
      clientSecret: 'cd03b7c657d50a5d76a7fa682c4f8eb48cb15fc3',
      repo        : 'xdksx.github.io',
      owner       : 'xdksx',
      admin       : ['xdksx'],
      id          : 'ff9f207bb9243b4c672769e94a67e4ff',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
