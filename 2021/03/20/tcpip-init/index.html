<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xdksx.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="linux内核网络子系统的初始化介绍基于linux4.8,版本其实现在已经是5.12了，但是因为我装的linux源码版本是4.8，为方便调试，都在这个版本分析，差别不会很大；以下的内核都指的这个linux4.8的内核；环境都在这个上的；">
<meta name="keywords" content="tcpip_init">
<meta property="og:type" content="article">
<meta property="og:title" content="tcpip_init">
<meta property="og:url" content="https://xdksx.github.io/2021/03/20/tcpip-init/index.html">
<meta property="og:site_name" content="追光者">
<meta property="og:description" content="linux内核网络子系统的初始化介绍基于linux4.8,版本其实现在已经是5.12了，但是因为我装的linux源码版本是4.8，为方便调试，都在这个版本分析，差别不会很大；以下的内核都指的这个linux4.8的内核；环境都在这个上的；">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-03-21T14:25:36.021Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tcpip_init">
<meta name="twitter:description" content="linux内核网络子系统的初始化介绍基于linux4.8,版本其实现在已经是5.12了，但是因为我装的linux源码版本是4.8，为方便调试，都在这个版本分析，差别不会很大；以下的内核都指的这个linux4.8的内核；环境都在这个上的；">

<link rel="canonical" href="https://xdksx.github.io/2021/03/20/tcpip-init/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>tcpip_init | 追光者</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">追光者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小兴的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-观影">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-阅读">

    <a href="/read/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-心理">

    <a href="/categories/心理/" rel="section"><i class="fa fa-fw fa-heart"></i>心理</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xdksx.github.io/2021/03/20/tcpip-init/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headicon2.jpg">
      <meta itemprop="name" content="小兴">
      <meta itemprop="description" content="始于歧路，愿归于征途">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="追光者">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          tcpip_init
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-21 07:11:45 / 修改时间：22:25:36" itemprop="dateCreated datePublished" datetime="2021-03-21T07:11:45+08:00">2021-03-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tcpip/" itemprop="url" rel="index"><span itemprop="name">tcpip</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="linux内核网络子系统的初始化介绍"><a href="#linux内核网络子系统的初始化介绍" class="headerlink" title="linux内核网络子系统的初始化介绍"></a>linux内核网络子系统的初始化介绍</h3><p>基于linux4.8,版本其实现在已经是5.12了，但是因为我装的linux源码版本是4.8，为方便调试，都在这个版本分析，差别不会很大；<br>以下的内核都指的这个linux4.8的内核；环境都在这个上的；<a id="more"></a><br>相关地址：<br>源码查阅：<a href="https://elixir.bootlin.com/linux/latest/source" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/latest/source</a></p>
<h4 id="linux内核网络子系统初始化组成"><a href="#linux内核网络子系统初始化组成" class="headerlink" title="linux内核网络子系统初始化组成"></a>linux内核网络子系统初始化组成</h4><ul>
<li>内核的初始化和各种init函数集合</li>
<li>网络文件系统等初始化：sock_init</li>
<li>协议栈及相关函数结构初始化：inet_init</li>
<li>设备相关初始化</li>
</ul>
<h4 id="内核的初始化过程整体和init函数集合"><a href="#内核的初始化过程整体和init函数集合" class="headerlink" title="内核的初始化过程整体和init函数集合"></a>内核的初始化过程整体和init函数集合</h4><p>内核的初始化，其实就是对应的启动linux的时候，各种数据结构，设备等等初始化的过程；更具体的涉及更多复杂细节，这里只展示关键部分；<br>内核启动时，会进入到head.S/head.c,这个和架构有关，每种linux支持的架构都会有对应的实现文件：<br>在源码查阅中可以看到：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/arch/alpha/kernel/head.S</span><br><span class="line">/arch/arm/kernel/head.S</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>在这些文件中，都能找到其调用start_kernel，这个函数就是用来启动内核；<br>arch/x86/kernel/head64.c, line 195为例：<br>可以看到调用启动内核的函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">start_kernel();</span><br><span class="line">进而找到：</span><br><span class="line">    init/main.c</span><br><span class="line">    简单分析start_kernel函数：截取其中的片段，可以看到其调用各种关键系统的初始化函数：</span><br><span class="line">    setup_log_buf(<span class="number">0</span>);</span><br><span class="line">	pidhash_init();</span><br><span class="line">	vfs_caches_init_early();</span><br><span class="line">	sort_main_extable();</span><br><span class="line">	trap_init();</span><br><span class="line">	mm_init();</span><br><span class="line">    ...</span><br><span class="line">    cred_init();</span><br><span class="line">	fork_init();</span><br><span class="line">	proc_caches_init();</span><br><span class="line">	buffer_init();</span><br><span class="line">	key_init();</span><br><span class="line">	security_init();</span><br><span class="line">	dbg_late_init();</span><br><span class="line">	vfs_caches_init(totalram_pages);</span><br><span class="line">	signals_init();</span><br><span class="line">    ...</span><br><span class="line">    rest_init();</span><br><span class="line">    从名字大概可以知道是初始化哪部分内容，这里每部分深入进去都是很长的内容，这里只去找网络相关的，看起来在rest_init部分了；</span><br><span class="line">    rest_init:</span><br><span class="line">    &#123;</span><br><span class="line">        .... <span class="comment">//可以看到转门新建了一个内核线程来初始化；</span></span><br><span class="line">        kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">	    numa_default_policy();</span><br><span class="line">	    pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">	    rcu_read_lock();</span><br><span class="line"></span><br><span class="line">        kernel_init</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化各种init函数</span></span><br><span class="line">            kernel_init_freeable();</span><br><span class="line">               -&gt;do_basic_setup</span><br><span class="line">                 -&gt;driver_init();</span><br><span class="line">                  --&gt;do_initcalls(); <span class="comment">//这里会通过依赖编译器的方式，寻找到内核中所有的_init 表识的函数，如sock_init,inet_init函数等</span></span><br><span class="line">                  ‘static int __init sock_init(void)’ </span><br><span class="line">                     从而能初始化各种init函数，这种机制，涉及到ld链接脚本，gcc编译器本身的机制，以及elf文件结构，内容较多，等有机会再具体写写</span><br><span class="line">                    这里截取一段：通过objdump vmlinux后看到的能找到的init函数</span><br><span class="line">                    ffffffff820a48e8 l     O .init.data	<span class="number">0000000000000008</span> __initcall_sock_init1 关键函数<span class="number">1</span></span><br><span class="line">                    ffffffff820a4e18 l     O .init.data	<span class="number">0000000000000008</span> __initcall_proto_init4</span><br><span class="line">                    ffffffff820a48f0 l     O .init.data	<span class="number">0000000000000008</span> __initcall_net_inuse_init1</span><br><span class="line">                    ffffffff820a4788 l     O .init.data	<span class="number">0000000000000008</span> __initcall_net_ns_init0</span><br><span class="line">                    ffffffff820a48f8 l     O .init.data	<span class="number">0000000000000008</span> __initcall_net_defaults_init1</span><br><span class="line">                    ffffffff820a4900 l     O .init.data	<span class="number">0000000000000008</span> __initcall_init_default_flow_dissectors1</span><br><span class="line">                    ffffffff820a5020 l     O .init.data	<span class="number">0000000000000008</span> __initcall_sysctl_core_init5</span><br><span class="line">                    ffffffff820a4e20 l     O .init.data	<span class="number">0000000000000008</span> __initcall_net_dev_init4 关键函数<span class="number">2</span></span><br><span class="line">                    ffffffff820a4e28 l     O .init.data	<span class="number">0000000000000008</span> __initcall_neigh_init4</span><br><span class="line">                    ffffffff820a5030 l     O .init.data	<span class="number">0000000000000008</span> __initcall_inet_init5 关键函数<span class="number">3</span></span><br><span class="line">            <span class="comment">//拉取init进程</span></span><br><span class="line">            <span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">		    ret = run_init_process(execute_command);</span><br><span class="line">		    <span class="keyword">if</span> (!ret)</span><br><span class="line">		    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		    panic(<span class="string">"Requested init %s failed (error %d)."</span>,</span><br><span class="line">		          execute_command, ret);</span><br><span class="line">	        &#125;</span><br><span class="line">	    <span class="keyword">if</span> (!try_to_run_init_process(<span class="string">"/sbin/init"</span>) ||</span><br><span class="line">	        !try_to_run_init_process(<span class="string">"/etc/init"</span>) ||</span><br><span class="line">	        !try_to_run_init_process(<span class="string">"/bin/init"</span>) ||</span><br><span class="line">	        !try_to_run_init_process(<span class="string">"/bin/sh"</span>))</span><br><span class="line">	    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="网络文件系统等初始化：sock-init"><a href="#网络文件系统等初始化：sock-init" class="headerlink" title="网络文件系统等初始化：sock_init"></a>网络文件系统等初始化：sock_init</h4><h5 id="代码流程分析"><a href="#代码流程分析" class="headerlink" title="代码流程分析"></a>代码流程分析</h5><h6 id="整体代码："><a href="#整体代码：" class="headerlink" title="整体代码："></a>整体代码：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">sock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *      Initialize the network sysctl infrastructure.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	err = net_sysctl_init();</span><br><span class="line">    <span class="comment">//初始化网络相关的/proc/sys/下的目录：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    /* Avoid limitations in the sysctl implementation by</span></span><br><span class="line"><span class="comment">	 * registering "/proc/sys/net" as an empty directory not in a</span></span><br><span class="line"><span class="comment">	 * network namespace.</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">	net_header = register_sysctl("net", empty);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//初始化网络空间相关操作等，网络空间用于docker时，每个docker容器之间的网络隔离，类似的还有文件系统隔离等带来的文件系统空间等等；</span></span><br><span class="line">    <span class="comment">//ret = register_pernet_subsys(&amp;sysctl_pernet_ops);</span></span><br><span class="line">    <span class="comment">//register_sysctl_root(&amp;net_sysctl_root);</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *      Initialize skbuff SLAB cache</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	skb_init();</span><br><span class="line">    <span class="comment">//其实就是调用了kmem_cache_create初始化了skbuff,方便之后直接用kmem_cache_alloc分配skbuff</span></span><br><span class="line">    <span class="comment">//关于kmem_cache_create使用：https://docs.oracle.com/cd/E36784_01/html/E36886/kmem-cache-alloc-9f.html</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *      Initialize the protocols module.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    </span><br><span class="line">	init_inodecache();</span><br><span class="line">    <span class="comment">//初始化：kmem_cache_create: socket_alloc:</span></span><br><span class="line">    <span class="comment">/*sock_inode_cachep = kmem_cache_create("sock_inode_cache",</span></span><br><span class="line"><span class="comment">					      sizeof(struct socket_alloc),</span></span><br><span class="line"><span class="comment">					      0,</span></span><br><span class="line"><span class="comment">					      (SLAB_HWCACHE_ALIGN |</span></span><br><span class="line"><span class="comment">					       SLAB_RECLAIM_ACCOUNT |</span></span><br><span class="line"><span class="comment">					       SLAB_MEM_SPREAD | SLAB_ACCOUNT),</span></span><br><span class="line"><span class="comment">					      init_once);</span></span><br><span class="line"><span class="comment">    可以看到这个结构体，是包含了 socket和inode:所有操作网络的接口fd可以通过write等文件系统的函数和socket的特定函数send等</span></span><br><span class="line"><span class="comment">    struct socket_alloc &#123;</span></span><br><span class="line"><span class="comment">	struct socket socket;</span></span><br><span class="line"><span class="comment">	struct inode vfs_inode;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	err = register_filesystem(&amp;sock_fs_type);<span class="comment">//注册socketfs网络文件系统</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_fs;</span><br><span class="line">	sock_mnt = kern_mount(&amp;sock_fs_type);<span class="comment">//挂载网络文件系统，主要调用了通用的接口：vfs_kern_mount(type, MS_KERNMOUNT, type-&gt;name, data);</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(sock_mnt)) &#123;</span><br><span class="line">		err = PTR_ERR(sock_mnt);</span><br><span class="line">		<span class="keyword">goto</span> out_mount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The real protocol initialization is performed in later initcalls.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NETFILTER</span></span><br><span class="line">	err = netfilter_init();<span class="comment">//若配置了netfilter，需要进一步初始化</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	ptp_classifier_init();</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">out_mount:</span><br><span class="line">	unregister_filesystem(&amp;sock_fs_type);</span><br><span class="line">out_fs:</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要真正理解上面的代码，需要了解：<br>1 内存管理相关的，理解kmem_cache高速缓存  –已独立文章分析<br>2 文件系统相关的，理解socketfs是什么存在，以及如何管理sockinode; –有独立文章分析文件系统，待分析socketfs<br>这里简单分析：socketfs是一种特殊的文件系统<br>特殊文件系统：通常是Linux为了方便计算机管理或者提供某些服务而编写。典型的有proc、tmpfs、pipefs、sockfs等。<br>所以sockfs就是为了套接字而设计的伪文件系统，在socket.c中  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">sock_fs_type</span> = &#123;</span></span><br><span class="line">         .name    =  <span class="string">"sockfs"</span>,</span><br><span class="line">         .mount   =  sockfs_mount,</span><br><span class="line">         .kill_sb =  kill_anon_super,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从平常对套接字的使用，如可以用协议栈相关函数connect,bind accept,还可以用read,write进行发送和接收等，很明显后者是读写文件的函数；<br>从这里可以看到socket套接字兼顾两种特性；  sockfs是一个文件系统，自然支持inode，同时socket本身的结构支持协议栈函数；  </p>
<p>使用socket函数创建socket时：<br>socket结构初始化：从alloc_inode -&gt;调用sock_alloc_inode:创建如下结构体：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_alloc</span> &#123;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> <span class="title">socket</span>;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到包含socket,和inode,同时socket结构包含file结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">        …</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">        …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>socket 成员面向的是协议栈，而 vfs_inode 成员面向的是文件系统，这体现了套接字的双重属性。struct file 则是将两者联系起来的枢纽，其面向的是进程。这样就把内核中的套接字，抽象成为一个简单的文件描述符，提供给用户空间使用。  </p>
<p>struct inode由于代表了文件系统中一个实际的文件在内存中的反映，已经不属于进程的范畴，所以 struct inode 不会有上面所谓的共享问题。但是 struct inode 只会在必要的时候创建，在允许的情况下销毁。  </p>
<p>3 sysctl相关的，如何 /proc/net/目录 </p>
<h5 id="数据结构图"><a href="#数据结构图" class="headerlink" title="数据结构图"></a>数据结构图</h5><p>这部分涉及到几个数据结构：<br>1 skbuff: kmem_cache_create后产生的两个头：skbuff_head_cache，skbuff_fclone_cache<br>为后面分配skbuff做准备；<br>2 sysctl:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">proc_sysctl.c</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table_root</span> <span class="title">sysctl_table_root</span> = &#123;</span></span><br><span class="line">	.default_set.dir.header = &#123;</span><br><span class="line">		&#123;&#123;.count = <span class="number">1</span>,</span><br><span class="line">		  .nreg = <span class="number">1</span>,</span><br><span class="line">		  .ctl_table = root_table &#125;&#125;,</span><br><span class="line">		.ctl_table_arg = root_table,</span><br><span class="line">		.root = &amp;sysctl_table_root,</span><br><span class="line">		.<span class="built_in">set</span> = &amp;sysctl_table_root.default_set,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>3 socketfs相关：<br>sock_fs_type</p>
<h4 id="协议栈及相关函数结构初始化：inet-init"><a href="#协议栈及相关函数结构初始化：inet-init" class="headerlink" title="协议栈及相关函数结构初始化：inet_init"></a>协议栈及相关函数结构初始化：inet_init</h4><p>用户层通过socket函数创建socket,会传入三个参数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">domain:</span><br><span class="line">指定协议簇，ipv4/ipv6..</span><br><span class="line">AF_INET      IPv4 Internet protocols </span><br><span class="line"></span><br><span class="line">type: </span><br><span class="line">指定udp/tcp</span><br><span class="line">SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based byte streams.  </span><br><span class="line">                An out-of-band data transmission mechanism may be supported.</span><br><span class="line">SOCK_DGRAM      Supports datagrams (connectionless, unreliable messages of a fixed maximum length).</span><br><span class="line"></span><br><span class="line">protocol:</span><br><span class="line">通常只存在一个协议来支持 给定协议族中的特定套接字类型，在这种情况下，protocol可以指定为<span class="number">0</span>。</span><br></pre></td></tr></table></figure></p>
<p>然后会返回一个fd来唯一标识这个socket，那内核如何根据传入的三个参数，来选择正确的匹配协议和传输协议类型的相关函数呢？<br>在收到包后，如何根据收到的包，找到匹配的协议相关函数呢？<br>在下面的inet_init初始化后，就搭建好了这个基本的协议栈函数；  </p>
<h5 id="代码结构分析"><a href="#代码结构分析" class="headerlink" title="代码结构分析"></a>代码结构分析</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">inet_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">r</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rc = -EINVAL;</span><br><span class="line"></span><br><span class="line">	sock_skb_cb_check_size(<span class="keyword">sizeof</span>(struct inet_skb_parm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将tcp_prot,udp_prot，注册到(添加到)prot_list链表中；</span></span><br><span class="line">    <span class="comment">//list_add(&amp;prot-&gt;node, &amp;proto_list); 将prot结构挂到链表上；</span></span><br><span class="line">	rc = proto_register(&amp;tcp_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	rc = proto_register(&amp;udp_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_tcp_proto;</span><br><span class="line"></span><br><span class="line">	rc = proto_register(&amp;raw_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_udp_proto;</span><br><span class="line"></span><br><span class="line">	rc = proto_register(&amp;ping_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_raw_proto;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Tell SOCKET that we are alive...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     </span><br><span class="line">	(<span class="keyword">void</span>)sock_register(&amp;inet_family_ops);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //将inet_family_ops注册到地址簇列表中</span></span><br><span class="line"><span class="comment">	(void)sock_register(&amp;inet_family_ops);</span></span><br><span class="line"><span class="comment">    rcu_assign_pointer(net_families[ops-&gt;family], ops); //其实就是把ops放到对应的表net_family中，这个是全局变量，下面会解释</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSCTL</span></span><br><span class="line">	ip_static_sysctl_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Add all the base protocols.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//下面填充 inet_protos[protocol]=struct net_protocol结构；</span></span><br><span class="line">	<span class="keyword">if</span> (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; <span class="number">0</span>)</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot add ICMP protocol\n"</span>, __func__);</span><br><span class="line">	<span class="keyword">if</span> (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; <span class="number">0</span>)</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot add UDP protocol\n"</span>, __func__);</span><br><span class="line">	<span class="keyword">if</span> (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; <span class="number">0</span>)</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot add TCP protocol\n"</span>, __func__);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IP_MULTICAST</span></span><br><span class="line">	<span class="keyword">if</span> (inet_add_protocol(&amp;igmp_protocol, IPPROTO_IGMP) &lt; <span class="number">0</span>)</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot add IGMP protocol\n"</span>, __func__);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//初始化和注册 inetsw[]</span></span><br><span class="line">	<span class="comment">/* Register the socket-side information for inet_create. */</span></span><br><span class="line">	<span class="keyword">for</span> (r = &amp;inetsw[<span class="number">0</span>]; r &lt; &amp;inetsw[SOCK_MAX]; ++r)</span><br><span class="line">		INIT_LIST_HEAD(r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</span><br><span class="line">		inet_register_protosw(q);</span><br><span class="line">    /# 这个函数展开看看,主要是将inetws_array中的元素添加到全局静态链表中inetsw，注意linux特殊的链表连接方式，是结构中的成员为一个结点；</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inet_register_protosw</span><span class="params">(struct inet_protosw *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">lh</span>;</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line">	    <span class="keyword">int</span> protocol = p-&gt;protocol;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">last_perm</span>;</span></span><br><span class="line">    </span><br><span class="line">	    spin_lock_bh(&amp;inetsw_lock);</span><br><span class="line">    </span><br><span class="line">	    <span class="keyword">if</span> (p-&gt;type &gt;= SOCK_MAX)</span><br><span class="line">	    	<span class="keyword">goto</span> out_illegal;</span><br><span class="line">    </span><br><span class="line">	    <span class="comment">/* If we are trying to override a permanent protocol, bail. */</span></span><br><span class="line">	    last_perm = &amp;inetsw[p-&gt;type];<span class="comment">//取出结构</span></span><br><span class="line">	    list_for_each(lh, &amp;inetsw[p-&gt;type]) &#123;</span><br><span class="line">	    	answer = list_entry(lh, struct inet_protosw, <span class="built_in">list</span>);</span><br><span class="line">	    	<span class="comment">/* Check only the non-wild match. */</span></span><br><span class="line">	    	<span class="keyword">if</span> ((INET_PROTOSW_PERMANENT &amp; answer-&gt;flags) == <span class="number">0</span>)</span><br><span class="line">	    		<span class="keyword">break</span>;</span><br><span class="line">	    	<span class="keyword">if</span> (protocol == answer-&gt;protocol)</span><br><span class="line">	    		<span class="keyword">goto</span> out_permanent;</span><br><span class="line">	    	last_perm = lh;</span><br><span class="line">	    &#125;</span><br><span class="line">    </span><br><span class="line">	    <span class="comment">/* Add the new entry after the last permanent entry if any, so that</span></span><br><span class="line"><span class="comment">	     * the new entry does not override a permanent entry when matched with</span></span><br><span class="line"><span class="comment">	     * a wild-card protocol. But it is allowed to override any existing</span></span><br><span class="line"><span class="comment">	     * non-permanent entry.  This means that when we remove this entry, the</span></span><br><span class="line"><span class="comment">	     * system automatically returns to the old behavior.</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    list_add_rcu(&amp;p-&gt;<span class="built_in">list</span>, last_perm);<span class="comment">//将p-&gt;list加到取出的结构中</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    #/</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Set the ARP module up</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//初始化arp和arp_packet_type注册：dev_add_pack(&amp;arp_packet_type);</span></span><br><span class="line">	arp_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Set the IP module up</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//ip路由表初始化</span></span><br><span class="line">	ip_init();</span><br><span class="line">    <span class="comment">//tcp hashinfo相关初始化</span></span><br><span class="line">	tcp_v4_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup TCP slab cache for open requests. */</span></span><br><span class="line">	tcp_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup UDP memory threshold */</span></span><br><span class="line">	udp_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add UDP-Lite (RFC 3828) */</span></span><br><span class="line">	udplite4_register();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ping_table相关初始化</span></span><br><span class="line">	ping_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Set the ICMP layer up</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (icmp_init() &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"Failed to create the ICMP control socket.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Initialise the multicast router</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IP_MROUTE)</span></span><br><span class="line">	<span class="keyword">if</span> (ip_mr_init())</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot init ipv4 mroute\n"</span>, __func__);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (init_inet_pernet_ops())</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot init ipv4 inet pernet ops\n"</span>, __func__);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Initialise per-cpu ipv4 mibs</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (init_ipv4_mibs())</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot init ipv4 mibs\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">	ipv4_proc_init();</span><br><span class="line"></span><br><span class="line">	ipfrag_init();</span><br><span class="line">    <span class="comment">//注册ip_packet_type</span></span><br><span class="line">	dev_add_pack(&amp;ip_packet_type);</span><br><span class="line"></span><br><span class="line">	rc = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">out_unregister_raw_proto:</span><br><span class="line">	proto_unregister(&amp;raw_prot);</span><br><span class="line">out_unregister_udp_proto:</span><br><span class="line">	proto_unregister(&amp;udp_prot);</span><br><span class="line">out_unregister_tcp_proto:</span><br><span class="line">	proto_unregister(&amp;tcp_prot);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数据结构图-1"><a href="#数据结构图-1" class="headerlink" title="数据结构图"></a>数据结构图</h5><p>int socket(int domain, int type, int protocol);//先放着参考 协议簇，协议类型，协议号<br>上述涉及几个结构，从发送和接收的方向来解释：<br>发送方向：</p>
<ul>
<li>net_families[]:<br>net_families[PF_INET]=inet_family_ops 上面主要初始化了这个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> = &#123;</span></span><br><span class="line">	.family = PF_INET,</span><br><span class="line">	.create = inet_create,</span><br><span class="line">	.owner	= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  但是其实还有如：<br>  /<em> Protocol families, same as address families. </em>/</p>
<pre><code>#define PF_UNSPEC    AF_UNSPEC
#define PF_UNIX        AF_UNIX
#define PF_LOCAL    AF_LOCAL
#define PF_INET        AF_INET
#define PF_AX25        AF_AX25
#define PF_IPX        AF_IPX
int socket(int domain, int type, int protocol);
...
还有这些协议簇，其实对应了上面socket函数传入的参数1；
当我们调用socket创建socket套接字时：
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __sock_create(struct net *net, <span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol,</span><br><span class="line">struct socket **res, <span class="keyword">int</span> kern)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line">     ...</span><br><span class="line">     pf = rcu_dereference(net_families[family]);<span class="comment">//通过传入的第一个参数找到对应的ops</span></span><br><span class="line">     err = pf-&gt;create(net, sock, protocol, kern);<span class="comment">//调用ops的create函数来创建socket</span></span><br><span class="line">     进而调用到套接口层的create函数创建套接口；</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>inetsw，inetsw_array:<br>定义：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">inetsw</span>[<span class="title">SOCK_MAX</span>];</span></span><br><span class="line"><span class="comment">/* This is used to register socket interfaces for IP protocols.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* These two fields form the lookup key.  */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>	 type;	   <span class="comment">/* This is the 2nd argument to socket(2). */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>	 protocol; <span class="comment">/* This is the L4 protocol number.  */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto</span>	 *<span class="title">prot</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	 flags;      <span class="comment">/* See INET_PROTOSW_* below.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>后者初始化了一个静态的写死的表：<br>af_inet.c:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Upon startup we insert all the elements in inetsw_array[] into</span></span><br><span class="line"><span class="comment"> * the linked list inetsw.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	&#123;</span><br><span class="line">		.type =       SOCK_STREAM,</span><br><span class="line">		.protocol =   IPPROTO_TCP,</span><br><span class="line">		.prot =       &amp;tcp_prot,</span><br><span class="line">		.ops =        &amp;inet_stream_ops,</span><br><span class="line">		.flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">			      INET_PROTOSW_ICSK,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.type =       SOCK_DGRAM,</span><br><span class="line">		.protocol =   IPPROTO_UDP,</span><br><span class="line">		.prot =       &amp;udp_prot,</span><br><span class="line">		.ops =        &amp;inet_dgram_ops,</span><br><span class="line">		.flags =      INET_PROTOSW_PERMANENT,</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">		.type =       SOCK_DGRAM,</span><br><span class="line">		.protocol =   IPPROTO_ICMP,</span><br><span class="line">		.prot =       &amp;ping_prot,</span><br><span class="line">		.ops =        &amp;inet_dgram_ops,</span><br><span class="line">		.flags =      INET_PROTOSW_REUSE,</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">	       .type =       SOCK_RAW,</span><br><span class="line">	       .protocol =   IPPROTO_IP,	<span class="comment">/* wild card */</span></span><br><span class="line">	       .prot =       &amp;raw_prot,</span><br><span class="line">	       .ops =        &amp;inet_sockraw_ops,</span><br><span class="line">	       .flags =      INET_PROTOSW_REUSE,</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line">以udp为例：</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">inet_dgram_ops</span> = &#123;</span></span><br><span class="line">	.family		   = PF_INET,</span><br><span class="line">	.owner		   = THIS_MODULE,</span><br><span class="line">	.release	   = inet_release,</span><br><span class="line">	.bind		   = inet_bind,</span><br><span class="line">	.connect	   = inet_dgram_connect,</span><br><span class="line">	.socketpair	   = sock_no_socketpair,</span><br><span class="line">	.accept		   = sock_no_accept,</span><br><span class="line">	.getname	   = inet_getname,</span><br><span class="line">	.poll		   = udp_poll,</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">struct proto udp_prot = &#123;</span><br><span class="line">	.name		   = <span class="string">"UDP"</span>,</span><br><span class="line">	.owner		   = THIS_MODULE,</span><br><span class="line">	.close		   = udp_lib_close,</span><br><span class="line">	.connect	   = ip4_datagram_connect,</span><br><span class="line">	.disconnect	   = udp_disconnect,</span><br><span class="line">	.ioctl		   = udp_ioctl,</span><br><span class="line">	.destroy	   = udp_destroy_sock,</span><br><span class="line">	.setsockopt	   = udp_setsockopt,</span><br><span class="line">	.getsockopt	   = udp_getsockopt,</span><br><span class="line">	.sendmsg	   = udp_sendmsg,</span><br><span class="line">	.recvmsg	   = udp_recvmsg,</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结构的作用，是对传入的参数2： type 协议类型进行函数匹配：<br>继续上面的，调用到create，其实是：inet_create函数；<br>这个函数会创建sock结构，并将从 inetsw_array匹配到的 SOCK_DGRAM/SOCK_STREAM/..对应的ops，进行赋值等；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_create</span><span class="params">(struct net *net, struct socket *sock, <span class="keyword">int</span> protocol,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">int</span> kern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">answer_prot</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> answer_flags;</span><br><span class="line">    ...</span><br><span class="line">    list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</span><br><span class="line"></span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* Check the non-wild match. */</span></span><br><span class="line">		<span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line">			<span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Check for the two wild cases. */</span></span><br><span class="line">			<span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">				protocol = answer-&gt;protocol;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		err = -EPROTONOSUPPORT;</span><br><span class="line">	&#125;</span><br><span class="line">    sock-&gt;ops = answer-&gt;ops;<span class="comment">//关键步骤，所以之后的函数，可以通过ops找到</span></span><br><span class="line">	answer_prot = answer-&gt;prot;<span class="comment">//关键步骤，所以之后的函数，可以通过prot找到</span></span><br><span class="line">	answer_flags = answer-&gt;flags;</span><br><span class="line">    sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot);</span><br></pre></td></tr></table></figure></p>
<p>接收方向：</p>
<ul>
<li>ptype_base,ptype_all,arp_packet_type,ip_packet_type<br>在接收到skbuff后确定是哪种三层包，ip还是arp;,从而找到对应的接收函数；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> <span class="title">arp_packet_type</span> __<span class="title">read_mostly</span> = &#123;</span></span><br><span class="line">	.type =	cpu_to_be16(ETH_P_ARP),</span><br><span class="line">	.func =	arp_rcv,</span><br><span class="line">&#125;;</span><br><span class="line">dev_add_pack(&amp;ip_packet_type);</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> <span class="title">ip_packet_type</span> __<span class="title">read_mostly</span> = &#123;</span></span><br><span class="line">	.type = cpu_to_be16(ETH_P_IP),</span><br><span class="line">	.func = ip_rcv,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>主要是：全局变量：<br>static struct list_head ptype_base[16];    /<em> 16 way hashed list </em>/  dev.c<br>是以下十六个三层协议的列表，每种协议都由，packet_type数据结构表示，列表中的每个元素指向这个结构，<br>形成一个hash表，在dev_add_pack函数时添加到列表中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *		0800	IP</span></span><br><span class="line"><span class="comment"> *		8100    802.1Q VLAN</span></span><br><span class="line"><span class="comment"> *		0001	802.3</span></span><br><span class="line"><span class="comment"> *		0002	AX.25</span></span><br><span class="line"><span class="comment"> *		0004	802.2</span></span><br><span class="line"><span class="comment"> *		8035	RARP</span></span><br><span class="line"><span class="comment"> *		0005	SNAP</span></span><br><span class="line"><span class="comment"> *		0805	X.25</span></span><br><span class="line"><span class="comment"> *		0806	ARP</span></span><br><span class="line"><span class="comment"> *		8137	IPX</span></span><br><span class="line"><span class="comment"> *		0009	Localtalk</span></span><br><span class="line"><span class="comment"> *		86DD	IPv6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">而  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptype_all</span>;</span>		<span class="comment">/* Taps */</span> 对应了ETH_P_ALL</span><br><span class="line">在skbuff向上传递时；</span><br><span class="line">dev.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __netif_receive_skb_core(struct sk_buff *skb, <span class="keyword">bool</span> pfmemalloc)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">type = skb-&gt;protocol;</span><br><span class="line"><span class="comment">/* deliver only exact match when indicated */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!deliver_exact)) &#123;</span><br><span class="line">		deliver_ptype_list_skb(skb, &amp;pt_prev, orig_dev, type,</span><br><span class="line">				       &amp;ptype_base[ntohs(type) &amp;</span><br><span class="line">						   PTYPE_HASH_MASK]);</span><br><span class="line">....</span><br><span class="line">基于此能传递到正确的三层处理函数；</span><br></pre></td></tr></table></figure></p>
<ul>
<li>inet_protos<br>extern const struct net_protocol __rcu *inet_protos[MAX_INET_PROTOS];<br>inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) //通过类似函数添加；<br>inet_protos[IPPROTO_UDP]=udp_protocol<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> <span class="title">udp_protocol</span> = &#123;</span></span><br><span class="line">	.early_demux =	udp_v4_early_demux,</span><br><span class="line">	.handler =	udp_rcv,</span><br><span class="line">	.err_handler =	udp_err,</span><br><span class="line">	.no_policy =	<span class="number">1</span>,</span><br><span class="line">	.netns_ok =	<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>进而能找到对应的四层函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ip_local_deliver_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__skb_pull(skb, skb_network_header_len(skb));</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> protocol = ip_hdr(skb)-&gt;protocol;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> *<span class="title">ipprot</span>;</span></span><br><span class="line">		<span class="keyword">int</span> raw;</span><br><span class="line"></span><br><span class="line">	resubmit:</span><br><span class="line">		raw = raw_local_deliver(skb, protocol);</span><br><span class="line"></span><br><span class="line">		ipprot = rcu_dereference(inet_protos[protocol]);<span class="comment">//这里去找；</span></span><br><span class="line">		<span class="keyword">if</span> (ipprot) &#123;</span><br></pre></td></tr></table></figure></p>
<p>其他：</p>
<ul>
<li>prot_list:<br>这个结构原先以为会也是类似net_family的作用，但是查了下引用的位置，这个全局的静态链表，inet域支持的所有协议全部在这个链表中，它只是用于在/proc/net/protocols文件中输出当前系统所支持的所有协议。没有其他功能；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sock.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">下面是proc相关的函数；</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">proto_seq_start</span><span class="params">(struct seq_file *seq, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function">	__<span class="title">acquires</span><span class="params">(proto_list_mutex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mutex_lock(&amp;proto_list_mutex);</span><br><span class="line">	<span class="keyword">return</span> seq_list_start_head(&amp;proto_list, *pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">proto_seq_next</span><span class="params">(struct seq_file *seq, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> seq_list_next(v, &amp;proto_list, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一个问题抛出来：<br>接收方向skbuff如何准确传递到正确的socket进而传递数据给对应的用户？<br>关于路由表相关和具体协议相关的结构，等到时候再分析；</p>
<h4 id="设备相关初始化"><a href="#设备相关初始化" class="headerlink" title="设备相关初始化"></a>设备相关初始化</h4><p>设备相关的初始化，是比较复杂的内容，linux很大一部分代码就是各种设备驱动程序代码；在2.6后，采用了通用设备模型来管理设备；<br>网络设备时比较特殊的设备之一；<br>涉及以下几个方面：<br>1 网络设备的表示，一个网络设备通过net_device结构实例来表示，内核通过net_device管理和控制，连接到实际网络设备驱动程序，进而控制设备；<br>2 网络设备的驱动程序；网络设备多种多样，有wifi网卡，有线网卡等，而且跟具体芯片型号等有关，不同种类的设备驱动程序不同；而发送和接收都需要通过驱动程序<br>  处理，并进而交互到设备的固件firmware，从而发送和接收；网络设备驱动程序本质上就是分配和初始化net_device的过程，并提供了各种操作设备的函数；<br>3 网络设备初始化的基本过程：<br>  （1）注册：一个网络设备可用，就必须被内核认可，并且关联正确的驱动程序；驱动程序把驱动设备所需要的所有信息存储在私有数据结构中，然后与其他需要此设备的内核组件交互；<br>  （2）网络设备驱动程序如何分配 设备与内核通信的资源<br>  网络设备驱动程序如何分配 建立设备/内核通信所需要的资源：<br>    即主要是包括：<br>    1) IRQ线初始化，虚拟设备不需要<br>        网络设备NIC必须被分配一个IRQ:然后再必要时如rx,提醒内核； –涉及请求和释放irq线，从/proc/interrupts文件可知当前分配状态；<br>    2)IO端口和内存注册：设备程序将其设备的一个内存区域如其配置寄存器映射到系统内存，这样驱动程序的读写可以通过系统内存进行；<br>        映射函数：request_region,release_region<br>    3)关键知识：<br>      内核和设备之间的交互：<br>      中断或轮询<br>硬件中断：<br>       每一个中断都会运行一个中断处理程序，这些中断响应程序都是设备驱动为设备量身定做的。一般而言，当设备注册一个NIC时，它首先会请求并分配一个IRQ，然后要为IRQ注册（如果设备被卸载了，则需要注销）一个IRQ响应程序。相应的内核代码在kernel/irq/manage.c和arch/XXX/kernel/irq.c。（其中XXX为处理器架构）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_threaded_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler,                                            </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">irq_handler_t</span> thread_fn, <span class="keyword">unsigned</span> <span class="keyword">long</span> irqflags,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line">    注意：irq的注册和释放函数都带有参数dev_id。因为IRQ是可以共享的，因此需要IRQ number和dev_id共同来唯一表示中断。</span><br><span class="line">    另，在注册IRQ时，必须保证IRQ还未有设备请求，除非所有设备都支持IRQ共享。</span><br><span class="line">    内核接收到一个中断信号时，会通过IRQ number调用关联的中断响应程序。IRQ number与中断响应程序以表的形式保存。由于多个设备可能共享IRQ的关系，IRQ number与中断响应程序的关系可能是一对多的。</span><br><span class="line">    中断类型：接收到数据帧、帧传输失败、DMA传输已成功完成、设备已经有足够内存来创建新的传输会话（可用NIC可用内存达到一定数值&lt;一般为设备MTU&gt;时产生一个中断）</span><br><span class="line">    为了防止内核在设备内存不足时多次提交传输请求，设备驱动可以关闭内核出口队列，待到资源足够是才重启。下面是一个范例：</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">netdev_tx_t</span></span><br><span class="line">el3_start_xmit(struct sk_buff *skb, struct net_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    netif_stop_queue (dev);</span><br><span class="line">    ……</span><br><span class="line">    dev-&gt;trans_start = jiffies;</span><br><span class="line">    <span class="keyword">if</span> (inw(ioaddr + TX_FREE) &gt; <span class="number">1536</span>)</span><br><span class="line">        netif_start_queue(dev);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* Interrupt us when the FIFO has room for max-sized packet. */</span></span><br><span class="line">        outw(SetTxThreshold + <span class="number">1536</span>, ioaddr + EL3_CMD);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"> IRQ共享：IRQ线是很有限的资源，为了让一个系统能支持更多的设备，只能让多个设备共享IRQ线。IRQ共享的机制是这样的，内核收到中断请求，然后调用所有与该中断相关联的响应例程，然后有各个响应例程自行判断过滤是否对这个中断进行处理。（注意，IRQ与响应程序是一对多的，发生一个IRQ，哪些响应程序要处理，哪些不需要不是有内核去判断，而是各个中断响应程序自己判断，内核则是调用所有的响应程序。）</span><br><span class="line">IRQ与IRQ响应程序的组织：用全局的<span class="built_in">vector</span>：irq_desc来组织，irq_desc包含所有IRQ，每个IRQ对应自己的链表，链表中是该IRQ关联的所有响应程序。只有IRQ共享时，IRQ链表的节点才会超过一个。</span><br></pre></td></tr></table></figure></p>
<p>  （3）网络设备结构net_device的分配和初始化<br>      module_init和probe<br>     注册和初始化任务的一部分由内核负责（module_init)，其他部分则由设备驱动程序负责(pci扫描到的具体的probe函数)；<br>     部分由内核完成，部分由驱动程序完成（决定如何分配建立设备/内核通信所需资源：irq,IO端口）<br>           1) 通过一组函数指针和驱动设备函数交互<br>           2) 这个结构的初始化部分由内核完成，部分由设备驱动函数完成</p>
<p>4 网络设备相关的初始化相关重要函数：<br>  (1)subsys_init(net_dev_init) 对应抽象设备层(核心模块)<br>  下面的(2)(3)对应特定设备驱动程序<br>  (2)device_init(module_init)<br>  (3)pci_scan(probe) 真正的和真实设备挂钩的初始化，设备模型 kobject pci，这样管理所有设备，并调用xxx_probe–&gt;xxx_setup初始化net_device或其他设备实例；  </p>
<p>  关于抽象设备层解释：<br>  这一层主要提供一些设备无关的处理流程，也提供一些公用的函数给底层的 device driver 调用。<br>它为网络协议提供统一的发送、接收接口。这主要是通过 net_device 结构。是上层的、与设备无关的，<br>这部分根据输入输出请求，通过特定设备驱动程序接口，来与设备进行通信。<br>subsys_initcall(net_dev_init);<br>这个宏定义请参见前面说的 init.h，它被定义为： define_initcall(“4”,fn)<br>所以它是在 core_initcall 和 fs_initcall 之后被调用的。 </p>
<p>  关于特定设备驱动程序解释：<br> 是一种下层的、与设备有关的，常称为设备驱动程序，它直接与相应设备打<br>交道，并且向上层提供一组访问接口； 当一个网络设备的初始化程序被调用时，它返回一个状态指<br>示它所驱动的控制器是否有一个实例。<br>主要包括module_init和probe函数，即最终都是对net_deivce结构的初始化  </p>
<h5 id="代码结构分析-net-dev-init"><a href="#代码结构分析-net-dev-init" class="headerlink" title="代码结构分析 -net_dev_init"></a>代码结构分析 -net_dev_init</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *       This is called single threaded during boot, so no need</span></span><br><span class="line"><span class="comment"> *       to take the rtnl semaphore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">net_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, rc = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!dev_boot_phase);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev_proc_init())<span class="comment">//在/proc/net目录下创建四个proc条目（分别为dev、softnet_stat、ptype和wireless） </span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (netdev_kobject_init())<span class="comment">//暂时不太清除</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;ptype_all);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PTYPE_HASH_SIZE; i++)</span><br><span class="line">		INIT_LIST_HEAD(&amp;ptype_base[i]);<span class="comment">//前面有提到，不赘述</span></span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;offload_base);()</span><br><span class="line">	<span class="keyword">if</span> (register_pernet_subsys(&amp;netdev_net_ops))<span class="comment">//将全局变量netdev_net_ops注册到链表(static struct list_head *first_device = &amp;pernet_list;)上</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Initialise the packet receive queues.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//对于多CPU的系统来说，每个CPU都有一个各自的接收队列，并且使用各自的softnet_data结构体变量*sd来管理网络数据包的收发流量（通过per_cpu函数）。</span></span><br><span class="line">	<span class="comment">//初始化两个sk_buff_head结构体变量process_queue和input_pkt_queue。</span></span><br><span class="line">    for_each_possible_cpu(i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> = &amp;<span class="title">per_cpu</span>(<span class="title">softnet_data</span>, <span class="title">i</span>);</span></span><br><span class="line"></span><br><span class="line">		skb_queue_head_init(&amp;sd-&gt;input_pkt_queue);</span><br><span class="line">		skb_queue_head_init(&amp;sd-&gt;process_queue);</span><br><span class="line">		INIT_LIST_HEAD(&amp;sd-&gt;poll_list);</span><br><span class="line">		sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line">		sd-&gt;csd.func = rps_trigger_softirq;</span><br><span class="line">		sd-&gt;csd.info = sd;</span><br><span class="line">		sd-&gt;cpu = i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		sd-&gt;backlog.poll = process_backlog;</span><br><span class="line">		sd-&gt;backlog.weight = weight_p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev_boot_phase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The loopback device is special if any other network devices</span></span><br><span class="line"><span class="comment">	 * is present in a network namespace the loopback device must</span></span><br><span class="line"><span class="comment">	 * be present. Since we now dynamically allocate and free the</span></span><br><span class="line"><span class="comment">	 * loopback device ensure this invariant is maintained by</span></span><br><span class="line"><span class="comment">	 * keeping the loopback device as the first device on the</span></span><br><span class="line"><span class="comment">	 * list of network devices.  Ensuring the loopback devices</span></span><br><span class="line"><span class="comment">	 * is the first device that appears and the last network device</span></span><br><span class="line"><span class="comment">	 * that disappears.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">//注册网络命令空间设备，确保loopback设备在所有网络设备中最先出现和最后消失</span></span><br><span class="line">	<span class="keyword">if</span> (register_pernet_device(&amp;loopback_net_ops))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (register_pernet_device(&amp;default_device_ops))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">//分别注册网络设备数据包接收和发送的软中断处理程序 </span></span><br><span class="line">	open_softirq(NET_TX_SOFTIRQ, net_tx_action);</span><br><span class="line">	open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br><span class="line">    <span class="comment">//注册回调处理函数dev_cpu_callback </span></span><br><span class="line">	hotcpu_notifier(dev_cpu_callback, <span class="number">0</span>);</span><br><span class="line">	dst_init();<span class="comment">//和通知链相关的初始化</span></span><br><span class="line">	rc = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先备知识：<br>1) 中断相关，软中断和硬中断<br>2) 通知链相关<br>3) 设备模型<br>4) softnet_data相关，这里先不解释；<br>5) other:用户空间辅助程序：<br>    /sbin/modprobe 在内核需要加载某个模块时调用，判断内核传递的模块是不是/etc/modprobe.conf文件中定义的别名<br>    /sbin/hotplug 在内核检测到一个新设备插入或拔出系统时调用，它的任务是根据设备标识加载正确的驱动  </p>
<h5 id="代码结构分析-module-init"><a href="#代码结构分析-module-init" class="headerlink" title="代码结构分析 -module_init:"></a>代码结构分析 -module_init:</h5><p>module_init是一大类的函数，几乎所有的设备都有实现这个函数：xxx_init_module为module_init类型；<br>凡是被 module_init()“修饰”过的函数只能在两种 情况下被调用：一种是被 do_initcalls 调用，一种是<br>在模块插入到系统中时被调用（如果它是模块方式）。每个模块只有一个被 module_init 修饰的函数入口<br>eg: 78. #define module_init(x) __initcall(x);<br>对第一种情况：<br>开机流程初始化有init_call机制，会做几乎所有的init,会包含一个初始化所有设备的module_init,自然就包括了net_device在module_init中的初始化；<br>eg:对回环设备：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">think@think-VirtualBox:~/source_linux/linux-lts-xenial<span class="number">-4.4</span><span class="number">.0</span>$ objdump  -t vmlinux| grep loopback</span><br><span class="line"><span class="number">0000000000000000</span> l    df *ABS*	<span class="number">0000000000000000</span> loopback.c</span><br><span class="line">ffffffff815ec3a0 l     F .text	<span class="number">00000000000000</span>a8 loopback_setup</span><br><span class="line">ffffffff81aa91c0 l     O .rodata	<span class="number">0000000000000198</span> loopback_ethtool_ops</span><br><span class="line">ffffffff81aa8f80 l     O .rodata	<span class="number">0000000000000238</span> loopback_ops</span><br><span class="line">ffffffff815ec450 l     F .text	<span class="number">0000000000000036</span> loopback_dev_free</span><br><span class="line">ffffffff815ec490 l     F .text	<span class="number">0000000000000081</span> loopback_get_stats64</span><br><span class="line">ffffffff815ec520 l     F .text	<span class="number">000000000000009</span>e loopback_xmit</span><br><span class="line">ffffffff815ec5c0 l     F .text	<span class="number">000000000000007</span>d loopback_dev_init</span><br><span class="line">ffffffff815ec640 l     F .text	<span class="number">000000000000009</span>d loopback_net_init <span class="comment">//这个函数</span></span><br></pre></td></tr></table></figure></p>
<p>module_init只是对设备结构等做一个基本的初始化，这个时候还不能使用；或者说linux支持很多种设备，在开机初始化时做的module_init只是一个对支持的设备的初始化，对这个机器是否插入这个硬件设备不依赖，也不代表就可以用了；而要等到pci扫描设备后，对真正存在的设备调用对应的probe函数，读取和初始化真正设备，之后才能使用；<br>具体过程如下：</p>
<h5 id="代码结构分析-module-init-1"><a href="#代码结构分析-module-init-1" class="headerlink" title="代码结构分析 -module_init:"></a>代码结构分析 -module_init:</h5><ul>
<li>pci子系统的基本介绍：<br>内核中的PCI子系统（PCI层）提供各种PCI设备驱动程序共同的所有通用功能；PCI电源管理和网络唤醒<br>1、几个数据结构：/include/linux/mod_devicetable.h<br>A:pci_device_id 设备标示符；<br>B:pci_dev 每个pci上的设备都会分配一个pci_dev实例，如同网络设备会被分配net_device一样，这个结构由内核使用，以引用一个PCi设备；<br>C:pci_driver:定义pci层和设备驱动程序之间的接口；由函数指针构成， 所有pci上的设备都会使用这个结构；<br>D:char <em>name:驱动程序名称；总线上的；<br>E:const struct pci_deivce_id </em>id_table:Id向量，内核用于把一些设备关联到此驱动程序；<br>F:int (<em>probe)当pci层发现他正在搜寻驱动程序设备id和前面的id_table匹配，就会调用此函数。来做类似开启硬件，分配net_deivce结构，初始化并注册新设备；<br> void (</em>remove)和上面相反；<br>G: suspend resume函数和电源管理有关；  </li>
</ul>
<p>2、PCI NIC 设备驱动程序的注册；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_device_id</span> &#123;</span></span><br><span class="line">	__u32 vendor, device;		<span class="comment">/* Vendor and device ID or PCI_ANY_ID*/</span></span><br><span class="line">	__u32 subvendor, subdevice;	<span class="comment">/* Subsystem ID's or PCI_ANY_ID */</span></span><br><span class="line">	__u32 <span class="class"><span class="keyword">class</span>, <span class="title">class_mask</span>;</span>	<span class="comment">/* (class,subclass,prog-if) triplet */</span></span><br><span class="line">	<span class="keyword">kernel_ulong_t</span> driver_data;	<span class="comment">/* Data private to the driver */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>用于独一无二识别pci设备；<br> 每个设备驱动程序都会把一个pci_device_id实例的向量注册到内核；这个实例向量列出了其所能处理的设备ID<br>3、pci设备本身的注册等；<br>4、pci的探测分静态和动态  </p>
<ul>
<li>pci总线系统在开机引导期间：<br>例如linux现在支持PCI域，每个PCI域可以占用多大256个总线，每个总线占用32个设备；<br>1) 系统引导时会建立一种数据库，把每个总线都关联到一份已侦测到而使用该总线的设备列表；如一个总线上挂了多个设备；<br>2)总线上的设备如何注册<br> 当设备驱动程序A（对应总线上的设备A）被加载时，会调用pci_register_driver并提供pci_driver实例而与pci层注册。<br> pci_driver结构中内含一个此驱动程序能驱动的pci设备id的向量（ *id_table),。<br> 接着，pci层使用这个表去查看已侦测到的pci上设备列表中与哪些设备匹配；于是就会建立该驱动程序的设备列表；<br> 接着，对每个匹配的设备，pci层会调用相匹配的驱动程序中的pci_driver结构中提供的probe函数；<br>接着，probe函数会建立并注册相关联的网络设备；接着调用到xx_setup函数；<br>3) 总线上设备除名：<br>当驱动程序稍后卸载时，该模块的module_exit函数会调用pci_unregister_driver，接着由于其数据库，使得pci能遍历所有与该驱动程序相关联的设备；并<br> 启动该设备的remove函数；从网络设备除名；  </li>
</ul>
<h5 id="几个问题："><a href="#几个问题：" class="headerlink" title="几个问题："></a>几个问题：</h5><p>0、module_init和probe函数中都会对net_device结果做更新和初始化，他们怎么调用的？<br>   开机流程初始化有init_call机制，会做几乎所有的init,会包含一个初始化所有设备的module_init,自然就包括了net_device在module_init中的初始化；<br>而开机会做pci扫描，这个时候配置好设备后，会调用对应的probe,过程太过复杂，待研究，只学习较理论方面，见 linux设备模型中的设备驱动模型例子_PCI总线为例，通过扫描pci，接着注册后会调用到各个pci设备的probe函数，进而也调用到了网络设备的probe函数  </p>
<p>1、module_init修饰的函数什么时候调用？<br>凡是被 module_init()“修饰”过的函数只能在两种 情况下被调用：一种是被 do_initcalls 调用，一种是<br>在模块插入到系统中时被调用（如果它是模块方式）。每个模块只有一个被 module_init 修饰的函数入口</p>
<ol start="78">
<li>#define module_init(x) __initcall(x);  </li>
</ol>
<p>所以真正的初始化是 probe函数调用时；  </p>
<h5 id="数据结构图-2"><a href="#数据结构图-2" class="headerlink" title="数据结构图"></a>数据结构图</h5><p>略<br>net_device结构介绍：ref 深入理解linux网络内幕<br>1、介绍：<br>net_device数据结构存储着特定网络设备的所有信息，每个网络设备对应一个net_device结构实例，无论是真实设备(如NIC)或者是虚拟设备(Bonding或VLAN)，并由驱动程序调用相关内核函数进行分配和注册，内核做一些初始化；<br>驱动程序，对这个设备的ops函数做初始化，并定义了相关函数赋值，这样内核通过统一的函数接口就可以掉用到对应的驱动函数；<br>可以说net_device是内核和驱动的桥梁；<br>所有设备的net_device结构放在一个全局变量 dev_base所指的全局列表中，在include/linux/netdevice.h中定义<br>网络设备可以分成几种类型，如Ethernet卡和Token Ring卡；对同一类型的所有设备，会设置某些字段为相同的值，有些则根据设备模型做不同的设置；<br>为了改善性能，驱动程序还可以改写一些已由内核初始化过的字段；<br>1_2: 结构组成：<br>net_device结构的字段可以分成以下几种类型：<br>标识符：net_device有三个标识符，不能搞混：<br>    int ifindex: 独一无二的ID,当设备以dev_new_index注册时分派给每个设备；<br>    int iflink: 这个字段主要是由(虚拟)隧道设备使用，可用于标识抵达隧道另一端的真实设备；<br>    unsigned short dev_id: 目前在zSeries OSA NIC上由IPv6使用，此字段用于区别可由不同OS同时共享的同一种设备的诸多设虚拟实例；见net/ipv6/addrconf.c的注释；  </p>
<p>配置<br>统计数据<br>设备状态<br>列表管理<br>流量管理<br>功能专用<br>通用<br>函数指针  </p>
<p>2、ref 深入理解linux网络内幕：设备注册和初始化：net_device<br>(1) 网络设备何时以及如何在内核注册：静态，热插拔<br>(2) 网络设备如何利用网络设备数据库注册，并指派一个net_device结构的实例<br>(3) net_device结构如何组织到hash表和列表，以便于做各种查询；<br>(4) net_device实例如何初始化，一部分由内核核心函数完成，一部分由其设备驱动程序完成，如ops结构中的函数指针；<br>(5）就注册而言，虚拟设备和真实设备有和区别；  </p>
<p>3、正文：<br>nic（网卡）可用之前，其相关联的net_deivce数据结构必须先初始化，添加到内核网络设备数据库，配置并开启；<br>注册/除名 和开启/关闭 是不同的，前者可以理解为注册和加载驱动/卸载驱动，后者可以理解为开启和关闭网络设备，即关闭相关进程；<br>(1)网络设备注册之时：<br>   A:开机时，加载nic设备驱动程序，insmod类似动作或者调用module_init这种；或者在运行时进行insmod动态加载；<br>           这种情况下，可能会是通过总线设备驱动程序进行pci_driver-&gt;probe的调用，来负责设备注册；<br>  <strong>这里详细说明下：通过pci检测设备并调用probe函数，这个函数是由驱动提供，通过.probe=xxx_probe来实现，并做与module_init相同的事情；</strong><br>  <strong>那么什么时候会用probe函数什么时候用module_init函数？前者是自动检测是用的，后者是运行时动态加载时使用的；</strong>–这个是查询的，需要再确认；<br><strong> 可以看到 若调用probe函数，则为XX_probe–&gt;alloc_dev–&gt;xxx_setup</strong><br>例子：net/wireless/airo.c<br>   B:插入热插拔设备；此时内核会通知其驱动程序，驱动程序再注册该设备；<br>  网络设备除名之时：pci_driver-&gt;remove<br>   1:关机时或者运行时做rmmod，即卸载设备驱动<br>   2:拔出热插拔设备，此时做删除等动作；  </p>
<p>(2)分配net_deivce结构：<br>使用在net/core/dev.c中的alloc_netdev分配，而一般由设备驱动程序进行调用；<br>这个函数的三个参数：由驱动程序提供实参<br>  私有数据结构大小:是驱动程序会使用的私有结构大小<br> ，设备名称，一个字符串，类似于eth0,eth1<br>设置函数：初始化函数指针，用来设置net_device结构的剩余部分；<br>返回值是指向已分配的net_device结构指针；<br>此外，内核也提供一组内含alloc_netdev的包裹函数，可用于为一组通用设备类型提供正确参数给alloc_netdev<br>好几个  </p>
<p>(3)Nic注册和除名的架构（设备驱动程序加载和卸载相关联）<br>依赖于总线；<br>其余部分则是网络设备驱动程序的架构；<br>    结构：私有数据结构+net_deivce+ops<br>    初始化：alloc_dev+register net_device and ops中的函数集合+setup函数以及其他初始化函数；<br>    卸载清理函数；<br>    module_init,module_exit;/xxx_probe xxx_remove_one<br>例子见上；注意一下几点：<br>A:驱动程序可能会使用包裹函数，并只提供其私有数据区大小；<br>B:包裹函数会使用驱动程序提供的参数（包括设备名加初始化函数）来调用alloc_netdev<br>C:alloc_netdev所分配的内存块大小包括net_device结构和驱动程序私有数据块以及强制对齐所补的空白空间；<br>D:有些驱动程序会调用netdev_boot_setup_check函数减产加载内核时用户是否提供了任何引导期间参数；<br>E:新的net_device实例会利用register_netdevice来插入设备数据库；  </p>
<p>(4)设备初始化，包含xxx_setup函数，驱动程序传入的指针对于的函数，会对net_device等做一些初始化；<br>设备初始化包含以下三类：<br>   设备驱动程序的初始化，包括但不止xxx_setup（init函数里面可能也会做一些初始化)，<br>   设备类型：由xxx_setup函数负责;<br>   各种功能：可选和强制功能也必须初始化如队列规则；  </p>
<p>注意：xxx_setup是设备驱动程序传给内核的，但会被设备模型（总线）通过xxx_probe调用到<br>xxx_setup也会做类似于设置mtu,macaddr,hard_head_len,等值；</p>
<p>(5) net_deivce 结构组织介绍：仅说明一些点；<br> 览:net_device数据结构插在一个全局列表和两张hash表中；这些结构可以让内核按需求浏览和查询net_deivce数据库；<br> A: dev_base是一个指针，指向net_deivce链表的头，net_device中的next结果将整个全部设备串起来，这样内核通过这个结构可以轻易浏览设备；取得关键数据等；<br> B: dev_name_head:是一张hash表，以设备名为索引，可以让类似ioctl进行操作；<br> C:dev_index_head:是一张hash表，以设备ID:dev-&gt;ifindex为索引，指向net_device结构指针；如ip,netlink时就是通过dev-&gt;ifindex来索引的；<br>上面两张表，就可以提供获取设备的接口如：dev_get_by_name()和dev_get_by_index; 也可能根据设备类型和mac地址搜寻net_device，此时用的是dev_base<br>    上述三个结构通过dev_base_lock锁保护，所有查询函数在net/core/dev.c中  </p>
<p>(6)设备状态：<br>net_device中有各种字段可以定义设备当前状态；<br>如： flags:开启或关闭,reg_state:注册状态；state:用于队列规则；<br>队列规则状态：<br>每个网络设备都会分配一种队列规则，流量控制并以此来实现其Qos机制；<br>state就是用于这个，是位域，在include/linux/netdeivce.h中；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">netdev_state_t</span></span><br><span class="line">&#123;</span><br><span class="line">	__LINK_STATE_XOFF=<span class="number">0</span>,</span><br><span class="line">	__LINK_STATE_START, 设备开启，此标示可以由netif_running检查</span><br><span class="line">	__LINK_STATE_PRESENT,</span><br><span class="line">	__LINK_STATE_SCHED,</span><br><span class="line">	__LINK_STATE_NOCARRIER,</span><br><span class="line">	__LINK_STATE_RX_SCHED,</span><br><span class="line">	__LINK_STATE_LINKWATCH_PENDING</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注册状态：<br>reg_state:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* register/unregister state machine */</span></span><br><span class="line"><span class="keyword">enum</span> &#123; NETREG_UNINITIALIZED=<span class="number">0</span>,</span><br><span class="line">       NETREG_REGISTERING,	<span class="comment">/* called register_netdevice */</span></span><br><span class="line">       NETREG_REGISTERED,	<span class="comment">/* completed register todo */</span></span><br><span class="line">       NETREG_UNREGISTERING,	<span class="comment">/* called unregister_netdevice */</span></span><br><span class="line">       NETREG_UNREGISTERED,	<span class="comment">/* completed unregister todo */</span></span><br><span class="line">       NETREG_RELEASED,		<span class="comment">/* called free_netdev */</span></span><br><span class="line">&#125; reg_state;</span><br></pre></td></tr></table></figure></p>
<p>(7)注册函数和除名函数过程：<br>net/core/dev.c中：<br>调用netdev_run_todo处理；书里面将的调用情况，先忽略<br>A:注册详情：即注册时做了什么<br>  注册不仅仅是将net_device插入上述三个结构中，而还有其他动作：如一般有；<br>   1) net_device的一些字段初始化；<br>   2) 内核支持divert功能时，分配配置；<br>   3) 执行xxx_setup函数<br>   4)执行dev_new_index分配一个独一无二的标识码给设备；<br>   5)将net_device加入上面三个结构中；<br>   6)检查，设置状态和标识，初始化队列规则等；<br>   7)调用通知链相关函数；  </p>
<p>B:除名详情，即反注册时做了什么：<br>上面的反过程</p>
<p>(8)设备注册状态的通知：<br>内核组件和用户空间应用程序可能都想知道何时发生网络设备注册，除名，关闭或者开启之事，这类事件的通知通过两种通道传送：<br>  A:netdev_chain:注册通知链；<br>  B:Netlink的RTMGRP_LINK多播群组；<br>A:所有的netdev_chain报告的NETDEV_XXX事件都列在include/linux/notifier.h中；通知链怎么用见前文<br>   如对上面NETDEV_XXX事件感兴趣的可以通过register_netdevice_notifier和unregister_netdevice_notifier注册和反注册，就可以监听到消息；<br>   目前如：路由，防火墙，协议代码，虚拟设备等内核组件都在netdev_chain注册了；</p>
<p>(9) 引用计数：<br>net_device结构无法释放除非所有的引用都已释放；dev-&gt;refcnt中；<br>netdev_wait_allrefs;  </p>
<p>(10)开启和关闭网络设备；<br>设备一旦注册就可以用，但是除非用户或用户应用程序明确开启，否则还是无法传输接收数据<br>net/core/dev.c中dev_open负责；<br>开启设备：<br>   A：dev-&gt;open;<br>  B:设置dev-&gt;state<br>  C:设置flag<br>  D:初始化流量控制队列规则等；<br>  E:通知链调用；<br>关闭设备：<br>相反</p>
<p>(11)和电源管理之间的交互：<br>  当内核支持电源管理时，若进入挂起模式，则NIC设备驱动程序会接到通知，通过pci pci_driver结构的suspend,resume；<br>会影响到网络设备，如net-&gt;state,并调用相关函数挂起设备或重新继续；netif_device_detach/netif_device_attach<br>其他：  </p>
<p>(12)链路状态变更检测：<br>A：驱动程序检测载波或者信号是否存在；  netif_carrier_on/netif_carrier_off;<br>B:  调度并处理链路状态变更事件；<br>C:链接监看标示  </p>
<p>(13)从用户空间配置设备相关信息；<br>ifconfig,ethool,ip link;通过ioctl或netlink下去；<br>媒介独立接口：MII<br>(14)虚拟设备注意<br>(15)上锁  </p>
<h5 id="probe等函数例子："><a href="#probe等函数例子：" class="headerlink" title="probe等函数例子："></a>probe等函数例子：</h5><p>driver/net/xxx/xxx 具体设备相关文件；  </p>
<h5 id="以wifi芯片举例："><a href="#以wifi芯片举例：" class="headerlink" title="以wifi芯片举例："></a>以wifi芯片举例：</h5><pre><code> (data数据网络：ap侧：手机cpu modem侧：modem芯片)  
 (wifi网络：ap侧：固件wifi芯片  host端：手机cpu）  
 网卡NIC如无线网卡，内部是由程序在运行，在网卡中运行的程序叫做固件，对wifi而言也称为AP侧，而在PC端运行的用于控制和相应网卡中断的称为driver（驱动）或host侧；  
驱动程序往往以ko的形式，被内核加载和运行  
固件以bin或其他形式(mtk:bin,qcom:mpb)，被push到设备指定目录中，并最后push到设备内存中运行；  
</code></pre><h6 id="ldd3上一个虚拟设备的例子：贴过来仅供参考；"><a href="#ldd3上一个虚拟设备的例子：贴过来仅供参考；" class="headerlink" title="ldd3上一个虚拟设备的例子：贴过来仅供参考；"></a>ldd3上一个虚拟设备的例子：贴过来仅供参考；</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * snull.c --  the Simple Network Utility</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2001 O'Reilly &amp; Associates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The source code in this file can be freely used, adapted,</span></span><br><span class="line"><span class="comment"> * and redistributed in source or binary form, so long as an</span></span><br><span class="line"><span class="comment"> * acknowledgment appears in derived source files.  The citation</span></span><br><span class="line"><span class="comment"> * should list that the code comes from the book "Linux Device</span></span><br><span class="line"><span class="comment"> * Drivers" by Alessandro Rubini and Jonathan Corbet, published</span></span><br><span class="line"><span class="comment"> * by O'Reilly &amp; Associates.   No warranty is attached;</span></span><br><span class="line"><span class="comment"> * we cannot take responsibility for errors or fitness for use.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * $Id: snull.c,v 1.21 2004/11/05 02:36:03 rubini Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt; /* printk() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt; /* kmalloc() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;  /* error codes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;  /* size_t */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt; /* mark_bh */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netdevice.h&gt;   /* struct device, and other headers */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/etherdevice.h&gt; /* eth_type_trans */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;          /* struct iphdr */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;         /* struct tcphdr */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"snull.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in6.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/checksum.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">"Alessandro Rubini, Jonathan Corbet"</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Transmitter lockup simulation, normally disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lockup = <span class="number">0</span>;</span><br><span class="line">module_param(lockup, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> timeout = SNULL_TIMEOUT;</span><br><span class="line">module_param(timeout, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do we run in NAPI mode?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> use_napi = <span class="number">0</span>;</span><br><span class="line">module_param(use_napi, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A structure representing an in-flight packet.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span>	datalen;</span><br><span class="line">	u8 data[ETH_DATA_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pool_size = <span class="number">8</span>;</span><br><span class="line">module_param(pool_size, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is private to each device. It is used to pass</span></span><br><span class="line"><span class="comment"> * packets in and out, so there is place for a packet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> &#123;</span><span class="comment">//这个网络设备的私有数据结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">ppool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">rx_queue</span>;</span>  <span class="comment">/* List of incoming packets */</span></span><br><span class="line">	<span class="keyword">int</span> rx_int_enabled;</span><br><span class="line">	<span class="keyword">int</span> tx_packetlen;</span><br><span class="line">	u8 *tx_packetdata;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一些net_deivce需要的函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">snull_tx_timeout</span><span class="params">(struct net_device *dev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*snull_interrupt)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span> *, struct pt_regs *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up a device's packet pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_setup_pool</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">pkt</span>;</span></span><br><span class="line"></span><br><span class="line">	priv-&gt;ppool = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool_size; i++) &#123;</span><br><span class="line">		pkt = kmalloc (<span class="keyword">sizeof</span> (struct snull_packet), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (pkt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			printk (KERN_NOTICE <span class="string">"Ran out of memory allocating packet pool\n"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pkt-&gt;dev = dev;</span><br><span class="line">		pkt-&gt;next = priv-&gt;ppool;</span><br><span class="line">		priv-&gt;ppool = pkt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_teardown_pool</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">pkt</span>;</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> ((pkt = priv-&gt;ppool)) &#123;</span><br><span class="line">		priv-&gt;ppool = pkt-&gt;next;</span><br><span class="line">		kfree (pkt);</span><br><span class="line">		<span class="comment">/* FIXME - in-flight packets ? */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Buffer/pool management.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct snull_packet *<span class="title">snull_get_tx_buffer</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">pkt</span>;</span></span><br><span class="line">    </span><br><span class="line">	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span><br><span class="line">	pkt = priv-&gt;ppool;</span><br><span class="line">	priv-&gt;ppool = pkt-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;ppool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk (KERN_INFO <span class="string">"Pool empty\n"</span>);</span><br><span class="line">		netif_stop_queue(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> pkt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_release_buffer</span><span class="params">(struct snull_packet *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">pkt</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line">	</span><br><span class="line">	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span><br><span class="line">	pkt-&gt;next = priv-&gt;ppool;</span><br><span class="line">	priv-&gt;ppool = pkt;</span><br><span class="line">	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (netif_queue_stopped(pkt-&gt;dev) &amp;&amp; pkt-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">		netif_wake_queue(pkt-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_enqueue_buf</span><span class="params">(struct net_device *dev, struct snull_packet *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span><br><span class="line">	pkt-&gt;next = priv-&gt;rx_queue;  <span class="comment">/* FIXME - misorders packets */</span></span><br><span class="line">	priv-&gt;rx_queue = pkt;</span><br><span class="line">	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct snull_packet *<span class="title">snull_dequeue_buf</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">pkt</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span><br><span class="line">	pkt = priv-&gt;rx_queue;</span><br><span class="line">	<span class="keyword">if</span> (pkt != <span class="literal">NULL</span>)</span><br><span class="line">		priv-&gt;rx_queue = pkt-&gt;next;</span><br><span class="line">	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> pkt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Enable and disable receive interrupts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">snull_rx_ints</span><span class="params">(struct net_device *dev, <span class="keyword">int</span> enable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	priv-&gt;rx_int_enabled = enable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Open and close</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_open</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* request_region(), request_irq(), ....  (like fops-&gt;open) */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Assign the hardware address of the board: use "\0SNULx", where</span></span><br><span class="line"><span class="comment">	 * x is 0 or 1. The first byte is '\0' to avoid being a multicast</span></span><br><span class="line"><span class="comment">	 * address (the first byte of multicast addrs is odd).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(dev-&gt;dev_addr, <span class="string">"\0SNUL0"</span>, ETH_ALEN);</span><br><span class="line">	<span class="keyword">if</span> (dev == snull_devs[<span class="number">1</span>])</span><br><span class="line">		dev-&gt;dev_addr[ETH_ALEN<span class="number">-1</span>]++; <span class="comment">/* \0SNUL1 */</span></span><br><span class="line">	netif_start_queue(dev);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_release</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* release ports, irq and such -- like fops-&gt;close */</span></span><br><span class="line"></span><br><span class="line">	netif_stop_queue(dev); <span class="comment">/* can't transmit any more */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Configuration changes (passed on by ifconfig)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_config</span><span class="params">(struct net_device *dev, struct ifmap *<span class="built_in">map</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;flags &amp; IFF_UP) <span class="comment">/* can't act on a running interface */</span></span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don't allow changing the I/O address */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>-&gt;base_addr != dev-&gt;base_addr) &#123;</span><br><span class="line">		printk(KERN_WARNING <span class="string">"snull: Can't change I/O address\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow changing the IRQ */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>-&gt;irq != dev-&gt;irq) &#123;</span><br><span class="line">		dev-&gt;irq = <span class="built_in">map</span>-&gt;irq;</span><br><span class="line">        	<span class="comment">/* request_irq() is delayed to open-time */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ignore other fields */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Receive a packet: retrieve, encapsulate and pass over to upper levels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_rx</span><span class="params">(struct net_device *dev, struct snull_packet *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The packet has been retrieved from the transmission</span></span><br><span class="line"><span class="comment">	 * medium. Build an skb around it, so upper layers can handle it</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	skb = dev_alloc_skb(pkt-&gt;datalen + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		<span class="keyword">if</span> (printk_ratelimit())</span><br><span class="line">			printk(KERN_NOTICE <span class="string">"snull rx: low on mem - packet dropped\n"</span>);</span><br><span class="line">		priv-&gt;stats.rx_dropped++;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	skb_reserve(skb, <span class="number">2</span>); <span class="comment">/* align IP on 16B boundary */</span>  </span><br><span class="line">	<span class="built_in">memcpy</span>(skb_put(skb, pkt-&gt;datalen), pkt-&gt;data, pkt-&gt;datalen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write metadata, and then pass to the receive level */</span></span><br><span class="line">	skb-&gt;dev = dev;</span><br><span class="line">	skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; <span class="comment">/* don't check it */</span></span><br><span class="line">	priv-&gt;stats.rx_packets++;</span><br><span class="line">	priv-&gt;stats.rx_bytes += pkt-&gt;datalen;</span><br><span class="line">	netif_rx(skb);</span><br><span class="line">  out:</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The poll implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snull_poll</span><span class="params">(struct net_device *dev, <span class="keyword">int</span> *budget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> npackets = <span class="number">0</span>, quota = min(dev-&gt;quota, *budget);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">pkt</span>;</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (npackets &lt; quota &amp;&amp; priv-&gt;rx_queue) &#123;</span><br><span class="line">		pkt = snull_dequeue_buf(dev);</span><br><span class="line">		skb = dev_alloc_skb(pkt-&gt;datalen + <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (! skb) &#123;</span><br><span class="line">			<span class="keyword">if</span> (printk_ratelimit())</span><br><span class="line">				printk(KERN_NOTICE <span class="string">"snull: packet dropped\n"</span>);</span><br><span class="line">			priv-&gt;stats.rx_dropped++;</span><br><span class="line">			snull_release_buffer(pkt);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		skb_reserve(skb, <span class="number">2</span>); <span class="comment">/* align IP on 16B boundary */</span>  </span><br><span class="line">		<span class="built_in">memcpy</span>(skb_put(skb, pkt-&gt;datalen), pkt-&gt;data, pkt-&gt;datalen);</span><br><span class="line">		skb-&gt;dev = dev;</span><br><span class="line">		skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">		skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; <span class="comment">/* don't check it */</span></span><br><span class="line">		netif_receive_skb(skb);</span><br><span class="line">		</span><br><span class="line">        	<span class="comment">/* Maintain stats */</span></span><br><span class="line">		npackets++;</span><br><span class="line">		priv-&gt;stats.rx_packets++;</span><br><span class="line">		priv-&gt;stats.rx_bytes += pkt-&gt;datalen;</span><br><span class="line">		snull_release_buffer(pkt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* If we processed all packets, we're done; tell the kernel and reenable ints */</span></span><br><span class="line">	*budget -= npackets;</span><br><span class="line">	dev-&gt;quota -= npackets;</span><br><span class="line">	<span class="keyword">if</span> (! priv-&gt;rx_queue) &#123;</span><br><span class="line">		netif_rx_complete(dev);</span><br><span class="line">		snull_rx_ints(dev, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* We couldn't process everything. */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">	    </span><br><span class="line">        </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The typical interrupt entry point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">snull_regular_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> statusword;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">pkt</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * As usual, check the "device" pointer to be sure it is</span></span><br><span class="line"><span class="comment">	 * really interrupting.</span></span><br><span class="line"><span class="comment">	 * Then assign "struct device *dev"</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">net_device</span> *)<span class="title">dev_id</span>;</span></span><br><span class="line">	<span class="comment">/* ... and check with hw if it's really ours */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* paranoid */</span></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lock the device */</span></span><br><span class="line">	priv = netdev_priv(dev);</span><br><span class="line">	spin_lock(&amp;priv-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* retrieve statusword: real netdevices use I/O instructions */</span></span><br><span class="line">	statusword = priv-&gt;status;</span><br><span class="line">	priv-&gt;status = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (statusword &amp; SNULL_RX_INTR) &#123;</span><br><span class="line">		<span class="comment">/* send it to snull_rx for handling */</span></span><br><span class="line">		pkt = priv-&gt;rx_queue;</span><br><span class="line">		<span class="keyword">if</span> (pkt) &#123;</span><br><span class="line">			priv-&gt;rx_queue = pkt-&gt;next;</span><br><span class="line">			snull_rx(dev, pkt);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (statusword &amp; SNULL_TX_INTR) &#123;</span><br><span class="line">		<span class="comment">/* a transmission is over: free the skb */</span></span><br><span class="line">		priv-&gt;stats.tx_packets++;</span><br><span class="line">		priv-&gt;stats.tx_bytes += priv-&gt;tx_packetlen;</span><br><span class="line">		dev_kfree_skb(priv-&gt;skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unlock the device and we are done */</span></span><br><span class="line">	spin_unlock(&amp;priv-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (pkt) snull_release_buffer(pkt); <span class="comment">/* Do this outside the lock! */</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A NAPI interrupt handler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">snull_napi_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> statusword;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * As usual, check the "device" pointer for shared handlers.</span></span><br><span class="line"><span class="comment">	 * Then assign "struct device *dev"</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">net_device</span> *)<span class="title">dev_id</span>;</span></span><br><span class="line">	<span class="comment">/* ... and check with hw if it's really ours */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* paranoid */</span></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lock the device */</span></span><br><span class="line">	priv = netdev_priv(dev);</span><br><span class="line">	spin_lock(&amp;priv-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* retrieve statusword: real netdevices use I/O instructions */</span></span><br><span class="line">	statusword = priv-&gt;status;</span><br><span class="line">	priv-&gt;status = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (statusword &amp; SNULL_RX_INTR) &#123;</span><br><span class="line">		snull_rx_ints(dev, <span class="number">0</span>);  <span class="comment">/* Disable further interrupts */</span></span><br><span class="line">		netif_rx_schedule(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (statusword &amp; SNULL_TX_INTR) &#123;</span><br><span class="line">        	<span class="comment">/* a transmission is over: free the skb */</span></span><br><span class="line">		priv-&gt;stats.tx_packets++;</span><br><span class="line">		priv-&gt;stats.tx_bytes += priv-&gt;tx_packetlen;</span><br><span class="line">		dev_kfree_skb(priv-&gt;skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unlock the device and we are done */</span></span><br><span class="line">	spin_unlock(&amp;priv-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Transmit a packet (low level interface)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">snull_hw_tx</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> len, struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This function deals with hw details. This interface loops</span></span><br><span class="line"><span class="comment">	 * back the packet to the other snull interface (if any).</span></span><br><span class="line"><span class="comment">	 * In other words, this function implements the snull behaviour,</span></span><br><span class="line"><span class="comment">	 * while all other procedures are rather device-independent</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ih</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dest</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span>;</span></span><br><span class="line">	u32 *saddr, *daddr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">tx_buffer</span>;</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* I am paranoid. Ain't I? */</span></span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="keyword">sizeof</span>(struct ethhdr) + <span class="keyword">sizeof</span>(struct iphdr)) &#123;</span><br><span class="line">		printk(<span class="string">"snull: Hmm... packet too short (%i octets)\n"</span>,</span><br><span class="line">				len);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="comment">/* enable this conditional to look at the data */</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		PDEBUG(<span class="string">"len is %i\n"</span> KERN_DEBUG <span class="string">"data:"</span>,len);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">14</span> ; i&lt;len; i++)</span><br><span class="line">			printk(<span class="string">" %02x"</span>,buf[i]&amp;<span class="number">0xff</span>);</span><br><span class="line">		printk(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ethhdr is 14 bytes, but the kernel arranges for iphdr</span></span><br><span class="line"><span class="comment">	 * to be aligned (i.e., ethhdr is unaligned)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ih = (struct iphdr *)(buf+<span class="keyword">sizeof</span>(struct ethhdr));</span><br><span class="line">	saddr = &amp;ih-&gt;saddr;</span><br><span class="line">	daddr = &amp;ih-&gt;daddr;</span><br><span class="line"></span><br><span class="line">	((u8 *)saddr)[<span class="number">2</span>] ^= <span class="number">1</span>; <span class="comment">/* change the third octet (class C) */</span></span><br><span class="line">	((u8 *)daddr)[<span class="number">2</span>] ^= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	ih-&gt;check = <span class="number">0</span>;         <span class="comment">/* and rebuild the checksum (ip needs it) */</span></span><br><span class="line">	ih-&gt;check = ip_fast_csum((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)ih,ih-&gt;ihl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev == snull_devs[<span class="number">0</span>])</span><br><span class="line">		PDEBUGG(<span class="string">"%08x:%05i --&gt; %08x:%05i\n"</span>,</span><br><span class="line">				ntohl(ih-&gt;saddr),ntohs(((struct tcphdr *)(ih+<span class="number">1</span>))-&gt;source),</span><br><span class="line">				ntohl(ih-&gt;daddr),ntohs(((struct tcphdr *)(ih+<span class="number">1</span>))-&gt;dest));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		PDEBUGG(<span class="string">"%08x:%05i &lt;-- %08x:%05i\n"</span>,</span><br><span class="line">				ntohl(ih-&gt;daddr),ntohs(((struct tcphdr *)(ih+<span class="number">1</span>))-&gt;dest),</span><br><span class="line">				ntohl(ih-&gt;saddr),ntohs(((struct tcphdr *)(ih+<span class="number">1</span>))-&gt;source));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ok, now the packet is ready for transmission: first simulate a</span></span><br><span class="line"><span class="comment">	 * receive interrupt on the twin device, then  a</span></span><br><span class="line"><span class="comment">	 * transmission-done on the transmitting device</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dest = snull_devs[dev == snull_devs[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>];</span><br><span class="line">	priv = netdev_priv(dest);</span><br><span class="line">	tx_buffer = snull_get_tx_buffer(dev);</span><br><span class="line">	tx_buffer-&gt;datalen = len;</span><br><span class="line">	<span class="built_in">memcpy</span>(tx_buffer-&gt;data, buf, len);</span><br><span class="line">	snull_enqueue_buf(dest, tx_buffer);</span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;rx_int_enabled) &#123;</span><br><span class="line">		priv-&gt;status |= SNULL_RX_INTR;</span><br><span class="line">		snull_interrupt(<span class="number">0</span>, dest, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv = netdev_priv(dev);</span><br><span class="line">	priv-&gt;tx_packetlen = len;</span><br><span class="line">	priv-&gt;tx_packetdata = buf;</span><br><span class="line">	priv-&gt;status |= SNULL_TX_INTR;</span><br><span class="line">	<span class="keyword">if</span> (lockup &amp;&amp; ((priv-&gt;stats.tx_packets + <span class="number">1</span>) % lockup) == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">/* Simulate a dropped transmit interrupt */</span></span><br><span class="line">		netif_stop_queue(dev);</span><br><span class="line">		PDEBUG(<span class="string">"Simulate lockup at %ld, txp %ld\n"</span>, jiffies,</span><br><span class="line">				(<span class="keyword">unsigned</span> <span class="keyword">long</span>) priv-&gt;stats.tx_packets);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		snull_interrupt(<span class="number">0</span>, dev, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Transmit a packet (called by the kernel)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_tx</span><span class="params">(struct sk_buff *skb, struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">char</span> *data, shortpkt[ETH_ZLEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	</span><br><span class="line">	data = skb-&gt;data;</span><br><span class="line">	len = skb-&gt;len;</span><br><span class="line">	<span class="keyword">if</span> (len &lt; ETH_ZLEN) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(shortpkt, <span class="number">0</span>, ETH_ZLEN);</span><br><span class="line">		<span class="built_in">memcpy</span>(shortpkt, skb-&gt;data, skb-&gt;len);</span><br><span class="line">		len = ETH_ZLEN;</span><br><span class="line">		data = shortpkt;</span><br><span class="line">	&#125;</span><br><span class="line">	dev-&gt;trans_start = jiffies; <span class="comment">/* save the timestamp */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remember the skb, so we can free it at interrupt time */</span></span><br><span class="line">	priv-&gt;skb = skb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* actual deliver of data is device-specific, and not shown here */</span></span><br><span class="line">	snull_hw_tx(data, len, dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Our simple device can not fail */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Deal with a transmit timeout.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_tx_timeout</span> <span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	PDEBUG(<span class="string">"Transmit timeout at %ld, latency %ld\n"</span>, jiffies,</span><br><span class="line">			jiffies - dev-&gt;trans_start);</span><br><span class="line">        <span class="comment">/* Simulate a transmission interrupt to get things moving */</span></span><br><span class="line">	priv-&gt;status = SNULL_TX_INTR;</span><br><span class="line">	snull_interrupt(<span class="number">0</span>, dev, <span class="literal">NULL</span>);</span><br><span class="line">	priv-&gt;stats.tx_errors++;</span><br><span class="line">	netif_wake_queue(dev);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ioctl commands </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_ioctl</span><span class="params">(struct net_device *dev, struct ifreq *rq, <span class="keyword">int</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PDEBUG(<span class="string">"ioctl\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return statistics to the caller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct net_device_stats *<span class="title">snull_stats</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">return</span> &amp;priv-&gt;stats;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called to fill up an eth header, since arp is not</span></span><br><span class="line"><span class="comment"> * available on the interface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_rebuild_header</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = (<span class="title">struct</span> <span class="title">ethhdr</span> *) <span class="title">skb</span>-&gt;<span class="title">data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">skb</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">    </span><br><span class="line">	<span class="built_in">memcpy</span>(eth-&gt;h_source, dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">	<span class="built_in">memcpy</span>(eth-&gt;h_dest, dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">	eth-&gt;h_dest[ETH_ALEN<span class="number">-1</span>]   ^= <span class="number">0x01</span>;   <span class="comment">/* dest is us xor 1 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_header</span><span class="params">(struct sk_buff *skb, struct net_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">short</span> type, <span class="keyword">void</span> *daddr, <span class="keyword">void</span> *saddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = (<span class="title">struct</span> <span class="title">ethhdr</span> *)<span class="title">skb_push</span>(<span class="title">skb</span>,<span class="title">ETH_HLEN</span>);</span></span><br><span class="line"></span><br><span class="line">	eth-&gt;h_proto = htons(type);</span><br><span class="line">	<span class="built_in">memcpy</span>(eth-&gt;h_source, saddr ? saddr : dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">	<span class="built_in">memcpy</span>(eth-&gt;h_dest,   daddr ? daddr : dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">	eth-&gt;h_dest[ETH_ALEN<span class="number">-1</span>]   ^= <span class="number">0x01</span>;   <span class="comment">/* dest is us xor 1 */</span></span><br><span class="line">	<span class="keyword">return</span> (dev-&gt;hard_header_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The "change_mtu" method is usually not needed.</span></span><br><span class="line"><span class="comment"> * If you need it, it must be like this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_change_mtu</span><span class="params">(struct net_device *dev, <span class="keyword">int</span> new_mtu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> *lock = &amp;priv-&gt;lock;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* check ranges */</span></span><br><span class="line">	<span class="keyword">if</span> ((new_mtu &lt; <span class="number">68</span>) || (new_mtu &gt; <span class="number">1500</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do anything you need, and the accept the value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	spin_lock_irqsave(lock, flags);</span><br><span class="line">	dev-&gt;mtu = new_mtu;</span><br><span class="line">	spin_unlock_irqrestore(lock, flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* success */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The init function (sometimes called probe).</span></span><br><span class="line"><span class="comment"> * It is invoked by register_netdev()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这个是setup函数，用于初始化net_device部分结构，并作为alloc_netdev的第三个参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_init</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make the usual checks: check_region(), probe irq, ...  -ENODEV</span></span><br><span class="line"><span class="comment">	 * should be returned if no device found.  No resource should be</span></span><br><span class="line"><span class="comment">	 * grabbed: this is done on open(). </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Then, assign other fields in dev, using ether_setup() and some</span></span><br><span class="line"><span class="comment">	 * hand assignments</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ether_setup(dev); <span class="comment">/* assign some of the fields */</span></span><br><span class="line"></span><br><span class="line">	dev-&gt;open            = snull_open;</span><br><span class="line">	dev-&gt;stop            = snull_release;</span><br><span class="line">	dev-&gt;set_config      = snull_config;</span><br><span class="line">	dev-&gt;hard_start_xmit = snull_tx;</span><br><span class="line">	dev-&gt;do_ioctl        = snull_ioctl;</span><br><span class="line">	dev-&gt;get_stats       = snull_stats;</span><br><span class="line">	dev-&gt;change_mtu      = snull_change_mtu;  </span><br><span class="line">	dev-&gt;rebuild_header  = snull_rebuild_header;</span><br><span class="line">	dev-&gt;hard_header     = snull_header;</span><br><span class="line">	dev-&gt;tx_timeout      = snull_tx_timeout;</span><br><span class="line">	dev-&gt;watchdog_timeo = timeout;</span><br><span class="line">	<span class="keyword">if</span> (use_napi) &#123;</span><br><span class="line">		dev-&gt;poll        = snull_poll;</span><br><span class="line">		dev-&gt;weight      = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* keep the default flags, just add NOARP */</span></span><br><span class="line">	dev-&gt;flags           |= IFF_NOARP;</span><br><span class="line">	dev-&gt;features        |= NETIF_F_NO_CSUM;</span><br><span class="line">	dev-&gt;hard_header_cache = <span class="literal">NULL</span>;      <span class="comment">/* Disable caching */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Then, initialize the priv field. This encloses the statistics</span></span><br><span class="line"><span class="comment">	 * and a few private fields.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	priv = netdev_priv(dev);</span><br><span class="line">	<span class="built_in">memset</span>(priv, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct snull_priv));</span><br><span class="line">	spin_lock_init(&amp;priv-&gt;lock);</span><br><span class="line">	snull_rx_ints(dev, <span class="number">1</span>);		<span class="comment">/* enable receive interrupts */</span></span><br><span class="line">	snull_setup_pool(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The devices</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">snull_devs</span>[2];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Finally, the module stuff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//驱动卸载时调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>;  i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (snull_devs[i]) &#123;</span><br><span class="line">			unregister_netdev(snull_devs[i]);<span class="comment">//反注册net_deivce</span></span><br><span class="line">			snull_teardown_pool(snull_devs[i]);</span><br><span class="line">			free_netdev(snull_devs[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动加载时的初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result, i, ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	snull_interrupt = use_napi ? snull_napi_interrupt : snull_regular_interrupt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate the devices */</span></span><br><span class="line">	snull_devs[<span class="number">0</span>] = alloc_netdev(<span class="keyword">sizeof</span>(struct snull_priv), <span class="string">"sn%d"</span>,<span class="comment">//调用的分配net_deivce函数</span></span><br><span class="line">			snull_init);</span><br><span class="line">	snull_devs[<span class="number">1</span>] = alloc_netdev(<span class="keyword">sizeof</span>(struct snull_priv), <span class="string">"sn%d"</span>,<span class="comment">//这里"sn%d"内核会使用dev_alloc_name以完成该名字，次函数会把%d换成该设备类型中头一个未分配的数字</span></span><br><span class="line">			snull_init);</span><br><span class="line">	<span class="keyword">if</span> (snull_devs[<span class="number">0</span>] == <span class="literal">NULL</span> || snull_devs[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	ret = -ENODEV;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>;  i++)</span><br><span class="line">		<span class="keyword">if</span> ((result = register_netdev(snull_devs[i])))<span class="comment">//注册net_device</span></span><br><span class="line">			printk(<span class="string">"snull: error %i registering device \"%s\"\n"</span>,</span><br><span class="line">					result, snull_devs[i]-&gt;name);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line">   out:</span><br><span class="line">	<span class="keyword">if</span> (ret) </span><br><span class="line">		snull_cleanup();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(snull_init_module);</span><br><span class="line">module_exit(snull_cleanup);</span><br></pre></td></tr></table></figure>
<h4 id="其他部分，如子系统的初始化，等分析到了再写"><a href="#其他部分，如子系统的初始化，等分析到了再写" class="headerlink" title="其他部分，如子系统的初始化，等分析到了再写"></a>其他部分，如子系统的初始化，等分析到了再写</h4>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/tcpip-init/" rel="tag"># tcpip_init</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/12/filesystem/" rel="prev" title="filesystem">
      <i class="fa fa-chevron-left"></i> filesystem
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/03/cpp-type/" rel="next" title="cpp_type">
      cpp_type <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#linux内核网络子系统的初始化介绍"><span class="nav-number">1.</span> <span class="nav-text">linux内核网络子系统的初始化介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#linux内核网络子系统初始化组成"><span class="nav-number">1.1.</span> <span class="nav-text">linux内核网络子系统初始化组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内核的初始化过程整体和init函数集合"><span class="nav-number">1.2.</span> <span class="nav-text">内核的初始化过程整体和init函数集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络文件系统等初始化：sock-init"><span class="nav-number">1.3.</span> <span class="nav-text">网络文件系统等初始化：sock_init</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#代码流程分析"><span class="nav-number">1.3.1.</span> <span class="nav-text">代码流程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#整体代码："><span class="nav-number">1.3.1.1.</span> <span class="nav-text">整体代码：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据结构图"><span class="nav-number">1.3.2.</span> <span class="nav-text">数据结构图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协议栈及相关函数结构初始化：inet-init"><span class="nav-number">1.4.</span> <span class="nav-text">协议栈及相关函数结构初始化：inet_init</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#代码结构分析"><span class="nav-number">1.4.1.</span> <span class="nav-text">代码结构分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据结构图-1"><span class="nav-number">1.4.2.</span> <span class="nav-text">数据结构图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备相关初始化"><span class="nav-number">1.5.</span> <span class="nav-text">设备相关初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#代码结构分析-net-dev-init"><span class="nav-number">1.5.1.</span> <span class="nav-text">代码结构分析 -net_dev_init</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码结构分析-module-init"><span class="nav-number">1.5.2.</span> <span class="nav-text">代码结构分析 -module_init:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码结构分析-module-init-1"><span class="nav-number">1.5.3.</span> <span class="nav-text">代码结构分析 -module_init:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#几个问题："><span class="nav-number">1.5.4.</span> <span class="nav-text">几个问题：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据结构图-2"><span class="nav-number">1.5.5.</span> <span class="nav-text">数据结构图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#probe等函数例子："><span class="nav-number">1.5.6.</span> <span class="nav-text">probe等函数例子：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#以wifi芯片举例："><span class="nav-number">1.5.7.</span> <span class="nav-text">以wifi芯片举例：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ldd3上一个虚拟设备的例子：贴过来仅供参考；"><span class="nav-number">1.5.7.1.</span> <span class="nav-text">ldd3上一个虚拟设备的例子：贴过来仅供参考；</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他部分，如子系统的初始化，等分析到了再写"><span class="nav-number">1.6.</span> <span class="nav-text">其他部分，如子系统的初始化，等分析到了再写</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小兴"
      src="/images/headicon2.jpg">
  <p class="site-author-name" itemprop="name">小兴</p>
  <div class="site-description" itemprop="description">始于歧路，愿归于征途</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xdksx/" title="GitHub → https://github.com/xdksx/" rel="noopener" target="_blank"><i class="fa fa-fw fa-github-square"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/ksance@gmail.com" title="E-Mail → ksance@gmail.com"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/572897439" title="FB Page → https://www.facebook.com/572897439" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      friendly link
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://yoursite.com" title="http://yoursite.com" rel="noopener" target="_blank">Title</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小兴</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '06e6b70d396f6928e45a',
      clientSecret: 'cd03b7c657d50a5d76a7fa682c4f8eb48cb15fc3',
      repo        : 'xdksx.github.io',
      owner       : 'xdksx',
      admin       : ['xdksx'],
      id          : 'd1105ec237dfdbb707855f11f3e0f1a2',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
