<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xdksx.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="linux内存系统概述linux的内存系统是一个很复杂的系统，需要从几个角度去分析，里面包含多种机制，比如虚拟地址和物理地址的转换等等；本文是一个系统性的大局观来从几个方面分析内存系统的记录：">
<meta name="keywords" content="memory">
<meta property="og:type" content="article">
<meta property="og:title" content="memory_overiew">
<meta property="og:url" content="https://xdksx.github.io/2021/03/06/memory-overiew/index.html">
<meta property="og:site_name" content="追光者">
<meta property="og:description" content="linux内存系统概述linux的内存系统是一个很复杂的系统，需要从几个角度去分析，里面包含多种机制，比如虚拟地址和物理地址的转换等等；本文是一个系统性的大局观来从几个方面分析内存系统的记录：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/MMU.png">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/NUMA.png">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/numa_zone.png">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/pgtable.png">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/pgtable2.png">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/allalloc.png">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/vmareatree.png">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/moremm.png">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/mm_file.png">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/malloc.png">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/slab.png">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/slaball.png">
<meta property="og:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/slablist.png">
<meta property="og:updated_time" content="2021-03-07T12:36:51.020Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="memory_overiew">
<meta name="twitter:description" content="linux内存系统概述linux的内存系统是一个很复杂的系统，需要从几个角度去分析，里面包含多种机制，比如虚拟地址和物理地址的转换等等；本文是一个系统性的大局观来从几个方面分析内存系统的记录：">
<meta name="twitter:image" content="https://xdksx.github.io/2021/03/06/memory-overiew/MMU.png">

<link rel="canonical" href="https://xdksx.github.io/2021/03/06/memory-overiew/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>memory_overiew | 追光者</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">追光者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小兴的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-观影">

    <a href="/movies/" rel="section"><i class="fa fa-fw fa-film"></i>观影</a>

  </li>
        <li class="menu-item menu-item-阅读">

    <a href="/read/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-心理">

    <a href="/categories/心理/" rel="section"><i class="fa fa-fw fa-heart"></i>心理</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xdksx.github.io/2021/03/06/memory-overiew/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headicon2.jpg">
      <meta itemprop="name" content="小兴">
      <meta itemprop="description" content="始于歧路，愿归于征途">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="追光者">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          memory_overiew
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-07 04:35:25 / 修改时间：20:36:51" itemprop="dateCreated datePublished" datetime="2021-03-07T04:35:25+08:00">2021-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/overiew/" itemprop="url" rel="index"><span itemprop="name">overiew</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="linux内存系统概述"><a href="#linux内存系统概述" class="headerlink" title="linux内存系统概述"></a>linux内存系统概述</h3><p>linux的内存系统是一个很复杂的系统，需要从几个角度去分析，里面包含多种机制，比如虚拟地址和物理地址的转换等等；本文是一个系统性的大局观来从几个方面分析内存系统的记录：<a id="more"></a><br>1 linux内存系统的地址空间：主要解释虚拟内存空间的机制和地址转换关系；<br>2 liunx内存系统的物理内存相关结构和虚拟内存相关结构：主要解释内核用什么样的数据结构来管理内存<br>3 linux内存初始化<br>4 linux内存系统的分配路线：从kernel和用户进程两路分配出发，最后都用到伙伴系统分配内存页；<br>5 linux内存的回收机制简单分析；<br>6 linux下内存的查看等：<br>其中涉及的调试方法和模块代码例子等等，包含在各个子节中；  </p>
<h3 id="linux内存系统的地址空间："><a href="#linux内存系统的地址空间：" class="headerlink" title="linux内存系统的地址空间："></a>linux内存系统的地址空间：</h3><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>一般来说，linux系统在使用时，只要一块物理内存，或者说，即使外部插入多个内存，最后再使用时，也是一个物理内存的地址空间;最开始的系统，使用内存都是直接通过取物理地址写入读取的;<br>而演变为采用虚拟地址空间，并通过MMU地址转换为物理地址，再访问真正的物理内存，其作用，一方面是进一步保护内存防止滥用和增加控制，另一方面，也对每个进程之间起到隔离作用，加强保护；<br>另外，还可以避免因为直接操作物理内存的情况下，不同进程操作时地址的不连续性带来更高的复杂度，更多作用，我想通过进一步学习，可以加深理解；</p>
<h4 id="虚拟地址空间："><a href="#虚拟地址空间：" class="headerlink" title="虚拟地址空间："></a>虚拟地址空间：</h4><ul>
<li>简介：<br>一般来说，linux内核把处理器的虚拟地址空间分为两个部分，底部比较大的部分用于用户进程，顶部则是专用于内核；所以在两个用户进程上下文切换的时候，只会改变下半部分；<br>而内核部分总是不变；所以不同的用户进程，有不同的虚拟地址空间，也就是说，两个不同的进程中的两个变量可以有相同的虚拟地址，但是实际物理内存确是不同的；<br>划分比如4G的内存，1G给到内核，3G给到用户空间；当然可以通过配置修改这种比例；  </li>
<li>举例<br>内核和用户进程，在操作时，变量等结构，函数等打印出来的指针(地址)，是虚拟地址，而实际写入和读取的数据是放在物理内存的，是有唯一的物理内存地址的，那虚拟地址是如何对应到物理内存地址的呢？<br>这个涉及到虚拟地址到物理地址的转换–MMU,借助MMU，linux可以把虚拟地址通过某种映射转换为物理地址；</li>
<li>MMU(内存管理单元):<br>是计算机系统的一个物理部件，通常是CPU的一部分(但不一定)， linux的MMU是一个很复杂的模块，本文暂时不会进行详细的分析，等后面有时间再深入研究：<br>关于MMU是如何将虚拟地址转换为物理地址的过程，可以参考下图：<img src="/2021/03/06/memory-overiew/MMU.png" title="MMU about">
</li>
</ul>
<h3 id="linux内存系统的相关结构："><a href="#linux内存系统的相关结构：" class="headerlink" title="linux内存系统的相关结构："></a>linux内存系统的相关结构：</h3><p>主要分为这几个部分：</p>
<ul>
<li>基础的，物理内存：</li>
<li>和MMU相关的</li>
<li>和虚拟内存相关的：和内核相关的，和用户进程相关的；<h4 id="基础的，物理内存："><a href="#基础的，物理内存：" class="headerlink" title="基础的，物理内存："></a>基础的，物理内存：</h4></li>
<li>NUMA概念：VM中流行的第一个主要概念是非均匀内存访问(NUMA)。在大型机器中，内存可能被根据与处理器的“距离”而产生不同的存取成本，划分为多个部分(结点)。例如，可能有一个内存库分配给每个CPU或一个内存库非常适合DMA近设备卡。每个部分称为一个node,由挂在同一个CPU下的一片连续的物理内存组成，在内核中使用pg_data_t进行抽象.<br>可以从linux/mmzone.h来找到相关结构：<img src="/2021/03/06/memory-overiew/NUMA.png" title="NUMA about">
</li>
</ul>
<ul>
<li>NUMA的结点node和相关的结构：zone:  <img src="/2021/03/06/memory-overiew/numa_zone.png" title="numa_zone about">
由于一些特殊的应用场景，导致只能分配特定地址范围内的内存（比如老式的ISA设备DMA时只能使用前16M内存；比如kmalloc只能分配低端内存，而不能分配高端内存），因此在node中又将内存细分为zone。<br>zone 有以下几种类型，由zone结构中的flags标识；<br> 1) ZONE_DMA：定义适合DMA的内存域，该区域的长度依赖于处理器类型。比如ARM所有地址都可以进行DMA，所以该值可以很大，或者干脆不定义DMA类型的内存域。而在IA-32的处理器上，一般定义为16M。<br> 2) ZONE_DMA32：只在64位系统上有效，为一些32位外设DMA时分配内存。如果物理内存大于4G，该值为4G，否则与实际的物理内存大小相同。<br> 3) ZONE_NORMAL：定义可直接映射到内核空间的普通内存域。在64位系统上，如果物理内存小于4G，该内存域为空。而在32位系统上，该值最大为896M。<br> 4) ZONE_HIGHMEM：只在32位系统上有效，标记超过896M范围的内存。在64位系统上，由于地址空间巨大，超过4G的内存都分布在ZONE_NORMA内存域。<br> 5) ZONE_MOVABLE：伪内存域，为了实现减小内存碎片的机制。</li>
</ul>
<ul>
<li><p>zone结构下的free_area,free_list和伙伴系统：<br>简单的说，就是zone下维护的free_area,是维护2^n个page的内存块的链表的数据结构，用来方便分配指定大小的内存页以及进行合并，拆分等，解决页外碎片的机制：<br>更详细可以参考：<a href="http://blog.chinaunix.net/uid-30282771-id-5185451.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-30282771-id-5185451.html</a><br>或者翻阅资料；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/buddyinfo </span><br><span class="line">Node <span class="number">0</span>, zone      DMA      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">3</span> </span><br><span class="line">Node <span class="number">0</span>, zone    DMA32      <span class="number">4</span>      <span class="number">2</span>      <span class="number">3</span>     <span class="number">28</span>    <span class="number">149</span>     <span class="number">21</span>     <span class="number">13</span>      <span class="number">8</span>      <span class="number">1</span>      <span class="number">2</span>    <span class="number">178</span> </span><br><span class="line">Node <span class="number">0</span>, zone   Normal      <span class="number">2</span>     <span class="number">84</span>     <span class="number">46</span>     <span class="number">23</span>     <span class="number">13</span>     <span class="number">13</span>     <span class="number">15</span>     <span class="number">21</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>page：即物理页，物理内存是按页为单元进行分配管理的，一页通常是4k</p>
</li>
<li>以下是在linux4.8中以上各个数据结构的定义：<br>linux/mmzone.h pg_data_t:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">	<span class="keyword">int</span> nr_zones;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP	<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_NO_BOOTMEM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must be held any time you expect node_start_pfn, node_present_pages</span></span><br><span class="line"><span class="comment">	 * or node_spanned_pages stay constant.  Holding this will also</span></span><br><span class="line"><span class="comment">	 * guarantee that any pfn_valid() stays that way.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment">	 * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_pfn;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_spanned_pages; <span class="comment">/* total size of physical page</span></span><br><span class="line"><span class="comment">					     range, including holes */</span></span><br><span class="line">	<span class="keyword">int</span> node_id;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>	<span class="comment">/* Protected by</span></span><br><span class="line"><span class="comment">					   mem_hotplug_begin/end() */</span></span><br><span class="line">	<span class="keyword">int</span> kswapd_order;</span><br><span class="line">	<span class="keyword">enum</span> zone_type kswapd_classzone_idx;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="keyword">int</span> kcompactd_max_order;</span><br><span class="line">	<span class="keyword">enum</span> zone_type kcompactd_classzone_idx;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">	<span class="comment">/* Lock serializing the migrate rate limiting window */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> numabalancing_migrate_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Rate limiting time interval */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> numabalancing_migrate_next_window;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of pages migrated during the rate limiting time interval */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> numabalancing_migrate_nr_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a per-node reserve of pages that are not available</span></span><br><span class="line"><span class="comment">	 * to userspace allocations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line">	<span class="keyword">spinlock_t</span>		lru_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">	 * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> split_queue_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">split_queue</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> split_queue_len;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>		<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on</span></span><br><span class="line"><span class="comment">	 * this node's LRU.  Maintained by the pageout code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> inactive_ratio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-node vmstats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br><span class="line"><span class="keyword">pg_data_t</span>中描述了node的所有基本元素：</span><br><span class="line">    <span class="number">1</span>) node_zones: 该node包含的内存域zone</span><br><span class="line">    <span class="number">2</span>) node_zonelists：该node的备选节点及内存域列表，后面会详细说明。</span><br><span class="line">    <span class="number">3</span>) node_mem_map：linux为每个物理页分配了一个<span class="class"><span class="keyword">struct</span> <span class="title">page</span>的管理结构体，并形成了一个结构体数组，<span class="title">node_mem_map</span>即为数组的指针；<span class="title">pfn_to_page</span>和<span class="title">page_to_pfn</span>都借助该数组实现。</span></span><br><span class="line"><span class="class">    4) <span class="title">node_start_pfn</span>：该<span class="title">node</span>中内存的起始页帧号</span></span><br><span class="line"><span class="class">    5) <span class="title">node_present_pages</span>：该<span class="title">node</span>中所有的物理<span class="title">page</span>页数</span></span><br><span class="line"><span class="class">    6) <span class="title">node_spanned_pages</span>：该<span class="title">node</span>地址范围内的所有<span class="title">page</span>页数，包括空洞；目前还不清楚什么情况导致与<span class="title">node_present_pages</span>不同。</span></span><br><span class="line"><span class="class">    7) <span class="title">kswapd</span>：负责回收该<span class="title">node</span>内存的内核线程，每个<span class="title">node</span>对应一个内核线程<span class="title">kswapd</span>。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>zone:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> watermark[NR_WMARK];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We don't know if the memory that we're going to allocate will be freeable</span></span><br><span class="line"><span class="comment">	 * or/and it will be released eventually, so to avoid totally wasting several</span></span><br><span class="line"><span class="comment">	 * GB of ram we must reserve some of the lower zone memory (otherwise we risk</span></span><br><span class="line"><span class="comment">	 * to run OOM on the lower zones despite there's tons of freeable ram</span></span><br><span class="line"><span class="comment">	 * on the higher zones). This array is recalculated at runtime if the</span></span><br><span class="line"><span class="comment">	 * sysctl_lowmem_reserve_ratio sysctl changes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on</span></span><br><span class="line"><span class="comment">	 * this zone's LRU.  Maintained by the pageout code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> inactive_ratio;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a per-zone reserve of pages that should not be</span></span><br><span class="line"><span class="comment">	 * considered dirtyable memory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		dirty_balance_reserve;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment">	 * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		zone_start_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">	 * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">	 * 	spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">	 * is calculated as:</span></span><br><span class="line"><span class="comment">	 *	present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">	 * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">	 * bootmem allocator):</span></span><br><span class="line"><span class="comment">	 *	managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">	 * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">	 * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">	 * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">	 * and thresholds.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Locking rules:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">	 * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">	 * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">	 * quite infrequently.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">	 * frequently read in proximity to zone-&gt;lock.  It's good to</span></span><br><span class="line"><span class="comment">	 * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">	 * mem_hotplug_begin/end(). Any reader who can't tolerant drift of</span></span><br><span class="line"><span class="comment">	 * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Read access to managed_pages should be safe because it's unsigned</span></span><br><span class="line"><span class="comment">	 * long. Write access to zone-&gt;managed_pages and totalram_pages are</span></span><br><span class="line"><span class="comment">	 * protected by managed_page_count_lock at runtime. Idealy only</span></span><br><span class="line"><span class="comment">	 * adjust_managed_page_count() should be used instead of directly</span></span><br><span class="line"><span class="comment">	 * touching zone-&gt;managed_pages and totalram_pages.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		managed_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		spanned_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		present_pages;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of MIGRATE_RESERVE page block. To maintain for just</span></span><br><span class="line"><span class="comment">	 * optimization. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span>			nr_migrate_reserve_block;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment">	 * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment">	 * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">	<span class="keyword">seqlock_t</span>		span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * wait_table		-- the array holding the hash table</span></span><br><span class="line"><span class="comment">	 * wait_table_hash_nr_entries	-- the size of the hash table array</span></span><br><span class="line"><span class="comment">	 * wait_table_bits	-- wait_table_size == (1 &lt;&lt; wait_table_bits)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The purpose of all these is to keep track of the people</span></span><br><span class="line"><span class="comment">	 * waiting for a page to become available and make them</span></span><br><span class="line"><span class="comment">	 * runnable again when possible. The trouble is that this</span></span><br><span class="line"><span class="comment">	 * consumes a lot of space, especially when so few things</span></span><br><span class="line"><span class="comment">	 * wait on pages at a given time. So instead of using</span></span><br><span class="line"><span class="comment">	 * per-page waitqueues, we use a waitqueue hash table.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The bucket discipline is to sleep on the same queue when</span></span><br><span class="line"><span class="comment">	 * colliding and wake all in that wait queue when removing.</span></span><br><span class="line"><span class="comment">	 * When something wakes, it must check to be sure its page is</span></span><br><span class="line"><span class="comment">	 * truly available, a la thundering herd. The cost of a</span></span><br><span class="line"><span class="comment">	 * collision is great, but given the expected load of the</span></span><br><span class="line"><span class="comment">	 * table, they should be so rare as to be outweighed by the</span></span><br><span class="line"><span class="comment">	 * benefits from the saved space.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __wait_on_page_locked() and unlock_page() in mm/filemap.c, are the</span></span><br><span class="line"><span class="comment">	 * primary users of these fields, and in mm/page_alloc.c</span></span><br><span class="line"><span class="comment">	 * free_area_init_core() performs the initialization of them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span>	*wait_table;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		wait_table_hash_nr_entries;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		wait_table_bits;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line">	<span class="comment">/* free areas of different sizes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone flags, see below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lru_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>		<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Evictions &amp; activations on the inactive file list */</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		inactive_age;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">	 * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">	 * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_cached_free_pfn;</span><br><span class="line">	<span class="comment">/* pfn where async and sync compaction migration scanner should start */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_cached_migrate_pfn[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">	 * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">	 * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		compact_considered;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		compact_defer_shift;</span><br><span class="line">	<span class="keyword">int</span>			compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">	<span class="keyword">bool</span>			compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad3_)</span><br><span class="line">	<span class="comment">/* Zone statistics */</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure></p>
<p>free_area:注意在zone定义中数组大小只有11，意味着是只支持到2^10个页大小的内存块<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">/include/linux/mm_types.h</span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each physical page in the system has a struct page associated with</span></span><br><span class="line"><span class="comment"> * it to keep track of whatever it is we are using the page for at the</span></span><br><span class="line"><span class="comment"> * moment. Note that we have no way to track which tasks are using</span></span><br><span class="line"><span class="comment"> * a page, though if it is a pagecache page, rmap structures can tell us</span></span><br><span class="line"><span class="comment"> * who is mapping it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The objects in struct page are organized in double word blocks in</span></span><br><span class="line"><span class="comment"> * order to allows us to use atomic double word operations on portions</span></span><br><span class="line"><span class="comment"> * of struct page. That is currently only used by slub but the arrangement</span></span><br><span class="line"><span class="comment"> * allows the use of atomic double word operations on the flags/mapping</span></span><br><span class="line"><span class="comment"> * and lru list pointers also.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="comment">/* First double word block */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;		<span class="comment">/* Atomic flags, some possibly</span></span><br><span class="line"><span class="comment">					 * updated asynchronously */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span>	<span class="comment">/* If low bit clear, points to</span></span><br><span class="line"><span class="comment">						 * inode address_space, or NULL.</span></span><br><span class="line"><span class="comment">						 * If page mapped as anonymous</span></span><br><span class="line"><span class="comment">						 * memory, low bit is set, and</span></span><br><span class="line"><span class="comment">						 * it points to anon_vma object:</span></span><br><span class="line"><span class="comment">						 * see PAGE_MAPPING_ANON below.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">		<span class="keyword">void</span> *s_mem;			<span class="comment">/* slab first object */</span></span><br><span class="line">		<span class="keyword">atomic_t</span> compound_mapcount;	<span class="comment">/* first tail page */</span></span><br><span class="line">		<span class="comment">/* page_deferred_list().next	 -- second tail page */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Second double word */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">union</span> &#123;</span><br><span class="line">			<span class="keyword">pgoff_t</span> index;		<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">			<span class="keyword">void</span> *freelist;		<span class="comment">/* sl[aou]b first free object */</span></span><br><span class="line">			<span class="comment">/* page_deferred_list().prev	-- second tail page */</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line">	defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span><br><span class="line">			<span class="comment">/* Used for cmpxchg_double in slub */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> counters;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Keep _count separate from slub cmpxchg_double data.</span></span><br><span class="line"><span class="comment">			 * As the rest of the double word is protected by</span></span><br><span class="line"><span class="comment">			 * slab_lock but _count is not.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> counters;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">union</span> &#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * Count of ptes mapped in mms, to show</span></span><br><span class="line"><span class="comment">					 * when page is mapped &amp; limit reverse</span></span><br><span class="line"><span class="comment">					 * map searches.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					<span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* SLUB */</span></span><br><span class="line">						<span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">						<span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">						<span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">					&#125;;</span><br><span class="line">					<span class="keyword">int</span> units;	<span class="comment">/* SLOB */</span></span><br><span class="line">				&#125;;</span><br><span class="line">				<span class="keyword">atomic_t</span> _count;		<span class="comment">/* Usage count, see below. */</span></span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> active;	<span class="comment">/* SLAB */</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Third double word block</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * WARNING: bit 0 of the first word encode PageTail(). That means</span></span><br><span class="line"><span class="comment">	 * the rest users of the storage space MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">	 * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>	<span class="comment">/* Pageout list, eg. active_list</span></span><br><span class="line"><span class="comment">					 * protected by zone-&gt;lru_lock !</span></span><br><span class="line"><span class="comment">					 * Can be used as a generic list</span></span><br><span class="line"><span class="comment">					 * by the page owner.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span> <span class="comment">/* ZONE_DEVICE pages are never on an</span></span><br><span class="line"><span class="comment">					    * lru or handled by a slab</span></span><br><span class="line"><span class="comment">					    * allocator, this points to the</span></span><br><span class="line"><span class="comment">					    * hosting device page map.</span></span><br><span class="line"><span class="comment">					    */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>		<span class="comment">/* slub per cpu partial pages */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span>	<span class="comment">/* Next partial slab */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">			<span class="keyword">int</span> pages;	<span class="comment">/* Nr of partial slabs left */</span></span><br><span class="line">			<span class="keyword">int</span> pobjects;	<span class="comment">/* Approximate # of objects */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line">			<span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span>	<span class="comment">/* Used by SLAB</span></span><br><span class="line"><span class="comment">						 * when destroying via RCU</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">		<span class="comment">/* Tail pages of compound page */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head; <span class="comment">/* If bit zero is set */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* First tail page only */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * On 64 bit system we have enough space in struct page</span></span><br><span class="line"><span class="comment">			 * to encode compound_dtor and compound_order with</span></span><br><span class="line"><span class="comment">			 * unsigned int. It can help compiler generate better or</span></span><br><span class="line"><span class="comment">			 * smaller code on some archtectures.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> compound_dtor;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> compound_dtor;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> __pad;	<span class="comment">/* do not overlay pmd_huge_pte</span></span><br><span class="line"><span class="comment">						 * with compound_head to avoid</span></span><br><span class="line"><span class="comment">						 * possible bit 0 collision.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">			<span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">		&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remainder is not double word aligned */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;		<span class="comment">/* Mapping-private opaque data:</span></span><br><span class="line"><span class="comment">					 	 * usually used for buffer_heads</span></span><br><span class="line"><span class="comment">						 * if PagePrivate set; used for</span></span><br><span class="line"><span class="comment">						 * swp_entry_t if PageSwapCache;</span></span><br><span class="line"><span class="comment">						 * indicates order in the buddy</span></span><br><span class="line"><span class="comment">						 * system if PG_buddy is set.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SPLIT_PTE_PTLOCKS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">		<span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span>	<span class="comment">/* SL[AU]B: Pointer to slab */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment">	 * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment">	 * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment">	 * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment">	 * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment">	 * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">virtual</span>;			<span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">					   not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * kmemcheck wants to track the status of each byte in a page; this</span></span><br><span class="line"><span class="comment">	 * is a pointer to such a status block. NULL if not tracked.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">	<span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The struct page can be forced to be double word aligned so that atomic ops</span></span><br><span class="line"><span class="comment"> * on double words work. The SLUB allocator can make use of such a feature.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAVE_ALIGNED_STRUCT_PAGE</span></span><br><span class="line">	__aligned(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">;</span><br></pre></td></tr></table></figure></p>
<h5 id="实践：操作zone等："><a href="#实践：操作zone等：" class="headerlink" title="实践：操作zone等："></a>实践：操作zone等：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">  * Author: ksx</span></span><br><span class="line"><span class="comment">  * File name: sysctl_example.c</span></span><br><span class="line"><span class="comment">  * Description: sysctl example</span></span><br><span class="line"><span class="comment">  * Date: 2021-02-26</span></span><br><span class="line"><span class="comment">  *********************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/swap.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/topology.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/mm_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">pages</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">sysctl_example_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    pages = alloc_pages(GFP_KERNEL,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(!pages) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        printk(<span class="string">"alloc_pages Successfully!\n"</span>); </span><br><span class="line">        printk(<span class="string">"page_address(pages) = 0x%lx\n"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_address(pages));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">arr</span> = <span class="title">NODE_DATA</span>(<span class="title">numa_node_id</span>())-&gt;<span class="title">node_zones</span>;</span></span><br><span class="line">   <span class="comment">// printk(KERN_INFO,"zone: some:%ld\n",z1.managed_pages);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zoneli</span> = <span class="title">node_zonelist</span>(<span class="title">numa_node_id</span>(),<span class="title">GFP_KERNEL</span>);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> free_areasize = <span class="keyword">sizeof</span>(arr-&gt;free_area)/<span class="keyword">sizeof</span>(arr-&gt;free_area[<span class="number">0</span>]);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">fa</span> = <span class="title">arr</span>-&gt;<span class="title">free_area</span>;</span></span><br><span class="line">    <span class="keyword">int</span> freearea0_nrfree = arr-&gt;free_area[<span class="number">0</span>].nr_free;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">"sysctl registercess %ld num_node_id:%d freeareasize :%u freelist:: %ld nr_free:%d\n"</span>,nr_free_buffer_pages(),numa_node_id(),free_areasize,<span class="keyword">sizeof</span>(fa-&gt;free_list)/<span class="keyword">sizeof</span>(fa-&gt;free_list[<span class="number">0</span>]),freearea0_nrfree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">sysctl_example_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"sysctl unregister success.\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(pages) </span><br><span class="line">    &#123;</span><br><span class="line">        __free_pages(pages,<span class="number">8</span>);   <span class="comment">// 释放所分配的</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">        printk(<span class="string">"__free_pages ok!\n"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(sysctl_example_init);</span><br><span class="line">module_exit(sysctl_example_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="和MMU相关的："><a href="#和MMU相关的：" class="headerlink" title="和MMU相关的："></a>和MMU相关的：</h4><ul>
<li>TLB:<br>地址转换需要几次内存访问，内存访问相对CPU速度较慢。为了避免在地址转换上花费宝贵的处理器周期，cpu维护了一个名为翻译后备缓冲区(translation Lookaside Buffer, TLB)的此类转换缓存。</li>
<li>Huge Pages:Linux中有两种机制支持将物理内存映射到大页面。第一个是HugeTLB文件系统，或hugetlbfs。它是一个使用RAM作为后备存储的伪文件系统。对于在该文件系统中创建的文件，数据驻留在内存中，并使用大页进行映射。</li>
<li>page tables:页表,页表是用来建立用户进程虚拟地址空间和系统物理内存(页帧等)之间的关联：即通过上述图1可以看到线性(虚拟)地址和页表的关系，linux用三级甚至4级页表来管理内存页<br>通过页表，每个进程提供一致的虚拟地址空间，应用程序看到的地址空间是一个连续的内存区，该表也将虚拟内存页映射到物理内存，进而支持共享内存的实现，即几个进程共享的内存；<br>相关结构： /asm-arch/page.h  asm-arch/pgtable.h和具体的体系架构相关；  </li>
</ul>
<p>每个进程都有一个指针(mm_struct→pgd)指向它自己的页全局目录(pgd)， pgd是一个物理页帧。这个框架包含一个类型为pgd_t的数组，pgd_t是在&lt;asm/page.h&gt;中定义的架构特定类型。根据架构的不同，页表的加载方式也不同。在x86上，通过将mm_struct→pgd复制到cr3寄存器来加载进程页表，这有冲洗TLB的副作用。事实上，这就是函数__flush_tlb()在依赖于体系结构的代码中实现的方式。<br>PGD表中的每个活动条目指向一个包含pmd_t类型的页中间目录(PMD)项数组的页框架，该页框架又指向一个包含pte_t类型的页表项(PTE)的页框架，pte_t类型的页表项最终指向包含实际用户数据的页框架。如果页面被交换到后备存储，交换项将存储在PTE中，并在页面故障期间由do_swap_page()使用，以查找包含页面数据的交换项。  </p>
<p>页表项的一些操作函数:pgd_alloc(如 /arch/arm64/mm/pgd.c),pte_page,pud_alloc等等<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">页表：层次化的页表用于支持对大地址空间的快速，高效管理；</span><br><span class="line">用于建立用户进程的虚拟地址空间和系统物理内存（内存，页帧）之间的关联</span><br><span class="line">页表也用于向每个进程提供一致的虚拟地址空间，应用程序看到的地址空间是一个连续的内存区，该表也将虚拟内存页映射到物理内存，因而支持共享内存的实现；</span><br><span class="line">内核内存管理使用四级页表，不管底层处理器，一个页表有<span class="number">1024</span>项，每项对应一个页(<span class="number">4</span>K)</span><br><span class="line">内存虚拟地址的分解：</span><br><span class="line">页表格式：   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * These are used to make use of C type-checking..</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pte; &#125; <span class="keyword">pte_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pmd; &#125; <span class="keyword">pmd_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_PGTABLE_LEVELS == 4</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pud; &#125; <span class="keyword">pud_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pgd; &#125; <span class="keyword">pgd_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pgprot; &#125; <span class="keyword">pgprot_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">pgtable_t</span>;</span></span><br><span class="line"></span><br><span class="line">用于处理内存页的体系结构相关状态的函数以及页表项操作函数</span><br></pre></td></tr></table></figure></p>
<img src="/2021/03/06/memory-overiew/pgtable.png" title="pgtable about">
<img src="/2021/03/06/memory-overiew/pgtable2.png" title="pgtable about">
<p>更多参考：<a href="https://www.kernel.org/doc/gorman/html/understand/understand006.html" target="_blank" rel="noopener">https://www.kernel.org/doc/gorman/html/understand/understand006.html</a></p>
<ul>
<li>和虚拟内存相关的：<br>内核相关：<br>内核内存分配器：slab/slub/slob,具体使用场景和机制见下 内核的内存分配<br>eg:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>		<span class="comment">//slab描述符的三个双向循环链表中的一个</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff;	<span class="comment">//slab中第一个对象</span></span><br><span class="line">	<span class="keyword">void</span> *s_mem;			<span class="comment">//slab中第一个对象的地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;		<span class="comment">//当前正在使用的slab中的对象的个数</span></span><br><span class="line">	<span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;		<span class="comment">//slab中第一个空闲对象的下标。</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> nodeid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用户进程相关：具体怎么用见下 用户进程的内存分配<br>/include/linux/mm_types.h vm_area_struct<br>在 task_struct-&gt;mm_struct-&gt;vm_area_struct* 链表<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct defines a memory VMM memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task.  A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="keyword">pgprot_t</span> vm_page_prot;		<span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">	 * linkage into the address_space-&gt;i_mmap interval tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</span><br><span class="line">	&#125; shared;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">	 * list, after a COW of one of the file pages.	A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">	 * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> <span class="comment">/* Serialized by mmap_sem &amp;</span></span><br><span class="line"><span class="comment">					  * page_table_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>	<span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Information about our backing store: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">					   units */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">	<span class="keyword">void</span> * vm_private_data;		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="linux内存初始化简介："><a href="#linux内存初始化简介：" class="headerlink" title="linux内存初始化简介："></a>linux内存初始化简介：</h3><ul>
<li><p>概述：<br>初始化大都是建立全局数据结构并做初始化，设置系统状态，寄存器等等，linux内存也是大致如此；<br>linux内存初始化有个过程比较特别，就是在建立起这个内存管理之前，也要内存，但是此时是不能用内存管理接口的，那在这期间，是使用了一个额外的简化形式的内存管理模块(bootmem)<br>在初始化完成内存管理后，再丢弃掉；<br>linux内存初始化主要是体系架构相关的初始化和机器无关的初始化：前者主要是统计系统可用内存总数，以及cpu模型，结点node数量和内存域之间的分配情况，后者主要是建立起前面介绍的各个必要结构，比如pg_data_t;前者完成后，才能完成后者；<br>我们可以通过一个宏 mmzone.h: #define NODE_DATA(nid)        (&amp;contig_page_data) 来获取到对应node编号的 pg_data_t实例，进而进行操作；  </p>
</li>
<li><p>系统启动时内存的的初始化流程：<br>在初始化过程中主要包含以下几个步骤，在如下源文件中：<br>依然是从：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> arch/ia64/kernel/head.S, line <span class="number">413</span></span><br><span class="line">    arch/arm64/kernel/head.S, line <span class="number">453</span></span><br><span class="line">    等都能找到其调用start_kernel，这个函数就是用来启动内核；</span><br><span class="line">    注意这个头文件：include/linux/start_kernel.h, line <span class="number">11</span> (as a prototype)</span><br><span class="line">    和这个实现文件：init/main.c, line <span class="number">849</span> (as a function)</span><br><span class="line">```c</span><br><span class="line">    head.S -&gt;start_kernel(init/main.c)</span><br><span class="line">      lock_kernel();<span class="comment">//首先让lock_depth变量自增，然后判断结果是否为0，如果是，则进行对信号量的自减操作，类似于PV操作</span></span><br><span class="line">   start_kernel()函数会做很多init初始化，里面自然也有内存相关的初始化：</span><br><span class="line">       setup_arch 体系结构相关的初始化</span><br><span class="line">       setup_per_cpu_areas 每个cpu的初始化</span><br><span class="line">       build_all_zonelists 初始化建立结点和内存区域</span><br><span class="line">       mem_init  特定于体系结构的，用于停用bootmem分配器并迁移到内存管理函数</span><br><span class="line">       kmem_cache_init:初始化内核内部小块内存区的分配器</span><br><span class="line">       setup_per_cpu_pageset：zone下为pageset数组的第一个数组元素分配内存，分配第一个数组元素；</span><br><span class="line">关于结点和内存域初始化：</span><br><span class="line">```cpp</span><br><span class="line">在page_alloc.c 中</span><br><span class="line">void __init build_all_zonelists(void)遍历所有结点进行初始化</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; numnodes ; i++)</span><br><span class="line">		build_zonelists(NODE_DATA(i));<span class="comment">//通过这个结构可以拿到所有的node_data[] pg_data_t</span></span><br><span class="line">	printk(<span class="string">"Built %i zonelists\n"</span>, numnodes);</span><br><span class="line">&#125;</span><br><span class="line">free_area: mmzone.h </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过模块类似的获取机制，来获取当前系统的页详情，以及分配时的动态变化；<br>build_zonelists：这个函数任务为：在当前处理的结点的内存域和其他结点的内存域之间建立一个等级次序，并下来按这种次序分配内存；<br>等级次序例子：内存要分配高端内存，则首先企图在当前结点的高端内存中找一个大小合适的空闲段，若失败，则查看该结点的普通内存域，若还是失败，则看<br>该结点的DMA内存域进行分配，还失败就去找其他结点；备选结点要尽量靠近主结点；<br>层次结构：<br>首先分配高端内存：廉价，在于内核没有任何部分依赖该内存域分配的内存；<br>接着普通内存：许多内核数据结构必须保存在该区域，而不能放置在高端内存域；普通内存用尽就紧急；<br>最后是DMA内存域，它用于外设和系统的数据传输；<br>没有再考虑其他内存结点 ；备选结点也有一个等级次序；<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">在初始化后，物理内存大致是这样分布的：</span><br><span class="line">&#123;% asset_img memlayout.png memlayout %&#125;</span><br><span class="line">我们也可以在procfs中查看：</span><br><span class="line">```cpp</span><br><span class="line">sudo cat /<span class="keyword">proc</span>/iomem</span><br><span class="line">00000000-00000fff :<span class="title"> reserved</span></span><br><span class="line"><span class="title">00001000-0009fbff</span> :<span class="title"> System</span> RAM</span><br><span class="line">0009fc00-0009ffff :<span class="title"> reserved</span></span><br><span class="line"><span class="title">000a0000-000bffff</span> :<span class="title"> PCI</span> Bus 0000:00</span><br><span class="line">000c0000-000c7fff :<span class="title"> Video</span> ROM</span><br><span class="line">000e2000-000ef3ff :<span class="title"> Adapter</span> ROM</span><br><span class="line">000f0000-000fffff :<span class="title"> reserved</span></span><br><span class="line"><span class="title"></span>  000f0000-000fffff :<span class="title"> System</span> ROM</span><br><span class="line">00100000-dffeffff :<span class="title"> System</span> RAM</span><br><span class="line">  01000000-0182e000 :<span class="title"> Kernel</span> code</span><br><span class="line">  0182e001-01f4dfff :<span class="title"> Kernel</span> data</span><br><span class="line">  020cd000-02207fff :<span class="title"> Kernel</span> bss</span><br><span class="line">dfff0000-dfffffff :<span class="title"> ACPI</span> Tables</span><br><span class="line">e0000000-fdffffff :<span class="title"> PCI</span> Bus 0000:00</span><br><span class="line"><span class="title">  e0000000-e0ffffff</span> : 0000:00:02.0</span><br><span class="line"><span class="title">    e0000000-e0ffffff</span> :<span class="title"> vmwgfx</span> probe</span><br><span class="line"><span class="title">  f0000000-f01fffff</span> : 0000:00:02.0</span><br><span class="line"><span class="title">    f0000000-f01fffff</span> :<span class="title"> vmwgfx</span> probe</span><br><span class="line"><span class="title">  f0200000-f021ffff</span> : 0000:00:03.0</span><br><span class="line"><span class="title">    f0200000-f021ffff</span> :<span class="title"> e1000</span></span><br><span class="line"><span class="title"></span> <span class="title"> f0400000-f07fffff</span> : 0000:00:04.0</span><br><span class="line"><span class="title">    f0400000-f07fffff</span> :<span class="title"> vboxguest</span></span><br><span class="line"><span class="title"></span> <span class="title"> f0800000-f0803fff</span> : 0000:00:04.0</span><br><span class="line"><span class="title">  f0804000-f0804fff</span> : 0000:00:06.0</span><br><span class="line"><span class="title">    f0804000-f0804fff</span> :<span class="title"> ohci_hcd</span></span><br><span class="line"><span class="title"></span> <span class="title"> f0806000-f0807fff</span> : 0000:00:0d.0</span><br><span class="line"><span class="title">    f0806000-f0807fff</span> :<span class="title"> ahci</span></span><br><span class="line"><span class="title">fec00000-fec00fff</span> :<span class="title"> reserved</span></span><br><span class="line"><span class="title"></span> <span class="title"> fec00000-fec003ff</span> :<span class="title"> IOAPIC</span> 0</span><br><span class="line">fee00000-fee00fff :<span class="title"> Local</span> APIC</span><br><span class="line"><span class="title">  fee00000-fee00fff</span> :<span class="title"> reserved</span></span><br><span class="line"><span class="title">fffc0000-ffffffff</span> :<span class="title"> reserved</span></span><br><span class="line"><span class="title">100000000-11fffffff</span> :<span class="title"> System</span> RAM</span><br><span class="line"></span><br><span class="line">如果想看BIOS等占用的物理内存情况，也可以</span><br><span class="line"><span class="title"> dmesg|</span> grep<span class="title"> BIOS</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> e820:</span> BIOS-provided<span class="title"> physical</span> RAM<span class="title"> map:</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x0000000000000000-0x000000000009fbff]<span class="title"> usable</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x000000000009fc00-0x000000000009ffff]<span class="title"> reserved</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000000f0000-0x00000000000fffff]<span class="title"> reserved</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x0000000000100000-0x00000000dffeffff]<span class="title"> usable</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000dfff0000-0x00000000dfffffff]<span class="title"> ACPI</span> data</span><br><span class="line">[    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000fec00000-0x00000000fec00fff]<span class="title"> reserved</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000fee00000-0x00000000fee00fff]<span class="title"> reserved</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000fffc0000-0x00000000ffffffff]<span class="title"> reserved</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x0000000100000000-0x000000011fffffff]<span class="title"> usable</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> SMBIOS</span> 2.5<span class="title"> present.</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> DMI:</span> innotek<span class="title"> GmbH</span> VirtualBox/VirtualBox,<span class="title"> BIOS</span> VirtualBox 12/01/2006</span><br><span class="line">[    0.000000]<span class="title"> ACPI:</span> DSDT 0x00000000DFFF0470 002325 (v02<span class="title"> VBOX</span> <span class="title">  VBOXBIOS</span> 00000002<span class="title"> INTL</span> 20100528)</span><br><span class="line">[    0.000000]<span class="title"> Calgary:</span> detecting<span class="title"> Calgary</span> via<span class="title"> BIOS</span> EBDA<span class="title"> area</span></span><br><span class="line"><span class="title">[</span>    5.020947]<span class="title"> BIOS</span> EDD<span class="title"> facility</span> v0.16 2004-Jun-25, 0<span class="title"> devices</span> found</span><br></pre></td></tr></table></figure></p>
<p>更多见源码和其他文章参考：eg: <a href="https://www.kernel.org/doc/gorman/html/understand/understand008.html" target="_blank" rel="noopener">https://www.kernel.org/doc/gorman/html/understand/understand008.html</a></p>
<h3 id="linux内存分配："><a href="#linux内存分配：" class="headerlink" title="linux内存分配："></a>linux内存分配：</h3><h4 id="linux内存分配图谱："><a href="#linux内存分配图谱：" class="headerlink" title="linux内存分配图谱："></a>linux内存分配图谱：</h4><img src="/2021/03/06/memory-overiew/allalloc.png" title="allalloc">
<h4 id="linux内存用户进程分配"><a href="#linux内存用户进程分配" class="headerlink" title="linux内存用户进程分配:"></a>linux内存用户进程分配:</h4><h5 id="用于进程内存相关机制："><a href="#用于进程内存相关机制：" class="headerlink" title="用于进程内存相关机制："></a>用于进程内存相关机制：</h5><p> A:简介：</p>
<ul>
<li>进程的虚拟地址空间技术使得不同进程可以同时运行，而不会干扰到其他进程的内存；而所有进程的关联，在于物理内存中的页帧和所有进程虚拟地址空间中的页之间的关联：逆向映射，从虚拟内存页追踪物理页，缺页处理：从块设备读取数据填充虚拟地址空间；</li>
<li>在巨大的线性地址空间中有很少的段可以用于各个用户空间进程，这些段需要被内核管理</li>
<li>内核信任自身，不信任用户进程，所以用户进程在操作地址时需要接受权限等的检查</li>
<li>fork-exec模型：写时复制 </li>
</ul>
<p>B:进程虚拟地址空间</p>
<ul>
<li>用户进程：0–TASK_SIZE-1 ,其上是内核地址 (虚拟地址：内核1G,进程3G：32位）<br>进程地址空间布局：text段，动态库代码,全局变量和动态产生数据的堆，局部变量和实现函数的栈，环境变量和命令行参数的段，将文件内容映射到虚拟地址空间中的内存映射；（mm_type.h: 见mm_struct的定义)</li>
<li>建立内存空间布局：<br>(1) 输入./xxx文件运行时，由exec系统调用执行，并通过load_elf_binary函数装载一个ELF二进制文件，elf装载涉及太复杂流程，只看重要的；<br>(2) randomsize_via_space设置，用于启动地址随机化，可能会拖慢cpu速度<br>(3) 布局工作由arch_pick_mmap_layout完成，和体系结构相关；用户通过/proc/sys/kernel/legacy_va_layout输出得到指示，是执行新布局还是旧布局，无非是栈的上界确定和mmap的上下界确定等，最后确定栈的开始位置，mmap开始位置和堆的开始位置等等，这样便完成了布局<br>到这个时候，就会建立在task结构中的mm结构中，初始化各个段的位置，比如text段，堆栈段开始结束等；也会建立起vm_area_struct;<br>这里可能会有个疑问，就是vm_area_struct和进程中的数据段，代码段和堆栈段的关系：可能会认为一个vm_area_struct就是一个段，可能是代码段和数据段，但是实际实践发现不是；<br>vm_area_struct是进程中的内存区域，或者说是内存单元：其本身结构中的字段决定了它的大小，通常是页的整数倍，而数据段代码段等，mm_struct中已经有字段来表明边界；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/pid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">sysctl_example_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">tpid</span> = <span class="title">find_get_pid</span>(12473);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> = <span class="title">pid_task</span>(<span class="title">tpid</span>,<span class="title">PIDTYPE_PID</span>);</span></span><br><span class="line">    printk(<span class="string">"the state of the task is:%d\n"</span>,task-&gt;state);     <span class="comment">// 显示任务当前所处的状态</span></span><br><span class="line">    printk(<span class="string">"the pid of the task is:%d\n"</span>,task-&gt;pid);         <span class="comment">// 显示任务的进程号</span></span><br><span class="line">    printk(<span class="string">"the pid of current thread is:%d\n"</span>,current-&gt;pid);<span class="comment">// 显示当前进程的进程号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">mm_task</span>=<span class="title">get_task_mm</span>(<span class="title">task</span>);</span>             <span class="comment">// 获取任务的内存描述符   </span></span><br><span class="line">     printk(<span class="string">"the mm_users of the mm_struct is:%d\n"</span>,mm_task-&gt;mm_users);</span><br><span class="line">    printk(<span class="string">"the mm_count of the mm_struct is:%d\n total vm :%ld exec_vm:%ld"</span>,mm_task-&gt;mm_count,mm_task-&gt;total_vm,mm_task-&gt;exec_vm); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm</span>= <span class="title">mm_task</span>-&gt;<span class="title">mmap</span>;</span></span><br><span class="line">    printk(<span class="string">"mmap base:%016x ,task_size:%016x,start_code:%016x,end_code:%016x,start_data:%016x, end_data:%016x,start_brk:%016x,endbrk:%016x, start_stack:%016x\n"</span>,mm_task-&gt;mmap_base,mm_task-&gt;task_size,mm_task-&gt;start_code,mm_task-&gt;end_code,mm_task-&gt;start_data,mm_task-&gt;end_data,mm_task-&gt;start_brk,mm_task-&gt;brk,mm_task-&gt;start_stack);</span><br><span class="line">    printk(<span class="string">"the first vmarea:start:%016x ,end:%016x\n"</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    printk(<span class="string">"the  vmarea:start:%016x ,end:%016x\n"</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    printk(<span class="string">"the first vmarea:start:%016x ,end:%016x\n"</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    printk(<span class="string">"the first vmarea:start:%016x ,end:%016x\n"</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    printk(<span class="string">"the first vmarea:start:%016x ,end:%016x\n"</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    printk(<span class="string">"the first vmarea:start:%016x ,end:%016x\n"</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">sysctl_example_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"sysctl unregister success.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(sysctl_example_init);</span><br><span class="line">module_exit(sysctl_example_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">结果举例：dmesg</span><br><span class="line">[<span class="number">41928.340021</span>] the state of the task is:<span class="number">0</span></span><br><span class="line">[<span class="number">41928.340023</span>] the pid of the task is:<span class="number">12473</span></span><br><span class="line">[<span class="number">41928.340024</span>] the pid of current thread is:<span class="number">14907</span></span><br><span class="line">[<span class="number">41928.340025</span>] the mm_users of the mm_struct is:<span class="number">6</span></span><br><span class="line">[<span class="number">41928.340026</span>] the mm_count of the mm_struct is:<span class="number">1</span></span><br><span class="line">[<span class="number">41928.340026</span>]  total vm :<span class="number">1083</span> exec_vm:<span class="number">478</span>mmap base:<span class="number">00000000007</span>de000 ,task_size:<span class="number">00000000f</span>ffff000,start_code:<span class="number">0000000000400000</span>,end_code:<span class="number">0000000000400</span>af4,start_data:<span class="number">0000000000600e10</span>, end_data:<span class="number">0000000000601054</span>,start_brk:<span class="number">00000000014b</span>2000,endbrk:<span class="number">00000000014</span>d3000, start_stack:<span class="number">000000005</span>a04e590</span><br><span class="line">[<span class="number">41928.340029</span>] the first vmarea:start:<span class="number">0000000000400000</span> ,end:<span class="number">0000000000401000</span></span><br><span class="line">[<span class="number">41928.340030</span>] the  vmarea:start:<span class="number">00000000005b</span>2000 ,end:<span class="number">00000000005b</span>4000</span><br><span class="line">[<span class="number">41928.340031</span>] the first vmarea:start:<span class="number">0000000000600000</span> ,end:<span class="number">0000000000601000</span></span><br><span class="line">[<span class="number">41928.340033</span>] the first vmarea:start:<span class="number">00000000005b</span>4000 ,end:<span class="number">00000000005b</span>9000</span><br><span class="line">[<span class="number">41928.340034</span>] the first vmarea:start:<span class="number">000000005</span>a061000 ,end:<span class="number">000000005</span>a063000</span><br><span class="line">[<span class="number">41928.340035</span>] the first vmarea:start:<span class="number">00000000007</span>db000 ,end:<span class="number">00000000007</span>dc000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>C:内存映射原理：</p>
<ul>
<li>前言：实际上进程此时用的还是虚拟内存，那么怎么和物理页关联？实际上物理页有限，虚拟空间大，所以，只有最常用的部分才和物理页关联；大多程序也只占一小部分内存；</li>
<li>进程经常要从文件中读取数据，文件存放于磁盘上，于是，将磁盘上的文件映射到内存则很关键，涉及文件读写和磁盘文件的更新；而实际的映射过程，只是用了几页来存储文件结尾的数据，而文件开始处，则内核只需在地址空间保存相关信息如：数据位置，数据如何读取即可(PS:这些不是保存在进程中的结构吗？ ),text段也类似，只有在需要时才加载；</li>
<li>用户进程访问一个内存地址的过程：<br>虚拟地址–&gt;页表–&gt;确定物理页(有则读取)–&gt;无，出发缺页异常发送到内核-&gt;内核检查进程并找到适当的后备存储器(和文件系统相关),分配物理页并填充来自后备存储器的数据–&gt;借助页表将物理页并入用户进程地址空间，进程恢复执行；<br>– &gt;     malloc-&gt;do_brk–&gt;写时复制，缺页异常—&gt;到vm_area_struct找，vma_fault–&gt;page—&gt;没有做alloc_page ，这样的流程；</li>
</ul>
<p>D:详细阐述：数据结构mm_struct：vmarea_struct mmap虚拟内存区域列表 ; rb_root mm_rb;  vm_area_struct *mmap_cache上一个find_vma结果(上次处理的区域）<br>树和链表：每个区域都通过一个vmarea_struct实例描述，进程的各区域(如text段等)按两种方式排序：在一个单链表上(开始于mm_struct-&gt;mmap)/在一个红黑树中，根位于mm_rb; (task_struct-&gt;mm)即一个进程只有一个mm;<br><img src="/2021/03/06/memory-overiew/vmareatree.png" title="vmareatree"><br>而其实多个mm会连接起来形成全局链表：<br><img src="/2021/03/06/memory-overiew/moremm.png" title="moremm"></p>
<p>虚拟内存区域 vmarea_struct详解：<br>优先查找树结构：一个文件往往关联了多个进程：为了建立一个文件中的一个区域与该区域映射到的所有虚拟地址空间的关联，使用了优先查找树；<br>1) struct file: 每个打开的文件(和每个块设备，因为也可以和内存映射)都会表示为struct file的一个实例，该结构包含了一个指向地址空间对象struct address_space的指针(和后备存储器相关),关联是优先查找树的基础；其文件区间与其映射到的地址空间之间的关联即通过优先树建立；stuct file 和struct address_space见源码<br>2) 另外，每个文件和块设备都表示为struct inode的一个实例，struct file是通过open调用时打开的文件抽象，而inode 则是文件系统自身中的对象；<br>struct inode: address_space *i_mapping; 注意每个file是特定于给定进程的，也就是每个进程都有其file成员；<br><img src="/2021/03/06/memory-overiew/mm_file.png" title="moremm"><br>E 对区域的操作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">将虚拟地址关联到区域:通过虚拟地址，借助find_vma函数可以查找用户地址空间中结束地址在给定地址后的第一个区域；</span><br><span class="line"><span class="function">struct vm_area_struct * <span class="title">find_vma</span><span class="params">(struct mm_struct * mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mm) &#123;</span><br><span class="line">		<span class="comment">/* Check the cache first. */</span> <span class="comment">//先检查缓存，也就是上次使用的内存；</span></span><br><span class="line">		<span class="comment">/* (Cache hit rate is typically around 35%.) */</span></span><br><span class="line">		vma = mm-&gt;mmap_cache;</span><br><span class="line">		<span class="keyword">if</span> (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123;<span class="comment">//不行再查找区域红黑树；</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> * <span class="title">rb_node</span>;</span></span><br><span class="line"></span><br><span class="line">			rb_node = mm-&gt;mm_rb.rb_node;</span><br><span class="line">			vma = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (rb_node) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vma_tmp</span>;</span></span><br><span class="line"></span><br><span class="line">				vma_tmp = rb_entry(rb_node,</span><br><span class="line">						struct vm_area_struct, vm_rb);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;</span><br><span class="line">					vma = vma_tmp;</span><br><span class="line">					<span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					rb_node = rb_node-&gt;rb_left;</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					rb_node = rb_node-&gt;rb_right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (vma)</span><br><span class="line">				mm-&gt;mmap_cache = vma;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>区域合并：当新区域被加到进程的地址空间时，内核会检查它是否可以与一个或多个现存区域合并：无非检查地址是否相邻等等<br>插入区域： insert_vm_struct函数，实际工作：将区域插入红黑树；<br>创建区域：需要检查虚拟地址空间中是否还有足够的空闲空间来插入新区域；get_unmapped_area  </p>
<p>F:地址空间：文件和进程的内存映射：可以看是文件系统对于的地址空间和用户进程虚拟地址空间的关联映射；<br>vm_operations_struct结构：用于建立两个地址空间的关联和通信；</p>
<h5 id="用户进程内存分配的流程："><a href="#用户进程内存分配的流程：" class="headerlink" title="用户进程内存分配的流程："></a>用户进程内存分配的流程：</h5><p>malloc–&gt; chunks<br>  <strong>brk:/</strong>map–&gt;<br>    sys_brk/sys_mmap_pgoff: 找vm_area_struct<br>       无：缺页异常 ，操作vm_area_struct:-&gt;ops-&gt;vm_fault-&gt;page<br>         –伙伴系统 alloc_page</p>
<img src="/2021/03/06/memory-overiew/malloc.png" title="malloc">
<h4 id="linux内存内核分配："><a href="#linux内存内核分配：" class="headerlink" title="linux内存内核分配："></a>linux内存内核分配：</h4><p>总的来说，有如下几种分配：</p>
<ul>
<li>kmalloc/kzmalloc: 小内存的分配</li>
<li>kmem_cache_alloc: 特定内存大小的内存分配</li>
<li>vmalloc:不连续的大内存分配，多个页</li>
<li>alloc_page:底层分配，分配多个页；<h5 id="slab机制"><a href="#slab机制" class="headerlink" title="slab机制"></a>slab机制</h5></li>
</ul>
<p>针对页内碎片的slab分配技术：将页拆分，分配小单元内存<br>slab分配器：分配比4K更小的内存；提供要经常分配的缓存结构如struct fs_struct;slab着色；slab分配器命名由来<br>PS：slab分配器负责完成与伙伴系统的交互，来分配所需的页</p>
<p>备选分配器：slob分配器；slub分配器</p>
<p>slab分配的原理：<br>下图：缓存即高速缓存kmem_cache 结构，也叫slab缓存由两部分组成：保存管理性数据的缓存对象(kmem_cache)和保存被管理对象的各个slab<br>(1)每个缓存只负责一种对象类型(如struct unix_sock实例，通过/proc/slabinfo可看到),或提供一般性缓冲区(kmalloc分配时用);各个缓存中slab数目各有不同<br>(2)各个缓存都保持在一个双向链表中cache_chain,内核有机会遍历他们<br><img src="/2021/03/06/memory-overiew/slab.png" title="slab"></p>
<ul>
<li>详细缓存结构(kmem_cache)<br>下图：重要成员1：<pre><code> array_cache :保存了各个cpu最后释放的对象：在分配和释放这些对象时，采用后进先出原理，内核假定刚释放的对象仍然处于CPU高速缓存中，会尽快再次分配它
                    仅当per-CPU缓存为空时，才会用slab中的空闲对象重新填充它们
 由此形成三级的分配体系：按照分配成本和操作对CPU高速缓存和TLB的负面影响逐级升高：
 (1) 仍然处于CPU高速缓存中的per-CPU对象
 (2) 现存于slab中的未使用对象
 (3)刚使用伙伴系统分配的新slab中未使用的对象
重要成员2：kmem_list3:每个内存结点都对应3个表头，用于组织slab链表；完全用尽的slab,部分空闲的slab和空闲的slab
</code></pre><img src="/2021/03/06/memory-overiew/slaball.png" title="slaball"></li>
<li><p>slab结构解释：<br>(1)对象在slab中非连续排列，用于每个对象的长度非确切大小，舍入和对齐了；<br>(2)slab创建时有两种方案对齐：1可使用标志SLAB_HWCACHE_ALIGN，slab用户可以按照要求按硬件缓存行对齐，cache_line_size返回值进行；2 不按照硬件对齐<br>(3)填充字节情况；链接了第一个对象，所以slab首部可以不用和slab对象在一起<br>(4)另外 page结构包含了一个链表元素，用于管理各种链表中的页，但是slab缓存不用，用于：<br>page-&gt;lru.next指向页驻留的缓存的管理结构  kmem_cache<br>page-&gt;lru.prev指向保存该页的slab的管理结构 slab<br>设置或读取slab信息分别由set_page_slab和get_page_slab函数完成，带有__cache后缀的函数则处理缓存信息的设置和读取：<br>mm/slab.c:2.6版本：<br>page_set_cache<br><em>page_get_cache<br>page_set_slab
</em>page_get_slab<br>此外，内核还对分配给slab分配器的各个物理页都设置标志PG_SLAB</p>
<img src="/2021/03/06/memory-overiew/slablist.png" title="slablist">
</li>
<li><p>kmem_cache_系列实现：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)数据结构详情：主要是对slab中涉及的kmem_cache,slab,kmem_list3等中的成员做详细的介绍；略</span><br><span class="line">(<span class="number">2</span>)初始化slab系统：</span><br><span class="line">    一个问题：为初始化slab数据结构，内核需要若干远小于一页的内存块（slab中的<span class="keyword">object</span>要分配内存，不然为空指针), 这些由kmalloc分配，但是kmaloc需要在slab启动后才能用；</span><br><span class="line">   解决：涉及kmalloc中的per-CPU缓存的初始化：需要一些技巧：</span><br><span class="line">       A: kmem_cache_init初始化slab分配器：在伙伴系统启动后调用：</span><br><span class="line">           创建系统中第一个slab缓存，以便为kmem_cache的实例提供内存，内核此时使用的主要是在编译时创建的静态数据，一个静态数据结构(initarray_cache)用作per-CPU数组，缓存名为cache_cache;</span><br><span class="line">           接着，初始化一般性缓存，用于kmalloc内存来源：调用kmem_cache_create，存在cache_cache需要借助kmalloc，但是kmalloc又需要借助它的问题：</span><br><span class="line">                     内核使用g_cpucache_up变量解决，类似状态机；在合适的时候才用更大的缓存</span><br><span class="line">           最后，将kmalloc动态分配的版本替换为slab对象的数据结构</span><br><span class="line">(<span class="number">3</span>)创建缓存：创建新的slab缓存必须调用kmem_cache_create；调用后可读的<span class="keyword">name</span>会出现在/proc/slabinfo中；</span><br><span class="line">(<span class="number">4</span>)分配对象：kmem_cache_alloc:用于从特定的高速缓存kmem_cache获取对象，类似于所有的malloc函数；</span><br><span class="line">(<span class="number">5</span>)释放对象：kmem_cache_free</span><br><span class="line">(<span class="number">6</span>)销毁缓存：kmem_cache_destroy</span><br></pre></td></tr></table></figure>
</li>
<li><p>通用缓存:kamlloc:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">通用缓存：若不涉及特殊对象如<span class="class"><span class="keyword">struct</span> <span class="title">unix_sock</span>,而是传统的分配/释放内存，则必须调用<span class="title">kmalloc</span>和<span class="title">kfree</span>函数，这两个函数相当于<span class="title">c</span>的<span class="title">malloc</span>和<span class="title">free</span></span></span><br><span class="line"><span class="class">          需要注意的是：这里的内存分配采用的所有可用的长度：2的幂次：</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">cache_sizes</span> <span class="title">malloc_sizes</span>[] = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHE(x) &#123;.cs_size = (x) &#125;,</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#if (PAGE_SIZE == 4096)</span></span><br><span class="line"><span class="comment">	CACHE(32)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">	CACHE(64)</span></span><br><span class="line"><span class="comment">#if L1_CACHE_BYTES &lt; 64	// L1_CACHE_BYTES = 128</span></span><br><span class="line"><span class="comment">	CACHE(96)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">	CACHE(128)</span></span><br><span class="line"><span class="comment">#if L1_CACHE_BYTES &lt; 128</span></span><br><span class="line"><span class="comment">	CACHE(192)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">	CACHE(256)</span></span><br><span class="line"><span class="comment">	CACHE(512)</span></span><br><span class="line"><span class="comment">	CACHE(1024)</span></span><br><span class="line"><span class="comment">	CACHE(2048)</span></span><br><span class="line"><span class="comment">	CACHE(4096)</span></span><br><span class="line"><span class="comment">	CACHE(8192)</span></span><br><span class="line"><span class="comment">	CACHE(16384)</span></span><br><span class="line"><span class="comment">	CACHE(32768)</span></span><br><span class="line"><span class="comment">	CACHE(65536)</span></span><br><span class="line"><span class="comment">	CACHE(131072)</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 262144</span></span><br><span class="line"><span class="comment">	CACHE(262144)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 524288</span></span><br><span class="line"><span class="comment">	CACHE(524288)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 1048576</span></span><br><span class="line"><span class="comment">	CACHE(1048576)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 2097152</span></span><br><span class="line"><span class="comment">	CACHE(2097152)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 4194304</span></span><br><span class="line"><span class="comment">	CACHE(4194304)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 8388608</span></span><br><span class="line"><span class="comment">	CACHE(8388608)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 16777216</span></span><br><span class="line"><span class="comment">	CACHE(16777216)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 33554432</span></span><br><span class="line"><span class="comment">	CACHE(33554432)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	CACHE(ULONG_MAX);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CACHE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="linux内存内核分配的选择："><a href="#linux内存内核分配的选择：" class="headerlink" title="linux内存内核分配的选择："></a>linux内存内核分配的选择：</h5><ul>
<li>概述：<br>分配小的chunks 使用 kmalloc或kmem_cache_alloc 家族函数<br>分配大的虚拟的连续区域，使用vmalloc和它的变种函数，或者你可以直接请求页，从页的分配器 with alloc_pages;分配器也可能使用的是更专业的比如 cma_alloc或 zs_malloc</li>
</ul>
<p>许多内存分配器都使用GFP flags来表达内存应该怎么被分配。 这个GFP标志是给到get free pages的，是底层的分配函数<br>分配api的多样性和众多的GFP标志使得“我应该如何分配内存?”这并不容易回答，尽管你很可能会用<br>kzalloc(<size>, GFP_KERNEL);</size></p>
<ul>
<li>关于Get Free Page FLags:<br>GFP(get free page)标志，控制分配器的行为，他们告知什么内存zones被使用，分配器应该如何努力寻找空闲内存，内存是否可以被用户空间访问等<br>内存管理api提供了GFP标志及其组合的参考文档，这里我们简要概述了它们的推荐用法:<br>1) 大多数情况下，GFP_KERNEL正是您所需要的。用于内核数据结构的内存、DMAable内存、索引节点缓存，所有这些以及许多其他分配类型都可以使用GFP_KERNEL。注意，使用GFP_KERNEL意味着GFP_RECLAIM，这意味着直接回收可能会在内存压力下触发;必须允许调用上下文休眠。</li>
</ul>
<p>2)如果分配从一个原子上下文执行，例如中断处理程序，使用GFP_NOWAIT。这个标志防止直接回收IO或文件系统操作。因此，在内存压力下，GFP_NOWAIT分配很可能失败。有合理回退的分配应该使用GFP_NOWARN。</p>
<p>3)如果你认为你访问的内存储备是合理的，且除非内核分配成功，否则会给内核带来压力的话，可以用GFP_ATOMIC;</p>
<p>4)从用户空间触发的不受信任的分配，应该被当成一个分配统计对象，并且有__GFP_ACCOUNT这个标志被设置；即GFP_KERNEL_ACCOUNT;</p>
<p>5)用户空间分配应该使用GFP_USER、GFP_HIGHUSER或 GFP_HIGHUSER_MOVABLE  ;标志名越长，限制越小；<br>GFP_HIGHUSER_MOVABLE不要求内核可以直接访问已分配的内存，这意味着数据是可移动的。<br>GFP_HIGHUSER表示所分配的内存是不可移动的，但是内核不需要直接访问它。一个例子可能是硬件分配，它将数据直接映射到用户空间，但没有寻址限制。<br>GFP_USER表示所分配的内存是不可移动的，必须由内核直接访问。</p>
<p>6)您可能注意到，现有代码中有相当多的分配指定了GFP_NOIO或GFP_NOFS。历史上，它们被用来防止由于直接内存回收调用FS或IO路径和阻塞已经占用的资源而引起的递归死锁。从4.12开始，解决这个问题的首选方法是使用FS/IO上下文中使用的GFP掩码中描述的新的作用域api。<br>7)其他遗留的GFP标志是GFP_DMA和GFP_DMA32。它们用于确保具有有限寻址能力的硬件可以访问所分配的内存。所以，除非你正在为一个有这样限制的设备编写驱动程序，否则不要使用这些标志。即使是有限制的硬件，使用dma_alloc* api也是可取的。</p>
<ul>
<li>GFP flags和它的回收内存行为，即多个和一起：<br>1)GFP_KERNEL &amp; ~<strong>GFP_RECLAIM -乐观分配，根本没有尝试释放内存。最轻的重量模式，甚至不触发后台回收。应该谨慎使用，因为它可能会耗尽内存，下一个用户可能会更主动地回收内存。<br>2)GFP_KERNEL &amp; ~</strong>GFP_DIRECT_RECLAIM(或GFP_NOWAIT)-乐观分配，不尝试从当前上下文释放内存，但可以唤醒kswapd回收内存，如果该区域低于低水位。可以在原子上下文中使用，也可以在请求进行性能优化时使用，对于慢路径有另一种退路。<br>3)(GFP_KERNEL|<strong>GFP_HIGH) &amp; ~</strong>GFP_DIRECT_RECLAIM(又名GFP_ATOMIC) -非睡眠分配，具有昂贵的回退，因此它可以访问部分内存储备。通常从中断/下半部分上下文使用一个昂贵的慢路径回退。</li>
</ul>
<p>4)GFP_KERNEL -允许后台和直接回收，并使用默认的页面分配器行为。这意味着不昂贵的分配请求基本上是不会失败的，但没有这种行为的保证，所以失败必须由调用者正确地检查(例如，OOM killer 异常是<br>允许失败的）<br>5)GFP_KERNEL | <strong>GFP_NORETRY -覆盖默认的分配器行为，所有的分配请求在早期失败，而不是导致中断回收(在这个实现中是一轮回收)。OOM杀手没有被调用。<br>6)GFP_KERNEL | </strong>GFP_RETRY_MAYFAIL -覆盖默认的分配器行为和所有的分配请求尝试真正努力。如果回收不能取得任何进展，请求将失败。OOM杀手不会被触发。</p>
<p>7)GFP_KERNEL | __GFP_NOFAIL -覆盖默认的分配器行为，所有的分配请求将不断循环，直到它们成功。这可能真的很危险，特别是对大订单来说。</p>
<ul>
<li>如何选择正确的内存分配器：<br>1 最直接的方式就是用 kmalloc，当然，安全的是初始化内存为0，如kzalloc(),若想分配给一个数组，则有kmalloc_array(),和kcalloc() ;辅助函数：struct_size(),array_size(),array3_size();用来防止溢出；<br>不过，用kmalloc分配的chunk的最大长度是被限制的，实际限制依赖于硬件和内核配置，但是好的实践是，分配的对象比页的大小小；用kmalloc分配的块的地址至少对齐到ARCH_KMALLOC_MINALIGN字节<br>对于2的幂次大小，对齐也保证至少是各自的大小。用kmalloc()分配的块可以用krealloc()调整大小。与kmalloc_array()类似:以krealloc_array()的形式提供了调整数组大小的帮助器。</li>
</ul>
<p>2 对于大的分配来说，可以用vmalloc和vzalloc，或直接用页分配器；用vmalloc和相关联的函数分配可能不是物理上连续的内存；<br>如果您不确定分配大小对于kmalloc来说是否太大，则可以使用kvmalloc()及其衍生物。它将尝试使用kmalloc分配内存，如果分配失败，它将使用vmalloc重试。对于哪些GFP标志可以用于kvmalloc有一些限制;请参阅kvmalloc_node()参考文档。注意，kvmalloc可能返回的内存不是物理上连续的。</p>
<p>3 如果你需要分配许多相同的对象，你可以使用slab缓存分配器。在使用缓存之前，应该使用kmem_cache_create()或kmem_cache_create_usercopy()来设置缓存。如果缓存的一部分可能被复制到用户空间，则应该使用第二个函数。创建缓存之后，kmem_cache_alloc()及其方便的包装器可以从缓存中分配内存。<br>当分配的内存不再需要时，必须释放它。可以对kmalloc、vmalloc和kvmalloc分配的内存使用kvfree()。slab缓存应该使用kmem_cache_free()来释放。不要忘记使用kmem_cache_destroy()来销毁缓存。</p>
<h5 id="kmalloc和kmem-cache-系列的区别："><a href="#kmalloc和kmem-cache-系列的区别：" class="headerlink" title="kmalloc和kmem_cache_系列的区别："></a>kmalloc和kmem_cache_系列的区别：</h5><p>来源于网上比较好的回答：<br>Here is the brief description about how kernel manages memory.<br>In order to manage small sized physical memory allocation, kernel uses slab<br>allocator. Slab allocator maintains two types of caches</p>
<ol>
<li>Generalized Caches of memory pools</li>
<li>Specialized caches of memory pools.</li>
</ol>
<p>Generalized caches contains small memory objects of sizes 8, 16, 32,<br>64,….512, 1024, 2048, 4096, 8192 bytes. These are named as kmalloc’ed<br>caches because kernel allocates memory from these caches when kmalloc is<br>used to to allocate memory.<br>These caches are created at the boot initialization phase. Ref<br>/proc/slabinfo for the list of kmalloc-ed caches.</p>
<p>Not always the user of the kernel will use the objects of the size<br>maintained by the generalized cache. For Eg. In case of Ethernet driver, the<br>driver has to allocate memory for the size 1500 bytes.<br>In this case, if the driver has to allocate memory using kmalloc, it has to<br>allocate a minimum of 2048 bytes per packet, thus wasting almost 550 bytes<br>for every allocation of memory per packet.<br>Hence kernel allows for the driver to create a specialized cache which<br>contains the memory objects of the size specified by user.<br>i.e. In the above example the driver can create his own cache of memory<br>objects of size 1500 bytes by using following KPIs</p>
<ol>
<li>kmem_cache_create - Creates a specialized cache</li>
<li>kmem_cache_alloc - allocates memory from a specialized cache</li>
<li>kmem_cache_free - frees memory to the speicialized cache</li>
<li>kmem_cache_destroy - destroys the specialized cache.</li>
</ol>
<p>Hence kmem_cache_alloc is used when the user of the kernel needs to allocate<br>memory from the specialized cache and kmalloc is used to allocate memory<br>from the generalized caches.</p>
<p>不过看实现，貌似后来的版本，这两个函数都基于slab/slub/slob:具体用哪个分配器，需要根据内核的默认配置； 只是前者kmalloc是可能两个模块共用一个cache，而后者则不是；<br>关于kmalloc和kmem_cache_alloc的区别：<br>kmalloc: It uses the generic slab caches available to any kernel code. so your module will share slab cache with other components in kernel.</p>
<p>kmem_cache_alloc: It will allocate objects from a dedicated slab cache created by kmem_cache_create. If you specifically want a better slab cache management dedicated to your module only, that too for a specific type of objects, use kmem_cache_create followed by kmem_cache_alloc. USB/SCSI drivers use this. kmem_cache_create takes sizeof your object you want to create slab of, a name which appears in /proc/slabinfo and flags to govern behavior of your slab cache.</p>
<h3 id="linux下内存的查看和几个问题："><a href="#linux下内存的查看和几个问题：" class="headerlink" title="linux下内存的查看和几个问题："></a>linux下内存的查看和几个问题：</h3><h4 id="linux下物理内存统计等"><a href="#linux下物理内存统计等" class="headerlink" title="linux下物理内存统计等"></a>linux下物理内存统计等</h4><p>ref:<a href="http://linuxperf.com/?cat=7" target="_blank" rel="noopener">http://linuxperf.com/?cat=7</a><br>系统当前的内存情况：<br>物理内存总数：和可用的物理内存数：<br> dmesg | grep Memory<br>[    0.000000] Memory: 3857076K/4193848K available (8375K kernel code, 1336K rwdata, 3944K rodata, 1492K init, 1260K bss, 336772K reserved, 0K cma-reserved)<br>4193848K 表示此系统物理内存大小<br>3857076K 表示在初始化时，可供kernel分配的free memory的大小，注意这个值在初始化后，实际可用会变大，因为之后还会释放一些bootmem等用完的内存；<br>后面括号的是内核的代码大小占用等等；<br>所以：一个物理内存划分：BIOS|kernel code|initdata| totalavail<br>系统启动后，totalavail为：注意是物理内存<br>$ free  执行结果的total<br>             total       used       free     shared    buffers     cached<br>Mem:       4046636    2568888    1477748      17884      70888    1764708<br>-/+ buffers/cache:     733292    3313344<br>Swap:      4191228          0    4191228<br>或：下面指令的memtotal<br>$ cat /proc/meminfo<br>MemTotal:        4046636 kB<br>MemFree:         1477676 kB<br>MemAvailable:    3113840 kB<br>Buffers:           70896 kB<br>Cached:          1764708 kB<br>SwapCached:            0 kB<br>Active:           827164 kB<br>Inactive:        1596816 kB<br>Active(anon):     589152 kB<br>Inactive(anon):    17104 kB<br>Active(file):     238012 kB<br>Inactive(file):  1579712 kB<br>Unevictable:          16 kB<br>Mlocked:              16 kB<br>SwapTotal:       4191228 kB<br>SwapFree:        4191228 kB<br>Dirty:                 0 kB<br>Writeback:             0 kB<br>AnonPages:        588396 kB<br>Mapped:           163956 kB<br>Shmem:             17884 kB<br>Slab:              61964 kB<br>SReclaimable:      42112 kB<br>SUnreclaim:        19852 kB<br>KernelStack:        5888 kB<br>PageTables:        24916 kB<br>NFS_Unstable:          0 kB<br>Bounce:                0 kB<br>WritebackTmp:          0 kB<br>CommitLimit:     6214544 kB<br>Committed_AS:    2746044 kB<br>VmallocTotal:   34359738367 kB<br>VmallocUsed:           0 kB<br>VmallocChunk:          0 kB<br>HardwareCorrupted:     0 kB<br>AnonHugePages:    407552 kB<br>CmaTotal:              0 kB<br>CmaFree:               0 kB<br>HugePages_Total:       0<br>HugePages_Free:        0<br>HugePages_Rsvd:        0<br>HugePages_Surp:        0<br>Hugepagesize:       2048 kB<br>DirectMap4k:       96192 kB<br>DirectMap2M:     4098048 kB</p>
<p>更多内核内存的查看，见ref<br>进程的物理内存使用：<br>cat /proc/{pid}/status<br>VmRSS 或 VmHWM<br>这个怎么来的：追了下，它定义在：task_mem in task_mmu.c (fs\proc) :         “VmRSS:\t%8lu kB\n”<br> get_mm_rss(mm);其实就是task_struct-&gt;&amp;mm-&gt;rss_stat.count[member]<br> 看下这个结构的解释：（看了下代码，就是在缺页等实际分配的时候做累加）<br> struct mm_rss_stat rss_stat - A set of statistics contained in struct mm_rss_stat relating to Resident Set Size (RSS), i.e. memory that has been faulted in. The structure is simply an array of atomic_long_t counts for each of: MM_FILEPAGES - number of resident pages mapping files, MM_ANONPAGES - number of resident anonymous pages, MM_SWAPENTS - number of resident swap entries, and MM_SHMEMPAGES - number of resident shared pages. Note that in the usual case where the SPLIT_RSS_COUNTING constant is set, these statistics are only updated every TASK_RSS_EVENTS_THRESH page faults (hardcoded to 64.)</p>
<p>进程的虚拟内存大小：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /proc/<span class="number">12473</span>/status</span><br><span class="line">Name:	task_test2</span><br><span class="line">State:	R (running)</span><br><span class="line">Tgid:	<span class="number">12473</span></span><br><span class="line">Ngid:	<span class="number">0</span></span><br><span class="line">Pid:	<span class="number">12473</span></span><br><span class="line">PPid:	<span class="number">10096</span></span><br><span class="line">TracerPid:	<span class="number">0</span></span><br><span class="line">Uid:	<span class="number">1000</span>	<span class="number">1000</span>	<span class="number">1000</span>	<span class="number">1000</span></span><br><span class="line">Gid:	<span class="number">1000</span>	<span class="number">1000</span>	<span class="number">1000</span>	<span class="number">1000</span></span><br><span class="line">FDSize:	<span class="number">256</span></span><br><span class="line">Groups:	<span class="number">4</span> <span class="number">24</span> <span class="number">27</span> <span class="number">30</span> <span class="number">46</span> <span class="number">108</span> <span class="number">124</span> <span class="number">1000</span> </span><br><span class="line">NStgid:	<span class="number">12473</span></span><br><span class="line">NSpid:	<span class="number">12473</span></span><br><span class="line">NSpgid:	<span class="number">12473</span></span><br><span class="line">NSsid:	<span class="number">10096</span></span><br><span class="line">VmPeak:	    <span class="number">4332</span> kB</span><br><span class="line">VmSize:	    <span class="number">4332</span> kB  是虚拟内存的大小，即task_struct-&gt;mm-&gt;total_vm个页，一个页是<span class="number">4</span>k;</span><br><span class="line">VmLck:	       <span class="number">0</span> kB</span><br><span class="line">VmPin:	       <span class="number">0</span> kB</span><br><span class="line">VmHWM:	     <span class="number">660</span> kB</span><br><span class="line">VmRSS:	     <span class="number">660</span> kB </span><br><span class="line">VmData:	     <span class="number">200</span> kB</span><br><span class="line">VmStk:	     <span class="number">132</span> kB</span><br><span class="line">VmExe:	       <span class="number">4</span> kB</span><br><span class="line">VmLib:	    <span class="number">1908</span> kB</span><br><span class="line">VmPTE:	      <span class="number">32</span> kB</span><br><span class="line">VmPMD:	      <span class="number">12</span> kB</span><br><span class="line">VmSwap:	       <span class="number">0</span> kB</span><br><span class="line">HugetlbPages:	       <span class="number">0</span> kB</span><br><span class="line">Threads:	<span class="number">1</span></span><br><span class="line">SigQ:	<span class="number">0</span>/<span class="number">15066</span></span><br><span class="line">SigPnd:	<span class="number">0000000000000000</span></span><br><span class="line">ShdPnd:	<span class="number">0000000000000000</span></span><br><span class="line">SigBlk:	<span class="number">0000000000000000</span></span><br><span class="line">SigIgn:	<span class="number">0000000000000000</span></span><br><span class="line">SigCgt:	<span class="number">0000000000000000</span></span><br><span class="line">CapInh:	<span class="number">0000000000000000</span></span><br><span class="line">CapPrm:	<span class="number">0000000000000000</span></span><br><span class="line">CapEff:	<span class="number">0000000000000000</span></span><br><span class="line">CapBnd:	<span class="number">0000003f</span>ffffffff</span><br><span class="line">CapAmb:	<span class="number">0000000000000000</span></span><br><span class="line">Seccomp:	<span class="number">0</span></span><br><span class="line">Speculation_Store_Bypass:	vulnerable</span><br><span class="line">Cpus_allowed:	<span class="number">3</span></span><br><span class="line">Cpus_allowed_list:	<span class="number">0</span><span class="number">-1</span></span><br><span class="line">Mems_allowed:	<span class="number">00000000</span>,<span class="number">00000001</span></span><br><span class="line">Mems_allowed_list:	<span class="number">0</span></span><br><span class="line">voluntary_ctxt_switches:	<span class="number">0</span></span><br><span class="line">nonvoluntary_ctxt_switches:	<span class="number">167165</span></span><br></pre></td></tr></table></figure></p>
<h4 id="几个问题："><a href="#几个问题：" class="headerlink" title="几个问题："></a>几个问题：</h4><ul>
<li>通过malloc分配的最小物理内存单位是页吗，就是最小的话，一定会分配一个页，那这个页是不是这个进程独占，还是可以和其他进程共享？</li>
<li>内存映射和普通的内存分配操作有什么区别？</li>
<li>通过alloc_page分配内存页的时候，是不是就是即分配物理页，而不会再通过写入才分配？<br>是，即分配物理页，可以通过模块中alloc_page接口的调用，观察free指令下内存的变化；模块例子可以在本文中搜 alloc_page,在insmod模块后观察free下的值，最好指定分配的页多些，因为free下的空闲内存在一个范围变动；</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p>深入linux内核架构等</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/memory/" rel="tag"># memory</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/26/procsysfs/" rel="prev" title="procsysfs">
      <i class="fa fa-chevron-left"></i> procsysfs
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#linux内存系统概述"><span class="nav-number">1.</span> <span class="nav-text">linux内存系统概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux内存系统的地址空间："><span class="nav-number">2.</span> <span class="nav-text">linux内存系统的地址空间：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简介："><span class="nav-number">2.1.</span> <span class="nav-text">简介：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟地址空间："><span class="nav-number">2.2.</span> <span class="nav-text">虚拟地址空间：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux内存系统的相关结构："><span class="nav-number">3.</span> <span class="nav-text">linux内存系统的相关结构：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础的，物理内存："><span class="nav-number">3.1.</span> <span class="nav-text">基础的，物理内存：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实践：操作zone等："><span class="nav-number">3.1.1.</span> <span class="nav-text">实践：操作zone等：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#和MMU相关的："><span class="nav-number">3.2.</span> <span class="nav-text">和MMU相关的：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux内存初始化简介："><span class="nav-number">4.</span> <span class="nav-text">linux内存初始化简介：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux内存分配："><span class="nav-number">5.</span> <span class="nav-text">linux内存分配：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#linux内存分配图谱："><span class="nav-number">5.1.</span> <span class="nav-text">linux内存分配图谱：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux内存用户进程分配"><span class="nav-number">5.2.</span> <span class="nav-text">linux内存用户进程分配:</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#用于进程内存相关机制："><span class="nav-number">5.2.1.</span> <span class="nav-text">用于进程内存相关机制：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#用户进程内存分配的流程："><span class="nav-number">5.2.2.</span> <span class="nav-text">用户进程内存分配的流程：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux内存内核分配："><span class="nav-number">5.3.</span> <span class="nav-text">linux内存内核分配：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#slab机制"><span class="nav-number">5.3.1.</span> <span class="nav-text">slab机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#linux内存内核分配的选择："><span class="nav-number">5.3.2.</span> <span class="nav-text">linux内存内核分配的选择：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kmalloc和kmem-cache-系列的区别："><span class="nav-number">5.3.3.</span> <span class="nav-text">kmalloc和kmem_cache_系列的区别：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux下内存的查看和几个问题："><span class="nav-number">6.</span> <span class="nav-text">linux下内存的查看和几个问题：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#linux下物理内存统计等"><span class="nav-number">6.1.</span> <span class="nav-text">linux下物理内存统计等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#几个问题："><span class="nav-number">6.2.</span> <span class="nav-text">几个问题：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考："><span class="nav-number">6.3.</span> <span class="nav-text">参考：</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小兴"
      src="/images/headicon2.jpg">
  <p class="site-author-name" itemprop="name">小兴</p>
  <div class="site-description" itemprop="description">始于歧路，愿归于征途</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xdksx/" title="GitHub → https://github.com/xdksx/" rel="noopener" target="_blank"><i class="fa fa-fw fa-github-square"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/ksance@gmail.com" title="E-Mail → ksance@gmail.com"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/572897439" title="FB Page → https://www.facebook.com/572897439" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      friendly link
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://yoursite.com" title="http://yoursite.com" rel="noopener" target="_blank">Title</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小兴</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '06e6b70d396f6928e45a',
      clientSecret: 'cd03b7c657d50a5d76a7fa682c4f8eb48cb15fc3',
      repo        : 'xdksx.github.io',
      owner       : 'xdksx',
      admin       : ['xdksx'],
      id          : '4e204fce0ad643abc71bd6b940f1b4e7',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
