<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tcpip_pingtraceroute]]></title>
    <url>%2F2018%2F06%2F24%2Ftcpip-pingtraceroute%2F</url>
    <content type="text"><![CDATA[ping and traceroutepingping是ICMP中的回显报文类型： ping 对应的icmp，type字段为0/8,code字段为0 ICMP回显请求和应答报文格式： 123类型(0/8） code(0) 检验和 --4B标示符（unix系统中为进程pid) 序号 --4B 选项数据 最常见，回显时间，得到往返时间：通过在icmp数据报文中存放发送请求的时间值来计算往返时间，当应答返回时，用当前时间减去存放在ICMP报文中的时间值，即是往返时间 123类型(0/8） code(0) 检验和 --4B标示符（unix系统中为进程pid) 序号 --4B struct timeval tv; --8B 共16Byte,除开ip头 放抓包的图片，ping回显示时间 ping程序代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122int addr_conv(char *address,struct in_addr *inaddr)&#123; struct hostent *he; if(inet_aton(address,inaddr)==1) return (1); he=gethostbyname(address); if(he!=NULL) &#123; *inaddr=*((struct in_addr *)he-&gt;h_addr_list[0]); return (1); &#125; return 0;&#125;void send_icmp(int sockfd,sockaddr_in send_addr);void recv_icmp(int sockfd,sockaddr_in send_addr);int main(int argc,char **argv)&#123; int sockfd; sockfd=socket(AF_INET,SOCK_RAW,IPPROTO_ICMP); if(sockfd&lt;0) &#123; cout&lt;&lt;"creat socket error"&lt;&lt;endl; return 1; &#125; sockaddr_in send_addr; bzero(&amp;send_addr,sizeof(send_addr)); send_addr.sin_family=AF_INET; addr_conv(argv[1],&amp;send_addr.sin_addr);//send_addr.sin_addr.s_addr=inet_addr("192.168.0.110"); for(int i=0;i&lt;3;i++) &#123; send_icmp(sockfd,send_addr); recv_icmp(sockfd,send_addr); sleep(1); &#125; return 0;&#125;unsigned short checksum(unsigned short *addr,int len)&#123; int nleft=len; int sum=0; unsigned short *w=addr; unsigned short answer=0; while(nleft&gt;1) &#123; sum+=*w++; nleft-=2; &#125; if(nleft==1) &#123; *(unsigned char *)(&amp;answer)=*(unsigned char *)w; sum+=answer; &#125; sum=(sum&gt;&gt;16)+(sum&amp;0xffff); sum+=(sum&gt;&gt;16); answer=~sum; //answer=(unsigned short)sum&amp;0xffff; return answer;&#125;void send_icmp(int sockfd,sockaddr_in send_addr)&#123; static short int seq=10; char buf[8+8]; struct icmphdr *icmp=(struct icmphdr *)buf; //填充icmp首部 icmp-&gt;type=ICMP_ECHO;//类型 icmp-&gt;code=0;//和编码共同决定是回显报文 icmp-&gt;checksum=0;//头部包含校验和 icmp-&gt;un.echo.id=getpid();//标识符，唯一性，一般填充pid，这样即使几个程序发送ping也能识别，写成其他时接收失败 icmp-&gt;un.echo.sequence=seq++;//顺序号，回显时，显示，一般无规定，但是会在此基础上加１，接着加１，， //填充icmp数据(时间)//这里报文数据只有时间戳 struct timeval tv; //tv=(struct timeval*)icmp-&gt;icmp_data; gettimeofday(&amp;tv,NULL); memcpy(buf+8,&amp;tv,sizeof(tv)); int buflen=sizeof(struct icmphdr)+sizeof(struct timeval); //计算校验和 icmp-&gt;checksum=checksum((unsigned short *)buf,buflen); //发送icmp数据包 int len=sendto(sockfd,buf,buflen,0,(struct sockaddr *)&amp;send_addr,sizeof(send_addr)); if(len&lt;0) cout&lt;&lt;"send icmp error"&lt;&lt;endl; else cout&lt;&lt;"senmd ok"&lt;&lt;endl;&#125;void recv_icmp(int sockfd,sockaddr_in send_addr)&#123; char buf[256]; struct icmphdr *icmp; struct ip *ip; int ipheadlen; int icmplen; //接收icmp响应 for(;;) &#123; int n=recvfrom(sockfd,buf,sizeof(buf),0,NULL,NULL); if(n&lt;0) &#123; cout&lt;&lt;"recv error"&lt;&lt;endl; continue; &#125; ip=(struct ip *)buf; ipheadlen=ip-&gt;ip_hl&lt;&lt;2; icmplen=n-ipheadlen; if(icmplen&lt;16) continue; icmp=(struct icmphdr *)(buf+ipheadlen); if(icmp-&gt;type==ICMP_ECHOREPLY&amp;&amp;icmp-&gt;un.echo.id==getpid()) break; &#125; //计算时间差 struct timeval recv_tv; gettimeofday(&amp;recv_tv,NULL); struct timeval send_tv; memcpy(&amp;send_tv,icmp+1,sizeof(send_tv)); recv_tv.tv_sec-=send_tv.tv_sec; recv_tv.tv_usec+=recv_tv.tv_sec*1000000L; long interval=recv_tv.tv_usec-send_tv.tv_usec; //输出信息 cout&lt;&lt;icmplen&lt;&lt; " bytes fromfdfd "&lt;&lt;inet_ntoa(send_addr.sin_addr); cout&lt;&lt;" icmp_seq="&lt;&lt;icmp-&gt;un.echo.sequence&lt;&lt;" bytes="&lt;&lt;icmplen&lt;&lt;" ttl="&lt;&lt;(int)ip-&gt;ip_ttl; cout&lt;&lt;" time="&lt;&lt;(float)interval/1000.0&lt;&lt;"ms"&lt;&lt;endl;&#125; ip 记录路由选项：利用ip头，ip头长度字段为4bit,最长的ip首部为15x32bit=60字节，所以除去头20字节，选项字段最大40字节，除去3字节的code,len.ptr三个字节，剩下37个字节，可以容纳9个ip地址windows下可以通过ping -r ip来尝试 ip时间戳选项 traceroutetraceroute主要两点 利用ttl,ttl是一个有限值，每经过一个路由器减1，这样放置循环发包。 利用icmp报文，当路由器接收到ttl为0或1时，不转发，而是丢弃，并给信源回复一个icmp超时信息，且包含该路由器的ip 具体流程：traceroute发送一份ttl字段为1的ip数据报给目的主机，处理这个数据报的第一个路由器将ttl值减去1，丢弃该数据报，并发送一份超时icmp报文，这样就得到了该路径的第一个路由器的地址；以此类推，发送ttl为2的数据报，则得到第二个路由器的地址；直到到达目的地址；怎么知道到达了目的地?traceroute发送了一份udp数据包给目的主机，但它选择了一个不可能的值作为udp端口号（大于30000)，使目的主机的任何一个应用程序都不可能使用该端口号，则当包到达目的主机时，目的主机的udp模块会产生一个端口不可达的错误icmp报文。traceroute要做的是区分icmp是超时还是端口不可达，以判断什么时候结束 traceroute命令1234567891011121314151617181920212223242526272829303132traceroute www.baidu.comtraceroute to www.baidu.com (119.75.216.20), 30 hops max, 60 byte packets//ttl字段为30跳，每个数据包为60字节（20ip头等） 1 192.168.0.1 (192.168.0.1) 2.762 ms 3.485 ms 3.477 ms/发到网关1,针对每个ttl值发送三份包，分别在2.762,3.485,3.477收到 2 192.168.1.1 (192.168.1.1) 3.466 ms 3.453 ms 3.443 ms 3 101.232.192.1 (101.232.192.1) 6.807 ms 6.813 ms 7.412 ms 4 10.144.11.37 (10.144.11.37) 7.405 ms 7.393 ms 7.381 ms 5 10.144.14.138 (10.144.14.138) 7.369 ms 7.362 ms 7.340 ms 6 * * 14.197.242.145 (14.197.242.145) 10.329 ms 7 14.197.218.173 (14.197.218.173) 7.240 ms 14.197.248.253 (14.197.248.253) 6.855 ms 7.212 ms 8 14.197.240.249 (14.197.240.249) 44.799 ms 14.197.252.189 (14.197.252.189) 42.107 ms 14.197.253.145 (14.197.253.145) 50.051 ms 9 14.197.252.54 (14.197.252.54) 49.394 ms 49.414 ms 14.197.248.94 (14.197.248.94) 49.406 ms10 14.197.149.178 (14.197.149.178) 49.406 ms 49.383 ms 14.197.178.102 (14.197.178.102) 49.382 ms11 182.61.253.119 (182.61.253.119) 49.912 ms 182.61.253.117 (182.61.253.117) 50.916 ms 182.61.253.119 (182.61.253.119) 50.554 ms12 182.61.253.126 (182.61.253.126) 47.975 ms * 50.625 ms//5s未收到时打印一个*号并发送下一份数据包13 * * *14 * * *15 * * *16 * * *17 * * *18 * * *19 * * *20 * * *21 * * *22 * * *23 * * *24 * * *25 * * *26 * * *27 * * *28 * * *29 * * *30 * * * tcpdump输出： 123456789101112131415161718192021222324traceroute www.baidu.com(119.75.213.61)192.168.0.110.39650 &gt; 119.75.213.61.33434: [udp sum ok] UDP, length 3220:21:58.009075 IP (tos 0x0, ttl 1, id 5354, offset 0, flags [none], proto UDP (17), length 60)//ttl=1192.168.0.1 &gt; 192.168.0.110: ICMP time exceeded in-transit, length 68//网关回复icmp超时 IP (tos 0x0, ttl 1, id 941, offset 0, flags [none], proto UDP (17), length 60) 192.168.0.110.48912 &gt; 119.75.213.61.33435: [udp sum ok] UDP, length 3220:21:58.009114 IP (tos 0x0, ttl 1, id 5355, offset 0, flags [none], proto UDP (17), length 60) 192.168.0.110.43061 &gt; 119.75.213.61.33436: [udp sum ok] UDP, length 3220:21:58.009148 IP (tos 0x0, ttl 2, id 5356, offset 0, flags [none], proto UDP (17), length 60)//ttl=2 192.168.1.1 &gt; 192.168.0.110: ICMP time exceeded in-transit, length 68 IP (tos 0x0, ttl 1, id 942, offset 0, flags [none], proto UDP (17), length 60)//第2个路由器回复超时 192.168.0.110.52554 &gt; 119.75.213.61.33437: [udp sum ok] UDP, length 3220:21:58.009189 IP (tos 0x0, ttl 2, id 5357, offset 0, flags [none], proto UDP (17), length 60) 192.168.0.110.51967 &gt; 119.75.213.61.33438: [udp sum ok] UDP, length 3220:21:58.009243 IP (tos 0x0, ttl 2, id 5358, offset 0, flags [none], proto UDP (17), length 60) 192.168.0.110.45922 &gt; 119.75.213.61.33439: [udp sum ok] UDP, length 3220:21:58.009281 IP (tos 0x0, ttl 3, id 5359, offset 0, flags [none], proto UDP (17), length 60)//ttl==3 192.168.0.110.34392 &gt; 119.75.213.61.33440: [udp sum ok] UDP, length 32 101.232.192.1 &gt; 192.168.0.110: ICMP time exceeded in-transit, length 60 IP (tos 0x0, id 945, offset 0, flags [none], proto UDP (17), length 60) 192.168.0.110.57724 &gt; 119.75.216.20.33440: UDP, length 32//第三个路由器回复icmpc超时20:21:59.304604 IP (tos 0x0, ttl 59, id 0, offset 0, flags [DF], proto UDP (17), length 161) 从上面包的情况可以看到: 设备首先发送ucp包。若用更详细的打印看到端口号为源55050 目的端口:33443别的设备可能不同，但是都很大，这样到达时会发出端口不可达；ttl字段从1递增，源地址目的地址不变 路由器根据ttl的值，回复icmp超时包，回复给设备，从源地址可以看到，经过的路由器； 该icmp的包格式：类型11 code 0/1 校验和ip首部（包括选项)+原始ip数据报中数据的前8个字节 注意：每一次的路由都可能不一样 关于ip源站选路选项 ip通常都是动态的，即每个路由都要判断数据报下面该转发到哪个路由器，一般不对此进行控制；这里提供的思想是： 由源站发送者指定路由，即经过哪些ip 分为严格的源路由选择和宽松的源站选路 前者必须采用确切的路由，若发现失败则路由器返回源站选路失败的icmp报文； 后者致命一个数据包经过的ip清单，但是数据包在清单上指明的任意两个地址之间可以通过其他路由器； ip源站路由选项的格式：包含在ip头部的选项中，因长度有限只能包含9个ip:code(1) len(1) ptr(1) ip1(4) ip2(4)…. eg: traceroute -g 192.168.23.1 www.baidu.com traceroute实现 参考linux traceroute源码实现； 主要就是发送一多个dp包设置ttl递增，并将接收到的icmp报文打印出来；直到收到端口不可达报文时退出；]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_string]]></title>
    <url>%2F2018%2F06%2F24%2Fleetcode-string%2F</url>
    <content type="text"><![CDATA[leetcode_string传统字符串匹配： 简单写写,变量命名等就先不纠结了 1234567891011121314151617181920212223242526int strStr(char s[],char p[])&#123; if(s[0]=='\0'||p[0]=='\0') cout&lt;&lt;"p or s is null"&lt;&lt;endl; int k=0,j=0,i=0; for(i=0,j=0;s[i]!='\0'&amp;&amp;s[k]!='\0';) &#123; if(p[j]=='\0') break; if(s[k]==p[j]) &#123; k++; j++; &#125; else //不匹配时重新来过 &#123; i++; k=i; j=0; &#125; &#125; if(p[j]=='\0') return i; else return -1;&#125; kmp匹配算法kmp算法：基本过程见另一篇文章数据结构之字符串，这里贴写代码(未经大数据检验，谨慎观看)123456789101112131415161718192021222324252627282930313233343536373839404142int nextfunc(char p[],int next[])&#123; next[0]=-1; next[1]=0; int j=1; int k=0; while(p[j]!='\0') &#123; if(k==0||p[j]==p[k]) &#123; ++j; ++k; next[j]=k; &#125; else k=next[k]; &#125; return 0;&#125;int kmp(char s[],char p[])&#123; int i=0; int j=0; int next[100]; nextfunc(p,next); for (i=0;s[i]!='\0'&amp;&amp;p[j]!='\0';i++) &#123; //if(j==-1)j=0; if(s[i]==p[j]) &#123; j++; continue; &#125; while(s[i]!=p[j]&amp;&amp;j&gt;=0)j=next[j]; j++; &#125; if(p[j]=='\0') return i-j; else return -1;&#125; 简单测试12345678910int main ()&#123; char a[19]=&#123;'a','b','c','a','b','c','a','s','s','f','r','e','r'&#125;; char b[10]=&#123;'a','b','c','a','s'&#125;; int pos=strStr(a,b); cout&lt;&lt;pos&lt;&lt;endl; int pos2=kmp(a,b); cout&lt;&lt;pos2&lt;&lt;endl; return 0;&#125; 其他字符串算法题目：判读字符串是否为回文串 所谓回文串即正者读反着读都一样： 解决方案： 1.设置两个索引，一个从字符串开始位置往后走，一个从字符串最后的位置往前走，比较这两个索引指向的字符是否相等，直到遍历完整个字符串；注意这里其实并不需要遍历整个字符串，一个索引只需要走一半就可以，回文串两边对称的。 2.利用栈，思路类似 字符串转整数(atoi) 分析：这个题目需要注意的是各种不规则的输入和其他边缘条件如int整数的范围等 解决方案: 若是严格的检查，则判断字符ASCII码是否在0-9之间，注意整数的首位不能为0）；整数的正负；数据是否溢出；是否数据的表现形式如33x8fe；等等。 非严格的检查，如遇到非法的字符跳过即可；首位为0时跳过或者当成八进制等等 对两个二进制字符串求和 如”111”+”101”=”1100” 解决方案： 像十进制那样直接求和，进位，从最右边的字符开始，若相加大于1则进位，注意两个字符串可能一个很长一个很短，而进位可能一直需要延续 2.将两个字符串分别转换为十进制再做运算，结果再转为二进制 最长回文子串 暴力方法：将所有子串列出来先判断哪些是回文串，再取长度最长的；正则表达式 我对正则表达式的处理方案一直很倾向于用状态机，这种方法可以用图表示出来，方案的完备性好判断，别人也好理解； 递归方案最长公共前缀 找出字符串数组中的最长公共前缀：给定一个字符串数组，找出他们的最长公共前缀 分析：这道题目需求不明确，是需要 所有的字符串=都有的公共前缀还是若只有部分字符串有公共前缀也可以？也可能我理解有误~ 实现strtod()函数 即判断一个字符串是否表示一个数字如:”1.0” 分析：可以用状态机实现 整数和罗马数字的相互转换 这道题有些无聊count and say 一个数列如下：1 11 21 1211 111221,…意思是1,第二个表示第一个的情况，即1个1故为11,第三个数表示第二个数的情况，即两个1,21，以此类推 求数列中的第n个数 解决方案，直接模拟，一个一个算出来 Anagrams: 字符串中的打乱字母顺序从而得到新的单词如eat打乱后得到tea等 给定绝对路径简化它在一个英文句子中找到最后一个单词的长度]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DS_string]]></title>
    <url>%2F2018%2F06%2F24%2FDS-string%2F</url>
    <content type="text"><![CDATA[数据结构之串欢迎来到简单而又复杂的串世界,博主许久没有去研究串，还停留在以前学习和使用串的水平，再来一波学习和归纳，发现串的基本用法其实简单，也好理解，但是衍生出来的和应用相关，而且复杂，下面道来； 串的基本串的定义 “a1a2…..an”,其中包含字母，广义上可以是任意字符 在c/c++中结尾带’\0’，python则不带，长度均不包含’\0’ 串长度-不同编码不同，根据具体需要如字节，实际字符等 空串和空白串，空白又可能是tab,回车，空格等等“ 串的子串:子串个数：n(n+1)/2–等差数列，串常用的数据结构 串常量–存在从汇编去看－数据段(data) 123456789 .file "test.c" .section .rodata.LC0: .string "kesance".LC1: .string "%d\n" .text .globl main .type main, @function 串数组:将字符串存在顺序数组中 堆分配存在链表中字符串常用函数 子串个数： 串赋值 串比较 求串长 串拼接 求子串 替换子串 定位子串的位置字符编码和字符串匹配字符串的编码 所谓字符编码，就是将字符用二进制唯一表示。在计算机的世界里不是1就是0，无论什么字符最后存入的还是二进制数，只是从内存中读出来时解析不同而已，即如让计算机将读出来的00111000解析成数字8,如文本显示程序，当设定为某种编码时，将字节流解析成对应的字符～现在看到的许多字体库也是这样的，将一串二进制串和某个字体对应起来，解析程序负责处理匹配和显示等 https://en.wikipedia.org/wiki/Unicode unicode编码了解一下 传统模式匹配算法模式匹配，就是在字符串里面匹配另一个串相似或者相同的子串，传统的想法也和一般人想到的一样，扫描并一个一个字符对比，若第二串失配，则第二串重新匹配第一串的第二个，接着往下。。 KMP算法kmp作为完全匹配算法中的高效算法，基本原理如下：ps:大学学这个算法只学了它是什么原理，还没去想为什么这么做等） 基本思想：从上面看传统的匹配算法： 12a b c a e f g a b d a e f 像上面的字符串匹配，第一次失配的地方是在c,则按照传统的方式，则应该重新： 12a b c a e f g a b d a e f 但是其实如果是我们人去做匹配时，则会直接从： 12a b c a e f g a b d a e f 开始匹配，而kmp的基本思想也是这样；例子： 12345a b c d a b c f g e a b c e a b c t第一次失配在d,那下一次应该在 a b c d a b c f g e a b c e a b c t 所以它分为两部分，１是模式串在移动时候遵循的基本原理，２是当失配时，模式串的哪个位置的字符和源串的当前位置进行重新匹配； 1基本原理，重复：当模式串中存在大量的重复时，效果尤为明显12a b c d a b c e f g a b c d a b c t 上述例子一样，可以看到 以d 为中点，前后有相同的串，abc,则显然next函数也能隐士检测到这个，所以当显然因为模式串的前后abc相等，而后abc又和源串的后abc相等，所以源串的后abc和模式串的前abc想等，自然失配时候就可以从模式串的d开始匹配起 2重点在next的计算，它决定当发生失配时，模式串如何移动： 假设模式串为P,j是当前模式串正在匹配的位置，源串为S,i是源串的当前位置，k是当P[j]!=S[i]时，P应该和S[i]比较的位置，以next[j]=k表示，故关键是求出next数组，显然k&lt;j next如何计算得到:其实要利用前面的基本原理，P[0-k-1]==P[j-k~j-1]==S[i-k到i-1] (即next[j]=k)所以要求next[j+1]=?-若P[k]==P[j]P[0-k-1]+P[k]==P[j-k~j-1]+P[j]即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1-若P[k]!=P[j]我们已经知道（0，k-1）串和（j-k,j-1）串是相等的，所以可以把（0，k-1）串当做一个新的模式串，发现在新模式串中（0，next[k]-1）串与（k-next[k],k-1）串相等，所以（j-k,j-1）中存在与（0，next[k]-1）相等的串，所以可以把j移动到next[k],继续比较和移动。 具体程序： 1234567891011//显然，next[0]=-1,此时无法向左边移动了源串模式串都要移动next[1]=0,此时只能向左移动到0.int getnext(char *P,int next[])&#123; j=1,next[j]=0,k=0; while(j&lt;sizeof(P)&#123; if(k==0||P[j++]==P[k++]) next[j]==k;//next[j]=next[j]+1 else k=next[k]; &#125; &#125; 串和哈夫曼编码 霍夫曼编码是和编码相关的一个算法，是将一个串编码为二进制整数，如类似AABXBDHADFBFJD编码为1010011100011101001,而霍夫曼编码则作为转换算法，Huffman编码使得每一个字符的编码都与另一个字符编码的前一部分不同，不会出现像’A’：00， ’B’：001，这样的情况，解码也不会出现冲突。 论文查重对比的几个算法(文本相似度） 杰卡德（Jaccard）相似系数这种相似度计算方式相对简单，原理也易于理解，就是计算单词集合之间的交集和并集大小的比例，该值越大，表示两个文本越相似。在涉及到大规模并行计算时，该方法效率上有一定的优势。 余弦（Cosine）相似度余弦相似度是利用计算两个向量之间的夹角，夹角越小相似度越高，其公式为：假定A和B是两个n维向量，A是[A1,A2,…,An],B是[B1,B2,B3,…,Bn],则A与B的夹角余弦等于 等等,用时再看：https://www.cnblogs.com/huilixieqi/p/6493089.html linux下的diff命令还有win上的beyondcompare软件，这两个是用于比较文本的差异的，在代码移植时经常用到 串匹配－正则表达式 正则表达式用于匹配文本字符串，但是并不一定是完全匹配，且是匹配的串出现有随意性 正则表达式的理论基础 最早接触到正则表达式，是在大三学习编译原理的时候，解析词法语法的时候会用到正则表达式，用来过滤关键词，像c语言的很多关键词，以及判断它是不是合法的表达式，等等，常用的是lex和yacc,最原始的是自己的实现对词法和语法的解析，而不借助的lex； 正则表达，语法树，常用有限状态机来来实现，功能强大的如图灵机； 正则表达式和编译原理正则表达式的基本实现 用c实现正则表达实现词法分析： 常用的正则表达式 语言支持 脚本语言支持情况 sed,awk 串和流 流，所有的文本流 流分为二进制流和文本流]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_routeicmp]]></title>
    <url>%2F2018%2F06%2F10%2Ftcpip-routeicmp%2F</url>
    <content type="text"><![CDATA[IP选路和ICMP协议IP如何选路概述： ip选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组，区别于选路策略，后者是一组决定把哪些路由放入路由表的规则；ip执行选路机制，而路由守护程序则一般提供选路策略如rip,ospf 点对点时，直接送到 非点对点时，经过路由器送到 Ip层可以是配置为路由或者主机前者非则转发，后者非则丢弃 路由表项：每一项为 目的ip地址（网络地址指定网络中所有主机或主机地址); 下一站路由器的ip地址，可能充当中继转发的，下一站非终点； 标志：指明目的地址是网络还是主机，下一站是路由器还是直连的接口 数据传输的网络接口如wlan0,eth0 ip选路是逐跳进行的， 例子：没连接热点前：1234ernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface10.42.0.0 * 255.255.255.0 U 600 0 0 wlp2s0link-local * 255.255.0.0 U 1000 0 0 wlp2s0 连接热点后：12345Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Ifacedefault 192.168.0.1 0.0.0.0 UG 600 0 0 wlp2s0link-local * 255.255.0.0 U 1000 0 0 wlp2s0192.168.0.0 * 255.255.255.0 U 600 0 0 wlp2s0 123456789101112131415Destination 目标网段或者主机Gateway 网关地址，”*” 表示目标是本主机所属的网络，不需要路由Genmask 网络掩码Flags 标记。一些可能的标记如下： U — 路由是活动的 H — 目标是一个主机 G — 路由指向网关 R — 恢复动态路由产生的表项 D — 由路由的后台程序动态地安装,(由重定向报文创建） M — 由路由的后台程序修改(已被重定向报文修改） ! — 拒绝路由Metric 路由距离，到达指定网络所需的中转数（linux 内核中没有使用）Ref 路由项引用次数（linux 内核中没有使用）Use 此路由项被路由软件查找的次数Iface 该路由表项对应的输出接口 如何搜索路由表 搜索路由表，目的ip地址匹配条母时，送到该条目的下一站，否则下一步： 搜索路由表，寻找与目的网络相匹配的条目，找到则送到下一站，如本地局域网；否则下一步： 搜索路由表，寻找标为默认的条目，有则使用它 若走完最后一步都没有，则数据包无法被传送，会向生成数据包的程序返回主机不可达或者网络不可达的错误 详细例子见卷１，这里较清楚了 子网寻址rfc950 主机号再分为子网号和主机号，子网掩码也跟着变化；这样可以缩小路由表规模，想象一个包含30个子网的B类地址和30个C类地址相比 此时，外网–&gt;网关–&gt;局域网１–&gt;局域网１中的子网（局域网）10–&gt;子网11。。。 所以此时网关并非就是其直接路由器，若主机在子网11,10中，路由器需要知道发往哪个子网，通过子网掩码 给定ip地址和子网掩码后能知道什么：知道该主机所在的子网；路由器可以知道是本子网的主机还是本网络中其他子网的主机还是其他网络的主机。。。路由进行的比较不需要比较到主机，如先比较类别网络地址如A,B,C:如我们主机为140.252.1.1,子掩码为255.255.255.0,则与目的ip地址比较：140.252.4.5,可以知道B类网络地址相同但是子网不同(1,4),就不用再比较主机了， 特殊的网络地址ifconfig命令 ifconfig -a12345678wlp2s0 Link encap:Ethernet HWaddr 48:5a:b6:6e:c9:5f inet addr:192.168.0.110 Bcast:192.168.0.255 Mask:255.255.255.0 inet6 addr: fe80::d713:7c0f:b40c:c085/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:7032 errors:0 dropped:0 overruns:0 frame:0 TX packets:4297 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:3668623 (3.6 MB) TX bytes:703812 (703.8 KB) netstat命令 其实这个命令的功能很强，可以相互开服务端客户端通信和反向shell netstat -in12345Kernel Interface tableIface MTU Met RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flgenp1s0 1500 0 0 0 0 0 0 0 0 0 BMUlo 65536 0 1404 0 0 0 1404 0 0 0 LRUwlp2s0 1500 0 7257 0 0 0 4311 0 0 0 BMRU 123456netstat -rnKernel IP routing tableDestination Gateway Genmask Flags MSS Window irtt Iface0.0.0.0 192.168.0.1 0.0.0.0 UG 0 0 0 wlp2s0169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 wlp2s0192.168.0.0 0.0.0.0 255.255.255.0 U 0 0 0 wlp2s0 初始化路由表 ifconfig设置接口地址，并用route 命令添加或删除路由表项主机可以选择转发或者不转发报文 在配置文件中配置ipfordwarding: echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardrootICMP协议rfc792Icmp报文： ICMP：IP头(20字节）+ICMP报文 IP头：123456789101112131415 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version| IHL |Type of Service| Total Length |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Identification |Flags| Fragment Offset |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Time to Live | Protocol | Header Checksum |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Destination Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options | Padding |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 其中options和padding不一定有 ICMP报文：type+code共同决定ICMP类型，如回显or差错，，， 123456780 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Type | Code | Checksum |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| different type and code has different content || |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 被封装于ip报文中，ip头加icmp,所有报文前四个字节都相同(8位类型，8位代码，16位校验和） 类型+代码决定ICMP的报文类型，种类很多，见协议卷表 下列几种不会导致icmp差错报文： icmp差错报文； 目的地址为广播地址 作为链路层的广播地址 不是ip分片第一片 源地址不能为零地址，环回地址，广播地址或多播地址 上述是为了防止过去允许icmp差错报文对广播分组带来的广播风暴 ICMP协议总结几种类型： 主机不可达 重定向错误 路由发现报文 icmp地址掩码请求和应答 icmp时间戳请求和应答 icmp端口不可达 ping 回显请求： 等等见表 且类型不同发送的报文格式不同 主机不可达：当路由器收到一份ip数据报但是在路由表中搜索后找不到，不能转发时，会发送一份icmp主机不可达的差错报文 还有可能是已经经过了几个路由器后出现主机或网络不可达的情况，所以若是测试局域网，则先让路由器断开网络，ping路由器则确保问题不是在本地，而是在网络上； icmp重定向错误：举个例子，主机在路由表中搜索后将数据包发给默认路由，R1路由器，接着R1路由器搜索后发送给R2路由器，并同时发现它正在发送的接口(R2)和数据报到达的接口相同，即主机和两个路由器所在lan，即在同一个lan中）此时主机可以直接发送给R2,所以R1就发送一份ICMP重定向报文给主机，这样主机下次就可以直接发给R2了 如何更新路由表?通过ICMP的路由器发现报文：以及利用路由器的定期广播多播它们的路由器通告报文rfc1256,而它一般是由用户守护进程来创建和处理 icmp地址掩码请求和应答，发送对某个ip地址请求地址掩码，并接收到子网掩码。路由器回复或者主机回复 icmp时间戳请求和应答，通过向某个IP主机发送这个，从而得到时间信息，telnet也可以进行，如NTP协议（网络时间协议） icmp端口不可达：udp报文发送给主机后，若端口不匹配，对方主机会发送端口不可达的差错报文 ping回显，后面有文章记录ping程序编写动态选路使用场景上述讲的是静态路由表的情况：适合于1网络较小，2且与其他网络只有单个连接点，3且没有多余的路由时（如主路由失败，可以选择备用路由）； 总结：一种更新路由表的动态协议，从而达到最短路径 上述三个条件不满足时，通常使用动态选路协议 当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时出现动态选路，路由器之间必须采用选路协议进行通信；路由器上有一个称为路由守护程序的进程，它运行选路协议，并与相邻的路由器通信，根据收到的信息，更新路由表 分类：RIP ,OSPF(开放最短路径优先）,BGP 宏观上看在internet上，存在大量的主机，路由器等；并以一组自治系统(AS)的方式组织的，每个自治系统通常由单个实体管理，比如大学校园，公司，常常被定义为一个自治系统，NSFNET的internet骨干网形成一个自治系统； 自治系统中使用的选路协议，称为内部网关协议IGP或者称为域内选路协议，这些协议有RIP,OSPF 用于不同自治系统之间的路由器，称为外部网关协议EGP,常见有BGP unix选路守护程序：routed,gated等 RIP：rfc1058 rip采用udp报文，端口号位520，为一种采用距离向量的协议,易受攻击 流程： 初始化：启动一个路由守护进程时，先判断启动了哪些接口，接着在每个接口上发送请求报文，要求其他路由器发送完整的路由表，广播或点对点 接收请求：接收到上述请求后，会回复完整的路由表，否则处理请求报文每一个表项，若有链接到指明地址路由，则度量设置为我们的值，否则设置为16表示无穷大。返回响应 接收到响应后，更新路由表，如增加或修改或删除,采用Dijkstra算法得到最短路径树 定期选路更新，30s一次，进行广播发送完整路由表给相邻的路由器 触发更新：即每当度量发生变化，则对它进行更新，只需要发送度量变化的表项 定时器：3min内无更新路由，则度量设置为无穷大，标注为删除，再过60s删除并传波 注:度量就是跳数，相邻路由度量为１ rip问题：无子网概念；路由器或链路故障要很久才能稳定下来，即收敛慢；易发生环回路由；跳数限制了网络大小15 OSPF开放最短路径优先：rfc1247 是一个链路状态协议； 使用ip协议而不是udp.tcp, 不与邻站交换距离信息而是主动测试与其他邻站相连链路状态，并将这些信息发送给它的其他邻站，邻站接着广播出去，每个路由器接收到后更新路由表 收敛快 可以对每个ip服务类型计算各自的路由集，意味着对任何目的，可以有多个路由表表项，每个表项对应一个ip服务类型； 给每个接口指派一个费用，通过吞吐率，往返时间，可靠性等，可以给每个ip服务类型指派一个费用 同一个目的地址存在多个相同费用的路由时，在这些路由上平均分配流量，即流量平衡 支持子网 路由器之间的点对点链路不需要每端都有一个ip地址，－无编号网络，节省ip 多播而非广播 BGP边界网关协议rfc1268 自治系统分类： 残桩自治系统，他和其他自治系统只有单个连接，只有本地流量 多接口自治系统，和其他多个自治系统有多个链接，但是拒绝传送流量 转送自治系统，多链接且在一些策略准则下，它可以传送本地流量和通过流量 是距离向量协议，用于自治系统之间，定期发送keepalive报文，30sCIDR无类型域间选路：rfc1518,1519待探索]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_conanddest_semantics]]></title>
    <url>%2F2018%2F06%2F09%2Fcpp-conanddest-semantics%2F</url>
    <content type="text"><![CDATA[构造和析构函数语义学1.即使是abstract base class也可能需要手动写constructor,de…,关键是看它有没有non satic data member 例如:12345678910class Abstract_class &#123; public: virtual ~Abstract_base() = 0; virtual void interface() const=0; virtual const char * mumble() const &#123; return _mumble; &#125; protected: char *_mumble; &#125;; 上述例子，该抽象类本身不能被实例化，但是可以被继承，被继承时在构造时必须初始化 “mumble”,此时就需要用它的默认构造函数，所以必须为这个抽象类写一个构造函数； 2. 纯虚函数的存在：12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;class Abstra_class &#123; public : // virtual ~Abstra_class() =0; virtual ~Abstra_class() &#123; delete _mumble;cout&lt;&lt;"use ~abstra_class";&#125; //virtual void interface() const=0; virtual void interface() const &#123; cout&lt;&lt;"use interface Abstra_class:";&#125; virtual const char* mumble() const&#123; return _mumble; &#125; Abstra_class()&#123;_mumble=new char[4];cout&lt;&lt;"construct:Abs..";&#125; protected: char* _mumble;&#125;;class dev : public Abstra_class &#123; public: ~dev() &#123;dd=0;&#125; dev()&#123;dd=3;&#125; void useA ()&#123; Abstra_class::interface();//即使可以这样，但是链接失败，即因该函数的定义=0,重新加上定义使之不为pure就ok了 &#125; virtual void interface() const &#123;if(dd==4)cout&lt;&lt;"re";&#125; protected: int dd;&#125;;int main ()&#123; dev ddd; ddd.useA(); ddd.interface(); // Abstra_class::interface(); return 0;&#125; 输出：construct:Abs..use interface Abstra_class:use ~Abstra_class: “可以定义和调用pure virtual func ,但是只能被静态的调用，而不能通过虚拟机制 “这个在g++上实验了下，发现：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;class Abstra_class &#123; public : // virtual ~Abstra_class() =0; virtual ~Abstra_class() &#123; delete _mumble;cout&lt;&lt;"use ~Abstra_class:";&#125; virtual void interface() const=0; //virtual void interface() const &#123; cout&lt;&lt;"use interface Abstra_class:";&#125; virtual const char* mumble() const&#123; return _mumble; &#125; virtual void ii() const=0;//ensure is a abstra class Abstra_class()&#123;_mumble=new char[4];cout&lt;&lt;"construct:Abs..";&#125; protected: char* _mumble;&#125;;inline void Abstra_class::interface() const &#123;&#125;class dev : public Abstra_class &#123; public: ~dev() &#123;dd=0;&#125; dev()&#123;dd=3;&#125; void useA ()&#123; Abstra_class::interface();//即使可以这样，但是链接失败，即因该函数的引用为0 dd=4; &#125; virtual void interface() const &#123; if(dd==4)cout&lt;&lt;"\nre\n"; //Abstra_class::interface(); &#125; virtual void ii() const &#123;cout&lt;&lt;"is implenment";&#125; protected: int dd;&#125;;int main ()&#123; dev ddd; ddd.useA(); ddd.interface(); Abstra_class *pt=&amp;ddd; pt-&gt;interface(); // Abstra_class::interface(); return 0;&#125; 输出了两次re,说明可以通过虚拟机制调用它；interface在这里被内联的定义了空的函数，它不算pure了，所以上述说法感觉存在问题。。。 注意，因为在每一个derived class destructor会被扩展，以静态方式调用每一个virtual base class 和上一层的desturctor, 所以只要缺少任何一个 base destructor定义则链接失败 ，所以需要定义pure virtual destructor 一个比较好的替代方式就是不要把vitual dect~定义为pure 考虑到成本，不要把所有的函数都定以为virtual 3)虚拟规格的存在： 在virtual func要不要为const ,主要看要不要对date member做修改所以不要随便定义为pure,virtual const,毕竟效率 考虑几种情况下的构造情况：一、无继承情况下对象构造几种方式：123456789Point global; //周期：程序的生命周期，exit前 Point foobar()&#123; Point local; //此函数的周期，调用默认构造函数但是不会初始化成员 Point *heap=new Point;//delete 前，调用默认构造函数，但不会初始化成员 *heap=local;//local若未调用用户初始化的构造函数，则warning,调用拷贝赋值函数，maybe 位搬移 delete heap;//默认析构函数 return local;//maybe拷贝构造或者位搬移 &#125; 考虑这几个对象的声明周期 在c中，global会被放入bss中，未初始化，但是c++中所有的全局对象被当做“初始化过的数据”，会调用constructor函数 可以测试一下 一般情况下，c++默认为类生成：default constructor,destructor,copy constructor,copy assignment operator123456789101112#include&lt;iostream&gt;using namespace std;class Point &#123; public: Point ()&#123;cout&lt;&lt;"in constructor "&lt;&lt;endl;&#125; ~Point() &#123;cout&lt;&lt;"in destructor"&lt;&lt;endl;&#125;&#125;;Point glo;int main ()&#123; return 0;&#125; 显然在定义Point glo的时候构造函数是会调用的 １、抽象数据类型： 根据需要决定是否写constructor destructor或者默认的就足够了 global类型的对象直到程序激活才调用构造函数 显性的初始化列表比将构造函数扩展为inline效率更高，后者需要赋值等，看下面例子：1234567891011121314151617181920212223242526272829#include&lt;iostream&gt; using namespace std; class Point&#123; public: Point(double x = 0.0, double y = 0.0, double z = 0.0) :_x(x), _y(y), _z(z)&#123;&#125; void print()&#123; cout &lt;&lt; _x &lt;&lt; endl &lt;&lt; _y &lt;&lt; endl &lt;&lt; _z &lt;&lt; endl; &#125;; private: double _x, _y, _z; &#125;; int main()&#123; Point local1 = &#123; 1.1, 1.2, 1.3 &#125;;//用g++ --std=c++11可以，若为double a=1.5; ..=&#123;a,...&#125;变量形式则不行（c++11可以） local1.print(); system("pause"); return 0; &#125; ``` 而在显性初始化列表（explicit initialization list)-&gt;xxx=&#123;yyy&#125;;使用时较快是如下原因： 函数的activation record 被放进程序的堆栈时，initializatioin list 中的常量就可以被放进local1的内存中了; 但是explicit initialization list带来三个缺点：+ 只有当class member 都是public时才生效，这点实验private时也可以 + 只能在&#123; &#125;中指定常量，因为在编译期间进行评估求值+ 由于编译器为自动施行，所以失败的可能性更高 看一下汇编代码：```cppclass Point&#123; public: Point(int x = 0, int y = 0, int z = 0) :_x(x), _y(y), _z(z)&#123;&#125; 1234560x400938 push %rbp0x400939 mov %rsp,%rbp0x40093c mov %rdi,-0x8(%rbp)0x400940 mov %esi,-0xc(%rbp)0x400943 mov %edx,-0x10(%rbp)0x400946 mov %ecx,-0x14(%rbp) 12345678 void print()&#123; cout &lt;&lt; _x &lt;&lt; endl &lt;&lt; _y &lt;&lt; endl &lt;&lt; _z &lt;&lt; endl; &#125;; private: int _x, _y, _z; &#125;; int main()&#123; int a=1; Point local1 = &#123; a, 4, 5&#125;; 1234560x4008a4 mov -0x24(%rbp),%esi0x4008a7 lea -0x20(%rbp),%rax0x4008ab mov $0x5,%ecx0x4008b0 mov $0x4,%edx0x4008b5 mov %rax,%rdi0x4008b8 callq 0x400938 &lt;Point::Point(int, int, int)&gt; 上述讲的activation record是： Locals to the callee Return address to the caller Parameters of the callee从上述的汇编代码可以看到，在做显示初始化列表时将常量值赋给ecx等两个寄存器，接着调用构造函数，构造函数将寄存器的内容赋给成员，而其实采用Point local2;这种直接调用构造函数的发式也是如此，且和在构造函数中赋值给成员时转换的汇编相同，所以不是很理解这块的区别，在g++ c++11是如此表现的 ２、为继承做准备：继承可能用到多态，此时需要使用virtual ,那就会带来constructor等函数中加入对vptr的初始化（copy constructor等）c++标准会要求编译器尽量延迟对nontrivial members的实际合成 操作，直到真正遇到其使用场合：这里trivial意思是无意义，这个trivial和non-trivial是对类的四种函数来说的： 构造函数(ctor) 复制构造函数(copy) 赋值函数(assignment) 析构函数(dtor) 如果至少满足下面3条里的一条： 显式(explict)定义了这四种函数。 类里有非静态非POD的数据成员。 有基类。 那么上面的四种函数是non-trivial函数，比如叫non-trivial ctor、non-trivial copy…，也就是说有意义的函数，里面有一下必要的操作，比如类成员的初始化，释放内存等。 二、继承体系下的对象构造：constructor函数中的隐藏代码， 初始化列表 member的默认构造函数,若该member未出现在初始化列表中 vptr，在1,2之前，指向vtable base class constructor 1,2,3之前，以声明顺序为顺序，若在member initialization list中，则应传递参数，否则在1,2,3前加入其默认构造函数。多继承时可能this指针调 virtual base class constructor，从左到右，从最深到最浅 ，同4，若在list中有则用，否则。。 例子：12345678910111213141516class Point&#123; public: Point (float x=0.0,float y=0.0); Point(const Point&amp;); Point&amp; operator=(const Point&amp;); virtual ~Point(); virtual float z() &#123;return 0.0;&#125; protected: float _x,_y; &#125;; class line &#123; Point _begin,_end; public: Line(....); Line(...); &#125;; line的默认析构函数会被合成，但是无意义，当然它的member的默认析构函数会被加入。。。其他类似 三、虚拟继承： 考虑下面的例子： 12345678910class Point3d:public virtual Point&#123; public: Point3d(float x=0.0,float y=0.0,float z=0.0):Point(x,y),_z(z)&#123;&#125; Point3d(const Point3d&amp; rhs):point(rhs),_z(rhs._z)&#123;&#125; ~Point3d(); Point3d&amp; operator=... //.. proteced: float _z; &#125; 传统的如上面的扩充构造函数： 12345this-&gt;Point(:Point(x,y);this-&gt;_vptr_Point3d = vtbl_Point3d;this-&gt;_vptr_point3d_point=_vtbl_point3d_point;this-&gt;_z=rhs_z;return this 但是在这里，虚拟继承这显然不够准确： 考虑当出现菱形继承： 123class Vertex:virtual public Point;class Vertex3d:public Point3d,public Vertex&#123;;&#125;;class Pvertex:public Vertex3d&#123;;&#125;;' 那作为被共享的Point subobject应该由最底层的如Vertex3d来初始化： 而最底层显然也会初始化Point3d和vertex,并调用他们的构造函数；如果他们的构造函数不加限制，就会又调用Point的构造，导致错误； 所以应该做限制，如下： 1234567Vertex3d::Vertex3d(Vertex3d *this,bool __most_derived,float x,float y,float z)&#123;if(__most_derived!=false)//判断是否为最底层 this-&gt;Point::Point(x,y);//是则构造最上层的 //调用上一层的base classes //设定__most_derived为falsethis-&gt;Point3d::Ponint3d(..);... 而在123456Point3d::Point3d(Point3d* this,...)&#123; if(___most_derived!=false) this-&gt;Point::Point(x,y); .... &#125; 所以最底层的构造函数等会限制中间层对最上层的构造 思考： 当obj只是某个完整的obj的子obj时，则不用调用virtual base class constructor:,如上，那就产生了一种提高效率的方式： 将构造函数分割为obj和subobj,，前者为完整版本的obj，自然要调用所有，包括基类的构造，后者不用，这种分裂可以提高效率 vptr初始化语意 题外，这本书总喜欢讨论特殊的情况，哭笑，下面也是，在构造函数中调用虚函数222 主要讨论vptr什么时候初始化合适，以及为什么 constructor调用顺序：考虑： 123class Vertex:virtual public Point;class Vertex3d:public Point3d,public Vertex&#123;;&#125;;class Pvertex:public Vertex3d&#123;;&#125;;' 当一个PVertex对象被构造时，构造函数顺序为： PointPoint3dVertexVertex3dPvertex 假设这个继承体系中的每一个类都定义了一个virtual func size()，该函数负责传回class的大小；如果我们写：Pvertex pv;Point3d p3d;Point *pt=&pv;那么这个调用pt-&gt;size()传回PVertex的大小，而pt=&p3d; pt-&gt;size()则传回p3d的大小； 更进一步，特殊情况：当在构造函数中调用这个操作时，如在point3d构造函数中调用时，是选择哪个class的size,毕竟现在正在构造point3d,答案是point3d的 考虑如何使得上述生效? 静态调用Point3d::size()或者bnalalla 最后，利用vptr虚拟机制，即要在调用size之前初始化好其class对应的vptr 总结：在这种情况下，vptr在base class constructor 调用之后，在程序员代码之前（如size),或是初始化列表所列的member初始化操作前 更好的，分割constructor为完整obj和subobj 对象复制语意学复制函数什么时候会被合成和使用 前言，当你设计一个类，并以一个对象复制给另一个对象时，有三种选择： 什么也不做，实行默认行为 提供一个显性拷贝函数 拒绝，只需要把复制函数声明为private就可以 考虑默认的行为： bitwise copy行为，当不出现一下情况时，甚至不会调用复制函数，而是做bitwise copy 而当出现以下行为时，调用默认的copy assignment operator函数，并合成相关操作： 当class中有mem obj，这个obj有一个copy ass operaator 当类的基类有copy assi opera.. 类带virtual func 继承自一个virtual base class 写一个显性的复制函数： 在发生上述情况时，编译器也会像合成构造函数一样在显性的复制函数中加东西 而继上面的，Point共享基类，编译器如何能在Point3d和Vertex的copy assignment operator中压抑point的copy assignment operator呢? 书中的后面有些难以理解，等后面再探索吧，哎时间有限。。对象的功能测试对象构造和拷贝的成本，在从简单形式，单一继承，到多重继承，虚拟继承等情况下的时间复杂度解构语意学 析构函数并不会总是被合成出来，更别提调用； 只有在类内带的member object或者自己的base class带有destructor，编译器才会合成一个析构函数，否则被视为不需要或者不用合成调用 析构函数没必要和构造函数对称 析构函数一般有以下顺序： 先调用最底层子类析构函数，接着往上，直到基类 析构函数本身在被执行时，vprt会在程序员代码前被执行 若class拥有member class object ,而后者拥有destructor,则他们会以其声明顺序相反顺序被调用 如果object内带一个vptr,则首先重设相关的virtual table 若有任何直接的非虚基类拥有析构函数，则同上 若有虚基类，则按照构造顺序相反顺序调用 类似于构造函数，可以分裂]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_funcmember_memory]]></title>
    <url>%2F2018%2F06%2F09%2Fcpp-funcmember-memory%2F</url>
    <content type="text"><![CDATA[c++ function语意学something:恩，这部分记录自己对c++中的函数特殊性的理解，本想深入函数本质，之前接触过，记得在linux内核剖析那本书讲的很好。 可以参考； 实现类的成员函数和类之间的关联，即通过对象能调用成员函数。这种实现，可以是以下几种方式：1）struct+函数指针：结构体中，一个成员函数对应一个指针，增加空间 如何操作成员？2）函数+this指针，普通函数，this指针一个，不添加额外多的空间，this 操作成员。。。 c++的类主要是将成员和函数封装起来。那么成员的封装就像struct一样，而函数呢？成员函数如何和类，对象联系起来？–this指针 c++中的成员函数和普通函数一样，只是多了个this指针，这个指针指向当前调用这个函数的对象，并以形参传入，这样，成员函数就可以使用对象成员了，通过this指针； 这里也是根据深入探索c++模型中第四章，function语义学总结的： 引入这个问题：通过对象和对象指针来调用成员函数的不同：Point3d obj;Point3d *p=&obj;两者效率有何不同？ 通过上面分析：当这个成员函数为普通的成员函数时，则直接调用函数，传入this指针，所以基本没有大的区别 以下分为几种函数讨论：非静态成员函数：为了支持this指针等构成成员函数，c++做了如下步骤： a;改写函数原型：安插了一个this参数 b；对对象成员的操作，通过this c;对成员函数写成外部函数，并将其名称进行mangling处理，成独一无二～类似：函数名___类名参数名 等等 如何命名：成员函数和成员都会被名称特殊化处理：一般加上base class &amp;derived class名 对重载函数而言如何区分：加上参数链表； 当extern C时，会压抑这种特殊命名化 具体编译器实现不同，可以通过汇编等。gdb等看 鉴于此：看一个例子：当你需要构造一个（拷贝构造函数）或者改变一个类的成员： 伪代码： 1234567891011void normalize__Point(register const Point3d *const this,Point3d &amp;_result) &#123; _reuslt.Point3d::Point3d() //默认构造函数： _result._x=this-&gt;__x/2; ... return ; &#125; 那么，以下这种方式：更好： Point3d Point3d::normmalize() const&#123; return Point3d(_x/2 ...)直接构建会更快） =》转换为return Point3d(this-&gt;_x/2,...) virtual func若normilaze是虚拟函数，则ptr-&gt;normilaze()=》 （*ptr-&gt;vptr[1])(ptr);可以看到效率较低，所以当确认不用多态机制的时候，最好抑制它，直接使用：Point3d::xxx 这种方式调用函数而若被写成内连函数会更优–原因待探索： 静态成员函数： 显然这种能被类直接调用的函数，没有this指针，从而也就无法用成员 这种函数的出现，是因为一种需求：即不用每个成员函数都会使用成员，不一定需要this 不用声明一个对象就可以调用函数，当非要对象不可，又不用成员时： 1((Point3d*)0)-&gt;object_count() ; 有了static后，就不用上述方式了 所以static的特性完全来源它的原理： 它不能直接存取non static 成员 它不能被声明为const volatile virtual 能直接被类调用静态成员函数和普通函数更像，因为它没有this指针，也就不是这种类型：~ unsigned int(*) ();所以更可以和类之外的元素沟通，比如回调函数 虚拟成员函数 a 为了支持多态，需要在执行期间能判断到底调用哪个函数？即pz-&gt;z()这个函数，pz为基类指针，而能调用子类函数 b 基类指针或引用参考到的（指向的）子类，，子类中的重写父类的函数，在调用时并不知道传入哪个this,即表现为调用哪个函数 c 那么为了支持通过基类能调用它，通过子类也能调用该函数，则需要基类和子类共享某个东西，他能正确决议出要调用的函数 带来：额外的空间，和c的兼容性 积极多态的概念：（１）被指出的对象真正被使用；（２）dynamic_cast那么哪些函数需要支持这样的特性－－－》由virtual标志来指出如何在执行期间调用真正的函数？－－－》ptr所指的对象真实类型＋函数的位置 真实类型放在vtable[0] 编译期间做的：在每个对象中加入：一个字符串或数字来表示class 类型＋一个指针，指向表格vtable,它带有程序的virtual func执行期地址确定表格中的函数指针，执行期无法改变表格一个类对应一个表格，每个virtual func被指定一个固定的索引值 执行期间做的：为vptr分配内存地址。它的值在编译期间确定，类似于x=3; 指向vtable调用函数时激活 。编译器已经为其转换语义为xxx-&gt;vptrn.. 注意，当一个子类继承基类时，vptr继承过来，当子类改写virtual函数时，则改变表中的指针指向子类的；当子类添加一个新的virtual func时，则在表中加一个slot 唯一在执行期间才知道的：slot(n)到底指向哪个函数实体细想一下： derived de; //编译期间，符号表确认要分配的对象类型,执行期间分配内存和调用构造函数等，构造函数中会初始化vptr, base *p=&amp;de;//编译期间，类似于int x=3;,执行期间分 配内存给x,并将３给x,确定p所指的真正对象，从而才能取得vptr,到调用到最终的函数 p-&gt;xx();//xx为virtual (*p-&gt;vptr[1])(p) some question //关于执行期和编译期确定的东西，有些困惑，为啥编译器不能在p-&gt;xx()的时候指定调用子类的xx()? //在编译器扫描代码的时候，知道定义了一个derived类型的变量，知道，定义了一个base指针，并指向的变量类型为derived,后面调用时也能 确定函数名，为啥不能根据已存的这些信息。来得到哦。这时p指向的是derive类型的。所以调用derived的函数？ 不过也是，编译器从做词汇扫描，到语义扫描，出符号表，到语法检查，语义规则等 多重继承下面的virtual func 考虑以下例子： 1234567891011121314151617class base1&#123; public : int a; virtual int a()&#123;return a;&#125; virtual base1* clone() const; &#125;class base2&#123; public: int b; virtual int b()&#123;return b; virtual base2* clone() const; &#125;class derive:public base1,public base2 int c; virtual int c()&#123;return c;&#125; virtual derive* clone() const; &#125; 对于和derived有相同起点的base1不用考虑太多，关键是base2,;有三个问题要解决：1234567 (1)virtual destructor (记得之前是逐层调用） （２）被继承下来的b() (3）一组clone函数 （a) 做base2 *pbase2=new derive; ＆＆＆编译期间确定：＆＆＆ =&gt; derived *tmp=new derive; base2 *pbase2=tmp?tmp+sizeof(base1):0; 为了使pbase2能访问到 b 即pbase２-&gt;b, 多重继承下使用 base *p=de;时，注意此时需要调整，让p指向的是de中的base对应部分 当通过delete pbase2时，此时需要删除完整的对象，所以pbase２指针需要调整到指出完整对象的起始点他也要通过上述a类似的加法，以及调用virtual destructor函数 12 如base2 *pbase2=new derive; delete pbase2;//invoke derive class's destructor (virtual ) 首先这个调用要通过vptr,其次，传入的this指针需要调整 ＆＆＆执行期间确定＆＆＆ 注意：然而，这种offset加法无法在编译期间直接设定。pbase2所指的真正对象只有在执行期间才能确定//如何调整；早期的想法是：将vtable中的slot改为一个slot放置函数指针faddr和this的offset//则：（pbase2-&gt;vptr[1])(pbase2);//改为 （pbase2-&gt;vptr[1].faddr)(pbase2+pbase2- &gt;vptr[1].offset);但是连带处罚了其他形式virtual func调用， 那如何处理？ [１]方法１：thunk ～：this+=sizeof(base1)Derived::~Derived(this);//只有汇编才有效率 如何使能？在virtual table slot继续内含一个简单的指针，slot中的地址可以指向一个virtual func或者一个thunk(若需要调整this)其实多重继承来讲，每个继承的基类，都需要一个virtual table;,这样派生类就会维护多个基类的vtable 1)经由derived或第一个base class)调用，不需要调整this 2)经由&gt;=2的base class 调用，同一种函数在virtual table中可能需要多笔对应的slot base1 *pbase1 =new derived; base2 *pbase2=new derived; delete pbase1//不需要调整this,virtual table slot放置正真的destructor地址 delete pbase2//需要调整this ,放置thunk vptr和vtable命名也会被特殊化 参考图在书中，这里不放 [２]方法２ ： 因为动态链接器的原因，使得符号链接变得缓慢 为了调整执行期链接器的效率，sun编译器将多个vtable 连锁为一个，指向次要表格的指针可以由主要表格加offset 其他类似。例子： 1234567891011 base2 *ptr =new derived;delete ptr;//此时调用derived::~deirved,故ptr需要被调整，若为virtual，需要更多derived *pder=new derived;pder-&gt;b();//注意b没有被改写，所以需要调整pder指向base2 subobjbase2 *pb1=new derived;base2 *pb2=pb1-&gt;clone()//注意是调用derived:clone,所以调用后返回值要改变器指向base2 subobj当函数被认为足够小 ，sun编译器会采用某种算法优化，split。。，否则不会，具体待了解。所以virtual func的通常大小为８行 [３]IBM:函数若支持多重进入点，将不必有许多thunk;将thunk操作放在virtual func中，里面判断是否需要调整this指针 虚拟继承下的virtual func这种情况相当复杂了。需要探索上述的这些问题：point2d.point3d的对象不再相符，即使只继承一个，即单一虚拟继承，也需要调整this指针12345678910111213141516class point2d&#123; public: point2d() virtual ~point2d() virtual void mumble() virutal float z() protected: float _x,_y; &#125; class point3d:public virtual point2d&#123; public: point3d() ~point3d protected: float _z; &#125; 可以尝试下写出例子比较point2d和point3d指针看指向是否相同 当virtual base class中包含virtual func和nonstatic member时，各个厂商实现不同，复杂，作者不建议这么做 －－－－－－－－－－－－－－－－－－－ 函数的效能： 这部分可以通过函数的调用方式感性的了解，或者根据不同的编译器。测试对比几种调用的时间，以及是否已经开启优化等 （如编译器将被视为不变的表达式提到循环之外） （通过消除局部对象的使用可以消除对constructor的调用） 指向memeber func的指针： 取一个nonstatic member func的地址，若为nonvirtual 则为其在内存中的真正地址。 但需要this参数。 指向member func的指针：double (Point::pmf)();类似 定义：double (point::coord)() =&amp;point::x; 赋值:coord=&amp;point::y 调用：（origin.coord)()/(ptr-&gt;coord)() 转换为：(coord)(&amp;origin)/(coord)(ptr) 指向virtual memeber func指针 在g++中 1234567891011121314151617181920212223242526 #include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;class Base1 &#123; public: virtual float getp() &#123; return mp;&#125; void setp(float mmp)&#123;mp=mmp;&#125; virtual int test()&#123;return 3;&#125; virtual int test1()&#123;return 4;&#125; private: float mp;&#125;; int main()&#123; float (Base1::*pmf)()=&amp;Base1::getp; Base1 *ptr=new Base1; ptr-&gt;setp(3.2); cout&lt;&lt;ptr-&gt;getp()&lt;&lt;endl;//3.2 cout&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;endl;//3.2 会被内部转换：（*ptr-&gt;vptr[(int)pmf])(ptr) printf("%p\n",&amp;Base1::getp);//1 索引值 printf("%p\n",&amp;Base1::setp);//40xxx真实地址 printf("%p\n",&amp;Base1::test);// 9，为什么是９不清楚 printf("%p\n",&amp;Base1::test1);//11 return 0;&#125; 所以，对于虚拟函数也是可以通过函数指针来访问的，只不过得到的地址是索引值，但不影响访问或者对以下1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;class Base1 &#123; public: virtual float getp() &#123; return mp;&#125; void setp(float mmp)&#123;mp=mmp;&#125; int test()&#123;return 3;&#125; virtual int test1()&#123;return 4;&#125; private: float mp;&#125;; int main()&#123; float (Base1::*pmf)()=&amp;Base1::getp; Base1 *ptr=new Base1; ptr-&gt;setp(3.2); cout&lt;&lt;ptr-&gt;getp()&lt;&lt;endl; cout&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;endl; printf("%p\n",&amp;Base1::getp); printf("%p\n",&amp;Base1::setp); printf("%p\n",&amp;Base1::test); printf("%p\n",&amp;Base1::test1); int (Base1::*pmi)()=&amp;Base1::test1;//or test 可以指向两种，编译器如何区分呢？cfront２ 通过判断是索引（may &lt;127)还是函数地址来区分 Base1 *ptr2=new Base1; cout&lt;&lt;(ptr2-&gt;*pmi)()&lt;&lt;endl; delete ptr; delete ptr2; return 0;&#125; 多重继承下指向member func指针为了让mem func point能支持多重继承和虚拟继承：噢这种情况很复杂了。你得知道它指向的是virtual 还是non virtual书中并没有探讨太多，野比较复杂，这里举一个例子，探索细节可以看编译器，gdb等结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;class Base1 &#123; public: virtual float getp() &#123; return mp;&#125; void setp(float mmp)&#123;mp=mmp;&#125; int test()&#123;return 3;&#125; virtual int test1()&#123;return 4;&#125; private: float mp;&#125;;class Base2 &#123; public: virtual float get2p()&#123;return m2p;&#125; virtual void set2p(float m2pp)&#123;m2p=m2pp;&#125; int test22() &#123;return 5;&#125; virtual int test21()&#123;return 6;&#125; private: float m2p;&#125;;class Der:public Base1,public Base2&#123; public: virtual float get3p()&#123;return m3p;&#125; private: float m3p;&#125;;int main()&#123; float (Base1::*pmf)()=&amp;Base1::getp;//这后面的调用就发挥想象把，想怎么尝试都行 Base1 *ptr=new Der; ptr-&gt;setp(3.2); cout&lt;&lt;ptr-&gt;getp()&lt;&lt;endl; cout&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;endl; printf("%p\n",&amp;Der::getp); printf("%p\n",&amp;Base1::setp); printf("%p\n",&amp;Base1::test); printf("%p\n",&amp;Base1::test1); int (Base1::*pmi)()=&amp;Base1::test1;//or test Base1 *ptr2=new Base1; cout&lt;&lt;(ptr2-&gt;*pmi)()&lt;&lt;endl; delete ptr; delete ptr2; return 0;&#125; 效能inline func:首先得直到，内联函数实际上表现为什么？函数本质上被经过栈调用，而内联函数是直接 在主函数中铺开为表达式，所以调用内联函数 能提高效率，但是响应的源代码会变大，而且有参数的限制应用：在操作符函数中，指定set,get类函数，使得操作符函数能被写成普通的函数。 而set get 写成inline函数，会减少效率降低inline关键词只是请求，并不会所有都inline展开，编译器会做判断权衡具体看书，不是很细内联函数两个注意点：形式参数：inline扩展时，每一个形式参数会被对应的实际参数代替：123456789101112131415 inline int min (int i,int j)&#123; return i&lt;j?i:j; &#125;三个调用：inline int bar() &#123; int minval; int val1=1024; int val2=2048; minval=min(val1,val2); 参数直接替换val1&lt;val2?val1:val2; minval=min(1024,2048);替换后直接使用常量：1024 minval=min(fool(),bar()+1) 引发参数副作用，需要导入一个临时对象，以避免重复求值： int t1,t2; minval=(t1=foo()),(t2=bar()+1),t1&lt;t2?...) return minval&#125; 局部变量:在内联函数中加入局部变量，会导致因为维护局部变量带来的成本； 内联函数在替代c宏，是比较安全的；但是若宏中参数有副作用的话，如上，会导致大的扩展码以维护局部变量或者生成临时的变量]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_datamember_memory]]></title>
    <url>%2F2018%2F06%2F09%2Fcpp-datamember-memory%2F</url>
    <content type="text"><![CDATA[c++ class datamemory详细介绍c++的成员布局，类本身的布局和在各种情况下的布局 “类”本身的大小： the simplest 引入 1.2 多少内存能表现一个class?最小是１ size 123456789101112131415161718192021222324252627282930313233343536373839404142class T&#123; &#125;; ---1 一个char 表示这个类型class X :public virtual T&#123;&#125;; --指针大小，指针指向T virtual base class subobjectclass Y :public virtual T&#123;&#125;; --指针大小class A:public X,public Y &#123;&#125;; --两个指针大小 ``` －－从深入那本书中说有两种方式，体现class的大小，这里是优化的特殊的类型，这些好理解，但是需要类的空间的真正原因是什么？这T的一个char存储了什么？ 用来干嘛？那在X中指向T的又是为什么需要？ 最小１char? 我们知道，当一个类中仅包含一个nonstatic member时，如int ,则对象为int大小，但是当类为空时，对象如何去分配内存？如果同时定义了两个对象，那如何去区分这两个对象？让他们地址不相同？－－－所以这里需要一个char+ 注意，类本身也是一个类型，像int，struct一样，它的大小为４，struct成员和对齐，则类也一样，sizeof是在编译期间（确定c89中） 一个例子：```cpp#include&lt;iostream&gt;#define _sizeof(T) ((size_t)((T*)0+1))#include&lt;stdio.h&gt;using namespace std;class T &#123;&#125;;class X:public virtual T&#123;&#125;;class Y:public virtual T&#123;&#125;;class A :public X,public Y&#123;&#125;;class TT&#123;public:int q;int x;&#125;;int main()&#123; T t1,t2; int xx; if (&amp;t1==&amp;t2) cout&lt;&lt;"same"&lt;&lt;endl; printf("%x\n",&amp;t1); printf("%x\n",&amp;t2); printf("%x\n",&amp;xx); // int sie=(Y*)0+1; // printf("%x\n",X&#123;&#125;); int s= _sizeof(TT); ８ 编译期间确定，直接把８赋给内存 cout&lt;&lt;_sizeof(T)&lt;&lt;endl; １ cout&lt;&lt;sizeof(TT)&lt;&lt;endl; ８ cout&lt;&lt;sizeof(T)&lt;&lt;endl; cout&lt;&lt;sizeof(X)&lt;&lt;endl; cout&lt;&lt;sizeof(Y)&lt;&lt;endl; cout&lt;&lt;sizeof(A)&lt;&lt;endl; return 0;&#125; 自然t1,t2地址不同，相邻 那么一个类大的方面需要这些：１）类中定义的普通成员２）语言本身所造成的额外负担如virtual机制，virtual table ,virtual base class subobject３）Aligmnment带来的（编译器的优化会带来内存布局的影响） 上述例子：当编译器不做优化时，为１，8+1+3,8+1+3 ,1(X)+8+8+3(ali) 总结datamember的布局 对象只存非静态的成员变量，而无论中间放置了几个静态变量都不会影响他们之间的排布。 大部分的编译器将先定义的非静态成员变量放在低地址，而后的放在高地址。最好用时先用kdbg或测试程序等看下 静态成员的存取不通过对象，他们放在数据段中 vptr一般会放在哪里？ 对象的头或者尾巴 align:C++标准要求，在同一个access section(private,public,protect等区段），member的排列只需要符和较晚出现放在较高的地址“即可， access sections的多少并不会带来额外的负担 我在g++上做了测试: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TT&#123; public: int a; char b; &#125;; sizeof&#123;TT); 8class TT&#123; public: int a; char b; protect: int c; char d; &#125;; sizeof(TT)=16class TT&#123; public: int a; char b; protect: int c; char d; public: int e; char f; &#125;; sizeof(TT)=24 class TT&#123; public: int a; char b; int e; char f; protect: int c; char d; &#125;; sizeof(TT)=24class TT&#123; public: int a; int e; char f; char b; protect: int c; char d; &#125;; sizeof(TT)=20 由此看来这个编译器是按着c的struct对齐来的啊， data member的存取： 成本比较： 1234567891011 TT tt1; TT *tt2=&amp;tt1;0x400b87 lea -0x20(%rbp),%rax0x400b8b mov %rax,-0x48(%rbp) int d=tt1.d;0x400b8f mov -0x1c(%rbp),%eax0x400b92 mov %eax,-0x68(%rbp) int f=tt2-&gt;d;0x400b95 mov -0x48(%rbp),%rax0x400b99 mov 0x4(%rax),%eax0x400b9c mov %eax,-0x64(%rbp) 对static成员啊而言，实际是在数据段中，所以不管什么形式的访问都是相同的待测试 通过成员函数需要通过this 指针，则同上例子中的指针访问 总结几种情况下的的布局单一继承不含多态一个典型的例子如下12345678910111213141516171819202122232425262728class Point2d&#123; public: Point2d( float x=0.0,float y=0.0):_x(x),_y(y)&#123;&#125;; float x() &#123;return _x;&#125; float y() &#123;return _y;&#125; void x(float newX) &#123; _x=newX;&#125; void y(float newY) &#123; _y=newY;&#125; void operator+= (const Point2d&amp; rhs) &#123; _x+=rhs.x(); _y+=rhs.y(); &#125; ...more member; protected: float _x,_y;&#125;;class Point3d: public Point2d&#123; public: Point3d(float x=0.0,float y=0.0,float z=0.0):Point2d(x,y),_z(z)&#123;&#125;; float z()&#123;return _z;&#125; void z(float newZ)&#123;_z=newZ;&#125; void operator+=(const Point3d&amp; rhs) &#123; Point2d::operator+=(rhs); _z+=rhs.z(); &#125; ...more member protected: float _z;&#125;; 单一继承则 基类的成员被子类包含，放在较低的地址；相比之下，多了对齐的空间；123456789class Concrete &#123; public: ... private: int val; char c1; char c2; char c3; &#125;; 则需要占用８bytes; 而当被继承实现时：12345678910111213141516class Concrete1&#123; public: private: int val; char bit1; &#125;;class Concrete2：public Concrete1&#123; public: private: char bit2; &#125;; class Concrete3:public Concrete2&#123; public: private: char bit3; &#125;; 由此带来成本 8+4+4=16 那为什么要这么做的？继承的时候不能挤在一起吗？（在深入c++对象模型中有图容易理解。这里仅说明： 若： Concrete2 *pc2;Concrete1 *pc1_1,*pc1_2; *pc1_2=*pc1_1; -默认复制构造 pc1_1 = pc2; //pc1_1指向pc2; *pc1_2=*pc1_1;//覆盖掉了，如果继承是成员挤在一起，而不是对齐来的 单一继承含多态：12345678910111213141516171819202122232425262728293031 class Point2d&#123; public: Point2d( float x=0.0,float y=0.0):_x(x),_y(y)&#123;&#125;; float x() &#123;return _x;&#125; float y() &#123;return _y;&#125; virtual float z()&#123;return 0.0;&#125; virtual void z(float)&#123;&#125; void x(float newX) &#123; _x=newX;&#125; void y(float newY) &#123; _y=newY;&#125; virtual void operator+= (const Point2d&amp; rhs) &#123; _x+=rhs.x(); _y+=rhs.y(); &#125; ...more member; protected: float _x,_y;&#125;;class Point3d: public Point2d&#123; public: Point3d(float x=0.0,float y=0.0,float z=0.0):Point2d(x,y),_z(z)&#123;&#125;; virtual float z()&#123;return _z;&#125; virtual void z(float newZ)&#123;_z=newZ;&#125; virtual void operator+=(const Point3d&amp; rhs) &#123; Point2d::operator+=(rhs); _z+=rhs.z(); &#125; ...more member protected: float _z;&#125;; 由此可以满足123 void fool(Point2d &amp;p1,Point2d &amp;p2)&#123;p1+=p2;&#125; 可以是Point2d和Point3d 这种弹性，牺牲了时间和空间加入了什么呢？ virtual table vptr add constructor vptr setting add destructor vptr virtual table dele 所以需要视情况而定，如若只是涉及到2d&amp;3d之间，则可以是1234567 virtual void operator+=(const Point２d&amp; rhs) &#123; Point2d::operator+=(rhs); _z+=rhs.z();//此时＋０ &#125;Point2d p2d(...)Point3d p3d(,,,,);p3d+=p2d 另外：对vptr的摆放位置，若放在最后面，则兼容c但是损失了对继承的更好支持，所以现在放在最前面 多重继承多重继承考虑的问题较多？但从设计角度看，你可能会问？对比单一继承，子类成员起始地址和基类相同，那多重继承，和哪个基类一样？其他基类怎么办，在向上转型如何处理，指针呢？ 另外，在单一继承中，vptr放在最开始的地方，如果base class没有virtual func而derived class有呢？则此时单一继承的自然多态被打破，若此时把一个derived class 转换为base class则 需要编译器介入，在多重继承+虚拟继承下就更有必要了 考虑这个例子：123456789101112131415161718 class Point2d&#123; 带virtual 接口 public: protected: float _x _y; &#125;;class Point3d:public Point2d&#123; public: protectd: float _z; &#125;' class Vertex &#123;带virtual接口 protected: Vertex *next; &#125;; class Vertex3d:public Point3d,public Vertex &#123; protexted: float mumble; &#125; 对多重继承派生对象，若将其地址 指定给最左端的base class则情况同单一继承一样，因为二者指向相同的地址。但是对第二个及以上时需要将地址修改，加上或减去 介于中间的base class subobject1234567891011121314151617181920212223 eg: Vertex3d v3d; Vertex *pv; Point２d *p2d POint3d *p3d; pv=&amp;v3d 则内部为：pv=(Vertex*)(((char*)&amp;v3d)+sizeof(Point3d)); 而对p2d=&amp;v3d; p3d=&amp;v3d则只需要简单的拷贝``` 若为Vertex3d *v3d; pv=v3d;则内部还要进行判断空。因为*v3d可能为空， 而引用不用，因为引用不可能参考到无对存取其第二个基类成员，也是做类似的offset操作##### 虚拟继承在多重继承加虚拟继承时，如ios istream ostream前面的内容会好理解一些，这部分的内容不好理解，也有些繁琐，于是，我回到之前学习的方法，即为什么，出现的原因，如果是自己实现又如何，等思考：+ 为什么需要虚拟继承？ 虚拟继承出现，是因为当基类2和3都继承了基类1，而基类4继承了2和3，则基类4会同时拥有两份基类1，而虚拟继承就是为了让基类4只包含一份基类1，形成菱形继承结构```cppclass ios&#123;..&#125;class istream:public virtual ios&#123;..&#125;class ostream:public virtual ios&#123;..&#125;class iostream:public istream, public ostream &#123;..&#125; 那么，虚拟继承是如何做，使得类4能只包含1份基类1，而不影响其他功能呢： 梳理下：上述例子：挑战在于，将istream 和ostream 各自维护的一个ios subobj ，折叠为一个由iostream维护的单一ios subobj ，并且还可以保存base class 和derived class的指针（以及reference)之间的多态操作一般的实现方式如下： class 如果内含一个或者多个virtual base class obj,像istream那样，将被分割为两部分，一个不变的局部和一个共享局部不变的局部中的数据，不管后继如何演化，都总是拥有固定的offset(从obj头算起），这部分数据可以直接存取，共享局部，则是virtual base class subject，这部分数据位置会因为每次派生发生变化，所以他们只能被间接存取 所以就是：istream 中有自己的和ios相关的部分，这部分为共享部分 1234 class Point2d _x _yclass Point3d:public virtual Point2d _zclass Vertex:public virtual Point2dclass Vertex3d:public Point3d public Vertex 那 istream 如何存取这部分共享的数据？和iostream共享？感觉有点像单例模式 cfront是这样实现的：（这语言没见过）： 会在每个derived class obj中安插一些指针，每个指针 指向一个virtual base class 存取继承得来的virtual baseclass member;所以在存取时通过这个指针存取在多层继承时间接存取次数多；每个对象需要为每个virtual base class 背负一个指针） void Point3d::operator+=(const Point3d &amp;rhs) { _x+=rhs._x; _y+=rhs._y; _z+=rhs._z; } 则在这里：被转为：伪代码：_vbcPoint2d-&gt;_x+=rhs.__vbcPoint2d-&gt;_x;//vbc==virtual base class .... 而Point2d *2d=3d; Point2d *2d=3d? 3d-&gt;__vbcPoint2d:0; microsoft ：引入类似于vbtable的方法，引入virtual base class table 。而在对象中放一个指针指向该表，表则放置那些指向virtual base class 指针Bjarne: g++等（现在可能变了，但是类似）： 在虚函数表中放置virtual base class 的offset而不是地址。 在这里，上面的例子：（this+__vbtr__point3d[-1])-&gt;_x+= (&amp;rhs+rhs.__vptr__point3d[-1])-&gt;_x; ... Point2d *2d=3d?3d+3d-&gt;__vptr__point3d[-1]:0 注意：若是基类1含有virtual func则会拥有一个vptr指向自己的vtable. 而虚拟继承它的基类2,3，基类2,3本身含有virtual func则不会通过继承基类1的方式继承它的vptr,所以可以看到在书中的图中point3d有两个指针vptr,以下例子通过kdbg调试可以看到这个两个vptr 两个问题： 基类1在继承连增加时位置如何变化？ 在基类自己有virtual func时为什么要自己独用一个vptr?123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;class Point2d &#123; public: virtual float printx()&#123;return _x;&#125; protected: float _x,_y;&#125;;class Vertex:public virtual Point2d&#123; protected: Vertex *next;&#125;;class Point3d:public virtual Point2d&#123; protected: float _z;&#125;;class Vertex3d:public Vertex,public Point3d&#123; protected: float mumble;&#125;;class PO&#123; public: // virtual ~PO(); static int origin; float x,y,z;&#125;;int PO::origin =3;int main()&#123; Point2d d2d; Point3d d3d; Vertex vx; Vertex3d v3x; PO po; printf("%d\n",&amp; PO::z); printf("%d\n",&amp;po); printf("%d\n",&amp;po.x); printf("%d\n",&amp;po.y);// printf("%d\n",&amp;po.origin); float PO::*p1=0; float PO::*p2=&amp;PO::x; if(p1==p2) cout&lt;&lt;"sma"&lt;&lt;endl; return 0;&#125; 使用gdb调试：写完程序后：编译时加-ggdb 科执行程序名 设置断点：break 行号s向下执行set p obj &lt;on/off&gt;: 在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。 使用show print object查看对象选项的设置。set p pertty &lt;on/off&gt;: 按照层次打印结构体。可以从设置前后看到这个区别。on的确更容易阅读。1234567891011121314151617181920212223set p obj onset p pertty onp 对象名p /a ((void ***)d3d)[0]@18 //看到更详细的内存 @18为打印的成员数，[0]指从第0个开始打印--感觉不太对p /a ((void **)vx)[0]@16//同上(gdb) p b$1 = &#123;_vptr.Base = 0x400a60 &lt;vtable for Base+16&gt;&#125;(gdb) x/16x 0x400a600x400a60 &lt;_ZTV4Base+16&gt;: 0x0040094c 0x00000000 0x72654437 0x64657669(gdb) x/16x 0x0040094c0x40094c &lt;Base::f()&gt;: 0xe5894855 0x10ec8348 0xf87d8948 0x400a15be0x40095c &lt;Base::f()+16&gt;: 0x10c0bf00 0xf9e80060 0xc9fffffd 0x485590c30x40096c &lt;Derived::f()+2&gt;: 0x8348e589 0x894810ec 0x1bbef87d 0xbf00400a0x40097c &lt;Derived::f()+18&gt;: 0x006010c0 0xfffddbe8 0x66c3c9ff 0x00841f0f (gdb) set $i = 0 (gdb) while $i &lt; 10 &gt;print $i &gt;p /a (*(void ***)obj)[$i] &gt;set $i = $i + 1 &gt;endWhere "obj" is the object whose vtable you'd like to print, and 10 is the number of methods.p /a (*(void ***)obj)[0]@10info address _ZTV3Bar 对象成员的效率指向对象成员变量的指针可以用于测试底层布局，如vptr放在哪，access section 次序。等例子：1234567 class Point3d &#123; public : virtual ~Point3d(); protected: static Point3d origin； float x,y,z;&#125; 1)&amp;Point3d::z –得到z在class obj中的偏移量需用printf 书中说的为了使得指向对象和对象成员的指针区分，而+1,在g++中没有怎么体现：123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;class Point3d&#123; public: // virtual ~Point3d()&#123;;&#125; static Point3d origin; float x,y,z;&#125;;Point3d Point3d::origin;int main ()&#123; Point3d p3d; printf("&amp;Point3d=%p\n",&amp;p3d); printf("&amp;Point3d=%p\n",&amp;p3d.x);//这两个地址相同 printf("&amp;Point3d=%p\n",&amp;p3d.y); printf("&amp;Point3d::x=%p\n",&amp;Point3d::x);//nil,若Point3d带virtual func,则为8 printf("&amp;Point3d::y=%p\n",&amp;Point3d::y); printf("&amp;Point3d::z=%p\n",&amp;Point3d::z); if((float*)&amp;p3d==(float*)&amp;p3d.x)cout&lt;&lt;"yes"&lt;&lt;endl; //输出yes float Point3d::*p1=0; float Point3d::*p2=&amp;Point3d::x; float Point3d::*p3=NULL; if(p1==p2)//未输出 &#123; cout&lt;&lt;"p1==p2"&lt;&lt;endl;//no output in g++ &#125; if(p2==p3) &#123; cout&lt;&lt;"p2==p3"&lt;&lt;endl;//no output in g++ &#125; return 0;&#125; 在这里若是加了virtual func则，x为8，说明是vptr是放在前面的通过指针取得对象成员:1234567float *p=origin.z struct Base1&#123;int val1;&#125;struct Base2 (int val2;&#125;struct Derved:Base1,Base2&#123;..&#125;void func1(int Derved::*bmp,Derved *pd)//传入offset等，多继承时易出错&#123; pd-&gt;*dmp;.....]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_polymorphism]]></title>
    <url>%2F2018%2F06%2F09%2Fcpp-polymorphism%2F</url>
    <content type="text"><![CDATA[多态：为什么需要多态？引入几个点： 继承的机制中，基类的指针和引用能指向派生类，（派生类对象中的基类成员是在内存前面的，即指向派生类对象的指针指向的是第一个基类的第一个成员） 指针的值本质上是内存地址，也就是说指向不同变量(int char.)，对象的指针本身的值都是地址的value) 指针的类型限定了指针的操作内存范围和取值的方式，如通过int指针取值的时候，取到４byte,通过char指针取值时取得1byte;） 因此，基类指针限定了，即使它指向派生类，它也只能操作基类自身的成员和方法；就像char形指针指向int形，取得的只是一部分） 123456789 #include&lt;iostream&gt; 3 using namespace std; 4 int main() 5 &#123; 6 int in=2; 7 char *pc=(char*)&amp;in; 8 cout&lt;&lt;*pc&lt;&lt;endl;//乱码 9 return 0;10 &#125; 所以基类指针可以指向子类，但是只能调用基类的函数，即使子类复写了父类的函数123456789101112131415161718class Base&#123;public: const char* getName() &#123; return "Base"; &#125;&#125;; class Derived: public Base&#123;public: const char* getName() &#123; return "Derived"; &#125;&#125;; int main()&#123; Derived derived; Base &amp;rBase = derived; std::cout &lt;&lt; "rBase is a " &lt;&lt; rBase.getName() &lt;&lt; '\n';&#125; This example prints the result: rBase is a Base /＝》简化：如何让下面的例子得到想要的结果？123Animal *animals[] = &#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;; for (int iii=0; iii &lt; 6; iii++) std::cout &lt;&lt; animals[iii]-&gt;getName() &lt;&lt; " says " &lt;&lt; animals[iii]-&gt;speak() &lt;&lt; '\n'; 如何让父类指针指向子类对象，可以调用子类函数呢？－－－多态 调用的子类函数要满足:A derived function is considered a match if it has the same signature (name, parameter types, and whether it is const) and return type as the base version of the function. Such functions are called overrides. 如何使用－－－例子1234567891011121314151617181920class Base&#123;public: virtual const char* getName() &#123; return "Base"; &#125; // note addition of virtual keyword&#125;; class Derived: public Base&#123;public: virtual const char* getName() &#123; return "Derived"; &#125;&#125;; int main()&#123; Derived derived; Base &amp;rBase = derived; std::cout &lt;&lt; "rBase is a " &lt;&lt; rBase.getName() &lt;&lt; '\n'; return 0;&#125; This example prints the result: rBase is a Derived－－－－－－－－－－－－－－－－－－－－－－－再盗一个例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;string&gt;class Animal&#123;protected: std::string m_name; // We're making this constructor protected because // we don't want people creating Animal objects directly, // but we still want derived classes to be able to use it. Animal(std::string name) : m_name(name) &#123; &#125; public: std::string getName() &#123; return m_name; &#125; virtual const char* speak() &#123; return "???"; &#125;&#125;; class Cat: public Animal&#123;public: Cat(std::string name) : Animal(name) &#123; &#125; virtual const char* speak() &#123; return "Meow"; &#125;&#125;; class Dog: public Animal&#123;public: Dog(std::string name) : Animal(name) &#123; &#125; virtual const char* speak() &#123; return "Woof"; &#125;&#125;; void report(Animal &amp;animal)&#123; std::cout &lt;&lt; animal.getName() &lt;&lt; " says " &lt;&lt; animal.speak() &lt;&lt; '\n';&#125; int main()&#123; Cat cat("Fred"); Dog dog("Garbo"); report(cat); report(dog);&#125; 注意多态的方式：调用基类指针指向子类，函数时，会调用到继承琏最底端，且该最低端的子类有该virtual函数的，否则只调用到最下且复写了该函数的。如下例子：1234567891011121314151617181920212223242526272829303132333435 1 #include&lt;iostream&gt; 2 using namespace std; 3 class A 4 &#123; 5 public: 6 virtual const char* getName() &#123; return "A"; &#125; 7 &#125;; 8 9 class B: public A10 &#123;11 public:12 virtual const char* getName() &#123; return "B"; &#125;13 &#125;;14 15 class C: public B16 &#123;17 public:18 virtual const char* getName() &#123; return "C"; &#125; //or const char * getName()&#123;..&#125; and default virtual19 &#125;;20 21 class D: public C22 &#123;23 public:24 // virtual const char* getName() &#123; return "D"; &#125;25 &#125;;26 27 int main()28 &#123;29 D d;30 A &amp;rBase = d;31 std::cout &lt;&lt; "rBase is a " &lt;&lt; rBase.getName() &lt;&lt; '\n';32 33 return 0;34 &#125; 输出c 注意点： virtual关键字是否都需要写？：Only the most base class function needs to be tagged as virtual for all of the derivedfunctions to work virtually. However, having the keyword virtual on the derived functionsdoes not hurt, and it serves as a useful reminder that the function is a virtual functionrather than a normal one. 不能在构造函数和西沟函数中调用它，因为此时子类对象还没有被构造 c++11引入override和final来防止避免不匹配的复写和阻止继承：１）override:出现错误的例子: 123456789101112131415161718192021 class A&#123;public: virtual const char* getName1(int x) &#123; return "A"; &#125; virtual const char* getName2(int x) &#123; return "A"; &#125;&#125;;class B : public A&#123;public: virtual const char* getName1(short int x) &#123; return "B"; &#125; // note: parameter is a short int virtual const char* getName2(int x) const &#123; return "B"; &#125; // note: function is const&#125;; int main()&#123; B b; A &amp;rBase = b; std::cout &lt;&lt; rBase.getName1(1) &lt;&lt; '\n'; std::cout &lt;&lt; rBase.getName2(2) &lt;&lt; '\n'; return 0;&#125; 由于参数返回值不匹配，所以编译器认为不是复写，结果： AA1234567891011121314151617181920加入override:class A&#123;public: virtual const char* getName1(int x) &#123; return "A"; &#125; virtual const char* getName2(int x) &#123; return "A"; &#125; virtual const char* getName3(int x) &#123; return "A"; &#125;&#125;;class B : public A&#123;public: virtual const char* getName1(short int x) override &#123; return "B"; &#125; // compile error, function is not an override virtual const char* getName2(int x) const override &#123; return "B"; &#125; // compile error, function is not an override virtual const char* getName3(int x) override &#123; return "B"; &#125; // okay, function is an override of A::getName3(int) &#125;;int main()&#123; return 0;&#125; Rule: Apply the override specifier to every intended override function you write. final:12345678910111213141516171819202122232425262728293031323334 加了final的函数无法被复写： class A&#123;public: virtual const char* getName() &#123; return "A"; &#125;&#125;;class B : public A&#123;public: // note use of final specifier on following line -- that makes this function no longer overridable virtual const char* getName() override final &#123; return "B"; &#125; // okay, overrides A::getName()&#125;; class C : public B&#123;public: virtual const char* getName() override &#123; return "C"; &#125; // compile error: overrides B::getName(), which is final&#125;; 加了final的类不能被继承： class A&#123;public: virtual const char* getName() &#123; return "A"; &#125;&#125;;class B final : public A // note use of final specifier here&#123;public: virtual const char* getName() override &#123; return "B"; &#125;&#125;;class C : public B // compile error: cannot inherit from final class&#123;public: virtual const char* getName() override &#123; return "C"; &#125;&#125;; ` 对匹配返回值的一个“例外”：covariant return types:123456789101112 class Base&#123;public: // This version of getThis() returns a pointer to a Base class virtual Base* getThis() &#123; return this; &#125;&#125;;class Derived: public Base&#123; // Normally override functions have to return objects of the same type as the base function // However, because Derived is derived from Base, it's okay to return Derived* instead of Base* virtual Derived* getThis() &#123; return this; &#125;&#125;; 注意当base=&derive; base.getThis()—-取得的任然是base 当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：12345678#include &lt;iostream&gt;int main()&#123; Derived derived; Base &amp;base = derived; // Calls Base::GetName() instead of the virtualized Derived::GetName() std::cout &lt;&lt; base.Base::getName() &lt;&lt; std::endl;&#125; 虚析构函数 ：为什么需要虚析构函数： 当基类指针指向派生类时，当析构后，只会调用基类的析构函数：12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;class Base&#123;public: ~Base() // note: not virtual &#123; std::cout &lt;&lt; "Calling ~Base()" &lt;&lt; std::endl; &#125;&#125;;class Derived: public Base&#123;private: int* m_array;public: Derived(int length) &#123; m_array = new int[length]; &#125; ~Derived() // note: not virtual &#123; std::cout &lt;&lt; "Calling ~Derived()" &lt;&lt; std::endl; delete[] m_array; &#125;&#125;;int main()&#123; Derived *derived = new Derived(5); Base *base = derived ; delete base; return 0;&#125; 只输出Calling ~Base() 所以为了调用派生类的析构函数，需要定义为虚析构函数：123456789101112131415161718192021222324252627282930313233343536 #include &lt;iostream&gt;class Base&#123;public: virtual ~Base() // note: virtual &#123; std::cout &lt;&lt; "Calling ~Base()" &lt;&lt; std::endl; &#125;&#125;;class Derived: public Base&#123;private: int* m_array;public: Derived(int length) &#123; m_array = new int[length]; &#125; virtual ~Derived() // note: virtual &#123; std::cout &lt;&lt; "Calling ~Derived()" &lt;&lt; std::endl; delete[] m_array; &#125;&#125;;int main()&#123; Derived *derived = new Derived(5); Base *base = derived; delete base; return 0;&#125;Now this program produces the following result:Calling ~Derived()Calling ~Base()Rule: Whenever you are dealing with inheritance, you should make any explicit destructors virtual. 虚表：Early binding（静态绑定） and late binding（动态绑定） 前者指的是直接在代码里调用函数，通过函数名，即编译期间就可以直到函数的地址的（偏移，非真实的内存地址）“” Early binding (also called static binding) means the compiler (or linker) is able to directly associate the identifier name (such as a function or variable name) with a machine address. Remember that all functions have a unique address. So when the compiler (or linker) encounters a function call, it replaces the function call with a machine language instruction that tells the CPU to jump to the address of the function.”” 1234567891011121314151617181920212223242526272829303132333435363738 #include &lt;iostream&gt;int add(int x, int y)&#123; return x + y;&#125;int subtract(int x, int y)&#123; return x - y;&#125;int multiply(int x, int y)&#123; return x * y;&#125;int main()&#123; int x; std::cout &lt;&lt; "Enter a number: "; std::cin &gt;&gt; x; int y; std::cout &lt;&lt; "Enter another number: "; std::cin &gt;&gt; y; int op; do &#123; std::cout &lt;&lt; "Enter an operation (0=add, 1=subtract, 2=multiply): "; std::cin &gt;&gt; op; &#125; while (op &lt; 0 || op &gt; 2); int result = 0; switch (op) &#123; // call the target function directly using early binding case 0: result = add(x, y); break; case 1: result = subtract(x, y); break; case 2: result = multiply(x, y); break; &#125; std::cout &lt;&lt; "The answer is: " &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 后者指的是通过函数指针等方式，即在编译期间无法确定调用什么函数，需要通过指针来访问函数（函数指针），效率比前者低 in some programs, it is not possible to know which function will be called until runtime (when the program is run). This is known as late binding (or dynamic binding). In C++, one way to get late binding is to use function pointers. 123456789101112 #include &lt;iostream&gt;int add(int x, int y)&#123; return x + y;&#125;int main()&#123; // Create a function pointer and make it point to the Add function int (*pFcn)(int, int) = add; std::cout &lt;&lt; pFcn(5, 3) &lt;&lt; std::endl; // add 5 + 3 return 0;&#125; 虚表 为什么虚函数能成立－－基类指针指向派生类能调用派生类的函数： 实际上，在定义了虚函数的基类中维护了一个虚指针：它指向一张表，表中包含各个虚函数指针；在这个继承琏中的每一个类有自己的一张虚表，这张表由编译器在编译期间生成, 虚指针在包含虚函数的类的对象被创建时自动创建1234567891011121314151617181920212223242526272829303132333435363738394041424344class Base&#123;public: virtual void function1() &#123;&#125;; virtual void function2() &#123;&#125;;&#125;;class D1: public Base&#123;public: virtual void function1() &#123;&#125;;&#125;;class D2: public Base&#123;public: virtual void function2() &#123;&#125;;&#125;; 实际上为： class Base&#123;public: FunctionPointer *__vptr;//虚指针 virtual void function1() &#123;&#125;; virtual void function2() &#123;&#125;;&#125;;class D1: public Base&#123;public: virtual void function1() &#123;&#125;;&#125;;class D2: public Base&#123;public: virtual void function2() &#123;&#125;;&#125;; base *__vptr;--------------------------&gt;base vtable virtual function1()&lt;----------------function1()|-&gt;virtual function2()&lt;----------------function2()-----------------------------------------------------| D1:public base | *__vptr,(inherited) ----------------D1 vtable | virtual function1(); &lt;--------------function1() | function2()---- D2类似D1 纯虚函数和纯虚类：什么是纯虚函数和纯虚类： 没有定义函数体的虚成员函数成为纯虚函数：virtual int getValue() = 0; // a pure virtual function包含一个或多个纯虚函数的类成为纯虚类虚基类是不能被对象化的，当对象化后调用纯虚函数，就会出现错误 12345int main()&#123; Base base; // We can't instantiate an abstract base class, but for the sake of example, pretend this was allowed base.getValue(); // what would this do?&#125; 为什么需要纯虚函数和纯虚类？当子类继承了基类后，对虚函数来讲，需要复写基类的虚函数，而当忘记去写时，默认就会调用基类的虚函数；而如果将基类的虚函数定义为纯虚函数。就会通过编译报错来提醒我们要复写子类的虚函数： 例子： 12345678910111213141516171819202122232425262728 #include &lt;string&gt;class Animal // This Animal is an abstract base class&#123;protected: std::string m_name;public: Animal(std::string name) : m_name(name) &#123; &#125; std::string getName() &#123; return m_name; &#125; virtual const char* speak() = 0; // note that speak is now a pure virtual function&#125;;#include &lt;iostream&gt;class Cow: public Animal&#123;public: Cow(std::string name) : Animal(name) &#123; &#125; // We forgot to redefine speak&#125;;int main()&#123; Cow cow("Betsy"); std::cout &lt;&lt; cow.getName() &lt;&lt; " says " &lt;&lt; cow.speak() &lt;&lt; '\n';&#125; 123456789101112131415#include &lt;iostream&gt;class Cow: public Animal&#123;public: Cow(std::string name) : Animal(name) &#123; &#125; virtual const char* speak() &#123; return "Moo"; &#125;&#125;;int main()&#123; Cow cow("Betsy"); std::cout &lt;&lt; cow.getName() &lt;&lt; " says " &lt;&lt; cow.speak() &lt;&lt; '\n';&#125; 当想要使用虚基类的实现时，又同时想让虚基类不能对象化且子类能提示需要实现纯虚函数时，应该怎么做？12345678910111213141516171819202122232425262728293031323334353637#include &lt;string&gt;#include &lt;iostream&gt; class Animal // This Animal is an abstract base class&#123;protected: std::string m_name;public: Animal(std::string name) : m_name(name) &#123; &#125; std::string getName() &#123; return m_name; &#125; virtual const char* speak() = 0; // note that speak is a pure virtual function&#125;; const char* Animal::speak()&#123; return "buzz"; // some default implementation&#125;class Dragonfly: public Animal&#123;public: Dragonfly(std::string name) : Animal(name) &#123; &#125; virtual const char* speak() // this class is no longer abstract because we defined this function &#123; return Animal::speak(); // use Animal's default implementation &#125;&#125;;int main()&#123; Dragonfly dfly("Sally"); std::cout &lt;&lt; dfly.getName() &lt;&lt; " says " &lt;&lt; dfly.speak() &lt;&lt; '\n';&#125;The above code prints:Sally says buzz 接口类：接口类的类中没有成员变量。全部由纯虚函数构成；常命名为I开头的:如IErrorLog,类似于java中的接口12345678class IErrorLog&#123;public: virtual bool openLog(const char *filename) = 0; virtual bool closeLog() = 0; virtual bool writeError(const char *errorMessage) = 0; virtual ~IErrorLog() &#123;&#125;; // make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called&#125;; virtual base class当普通的继承，即一个子类继承自两个不同的父类，这两个父类继承自同一个基类时。就容易出现问题：如：123456789101112131415161718192021222324252627282930313233343536373839404142class PoweredDevice&#123;public: PoweredDevice(int power) &#123; cout &lt;&lt; "PoweredDevice: " &lt;&lt; power &lt;&lt; '\n'; &#125;&#125;;class Scanner: public PoweredDevice&#123;public: Scanner(int scanner, int power) : PoweredDevice(power) &#123; cout &lt;&lt; "Scanner: " &lt;&lt; scanner &lt;&lt; '\n'; &#125;&#125;;class Printer: public PoweredDevice&#123;public: Printer(int printer, int power) : PoweredDevice(power) &#123; cout &lt;&lt; "Printer: " &lt;&lt; printer &lt;&lt; '\n'; &#125;&#125;;class Copier: public Scanner, public Printer&#123;public: Copier(int scanner, int printer, int power) : Scanner(scanner, power), Printer(printer, power) &#123; &#125;&#125;;int main()&#123; Copier copier(1, 2, 3);&#125;PoweredDevice: 3Scanner: 1PoweredDevice: 3Printer: 2 从输出看，基类被构造了两次如何防止构造两个基类呢？使用virtual base class123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class PoweredDevice&#123;&#125;;class Scanner: virtual public PoweredDevice&#123;&#125;;class Printer: virtual public PoweredDevice&#123;&#125;;class Copier: public Scanner, public Printer&#123;&#125;;#include &lt;iostream&gt;class PoweredDevice&#123;public: PoweredDevice(int power) &#123; std::cout &lt;&lt; "PoweredDevice: " &lt;&lt; power &lt;&lt; '\n'; &#125;&#125;;class Scanner: virtual public PoweredDevice // note: PoweredDevice is now a virtual base class&#123;public: Scanner(int scanner, int power) : PoweredDevice(power) // this line is required to create Scanner objects, but ignored in this case &#123; std::cout &lt;&lt; "Scanner: " &lt;&lt; scanner &lt;&lt; '\n'; &#125;&#125;;class Printer: virtual public PoweredDevice // note: PoweredDevice is now a virtual base class&#123;public: Printer(int printer, int power) : PoweredDevice(power) // this line is required to create Printer objects, but ignored in this case &#123; std::cout &lt;&lt; "Printer: " &lt;&lt; printer &lt;&lt; '\n'; &#125;&#125;;class Copier: public Scanner, public Printer&#123;public: Copier(int scanner, int printer, int power) : Scanner(scanner, power), Printer(printer, power), PoweredDevice(power) // PoweredDevice is constructed here &#123; &#125;&#125;;This time, our previous example:int main()&#123; Copier copier(1, 2, 3);&#125;produces the result:PoweredDevice: 3Scanner: 1Printer: 2 这样的话，基类的构造交给了继承琏最底层的类 注意： virtual base class在子类对象之前就创建了 if Copier was singly inherited from Printer, and Printer was virtually inherited from PoweredDevice, Copier is still responsible for creating PoweredDevice Fourth, a virtual base class is always considered a direct base of its most derived class(which is why the most derived class is responsible for its construction). But classes inheriting the virtual base still need access to it. So in order to facilitate this, the compiler creates a virtual table for each class directly inheriting the virtual class (Printer and Scanner). These virtual tables point to the functions in the most derived class. Because the derived classes have a virtual table, that also means they are now larger by a pointer (to the virtual table). 对象分割：当子类对象赋值给基类会发生什么？子类对象的基类部分会给基类对象12345678910111213141516171819int main()&#123; Derived derived(5); Base base = derived; // what happens here? std::cout &lt;&lt; "base is a " &lt;&lt; base.getName() &lt;&lt; " and has value " &lt;&lt; base.getValue() &lt;&lt; '\n'; return 0;&#125;传值给基类void printName(const Base base) // note: base passed by value, not reference&#123; std::cout &lt;&lt; "I am a " &lt;&lt; base.getName() &lt;&lt; '\n';&#125;This is a pretty simple function with a const base object parameter that is passed by value. If we call this function like such: int main()&#123; Derived d(5); printName(d); // oops, didn't realize this was pass by value on the calling end return 0;&#125; vector和vector&lt;&amp;base&gt;和vector&lt;base*&gt;第一种可以但是只能调用基类的部分第二种不行：std::vector&lt;Base&amp;&gt; v;Unfortunately, this won’t compile. The elements of std::vector must be assignable, whereas references can’t be reassigned (only initialized).第三种可以但是要做delete12345678910111213141516171819202122232425262728#include &lt;vector&gt;int main()&#123; std::vector&lt;Base*&gt; v; v.push_back(new Base(5)); // add a Base object to our vector v.push_back(new Derived(6)); // add a Derived object to our vector // Print out all of the elements in our vector for (int count = 0; count &lt; v.size(); ++count) std::cout &lt;&lt; "I am a " &lt;&lt; v[count]-&gt;getName() &lt;&lt; " with value " &lt;&lt; v[count]-&gt;getValue() &lt;&lt; "\n"; for (int count = 0; count &lt; v.size(); ++count) delete v[count]; return 0;&#125;用智能指针可以避免：#include &lt;vector&gt;#include &lt;functional&gt; // for std::reference_wrapperint main()&#123; std::vector&lt;std::reference_wrapper&lt;Base&gt; &gt; v; // our vector is a vector of std::reference_wrapper wrapped Base (not Base&amp;) Base b(5); // b and d can't be anonymous objects Derived d(6); v.push_back(b); // add a Base object to our vector v.push_back(d); // add a Derived object to our vector // Print out all of the elements in our vector for (int count = 0; count &lt; v.size(); ++count) std::cout &lt;&lt; "I am a " &lt;&lt; v[count].get().getName() &lt;&lt; " with value " &lt;&lt; v[count].get().getValue() &lt;&lt; "\n"; // we use .get() to get our element from the wrapper return 0;&#125; 一种极端情况：12345678int main()&#123; Derived d1(5); Derived d2(6); Base &amp;b = d2;//b为d2的引用 b = d1; // this line is problematic 导致b的基类部分为d1,子类部分为d2,因为b是d2的引用，导致现在d2的基类部分是d1而子类部分是d2 return 0;&#125; 总结多态的方式＋dynamic_cast: shape ps=new circle(); 经由virtual func: ps-&gt;rotate() //virtual func 经由dynamic_cast:和type运算符： if(circle pc=dynamic_cast&lt;circle*&gt;(ps)) (理解了指针类型的本质就可以理解它和理解分割的内容了:指针的类型会教导编译器如何解释某个特定地址的内容和大小: 所以一个void*的指针无法去确定涵盖多大的地址空间，所以它只能含有一个地址但是不能操作它指向的Ｏｂｊｅｃｔ 所以转型只是一种编译器指令，不改变真正的地址，而是改变解读指针的方式让它指出其内存的大小和内容） 更多见内存布局第一章图就能理解）]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_inheritance]]></title>
    <url>%2F2018%2F06%2F09%2Fcpp-inheritance%2F</url>
    <content type="text"><![CDATA[c++ 继承：继承是什么能做什么继承是创建复杂类的另一种方式，它展现出来俩个obj 的is-a的概念（前一种方式是加入复杂的函数和成员等has-a 概念）继承体现的是两个对象（类）之间的联系，子类继承父类的成员和方法，然后特殊化于扩展自己的成员和方法，正如苹果和梨都是水果，它们拥有水果的一般特性，等边三角形是特殊的等腰三角形几个概念引英文词： the class being inherited from is called the parent class, base class, or superclass, and the class doing the inheriting is called the child class, derived class, or subclass. 继承怎么使用，分为什么继承的使用通过例子来学习，分为单继承和多继承等多继承的问题：１）两个基类中存在相同的方法，子类调用该方法－－－》解决，可以调用的方法前加上类限定符base::2)俩个类继承自同一个类，接着另一个类继承这两个类懒得自己写，从learncpp拷贝12#include &lt;iostream&gt;#include &lt;string&gt; 12345678910111213141516171819202122232425262728293031323334353637383940class Person&#123;public: std::string m_name; int m_age; Person(std::string name = "", int age = 0) : m_name(name), m_age(age) &#123; &#125; std::string getName() const &#123; return m_name; &#125; int getAge() const &#123; return m_age; &#125; &#125;; // BaseballPlayer publicly inheriting Personclass BaseballPlayer : public Person&#123;public: double m_battingAverage; int m_homeRuns; BaseballPlayer(double battingAverage = 0.0, int homeRuns = 0) : m_battingAverage(battingAverage), m_homeRuns(homeRuns) &#123; &#125;&#125;; int main()&#123; // Create a new BaseballPlayer object BaseballPlayer joe; // Assign it a name (we can do this directly because m_name is public) joe.m_name = "Joe"; // Print out the name std::cout &lt;&lt; joe.getName() &lt;&lt; '\n'; // use the getName() function we've acquired from the Person base class return 0;&#125; 继承的方式，访问控制A child class inherits both behaviors (member functions) and properties (member variables) from the parent 但是受继承方式的限制继承的方式有public等，受限制，这种可以通俗的理解为，你和你妈，你姨妈，你表舅等的亲密度和能访问的内容是有等级差别的 Access specifier in base class when inherited publicly when inherited privately when inherited protectedly Public Public Private Protected Private Inaccessible Inaccessible Inaccessible Protected Protected Private Protected 继承的内存 对单纯的类对象来说，没有继承时，其对象内存是成员变量，存储在栈中，当继承了基类后，基类的成员变量（即使是private不能访问的）会添加到子类的对象内存中，而且一般是放在低地址（前面）对访问控制是在编译期间去做限制的 编译器对继承做了什么？ 构造函数 首先，构造函数顺序：Because Derived inherits functions and variables from Base,you may assume that the members of Base are copied into Derived.However, this is not true. Instead, we can consider Derived as a two part class:one part Derived, and one part Base.，从构造函数可以看出，继承的类，对象先调用继承连最上层的类构造函数，最后调用它自己的构造函数 其次，基类构造函数被子类调用：//弥补了子类不能 初始化父类成员的缺陷－－－为什么子类不能在初始化队列中初始化父类成员？若为const就出错了，初始化两次 1234567891011class Derived: public Base&#123;private: // our member is now private double m_cost; public: Derived(double cost=0.0, int id=0) : Base(id), // Call Base(int) constructor with value id! m_cost(cost) &#123; &#125; 析构函数：调用顺序和构造函数相反 子类加入自己的函数和ovrridewirte父类函数 策略：When a member function is called with a derived class object,the compiler first looks to see if that member exists in the derived class.If not, it begins walking up the inheritance chain and checking whether the memberhas been defined in any of the parent classes. It uses the first one it finds. 在父类中被声明为private 的函数经过子类重写后可能会变成public: 12345678910111213141516171819202122 class Base&#123;private: void print() &#123; std::cout &lt;&lt; "Base"; &#125;&#125;;class Derived : public Base&#123;public: void print() &#123; std::cout &lt;&lt; "Derived "; &#125;&#125;;int main()&#123; Derived derived; derived.print(); // calls derived::print(), which is public return 0;&#125; 保留父类函数的方法: 123456789101112131415161718192021222324252627282930class Base&#123;protected: int m_value; public: Base(int value) : m_value(value) &#123; &#125; void identify() &#123; std::cout &lt;&lt; "I am a Base\n"; &#125;&#125;;class Derived: public Base&#123;public: Derived(int value) : Base(value) &#123; &#125; int GetValue() &#123; return m_value; &#125; void identify() &#123; Base::identify(); // call Base::identify() first std::cout &lt;&lt; "I am a Derived\n"; // then identify ourselves &#125;&#125;; c++11新：将base类中的保护函数，在子类中声明为public: 12345678910111213141516171819202122232425262728293031323334class Base&#123;private: int m_value; public: Base(int value) : m_value(value) &#123; &#125; protected: void printValue() &#123; std::cout &lt;&lt; m_value; &#125;&#125;;class Derived: public Base&#123;public: Derived(int value) : Base(value) &#123; &#125; // Base::printValue was inherited as protected, so the public has no access // But we're changing it to public via a using declaration using Base::printValue; // note: no parenthesis here //c++11&#125;;int main()&#123; Derived derived(7); // printValue is public in Derived, so this is okay derived.printValue(); // prints 7 return 0;&#125; 子类中将父类的方法隐藏：1234567891011121314151617181920212223242526272829303132333435class Base&#123;private: int m_value; public: Base(int value) : m_value(value) &#123; &#125; int getValue() &#123; return m_value; &#125;&#125;; class Derived : public Base&#123;public: Derived(int value) : Base(value) &#123; &#125; int getValue() = delete; // mark this function as inaccessible&#125;; int main()&#123; Derived derived(7); // The following won't work because getValue() has been deleted! std::cout &lt;&lt; derived.getValue(); return 0;&#125;]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_conandde]]></title>
    <url>%2F2018%2F06%2F09%2Fcpp-conandde%2F</url>
    <content type="text"><![CDATA[c++ class constructor and destructor构造函数构造函数表现构造函数的作用：构造函数主要是用来初始化对象的－－－一般是成员，函数不用–所以它需要在构建对象时就执行 构造函数如何写：1234567891011121314public: classname(arg...):member(arg),mem2(arg),..&#123;xxx&#125; classname(..)&#123;..&#125;``` ##### 默认构造函数的生成规则（深入对象模型）+ 下面四个情况下会生成默认构造函数（编译器控制）(nontrivial default constructor) + 带有default constructor的member class object 即在类中带有对象成员，该对象成员所属的类有构造函数如： ```cppclass Foo &#123;public :Foo(),Foo(int)...&#125;class Bar&#123;public:Foo foo;char *str&#125;; void funv() &#123; Bar bar;.... &#125; 这种情况下若程序员没有实现构造函数，则编译器会自己生成构造函数，来调用Foo的构造函数但是不初始化str,这个得由程序员来做。如类似于：123456789101112131415161718192021Bar::Bar()&#123; foo.Foo::Foo(); ``` 若程序员自己写了构造函数但是不包括初始化foo则，编译器会在程序眼写的构造函数中加入上述，另外若有多个对象则按照声明顺序进行调用他们的构造函数； + 带有Default constructor 的base class 同理，当继承的基类带有构造函数时就会加入，若程序员的构造函数没有初始化他们时就会扩展 //以上见例子class_constructor.cpp， + 和vcirtual相关need to create vptr 带有一个virtual func的class 1)class 声明或继承一个virtua func 2)class派生自一个继承琏，其中有virtual base classes 这个比较容易理解 + 和virtual相关 need to init vptr 带有一个virtual base class 的class 如： ```cpp class X&#123; public int i;&#125; class A :public virtual X &#123;/// class B :public virtual X &#123; class C: public A,public B 构造函数何时被执行-在对象定义时若有构造函数，则会执行 实践：1:5构造函数的使用：重载，初始化式 构造函数表现的原理构造函数在静态代码块中的位置和符号体现如果有定义构造函数，它本身也是一个函数，放在代码段中，可以通过kdbg查看123456origin(int ax=3,int bx=4):a(ax),b(bx)&#123;&#125;0x400bae push %rbp0x400baf mov %rsp,%rbp0x400bb2 mov %rdi,-0x8(%rbp)0x400bb6 mov %esi,-0xc(%rbp)0x400bb9 mov %edx,-0x10(%rbp) 构造函数在动态执行时，放在哪个内存段中，如何被引用，使用 动态执行时，在代码段中，通过this引用 构造函数总结：任何c++ class只有在以上四中情况下才会产生默认构造函数，且产生的默认构造函数不会去初始化成员的值拷贝构造函数拷贝的动作发生了什么拷贝的本质，为什么需要拷贝构造函数？ 首先对基本的类型而言，拷贝是把值赋给另一个同类型的变量，而数租不能做=赋值拷贝 对对象而言，也是把值赋给同类型的对象，而不是共享一个指针，所以这个过程需要将对象中的成员也复制过去（复制的是当前对象在此时时成员的值 ） c++中的拷贝构造函数针对三种行为：＝ ，f(T t)和 f(){T t;return t}返回对象－－这三种情况都针对左值的 =:注意这个是在定义时做的，如origin or1=or2;此时会调用”拷贝构造函数”（ 同or1(or2)) or2=or3;此时不会调用拷贝构造函数（当程序员自己写了拷贝构造函数时，默认调用该构造函数，而不会区做成员复制，所以若在其中没有做复制，可能得到不想要的值，见例子) 拷贝构造函数的作用和使用什么情况下会生成默认的拷贝构造函数？类似于构造函数，在以下情形会生成默认的拷贝构造函数－ 当需要调用别的拷贝构造函数时，如：当类内含有一个member object而后者的class声明有一个copy constructor时； 当类继承自一个base class而后者有拷贝构造函数 当类声明了一个或多个virtual functions时 当class 派生自一个继承 串琏，而其中有一个或多个virtual base classes 时 拷贝构造函数和编译器－－－汇编，转换：分三种情况讨论： 初始化拷贝构造： 123X x1(x0);X x2=x0;X x3=X(x0); 上述三种都是定义一个类，即定义的本质会在内存中开辟空间上述三个都会执行拷贝构造函数，如何执行？会被转换为：伪代码 X x1; x1.X::X(x0); 会调用X::X(const X&amp; xx) x2,x3也是这样，将拷贝方作为函数参数传入 这样就可以解释为什么拷贝构造函数的定义是 classname (const classname &amp;obj) 参数的初始化即传入一个参数给函数：foo(X x) 如：X xx; //,.. foo(xx); 则会产生一个临时的对象： 伪代码X __temp0; _temp0.X::X(xx);//use copy construtor foo(__temp0) 这里因为它是临时的，所以则定义的时候需要用引用foo(X &amp;x)//这里不是很清楚为什么用引用～！，是否后面的操作直接面向该对象，需要做实际的修改，所以。。所以，为了对付临时的对象，在执行完函数后，需要调用该对象的析构函数 返回值的初始化：如X bar(){ X xx; //... return xx; } 如何做X xxx=bar();如何拷贝的？双阶段初始化： a 增加一个额外的引用参数给函数，如void bar(X＆ _result) b 在return 前插入一个copy constructor void bar(X &amp;__result){ X xx; xx.X::X(); __result.X::XX(xx); return ; } 所以上述会被转化为： Ｘ xx=bar() ---&gt; X xx ;//注意这里不会执行默认构造函数 bar(xx); ex:bar().memfunc()---&gt;X __temp0;(bar(__temp0),__temp0).memfunc(); X (*pf)();pf=bar;---&gt;void (*pf)(X&amp;);pf=bar; 关于上述三种情况的优化：１)在使用者层面上优化；２）在编译器层面的优化（ＮＲＶ）具体见深入模型（书） 关于该不该编写copy constructor:除非需要大量的memberwise 初始化操作，如传值给object以便做NRV优化，否则不需要//上述情况的检验可以通过代码，或者去看编译器的生成代码～ 拷贝构造函数的内存放在代码段， 初始化队列即构造函数的一种形式如：X(int f):a(ax),b(bx)..{….} 问题：什么时候用初始化列表？它和初始化赋值有什么不同？ 有以下四种情况需要使用初始化列表： １）当初始化一个reference member时 ２）当初始化一个const member时 ３）当调用一个base class的constructor,当它拥有一组参数时 ４）当调用一个member class 的consructor，而它有一组参数时； 如cpp class world { String _nhame; int cnt; public :world(){_nhame=0;cnt=0;}}1234567891011//此时，对_nhame这个成员，需要做较多的事，如产生临时对像，调用operator=.... －－－－所以想到用初始化列表：```cpp world::world:nhame(0)&#123; cnt=0; &#125; 这样只会调用nhame的构造函数 会被转换为：world::world&#123; //伪代码 _nhame.String::String(0); cnt=0; &#125; 更具体的，初始化列表如何进行：顺序如何：如前，初始化列表最终会被转换为初始化表达式到构造函数体中，那是什么顺序呢？注意这里的初始化顺序是根据成员在类中的定义（声明）顺序来的，而不是初始化列表中的顺序看这个例子： 1234567class X&#123; int i; int j; public: X(int cal):i(j)&#123;&#125; ... 此时，因为i先初始化,再j,出错，i需要j —-&gt;可以改善为：X::X(int cal):j(cal){i=j;} —-为什么这样可以？ 因为初始化列表的内容会放到初始化体中的表达式前面，这样j就会先定义 －－－－》另一个可能出错的例子： X::X(int cal):i(xfoo(cal)),j(cal){} –&gt;转换为：X::X(/this pointer/ int cal){ i=this-&gt;xfoo(cal); j=cal; } 这个情况在这里是对的，但是当X 继承自某个类，在xfoo是基类的函数，，则会出错this-&gt;xfoo 几个问题： 较为简单的例子见文件中的例子 当程序员定义了拷贝构造函数时，还会执行memberwise initialization吗 －－会执行拷贝构造函数参考：深入c++对象模型和http://en.cppreference.com/w/cpp/language/copy_constructor]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_class_memory]]></title>
    <url>%2F2018%2F06%2F09%2Fcpp-class-memory%2F</url>
    <content type="text"><![CDATA[c++类内存布局：静态下编译后的“内存布局”，此时还未分配内存，不能算是内存，只能说是文件布局 two question:多少内存能表现一个ob:?多少内存能表现一个class?–编译期，如 int 大小为４ 静态下，编译后同C一样分为代码段等；而类的特性有些类似于struct,定义类的文件中包含了成员变量，成员函数。 类：非静态成员变量：存于对象中 vptr指针：存于对象中 vt表:vptr指向这个表，这个表在构造函数中默认隐士初始化，将对应的虚拟函数地址赋给表中的各个值（表本身with&quot;类&quot;） obj: class: _vptr ---&gt; table: ptr1 --&gt;virtual func1 ptr2 --&gt;virtual func2 静态变量: 存入数据段中 成员函数:代码段,通过this和成员变量建立联系 静态函数： 存于代码段中 全局函数 main函数 全局变量和静态变量 局部变量：栈 something extra depend on compiler~ some rules 每个类产生一堆指向virtual func的指针，放在表格中，表称为：vtbl; 每个obj被添加了一个指针，指向相关的tirtual table ,为vptr; vptr的设定和重置由constructor，destructor,copy assignment运算服自动完成） 注意每一个class所关联的type info object(用于支持runtime type identification )也经由virtual table指出，放在vptr[0]处） 虚函数有可能被转换为：(*px-&gt;vtbl[1])(px)具体见深入c++模型书 多少内存能表现一个ob:? non static data members padding virtual—vptr多少内存能表现一个class?见datamember_memory 12345最小是１ size class T&#123; &#125;; ---1 一个char 表示这个类型 class X :public virtual T&#123;&#125;; --指针大小，指针指向T virtual base class subobject class Y :public virtual T&#123;&#125;; --指针大小class A:public X,public Y &#123;&#125;; --两个指针大小 more seee datamember_memory 运行时的内存布局，即作为进程运行时，其内存是如何的； 运行时，涉及类的对象模型，对象的内存部分只包含非静态成员变量和虚拟函数指针表； 可以通过gdb 或kgdb进行查看类对象的地址或者类函数的地址：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 Circle c12; Circle c1(1.2,"red");printf("getRadius:%x\n",&amp;Circle::getRadius);printf("%x, %x\n",&amp;c12,c12); void *cc; cc=(Circle*)(&amp;c12); cout&lt;&lt;*((double*)cc)&lt;&lt;endl;``` 所以c++的对象带来的开销在于操作多态时的vptr等效率低） 一个例子```cpp#include&lt;iostream&gt;using namespace std;class A&#123; public: virtual const char* getName() &#123; return "A"; &#125; virtual int getage()&#123; return 3;&#125;&#125;; class B: public A&#123; public: virtual const char* getName() &#123; return "B"; &#125; virtual int getage()&#123;return 5;&#125;&#125;; class C: public B&#123; public: const char* getName() &#123; return "C"; &#125; int getage()&#123;return 6;&#125;&#125;; class D: public C&#123; public: virtual const char* getName() &#123; return "D"; &#125;0x400ae8 push %rbp0x400ae9 mov %rsp,%rbp0x400aec mov %rdi,-0x8(%rbp) int getage() &#123;return 8;&#125;0x400af8 push %rbp0x400af9 mov %rsp,%rbp0x400afc mov %rdi,-0x8(%rbp)&#125;; int main()&#123; A aa; aa.getName(); D d; d.getName(); A &amp;rBase = d; rBase.getName();0x400986 mov -0x28(%rbp),%rax0x40098a mov (%rax),%rax0x40098d mov (%rax),%rax0x400990 mov -0x28(%rbp),%rdx0x400994 mov %rdx,%rdi0x400997 callq *%rax rBase.getage();0x400999 mov -0x28(%rbp),%rax0x40099d mov (%rax),%rax0x4009a0 add $0x8,%rax0x4009a4 mov (%rax),%rax0x4009a7 mov -0x28(%rbp),%rdx0x4009ab mov %rdx,%rdi0x4009ae callq *%rax std::cout &lt;&lt; "rBase is a " &lt;&lt; rBase.getName() &lt;&lt; '\n'; D d2; A &amp;rBase2 =d2;0x4009f9 lea -0x30(%rbp),%rax0x4009fd mov %rax,-0x20(%rbp) rBase2.getName(); 0x400a01 mov -0x20(%rbp),%rax0x400a05 mov (%rax),%rax0x400a08 mov (%rax),%rax0x400a0b mov -0x20(%rbp),%rdx0x400a0f mov %rdx,%rdi0x400a12 callq *%rax return 0;&#125; something else: 成员函数也是只有一份被存于代码区中，而对象并没有指向成员函数的指针，对象只存成员和虚拟表 ；那在对象.成员函数使用时， 是如何确定该函数中使用的成员是该对象的成员?这里是this指针的作用从汇编看，是否是成员函数在取的成员变量时，会做一些动作，这时的成员变量是在栈区；；或者从调用成员函数时，是否有传入或控制函数的一些动作，让它知道从哪里取得对应的成员返回； 成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_this]]></title>
    <url>%2F2018%2F06%2F09%2Fcpp-this%2F</url>
    <content type="text"><![CDATA[c++关键字之thisthis指针是什么this是一个指向当前正在使用的对象的指针，它是一个指针；成员函数通过它来使用对象的值，通过它知道要对哪个对象的成员操作如：12345678910111213141516171819class Simple&#123;private: int m_id;public: Simple(int id) &#123; setID(id); &#125; void setID(int id) &#123; m_id = id; &#125; int getID() &#123; return m_id; &#125;&#125;;int main()&#123; Simple simple(1); simple.setID(2); std::cout &lt;&lt; simple.getID() &lt;&lt; '\n'; return 0;&#125; 1234simple.setID(2);---&gt;setID(&amp;simple, 2); // note that simple has been changed from an object prefix to a function argument! void setID(int id) &#123; m_id = id; &#125;---&gt; void setID(Simple* const this, int id) &#123; this-&gt;m_id = id; &#125; this指针用法关键词 this 是一个纯右值表达式，其值是在调用成员函数时的对象地址。它能出现于下列语境： 在任何非静态成员函数体内，含成员初始化列表 在非静态成员函数的声明内任何(可选) cv 限定符序列后处，包含动态异常规定(弃用)、 noexcept 规定(C++11)及尾随返回类型(C++11 起) 在默认成员初始化中 (C++11 起) 在一个对象的构造期间，若通过不直接或间接从构造函数的 this 指针获得的泛左值，访问对象的值或任何其子对象，则如此获得的对象或子对象的值是未指定的。换言之，构造函数中 this 指针不能别名使用： 123456extern struct D d;struct D &#123;D(int a) : a(a), b(d.a) &#123;&#125; // a(a)will change to this-&gt;a(a),but b(d.a)--&gt;this-&gt;b(d.a),and will get random value,but b(a) 或 b(this-&gt;a) 是正确的 int a, b;&#125;;D d = D(1); // 因为 b(d.a) 不通过 this 访问， d.b 现在是未指定的,i try in g++.find it d.b==1 this指针于内存哪里？this 指针是不占类的内存的，它是传入成员函数的参数，所以它在栈中 this 指针总是指向正在操作的对象：1234567891011121314151617181920212223242526272829303132333435363738394041424344int main()&#123; Simple A(1); // *this = &amp;A inside the Simple constructor Simple B(2); // *this = &amp;B inside the Simple constructor A.setID(3); // *this = &amp;A inside member function setID B.setID(4); // *this = &amp;B inside member function setID return 0;&#125;``+ this指针的连锁使用： 由this指针理解cout&lt;&lt;xxx&lt;&lt;&lt;xxx&lt;&lt;&lt;xxxxx....对上述的表达式，cout是一个类，&lt;&lt;是该类的操作符函数，则&lt;&lt;函数返回this，若返回空，则无法进行： ```cppstd::cout &lt;&lt; "Hello, " &lt;&lt; userName;(std::cout &lt;&lt; "Hello, ") &lt;&lt; userName;(void) &lt;&lt; userName; 错误(std::cout) &lt;&lt; userName;正确如何写？class Calc&#123;private: int m_value; public: Calc() &#123; m_value = 0; &#125; Calc&amp; add(int value) &#123; m_value += value; return *this; &#125; Calc&amp; sub(int value) &#123; m_value -= value; return *this; &#125; Calc&amp; mult(int value) &#123; m_value *= value; return *this; &#125; int getValue() &#123; return m_value; &#125;&#125;;#include &lt;iostream&gt;int main()&#123; Calc calc; calc.add(5).sub(3).mult(4); std::cout &lt;&lt; calc.getValue() &lt;&lt; '\n'; return 0;&#125; 注意Calc&amp; 和return *this this指针到对象名代表的是什么由above和以下例子：来看对象的地址等1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class set&#123; int m_i;public: set() &#123; m_i = 0; &#125; set add(int i) &#123; m_i += i; return *this; &#125; int getval() &#123; return m_i; &#125;&#125;;int main()&#123; set s; s.add(2).add(2); cout&lt;&lt;s.getval();&#125; //结果是２ 因为函数返回的*this是一个值，它是set对象的值：1234567891011121314151617181920212223242526272829303132333435class set 5 &#123; 6 int m_e; 7 int m_i; 8 public: 9 set() 10 &#123; 11 m_e=0; 12 m_i=0; 13 &#125; 14 set add(int i)&#123; 15 m_i+=i; 16 return *this; 17 &#125; 18 int getval() &#123; 19 return m_i; 20 &#125; 21 &#125;;int main() 33 &#123; 34 set s; 35 set s2;&gt;&gt; 36 printf("%x\n",s.add(2));--输出0,返回的是*this，为s的值，m_e是其第一个成员&gt;&gt; 37 printf("%x\n",s);－－输出0 38 s2=s.add(2);--s2被赋值了s，s此时的m_i=2+2 39 s2.add(2);--s2的m_i=6&gt;&gt; 40 printf("%d\n",s2);//输出的是０－－－ m_e=0 41 cout&lt;&lt;s2.getval()&lt;&lt;endl;-输出6，因为 42 return 0; 43 &#125; 由此可以看出this-&gt;object this-&gt;s *this==s *this==s的内容 取对象的地址 &amp;s ref:http://zh.cppreference.com/w/cpp/language/thishttp://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_static]]></title>
    <url>%2F2018%2F06%2F08%2Fcpp-static%2F</url>
    <content type="text"><![CDATA[c++关键词之staticsomething share:其实，一开始学习c++的时候，并没有想去了解它的语法原理。虽然学c的时候，附带学了汇编，也学到了内存段，和学编译原理的时候顺带了解了它的相关词法语法处理。 现在开始从原因，历史，内存，汇编等角度去看cpp，觉得清晰了一些。虽然没有去学习g++或者其他编译器如何处理c++的语法词法。这个想着以后如果有时间再研究吧。应该也是有工具去看，毕竟，g++是开源的，可以直接看源码如何处理C++ static overiew static在c的时候就有，因存储的地方不同于局部变量(in static mem ,not in stack)，使得在函数代码块结束后不会被销毁。从而能持续整个程序. 静态存储区(data)：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。 目录：１、static概念和用法２、static内存存储和汇编３、static和类相关内容与原理 static概念： static为静态修饰符。编译器遇到这个修饰符时将对应的变量存储在静态存储区(data) 根据类型：static可以修饰变量和函数，修饰对象和成员函数 根据位置：静态局部变量和全局静态变量 -存于静态数据区(data) c中的static: 修饰变量：作用域是本程序文件，局部变量默认为auto,静态变量不管局部或者全局都存储于静态数据区，使得不会因为函数调用而销毁 修饰函数：只能用于本程序文件，普通函数默认为extern ,能被其他文件引用，static则不行 “ 举个例子：在stat.h中声明static int getstats()函数.并在stat.c中实现它，static int getstats(){return xxx;}在main中或者其他文件中使用这个函数编译时报错未能找到该函数（未定义该函数)c++中的static当和类无关时同c” static使用和内存与汇编：static全局变量123456789101112131415161718 static int global1=4; 12 int main() 13 &#123;&gt;&gt; 14 int loc1=global1;_ZL7global1: .long 4 .text .globl main .type main, @function movl _ZL7global1(%rip), %eax movl %eax, -4(%rbp)//且可以通过kdbg看到在执行期，static变量的内存位置约为：(int *) 0x601048 &lt;global1&gt; 数据段地址局部变量的位置约为：(char **) 0x7ffff7a54530 &lt;loc1&gt; 栈地址 静态局部变量1234567891011121314151617int main() 13 &#123; 14 static int locstatic1=5;&gt;&gt; 15 int loc1=global1;&gt;&gt; 16 int loc2=locstatic1; movl _ZZ4mainE10locstatic1(%rip), %eax movl %eax, -4(%rbp)_ZZ4mainE10locstatic1: .long 5执行期： loca1 (int *) 0x7fffffffd8a8 loca2 (int *) 0x7fffffffd8ac global1 (int *) 0x601048 &lt;global1&gt; locstatic:(int *) 0x60104c &lt;main::locstatic1&gt; static定义的变量和函数只能在本程序文件中使用要知道这个的原因可能有些复杂，一时半会也说不清，得先直到函数为什么能被外部引用：存在“符号表”中，能被外部链接，静态函数不在符号表中所以不行，类似这样吧，这块不太清楚，感觉是这个原因 static函数：12345678910111213141516171819 static int getv() 4 &#123; 5 int a=5; 6 a++; 7 cout&lt;&lt;a&lt;&lt;endl; 8 return 4; 9 &#125; .type _ZL4getvv, @function_ZL4getvv:.LFB1021: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $16, %rsp 。。。。 call _ZL4getvv从汇编代码看貌似跟普通函数没什么差别123456789101112131415161718192021运行时 static int getv()&#123;0x400816 push %rbp0x400817 mov %rsp,%rbp0x40081a sub $0x10,%rsp int a=5; a++; cout&lt;&lt;a&lt;&lt;endl; return 4;&#125; static int global1=4;int main()&#123; static int locstatic1=5; int loc1=global1; int loc2=locstatic1;// cout&lt;&lt;getv()&lt;&lt;endl; getv();0x400866 callq 0x400816 &lt;getv()&gt; static和类相关static成员变量的使用 static成员变量是类的所有对象共有的，但是只有一份，通过类也可以访问到12345678910111213141516class Something&#123;public: static int s_value; // declares the static member variable&#125;; int Something::s_value = 1; // defines the static member variable (we'll discuss this section below) int main()&#123; // note: we're not instantiating any objects of type Something Something::s_value = 2; std::cout &lt;&lt; Something::s_value &lt;&lt; '\n'; return 0;&#125; 12345678910111213_ZN9Something7s_valueE: .long 1 .text .globl main .type main, @function Something::s_value=3;0x40081a movl $0x3,0x20083c(%rip) # 0x601060 &lt;Something::s_value&gt;（ movl _ZN9Something7s_valueE(%rip), %eax movl %eax, %esi）可见类似于上述的，存在内存的数据段中 类静态变量作用域静态成员在多个文件中:类中的机制，可以让定义在文件中的静态成员变量能被其他文件访问；加了作用域的声明，所以可以这样用1234567891011121314151617181920212223在stati.h class Some&#123; 2 public: 3 static int s_v; 4 &#125;; 5 //static int s_vv;//error 错误在stati.cpp #include"stati.h" 2 int Some::s_v=4; 3 //static int s_vv=5;error在main #include "stati.h" int gets= Some::s_v;other:class Whatever&#123;public: static const int s_value = 4; // a static const int can be declared and initialized directly&#125;; 静态成员函数的使用 考虑一个问题，当静态成员被申明为private时，则无法使用它directly by class。but you can用非静态成员函数操作或者用静态成员函数操作to use it 静态成员函数也是可以用类直接调用，它没有this指针，所以不能修改和访问对象的成员； （非静态成员func,它可以定义在类的内部或者外部，外部不用加static,这点和static成员不同，成员得在外部初始化－－因为public等定义成员时，非const不能赋值，而static不能修饰构造函数（对象相关），所以只能在外部初始化) 1234567891011121314151617181920212223class IDGenerator&#123;private: static int s_nextID; // Here's the declaration for a static member public: static int getNextID(); // Here's the declaration for a static function&#125;; // Here's the definition of the static member outside the class. Note we don't use the static keyword here.// We'll start generating IDs at 1int IDGenerator::s_nextID = 1; // Here's the definition of the static function outside of the class. Note we don't use the static keyword here.int IDGenerator::getNextID() &#123; return s_nextID++; &#125; int main()&#123; for (int count=0; count &lt; 5; ++count) std::cout &lt;&lt; "The next ID is: " &lt;&lt; IDGenerator::getNextID() &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_const]]></title>
    <url>%2F2018%2F06%2F08%2Fcpp-const%2F</url>
    <content type="text"><![CDATA[c++关键词之constconst介绍，用法，原理，注意点等const 介绍：const是用于标示不可修改的变量，对象或函数的。在其前面添加const就无法在之后做修改 用法 const总结起来有以下用法： const 修饰基本类型的变量 const int xx=4; const double xd=3.3; const int array[3]={3,4,5}; const 修饰指针和引用 const 指针： const int *p=&value;//无法改变指针指向的值，但是可以改变指针,value可以是int value;/const int value; 123456 int va=4; 6 const int *p=&amp;va ; 7 va=5;&gt;&gt; 8 *p=6;//error 9 cout&lt;&lt;*p&lt;&lt;endl;//5 10 return 0; int *const p=&value; //无法改变指针的值，但是可以改变指针指向的值 const int *const p=&value;//指针的值和指针指向的值 都不可以改变 const 引用： const int &amp;ref=value; const c&amp;cpp差异 不同于CPP，c将const存入的内存中设为只读，还是在栈中，而取其值时需要从内存中获取，所以从这个点看其效率比cpp差why?see follow 123456 c code: const int cc=8;0x4004da movl $0x8,-0x8(%rbp) int ccc=cc;0x4004e1 mov -0x8(%rbp),%eax0x4004e4 mov %eax,-0x4(%rbp) const和类 const 对象 const对象不能调用非const成员函数，也不能改变成员 12345678910111213141516class constobj&#123; public: int ax; int bx; constonj(int a,int b):ax(a),bx(b)&#123;&#125;; int getax() const &#123;return ax;&#125; int getbx() const &#123;return bx;&#125; void setax(int a)&#123;ax=a;&#125; &#125; int main () &#123; constobj cobj; const constobj ccobj; ccobj.setax(3);//error return 0; &#125; const 成员函数（只有成员函数能被声明为const )，它不能改变成员 不能在const成员函数中修改成员变量，但是可以修改其他变量。 非const对象可以调用const成员函数 一个灵活使用const成员函数的例子： 12345678910111213141516171819class Something&#123;private: std::string m_value;public: Something(const std::string &amp;value="") &#123; m_value= value; &#125; const std::string&amp; getValue() const &#123; return m_value; &#125; // getValue() for const objects std::string&amp; getValue() &#123; return m_value; &#125; // getValue() for non-const objects&#125;;int main()&#123; Something something; something.getValue() = "Hi"; // calls non-const getValue(); const Something something2; something2.getValue(); // calls const getValue(); return 0;&#125; c++11中的添加的新内容 constexp，cv限定 c++ const内存和原理 基本变量const变量是在栈中分配内存的，但是仅限于定义的时候，之后其他地方使用这个const变量都直接是使用该值从汇编中可以看到 1234 const int co1=3;0x4008ed movl $0x3,-0x14(%rbp) int nor=co1;0x4008f4 movl $0x3,-0x10(%rbp) 所以无法当进行co1=4;的赋值操作时会被编译器拦截，想想，编译后会变成3=4;是不对的； 这也解释了为什么一开始就要给const的变量赋值 * 数组:save in stack 1234 const int a[3]=&#123;2,3,5&#125;;0x4008fb movl $0x2,-0x20(%rbp)0x400902 movl $0x3,-0x1c(%rbp)0x400909 movl $0x5,-0x18(%rbp) 指针：const指针结合，其并不像基本类型那样贴出值，而是每次还是得去内存中取值，它的限定改变值，由编译器控制报错 指针并不是像前面那样，如123456789101112 const int *p=&amp;value; int xx=*p;//被替换成值?不是的，而是去内存中先取出指针的值，再以此为地址去取值； int pv=4;0x400a12 movl $0x4,-0x58(%rbp) const int *p=&amp;pv;0x400a19 lea -0x58(%rbp),%rax0x400a1d mov %rax,-0x40(%rbp) int px=*p;0x400a69 mov -0x40(%rbp),%rax0x400a6d mov (%rax),%eax0x400a6f mov %eax,-0x48(%rbp) 1234567891011 int pv=4;0x400a12 movl $0x4,-0x70(%rbp)//put 4 in mem(statck) const int *p=&amp;pv;0x400a19 lea -0x70(%rbp),%rax//get its addr0x400a1d mov %rax,-0x58(%rbp)//addr to p int *const pp=&amp;pv; 0x400a21 lea -0x70(%rbp),%rax0x400a25 mov %rax,-0x50(%rbp)//adddr to pp int *ppp=pp;0x400a29 mov -0x50(%rbp),%rax//get pp num0x400a2d mov %rax,-0x48(%rbp)//to ppp 引用：引用同指针，是会去内存中取值的,same to pointer 12345678follow aboveconst int &amp;ref=pv;0x400aba lea -0x7c(%rbp),%rax//get pv0x400abe mov %rax,-0x38(%rbp)//to ref int cs=ref;0x400ac2 mov -0x38(%rbp),%rax//get ref0x400ac6 mov (%rax),%eax//get *ref0x400ac8 mov %eax,-0x64(%rbp)//to cs const类对象： const对象为什么不能更改成员：成员是存在对象中的，如int,char等成员，存在栈中const对象的成员也是放在栈中的，它们之所以不能赋值，是在编译期间确定，更具体的细节未知； const对象为什么不能调用非const成员函数： 一个成员函数如何被调用： 其实成员函数也是全局函数，所以它能被调用， eg: 123456 obj.show();---&gt;实际上被转换为： show(&amp;obj) --传递给this指针： 所以当：const OB obj();obj.show();时，翻译为 const OB *this;在传递给OB *this时会出现不能将this指针从const OB转换为OB &amp;的错误 可以做个实验试试 conclude:if it can use non const func ,it will change member by non const this pointer; 为什么可以调用const函数：const函数：void show() const转换为：show(const OB *this);所以匹配上了，就可以调用了 注意：有最小权限原则，非const对象可以调用const成员函数，就像可以赋值一样。非const变量可以用const赋值]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_linklist3]]></title>
    <url>%2F2018%2F06%2F07%2Fleetcode-linklist3%2F</url>
    <content type="text"><![CDATA[leetcode_linklist3continue.. 反转链表Given a linked list, rotate the list to the right by k places, where k is non-negative.Example 1: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL/** Definition for singly-linked list. struct ListNode { int val; struct ListNode *next; };*/ 12345678910111213141516171819202122232425262728293031323334struct ListNode* rotateRight(struct ListNode* head, int k) &#123; if(head==NULL) return NULL; if(head-&gt;next==NULL) return head; struct ListNode *headnode=(struct ListNode*)malloc(sizeof(struct ListNode)); headnode-&gt;next=head; struct ListNode *sumhead=head; //compute len of list int sum=0; while(sumhead-&gt;next!=NULL) &#123; sum++; sumhead=sumhead-&gt;next; &#125; sum++; //compare k and len,or just compute the rota num int num=k%sum; int i=0; struct ListNode *dealheadf=head; for(i=1;i&lt;sum-num;i++) &#123; dealheadf=dealheadf-&gt;next; &#125; sumhead-&gt;next=headnode-&gt;next; headnode-&gt;next=dealheadf-&gt;next; dealheadf-&gt;next=NULL; head=headnode-&gt;next; headnode-&gt;next=NULL; free(headnode); return head;&#125; 移除倒数第n个元素Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? /** Definition for singly-linked list. struct ListNode { int val; struct ListNode *next; };*/ 12345678910111213141516171819202122232425262728293031323334353637383940struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123; if(head==NULL)//这个几乎没道题都要注意 return head; if(head-&gt;next==NULL&amp;&amp;n&gt;=1) return NULL; int sum=0; struct ListNode *sumhead=head; while(sumhead!=NULL) &#123; sum++; sumhead=sumhead-&gt;next; &#125; int remove=sum-n; struct ListNode *removenode=head; while(remove&gt;1) &#123; removenode=removenode-&gt;next; remove--; &#125; struct ListNode *rmnode; if(remove==1) &#123; struct ListNode *rmnode; rmnode=removenode-&gt;next; removenode-&gt;next=removenode-&gt;next-&gt;next; rmnode-&gt;next=NULL; free(rmnode); &#125; else//删除头 &#123; rmnode=removenode; head=head-&gt;next; rmnode-&gt;next=NULL; free(rmnode); &#125; return head; &#125; //一开始未考虑到删除头的情况，所以加了else 部分 交换元素Given a linked list, swap every two adjacent nodes and return its head. Example: Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Note: Your algorithm should use only constant extra space. You may not modify the values in the list&apos;s nodes, only nodes itself may be changed. /** Definition for singly-linked list. struct ListNode { int val; struct ListNode *next; };*/ 1234567891011121314151617181920212223242526272829struct ListNode* swapPairs(struct ListNode* head) &#123; if(head==NULL) return head; if(head-&gt;next==NULL) return head; struct ListNode *headNode=(struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode *second=head-&gt;next; struct ListNode *first=head; struct ListNode *curhead=headNode; while(1) &#123; if(first==NULL)break; second=first-&gt;next; if(second!=NULL) &#123; first-&gt;next=second-&gt;next==NULL?NULL:second-&gt;next; second-&gt;next=first; curhead-&gt;next=second; curhead=first; first=first-&gt;next==NULL?NULL:first-&gt;next; &#125; else break; &#125; head=headNode-&gt;next; headNode-&gt;next=NULL; free(headNode); return head; &#125; k组反转Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note: Only constant extra memory is allowed. You may not alter the values in the list&apos;s nodes, only nodes itself may be changed. /** Definition for singly-linked list. struct ListNode { int val; struct ListNode *next; };//这道题目原想在遍历一次就解决，可是还是想不出好的方法，得遍历两次，一次计算长度，一次正真的处理；在处理的过程使用头插法。注意边界条件，但因为有数量控制好些*/12345678910111213141516171819202122232425262728293031323334struct ListNode* reverseKGroup(struct ListNode* head, int k) &#123; if(head==NULL) return head; struct ListNode* headnode=(struct ListNode*)malloc(sizeof(struct ListNode)); headnode-&gt;next=head; int len=0; struct ListNode *lenhead=head,*curhead=headnode,*cur=head,*tmp=NULL; while(lenhead!=NULL)//计算长度 &#123; len++; lenhead=lenhead-&gt;next; &#125; int numofreverse=len/k;//要reverse几次 int i=0; int j=0; for(i=1;i&lt;=numofreverse;i++) &#123; j=k; while(j&gt;1)//每一次reverse k次，头插法 &#123; tmp=curhead-&gt;next; curhead-&gt;next=cur-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; curhead-&gt;next-&gt;next=tmp; j--; &#125; curhead=cur; cur=cur-&gt;next; &#125; head=headnode-&gt;next; headnode-&gt;next=NULL; free(headnode); return head; &#125; 总结后面还有几道题，不贴了，这里简述下： 检查是否链表中存在循环 检查链表中是否存在循环并找到循环的起点 深度复制链表，链表中的每个节点存在一个指向任意节点的指针 设计一个LRU cache,即（最近使用的） 。。。。。 链表的套路： 常使用头插法进行反转操作 使用两个指针解决循环问题，指针相遇测试是否存在循环，指针遍历减少时间 使用哈希，以空间换时间 加头节点，简化逻辑 使用链表注意 检查空和是否只有一个节点 释放空间，和放置取空指针，可以通过次数控制和判空]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_linklist2]]></title>
    <url>%2F2018%2F06%2F03%2Fleetcode-linklist2%2F</url>
    <content type="text"><![CDATA[leetcode——单链表2partition list这个是快速排序中一个很重要的步骤，即比该数大于等于的放其前小的放后。在链表中，基本思路:扫描链表，比给定数字小的不处理，比给定数字大的取下并插入到末尾 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions.Example:Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5*//** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* partition(struct ListNode* head, int x) &#123; /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */ if(head==NULL) return NULL; if(head-&gt;next ==NULL) return head; struct ListNode *list=(struct ListNode*)malloc(sizeof(struct ListNode)); list-&gt;next=head; struct ListNode*head1=list; struct ListNode*cur = head1-&gt;next; struct ListNode*tail=head1; int lenoflist1=0; while(tail-&gt;next!=NULL) &#123; tail=tail-&gt;next; lenoflist1++; &#125; struct ListNode* tmp=tail; while(lenoflist1&gt;=1) &#123; lenoflist1--; if(tail==cur) continue; if(cur-&gt;val&gt;=x) &#123; head1-&gt;next=cur-&gt;next; cur-&gt;next=NULL; tail-&gt;next=cur; tail=tail-&gt;next;//not consid at first cur=head1-&gt;next; &#125; else&#123; head1=head1-&gt;next; cur=cur-&gt;next; &#125; // printf("%d : ",cur-&gt;num); &#125; //if(head1-&gt;next==NULL)head1-&gt;next=tmp; head=list-&gt;next; list-&gt;next=NULL; free(list); printf("\n"); return head; &#125; //此题目最终被accepted//应该在函数中添加头节点而不是依靠传入的链表带头节点,一开始没有考虑到传入的链表不带链表头。。，没有考虑到一个元素的情况，这个方案最终accept 链表中的子链表反转，考察头插法 头插法在链表的反转，倒序，常被用到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* reverse a linklist from m to n * 1-&gt;2-&gt;4-&gt;5-&gt;null and m,n(ex:2,4) * return 1-&gt;5-&gt;4-&gt;2-&gt;null */#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;typedef struct LinkList&#123; int num; struct LinkList *next;&#125;Linklist;int reverselinklist(Linklist *list1,int m,int n,Linklist **result)&#123; if(list1==NULL) return -1; int i=0; Linklist *head1,*head2,*cur,*tmp,*pre; cur=list1; head1=cur; pre=head1; if(m==1) &#123; cur=cur-&gt;next; for(i=m;i&lt;n;i++) &#123; pre-&gt;next=cur-&gt;next; cur-&gt;next=head1; head1=cur; cur=pre-&gt;next; &#125; *result=head1; return 1; &#125; for(i=1;i&lt;m;i++)//node1-&gt;node2-&gt;node3---1-&gt;2-&gt;3--ex:m=2,list1-&gt;1 &#123; head1=cur; cur=cur-&gt;next; &#125; head2=cur; cur=cur-&gt;next; pre=head2; for(i=m;i&lt;n;i++) &#123; pre-&gt;next=cur-&gt;next; cur-&gt;next=head1-&gt;next; head1-&gt;next=cur; cur=pre-&gt;next; &#125; return 3;&#125;int main ()&#123; Linklist *list1=(Linklist*)malloc(sizeof(Linklist)); Linklist *result11=list1; int i; list1-&gt;num=4; printf("4 "); for(i=1; i&lt;9;i++) &#123; list1-&gt;next = (Linklist *)malloc(sizeof(Linklist)); list1 = list1-&gt;next; list1-&gt;num = i*2; printf("%d ",i*2); &#125; printf("\n"); Linklist *rr=(Linklist *)malloc(sizeof(Linklist)); Linklist **resull=&amp;rr; int rere=reverselinklist(result11,1,9,resull); if(rere==3) &#123; for(i=0;result11!=NULL ;i++,result11=result11-&gt;next) printf("%d ",result11-&gt;num); free(list1); &#125; else &#123; for(i=0;*resull!=NULL ;i++,*resull= (*resull)-&gt;next) printf("%d ",(*resull)-&gt;num); free(*resull); &#125; return 0;&#125; //此解法未经过leetcode检验，不过应该问题不大 有序链表移除重复元素 考察的是遍历链表删除链表中的元素，注意边缘条件控制如头部和尾部 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** Given a sorted linked list, delete all duplicates such that each element appear only once.Example 1:Input: 1-&gt;1-&gt;2Output: 1-&gt;2Example 2:Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* deleteDuplicates(struct ListNode* head) &#123; if(head==NULL)return NULL; if(head-&gt;next==NULL)return head; struct ListNode *first=head; struct ListNode *second=head-&gt;next; struct ListNode *tmp=second; while(second!=NULL) &#123; tmp=second; if(first-&gt;val==second-&gt;val) &#123; second=second-&gt;next; &#125; else &#123; first-&gt;next=second; first=first-&gt;next; second=second-&gt;next; &#125; &#125; if(first-&gt;val==tmp-&gt;val) first-&gt;next=NULL; return head;&#125; //此方案最后被accepted 删除有序链表中的有重复的node 和上一道题目类似: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** Given a sorted linked list, delete all duplicates such that each element appear only once.Example 1:Input: 1-&gt;1-&gt;2Output: 1-&gt;2Example 2:Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct ListNode &#123; int val; struct ListNode *next; &#125;;struct ListNode* deleteDuplicates(struct ListNode* head) &#123; if(head==NULL)return NULL; if(head-&gt;next==NULL)return head; struct ListNode *headnode=(struct ListNode*)malloc(sizeof(struct ListNode)); headnode-&gt;next=head; struct ListNode *first=head; struct ListNode *second=head-&gt;next; int numsame=0; struct ListNode *tmphead=headnode; while(second!=NULL) &#123; if(first-&gt;val==second-&gt;val) &#123; numsame++; first=first-&gt;next; second=second-&gt;next; &#125; else if(first-&gt;val !=second-&gt;val &amp;&amp; numsame==0) &#123; tmphead-&gt;next=first; tmphead=tmphead-&gt;next; first=first-&gt;next; second=second-&gt;next; &#125; else &#123; first=first-&gt;next; second=second-&gt;next; numsame=0; &#125; &#125; if(numsame==0)tmphead-&gt;next=first; else tmphead-&gt;next =NULL; head=headnode-&gt;next; headnode-&gt;next=NULL; free(headnode); return head;&#125;int main()&#123; struct ListNode *list1=(struct ListNode *)malloc(sizeof(struct ListNode)); struct ListNode *tmp=list1; struct ListNode *freelist1=list1; int i=0; for(i=1;i&lt;9;i++) &#123; list1-&gt;val=20-i; list1-&gt;next=(struct ListNode *)malloc(sizeof(struct ListNode)); list1=list1-&gt;next; printf("%d ",20-i); &#125; list1-&gt;val=12; tmp=deleteDuplicates(tmp); printf("\n"); for(i=1;tmp!=NULL;i++) &#123; printf("%d ",tmp-&gt;val); tmp=tmp-&gt;next; &#125; free(freelist1); return 0;&#125;这道题做的比较顺利，一次提交就=通过了注意：加头节点，由于解题的思路是两个指针的遍历，在第二个指针为空时停止，就会有尾巴为几种情况时的处理：如当尾巴为：4,4,4;4,5,5 这两种情况时，去掉尾巴，否则4,5,6.4,4,5时尾巴保留；见代码]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_linklist1]]></title>
    <url>%2F2018%2F06%2F03%2Fleetcode-linklist1%2F</url>
    <content type="text"><![CDATA[leetcode——单链表两数相加： 这道题是经一年多没刷题目之后，重新开始的第一道题，本来想着只是本地刷刷，后面开始就到leetcode提交了，毕竟写的程序还是得经过检验 所以这道题就纯粹的解答，未经检验，只是本地跑通，并且加上了自己的一些看法，比如对该题目该思路可能可以应用在哪些地方，这样算法才有了真正的意义，个人十分不赞同一些在公司呆久了的人说数据结构算法没什么用的人2333 废话不多说： 好久没写，第一道就别吐槽了，慢慢来 题目描述： You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.ExampleInput: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.注意两个数字位数可能不同，所以需要一些特殊情况要处理12#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149struct ListNode &#123; struct ListNode *next; int num;&#125; *linklist,listnode;//这是自己加的扩展，把输入的两个大数字符串转换为链表int changtolist(struct ListNode *list1,char num1[],struct ListNode *list2,char num2[])&#123;//应该在接口内计算长度好些 int i=0; int lennum1=0; while(num1[lennum1]!='\0')&#123;lennum1++;&#125; int lennum2=0; while(num2[lennum2]!='\0')&#123;lennum2++;&#125;//分配空间加字母转数字，无头节点 list1-&gt;num=num1[lennum1-1]-48; for(i=lennum1-2;i&gt;=0;i--) &#123; list1-&gt;next=(struct ListNode*)malloc(sizeof(struct ListNode)); list1=list1-&gt;next; list1-&gt;num=num1[i]-48; &#125; list1-&gt;next=NULL; list2-&gt;num=num2[lennum2-1]-48; for(i=lennum2-2;i&gt;=0;i--) &#123; list2-&gt;next=(struct ListNode*)malloc(sizeof(struct ListNode)); list2=list2-&gt;next; list2-&gt;num=num2[i]-48; &#125; list2-&gt;next=NULL; return 0;&#125;//两个大数相加，不用头节点的方式，麻烦一些int Add_two_num(struct ListNode *list1,struct ListNode *list2)&#123; int adding = 0; if(list1 == NULL || list2 == NULL) return -1;/* while(list1!=NULL &amp;&amp; list2!=NULL) &#123; list1-&gt;num = (list1-&gt;num+list2-&gt;num+adding)%10; adding = (list1-&gt;num + list2-&gt;num+adding)/10; list1 = list1-&gt;next; list2 = list2-&gt;next; &#125; if(list1==NULL &amp;&amp; list2!=NULL) */ struct ListNode *xx=list1; int n=0; int sum=0; sum = list1-&gt;num+list2-&gt;num+adding; list1-&gt;num = sum%10; adding = sum/10; do &#123;//常规情况，两个同长度部分 list1 = list1-&gt;next; list2 = list2-&gt;next; sum= list1-&gt;num+list2-&gt;num+adding; list1-&gt;num = sum %10; // printf("%d ",list1-&gt;num); adding = sum/10; &#125;while(list1-&gt;next!=NULL &amp;&amp; list2-&gt;next!=NULL); if(list1-&gt;next ==NULL&amp;&amp; list2-&gt;next==NULL &amp;&amp;adding!=0)//串1短于串2 &#123; list1-&gt;next = (struct ListNode *)malloc(sizeof(struct ListNode)); list1-&gt;next-&gt;num= adding; printf("show:%d\n",adding); &#125; if(list1-&gt;next==NULL &amp;&amp; list2-&gt;next !=NULL) &#123; list1-&gt;next = list2-&gt;next; while(list2-&gt;next!=NULL&amp;&amp;adding !=0) &#123; list2=list2-&gt;next; sum= list2-&gt;num+adding; list2-&gt;num=sum%10; adding = sum/10; &#125; if(adding&gt;0) &#123; list2-&gt;next=(struct ListNode *)malloc(sizeof(struct ListNode)); list2-&gt;next-&gt;num=adding; &#125; &#125; ...//串1长于 串2 ..... return 0;&#125;//需要思考，当进位到最后时，可能1,2都结束了，但是产生高位，此时要new listnode 完成//或者剩下２，和进位，则考虑２加进位int main ()&#123; struct ListNode *list1,*list2; list1 = (struct ListNode*)malloc(sizeof(struct ListNode)); list2 = (struct ListNode*)malloc(sizeof(struct ListNode)); list1-&gt;num=3; list2-&gt;num=5; struct ListNode *tmplist1=list1; struct ListNode *tmplist2=list2; int i; for(i=1; i&lt;9;i++) &#123; list1-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); list2-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); list1 = list1-&gt;next; list2 = list2-&gt;next; list1-&gt;num = 2; list2-&gt;num= 8; &#125; list2-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); list2-&gt;next-&gt;num=9; struct ListNode *result=tmplist1; struct ListNode *freelist1 = tmplist1; struct ListNode *freelist2 = tmplist2; for (i=0;i&lt;9;i++,tmplist1=tmplist1-&gt;next) printf("%d ",tmplist1-&gt;num); printf("\n"); for (i=0;i&lt;10;i++,tmplist2=tmplist2-&gt;next) printf("%d ",tmplist2-&gt;num); printf("\n"); Add_two_num(freelist1,freelist2); for(i=0;result!=NULL ;i++,result=result-&gt;next) printf("%d ",result-&gt;num); free(freelist1); free(freelist2); printf("\n");//------------------------------- struct ListNode *list11,*list22; list11 = (struct ListNode*)malloc(sizeof(struct ListNode)); list22 = (struct ListNode*)malloc(sizeof(struct ListNode)); char num1[100],num2[100]; gets(num1); gets(num2); changtolist(list11,num1,list22,num2); struct ListNode *result11 = list11; Add_two_num(list11,list22); for(i=0;result11!=NULL ;i++,result11=result11-&gt;next) printf("%d ",result11-&gt;num); free(list11); free(list22); return 0;&#125; //思考，扩大这道题的应用，在大数相加的时候，增加用户输入接口:”//5263565656554+5656537677834546//由char读入，int/char相加，——-极其丑的程序，以后不能这么搞，留个纪念想贴下两年多前（大三吧，那会刷这道题通过的程序–看来最喜欢的还是c）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *sum, *l4; sum = new ListNode(0); //新节点 l4 = sum; int sum_single, en = 0;//en表示进位的标志 while (l1 != NULL&amp;&amp;l2 != NULL) &#123; sum-&gt;next = new ListNode(0);//这里有个问题变为sum=NULL就行 sum = sum-&gt;next; // signal = 0; sum_single = l1-&gt;val + l2-&gt;val + en; if (sum_single&lt;10) &#123; sum-&gt;val = sum_single; en = 0; &#125; else if (sum_single &gt;= 10) &#123; sum-&gt;val = sum_single - 10; en = 1; &#125; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; while (l1 != NULL&amp;&amp;l2 == NULL) &#123; sum-&gt;next = new ListNode(0); sum = sum-&gt;next; sum_single = en + l1-&gt;val; if (sum_single &gt;= 10) &#123; sum-&gt;val = sum_single - 10; en = 1; &#125; else &#123; sum-&gt;val = sum_single; en = 0; &#125; l1 = l1-&gt;next; &#125; while (l2 != NULL&amp;&amp;l1 == NULL) &#123; sum-&gt;next = new ListNode(0); sum = sum-&gt;next; sum_single = en + l2-&gt;val; if (sum_single &gt;= 10) &#123; sum-&gt;val = sum_single - 10; en = 1; &#125; else &#123; sum-&gt;val = sum_single; en = 0; &#125; l2 = l2-&gt;next; &#125; if (l1 == NULL&amp;&amp;l2 == NULL&amp;&amp;en == 1) sum-&gt;next = new ListNode(en); //if(l1==NULL&amp;&amp;l2==NULL&amp;&amp;en==0)sum = NULL; /* while (l3) &#123; cout &lt;&lt; l3-&gt;val; l3 = l3-&gt;next; &#125;*/ return l4-&gt;next; &#125; &#125;;/*int main()&#123; Solution sou; ListNode *l1,*l2,*l3; l1=new ListNode(3); l1-&gt;next=new ListNode(7); l1-&gt;next-&gt;next=new ListNode(5); l2=new ListNode(7); l2-&gt;next=new ListNode(7); l2-&gt;next-&gt;next=new ListNode(5); l3=sou.addTwoNumbers(l1,l2); cout&lt;&lt;l3-&gt;val&lt;&lt;l3-&gt;next-&gt;val&lt;&lt;l3-&gt;next-&gt;next-&gt;val; return 0;&#125;*/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_IP]]></title>
    <url>%2F2018%2F06%2F03%2Ftcpip-IP%2F</url>
    <content type="text"><![CDATA[IP 协议和路由IP的作用–路由路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作? 从广义上讲，路由是路线图，就像百度地图上源地址到目的地址的路线，路线有很多，故路由也很多； 从网络层面讲，路由是一个数据包从源地址到目的地的传输路径，它如何被决定怎么走，即中间经过哪些路由器，选择哪一条路线等等。 一个数据包在网络上传输实例：A,B连上AP进行上网，AP和外网连接，AP的下一站是D;A 在构造了数据包后选择发送，要查询路由表，若该数据包发送给B,则通过路由表中的直连路由，找到B的ip,发送时不知道B的mac地址，故先做arp,得到后将数据包发给B:数据包：源ip：A,源mac A ，目的IP:B,目的mac:B若A在构造了数据包后，查询路由，该数据包是发送给外网，目的地址是百度ip,则无此条目，向默认路由；即发给路由器，此时若不知道mac地址会做arp;数据包：源ip:A,源mac：A ,目的ip:百度，目的mac：路由器(arp代理）数据包到路由器后，将做下一步转发：在路由发送的数据包：源ip:路由外网地址，源mac:路由，目的ip:百度ip.目的mac,D(注意，在源ip改为路由外网地址后，此时ip唯一，源地址在传输过程中不会再改变） 内网的路由器会将源地址改为路由器的外网地址—想想像192.168.0.4这样的源地址是内网地址，如果在包的传输过程中不做处理，到达目的地如QQ的服务器，那QQ处理完要发给你，这时得到包是从192.168.0.4来的，它作为内网地址，全世界很多个，怎么决定—–所以ip首部中的源地址和目的地址必须是全球唯一的ip地址，即外网地址； 路由器会对ttl做减1,然后再重新做校验和–即直接加1 路由器会将数据包的mac首部，源地址改为路由的mac地址，目的地址改为默认路由（或其他导向路由）ip对应的mac地址 网络地址和子网这里不记录太多的ip地址相关的内容，毕竟比较基础，且协议卷或者网上很多介绍 网络地址简介网络地址用来在网络上代表一台设备，就像家庭地址一样，当然现在的设备，如手机可以同时拥有几个ip地址（数据网，wifi，等等，可以理解为家有多个门）而现在的网络地址从32位点分十进制地址， 决定了它的数量–&gt;一个网络中的设备数量决定了它如何划分网络 网络中的设备数量动态性，可能很少，ip地址不够用–&gt;子网出现（CIDR) 网络地址不够用了–&gt;NAT出现，内网 网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?—其实本质上，设备间可以通过知道mac地址相互通信，即没有网络的隔离（只要介质支持如wifi,或者有线网下设备能被连在一起)在二层上考虑的 到了三层，ip层，设备与设备之间的通信，取决于网络的大小，在同一个局域网中，设备间可以直接通信，但是不同局域网，就必须借助路由器，网络，为什么?首先，考虑他们的距离，若很远，则单纯直连很难，则需要转发，转发单知道mac地址（好吧，假设一开始知道对方的mac地址），很难像现在用ip地址的方式去找到它emm感觉考虑到协议设计了。。。其次，考虑相邻的不同网络，对应不同的网段，路由表规定了只能和该网络地址范围的主机直接连接，否则就要用默认路由了 考虑这样一个例子：A 在子网192.168.0.0中，地址为192.168.0.3,B在子网10.170.3.0,地址为10.170.3.2,使用wifi,他们之间相邻，此时，A向B发送ARP请求，广播帧，所以B可以接收到，接着B给A回复了响应帧，单波能收到，因为在二层传递，能接收到，不被内核过滤，此时arp表中应该多了条目；接着为了能在三层通信，在路由表中增加一条路由指示不同网段的一个地址，表示他们可以直连，接着测试看看能不能相互发送ip包，ping通，当然可能因为防火墙等；就理论而言，应该是能通的，没试过~–&gt;问题总结：IP地址网段不同的两个设备，一定不能直接通信码? 网关地址必须是.1结尾码?恩当然可以是别的地址 路由表和路由规则决定了这些路由表如何决定了网络的方向，下一跳，和限制了网络范围？ IP封包简介 ip封包网上能找到详情，这里记录几个注意点： 网络字节序的概念，是大端字节序，传输的次序是先0-7bit—最后到24-31这样，所以小端的设备需要线转换为网络字节序再传输 首部长度字段是指占32bit的数量，有4bit，最大1111*4bytes=60bytes,即ip首部最长为60字节，普通ip同不带选项时是20字节 服务类型现在已经不怎么用，主要是指在不同服务下拥有不同的最小时延，最大吞吐，最高可靠性的情况，具体见协议卷１图3-2 总长度，指整个ip数据包的长度，包含首部和数据报，16位，即最大2^16=65535个字节，（考虑超级通道的mtu=65535并非是真正的mtu,而是最长ip数据报），数据报分片时会随着变化 标示和分片偏移等后面补充 校验和为ip首部校验和:首先校验和设置为0，接着每个16bit进行反码求和。rfc1071 网络的拓扑结构:理论上，网络中的每台设备都能相互通信，即使是点对点通信p2p.但是这要求设备能在网络上被唯一标示，如外网ip地址； 所以常见的设备A和B的通信借助服务器如：主机A路由器(给主机唯一标识)服务器路由器主机B(现有的大部分通信软件等都是这样的) 而主机A可以直接和主机B通信不通过服务器吗?答案是可以，我们使用的迅雷，bt,这些下载资源就是利用的各个主机的资源，其结构如何：主机A路由器(做NAPT等)路由器主机B那和主机A和B如何在网络上被唯一标示，且被B知道该地址呢?路由器在其中充当什么角色，会做什么限制呢？见下NAT和NAT穿透路由深入–NAT和NAT穿透感谢这两篇文章把我带进门：https://blog.csdn.net/u012908515/article/details/53518062https://blog.csdn.net/ustcgy/article/details/5655050rfc ：nathttps://tools.ietf.org/html/rfc1631https://tools.ietf.org/html/rfc2663rfc：p2phttps://tools.ietf.org/html/rfc5694NAT的由来 NAT的出现是因为ipv4的地址不够用，所以大量主机在内网使用内网地址，这样在互联网上通信的时候不能被寻找到，此时路由器将内网的设备发送的包中的ip转换为外网的ip,并记录映射在路由器中，这样就能实现主机在互联网上的正常通信，即发包和收包都能找到； 而这种方式阻碍了不同内网的主机之间的通信，即p2p;NAT的分类（路由器决定） 静态NAT:即内网的一个IP对应外网的一个IP，且一一对应，即每次分配的时候都是相同的，永久的 动态NAT：即内网的一个IP对应外网的一个IP,但是每次分配的外网IP可能不同，映射不同 NAPT:即为了使同一个外网IP能被多个内网的主机使用而出现；如何区分各个主机？即路由器发包时和收包时，如收包时，如何确定该包是发给主机A还是B?即用NAPT,IP加端口号的形式来区分 NAPT分为以下两大类：cone锥形NAT和symmetric 对称NAT cone NAT的特点是对内网的主机A，和外网所有的服务器通信，都使用相同的端口号；如：内网：192.168.4.5:4323–&gt;server:222.33.22.334:80则经过路由器：外网ip:122.332.43.32:1234–&gt;server:22…路由器把源地址改为122.332.43.32:1234后发送进过服务器2也是类似的，使用同一个端口1234//这里有个疑问，即内网下相同的ip地址，不同的端口时，经过路由器转换后是否为不同端口考虑在接收服务器回复的内容时:222.33.22.334:80–&gt;122.332.43.32：1234此时路由器根据映射，即端口122.332.43.32：1234对应的是192.168.4.5把目的地址和端口更改为它后发送。所以为了能让包在主机内找到对应端口的程序，路由器的设置应为内网同ip不同端口，映射外网的ip+不同端口（待验证） 锥形NAT类型：完全锥形full cone和受限锥形( restricted cone) 以及端口受限锥形（port restricted cone) 完全锥形：任何知道主机B银蛇在NAT上的外部地址和端口的主机都可以通过它发包给内部主机B,即使A在内网(在内网时通过映射的外网地址） 受限锥形：只有内部主机B向其发送过包的主机A才能对这个内部主机B发包（通过主机B映射在外部的地址端口） 端口受限：在受限锥形的基础上加了端口限制 对称NAT(symmetric nat):会为新的session分配新的端口，即和服务器1通信时使用端口1234，接着发起新的服务器2访问时，使用端口1235等如何检测类型？https://blog.csdn.net/u012908515/article/details/53518062 ipv6不需要NATipv6地址很多，有人形容世界上的每个沙子都能被定址，所以地址够用，也就不用内网，所以用来做p2p更适用，自然也就不用什么nat转换 p2p网络架构和内网穿透基于上面的napt类型介绍，可以知道内网的主机如何和外网的服务器通信，那内网的主机1如何和另一个内网的主机2直接通信?（不借助服务器）答案:基于上面的限制，有几种方案： 针对full cone类型的，内网主机2只要知道内网主机1映射到外部的ip地址和端口，就可以直接发送数据包给1，且能接收； 针对受限的cone类型，内网机2像上面的方式是不行的：得满足两个条件：1是知道主机1映射到外部的ip和端口，2是主机1曾向主机2发送过请求，相当于开了个口，显然这个条件下2为服务器或者有公网ip的设备；所以针对此受限的类型，有一下场景+方案： 场景1：主机1在nat后，打开了和服务器A通信，主机2想和1通信，主机2不在nat后；显然直接向主机1发起请求是不行的，上述条件2不满足，主机1不曾向2发起请求； 解决方案是，借助服务器A请求主机1做一个反向连接，即向2发起请求，从而打开通道，进而2就可以跟1通信了 场景2：主机1在nat后，主机2在nat后，主机1，2均打开了和服务器A通信，主机1想直接和2通过双方映射到外网的地址端口进行通信 解决方案：UDP打洞：假如1开始发送一个UDP信息到2的公网地址上,与此同时,他又通过A中转发送了一个邀请信息给2,请求2也给1发送一个UDP信息到1的公网地址上.这时1向2的公网IP发送的信息导致 NAT 1 打开一个处于1的私有地址和2的公网地址之间的新的通信会话,与此同时NAT 2也打开了一个处于2的私有地址和1的公网地址之间的新的通信会话.一旦这个新的UDP会话各自向对方打开了,1和2之间就可以直接通信,而无需A来牵线搭桥了.这就是所谓的打洞技术.一旦这种处于NAT之后的端对端的直连建立之后,连接的双方可以轮流担任对方的”媒人”,把对方介绍给其他的客户端,这样就极大的降低了服务器A的工作量. 场景3：主机1和2处于同一个NAT下，他们却不知道： 解决方案：综合相同内网下主机可以直接相互通信原理：在主机1发送给A的包中携带其内网地址和端口，A从而知道了1的外网端口地址和内网端口地址，相互都发给1,2，若接着1发起请求给2能收到回复说明在同一个内网，否则采用场景2的解决方案 场景4：主机1处于多层NAT下 问题：udp空闲状态下超时断开的问题：使用心跳包 扩展：tcp的打洞，同时开放tcp连接，原理类似，较复杂 针对对称性的cone,不定因素多，不建议写 所以p2p网络即是多个内网主机1,2,3,4等之间的相互直接通信，即他们之间的下载数据可以相互共享，也就是平常说的挂种子，bt下载，也是为什么能达到那么快速的原因;当然可想这个过程和普通的cs架构区别： p2p架构，bt模型（猜测)：首先客户端负责下载和挂种的基本功能。下载:需要向服务器取得可以获取资源的主机的nat外网地址和ip,接着服务器为其打洞，将正在挂种的客户ip等提供给该客户端，从而能下载；挂种：给服务器声明自己能提供资源，并通过心跳维持一个持续的洞；BT服务器做什么?综合客户端资源和打洞，即让下载方能方访问挂种放 。 这个过程需要考虑：下载方面对多个挂种方，如何下载文件块和组装，最多同时和几个挂种方下载等等； 回忆：之前学校的rs bt站就是这样，只是开放在学校的内网，可以说是相同nat下的不同主机???好像也不能这么说。。然后采用的原理就是上述的，记得一开始速度不是很快，但是后面15年吧，下载速度能达到10+m/s,很快的，我想可能是优化了下载多个挂种方的方案，增加了最多的下载源，或者学校的网络变优～Cbitterrot源码分析（待~)https://linux.cn/thread-5529-1-1.html对于p2p架构的软件设计，其实跟平常的cs架构很象，都需要用到socket等]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_MAC]]></title>
    <url>%2F2018%2F06%2F03%2Ftcpip-MAC%2F</url>
    <content type="text"><![CDATA[mac数据链路层的理解mac层的功能介绍mac层在理论上赋予了较全的功能，但是其实，实际上在使用的时候，由于无噪声通道，或者一些功能交给了上层的协议，所以实际的mac功能没有理论那么全面。mac层的实现包括在驱动和固件中，所以实际的功能得看芯片和固件的支持，比如是否支持监听模式； 理论上：建议书籍《数据通信与网络》寻址：实际的端到端通信，都是需要先知到对方的mac地址(通过arp),才能进行实际传输的；帧构建：这一层结束后就是完成了包封装，下一步传送给物理层编码发送了；数据差错检查；传送控制，流量控制，差错控制，编码，校验和等等；，编码是指在原始数据mac封包后，在实际传输时进行编码（按照某个80x协议等，这个属于偏物理层的事情了）实际上：数据差错检查，流量控制，差错控制等都没做，或者要看具体的厂商实现如高通，mtk等 mac层的传输限制 考虑一个包从电脑发出去，最后一次封包根据接口不同(有线，无线),协议不同，采用的mac头也不同，如ppp协议要加其他信息； –&gt;简述:接着可能发给无线路由器或者交换机，路由器会判断是wifi的mac头，接着要向以太网传输时，或者无线传输时，需要去掉mac头，并加上自己的mac头，改变mac源地址为自己，目的地址为(路由表对应)arp寻找的下一跳mac地址;若为以太网，还要转换为以太网的头类型等 … 整个过程，从物理层角度看，是可以顺利进行的，但是实际为了效率，不接受无用的包，不发送无效的包和安全等，在驱动和固件都会有做相应的过滤处理，从而使发包收包，转发包等受到了限制，见下实验等； mac层的封包,mtu,msdu,mpdu在包的封装上，有线网和无线网不同，更确切的是协议不同，其mac层封包也不同–对相同的ip包(ip头+上层数据/arp/…）带有不同的mac头：例如对以太网（有线）：常见有一下四种mac头封装的帧： EthernetII: dest addr+src addr+type+data+fcs Ethernet 802.2:dest addr+srcaddr+len+ llc+data+fcs Ethernet 802.3:dest addr+src addr+len+data+fcs Ethernet SNAP:dest addr+src addr+len+llc+snap+data+fcs参考：https://blog.csdn.net/xiao628945/article/details/8006022针对无线网络：802.11n等，更复杂些： 802.11头+msdu(数据部分)+fcs(crc)而802.11wifi无线帧分为控制帧，管理帧和数据帧，因为在无线网络中的安全性等考虑，需要扫描，关联，认证四次握手等步骤,在802.11头就包含了subtype，即数据部分是什么类型（控制，。。）https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了这么多的封包类型，除却ip层只有一种，那在传递的过程中如何处理?即有线到无线，怎么识别?答案是在路由器，主机中进行去头和加头不同厂商实现不同，在无线中，非数据帧部分：底层的实现分为full mac driver（Full Mac的Driver，一般Auth和Assoc的包直接在芯片里边处理了，Driver通过command形式告诉Firmware要连接AP的信息，Firmware处理了Assoc Response之后，report给Driver一个Event，说明连接的情况（result和AID）以及assoc相关的IE，Driver会直接调用cfg80211的接口报告给supplicant，然后处理EAPOL的握手过程，因为之后的EAPOL Data的处理会用到Assoc Response里边的IE） 而用soft mac则软件可以控制较多的事情(Soft Mac模块开源代码mac80211的WiFi芯片，会将这两种包送到Mac80211处理，mac80211处理完后调用cfg80211的接口通过nl80211(netlink)通知wpa_supplicant准备认证以及四次握手的状态机，等待处理EAPOL包，EAPOL是二层的Data包，会在Supplicant里边处理，连接加密的路由情况就是这样处理的，如果不加密，那就直接DHCP了)；扯远了。。在pc等设备中，在封装到数据链路层时，封装时用的是ethernetII，到底层驱动时就被替换为对应的802.11的头了，进而发送出去，而在接收数据包的时候，底层上报上来又会把802.11格式的转换为ehternetII的形式，所以我在实验wifi的时候，用的PF_PACKET来操作数据包，加的是ethernetII的头，接收到打印出来后还是ethernetII的头晒张空中包的和本地tcpdump抓到的包对比：//to do 当然除却mac头的不同，mtu的概念还是存在:mac层在传输时一次传输一帧，这一帧即是封装了mac头的数据包，它常为[46-1500]+mac头,而mtu即是最大的传输单元，是去掉mac头的负载部分最大值，如1500而在实际传输的空中包，情况又可能不同，这里看msdu 和mpdu:https://blog.csdn.net/zhengnice/article/details/51923132这篇文章讲的很好，在理解了上述的内容后，看这篇文章里面的msdu和mpdu就能很好的理解了，spec的416页也有相关的内容 mac头格式：不同协议可能不同：常见：dest addr,src addr ,proto type; 14byte见上文 mac层的发包和收包限制考虑一个问题，即在不考虑网络网段的情况下，两台设备在开启wifi或者连接网线的情况下，能相互直接通信吗？从理论上是可以的，首先是发送，无问题，接收，可以接收；其次，接收之后解码，需要双方使用相同的编码协议等；其次：实际上，需要几个条件，且有线和无线的方式不同： 有线：需要双方相同的编码，直连的情况下，可以直接通信； 无线: (分为数据部分和管理部分，需要双方相同的编码)，但是仅开启wifi，只能接收小量信息的beacon帧；即wifi为了安全性，效率等(wifi本身可以接收所有数据），做了连接前的扫描，关联认证，四次握手等过程，并且对mac地址进行过滤，使不同网段的两个相邻设备不能通过直接发送接收mac层数据来交互；具体见厂商的实现，可以参考实验部分； 所以关键看厂商怎么实现，底层的东西，他们提供接口给你，你就能操作了balalal普通模式，混杂模式和监听模式mac层的几个实验普通模式下，wifi实验，以station架构进行：设备A，B,路由器C，D; A,B连接同一个路由器C,A,B通过PF_PACKET发送和接收mac头加任意数据，成功发送接收，即使arp表无对方的条目 A,B都不连接wifi,只是打开wifi，此时无法发送和接收数据，厂商默认的只会发送主动扫苗和接收beacon帧，扫描的具体过程待文章写,在没有连接上时，只会发送小数据 A,B间任意设备连上路由器，同上 A连接路由C,B连接路由D,相互发送和接收mac头加任意数据，目的地址为对方mac，源地址为自己的mac—失败，其实一开始是怀着疑问的，从理论分析是可以的，但是还是不行，若只是在二层的话，对方怎么知道这个源mac地址是在不同网段并做过滤?难道发之前，底层进行了隐式arp？但是我发的包里面没有带ip信息啊，同时进行了广播帧的发送接收，还是失败了；应该都是出在接收的环节；也有可能是两个ap使用的协议不同导致编码方式不同从而接收失败 考虑到可能是两个路由器编码和使用的协议如一个是802.11n,一个是ac，等，可能导致接收不到，所以可以再尝试使用两个相同的型号的路由器；//待测试 发送方普通模式，接收方监听模式，接收方可以收到所有包，所以可以接收到 openwrt开源路由系统，驱动，固件了解一下。。。spec:Wireless LAN Medium Access Control(MAC)and Physical Layer (PHY) Specifications]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_ARP]]></title>
    <url>%2F2018%2F05%2F27%2Ftcpip-ARP%2F</url>
    <content type="text"><![CDATA[ARP 协议ARP协议的作用 ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信； 在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：端设备手机pc等–&gt;(交换机)路由器—&gt;下一个路由器—&gt;下一个终端设备 端设备默认路由到网关–&gt;网关收到包后，将源地址改为网关的外网地址—&gt;下一个路由–&gt;….-&gt;设备地址为目的地址时，接收而不转发 考虑一个问题：在上述的网络上发送时，如pc发给路由器时，只知道它的ip地址，怎么发给它：即端到端的发送：是借助设备唯一的mac地址来发送的在有线网中。利用了交换机的端口和mac地址关系，转发在wifi中，能接收到所有的包，但是会在驱动中将mac目的地址非本地的包丢弃，除非开启了混杂监听模式 但是路由器怎么知道设备如手机的mac地址呢？通过arp协议来获取，arp是依赖mac和ip的”映射” tcpip卷1中4.2举了一个完整的例子，可以去看ARP协议的交互过程 基本的交互方式：例如ping网关：station —ARP request—-&gt; AP ARP请求，广播帧station &lt;—ARP response — AP ARP应答 ,单播帧通过上述的方式，station得到了AP的mac地址，之后将AP的MAC地址存在缓存中，在下次数据包等包的时候就可以将该mac地址填在mac头中，即知道了AP的地址后，包就可以顺利的被AP接收了 AP(路由器)也会主动的向station发送arp request，当它不知道station的mac地址（或缓存过期），例如，AP收到一个外网的包，要转发给对应192.168.0.4的staton,但是没有他的mac地址，或者过期了或者其他情况，则向该station发出arp请求。从而得打station的mac地址 什么时候会触发arp请求？1.在ping的时候2.在发送tcp，ip包的时候3.在缓存过期时主动发出，这个由arp状态机中实现ARP代理和免费ARP 当我们通过ping百度，或者想访问百度的时候，怎么在mac头中填写目的mac地址呢？即怎么找到百度?（另一个网络) 是通过在mac头目的mac地址填写网关的mac地址实现的，借助w网关的来帮我们寻找，这个叫做ARP代理,其实欺骗了主机 tcpip卷对此有较详细解说4.6 免费ARP是用于检测是否周围有使用相同的ip地址的设备，即通过ping自己，寻找有自己的ip的主机ARP协议的包封装格式和抓包分析 分组格式： ()为字节数mac头：以太网目的地址(6) mac源地址(6) 帧类型(2)(0x0806)28byte arp帧：硬件类型(2)|协议类型(2)|硬件地址长度(1)|协议地址长度(1)|op(请求或应答或rarp 2)|发送端mac地址(6)|发送端ip(4)|接收端mac地址(6)|接收端ip(4) 请求广播帧：目的mac地址为全1，电缆上所有的以太网接口都要接收广播帧,硬件类型为1表示以太网地址，协议类型为要映射的协议地址类型0x0800,表示为ip地址，op（arp请求为1，答应为2，rarp请求为3，rarp答应为4） arp填充：以太网帧最小值为60，mac头14，所以=46，要填充：46-28=18个字节 arp抓包，可以用wireshark,Omnipeek - Savvius,tcpdump,或者自己写一个程序来抓～tcpdump : sudo tcpdump -vv arp 12345 tcpdump: listening on wlp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes21:51:21.134575 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.101 tell 192.168.0.1, length 28 //ap ask me21:51:21.135404 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.110 tell 192.168.0.1, length 2821:51:21.135413 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.0.110 is-at 48:5a:b6:6e:c9:5f (oui Unknown), length 28// i reply ap21:51:32.081916 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.106 tell 192.168.0.1, length 28 //ask other 123456722:01:27.149947 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.107 tell 192.168.0.1, length 28 0x0000: 0001 0800 0604 0001 206b e70f 1b42 c0a8 .........k...B.. 0x0010: 0001 0000 0000 0000 c0a8 006b ...........k 22:04:17.114593 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.0.110 is-at 48:5a:b6:6e:c9:5f (oui Unknown), length 28 0x0000: 0001 0800 0604 0002 485a b66e c95f c0a8 ........HZ.n._.. 0x0010: 006e 206b e70f 1b42 c0a8 0001 .n.k...B.... ARP协议的常用命令和调试分析 查看ARP缓存：即现在保存的arp映射表: 12345arp -a? (192.168.0.101) at 4c:32:75:3a:09:b3 [ether] on wlp2s0? (192.168.0.1) at 20:6b:e7:0f:1b:42 [ether] on wlp2s0? (192.168.0.108) at 94:d0:29:9d:74:dd [ether] on wlp2s0? (192.168.0.107) at 94:65:2d:ab:88:8b [ether] on wlp2s0 1234arp Address HWtype HWaddress Flags Mask Iface192.168.0.101 ether 4c:32:75:3a:09:b3 C wlp2s0192.168.0.1 ether 20:6b:e7:0f:1b:42 C wlp2s0 123456ip neigh192.168.0.101 dev wlp2s0 lladdr 4c:32:75:3a:09:b3 STALE192.168.0.1 dev wlp2s0 lladdr 20:6b:e7:0f:1b:42 STALE192.168.0.108 dev wlp2s0 lladdr 94:d0:29:9d:74:dd STALE192.168.0.107 dev wlp2s0 lladdr 94:65:2d:ab:88:8b STALE192.168.0.104 dev wlp2s0 lladdr e4:9a:dc:b0:a5:36 STALE arping命令：http://man.linuxde.net/arping arp 命令man arp 包括删除arp表项等，有问题，找男人~ARP协议内核状态机 对不存在的主机，arp请求的超时机制 arp缓存和老化时间：http://www.jb51.net/LINUXjishu/65693.html：改变老化时间：在Linux上如果你想设置你的ARP缓存老化时间，那么执行sysctl -w net.ipv4.neigh.ethX=Y即ARP协议的编程 在PF_PACKET中发出ARP包 直接贴例子，具体可以看博客的PF_PACKET文章：123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;linux/if.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;linux/if_ether.h&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230//获取硬件网卡的相应信息void GetEthInfor(char *name , char *MAC_addr , struct in_addr * IP_addr);//arp包的结构定义struct ARP_PACKET&#123; //以太网首部 unsigned char dest_mac[6]; //6字节 unsigned char sorce_mac[6];//6字节 unsigned short type; //2字节 //arp——内容 unsigned short hw_type; //2字节：硬件地址类型 0x0001 表示mac地址 unsigned short pro_type; //2字节：软件地址类型 0x0806 表示IPV4地址 unsigned char hw_len; //1字节：硬件地址长度 unsigned char pro_len; //1字节：软件地址长度 unsigned short op; //2字节：操作类型 0x0001表示ARP请求；0x0002表示ARP应答 unsigned char from_mac[6];//6字节 unsigned char from_ip[4]; //4字节 unsigned char to_mac[6]; //6字节 unsigned char to_ip[4]; //4字节 unsigned char padding[18];//18字节：填充字节，因为以太网数据最少要46字节&#125;;//主函数int main()&#123; int i = 0; int fd = 0; int num=0; unsigned char MAC_ADDR[6]; struct in_addr IP_ADDR;//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址. struct ARP_PACKET arp_pk=&#123;0&#125;; struct sockaddr_ll eth_info;//结构体的定义//在/linux/if_packet.h中， 表示设备无关的物理层地址结构 //第一步：获取指定网卡的信息（MAC地址和IP地址） GetEthInfor("wlp2s0",MAC_ADDR,&amp;IP_ADDR); /*printf("The MAC_addr is:"); for(i =0 ;i&lt;6;i++) printf("%4X",MAC_ADDR[i]); printf("\n"); printf("the IP is:%s\n",inet_ntoa(IP_ADDR));*/ //第二步：填充ARP数据包的内容 for(i=0;i&lt;6;i++) //填充以太网首部的目的mac地址 &#123; arp_pk.dest_mac[i]=0XFF; &#125; for(i=0;i&lt;6;i++) //填充以太网首部的源mac地址 &#123; arp_pk.sorce_mac[i]=MAC_ADDR[i]; &#125; arp_pk.type = htons(0x0806); //填充以太网首部的侦类型 arp_pk.hw_type = htons(0x0001); //填充硬件地址类型：0x0001表示的是MAC地址 arp_pk.pro_type = htons(0x0800);//填充协议地址类型：0x0800表示的是IP地址 arp_pk.hw_len = 6; //填充硬件地址长度 arp_pk.pro_len = 4; //填充协议地址长度 arp_pk.op = htons(0x0001); //填充操作类型：0x0001表示ARP请求 for(i=0;i&lt;6;i++) //填充源mac地址 &#123; arp_pk.from_mac[i]=MAC_ADDR[i]; &#125; in_addr_t ipaddr=inet_network(inet_ntoa(IP_ADDR)); for(i=3;i&gt;=0;i--) //填充源IP地址 &#123; arp_pk.from_ip[i]=(unsigned char)ipaddr&amp;0xFF; ipaddr=ipaddr&gt;&gt;8; printf("-%d-",arp_pk.from_ip[i]); &#125; /* arp_pk.from_ip[0]=192; arp_pk.from_ip[1]=168; arp_pk.from_ip[2]=199; arp_pk.from_ip[3]=145;*/ for(i=0;i&lt;6;i++) //填充欲获取的目的mac地址 &#123; arp_pk.to_mac[i]=0X00; &#125; arp_pk.to_ip[0]=0X0B; //填充想要装换为MAC地址的IP地址。可以使用命令行参数来做 arp_pk.to_ip[1]=0X40; arp_pk.to_ip[2]=0X39; arp_pk.to_ip[3]=0X0A; //第三步：填充sockaddr_ll eth_info结构 eth_info.sll_family = PF_PACKET; eth_info.sll_ifindex = if_nametoindex("wlp2s0");//返回输入的接口名称的索引值 //printf("number is:%d\n",eth_info.sll_family); //第四步：创建原始套接字 fd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL)); // if(fd&lt;0) &#123; printf("socket SOCK_RAW failed!\n"); exit(1); &#125; //第五步：发送ARP数据包 num = sendto(fd , &amp;arp_pk , sizeof(struct ARP_PACKET) , 0 ,(struct sockaddr*)(&amp;eth_info),sizeof(eth_info)); if(num&lt;0) &#123; printf("sendto failed!\n"); exit(1); &#125; //第六步：接受ARP应答 num = recvfrom(fd , &amp;arp_pk , sizeof(struct ARP_PACKET) ,0,NULL,0); if(num&lt;0) &#123; printf("rcvfrom failed!\n"); exit(1); &#125; else &#123; printf("I receive %d bytes!\n",num); printf("the mac is:"); for(i=0;i&lt;6;i++) &#123; printf("%4X ",arp_pk.from_mac[i]); &#125; printf("op:%d\n",arp_pk.op); for(i=0;i&lt;4;i++) &#123; printf("%d. ",arp_pk.to_ip[i]); &#125; printf("\n"); &#125; close(fd); return 0;&#125;void GetEthInfor(char *name , char *MAC_addr , struct in_addr * IP_addr)&#123; struct ifreq eth; //够结构用于存放最初多获取的接口信息//该结构存放在：/net/if.h,详细字段表示在头文件中 int fd; //用于创建套接字 int temp=0; //用于验证接口调用 int i=0; //用于循环 strncpy(eth.ifr_name,name,sizeof(struct ifreq)-1);// fd = socket(AF_INET,SOCK_DGRAM,0); // fd=socket(AF_INET,SOCK_STREAM,0); fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));if(fd&lt;0) &#123; printf("socket failed!\n"); exit(1); &#125; //获取并且保存和打印指定的物理接口MAC地址信息 temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth); if(temp&lt;0) &#123; printf("ioctl--get hardware addr failed!\n"); exit(1); &#125; strncpy(MAC_addr,eth.ifr_hwaddr.sa_data,6); printf("The MAC_addr is:"); for(i =0 ;i&lt;6;i++) printf("%4X",(unsigned char)eth.ifr_hwaddr.sa_data[i]); printf("\n"); //获取并且保存和打印指定的物理接口IP地址信息 temp = ioctl(fd,SIOCGIFADDR,&amp;eth); if(temp&lt;0) &#123; printf("ioctl--get hardware addr failed!\n"); exit(1); &#125; memcpy(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),4); //关闭套接口 printf("got ipaddr:%s\n",inet_ntoa(*IP_addr));/*i=0;printf("get the MAC_ADDR:\n");for(i;i&lt;6;i++) printf("%.2X:",MAC_addr[i]&amp;0xFF);*/ close(fd);&#125;//第二步填充arp数据包的时候，填充的数据和类型根据需要进行。//这里的arp数据包结构体是自己定义的，也可以是利用linux的相关结构：/*eg:typedef struct _tagARP_PACKET&#123; struct ether_header eh; ///net/ethernet.h struct ether_arp arp; &#125;ARP_PACKET_OBJ, *ARP_PACKET_HANDLE; /netinet/if_ether.h;/net/if_arp.h各个字段的填充见头文件*//*第三步：填充sockaddr_ll eth_info结构,关键是填充网络接口索引值，最直接的方法是上面的函数，还有另外的方法:利用ioctl函数获取struct ifreq结构的信息，该结构放置了很多网络接口的相关信息*//* struct sockaddr_ll&#123; unsigned short sll_family; //总是 AF_PACKET unsigned short sll_protocol; // 物理层的协议 int sll_ifindex; //接口号 unsigned short sll_hatype; // 报头类型 unsigned char sll_pkttype; // 分组类型 unsigned char sll_halen; // 地址长度 unsigned char sll_addr[8]; // 物理层地址 &#125;;eg:* struct sockaddr_ll peer_addr; * memset(&amp;peer_addr, 0, sizeof(peer_addr)); peer_addr.sll_family = AF_PACKET; struct ifreq req; bzero(&amp;req, sizeof(struct ifreq)); strcpy(req.ifr_name, "eth0"); if(ioctl(sockfd, SIOCGIFINDEX, &amp;req) != 0) perror("ioctl()"); peer_addr.sll_ifindex = req.ifr_ifindex; peer_addr.sll_protocol = htons(ETH_P_ARP); *//*第四步，创建套结字的时候，有以下的组合：更多见：man packet * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux. * 第二个参数： 2）套接字类型： SOCK_DGRAM----以太网头已经构造好了 SOCK_RAW------自己构造以太头 * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字 * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr）， * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部， * 而发送时也无须用户添加头部字段。 第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型： 1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806) 和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100) 2)IEEE维护的注册以太网类型列表 3）半官方的列表由IANA维护 ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。 0x88b5和0x88b6是保留以太网类型，供实验或私人使用。 */ /*第五步发送和接收套接字的函数可以是read write操作套结字，也可以是上文的UDP无连接用的函数*/ 处理的时候可能需要获取网关的ip地址：1234567891011121314151617181920212223242526272829303132333435363738/*proc方法获取网关地址*/void GetGateWayIP(uint8 *ip_addr)&#123; char inf[100]; FILE *file_fd; uint8 high=0,low=0,value; int i; file_fd = fopen("/proc/net/route","r"); if(file_fd==NULL) &#123; printf("can not open /proc/net/route\n"); &#125; else &#123; while(!feof(file_fd)) &#123; memset(inf,0,sizeof(inf)); fgets(inf,100,file_fd); if(inf[5]=='0'&amp;&amp;inf[6]=='0'&amp;&amp;inf[7]=='0'&amp;&amp;inf[8]=='0'&amp;&amp;inf[9]=='0'&amp;&amp;inf[10]=='0'&amp;&amp;inf[11]=='0'&amp;&amp;inf[12]=='0') &#123; for(i=20;i&gt;=14;i-=2) &#123; if(inf[i]&gt;=65) high = inf[i]-55; else high = inf[i]-48; if(inf[i+1]&gt;=65) low = inf[i+1]-55; else low = inf[i+1]-48; value = high*16+low; ip_addr[10-i/2] = value; &#125; break; &#125; &#125; &#125;&#125; ARP攻击 ARP包可以直接发送给对端不经过路由器，有趣在一个局域网中，客户端的几乎所有的包都是发往路由器的，这归结于默认路由设置，而在无线网，网卡其实可以接收所有数据，毕竟空气介质，所以，局域网中的设备可以直接通信实验：在文件全能王中开启wifi文件传输，和它在同一个局域网的sta能访问该地址，抓包，发现目的地址和源地址都为同一个局域网的不同ip,且不为路由器网关ip，证明其两个设备是可以直接通信的 再来做一个实验：通过pf_packet1、在电脑A上写一个程序，mac目的地址为B,源地址为A,协议类型随机，数据随意，发送给B 同时在B端进行接收，过滤掉其他mac地址，看是否可以接收到，在连接ap和不连接ap的条件下2、在A和B设置静态ip地址，且不同网段，都不连接AP ,让A向B 发送ARP请求包，B接收到后回复arp响应包，接着做ping或其他操作，看是否能互相通信 编程可以参考上述程序，改一下地址什么的就可以，或者参考其他：http://www.freebuf.com/articles/system/5157.html这篇文章讲的很具体，个人也喜欢这个网站，emm,实验过了，还可以，can also make your own program,具体程序不贴了 arp欺骗的基本原理：在局域网中，设备A,B连接同一个路由器，他们之间可以直接相互通信，因此可以直接向对方发送arp包；设备A ,B都会定期和AP交互arp请求和回复，相互知道对方的mac地址，这样，就能给ap发送请求，ap也能知道回复给谁；arp欺骗的基本原理在于，如B是攻击方，则B向A发送ARP回复自己是AP ,即在ARP回复包中带上自己的mac地址，ap的ip地址；同时向AP回复自己是A，即带上A的ip地址，自己的mac地址；这样A就会以为B是AP，就会把请求发给B ,同时AP以为B是A，会把回复传给B,但是同时得配置B的转发功能，echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot该博文中有一处错误，见评论]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_PF_PACKET]]></title>
    <url>%2F2018%2F05%2F27%2Ftcpip-PF-PACKET%2F</url>
    <content type="text"><![CDATA[PF_PACKET的使用：PF_PACKET简介：是linux下的用于发送和接收二层(mac层)的套接字： PF_PACKET基本使用： 基本的几个操作： 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;linux/if.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;linux/if_ether.h&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//获取硬件网卡的相应信息void GetEthInfor(char *name , char *MAC_addr , struct in_addr * IP_addr)//传入接口名，取回mac和ip&#123; struct ifreq eth; //结构用于存放最初获取的接口信息 //该结构存放在：/net/if.h,详细字段表示在头文件中 int fd; //用于创建套接字 int temp=0; //用于验证接口调用 int i=0; //用于循环 strncpy(eth.ifr_name,name,sizeof(struct ifreq)-1); // fd = socket(AF_INET,SOCK_DGRAM,0); // fd=socket(AF_INET,SOCK_STREAM,0); fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL)); if(fd&lt;0) &#123; printf("socket failed!\n"); exit(1); &#125; //获取并且保存和打印指定的物理接口MAC地址信息 temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth); if(temp&lt;0) &#123; printf("ioctl--get hardware addr failed!\n"); exit(1); &#125; strncpy(MAC_addr,eth.ifr_hwaddr.sa_data,6); printf("The MAC_addr is:"); for(i =0 ;i&lt;6;i++) printf("%4X",(unsigned char)eth.ifr_hwaddr.sa_data[i]); printf("\n"); //获取并且保存和打印指定的物理接口IP地址信息 temp = ioctl(fd,SIOCGIFADDR,&amp;eth); if(temp&lt;0) &#123; printf("ioctl--get hardware addr failed!\n"); exit(1); &#125; memcpy(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),4); //关闭套接口 printf("got ipaddr:%s\n",inet_ntoa(*IP_addr)); close(fd);&#125;//取得网络接口的索引：int值,传入fd和接口名int Get_IfaceIndex(int fd, const char* interfaceName)&#123;struct ifreq ifr;if (interfaceName == NULL)&#123; return -1;&#125;memset(&amp;ifr, 0, sizeof(ifr));strcpy(ifr.ifr_name, interfaceName);if (ioctl(fd, SIOCGIFINDEX, &amp;ifr) == -1)&#123; printf("RED ioctl error\n"); return -1;&#125;return ifr.ifr_ifindex;&#125;int set_Iface_promisc(int fd, int dev_id)//传入fd和index&#123;struct packet_mreq mr;memset(&amp;mr,0,sizeof(mr));mr.mr_ifindex = dev_id;mr.mr_type = PACKET_MR_PROMISC;if(setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&amp;mr,sizeof(mr))==-1)//退出混杂模式使用这个：PACKET_DROP_MEMBERSHIP&#123; fprintf(stderr,"GREEN set promisc failed! \n"); return -1;&#125;return 0;&#125; 使用123456789101112int main ()&#123; unsigned char MAC_ADDR[6]; struct in_addr IP_ADDR;//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址. //第一步：获取指定网卡的信息（MAC地址和IP地址） GetEthInfor("wlp2s0",MAC_ADDR,&amp;IP_ADDR); int fd; fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP)); int index=Get_IfaceIndex(fd,"enp1s0"); printf("index:%d\n",index); return 0; &#125; PF_PACKET的接收：简单说明：创建套结字的时候，有以下的组合：更多见：man packet 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux. 第二个参数： 套接字类型：SOCK_DGRAM----以太网头已经构造好了 SOCK_RAW------自己构造以太头 * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字 * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr）， * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部， * 而发送时也无须用户添加头部字段。 第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)2) IEEE维护的注册以太网类型列表3）半官方的列表由IANA维护 ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。 0x88b5和0x88b6是保留以太网类型，供实验或私人使用。(若指定socket_type为SOCK_RAW则意味着原始数据包包含了链路层头部，若指定为SOCK_DGRAM则将做一些处理以剥掉链路层头部。链路层头部信息的通用格式是一个sockaddr_ll结构。protocol填入网络字节序的IEEE 802.3协议号。参见&lt;linux/if_ether.h&gt;头文件了解允许的协议。如果protocol被设置为htons(ETH_P_ALL)，则意味着接受所有协议。所有接入的协议类型为protocol的数据包将在传递给内核之前传递到PACKET套接字。) 收包可以使用的接口：123int readnum = recvfrom(rawsock, buffer,2048,0, (struct sockaddr*)(&amp;eth_info),&amp;leneth_info);int readnum = read(rawsock, buffer,2048);int readnum = recvfrom(rawsock, buffer,2048,0, NULL,NULL); 一个简单的接收包的例子：12345678910111213141516#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/if_ether.h&gt;#include &lt;linux/in.h&gt;#include &lt;stdlib.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;linux/if.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;linux/if_ether.h&gt;#define BUFFER_MAX 2048 1234567891011121314int main(int argc, char *argv[])&#123; if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; 0) &#123; printf("error: create raw socket!!!\n"); exit(0); &#125; while(1) &#123; int readnum = read(rawsock, buffer,2048);// can read packet //printf("recv buffer:%s\n",buffer); &#125; return 0; &#125; 指定从某个接口接收数据：12345678910111213141516171819202122int main(int argc, char *argv[])&#123; struct sockaddr_ll eth_info;//结构体的定义在/linux/if_packet.h中， 表示设备无关的物理层地址结构 eth_info.sll_family = PF_PACKET; //PF_PACKET定义在sys/types.h中 eth_info.sll_ifindex = if_nametoindex("lo");//返回输入的接口名称的索引值 //次函数定义在net/if.h中 if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; 0) &#123; printf("error: create raw socket!!!\n"); exit(0); &#125; if(bind(rawsock,(struct sockaddr *)(&amp;eth_info),sizeof(eth_info))==-1)//绑定接口，从而只接收那个接口上的数据&#123; printf("error: bind!!\n"); exit(0);&#125; while(1) &#123; int readnum = read(rawsock, buffer,2048);// can read packet //printf("recv buffer:%s\n",buffer); &#125; return 0; &#125; 接收后的包如何读取：以包括mac头的形式来看：粗暴的形式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798int main(int argc, char *argv[])&#123; int rawsock; char buffer[BUFFER_MAX]; char *ethhead; char *iphead; char *tcphead; char *udphead; char *icmphead; char *pHead; if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; 0) &#123; printf("error: create raw socket!!!\n"); exit(0); &#125; while(1) &#123; int readnum = read(rawsock, buffer,2048);// can read packet //printf("recv buffer:%s\n",buffer); if(readnum &lt; 42) &#123; printf("error: Header is incomplete!!!\n"); continue; &#125; // for(j;j&lt;readnum;j++) // printf("%.2X:",buffer[j]&amp;0xFF); ethhead = (char *)buffer; pHead = ethhead; int ethernetmask = 0XFF; framecount++; printf("------------------Analysis Packet [%d]---------------------\n",framecount); // printf("all:-----%s\n",ethhead); printf("MAC:"); int i = 6; for(; i &lt;=11; i++) &#123; printf("%.2X:",pHead[i]&amp;ethernetmask); &#125; printf("----&gt;"); for(i = 0; i &lt;=5; i++) &#123; printf("%.2X:",pHead[i]&amp;ethernetmask); &#125; printf("\n"); printf("proto: %.2x:",pHead[12]&amp;ethernetmask); printf("proto2: %.2x:\n",pHead[13]&amp;ethernetmask); iphead = ethhead + 14; pHead = iphead + 14; printf("IP:"); for(i = 0; i &lt;=3; i++) &#123; printf("%d",pHead[i]&amp;ethernetmask); if(i != 3) printf("."); &#125; printf("----&gt;"); for(i = 10; i &lt;=13; i++) &#123; printf("%d",pHead[i]&amp;ethernetmask); if(i != 13) printf("."); &#125; printf("\n"); int prototype = (iphead + 9)[0]; // printf("Protocol: %.2X:",prototype); //int prototype = (iphead + 9)[0]; pHead = iphead + 20; printf("Protocol: "); switch(prototype) &#123; case IPPROTO_ICMP: printf("ICMP\n"); break; case IPPROTO_IGMP: printf("IGMP\n"); break; case IPPROTO_IPIP: printf("IP\n"); break; case IPPROTO_TCP : printf("TCP | source port: %u | ",(pHead[0]&lt;&lt;8)&amp;0XFF00 | pHead[1]&amp;0XFF); printf("dest port: %u\n", (pHead[2]&lt;&lt;8)&amp;0XFF00 | pHead[3]&amp;0XFF); break; case IPPROTO_UDP : printf("UDP | source port: %u | ",(pHead[0]&lt;&lt;8)&amp;0XFF00 | pHead[1]&amp;0XFF); printf("dest port: %u\n", (pHead[2]&lt;&lt;8)&amp;0XFF00 | pHead[3]&amp;0XFF); break; case IPPROTO_RAW : printf("RAW\n"); break; default: printf("Unkown\n"); &#125; printf("-------------------------end-----------------------\n"); &#125; return 0; &#125; 收包处理的方式，也可以把指针赋给内核的结构：struct iphdr如：12struct iphdr ip;ip = (struct iphdr *)(buffer + sizeof(struct ethhdr)); 内核提供了很多的包结构，在发包或者收包的时候可以直接使用这些结构解析或者粗暴的用字符串解析 PF_PACKET发送包： 发包和接收包类似： 1234567num = sendto(rawsock, buffer,2048 , 0 ,(struct sockaddr*)(&amp;eth_info),sizeof(eth_info)); if(num&lt;0) &#123; printf("sendto failed!\n"); exit(1); &#125; printf("success:%d\n",num);]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>PF_PACKET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DS_linklist]]></title>
    <url>%2F2018%2F05%2F26%2FDS-linklist%2F</url>
    <content type="text"><![CDATA[数据结构之线性表：有序表：数组：单链表：链表定义 { 数据成员:常见的基本类型或者对象类型均可 数据关系:在链表中的块的成员在连续的内存中，块与块之间内存位置不连续 指向块的指针：单链表只有一个next,双链表加上pre }基本运算：{ InitList(&amp;L);:初始化链表，在c/c++中需要做分配内存，初始化链表头和其值的操作； DestroyList(&amp;L); 在销毁时需要free内存 Length(L);链表的长度是块的个数 GetElem(L,i,&amp;e); 在链表中取元素需要一个一个遍历直到下标值，若为双链表会快些。所以这里取索引值对应的值和取链表的值，效率几乎一样； LocateElem(L,e,compare()); 和链表中的元素做对比 InsertElem(&amp;L,i,e); 在链表中插入元素，复杂度O(1),在提供位置的时候，若不提供位置，还需要加搜索的时间 DeleteElem(&amp;L,i,&amp;e); 在链表中删除元素，复杂度O(1)…… }eg:1234567891011typedef struct LNode &#123; ElemType data；//数据域 struct LNode *next； //指针域&#125; LNode, *LinkList;LNode *L;LinkList L;L = (LinkList) malloc( sizeof (LNode) );或 L = new LNode;L-&gt;data;LNode L;L.date 链表的两种头部： 没有头的链表：第一个块就开始存储数据 任何时候都有头的链表： 第一个块不存储数据，作为头节点，第二个块开始存数据 应用：在leetcode中的ReverseLinklist中，当反转的是从1开始的时候，若使用的是没有头的，则需要额外判断处理，否则可以统一处理； 链表的几个常见操作： 取第i个元素： 123456789101112Status GetElem_L(LinkList L, int i, ElemType &amp;e)&#123;//查找操作 p = L-&gt;next; j = 1; while( p &amp;&amp; j &lt; i)&#123; p = p-&gt;next; ++j; &#125; if (!p || j&gt;i) return ERROR; e = p-&gt;data; return OK;&#125; 插入元素：在第i个位置上插入 1234567891011Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123; p = L; j = 0; while (p &amp;&amp; j &lt; i-1) &#123; p = p-&gt;next; ++j &#125; if (!p || j&gt;i-1) return ERROR; s = (LinkList) malloc( sizeof (LNode) ); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return OK; &#125; 删除元素:删除第i个元素: 1234567891011 Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e)&#123; p = L; j = 0; while (p-&gt;next &amp;&amp; j &lt; i-1) &#123; p = p-&gt;next; ++j &#125; if (!(p-&gt;next) || j&gt;i-1) return ERROR; q = p-&gt;next; e = q-&gt;data; p-&gt;next = p-&gt;next-&gt;next; //(p-&gt;next = q-&gt;next;) free(q); return OK;&#125; 链表的建立： 头插法： 1234567891011CreateList_L(LinkList &amp;L, int n)&#123; L = (LinkList) malloc( sizeof (LNode) ); L-&gt;next = NULL; for( i=n; i&gt;0; --i)&#123; s = (LinkList) malloc( sizeof (LNode) ); scanf( &amp;s-&gt;data); s-&gt;next = L-&gt;next; ① L-&gt;next = s; ② &#125;&#125; 尾插法： 12345678910CreateList_L(LinkList &amp;L, int n)&#123; tail = L = (LinkList) malloc( sizeof (LNode) ); L-&gt;next = NULL; for( i=n; i&gt;0; --i)&#123; s = (LinkList) malloc( sizeof (LNode) ); scanf( &amp;s-&gt;data); tail-&gt;next = s; ① tail = s; ② &#125; &#125; 链表的常见复杂操作： 两个有序链表的合并：123456789101112131415void MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)&#123; pa = La-&gt;next; pb = Lb-&gt;next; Lc = pc = La; while( pa &amp;&amp; pb )&#123; if(pa-&gt;data &lt;= pb-&gt;data)&#123; pc-&gt;next = pa; pc = pa; pa = pa-&gt;next; &#125; else&#123; pc-&gt;next = pb; pc = pb; pb= pb-&gt;next; &#125; &#125; pc-&gt;next = pa ? pa : pb; free( Lb );&#125; 一些特殊的链表： 单向循环链表： 图示： 多重循环链表： 双向链表：12345typedef struct DuLNode&#123; ElemType data; struct DuLNode *prior; struct DuLNode *next;&#125;DuLNode, *DuLinkList; 双向循环链表： 探讨： 链表作为最基础的数据结构，是对其他数据结构：如栈，树等的支撑，其他这些大部分是在链表的基础上建立的； 从较底层的层面：即深入到内存，链表实现了对零散内存的有效使用，内存在为链表分配空间的时候不用大段的连续空间； 从较高层，即抽象的层面看，链表仅仅是一批数据的拓扑结构之一，就常见的栈，队列，树，图等等，你还可以想出其他可能有用没用的，如，立体的结构，方块，金字塔形(emm这个像堆），还有随意的，感觉想到了矩阵里面的压缩。 应用： 链表的应用：如 在文件中，对大文件的存储，采用类似链表的结构， 大数相加，像两个100位的整数相加，使用链表，每个块为一位，就可以解决这个问题，数组也行 倒排索引结构，在操作系统中用到，我的github上放着一个本科毕业设计做的简单搜索引擎，几乎全是自己搞的（解析网页那块自己c写了状态机，觉得效果不如beatifulsoup好，后面用它了),不过想想那会还不会很有意识的去想如果让它运行在大量用户下，各种使用条件（如输入条件下，会怎么样，年轻啊~) 其他，当然是其他数据结构基于链表做的，多了去了]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[code_efficandreadable]]></title>
    <url>%2F2018%2F05%2F26%2Fcode-efficandreadable%2F</url>
    <content type="text"><![CDATA[论代码的效率和可读性的权衡高效代码可读性差：有一些代码，占用额外内存小，即run in place，且执行的速度快，即复杂度O()低，但是可读性差，即使注释了，修改起来也容易出错，如：对链表的操作：举一个leetcode的例子：(这个例子不是很典型，能说明问题即可） reverse a linklist from m to n; 1-&gt;3-&gt;4-&gt;5-&gt;null and m,n(ex:2,4); return 1-&gt;5-&gt;4-&gt;2-&gt;null; 上面例子一开始可以想到，头插法，或者将范围内的那一段用新的处理过的链表替换掉，即只需要处理该片段的头和尾部，当然可能还有其他方法，这里先不考虑； 于是，头插法不是很复杂，但是在这里不用额外的内存时，需要频繁的改变next指针和对pre元素做临时保存，使得代码可读性差，所以可以考虑以下方案： 在替换的内存小时，可以采用后者，让代码可读性高些，方便维护和（被替代~更容易被炒鱿鱼的风险哈哈) 在内存小时，采用前者，爱怎么指怎么指，看不懂不管哈哈哈]]></content>
      <categories>
        <category>代码整洁</category>
      </categories>
      <tags>
        <tag>代码可读性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_mtu]]></title>
    <url>%2F2018%2F05%2F20%2Ftcpip-mtu%2F</url>
    <content type="text"><![CDATA[MTU这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍： 理论部分：１、MTU(Maximum Transmission Unit)如何定义: 指的是通信协议中的某一层上面所能通过的最大数据包大小 这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？ 答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B&gt;1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:分片：ip净载荷：MTU-IP头：1500-20=1480; 3008B 需要分为3片，3008=1480,1480,48总结：MTU就是MAC承载的载荷的最大值 2、MTU会影响什么: 数据包太大-&gt;分片重组-&gt;网络性能变差 数据包太小-&gt;一次能传输的数据小-&gt;网速差 路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191) 3、如何知道这个值呢？路径最大传输单元发现方法(RFC1191) 越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。 MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：ping -c 3 -s 1474 -M do 192.168.0.1PING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.ping: local error: Message too long, mtu=1500提示错误即消息太大且未设置分片 4 MTU大小的来源:ref https://www.zhihu.com/question/31460305/answer/183766816以太网传输帧的最小值： 最早的以太网工作方式：载波多路复用/冲突检测（CSMA/D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。 假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。 为什么标准以太网帧长度上限为1518字节? IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。 由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 byte那有效传输效率= 160 / 218 = 73%而如果以太网长度为1518，那有效传输效率= 1460 / 1518 = 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题. 于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。 其他疑问： 最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？ 这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到&gt; 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。 有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度&gt;接口MTU，怎么办？丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。 所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？ 我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU = MRU，但比如9000侧的数据到达1500，由于9000 &gt; MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样实践部分：如何设置MTU：ifconfig eth0 mtu 1460如何查看mtu:netstat -i]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[cpp_debug_layout_static]]></title>
    <url>%2F2018%2F05%2F20%2Fcpp-debug-layout-static%2F</url>
    <content type="text"><![CDATA[c compile time memory layout 标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法： 概述：首先介绍几个概念： 程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候； 当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程； 注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码 。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句； 本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c 前言：一个源代码通过编译后生成一个目标文件.o它是一个elf relocatable文件,以下.o文件指此类，elf文件为executable文件.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到 other data ... .comment offset 0x000000c6. .rodata ... //const &amp; str 常量 .data .text .elf header 一个elf文件的结构是这样的：可以通过readelf来看： elfheader 文件头包含了平台信息：/usr/include/elf.h .text 段表 各个段：应用程序也可以自己定义段，和指定变量在哪个段 .data .bss .. other sections section header table string tables 重定位表和字符串表 symbol tables 符号表是链接的接口 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂 可以通过readelf -s xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突 强符号和弱符号（强引用和若引用），调试信息 －g 扩展： １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀； 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o objdump -ht image.o 可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们 具体看文档２）自定义段：attribute((section(“FOO”))) int global=24; attribute((section(“BAR”))) void foo(){} 既可以把变量或函数放入该段中 段名：BAR FOO 正文： 0、先从几个命令：1)size filename:查看elf或.o文件中各个段大小： text data bss dec hex filename 74 0 0 74 4a simplest.o 代码段 数据段 代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null 2)其他工具： readelf -a simplest.o 可以看到更清楚的段信息 objdump -t simplest objdump -h simplest.o 替代size可以看到更多信息 此时显示出来的一些地址并不是装载后的地址 objdump -s -d xx.o: -s 16进制，-d反汇编 －－－查看代码段objdump -s -x -d xx.o: –查看数据段和rodata 3)查看目标文件文件属性如relocatable –.o/executable –elf/share object –.so.. file xxx １、从最简单的程序开始：simplest.cint main() { return 0; } 将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件： # 1 &quot;simplest.c&quot; # 1 &quot;&lt;built-in&gt;&quot; # 1 &quot;&lt;command-line&gt;&quot; # 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4 # 1 &quot;&lt;command-line&gt;&quot; 2 # 1 &quot;simplest.c&quot; int main() { return 0; } 将它进行汇编：gcc -S simplest.c .file “simplest.c” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits 生成.o文件：gcc -c simplest.c并通过file xx.o查看类型simplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped 通过size 查看各个段：size simplest.o: 可以看到只有代码段，数据为空，bss为空，是比较纯净的 text data bss dec hex filename 67 0 0 67 43 simplest.o 接着编译成elf:gcc -o simplest simplest.cfile simplestsimplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped可以看到连接器等信息 size simplest text data bss dec hex filename 1099 544 8 1651 673 simplest注意这里的和.o的文件大小和分段不同， ２、加入头文件和局部变量#include&lt;stdio.h&gt; int main() { int locala; int localb=3; return 0; } 进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数汇编，可以看到分配３到内存中 .file “simplest.c” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits 生成.o文件：可以看到未改变data和bss,但是代码段变大 text data bss dec hex filename 74 0 0 74 4a simplest.o 生成elf:数据区和bss未改变，代码段也未改变？ text data bss dec hex filename 1099 544 8 1651 673 simplest ３、加入已经初始化的局部静态变量：int main() { static int statica=3; .. } 看生成的汇编： .file “simplest.c” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .data .align 4 .type statica.2285, @object //新加的段 .size statica.2285, 4 statica.2285: .long 3 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits .o大小：在静态数据区增加了，４ １个int的长度 text data bss dec hex filename 74 4 0 78 4e simplest.o elf:有点费解，。。 text data bss dec hex filename 1099 548 4 1651 673 simplest ４、加入已经初始化的全局变量和全局静态变量int golbala=6; static long gs=12; 生成的汇编 .file “simplest.c” .globl golbala .data .align 4 .type golbala, @object .size golbala, 4 golbala://变量名 .long 6 .align 8 .type gs, @object .size gs, 8 gs://变量名 .quad 12 .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .data .align 4 .type statica.2287, @object .size statica.2287, 4 statica.2287: .long 3 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits size : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4=20 text data bss dec hex filename 74 20 0 94 5e simplest.o elf size:548–&gt;564 16 text data bss dec hex filename 1099 564 4 1667 683 simplest 5 将 int golbala=6; static long gs=12; 倒换位置！！！！！！！！！ 则对齐成：size x.o为：１６比原来小，可以用于节省内存： text data bss dec hex filename 74 16 0 90 5a simplest.o 汇编： .file “simplest.c” .data .align 8 .type gs, @object .size gs, 8gs: .quad 12 .globl golbala .align 4 .type golbala, @object .size golbala, 4golbala: .long 6 .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE0: .size main, .-main .data .align 4 .type statica.2287, @object .size statica.2287, 4statica.2287: .long 3 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbitself文件的也变小：但bss变大，费解。。 text data bss dec hex filename 1099 560 8 1667 683 simplest 6、加入未初始化的全局变量和全局与局部静态变量 1 #include&lt;stdio.h&gt; 2 static long gs=12; 3 int golbala=6; 4 5 6 static long gsl; 7 int gi; 8 int main() 9 { 10 static int staticn; 11 static int statica=3; 12 int locala; 13 int localb=3; 14 return 0; 15 } 汇编没有看到什么变化： .file “simplest.c” .data .align 8 .type gs, @object .size gs, 8gs: .quad 12 .globl golbala .align 4 .type golbala, @object .size golbala, 4golbala: .long 6 .local gsl .comm gsl,8,8 .comm gi,4,4 .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE0: .size main, .-main .data .align 4 .type statica.2290, @object .size statica.2290, 4statica.2290: .long 3 .local staticn.2289 .comm staticn.2289,4,4 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits .o文件：+12 未包含未初始化的全局变量text data bss dec hex filename 74 16 12 102 66 simplest.o elf:+16 未包含未初始化的全局变量text data bss dec hex filename 1099 560 24 1683 693 simplest 至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同 参考：程序员的自我修养]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_debug_layout_dynamic]]></title>
    <url>%2F2018%2F05%2F20%2Fcpp-debug-layout-dynamic%2F</url>
    <content type="text"><![CDATA[c执行期内存布局和调试：在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等１、将目标文件装入: １）重定位－－－ 放在内存哪里 2) 等待调度执行这里可以使用gdb进行调试查看 一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).一个进程主要包括： 在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等 栈区 高地址到低地址堆区 低地址到高地址bss数据代码 以下将从两个维度进行对一个程序被执行成进程时，内存的情况： １、各种段区的内存分布 ２、gdb 调试程序执行时的过程。－－可能涉及到汇编 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 1、gdb 常用的命令和用法：1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令 2)设置断点： b 行号b 函数名b 行号 if 条件eg:break main / b main 删除断点:delete 行号 3)列出代码l /list 4)运行，start 跳转到断点:c/continue r/run until 行号 运行直到该行5)观察变量b和地址watch b 若变量值发生变化，则程序停止 p/print b 看变量值 p/print &amp;b 看变量地址 i locals info registers 显示所有寄存器的值 查看特定内存位置的值如： print/x $eax 显示为16进制 print/t 2进制， print/d 十进制,x/nyz : n表示字段数，y为输出格式，z是字段长度 ６）单步调试 n/next / s/step 7) 保存断点： info b 查看断点信息 save breakpoint fig.dp 保存断点 读取断点文件： gdb hello -x fig.dp 退出quit http://bbs.chinaunix.net/thread-150524-1-1.html 2 使用kdbg 界面版本gdb 在gcc … -g后，用kdbg打开即可、 查看程序运行时各个地址： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;sys/types.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#define SHW_ADR(ID,I) printf("the id %s \t is at adr:%8X\n",ID,&amp;I);extern etext,edata,end;char *cptr="Hello World\n";char buffer1[25];int main(void)&#123; void showit(char *); int i=0; printf("Adr etext:%8x\tAdr edata:%8x \t Adr end :%8x \n\n",&amp;etext,&amp;edata,&amp;end); SHW_ADR("main",main); SHW_ADR("showit",showit); SHW_ADR("cptr",cptr); SHW_ADR("buffer1",buffer1); SHW_ADR("i",i); strcpy(buffer1,"A demonstration\n"); write(1,buffer1,strlen(buffer1)+1); for(;i&lt;1;++i) showit(cptr); return 0;&#125;void showit(char *p)&#123; char *buffer2; SHW_ADR("buffer2",buffer2); if((buffer2=(char *)malloc((unsigned)(strlen(p)+1)))!=NULL) &#123; strcpy(buffer2,p); printf("%s",buffer2); free(buffer2); &#125; else &#123; printf("Allocation error.\n"); exit(1); &#125;&#125; －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;unistd.h&gt;#include &lt;alloca.h&gt;extern void afunc(void);extern etext,edata,end;int bss_var; //no init globel data must be in bssint data_var=42; //init globel data must be in data#define SHW_ADR(ID,I) printf("the %8s\t is at adr:%8x\n",ID,&amp;I); //the macro to printf the addrint main(int argc,char *argv[])&#123; char *p,*b,*nb; printf("Adr etext:%8x\t Adr edata %8x\t Adr end %8x\t\n",&amp;etext,&amp;edata,&amp;end); printf("\ntext Location:\n"); SHW_ADR("main",main); //text section function SHW_ADR("afunc",afunc); //text section function printf("\nbss Location:\n"); SHW_ADR("bss_var",bss_var); //bss section var printf("\ndata location:\n"); SHW_ADR("data_var",data_var); //data section var printf("\nStack Locations:\n"); afunc(); p=(char *)alloca(32); //alloc memory from statck if(p!=NULL) &#123; SHW_ADR("start",p); SHW_ADR("end",p+31); &#125; b=(char *)malloc(32*sizeof(char)); //malloc memory from heap nb=(char *)malloc(16*sizeof(char)); printf("\nHeap Locations:\n"); printf("the Heap start: %p\n",b); printf("the Heap end:%p\n",(nb+16*sizeof(char))); printf("\nb and nb in Stack\n"); SHW_ADR("b",b); SHW_ADR("nb",nb); free(b); free(nb);&#125;void afunc(void)&#123; static int long level=0; //data section static var int stack_var; //temp var ,in stack section if(++level==5) &#123; return; &#125; SHW_ADR("stack_var in stack section",stack_var); SHW_ADR("Level in data section",level); afunc();&#125;]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_jni]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-jni%2F</url>
    <content type="text"><![CDATA[a example of JNI static way:first step: write a middle java file:mkdir jnicd jni/vim TestJni.java import java.util.*; public class TestJni { public native void xprint(String content); static { System.loadLibrary(&quot;TestJni&quot;); } } javac TestJni.java and make a class then javah -jni TestJni to make a .h file: /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class TestJni */ #ifndef _Included_TestJni #define _Included_TestJni #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: TestJni * Method: xprint * Signature: (Ljava/lang/String;)V */ JNIEXPORT void JNICALL Java_TestJni_xprint (JNIEnv *, jobject, jstring); #ifdef __cplusplus } #endif #endif step two write jni file.c:TestJni.c: #include&lt;jni.h&gt; #include&lt;stdio.h&gt; #include &quot;TestJni.h&quot; JNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content) { const jbyte *str=(const jbyte*)(*env)-&gt;GetStringUTFChars(env,content,JNI_FALSE); printf(&quot;hello--wo%s \n&quot;,str); (*env)-&gt;ReleaseStringUTFChars(env,content,(const char*)str); return; } three build .so libcc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c four write a test:hellow.javaimport java.util.*; public class hellow { public static void main(String argc[]) { new hellow(); } public hellow() { new TestJni().xprint(&quot;hi my name is keee&quot;); } } question:如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径： java -Djava.library.path=’.’ HelloWorld或者输入命令：export LD_LIBRARY_PATH=“HelloWorld路径”:$LD_LIBRARY_PATH 设置环境变量 然后再 java HelloWorld 一样OK referencehttp://www.cnblogs.com/bastard/archive/2012/05/17/2506877.htmlhttp://www.cnblogs.com/wzben/p/5733571.html a example of JNI dynamic way:step 1:write a TestJni.java public class SimpleJni{ static { System.out.println(&quot;[java] static code block,start load shared library...&quot;); System.loadLibrary(&quot;SimpleJni&quot;); System.out.println(&quot;[java]load library end...&quot;); } static native int add(int a,int b); public static void main(String args[]) { System.out.println(&quot;[java] in main...&quot;); System.out.println(&quot;[java] 3+4=&quot;+SimpleJni.add(3,4)); System.out.println(&quot;end...&quot;); } } step 2:write a Jni file: #include &lt;jni.h&gt; #include&lt;stdio.h&gt; const char *classPathName=&quot;com/bt/jni/SimpleJni&quot;; jint myadd(JNIEnv *env,jobject thiz,jint a,jint b) { return a+b; } static JNINativeMethod methods[]={ {&quot;add&quot;,&quot;(II)I&quot;,(void*)myadd},}; int registerNatives(JNIEnv *env) { jclass clazz; clazz=(*env)-&gt;FindClass(env,classPathName); if(NULL==clazz){ printf(&quot;[C] FindClass fail\n&quot;); goto failed; } if (0&gt;(*env)-&gt;RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0]))){ printf(&quot;RegisterNatives fail.\n&quot;); goto failed; } return JNI_TRUE; failed: return JNI_FALSE; } jint JNI_OnLoad(JavaVM *vm,void *reserved) { JNIEnv *env=NULL; jint result=-1; void **env_p=NULL; printf(&quot;start register native func\n&quot;); env_p=(void**)&amp;env; if(JNI_OK!=(*vm)-&gt;GetEnv(vm,env_p,0x00010006)){ printf(&quot;get env failed..\n&quot;); goto err; } if(JNI_TRUE!=registerNatives(env)){ printf(&quot;register fail...exit....\n&quot;); goto err; } result=0x00010006; err: return result; } step use:1.首先编写SimpleJni.java和simpel_jni.c 2.编译java和c文件$ java -d . SimpleJni.java$gcc -fPIC -I$JAVA_HOME/include/ -I$JAVA_HOME/include/linux/ -o libsimpleJni.so simple_jni.c 3.执行 $java -Djava.library.path=. com.bt.jni.SimpleJni other example:java file: import java.util.*; public class TestJni { public native void xprint(String content); static { System.loadLibrary(“TestJni”); } public native static String native_hello(); } JNI file: #include&lt;jni.h&gt; #include&lt;stdio.h&gt; //#include &quot;TestJni.h&quot; #include&lt;iostream&gt; using namespace std; void xprint(JNIEnv *env,jobject obj,jstring content) { // const jbyte *str=(const jbyte*)(env-&gt;GetStringUTFChars(env,content,JNI_FALSE)); //printf(&quot;hello--wo%s \n&quot;,str); // env-&gt;ReleaseStringUTFChars(env,content,(const char*)str); cout&lt;&lt;&quot;here:&quot;&lt;&lt;content&lt;&lt;endl; return; } static jstring native_hello(JNIEnv *env,jobject object) { return (env)-&gt;NewStringUTF(&quot;keshixi&quot;); } static JNINativeMethod method_table[]={ { &quot;xprint&quot;,&quot;(Ljava/lang/String;)V&quot;,(void*)xprint}, {&quot;native_hello&quot;,&quot;()Ljava/lang/String;&quot;,(void*)native_hello} // {,,(void*)xprint},{,,(void*)native_hello} }; jint JNI_OnLoad(JavaVM *jvm,void *reserved){ JNIEnv *env; if(jvm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6)!=JNI_OK){ return -1; } jclass clz=env-&gt;FindClass(&quot;TestJni&quot;); if(clz==NULL) { return JNI_FALSE; } if(env-&gt;RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK){ return JNI_VERSION_1_6; } } ####reference:jni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行 动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子 另外可以作为ndk在android中使用及在android stdio也可以直接生成so 一些链接：android_jni_ndk:http://www.cnblogs.com/wzben/p/5733571.html动态注册无运行实例：http://www.linuxidc.com/Linux/2017-02/140130.htm静态注册：http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html动态注册：有实例http://www.linuxidc.com/Linux/2017-02/140129.htm www.fer.unizg.hr/_download/repository/jni.pdf文档]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_adb]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-adb%2F</url>
    <content type="text"><![CDATA[android adb command从android群英传中学习到额外的几个adb指令，是之前没接触到的：adb list targetsadb install -r xx.apk -r为覆盖adb shell dfadb shell pm list packages -fadb shell input keyevent 3 －－模拟按键输入，这里为点击home建adb shell touchscreen ..模拟滑动adb shell dumpsys 监听Activity运行状态adb shell screenrecord /sdcard/demo.mp4 录制 屏幕adb shell am start -n 包名/包名＋类名 更多，见google develop中android studio的部分另在源码目录中/system/core/toolbox 和/frameworks/base/cmds为所有ADB命令和shell命令来源]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_AndroidManifest]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-AndroidManifest%2F</url>
    <content type="text"><![CDATA[一个典型的androidmanifest文件：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.ksx.helloworld&quot;&gt; &lt;!-- more --&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;hallo&quot;//app的名字和显示在bar上的文字 android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt;//活动的注册 &lt;android:label=&quot;this is hallo&quot;&gt;//会覆盖上面的 &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;//声明为主活动 &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_makefirst_app]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-makefirst-app%2F</url>
    <content type="text"><![CDATA[install and make first app20170608今天主要是安装了android-studio环境并成功开发第一个helloworld app 在模拟器和手机上运行，下面是整个教程：在ubuntu下 1 安装java-jdk:a 先下载java-jdk:Java SE Development Kit 8 Downloadshttp://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html下载对应系统的版本 b 下载到某个目录，解压到要安装的目录：如：/usr/jdk-8/ c 设置全局环境变量：如上述的安装目录，则将export JAVA_HOME=/usr/jdk-8export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin添加到/etc/profile文件中，在末尾另起一行添加 d 使用source /etc/profile命令使刚才配置的信息生效 e 测试是否成功：java -version测试,编写java文件：public class test{ public static void main(String[] args){ System.out.println(“hello world”); }}保存为test.java，生成字节码：javac test.java运行:java test 2 安装android-studio:a 下载：在官网或者其他网站下载后b 按照installion说明进行：一般是先选择要安装的目录：如/usr/android-studioc 直接在终端,进入bin目录后:./studio.shd 还有其他配置．比如在任意目录都能打开软件．e 其他见说明文件等 3 第一个app helloworld在模拟器上运行打开软件－－&gt;选择新建一个工程，适当选择之后-&gt;选择build-&gt;make project-&gt;点击run––&gt;会提示选择安装下载模拟器–&gt;选择合适的，最好不要是带锁的－－－&gt;之后会提示成功．再选择建立一个模拟器，之后就可以了 注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm如果不能运行x86的，可能需要安装kvm:也可以使用genymotion模拟器 4 安装kvm可选要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。首先要确定你的cpu满足要求，下面有几个命令可以参考： $ egrep -c ‘(vmx|svm)’ /proc/cpuinfo4 打印的值不为0即可。 下面安装kvm： $ sudo apt-get install qemu-kvm$ sudo adduser linc kvm$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils$ sudo adduser linc libvirtd (linc为用户名，适当改）检验安装是否成功： $ sudo virsh -c qemu:///system list Id Name State运行，在有模拟器的目录中：如/home/ksx/Android/Sdk/emulator/emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm 使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。 如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。 5在手机上运行app首先连接手机，打开usb调试还是一样，但是选择app那里不是app,而是选择Edit Configurations之后选择usb device，ok，就可以了，接着运行 关于项目结构模式：默认为android设置为project可以看到整个完整的目录结构： .gradle和.idea 为自动生成 app build 编译时自动生成的文件，不用太关心 gradle 包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle .gitignore build.gradle gradle.properties 全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本 gradlew 和gradlew.bat在命令行中执行gradle命令 local.properties 指定本机android sdk路径 setting.gradle指定项目中引入的模块 app目录下 build 为自动生成，同上 lib 项目使用的第三方库 test 测试用例 proguard-rules.pro 代码混淆规则 build gradle intruducegradle Groovy 领域语言 DSL 摒弃了Ant 和Maven 在app 外有一个 build.gradle。在app中有一个build.gradle 在外面的 gradle 也可以构建c++等项目，buildscript { repositories { jcenter() //代码托管仓库 利用它可以轻松引用jcenter开源项目 } dependencies { classpath &apos;com.android.tools.build:gradle:2.3.2&apos; //声明构建的是android // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { jcenter() }} task clean(type: Delete) { delete rootProject.buildDir} app中apply plugin: ‘com.android.application’ //表明为android 应用程序模块，为com.android.library表示库模块 android { //安卓闭包 compileSdkVersion 25 //项目的编译版本，25为API 25,对应android 7.1 buildToolsVersion “25.0.3” //项目构建工具版本 defaultConfig { applicationId “org.example.myactivity1” 项目包名 minSdkVersion 25 //项目最低兼容的android系统版本 targetSdkVersion 25 //表明如22表示只在22测试充分，如不启动运行时权限，android６ 的运行时权限就不会加，表明只在5上做充分测试 versionCode 1 项目版本编号 versionName “1.0” 项目版本名 testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner” } buildTypes {//分debug和release版本 release { minifyEnabled false //是否混淆代码 proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’//混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件 } }} dependencies {//分本地依赖，库依赖和远程依赖 compile fileTree(dir: ‘libs’, include: [‘*.jar’]) //本地依赖声明 androidTestCompile(‘com.android.support.test.espresso:espresso-core:2.2.2’, { exclude group: ‘com.android.support’, module: ‘support-annotations’ }) compile ‘com.android.support:appcompat-v7:25.3.1’ // 依赖库 compile ‘com.android.support.constraint:constraint-layout:1.0.2’ testCompile ‘junit:junit:4.12’ //测试用例库} 其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_howto_makeapk_cmd]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-howto-makeapk-cmd%2F</url>
    <content type="text"><![CDATA[how to make a android by cmd :在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni way 1:方法１prepareandroid studio 创建了一个工程，然后手动在命令行打包，进入工程里的. 或者direct use andrid create project创建 cd ~/Desktop/FirstTest/app/src/mainmkdir genmkdir buildmkdir out 在android工程目录下建立Makefile文件，添加如下代码： SDK=~/Android/Sdk BUILD_TOOLS=$(SDK)/build-tools/25.0.3 PLATFORMS=$(SDK)/platforms/android-25 aapt=$(BUILD_TOOLS)/aapt dx=$(BUILD_TOOLS)/dx aidl=$(BUILD_TOOLS)/aidl apkbuilder=$(SDK)/tools/apkbuilder2 //后面不支持apkbuilder所以 adb=$(SDK)/platform-tools/adb 资源编译，生成 R.javaaapt_task: $(aapt) package \ -f \ #如果编译出来的文件已经存在，强制覆盖 -M AndroidManifest.xml \ # Mainifest.xml 的路径 -I $(PLATFORMS)/android.jar \ # 某个版本平台的 android.jar 的路径 #依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:... -S res/ \ # res 文件夹路径 -J gen/ \ # 生成 R.java 的输出目录 -m #使得生成的包的目录放在 -J 参数指定的目录 代码编译，生成 .classjavac_task: javac -source 1.7 -target 1.7 \ # 使用 jdk1.8 编译 1.7 的 .class 文件 -encoding UTF-8 \ -bootclasspath $(PLATFORMS)/android.jar \ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:... -d build/ \ #指定放置生成的类文件的位置 java/thereisnospon/dextest/*.java \ gen/thereisnospon/dextest/*.java \ 生成 .dexdx_task: $(dx) --dex --output=build/classes.dex \ build 资源文件初始包resapk_task: $(aapt) package -f \ -M AndroidManifest.xml \ -I $(PLATFORMS)/android.jar \ -S res/ \ -F out/resources 将.dex 文件加入到资源文件初始包中 注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行 apk_task: java -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \ com.android.sdklib.build.ApkBuilderMain \ Demo.apk -v -u -z src/main/out/resources\ -f src/main/build/classes.dex -rf src 签名，使用debug的签名signer: jarsigner -verbose \ -keystore ~/.android/debug.keystore \ -storepass android \ -keypass android \ Demo.apk androiddebugkey 一次性打包pkg: make apk_task make signer 卸载apkuninstall: $(adb) uninstall thereisnospon.dextest 安装apkinstall: $(adb) install out/app.apk 运行run: make pkg make uninstall make install $(adb) shell am start -n thereisnospon.dextest/ thereisnospon.dextest.MainActivity 方法２，用gradle,首先用AS 建立工程，之后在工程文件下，之星执行，gradle cleangradle build即生成apk文件]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_will_write]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-will-write%2F</url>
    <content type="text"><![CDATA[#test categoriesthis is the android categories to test]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test_article_picture]]></title>
    <url>%2F2018%2F05%2F20%2Ftest-article-picture%2F</url>
    <content type="text"><![CDATA[##this is a test of pictureend]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ksance test article]]></title>
    <url>%2F2018%2F05%2F19%2Fksance-test-article%2F</url>
    <content type="text"><![CDATA[this is a test article by ksance]]></content>
  </entry>
</search>
