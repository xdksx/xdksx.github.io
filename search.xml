<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tcpip_ARP]]></title>
    <url>%2F2018%2F05%2F27%2Ftcpip-ARP%2F</url>
    <content type="text"><![CDATA[ARP 协议ARP协议的作用 ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信； 在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：端设备手机pc等–&gt;(交换机)路由器—&gt;下一个路由器—&gt;下一个终端设备 端设备默认路由到网关–&gt;网关收到包后，将源地址改为网关的外网地址—&gt;下一个路由将源地址改为其地址–&gt;….-&gt;设备地址为目的地址时，接收而不转发 考虑一个问题：在上述的网络上发送时，如pc发给路由器时，只知道它的ip地址，怎么发给它：即端到端的发送：是借助设备唯一的mac地址来发送的在有线网中。利用了交换机的端口和mac地址关系，转发在wifi中，能接收到所有的包，但是会在驱动中将mac目的地址非本地的包丢弃，除非开启了混杂监听模式 但是路由器怎么知道设备如手机的mac地址呢？通过arp协议来获取，arp是依赖mac和ip的”映射” tcpip卷1中4.2举了一个完整的例子，可以去看ARP协议的交互过程 基本的交互方式：例如ping网关：station —ARP request—-&gt; AP ARP请求，广播帧station &lt;—ARP response — AP ARP应答 ,单播帧通过上述的方式，station得到了AP的mac地址，之后将AP的MAC地址存在缓存中，在下次数据包等包的时候就可以将该mac地址填在mac头中，即知道了AP的地址后，包就可以顺利的被AP接收了 AP(路由器)也会主动的向station发送arp request，当它不知道station的mac地址（或缓存过期），例如，AP收到一个外网的包，要转发给对应192.168.0.4的staton,但是没有他的mac地址，或者过期了或者其他情况，则向该station发出arp请求。从而得打station的mac地址 什么时候会触发arp请求？1.在ping的时候2.在发送tcp，ip包的时候3.在缓存过期时主动发出，这个由arp状态机中实现ARP代理和免费ARP 当我们通过ping百度，或者想访问百度的时候，怎么在mac头中填写目的mac地址呢？即怎么找到百度?（另一个网络) 是通过在mac头目的mac地址填写网关的mac地址实现的，借助w网关的来帮我们寻找，这个叫做ARP代理,其实欺骗了主机 tcpip卷对此有较详细解说4.6 免费ARP是用于检测是否周围有使用相同的ip地址的设备，即通过ping自己，寻找有自己的ip的主机ARP协议的包封装格式和抓包分析 分组格式： ()为字节数mac头：以太网目的地址(6) mac源地址(6) 帧类型(2)(0x0806)28byte arp帧：硬件类型(2)|协议类型(2)|硬件地址长度(1)|协议地址长度(1)|op(请求或应答或rarp 2)|发送端mac地址(6)|发送端ip(4)|接收端mac地址(6)|接收端ip(4) 请求广播帧：目的mac地址为全1，电缆上所有的以太网接口都要接收广播帧,硬件类型为1表示以太网地址，协议类型为要映射的协议地址类型0x0800,表示为ip地址，op（arp请求为1，答应为2，rarp请求为3，rarp答应为4） arp填充：以太网帧最小值为60，mac头14，所以=46，要填充：46-28=18个字节 arp抓包，可以用wireshark,Omnipeek - Savvius,tcpdump,或者自己写一个程序来抓～tcpdump : sudo tcpdump -vv arp 12345 tcpdump: listening on wlp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes21:51:21.134575 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.101 tell 192.168.0.1, length 28 //ap ask me21:51:21.135404 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.110 tell 192.168.0.1, length 2821:51:21.135413 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.0.110 is-at 48:5a:b6:6e:c9:5f (oui Unknown), length 28// i reply ap21:51:32.081916 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.106 tell 192.168.0.1, length 28 //ask other 123456722:01:27.149947 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.107 tell 192.168.0.1, length 28 0x0000: 0001 0800 0604 0001 206b e70f 1b42 c0a8 .........k...B.. 0x0010: 0001 0000 0000 0000 c0a8 006b ...........k 22:04:17.114593 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.0.110 is-at 48:5a:b6:6e:c9:5f (oui Unknown), length 28 0x0000: 0001 0800 0604 0002 485a b66e c95f c0a8 ........HZ.n._.. 0x0010: 006e 206b e70f 1b42 c0a8 0001 .n.k...B.... ARP协议的常用命令和调试分析 查看ARP缓存：即现在保存的arp映射表: 12345arp -a? (192.168.0.101) at 4c:32:75:3a:09:b3 [ether] on wlp2s0? (192.168.0.1) at 20:6b:e7:0f:1b:42 [ether] on wlp2s0? (192.168.0.108) at 94:d0:29:9d:74:dd [ether] on wlp2s0? (192.168.0.107) at 94:65:2d:ab:88:8b [ether] on wlp2s0 1234arp Address HWtype HWaddress Flags Mask Iface192.168.0.101 ether 4c:32:75:3a:09:b3 C wlp2s0192.168.0.1 ether 20:6b:e7:0f:1b:42 C wlp2s0 123456ip neigh192.168.0.101 dev wlp2s0 lladdr 4c:32:75:3a:09:b3 STALE192.168.0.1 dev wlp2s0 lladdr 20:6b:e7:0f:1b:42 STALE192.168.0.108 dev wlp2s0 lladdr 94:d0:29:9d:74:dd STALE192.168.0.107 dev wlp2s0 lladdr 94:65:2d:ab:88:8b STALE192.168.0.104 dev wlp2s0 lladdr e4:9a:dc:b0:a5:36 STALE arping命令：http://man.linuxde.net/arping arp 命令man arp 包括删除arp表项等，有问题，找男人~ARP协议内核状态机 对不存在的主机，arp请求的超时机制 arp缓存和老化时间：http://www.jb51.net/LINUXjishu/65693.html：改变老化时间：在Linux上如果你想设置你的ARP缓存老化时间，那么执行sysctl -w net.ipv4.neigh.ethX=Y即ARP协议的编程 在PF_PACKET中发出ARP包 直接贴例子，具体可以看博客的PF_PACKET文章：123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;linux/if.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;linux/if_ether.h&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230//获取硬件网卡的相应信息void GetEthInfor(char *name , char *MAC_addr , struct in_addr * IP_addr);//arp包的结构定义struct ARP_PACKET&#123; //以太网首部 unsigned char dest_mac[6]; //6字节 unsigned char sorce_mac[6];//6字节 unsigned short type; //2字节 //arp——内容 unsigned short hw_type; //2字节：硬件地址类型 0x0001 表示mac地址 unsigned short pro_type; //2字节：软件地址类型 0x0806 表示IPV4地址 unsigned char hw_len; //1字节：硬件地址长度 unsigned char pro_len; //1字节：软件地址长度 unsigned short op; //2字节：操作类型 0x0001表示ARP请求；0x0002表示ARP应答 unsigned char from_mac[6];//6字节 unsigned char from_ip[4]; //4字节 unsigned char to_mac[6]; //6字节 unsigned char to_ip[4]; //4字节 unsigned char padding[18];//18字节：填充字节，因为以太网数据最少要46字节&#125;;//主函数int main()&#123; int i = 0; int fd = 0; int num=0; unsigned char MAC_ADDR[6]; struct in_addr IP_ADDR;//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址. struct ARP_PACKET arp_pk=&#123;0&#125;; struct sockaddr_ll eth_info;//结构体的定义//在/linux/if_packet.h中， 表示设备无关的物理层地址结构 //第一步：获取指定网卡的信息（MAC地址和IP地址） GetEthInfor("wlp2s0",MAC_ADDR,&amp;IP_ADDR); /*printf("The MAC_addr is:"); for(i =0 ;i&lt;6;i++) printf("%4X",MAC_ADDR[i]); printf("\n"); printf("the IP is:%s\n",inet_ntoa(IP_ADDR));*/ //第二步：填充ARP数据包的内容 for(i=0;i&lt;6;i++) //填充以太网首部的目的mac地址 &#123; arp_pk.dest_mac[i]=0XFF; &#125; for(i=0;i&lt;6;i++) //填充以太网首部的源mac地址 &#123; arp_pk.sorce_mac[i]=MAC_ADDR[i]; &#125; arp_pk.type = htons(0x0806); //填充以太网首部的侦类型 arp_pk.hw_type = htons(0x0001); //填充硬件地址类型：0x0001表示的是MAC地址 arp_pk.pro_type = htons(0x0800);//填充协议地址类型：0x0800表示的是IP地址 arp_pk.hw_len = 6; //填充硬件地址长度 arp_pk.pro_len = 4; //填充协议地址长度 arp_pk.op = htons(0x0001); //填充操作类型：0x0001表示ARP请求 for(i=0;i&lt;6;i++) //填充源mac地址 &#123; arp_pk.from_mac[i]=MAC_ADDR[i]; &#125; in_addr_t ipaddr=inet_network(inet_ntoa(IP_ADDR)); for(i=3;i&gt;=0;i--) //填充源IP地址 &#123; arp_pk.from_ip[i]=(unsigned char)ipaddr&amp;0xFF; ipaddr=ipaddr&gt;&gt;8; printf("-%d-",arp_pk.from_ip[i]); &#125; /* arp_pk.from_ip[0]=192; arp_pk.from_ip[1]=168; arp_pk.from_ip[2]=199; arp_pk.from_ip[3]=145;*/ for(i=0;i&lt;6;i++) //填充欲获取的目的mac地址 &#123; arp_pk.to_mac[i]=0X00; &#125; arp_pk.to_ip[0]=0X0B; //填充想要装换为MAC地址的IP地址。可以使用命令行参数来做 arp_pk.to_ip[1]=0X40; arp_pk.to_ip[2]=0X39; arp_pk.to_ip[3]=0X0A; //第三步：填充sockaddr_ll eth_info结构 eth_info.sll_family = PF_PACKET; eth_info.sll_ifindex = if_nametoindex("wlp2s0");//返回输入的接口名称的索引值 //printf("number is:%d\n",eth_info.sll_family); //第四步：创建原始套接字 fd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL)); // if(fd&lt;0) &#123; printf("socket SOCK_RAW failed!\n"); exit(1); &#125; //第五步：发送ARP数据包 num = sendto(fd , &amp;arp_pk , sizeof(struct ARP_PACKET) , 0 ,(struct sockaddr*)(&amp;eth_info),sizeof(eth_info)); if(num&lt;0) &#123; printf("sendto failed!\n"); exit(1); &#125; //第六步：接受ARP应答 num = recvfrom(fd , &amp;arp_pk , sizeof(struct ARP_PACKET) ,0,NULL,0); if(num&lt;0) &#123; printf("rcvfrom failed!\n"); exit(1); &#125; else &#123; printf("I receive %d bytes!\n",num); printf("the mac is:"); for(i=0;i&lt;6;i++) &#123; printf("%4X ",arp_pk.from_mac[i]); &#125; printf("op:%d\n",arp_pk.op); for(i=0;i&lt;4;i++) &#123; printf("%d. ",arp_pk.to_ip[i]); &#125; printf("\n"); &#125; close(fd); return 0;&#125;void GetEthInfor(char *name , char *MAC_addr , struct in_addr * IP_addr)&#123; struct ifreq eth; //够结构用于存放最初多获取的接口信息//该结构存放在：/net/if.h,详细字段表示在头文件中 int fd; //用于创建套接字 int temp=0; //用于验证接口调用 int i=0; //用于循环 strncpy(eth.ifr_name,name,sizeof(struct ifreq)-1);// fd = socket(AF_INET,SOCK_DGRAM,0); // fd=socket(AF_INET,SOCK_STREAM,0); fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));if(fd&lt;0) &#123; printf("socket failed!\n"); exit(1); &#125; //获取并且保存和打印指定的物理接口MAC地址信息 temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth); if(temp&lt;0) &#123; printf("ioctl--get hardware addr failed!\n"); exit(1); &#125; strncpy(MAC_addr,eth.ifr_hwaddr.sa_data,6); printf("The MAC_addr is:"); for(i =0 ;i&lt;6;i++) printf("%4X",(unsigned char)eth.ifr_hwaddr.sa_data[i]); printf("\n"); //获取并且保存和打印指定的物理接口IP地址信息 temp = ioctl(fd,SIOCGIFADDR,&amp;eth); if(temp&lt;0) &#123; printf("ioctl--get hardware addr failed!\n"); exit(1); &#125; memcpy(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),4); //关闭套接口 printf("got ipaddr:%s\n",inet_ntoa(*IP_addr));/*i=0;printf("get the MAC_ADDR:\n");for(i;i&lt;6;i++) printf("%.2X:",MAC_addr[i]&amp;0xFF);*/ close(fd);&#125;//第二步填充arp数据包的时候，填充的数据和类型根据需要进行。//这里的arp数据包结构体是自己定义的，也可以是利用linux的相关结构：/*eg:typedef struct _tagARP_PACKET&#123; struct ether_header eh; ///net/ethernet.h struct ether_arp arp; &#125;ARP_PACKET_OBJ, *ARP_PACKET_HANDLE; /netinet/if_ether.h;/net/if_arp.h各个字段的填充见头文件*//*第三步：填充sockaddr_ll eth_info结构,关键是填充网络接口索引值，最直接的方法是上面的函数，还有另外的方法:利用ioctl函数获取struct ifreq结构的信息，该结构放置了很多网络接口的相关信息*//* struct sockaddr_ll&#123; unsigned short sll_family; //总是 AF_PACKET unsigned short sll_protocol; // 物理层的协议 int sll_ifindex; //接口号 unsigned short sll_hatype; // 报头类型 unsigned char sll_pkttype; // 分组类型 unsigned char sll_halen; // 地址长度 unsigned char sll_addr[8]; // 物理层地址 &#125;;eg:* struct sockaddr_ll peer_addr; * memset(&amp;peer_addr, 0, sizeof(peer_addr)); peer_addr.sll_family = AF_PACKET; struct ifreq req; bzero(&amp;req, sizeof(struct ifreq)); strcpy(req.ifr_name, "eth0"); if(ioctl(sockfd, SIOCGIFINDEX, &amp;req) != 0) perror("ioctl()"); peer_addr.sll_ifindex = req.ifr_ifindex; peer_addr.sll_protocol = htons(ETH_P_ARP); *//*第四步，创建套结字的时候，有以下的组合：更多见：man packet * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux. * 第二个参数： 2）套接字类型： SOCK_DGRAM----以太网头已经构造好了 SOCK_RAW------自己构造以太头 * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字 * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr）， * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部， * 而发送时也无须用户添加头部字段。 第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型： 1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806) 和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100) 2)IEEE维护的注册以太网类型列表 3）半官方的列表由IANA维护 ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。 0x88b5和0x88b6是保留以太网类型，供实验或私人使用。 */ /*第五步发送和接收套接字的函数可以是read write操作套结字，也可以是上文的UDP无连接用的函数*/ 处理的时候可能需要获取网关的ip地址：1234567891011121314151617181920212223242526272829303132333435363738/*proc方法获取网关地址*/void GetGateWayIP(uint8 *ip_addr)&#123; char inf[100]; FILE *file_fd; uint8 high=0,low=0,value; int i; file_fd = fopen("/proc/net/route","r"); if(file_fd==NULL) &#123; printf("can not open /proc/net/route\n"); &#125; else &#123; while(!feof(file_fd)) &#123; memset(inf,0,sizeof(inf)); fgets(inf,100,file_fd); if(inf[5]=='0'&amp;&amp;inf[6]=='0'&amp;&amp;inf[7]=='0'&amp;&amp;inf[8]=='0'&amp;&amp;inf[9]=='0'&amp;&amp;inf[10]=='0'&amp;&amp;inf[11]=='0'&amp;&amp;inf[12]=='0') &#123; for(i=20;i&gt;=14;i-=2) &#123; if(inf[i]&gt;=65) high = inf[i]-55; else high = inf[i]-48; if(inf[i+1]&gt;=65) low = inf[i+1]-55; else low = inf[i+1]-48; value = high*16+low; ip_addr[10-i/2] = value; &#125; break; &#125; &#125; &#125;&#125; ARP攻击 ARP包可以直接发送给对端不经过路由器，有趣在一个局域网中，客户端的几乎所有的包都是发往路由器的，这归结于默认路由设置，而在无线网，网卡其实可以接收所有数据，毕竟空气介质，所以，局域网中的设备可以直接通信实验：在文件全能王中开启wifi文件传输，和它在同一个局域网的sta能访问该地址，抓包，发现目的地址和源地址都为同一个局域网的不同ip,且不为路由器网关ip，证明其两个设备是可以直接通信的 再来做一个实验：通过pf_packet1、在电脑A上写一个程序，mac目的地址为B,源地址为A,协议类型随机，数据随意，发送给B 同时在B端进行接收，过滤掉其他mac地址，看是否可以接收到，在连接ap和不连接ap的条件下2、在A和B设置静态ip地址，且不同网段，都不连接AP ,让A向B 发送ARP请求包，B接收到后回复arp响应包，接着做ping或其他操作，看是否能互相通信 编程可以参考上述程序，改一下地址什么的就可以，或者参考其他：http://www.freebuf.com/articles/system/5157.html这篇文章讲的很具体，个人也喜欢这个网站，emm,实验过了，还可以，具体程序不贴了]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_PF_PACKET]]></title>
    <url>%2F2018%2F05%2F27%2Ftcpip-PF-PACKET%2F</url>
    <content type="text"><![CDATA[PF_PACKET的使用：PF_PACKET简介：是linux下的用于发送和接收二层(mac层)的套接字： PF_PACKET基本使用： 基本的几个操作： 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;linux/if.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;linux/if_ether.h&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//获取硬件网卡的相应信息void GetEthInfor(char *name , char *MAC_addr , struct in_addr * IP_addr)//传入接口名，取回mac和ip&#123; struct ifreq eth; //结构用于存放最初获取的接口信息 //该结构存放在：/net/if.h,详细字段表示在头文件中 int fd; //用于创建套接字 int temp=0; //用于验证接口调用 int i=0; //用于循环 strncpy(eth.ifr_name,name,sizeof(struct ifreq)-1); // fd = socket(AF_INET,SOCK_DGRAM,0); // fd=socket(AF_INET,SOCK_STREAM,0); fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL)); if(fd&lt;0) &#123; printf("socket failed!\n"); exit(1); &#125; //获取并且保存和打印指定的物理接口MAC地址信息 temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth); if(temp&lt;0) &#123; printf("ioctl--get hardware addr failed!\n"); exit(1); &#125; strncpy(MAC_addr,eth.ifr_hwaddr.sa_data,6); printf("The MAC_addr is:"); for(i =0 ;i&lt;6;i++) printf("%4X",(unsigned char)eth.ifr_hwaddr.sa_data[i]); printf("\n"); //获取并且保存和打印指定的物理接口IP地址信息 temp = ioctl(fd,SIOCGIFADDR,&amp;eth); if(temp&lt;0) &#123; printf("ioctl--get hardware addr failed!\n"); exit(1); &#125; memcpy(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),4); //关闭套接口 printf("got ipaddr:%s\n",inet_ntoa(*IP_addr)); close(fd);&#125;//取得网络接口的索引：int值,传入fd和接口名int Get_IfaceIndex(int fd, const char* interfaceName)&#123;struct ifreq ifr;if (interfaceName == NULL)&#123; return -1;&#125;memset(&amp;ifr, 0, sizeof(ifr));strcpy(ifr.ifr_name, interfaceName);if (ioctl(fd, SIOCGIFINDEX, &amp;ifr) == -1)&#123; printf("RED ioctl error\n"); return -1;&#125;return ifr.ifr_ifindex;&#125;int set_Iface_promisc(int fd, int dev_id)//传入fd和index&#123;struct packet_mreq mr;memset(&amp;mr,0,sizeof(mr));mr.mr_ifindex = dev_id;mr.mr_type = PACKET_MR_PROMISC;if(setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&amp;mr,sizeof(mr))==-1)//退出混杂模式使用这个：PACKET_DROP_MEMBERSHIP&#123; fprintf(stderr,"GREEN set promisc failed! \n"); return -1;&#125;return 0;&#125; 使用123456789101112int main ()&#123; unsigned char MAC_ADDR[6]; struct in_addr IP_ADDR;//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址. //第一步：获取指定网卡的信息（MAC地址和IP地址） GetEthInfor("wlp2s0",MAC_ADDR,&amp;IP_ADDR); int fd; fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP)); int index=Get_IfaceIndex(fd,"enp1s0"); printf("index:%d\n",index); return 0; &#125; PF_PACKET的接收：简单说明：创建套结字的时候，有以下的组合：更多见：man packet 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux. 第二个参数： 套接字类型：SOCK_DGRAM----以太网头已经构造好了 SOCK_RAW------自己构造以太头 * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字 * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr）， * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部， * 而发送时也无须用户添加头部字段。 第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)2) IEEE维护的注册以太网类型列表3）半官方的列表由IANA维护 ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。 0x88b5和0x88b6是保留以太网类型，供实验或私人使用。(若指定socket_type为SOCK_RAW则意味着原始数据包包含了链路层头部，若指定为SOCK_DGRAM则将做一些处理以剥掉链路层头部。链路层头部信息的通用格式是一个sockaddr_ll结构。protocol填入网络字节序的IEEE 802.3协议号。参见&lt;linux/if_ether.h&gt;头文件了解允许的协议。如果protocol被设置为htons(ETH_P_ALL)，则意味着接受所有协议。所有接入的协议类型为protocol的数据包将在传递给内核之前传递到PACKET套接字。) 收包可以使用的接口：123int readnum = recvfrom(rawsock, buffer,2048,0, (struct sockaddr*)(&amp;eth_info),&amp;leneth_info);int readnum = read(rawsock, buffer,2048);int readnum = recvfrom(rawsock, buffer,2048,0, NULL,NULL); 一个简单的接收包的例子：12345678910111213141516#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/if_ether.h&gt;#include &lt;linux/in.h&gt;#include &lt;stdlib.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;linux/if.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;linux/if_ether.h&gt;#define BUFFER_MAX 2048 1234567891011121314int main(int argc, char *argv[])&#123; if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; 0) &#123; printf("error: create raw socket!!!\n"); exit(0); &#125; while(1) &#123; int readnum = read(rawsock, buffer,2048);// can read packet //printf("recv buffer:%s\n",buffer); &#125; return 0; &#125; 指定从某个接口接收数据：12345678910111213141516171819202122int main(int argc, char *argv[])&#123; struct sockaddr_ll eth_info;//结构体的定义在/linux/if_packet.h中， 表示设备无关的物理层地址结构 eth_info.sll_family = PF_PACKET; //PF_PACKET定义在sys/types.h中 eth_info.sll_ifindex = if_nametoindex("lo");//返回输入的接口名称的索引值 //次函数定义在net/if.h中 if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; 0) &#123; printf("error: create raw socket!!!\n"); exit(0); &#125; if(bind(rawsock,(struct sockaddr *)(&amp;eth_info),sizeof(eth_info))==-1)//绑定接口，从而只接收那个接口上的数据&#123; printf("error: bind!!\n"); exit(0);&#125; while(1) &#123; int readnum = read(rawsock, buffer,2048);// can read packet //printf("recv buffer:%s\n",buffer); &#125; return 0; &#125; 接收后的包如何读取：以包括mac头的形式来看：粗暴的形式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798int main(int argc, char *argv[])&#123; int rawsock; char buffer[BUFFER_MAX]; char *ethhead; char *iphead; char *tcphead; char *udphead; char *icmphead; char *pHead; if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; 0) &#123; printf("error: create raw socket!!!\n"); exit(0); &#125; while(1) &#123; int readnum = read(rawsock, buffer,2048);// can read packet //printf("recv buffer:%s\n",buffer); if(readnum &lt; 42) &#123; printf("error: Header is incomplete!!!\n"); continue; &#125; // for(j;j&lt;readnum;j++) // printf("%.2X:",buffer[j]&amp;0xFF); ethhead = (char *)buffer; pHead = ethhead; int ethernetmask = 0XFF; framecount++; printf("------------------Analysis Packet [%d]---------------------\n",framecount); // printf("all:-----%s\n",ethhead); printf("MAC:"); int i = 6; for(; i &lt;=11; i++) &#123; printf("%.2X:",pHead[i]&amp;ethernetmask); &#125; printf("----&gt;"); for(i = 0; i &lt;=5; i++) &#123; printf("%.2X:",pHead[i]&amp;ethernetmask); &#125; printf("\n"); printf("proto: %.2x:",pHead[12]&amp;ethernetmask); printf("proto2: %.2x:\n",pHead[13]&amp;ethernetmask); iphead = ethhead + 14; pHead = iphead + 14; printf("IP:"); for(i = 0; i &lt;=3; i++) &#123; printf("%d",pHead[i]&amp;ethernetmask); if(i != 3) printf("."); &#125; printf("----&gt;"); for(i = 10; i &lt;=13; i++) &#123; printf("%d",pHead[i]&amp;ethernetmask); if(i != 13) printf("."); &#125; printf("\n"); int prototype = (iphead + 9)[0]; // printf("Protocol: %.2X:",prototype); //int prototype = (iphead + 9)[0]; pHead = iphead + 20; printf("Protocol: "); switch(prototype) &#123; case IPPROTO_ICMP: printf("ICMP\n"); break; case IPPROTO_IGMP: printf("IGMP\n"); break; case IPPROTO_IPIP: printf("IP\n"); break; case IPPROTO_TCP : printf("TCP | source port: %u | ",(pHead[0]&lt;&lt;8)&amp;0XFF00 | pHead[1]&amp;0XFF); printf("dest port: %u\n", (pHead[2]&lt;&lt;8)&amp;0XFF00 | pHead[3]&amp;0XFF); break; case IPPROTO_UDP : printf("UDP | source port: %u | ",(pHead[0]&lt;&lt;8)&amp;0XFF00 | pHead[1]&amp;0XFF); printf("dest port: %u\n", (pHead[2]&lt;&lt;8)&amp;0XFF00 | pHead[3]&amp;0XFF); break; case IPPROTO_RAW : printf("RAW\n"); break; default: printf("Unkown\n"); &#125; printf("-------------------------end-----------------------\n"); &#125; return 0; &#125; 收包处理的方式，也可以把指针赋给内核的结构：struct iphdr如：12struct iphdr ip;ip = (struct iphdr *)(buffer + sizeof(struct ethhdr)); 内核提供了很多的包结构，在发包或者收包的时候可以直接使用这些结构解析或者粗暴的用字符串解析 PF_PACKET发送包： 发包和接收包类似： 1234567num = sendto(rawsock, buffer,2048 , 0 ,(struct sockaddr*)(&amp;eth_info),sizeof(eth_info)); if(num&lt;0) &#123; printf("sendto failed!\n"); exit(1); &#125; printf("success:%d\n",num);]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>PF_PACKET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DS_linklist]]></title>
    <url>%2F2018%2F05%2F26%2FDS-linklist%2F</url>
    <content type="text"><![CDATA[数据结构之线性表：有序表：数组：单链表：链表定义 { 数据成员:常见的基本类型或者对象类型均可 数据关系:在链表中的块的成员在连续的内存中，块与块之间内存位置不连续 指向块的指针：单链表只有一个next,双链表加上pre }基本运算：{ InitList(&amp;L);:初始化链表，在c/c++中需要做分配内存，初始化链表头和其值的操作； DestroyList(&amp;L); 在销毁时需要free内存 Length(L);链表的长度是块的个数 GetElem(L,i,&amp;e); 在链表中取元素需要一个一个遍历直到下标值，若为双链表会快些。所以这里取索引值对应的值和取链表的值，效率几乎一样； LocateElem(L,e,compare()); 和链表中的元素做对比 InsertElem(&amp;L,i,e); 在链表中插入元素，复杂度O(1),在提供位置的时候，若不提供位置，还需要加搜索的时间 DeleteElem(&amp;L,i,&amp;e); 在链表中删除元素，复杂度O(1)…… }eg:1234567891011typedef struct LNode &#123; ElemType data；//数据域 struct LNode *next； //指针域&#125; LNode, *LinkList;LNode *L;LinkList L;L = (LinkList) malloc( sizeof (LNode) );或 L = new LNode;L-&gt;data;LNode L;L.date 链表的两种头部： 没有头的链表：第一个块就开始存储数据 任何时候都有头的链表： 第一个块不存储数据，作为头节点，第二个块开始存数据 应用：在leetcode中的ReverseLinklist中，当反转的是从1开始的时候，若使用的是没有头的，则需要额外判断处理，否则可以统一处理； 链表的几个常见操作： 取第i个元素： 123456789101112Status GetElem_L(LinkList L, int i, ElemType &amp;e)&#123;//查找操作 p = L-&gt;next; j = 1; while( p &amp;&amp; j &lt; i)&#123; p = p-&gt;next; ++j; &#125; if (!p || j&gt;i) return ERROR; e = p-&gt;data; return OK;&#125; 插入元素：在第i个位置上插入 1234567891011Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123; p = L; j = 0; while (p &amp;&amp; j &lt; i-1) &#123; p = p-&gt;next; ++j &#125; if (!p || j&gt;i-1) return ERROR; s = (LinkList) malloc( sizeof (LNode) ); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return OK; &#125; 删除元素:删除第i个元素: 1234567891011 Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e)&#123; p = L; j = 0; while (p-&gt;next &amp;&amp; j &lt; i-1) &#123; p = p-&gt;next; ++j &#125; if (!(p-&gt;next) || j&gt;i-1) return ERROR; q = p-&gt;next; e = q-&gt;data; p-&gt;next = p-&gt;next-&gt;next; //(p-&gt;next = q-&gt;next;) free(q); return OK;&#125; 链表的建立： 头插法： 1234567891011CreateList_L(LinkList &amp;L, int n)&#123; L = (LinkList) malloc( sizeof (LNode) ); L-&gt;next = NULL; for( i=n; i&gt;0; --i)&#123; s = (LinkList) malloc( sizeof (LNode) ); scanf( &amp;s-&gt;data); s-&gt;next = L-&gt;next; ① L-&gt;next = s; ② &#125;&#125; 尾插法： 12345678910CreateList_L(LinkList &amp;L, int n)&#123; tail = L = (LinkList) malloc( sizeof (LNode) ); L-&gt;next = NULL; for( i=n; i&gt;0; --i)&#123; s = (LinkList) malloc( sizeof (LNode) ); scanf( &amp;s-&gt;data); tail-&gt;next = s; ① tail = s; ② &#125; &#125; 链表的常见复杂操作： 两个有序链表的合并：123456789101112131415void MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)&#123; pa = La-&gt;next; pb = Lb-&gt;next; Lc = pc = La; while( pa &amp;&amp; pb )&#123; if(pa-&gt;data &lt;= pb-&gt;data)&#123; pc-&gt;next = pa; pc = pa; pa = pa-&gt;next; &#125; else&#123; pc-&gt;next = pb; pc = pb; pb= pb-&gt;next; &#125; &#125; pc-&gt;next = pa ? pa : pb; free( Lb );&#125; 一些特殊的链表： 单向循环链表： 图示： 多重循环链表： 双向链表：12345typedef struct DuLNode&#123; ElemType data; struct DuLNode *prior; struct DuLNode *next;&#125;DuLNode, *DuLinkList; 双向循环链表： 探讨： 链表作为最基础的数据结构，是对其他数据结构：如栈，树等的支撑，其他这些大部分是在链表的基础上建立的； 从较底层的层面：即深入到内存，链表实现了对零散内存的有效使用，内存在为链表分配空间的时候不用大段的连续空间； 从较高层，即抽象的层面看，链表仅仅是一批数据的拓扑结构之一，就常见的栈，队列，树，图等等，你还可以想出其他可能有用没用的，如，立体的结构，方块，金字塔形(emm这个像堆），还有随意的，感觉想到了矩阵里面的压缩。 应用： 链表的应用：如 在文件中，对大文件的存储，采用类似链表的结构， 大数相加，像两个100位的整数相加，使用链表，每个块为一位，就可以解决这个问题，数组也行 倒排索引结构，在操作系统中用到，我的github上放着一个本科毕业设计做的简单搜索引擎，几乎全是自己搞的（解析网页那块自己c写了状态机，觉得效果不如beatifulsoup好，后面用它了),不过想想那会还不会很有意识的去想如果让它运行在大量用户下，各种使用条件（如输入条件下，会怎么样，年轻啊~) 其他，当然是其他数据结构基于链表做的，多了去了]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[code_efficandreadable]]></title>
    <url>%2F2018%2F05%2F26%2Fcode-efficandreadable%2F</url>
    <content type="text"><![CDATA[论代码的效率和可读性的权衡高效代码可读性差：有一些代码，占用额外内存小，即run in place，且执行的速度快，即复杂度O()低，但是可读性差，即使注释了，修改起来也容易出错，如：对链表的操作：举一个leetcode的例子：(这个例子不是很典型，能说明问题即可） reverse a linklist from m to n; 1-&gt;3-&gt;4-&gt;5-&gt;null and m,n(ex:2,4); return 1-&gt;5-&gt;4-&gt;2-&gt;null; 上面例子一开始可以想到，头插法，或者将范围内的那一段用新的处理过的链表替换掉，即只需要处理该片段的头和尾部，当然可能还有其他方法，这里先不考虑； 于是，头插法不是很复杂，但是在这里不用额外的内存时，需要频繁的改变next指针和对pre元素做临时保存，使得代码可读性差，所以可以考虑以下方案： 在替换的内存小时，可以采用后者，让代码可读性高些，方便维护和（被替代~更容易被炒鱿鱼的风险哈哈) 在内存小时，采用前者，爱怎么指怎么指，看不懂不管哈哈哈]]></content>
      <categories>
        <category>代码整洁</category>
      </categories>
      <tags>
        <tag>代码可读性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_mtu]]></title>
    <url>%2F2018%2F05%2F20%2Ftcpip-mtu%2F</url>
    <content type="text"><![CDATA[MTU这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍： 理论部分：１、MTU(Maximum Transmission Unit)如何定义: 指的是通信协议中的某一层上面所能通过的最大数据包大小 这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？ 答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B&gt;1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:分片：ip净载荷：MTU-IP头：1500-20=1480; 3008B 需要分为3片，3008=1480,1480,48总结：MTU就是MAC承载的载荷的最大值 2、MTU会影响什么: 数据包太大-&gt;分片重组-&gt;网络性能变差 数据包太小-&gt;一次能传输的数据小-&gt;网速差 路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191) 3、如何知道这个值呢？路径最大传输单元发现方法(RFC1191) 越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。 MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：ping -c 3 -s 1474 -M do 192.168.0.1PING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.ping: local error: Message too long, mtu=1500提示错误即消息太大且未设置分片 4 MTU大小的来源:ref https://www.zhihu.com/question/31460305/answer/183766816以太网传输帧的最小值： 最早的以太网工作方式：载波多路复用/冲突检测（CSMA/D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。 假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。 为什么标准以太网帧长度上限为1518字节? IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。 由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 byte那有效传输效率= 160 / 218 = 73%而如果以太网长度为1518，那有效传输效率= 1460 / 1518 = 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题. 于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。 其他疑问： 最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？ 这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到&gt; 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。 有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度&gt;接口MTU，怎么办？丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。 所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？ 我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU = MRU，但比如9000侧的数据到达1500，由于9000 &gt; MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样实践部分：如何设置MTU：ifconfig eth0 mtu 1460如何查看mtu:netstat -i]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[cpp_debug_layout_static]]></title>
    <url>%2F2018%2F05%2F20%2Fcpp-debug-layout-static%2F</url>
    <content type="text"><![CDATA[c compile time memory layout 标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法： 概述：首先介绍几个概念： 程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候； 当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程； 注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码 。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句； 本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c 前言：一个源代码通过编译后生成一个目标文件.o它是一个elf relocatable文件,以下.o文件指此类，elf文件为executable文件.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到 other data ... .comment offset 0x000000c6. .rodata ... //const &amp; str 常量 .data .text .elf header 一个elf文件的结构是这样的：可以通过readelf来看： elfheader 文件头包含了平台信息：/usr/include/elf.h .text 段表 各个段：应用程序也可以自己定义段，和指定变量在哪个段 .data .bss .. other sections section header table string tables 重定位表和字符串表 symbol tables 符号表是链接的接口 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂 可以通过readelf -s xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突 强符号和弱符号（强引用和若引用），调试信息 －g 扩展： １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀； 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o objdump -ht image.o 可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们 具体看文档２）自定义段：attribute((section(“FOO”))) int global=24; attribute((section(“BAR”))) void foo(){} 既可以把变量或函数放入该段中 段名：BAR FOO 正文： 0、先从几个命令：1)size filename:查看elf或.o文件中各个段大小： text data bss dec hex filename 74 0 0 74 4a simplest.o 代码段 数据段 代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null 2)其他工具： readelf -a simplest.o 可以看到更清楚的段信息 objdump -t simplest objdump -h simplest.o 替代size可以看到更多信息 此时显示出来的一些地址并不是装载后的地址 objdump -s -d xx.o: -s 16进制，-d反汇编 －－－查看代码段objdump -s -x -d xx.o: –查看数据段和rodata 3)查看目标文件文件属性如relocatable –.o/executable –elf/share object –.so.. file xxx １、从最简单的程序开始：simplest.cint main() { return 0; } 将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件： # 1 &quot;simplest.c&quot; # 1 &quot;&lt;built-in&gt;&quot; # 1 &quot;&lt;command-line&gt;&quot; # 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4 # 1 &quot;&lt;command-line&gt;&quot; 2 # 1 &quot;simplest.c&quot; int main() { return 0; } 将它进行汇编：gcc -S simplest.c .file “simplest.c” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits 生成.o文件：gcc -c simplest.c并通过file xx.o查看类型simplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped 通过size 查看各个段：size simplest.o: 可以看到只有代码段，数据为空，bss为空，是比较纯净的 text data bss dec hex filename 67 0 0 67 43 simplest.o 接着编译成elf:gcc -o simplest simplest.cfile simplestsimplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped可以看到连接器等信息 size simplest text data bss dec hex filename 1099 544 8 1651 673 simplest注意这里的和.o的文件大小和分段不同， ２、加入头文件和局部变量#include&lt;stdio.h&gt; int main() { int locala; int localb=3; return 0; } 进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数汇编，可以看到分配３到内存中 .file “simplest.c” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits 生成.o文件：可以看到未改变data和bss,但是代码段变大 text data bss dec hex filename 74 0 0 74 4a simplest.o 生成elf:数据区和bss未改变，代码段也未改变？ text data bss dec hex filename 1099 544 8 1651 673 simplest ３、加入已经初始化的局部静态变量：int main() { static int statica=3; .. } 看生成的汇编： .file “simplest.c” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .data .align 4 .type statica.2285, @object //新加的段 .size statica.2285, 4 statica.2285: .long 3 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits .o大小：在静态数据区增加了，４ １个int的长度 text data bss dec hex filename 74 4 0 78 4e simplest.o elf:有点费解，。。 text data bss dec hex filename 1099 548 4 1651 673 simplest ４、加入已经初始化的全局变量和全局静态变量int golbala=6; static long gs=12; 生成的汇编 .file “simplest.c” .globl golbala .data .align 4 .type golbala, @object .size golbala, 4 golbala://变量名 .long 6 .align 8 .type gs, @object .size gs, 8 gs://变量名 .quad 12 .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .data .align 4 .type statica.2287, @object .size statica.2287, 4 statica.2287: .long 3 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits size : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4=20 text data bss dec hex filename 74 20 0 94 5e simplest.o elf size:548–&gt;564 16 text data bss dec hex filename 1099 564 4 1667 683 simplest 5 将 int golbala=6; static long gs=12; 倒换位置！！！！！！！！！ 则对齐成：size x.o为：１６比原来小，可以用于节省内存： text data bss dec hex filename 74 16 0 90 5a simplest.o 汇编： .file “simplest.c” .data .align 8 .type gs, @object .size gs, 8gs: .quad 12 .globl golbala .align 4 .type golbala, @object .size golbala, 4golbala: .long 6 .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE0: .size main, .-main .data .align 4 .type statica.2287, @object .size statica.2287, 4statica.2287: .long 3 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbitself文件的也变小：但bss变大，费解。。 text data bss dec hex filename 1099 560 8 1667 683 simplest 6、加入未初始化的全局变量和全局与局部静态变量 1 #include&lt;stdio.h&gt; 2 static long gs=12; 3 int golbala=6; 4 5 6 static long gsl; 7 int gi; 8 int main() 9 { 10 static int staticn; 11 static int statica=3; 12 int locala; 13 int localb=3; 14 return 0; 15 } 汇编没有看到什么变化： .file “simplest.c” .data .align 8 .type gs, @object .size gs, 8gs: .quad 12 .globl golbala .align 4 .type golbala, @object .size golbala, 4golbala: .long 6 .local gsl .comm gsl,8,8 .comm gi,4,4 .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE0: .size main, .-main .data .align 4 .type statica.2290, @object .size statica.2290, 4statica.2290: .long 3 .local staticn.2289 .comm staticn.2289,4,4 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits .o文件：+12 未包含未初始化的全局变量text data bss dec hex filename 74 16 12 102 66 simplest.o elf:+16 未包含未初始化的全局变量text data bss dec hex filename 1099 560 24 1683 693 simplest 至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同 参考：程序员的自我修养]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_debug_layout_dynamic]]></title>
    <url>%2F2018%2F05%2F20%2Fcpp-debug-layout-dynamic%2F</url>
    <content type="text"><![CDATA[c执行期内存布局和调试：在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等１、将目标文件装入: １）重定位－－－ 放在内存哪里 2) 等待调度执行这里可以使用gdb进行调试查看 一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).一个进程主要包括： 在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等 栈区 高地址到低地址堆区 低地址到高地址bss数据代码 以下将从两个维度进行对一个程序被执行成进程时，内存的情况： １、各种段区的内存分布 ２、gdb 调试程序执行时的过程。－－可能涉及到汇编 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 1、gdb 常用的命令和用法：1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令 2)设置断点： b 行号b 函数名b 行号 if 条件eg:break main / b main 删除断点:delete 行号 3)列出代码l /list 4)运行，start 跳转到断点:c/continue r/run until 行号 运行直到该行5)观察变量b和地址watch b 若变量值发生变化，则程序停止 p/print b 看变量值 p/print &amp;b 看变量地址 i locals info registers 显示所有寄存器的值 查看特定内存位置的值如： print/x $eax 显示为16进制 print/t 2进制， print/d 十进制,x/nyz : n表示字段数，y为输出格式，z是字段长度 ６）单步调试 n/next / s/step 7) 保存断点： info b 查看断点信息 save breakpoint fig.dp 保存断点 读取断点文件： gdb hello -x fig.dp 退出quit http://bbs.chinaunix.net/thread-150524-1-1.html 2 使用kdbg 界面版本gdb 在gcc … -g后，用kdbg打开即可、 查看程序运行时各个地址： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;sys/types.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#define SHW_ADR(ID,I) printf("the id %s \t is at adr:%8X\n",ID,&amp;I);extern etext,edata,end;char *cptr="Hello World\n";char buffer1[25];int main(void)&#123; void showit(char *); int i=0; printf("Adr etext:%8x\tAdr edata:%8x \t Adr end :%8x \n\n",&amp;etext,&amp;edata,&amp;end); SHW_ADR("main",main); SHW_ADR("showit",showit); SHW_ADR("cptr",cptr); SHW_ADR("buffer1",buffer1); SHW_ADR("i",i); strcpy(buffer1,"A demonstration\n"); write(1,buffer1,strlen(buffer1)+1); for(;i&lt;1;++i) showit(cptr); return 0;&#125;void showit(char *p)&#123; char *buffer2; SHW_ADR("buffer2",buffer2); if((buffer2=(char *)malloc((unsigned)(strlen(p)+1)))!=NULL) &#123; strcpy(buffer2,p); printf("%s",buffer2); free(buffer2); &#125; else &#123; printf("Allocation error.\n"); exit(1); &#125;&#125; －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;unistd.h&gt;#include &lt;alloca.h&gt;extern void afunc(void);extern etext,edata,end;int bss_var; //no init globel data must be in bssint data_var=42; //init globel data must be in data#define SHW_ADR(ID,I) printf("the %8s\t is at adr:%8x\n",ID,&amp;I); //the macro to printf the addrint main(int argc,char *argv[])&#123; char *p,*b,*nb; printf("Adr etext:%8x\t Adr edata %8x\t Adr end %8x\t\n",&amp;etext,&amp;edata,&amp;end); printf("\ntext Location:\n"); SHW_ADR("main",main); //text section function SHW_ADR("afunc",afunc); //text section function printf("\nbss Location:\n"); SHW_ADR("bss_var",bss_var); //bss section var printf("\ndata location:\n"); SHW_ADR("data_var",data_var); //data section var printf("\nStack Locations:\n"); afunc(); p=(char *)alloca(32); //alloc memory from statck if(p!=NULL) &#123; SHW_ADR("start",p); SHW_ADR("end",p+31); &#125; b=(char *)malloc(32*sizeof(char)); //malloc memory from heap nb=(char *)malloc(16*sizeof(char)); printf("\nHeap Locations:\n"); printf("the Heap start: %p\n",b); printf("the Heap end:%p\n",(nb+16*sizeof(char))); printf("\nb and nb in Stack\n"); SHW_ADR("b",b); SHW_ADR("nb",nb); free(b); free(nb);&#125;void afunc(void)&#123; static int long level=0; //data section static var int stack_var; //temp var ,in stack section if(++level==5) &#123; return; &#125; SHW_ADR("stack_var in stack section",stack_var); SHW_ADR("Level in data section",level); afunc();&#125;]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_jni]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-jni%2F</url>
    <content type="text"><![CDATA[a example of JNI static way:first step: write a middle java file:mkdir jnicd jni/vim TestJni.java import java.util.*; public class TestJni { public native void xprint(String content); static { System.loadLibrary(&quot;TestJni&quot;); } } javac TestJni.java and make a class then javah -jni TestJni to make a .h file: /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class TestJni */ #ifndef _Included_TestJni #define _Included_TestJni #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: TestJni * Method: xprint * Signature: (Ljava/lang/String;)V */ JNIEXPORT void JNICALL Java_TestJni_xprint (JNIEnv *, jobject, jstring); #ifdef __cplusplus } #endif #endif step two write jni file.c:TestJni.c: #include&lt;jni.h&gt; #include&lt;stdio.h&gt; #include &quot;TestJni.h&quot; JNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content) { const jbyte *str=(const jbyte*)(*env)-&gt;GetStringUTFChars(env,content,JNI_FALSE); printf(&quot;hello--wo%s \n&quot;,str); (*env)-&gt;ReleaseStringUTFChars(env,content,(const char*)str); return; } three build .so libcc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c four write a test:hellow.javaimport java.util.*; public class hellow { public static void main(String argc[]) { new hellow(); } public hellow() { new TestJni().xprint(&quot;hi my name is keee&quot;); } } question:如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径： java -Djava.library.path=’.’ HelloWorld或者输入命令：export LD_LIBRARY_PATH=“HelloWorld路径”:$LD_LIBRARY_PATH 设置环境变量 然后再 java HelloWorld 一样OK referencehttp://www.cnblogs.com/bastard/archive/2012/05/17/2506877.htmlhttp://www.cnblogs.com/wzben/p/5733571.html a example of JNI dynamic way:step 1:write a TestJni.java public class SimpleJni{ static { System.out.println(&quot;[java] static code block,start load shared library...&quot;); System.loadLibrary(&quot;SimpleJni&quot;); System.out.println(&quot;[java]load library end...&quot;); } static native int add(int a,int b); public static void main(String args[]) { System.out.println(&quot;[java] in main...&quot;); System.out.println(&quot;[java] 3+4=&quot;+SimpleJni.add(3,4)); System.out.println(&quot;end...&quot;); } } step 2:write a Jni file: #include &lt;jni.h&gt; #include&lt;stdio.h&gt; const char *classPathName=&quot;com/bt/jni/SimpleJni&quot;; jint myadd(JNIEnv *env,jobject thiz,jint a,jint b) { return a+b; } static JNINativeMethod methods[]={ {&quot;add&quot;,&quot;(II)I&quot;,(void*)myadd},}; int registerNatives(JNIEnv *env) { jclass clazz; clazz=(*env)-&gt;FindClass(env,classPathName); if(NULL==clazz){ printf(&quot;[C] FindClass fail\n&quot;); goto failed; } if (0&gt;(*env)-&gt;RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0]))){ printf(&quot;RegisterNatives fail.\n&quot;); goto failed; } return JNI_TRUE; failed: return JNI_FALSE; } jint JNI_OnLoad(JavaVM *vm,void *reserved) { JNIEnv *env=NULL; jint result=-1; void **env_p=NULL; printf(&quot;start register native func\n&quot;); env_p=(void**)&amp;env; if(JNI_OK!=(*vm)-&gt;GetEnv(vm,env_p,0x00010006)){ printf(&quot;get env failed..\n&quot;); goto err; } if(JNI_TRUE!=registerNatives(env)){ printf(&quot;register fail...exit....\n&quot;); goto err; } result=0x00010006; err: return result; } step use:1.首先编写SimpleJni.java和simpel_jni.c 2.编译java和c文件$ java -d . SimpleJni.java$gcc -fPIC -I$JAVA_HOME/include/ -I$JAVA_HOME/include/linux/ -o libsimpleJni.so simple_jni.c 3.执行 $java -Djava.library.path=. com.bt.jni.SimpleJni other example:java file: import java.util.*; public class TestJni { public native void xprint(String content); static { System.loadLibrary(“TestJni”); } public native static String native_hello(); } JNI file: #include&lt;jni.h&gt; #include&lt;stdio.h&gt; //#include &quot;TestJni.h&quot; #include&lt;iostream&gt; using namespace std; void xprint(JNIEnv *env,jobject obj,jstring content) { // const jbyte *str=(const jbyte*)(env-&gt;GetStringUTFChars(env,content,JNI_FALSE)); //printf(&quot;hello--wo%s \n&quot;,str); // env-&gt;ReleaseStringUTFChars(env,content,(const char*)str); cout&lt;&lt;&quot;here:&quot;&lt;&lt;content&lt;&lt;endl; return; } static jstring native_hello(JNIEnv *env,jobject object) { return (env)-&gt;NewStringUTF(&quot;keshixi&quot;); } static JNINativeMethod method_table[]={ { &quot;xprint&quot;,&quot;(Ljava/lang/String;)V&quot;,(void*)xprint}, {&quot;native_hello&quot;,&quot;()Ljava/lang/String;&quot;,(void*)native_hello} // {,,(void*)xprint},{,,(void*)native_hello} }; jint JNI_OnLoad(JavaVM *jvm,void *reserved){ JNIEnv *env; if(jvm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6)!=JNI_OK){ return -1; } jclass clz=env-&gt;FindClass(&quot;TestJni&quot;); if(clz==NULL) { return JNI_FALSE; } if(env-&gt;RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK){ return JNI_VERSION_1_6; } } ####reference:jni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行 动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子 另外可以作为ndk在android中使用及在android stdio也可以直接生成so 一些链接：android_jni_ndk:http://www.cnblogs.com/wzben/p/5733571.html动态注册无运行实例：http://www.linuxidc.com/Linux/2017-02/140130.htm静态注册：http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html动态注册：有实例http://www.linuxidc.com/Linux/2017-02/140129.htm www.fer.unizg.hr/_download/repository/jni.pdf文档]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_adb]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-adb%2F</url>
    <content type="text"><![CDATA[android adb command从android群英传中学习到额外的几个adb指令，是之前没接触到的：adb list targetsadb install -r xx.apk -r为覆盖adb shell dfadb shell pm list packages -fadb shell input keyevent 3 －－模拟按键输入，这里为点击home建adb shell touchscreen ..模拟滑动adb shell dumpsys 监听Activity运行状态adb shell screenrecord /sdcard/demo.mp4 录制 屏幕adb shell am start -n 包名/包名＋类名 更多，见google develop中android studio的部分另在源码目录中/system/core/toolbox 和/frameworks/base/cmds为所有ADB命令和shell命令来源]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_AndroidManifest]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-AndroidManifest%2F</url>
    <content type="text"><![CDATA[一个典型的androidmanifest文件：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.ksx.helloworld&quot;&gt; &lt;!-- more --&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;hallo&quot;//app的名字和显示在bar上的文字 android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt;//活动的注册 &lt;android:label=&quot;this is hallo&quot;&gt;//会覆盖上面的 &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;//声明为主活动 &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_makefirst_app]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-makefirst-app%2F</url>
    <content type="text"><![CDATA[install and make first app20170608今天主要是安装了android-studio环境并成功开发第一个helloworld app 在模拟器和手机上运行，下面是整个教程：在ubuntu下 1 安装java-jdk:a 先下载java-jdk:Java SE Development Kit 8 Downloadshttp://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html下载对应系统的版本 b 下载到某个目录，解压到要安装的目录：如：/usr/jdk-8/ c 设置全局环境变量：如上述的安装目录，则将export JAVA_HOME=/usr/jdk-8export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin添加到/etc/profile文件中，在末尾另起一行添加 d 使用source /etc/profile命令使刚才配置的信息生效 e 测试是否成功：java -version测试,编写java文件：public class test{ public static void main(String[] args){ System.out.println(“hello world”); }}保存为test.java，生成字节码：javac test.java运行:java test 2 安装android-studio:a 下载：在官网或者其他网站下载后b 按照installion说明进行：一般是先选择要安装的目录：如/usr/android-studioc 直接在终端,进入bin目录后:./studio.shd 还有其他配置．比如在任意目录都能打开软件．e 其他见说明文件等 3 第一个app helloworld在模拟器上运行打开软件－－&gt;选择新建一个工程，适当选择之后-&gt;选择build-&gt;make project-&gt;点击run––&gt;会提示选择安装下载模拟器–&gt;选择合适的，最好不要是带锁的－－－&gt;之后会提示成功．再选择建立一个模拟器，之后就可以了 注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm如果不能运行x86的，可能需要安装kvm:也可以使用genymotion模拟器 4 安装kvm可选要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。首先要确定你的cpu满足要求，下面有几个命令可以参考： $ egrep -c ‘(vmx|svm)’ /proc/cpuinfo4 打印的值不为0即可。 下面安装kvm： $ sudo apt-get install qemu-kvm$ sudo adduser linc kvm$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils$ sudo adduser linc libvirtd (linc为用户名，适当改）检验安装是否成功： $ sudo virsh -c qemu:///system list Id Name State运行，在有模拟器的目录中：如/home/ksx/Android/Sdk/emulator/emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm 使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。 如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。 5在手机上运行app首先连接手机，打开usb调试还是一样，但是选择app那里不是app,而是选择Edit Configurations之后选择usb device，ok，就可以了，接着运行 关于项目结构模式：默认为android设置为project可以看到整个完整的目录结构： .gradle和.idea 为自动生成 app build 编译时自动生成的文件，不用太关心 gradle 包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle .gitignore build.gradle gradle.properties 全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本 gradlew 和gradlew.bat在命令行中执行gradle命令 local.properties 指定本机android sdk路径 setting.gradle指定项目中引入的模块 app目录下 build 为自动生成，同上 lib 项目使用的第三方库 test 测试用例 proguard-rules.pro 代码混淆规则 build gradle intruducegradle Groovy 领域语言 DSL 摒弃了Ant 和Maven 在app 外有一个 build.gradle。在app中有一个build.gradle 在外面的 gradle 也可以构建c++等项目，buildscript { repositories { jcenter() //代码托管仓库 利用它可以轻松引用jcenter开源项目 } dependencies { classpath &apos;com.android.tools.build:gradle:2.3.2&apos; //声明构建的是android // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { jcenter() }} task clean(type: Delete) { delete rootProject.buildDir} app中apply plugin: ‘com.android.application’ //表明为android 应用程序模块，为com.android.library表示库模块 android { //安卓闭包 compileSdkVersion 25 //项目的编译版本，25为API 25,对应android 7.1 buildToolsVersion “25.0.3” //项目构建工具版本 defaultConfig { applicationId “org.example.myactivity1” 项目包名 minSdkVersion 25 //项目最低兼容的android系统版本 targetSdkVersion 25 //表明如22表示只在22测试充分，如不启动运行时权限，android６ 的运行时权限就不会加，表明只在5上做充分测试 versionCode 1 项目版本编号 versionName “1.0” 项目版本名 testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner” } buildTypes {//分debug和release版本 release { minifyEnabled false //是否混淆代码 proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’//混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件 } }} dependencies {//分本地依赖，库依赖和远程依赖 compile fileTree(dir: ‘libs’, include: [‘*.jar’]) //本地依赖声明 androidTestCompile(‘com.android.support.test.espresso:espresso-core:2.2.2’, { exclude group: ‘com.android.support’, module: ‘support-annotations’ }) compile ‘com.android.support:appcompat-v7:25.3.1’ // 依赖库 compile ‘com.android.support.constraint:constraint-layout:1.0.2’ testCompile ‘junit:junit:4.12’ //测试用例库} 其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_howto_makeapk_cmd]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-howto-makeapk-cmd%2F</url>
    <content type="text"><![CDATA[how to make a android by cmd :在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni way 1:方法１prepareandroid studio 创建了一个工程，然后手动在命令行打包，进入工程里的. 或者direct use andrid create project创建 cd ~/Desktop/FirstTest/app/src/mainmkdir genmkdir buildmkdir out 在android工程目录下建立Makefile文件，添加如下代码： SDK=~/Android/Sdk BUILD_TOOLS=$(SDK)/build-tools/25.0.3 PLATFORMS=$(SDK)/platforms/android-25 aapt=$(BUILD_TOOLS)/aapt dx=$(BUILD_TOOLS)/dx aidl=$(BUILD_TOOLS)/aidl apkbuilder=$(SDK)/tools/apkbuilder2 //后面不支持apkbuilder所以 adb=$(SDK)/platform-tools/adb 资源编译，生成 R.javaaapt_task: $(aapt) package \ -f \ #如果编译出来的文件已经存在，强制覆盖 -M AndroidManifest.xml \ # Mainifest.xml 的路径 -I $(PLATFORMS)/android.jar \ # 某个版本平台的 android.jar 的路径 #依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:... -S res/ \ # res 文件夹路径 -J gen/ \ # 生成 R.java 的输出目录 -m #使得生成的包的目录放在 -J 参数指定的目录 代码编译，生成 .classjavac_task: javac -source 1.7 -target 1.7 \ # 使用 jdk1.8 编译 1.7 的 .class 文件 -encoding UTF-8 \ -bootclasspath $(PLATFORMS)/android.jar \ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:... -d build/ \ #指定放置生成的类文件的位置 java/thereisnospon/dextest/*.java \ gen/thereisnospon/dextest/*.java \ 生成 .dexdx_task: $(dx) --dex --output=build/classes.dex \ build 资源文件初始包resapk_task: $(aapt) package -f \ -M AndroidManifest.xml \ -I $(PLATFORMS)/android.jar \ -S res/ \ -F out/resources 将.dex 文件加入到资源文件初始包中 注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行 apk_task: java -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \ com.android.sdklib.build.ApkBuilderMain \ Demo.apk -v -u -z src/main/out/resources\ -f src/main/build/classes.dex -rf src 签名，使用debug的签名signer: jarsigner -verbose \ -keystore ~/.android/debug.keystore \ -storepass android \ -keypass android \ Demo.apk androiddebugkey 一次性打包pkg: make apk_task make signer 卸载apkuninstall: $(adb) uninstall thereisnospon.dextest 安装apkinstall: $(adb) install out/app.apk 运行run: make pkg make uninstall make install $(adb) shell am start -n thereisnospon.dextest/ thereisnospon.dextest.MainActivity 方法２，用gradle,首先用AS 建立工程，之后在工程文件下，之星执行，gradle cleangradle build即生成apk文件]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_will_write]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-will-write%2F</url>
    <content type="text"><![CDATA[#test categoriesthis is the android categories to test]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test_article_picture]]></title>
    <url>%2F2018%2F05%2F20%2Ftest-article-picture%2F</url>
    <content type="text"><![CDATA[##this is a test of pictureend]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ksance test article]]></title>
    <url>%2F2018%2F05%2F19%2Fksance-test-article%2F</url>
    <content type="text"><![CDATA[this is a test article by ksance]]></content>
  </entry>
</search>
