<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>tcpip_tc</title>
    <url>/2021/05/22/tcpip-tc/</url>
    <content><![CDATA[<h3 id="流量控制概述"><a href="#流量控制概述" class="headerlink" title="流量控制概述"></a>流量控制概述</h3><p>linux下通过tc traffic control 框架及系列实现和工具来实现对出口，甚至入口流量的控制，所谓的控制，就是进行包延迟传输，<br>丢包，包损坏，带宽限制，针对某个ip规则进行限制等等，来达到模拟网络异常状况，包优先级传输，或者更多功能；<a id="more"></a><br>从手册上看：主要提供一下几种控制：<br>SHAPING: 平滑突发流量，如限制传输速率，小于有效带宽，作用于出口<br>       When traffic is shaped, its rate of transmission is under<br>       control. Shaping may be more than lowering the available<br>       bandwidth - it is also used to smooth out bursts in<br>       traffic for better network behaviour. Shaping occurs on<br>       egress.<br>SCHEDULING : 作用于出口，调度数据包的传输，比如优先级等<br>       By scheduling the transmission of packets it is possible<br>       to improve interactivity for traffic that needs it while<br>       still guaranteeing bandwidth to bulk transfers. Reordering<br>       is also called prioritizing, and happens only on egress.<br>POLICING： 作用于入口流量<br>       Whereas shaping deals with transmission of traffic,<br>       policing pertains to traffic arriving. Policing thus<br>       occurs on ingress.<br>DROPPING： 当流量超过阈值，丢弃数据包，作用于入口和出口；<br>       Traffic exceeding a set bandwidth may also be dropped<br>       forthwith, both on ingress and on egress.<br><!--more--></p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>ref:  <a href="https://netbeez.net/blog/how-to-use-the-linux-traffic-control/" target="_blank" rel="noopener">https://netbeez.net/blog/how-to-use-the-linux-traffic-control/</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">查看：当前只有默认的先入先出规则</span><br><span class="line">think@think-VirtualBox:~$ tc qdisc</span><br><span class="line">qdisc noqueue <span class="number">0</span>: dev lo root refcnt <span class="number">2</span> </span><br><span class="line">qdisc pfifo_fast <span class="number">0</span>: dev eth0 root refcnt <span class="number">2</span> bands <span class="number">3</span> priomap  <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">准备设置延迟：</span><br><span class="line">think@think-VirtualBox:~$ ping www.baidu.com</span><br><span class="line">PING www.baidu.com (<span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">56</span> time=<span class="number">9.13</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">56</span> time=<span class="number">9.38</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">56</span> time=<span class="number">9.09</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">56</span> time=<span class="number">9.68</span> ms</span><br><span class="line">^C</span><br><span class="line">--- www.baidu.com ping statistics ---</span><br><span class="line"><span class="number">4</span> packets transmitted, <span class="number">4</span> received, <span class="number">0</span>% packet loss, time <span class="number">7048</span>ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">9.093</span>/<span class="number">9.324</span>/<span class="number">9.687</span>/<span class="number">0.256</span> ms</span><br><span class="line"></span><br><span class="line">添加延迟规则：</span><br><span class="line">think@think-VirtualBox:~$ sudo tc qdisc add dev eth0 root netem delay <span class="number">200</span>ms</span><br><span class="line"></span><br><span class="line">think@think-VirtualBox:~$ ping www.baidu.com</span><br><span class="line">PING www.baidu.com (<span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">56</span> time=<span class="number">209</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">56</span> time=<span class="number">212</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">56</span> time=<span class="number">211</span> ms</span><br><span class="line"></span><br><span class="line">删除规则： sudo tc qdisc del dev eth0 root netem delay <span class="number">200</span>ms</span><br><span class="line">/ sudo tc qdisc del dev eth0 root </span><br><span class="line"></span><br><span class="line">设置丢包规则：</span><br><span class="line">think@think-VirtualBox:~$ sudo tc qdisc add dev eth0 root netem loss <span class="number">20</span>%</span><br><span class="line">[sudo] password <span class="keyword">for</span> think: </span><br><span class="line">think@think-VirtualBox:~$ ping www.baidu.com -c <span class="number">100</span></span><br><span class="line">PING www.baidu.com (<span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">56</span> time=<span class="number">9.68</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">56</span> time=<span class="number">8.92</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">56</span> time=<span class="number">8.92</span> ms</span><br><span class="line">。。。</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">100</span> ttl=<span class="number">56</span> time=<span class="number">10.1</span> ms</span><br><span class="line"></span><br><span class="line">--- www.baidu.com ping statistics ---</span><br><span class="line"><span class="number">100</span> packets transmitted, <span class="number">80</span> received, <span class="number">20</span>% packet loss, time <span class="number">103846</span>ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">8.510</span>/<span class="number">9.537</span>/<span class="number">23.505</span>/<span class="number">1.655</span> ms</span><br><span class="line">删除规则：</span><br><span class="line">think@think-VirtualBox:~$ sudo tc qdisc del dev eth0 root netem loss <span class="number">20</span>%</span><br><span class="line"></span><br><span class="line">设置带宽限制规则：</span><br><span class="line">tc qdisc add dev eth0 root tbf rate <span class="number">1</span>mbit burst <span class="number">32</span>kbit latency <span class="number">400</span>ms</span><br><span class="line"></span><br><span class="line">tbf: use the token buffer filter to manipulate traffic rates</span><br><span class="line">rate: sustained maximum rate</span><br><span class="line">burst: maximum allowed burst</span><br><span class="line">latency: packets with higher latency get dropped</span><br><span class="line"></span><br><span class="line">通过iperf测试：</span><br><span class="line">iperf -c <span class="number">172.31</span><span class="number">.0</span><span class="number">.142</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Client connecting to <span class="number">172.31</span><span class="number">.0</span><span class="number">.142</span>, TCP port <span class="number">5001</span></span><br><span class="line">TCP window size: <span class="number">85.3</span> KByte (<span class="keyword">default</span>)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">[  <span class="number">3</span>] local <span class="number">172.31</span><span class="number">.0</span><span class="number">.25</span> port <span class="number">40233</span> connected with <span class="number">172.31</span><span class="number">.0</span><span class="number">.142</span> port <span class="number">5001</span></span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  <span class="number">3</span>]  <span class="number">0.0</span><span class="number">-10.0</span> sec   <span class="number">113</span> MBytes  <span class="number">95.0</span> Mbits/sec ---&gt; <span class="number">1.1</span>Mbits/sec</span><br></pre></td></tr></table></figure></p>
<ul>
<li>指令解释：<br>qdisc: modify the scheduler (aka queuing discipline) 即实际的使用是依赖的qidsc机制<br>add: add a new rule 添加一个排队规则<br>dev eth0: rules will be applied on device eth0 排队规则作用对象一般是网卡<br>root: modify the outbound traffic scheduler (aka known as the egress qdisc) 修改出口流量调度程序<br>netem: use the network emulator to emulate a WAN property 使用wan网络模拟器<br>delay: the network property that is modified<br>200ms: introduce delay of 200 ms</li>
</ul>
<p>tc是系统如linux提供的用户层操作指令，这里用的是shell指令：<br>更多  <a href="https://man7.org/linux/man-pages/man8/tc.8.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man8/tc.8.html</a> </p>
<h3 id="流量控制的基本实现原理"><a href="#流量控制的基本实现原理" class="headerlink" title="流量控制的基本实现原理"></a>流量控制的基本实现原理</h3><p>在linux内核中，流量控制用Qos实现，实际上使用了qdisc队列；主要是出口队列；（egress)<br>在链路层，每个数据包通过邻居子系统后，或者说离开协议栈后，都会由dev_queue_xmit(dev.c)来进一步调用相关设备驱动的发送函数<br>来发送出去； 而qdisc队列，和相关的排队规则即作用在dev_queue_xmit之后，设备驱动发送函数之前；</p>
<h3 id="流量控制的实现和基本流程："><a href="#流量控制的实现和基本流程：" class="headerlink" title="流量控制的实现和基本流程："></a>流量控制的实现和基本流程：</h3><h4 id="相关代码："><a href="#相关代码：" class="headerlink" title="相关代码："></a>相关代码：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sch_generic.c</span><br><span class="line">sch_generic.h</span><br><span class="line">sch_api.c</span><br><span class="line">pkt_sched.h</span><br><span class="line">net/core/dev.c</span><br></pre></td></tr></table></figure>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>在内核中的整体处理流程，及位置：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">net/core/dev.c</span><br><span class="line">int dev_queue_xmit(struct sk_buff *skb) --发送函数</span><br><span class="line">    <span class="comment">// 1 从设备中拿到设备下的qdisc结构，每个设备net_device结构都有</span></span><br><span class="line">  	txq = netdev_pick_tx(dev, skb, accel_priv);</span><br><span class="line">	q = rcu_dereference_bh(txq-&gt;qdisc);</span><br><span class="line"></span><br><span class="line">	trace_net_dev_queue(skb);</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;enqueue) &#123;</span><br><span class="line">		rc = __dev_xmit_skb(skb, q, dev, txq);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//2 插入根排队规则中，并启动运行：</span></span><br><span class="line">	rc = q-&gt;enqueue(skb, q, &amp;to_free) &amp; NET_XMIT_MASK; <span class="comment">//插入根排队规则</span></span><br><span class="line">		<span class="keyword">if</span> (qdisc_run_begin(q)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(contended)) &#123;</span><br><span class="line">				spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">				contended = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			__qdisc_run(q);<span class="comment">//会走netif_schedule来调度数据包输出软中断 net_tx_action,然后在合适的时机，比如延迟200ms，发送数据包；</span></span><br><span class="line">			在调度前会检查网络设备的启动情况，以及是否已经在调度了；</span><br><span class="line">			<span class="keyword">void</span> __qdisc_run(struct Qdisc *q)</span><br><span class="line">              &#123;</span><br><span class="line">              	<span class="keyword">int</span> quota = weight_p;</span><br><span class="line">              	<span class="keyword">int</span> packets;</span><br><span class="line">              </span><br><span class="line">              	<span class="keyword">while</span> (qdisc_restart(q, &amp;packets)) &#123;</span><br><span class="line">              		<span class="comment">/*</span></span><br><span class="line"><span class="comment">              		 * Ordered by possible occurrence: Postpone processing if</span></span><br><span class="line"><span class="comment">              		 * 1. we've exceeded packet quota</span></span><br><span class="line"><span class="comment">              		 * 2. another process needs the CPU;</span></span><br><span class="line"><span class="comment">              		 */</span></span><br><span class="line">              		quota -= packets;</span><br><span class="line">              		<span class="keyword">if</span> (quota &lt;= <span class="number">0</span> || need_resched()) &#123;</span><br><span class="line">              			__netif_schedule(q);</span><br><span class="line">              			<span class="keyword">break</span>;</span><br><span class="line">              		&#125;</span><br><span class="line">              	&#125;</span><br><span class="line">              </span><br><span class="line">              	qdisc_run_end(q);</span><br><span class="line">              &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    dev.c:</span><br><span class="line">	net_tx_action:</span><br><span class="line">	smp_mb__before_atomic();</span><br><span class="line">			clear_bit(__QDISC_STATE_SCHED, &amp;q-&gt;state);</span><br><span class="line">			qdisc_run(q);</span><br><span class="line">			spin_unlock(root_lock);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3 qdisc_run/ __qdisc_run都会调用qdisc_restart，当可以发送时</span></span><br><span class="line">	<span class="comment">//这个restart函数，将包从根排队规则中取出，然后调用设备发送函数发送：</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qdisc_restart</span><span class="params">(struct Qdisc *q, <span class="keyword">int</span> *packets)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">netdev_queue</span> *<span class="title">txq</span>;</span></span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    	<span class="keyword">spinlock_t</span> *root_lock;</span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    	<span class="keyword">bool</span> validate;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">/* Dequeue packet */</span></span><br><span class="line">    	skb = dequeue_skb(q, &amp;validate, packets);</span><br><span class="line">    	<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    	root_lock = qdisc_lock(q);</span><br><span class="line">    	dev = qdisc_dev(q);</span><br><span class="line">    	txq = skb_get_tx_queue(dev, skb);</span><br><span class="line">         <span class="comment">//4 发送</span></span><br><span class="line">    	<span class="keyword">return</span> sch_direct_xmit(skb, q, dev, txq, root_lock, validate);----&gt;ops-&gt;ndo_start_xmit(skb, dev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="流量控制的结构："><a href="#流量控制的结构：" class="headerlink" title="流量控制的结构："></a>流量控制的结构：</h4><p>构成流量控制的基本元素有三种： 排队规则，类和过滤器<br><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">排队规则1:0</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>  <span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">根排队规则，提供两个外部接口，enqueue和dequeue</span></span><br><span class="line"><span class="comment"></span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">过滤器1</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">过滤器2</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">过滤器3</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="literal">-</span><span class="literal">-</span><span class="comment">类1:1</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(类</span>  <span class="comment">1:2</span>  <span class="comment">)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="literal">-</span><span class="literal">-</span><span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="literal">-</span><span class="literal">-</span><span class="comment">排队规则2:0</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">排队规则3:0</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">内部规则</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>排队规则：<br>  在启用了流量控制的情况下，每个网络设备至少会配置一个排队规则；排队规则包括简单的fifo缓冲和令牌桶等，而精确的排队规则通常需要管理多个队列；<br>常见的排队规则由 fifo,令牌桶tbf(token bucket filter)等；</li>
<li>排队规则的分类：<br>排队规则至少有一个队列，可能简单，如fifo排队规则，也有复杂如令牌桶；通常排队规则分无类和有类两种，无类规则简单，内部不能包含可配置的子类及内部规则<br>而有类则可包含多个类，如上图，且每个类又可以包含一个排队规则，这里的排队规则叫内部规则，可以是有类和无类的；<br>无类规则不可被用户配置，而有类的可以；<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">   分为可分类的qdisc和不可分类的qdisc实现：</span><br><span class="line">不可分类：pfifo ,pfifo_fast,<span class="built_in">red</span>,sfq,tbf</span><br><span class="line">可分类：cbq,htb,prio</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如默认：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">qdisc pfifo_fast <span class="number">0</span>: dev eth0 root refcnt <span class="number">2</span> bands <span class="number">3</span> priomap  <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>在tc指令中，如下的，其中结尾的 qdisc [qdisc specific parameters] 就是指定具体的排队规则类型；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">创建qdisc 规则</span><br><span class="line">tc [ OPTIONS ] qdisc [ add | change | replace | link | <span class="keyword">delete</span> ]</span><br><span class="line">       dev DEV [ parent qdisc-id | root ] [ handle qdisc-id ] [</span><br><span class="line">       ingress_block BLOCK_INDEX ] [ egress_block BLOCK_INDEX ] qdisc [</span><br><span class="line">       qdisc specific parameters ]</span><br><span class="line">eg:</span><br><span class="line"></span><br><span class="line">目前支持的qdisc: 无类的：</span><br><span class="line">The classless qdiscs are:</span><br><span class="line"></span><br><span class="line">       <span class="function">choke  <span class="title">CHOKe</span> <span class="params">(CHOose <span class="keyword">and</span> Keep <span class="keyword">for</span> responsive flows, CHOose <span class="keyword">and</span></span></span></span><br><span class="line"><span class="function"><span class="params">              Kill <span class="keyword">for</span> unresponsive flows)</span> is a classless qdisc designed</span></span><br><span class="line"><span class="function">              to both identify <span class="keyword">and</span> penalize flows that monopolize the</span></span><br><span class="line">              queue. CHOKe is a variation of RED, and the configuration</span><br><span class="line">              is similar to RED.</span><br><span class="line"></span><br><span class="line">       codel  CoDel (pronounced "coddle") is an adaptive "no-knobs"</span><br><span class="line">              <span class="function">active <span class="built_in">queue</span> management <span class="title">algorithm</span> <span class="params">(AQM)</span> scheme that was</span></span><br><span class="line"><span class="function">              developed to address the shortcomings of RED <span class="keyword">and</span> its</span></span><br><span class="line">              variants.</span><br><span class="line"></span><br><span class="line">       [p|b]fifo</span><br><span class="line">              Simplest usable qdisc, pure First In, First Out behaviour.</span><br><span class="line">              Limited in packets <span class="keyword">or</span> in bytes.</span><br><span class="line"></span><br><span class="line">       fq     Fair Queue Scheduler realises TCP pacing <span class="keyword">and</span> scales to</span><br><span class="line">              millions of concurrent flows per qdisc.</span><br><span class="line"></span><br><span class="line">       fq_codel</span><br><span class="line">              Fair Queuing Controlled Delay is queuing discipline that</span><br><span class="line">              combines Fair Queuing with the CoDel AQM scheme. FQ_Codel</span><br><span class="line">              uses a stochastic model to classify incoming packets into</span><br><span class="line">              different flows <span class="keyword">and</span> is used to provide a fair share of the</span><br><span class="line">              bandwidth to all the flows <span class="keyword">using</span> the <span class="built_in">queue</span>. Each such flow</span><br><span class="line">              is managed by the CoDel queuing discipline. Reordering</span><br><span class="line">              within a flow is avoided since Codel internally uses a</span><br><span class="line">              FIFO <span class="built_in">queue</span>.</span><br><span class="line"></span><br><span class="line">       fq_pie FQ-PIE (Flow Queuing with Proportional Integral controller</span><br><span class="line">              Enhanced) is a queuing discipline that combines Flow</span><br><span class="line">              Queuing with the PIE AQM scheme. FQ-PIE uses a Jenkins</span><br><span class="line">              hash function to classify incoming packets into different</span><br><span class="line">              flows <span class="keyword">and</span> is used to provide a fair share of the bandwidth</span><br><span class="line">              to all the flows <span class="keyword">using</span> the qdisc. Each such flow is</span><br><span class="line">              managed by the PIE algorithm.</span><br><span class="line"></span><br><span class="line">       gred   Generalized Random Early Detection combines multiple RED</span><br><span class="line">              queues in order to achieve multiple drop priorities. This</span><br><span class="line">              is required to realize Assured Forwarding (RFC 2597).</span><br><span class="line"></span><br><span class="line">       hhf    Heavy-Hitter Filter differentiates between small flows <span class="keyword">and</span></span><br><span class="line">              the opposite, heavy-hitters. The goal is to <span class="keyword">catch</span> the</span><br><span class="line">              heavy-hitters <span class="keyword">and</span> move them to a separate <span class="built_in">queue</span> with less</span><br><span class="line">              priority so that bulk traffic does <span class="keyword">not</span> affect the latency</span><br><span class="line">              of critical traffic.</span><br><span class="line"></span><br><span class="line">       ingress</span><br><span class="line">              This is a special qdisc as it applies to incoming traffic</span><br><span class="line">              on an interface, allowing <span class="keyword">for</span> it to be filtered <span class="keyword">and</span></span><br><span class="line">              policed.</span><br><span class="line"></span><br><span class="line">       mqprio The Multiqueue Priority Qdisc is a simple queuing</span><br><span class="line">              discipline that allows mapping traffic flows to hardware</span><br><span class="line">              <span class="built_in">queue</span> ranges <span class="keyword">using</span> priorities <span class="keyword">and</span> a configurable priority</span><br><span class="line">              to traffic <span class="class"><span class="keyword">class</span> <span class="title">mapping</span>. <span class="title">A</span> <span class="title">traffic</span> <span class="title">class</span> <span class="title">in</span> <span class="title">this</span> <span class="title">context</span></span></span><br><span class="line"><span class="class">              <span class="title">is</span> <span class="title">a</span> <span class="title">set</span> <span class="title">of</span> <span class="title">contiguous</span> <span class="title">qdisc</span> <span class="title">classes</span> <span class="title">which</span> <span class="title">map</span> 1:</span><span class="number">1</span> to a</span><br><span class="line">              <span class="built_in">set</span> of hardware exposed queues.</span><br><span class="line"></span><br><span class="line">       multiq Multiqueue is a qdisc optimized <span class="keyword">for</span> devices with multiple</span><br><span class="line">              Tx queues. It has been added <span class="keyword">for</span> hardware that wishes to</span><br><span class="line">              avoid head-of-line blocking.  It will cycle though the</span><br><span class="line">              bands <span class="keyword">and</span> verify that the hardware <span class="built_in">queue</span> associated with</span><br><span class="line">              the band is <span class="keyword">not</span> stopped prior to dequeuing a packet.</span><br><span class="line"></span><br><span class="line">       netem  Network Emulator is an enhancement of the Linux traffic</span><br><span class="line">              control facilities that allow to add delay, packet loss,</span><br><span class="line">              duplication <span class="keyword">and</span> more other characteristics to packets</span><br><span class="line">              outgoing from a selected network interface.</span><br><span class="line"></span><br><span class="line">       pfifo_fast</span><br><span class="line">              Standard qdisc for 'Advanced Router' enabled kernels.</span><br><span class="line">              Consists of a three-band <span class="built_in">queue</span> which honors Type of</span><br><span class="line">              Service flags, as well as the priority that may be</span><br><span class="line">              assigned to a packet.</span><br><span class="line"></span><br><span class="line">       pie    Proportional Integral controller-Enhanced (PIE) is a</span><br><span class="line">              control theoretic active <span class="built_in">queue</span> management scheme. It is</span><br><span class="line">              based on the proportional integral controller but aims to</span><br><span class="line">              control delay.</span><br><span class="line"></span><br><span class="line">       red    Random Early Detection simulates physical congestion by</span><br><span class="line">              randomly dropping packets when nearing configured</span><br><span class="line">              bandwidth allocation. Well suited to very large bandwidth</span><br><span class="line">              applications.</span><br><span class="line"></span><br><span class="line">       rr     Round-Robin qdisc with support <span class="keyword">for</span> multiqueue network</span><br><span class="line">              devices. Removed from Linux since kernel version <span class="number">2.6</span><span class="number">.27</span>.</span><br><span class="line"></span><br><span class="line">       sfb    Stochastic Fair Blue is a classless qdisc to manage</span><br><span class="line">              congestion based on packet loss <span class="keyword">and</span> link utilization</span><br><span class="line">              history <span class="keyword">while</span> trying to prevent non-<span class="function">responsive <span class="title">flows</span> <span class="params">(i.e.</span></span></span><br><span class="line"><span class="function"><span class="params">              flows that <span class="keyword">do</span> <span class="keyword">not</span> react to congestion marking <span class="keyword">or</span> dropped</span></span></span><br><span class="line">              packets) from impacting performance of responsive flows.</span><br><span class="line">              Unlike RED, where the marking probability has to be</span><br><span class="line">              configured, BLUE tries to determine the ideal marking</span><br><span class="line">              probability automatically.</span><br><span class="line"></span><br><span class="line">       sfq    Stochastic Fairness Queueing reorders queued traffic so</span><br><span class="line">              each 'session' gets to send a packet in turn.</span><br><span class="line"></span><br><span class="line">       tbf    The Token Bucket Filter is suited <span class="keyword">for</span> slowing traffic down</span><br><span class="line">              to a precisely configured rate. Scales well to large</span><br><span class="line">              bandwidths.</span><br><span class="line">无类的，在添加规则时需要注意：</span><br><span class="line">In the absence of classful qdiscs, classless qdiscs can only be</span><br><span class="line">       attached at the root of a device. Full syntax:</span><br><span class="line">       tc qdisc add dev DEV root QDISC QDISC-PARAMETERS</span><br><span class="line">To remove, issue</span><br><span class="line">       tc qdisc del dev DEV root</span><br><span class="line"> The pfifo_fast qdisc is the automatic <span class="keyword">default</span> in the absence of a</span><br><span class="line">       configured qdisc.</span><br><span class="line">有类的：</span><br><span class="line"></span><br><span class="line">       ATM    Map flows to <span class="keyword">virtual</span> circuits of an underlying</span><br><span class="line">              asynchronous transfer mode device.</span><br><span class="line"></span><br><span class="line">       CBQ    Class Based Queueing implements a rich linksharing</span><br><span class="line">              hierarchy of classes.  It contains shaping elements as</span><br><span class="line">              well as prioritizing capabilities. Shaping is performed</span><br><span class="line">              <span class="keyword">using</span> link idle time calculations based on average packet</span><br><span class="line">              size <span class="keyword">and</span> underlying link bandwidth. The latter may be ill-</span><br><span class="line">              defined <span class="keyword">for</span> some interfaces.</span><br><span class="line"></span><br><span class="line">       DRR    The Deficit Round Robin Scheduler is a more flexible</span><br><span class="line">              replacement <span class="keyword">for</span> Stochastic Fairness Queuing. Unlike SFQ,</span><br><span class="line">              there are no built-in queues -- you need to add classes</span><br><span class="line">              <span class="keyword">and</span> then <span class="built_in">set</span> up filters to classify packets accordingly.</span><br><span class="line">              This can be useful e.g. <span class="keyword">for</span> <span class="keyword">using</span> RED qdiscs with</span><br><span class="line">              different settings <span class="keyword">for</span> particular traffic. There is no</span><br><span class="line">              <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> -- <span class="title">if</span> <span class="title">a</span> <span class="title">packet</span> <span class="title">cannot</span> <span class="title">be</span> <span class="title">classified</span>, <span class="title">it</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">              <span class="title">dropped</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">       <span class="title">DSMARK</span> <span class="title">Classify</span> <span class="title">packets</span> <span class="title">based</span> <span class="title">on</span> <span class="title">TOS</span> <span class="title">field</span>, <span class="title">change</span> <span class="title">TOS</span> <span class="title">field</span> <span class="title">of</span></span></span><br><span class="line"><span class="class">              <span class="title">packets</span> <span class="title">based</span> <span class="title">on</span> <span class="title">classification</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">       <span class="title">ETS</span>    <span class="title">The</span> <span class="title">ETS</span> <span class="title">qdisc</span> <span class="title">is</span> <span class="title">a</span> <span class="title">queuing</span> <span class="title">discipline</span> <span class="title">that</span> <span class="title">merges</span></span></span><br><span class="line"><span class="class">              <span class="title">functionality</span> <span class="title">of</span> <span class="title">PRIO</span> <span class="title">and</span> <span class="title">DRR</span> <span class="title">qdiscs</span> <span class="title">in</span> <span class="title">one</span> <span class="title">scheduler</span>. <span class="title">ETS</span></span></span><br><span class="line"><span class="class">              <span class="title">makes</span> <span class="title">it</span> <span class="title">easy</span> <span class="title">to</span> <span class="title">configure</span> <span class="title">a</span> <span class="title">set</span> <span class="title">of</span> <span class="title">strict</span> <span class="title">and</span> <span class="title">bandwidth</span>-</span></span><br><span class="line"><span class="class">              <span class="title">sharing</span> <span class="title">bands</span> <span class="title">to</span> <span class="title">implement</span> <span class="title">the</span> <span class="title">transmission</span> <span class="title">selection</span></span></span><br><span class="line"><span class="class">              <span class="title">described</span> <span class="title">in</span> 802.1<span class="title">Qaz</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">       <span class="title">HFSC</span>   <span class="title">Hierarchical</span> <span class="title">Fair</span> <span class="title">Service</span> <span class="title">Curve</span> <span class="title">guarantees</span> <span class="title">precise</span></span></span><br><span class="line"><span class="class">              <span class="title">bandwidth</span> <span class="title">and</span> <span class="title">delay</span> <span class="title">allocation</span> <span class="title">for</span> <span class="title">leaf</span> <span class="title">classes</span> <span class="title">and</span></span></span><br><span class="line"><span class="class">              <span class="title">allocates</span> <span class="title">excess</span> <span class="title">bandwidth</span> <span class="title">fairly</span>. <span class="title">Unlike</span> <span class="title">HTB</span>, <span class="title">it</span> <span class="title">makes</span></span></span><br><span class="line"><span class="class">              <span class="title">use</span> <span class="title">of</span> <span class="title">packet</span> <span class="title">dropping</span> <span class="title">to</span> <span class="title">achieve</span> <span class="title">low</span> <span class="title">delays</span> <span class="title">which</span></span></span><br><span class="line"><span class="class">              <span class="title">interactive</span> <span class="title">sessions</span> <span class="title">benefit</span> <span class="title">from</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">       <span class="title">HTB</span>    <span class="title">The</span> <span class="title">Hierarchy</span> <span class="title">Token</span> <span class="title">Bucket</span> <span class="title">implements</span> <span class="title">a</span> <span class="title">rich</span> <span class="title">linksharing</span></span></span><br><span class="line"><span class="class">              <span class="title">hierarchy</span> <span class="title">of</span> <span class="title">classes</span> <span class="title">with</span> <span class="title">an</span> <span class="title">emphasis</span> <span class="title">on</span> <span class="title">conforming</span> <span class="title">to</span></span></span><br><span class="line"><span class="class">              <span class="title">existing</span> <span class="title">practices</span>. <span class="title">HTB</span> <span class="title">facilitates</span> <span class="title">guaranteeing</span> <span class="title">bandwidth</span></span></span><br><span class="line"><span class="class">              <span class="title">to</span> <span class="title">classes</span>, <span class="title">while</span> <span class="title">also</span> <span class="title">allowing</span> <span class="title">specification</span> <span class="title">of</span> <span class="title">upper</span></span></span><br><span class="line"><span class="class">              <span class="title">limits</span> <span class="title">to</span> <span class="title">inter</span>-<span class="title">class</span> <span class="title">sharing</span>. <span class="title">It</span> <span class="title">contains</span> <span class="title">shaping</span></span></span><br><span class="line"><span class="class">              <span class="title">elements</span>, <span class="title">based</span> <span class="title">on</span> <span class="title">TBF</span> <span class="title">and</span> <span class="title">can</span> <span class="title">prioritize</span> <span class="title">classes</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">       <span class="title">PRIO</span>   <span class="title">The</span> <span class="title">PRIO</span> <span class="title">qdisc</span> <span class="title">is</span> <span class="title">a</span> <span class="title">non</span>-<span class="title">shaping</span> <span class="title">container</span> <span class="title">for</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">              <span class="title">configurable</span> <span class="title">number</span> <span class="title">of</span> <span class="title">classes</span> <span class="title">which</span> <span class="title">are</span> <span class="title">dequeued</span> <span class="title">in</span></span></span><br><span class="line"><span class="class">              <span class="title">order</span>. <span class="title">This</span> <span class="title">allows</span> <span class="title">for</span> <span class="title">easy</span> <span class="title">prioritization</span> <span class="title">of</span> <span class="title">traffic</span>,</span></span><br><span class="line"><span class="class">              <span class="title">where</span> <span class="title">lower</span> <span class="title">classes</span> <span class="title">are</span> <span class="title">only</span> <span class="title">able</span> <span class="title">to</span> <span class="title">send</span> <span class="title">if</span> <span class="title">higher</span> <span class="title">ones</span></span></span><br><span class="line"><span class="class">              <span class="title">have</span> <span class="title">no</span> <span class="title">packets</span> <span class="title">available</span>. <span class="title">To</span> <span class="title">facilitate</span> <span class="title">configuration</span>,</span></span><br><span class="line"><span class="class">              <span class="title">Type</span> <span class="title">Of</span> <span class="title">Service</span> <span class="title">bits</span> <span class="title">are</span> <span class="title">honored</span> <span class="title">by</span> <span class="title">default</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">       <span class="title">QFQ</span>    <span class="title">Quick</span> <span class="title">Fair</span> <span class="title">Queueing</span> <span class="title">is</span> <span class="title">an</span> <span class="title">O</span>(1) <span class="title">scheduler</span> <span class="title">that</span> <span class="title">provides</span></span></span><br><span class="line"><span class="class">              <span class="title">near</span>-<span class="title">optimal</span> <span class="title">guarantees</span>, <span class="title">and</span> <span class="title">is</span> <span class="title">the</span> <span class="title">first</span> <span class="title">to</span> <span class="title">achieve</span> <span class="title">that</span></span></span><br><span class="line"><span class="class">              <span class="title">goal</span> <span class="title">with</span> <span class="title">a</span> <span class="title">constant</span> <span class="title">cost</span> <span class="title">also</span> <span class="title">with</span> <span class="title">respect</span> <span class="title">to</span> <span class="title">the</span> <span class="title">number</span></span></span><br><span class="line"><span class="class">              <span class="title">of</span> <span class="title">groups</span> <span class="title">and</span> <span class="title">the</span> <span class="title">packet</span> <span class="title">length</span>. <span class="title">The</span> <span class="title">QFQ</span> <span class="title">algorithm</span> <span class="title">has</span> <span class="title">no</span></span></span><br><span class="line"><span class="class">              <span class="title">loops</span>, <span class="title">and</span> <span class="title">uses</span> <span class="title">very</span> <span class="title">simple</span> <span class="title">instructions</span> <span class="title">and</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">              <span class="title">structures</span> <span class="title">that</span> <span class="title">lend</span> <span class="title">themselves</span> <span class="title">very</span> <span class="title">well</span> <span class="title">to</span> <span class="title">a</span> <span class="title">hardware</span></span></span><br><span class="line"><span class="class">              <span class="title">implementation</span>.</span></span><br><span class="line"><span class="class">			  </span></span><br><span class="line"><span class="class">#创建规则：</span></span><br><span class="line"><span class="class"><span class="title">tc</span> <span class="title">qdisc</span> <span class="title">add</span> <span class="title">dev</span> <span class="title">eth0</span> <span class="title">root</span> <span class="title">handle</span> 1:</span><span class="number">0</span> htb <span class="keyword">default</span> <span class="number">1</span> </span><br><span class="line">#添加一个tbf规则，绑定到eth0上，命名为<span class="number">1</span>:<span class="number">0</span> ，默认归类为<span class="number">1</span></span><br><span class="line"><span class="meta">#handle：为规则命名或指定某规则</span></span><br></pre></td></tr></table></figure></p>
<p>排队规则在内核中的表示结构：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">描述排队规则的结构：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> 			(*enqueue)(struct sk_buff *skb,   --上面提到的两个函数</span><br><span class="line">					   struct Qdisc *sch,</span><br><span class="line">					   struct sk_buff **to_free);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *	(*<span class="title">dequeue</span>)(<span class="title">struct</span> <span class="title">Qdisc</span> *<span class="title">sch</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qdisc_ops</span>	*<span class="title">ops</span>;</span><span class="comment">//队列操作的接口，每个排队规则都必须实现该接口，如pfifo,tbf</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qdisc_size_table</span>	__<span class="title">rcu</span> *<span class="title">stab</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span></span><br><span class="line">	u32			handle; <span class="comment">//和tc的handle对应 句柄，排队规则，类和过滤器都有一个32位的句柄标识；</span></span><br><span class="line">	u32			parent; <span class="comment">//父句柄</span></span><br><span class="line">	<span class="keyword">void</span>			*u32_node;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netdev_queue</span>	*<span class="title">dev_queue</span>;</span><span class="comment">//和netdevice挂钩</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>	<span class="title">q</span>;</span><span class="comment">//队列当前的数据包数</span></span><br><span class="line">    ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qdisc_ops</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc_ops</span>	*<span class="title">next</span>;</span><span class="comment">//用于链接已注册的各种排队规则的操作接口</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qdisc_class_ops</span>	*<span class="title">cl_ops</span>;</span><span class="comment">//所在规则提供的类操作接口</span></span><br><span class="line">	<span class="keyword">char</span>			id[IFNAMSIZ];</span><br><span class="line">	<span class="keyword">int</span>			priv_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> 			(*enqueue)(struct sk_buff *skb, <span class="comment">//将数据包加入排队规则的函数</span></span><br><span class="line">					   struct Qdisc *sch,</span><br><span class="line">					   struct sk_buff **to_free);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *	(*<span class="title">dequeue</span>)(<span class="title">struct</span> <span class="title">Qdisc</span> *);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *	(*<span class="title">peek</span>)(<span class="title">struct</span> <span class="title">Qdisc</span> *);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			(*init)(struct Qdisc *, struct nlattr *arg);<span class="comment">//排队规则的初始化</span></span><br><span class="line">	<span class="keyword">void</span>			(*reset)(struct Qdisc *);</span><br><span class="line">	<span class="keyword">void</span>			(*destroy)(struct Qdisc *);</span><br><span class="line">	<span class="keyword">int</span>			(*change)(struct Qdisc *, struct nlattr *arg);</span><br><span class="line">	<span class="keyword">void</span>			(*attach)(struct Qdisc *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			(*dump)(struct Qdisc *, struct sk_buff *);</span><br><span class="line">	<span class="keyword">int</span>			(*dump_stats)(struct Qdisc *, struct gnet_dump *);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>类：<br>类： 定义在排队规则中，报文通过过滤器，过滤，分配到不同的类中；排队规则可以没有类，如fifo先进先出，也可以有多个类<br>类中也可以有内部的排队规则，包被过滤器过滤为某个类后，在这个类中通过fifo的排队规则出去，或者其他规则，这里的规则就是内部规则；<br>创建类：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> tc [ OPTIONS ] <span class="class"><span class="keyword">class</span> [ <span class="title">add</span> | <span class="title">change</span> | <span class="title">replace</span> | <span class="title">delete</span> ] <span class="title">dev</span> <span class="title">DEV</span></span></span><br><span class="line"><span class="class">       <span class="title">parent</span> <span class="title">qdisc</span>-<span class="title">id</span> [ <span class="title">classid</span> <span class="title">class</span>-<span class="title">id</span> ] <span class="title">qdisc</span> [ <span class="title">qdisc</span> <span class="title">specific</span></span></span><br><span class="line"><span class="class">       <span class="title">parameters</span> ]</span></span><br><span class="line"><span class="class"><span class="title">eg</span>:</span></span><br><span class="line">#创建分类</span><br><span class="line">tc <span class="class"><span class="keyword">class</span> <span class="title">add</span> <span class="title">dev</span> <span class="title">eth0</span> <span class="title">parent</span> 1:</span><span class="number">0</span> classid <span class="number">1</span>:<span class="number">1</span> htb rate <span class="number">10</span>Mbit burst <span class="number">15</span>k</span><br><span class="line">#为eth0下的root队列<span class="number">1</span>:<span class="number">0</span>添加一个分类并命名为<span class="number">1</span>:<span class="number">1</span>，类型为htb，带宽为<span class="number">10</span>M</span><br><span class="line"><span class="meta">#rate: 是一个类保证得到的带宽值.如果有不只一个类,请保证所有子类总和是小于或等于父类.</span></span><br><span class="line"><span class="meta">#ceil: ceil是一个类最大能得到的带宽值.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>类的表示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">在linux中，以xxx_class来表示，如htb:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">htb_class</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc_class_common</span> <span class="title">common</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">psched_ratecfg</span>	<span class="title">rate</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">psched_ratecfg</span>	<span class="title">ceil</span>;</span></span><br><span class="line">	s64			buffer, cbuffer;<span class="comment">/* token bucket depth/rate */</span></span><br><span class="line">	s64			mbuffer;	<span class="comment">/* max wait time */</span></span><br><span class="line">	u32			prio;		<span class="comment">/* these two are used only by leaves... */</span></span><br><span class="line">	<span class="keyword">int</span>			quantum;	<span class="comment">/* but stored for parent-to-leaf return */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span> __<span class="title">rcu</span>	*<span class="title">filter_list</span>;</span>	<span class="comment">/* class attached filters */</span> 类的过滤器链</span><br><span class="line">	<span class="keyword">int</span>			filter_cnt;</span><br><span class="line">	<span class="keyword">int</span>			refcnt;		<span class="comment">/* usage count of this class */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			level;		<span class="comment">/* our level (see above) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		children;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">htb_class</span>	*<span class="title">parent</span>;</span>	<span class="comment">/* parent class */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gnet_stats_rate_est64</span> <span class="title">rate_est</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Written often fields</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gnet_stats_basic_packed</span> <span class="title">bstats</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tc_htb_xstats</span>	<span class="title">xstats</span>;</span>	<span class="comment">/* our special stats */</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>过滤器<br>过滤器： 具体的过滤规则，用来分类；包含若干个匹配条件，如果符合条件的包，被分类到具体的类中；</li>
</ul>
<p>一个类至少有一个过滤器，可能有多个过滤器，<br>tc指令：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tc [ OPTIONS ] filter [ add | change | replace | <span class="keyword">delete</span> | get ]</span><br><span class="line">       dev DEV [ parent qdisc-id | root ] [ handle filter-id ] protocol</span><br><span class="line">       protocol prio priority filtertype [ filtertype specific</span><br><span class="line">       parameters ] flowid flow-id</span><br><span class="line">内核目前提供的过滤器有：</span><br><span class="line"> The available filters are:</span><br><span class="line"></span><br><span class="line">       basic  Filter packets based on an ematch expression. See</span><br><span class="line">              tc-ematch(<span class="number">8</span>) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">       bpf    Filter packets using (e)BPF, see tc-bpf(8) for details.</span><br><span class="line"></span><br><span class="line">       cgroup Filter packets based on the control group of their</span><br><span class="line">              process. See tc-cgroup(<span class="number">8</span>) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">       flow, flower</span><br><span class="line">              Flow-based classifiers, filtering packets based on their</span><br><span class="line">              flow (identified by selectable keys). See tc-flow(<span class="number">8</span>) <span class="keyword">and</span></span><br><span class="line">              tc-flower(<span class="number">8</span>) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">       fw     Filter based on fwmark. Directly maps fwmark value to</span><br><span class="line">              traffic <span class="class"><span class="keyword">class</span>. <span class="title">See</span> <span class="title">tc</span>-<span class="title">fw</span>(8).</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">       <span class="title">route</span>  <span class="title">Filter</span> <span class="title">packets</span> <span class="title">based</span> <span class="title">on</span> <span class="title">routing</span> <span class="title">table</span>. <span class="title">See</span> <span class="title">tc</span>-<span class="title">route</span>(8) <span class="title">for</span></span></span><br><span class="line"><span class="class">              <span class="title">details</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">       <span class="title">rsvp</span>   <span class="title">Match</span> <span class="title">Resource</span> <span class="title">Reservation</span> <span class="title">Protocol</span> (<span class="title">RSVP</span>) <span class="title">packets</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">       <span class="title">tcindex</span></span></span><br><span class="line"><span class="class">              <span class="title">Filter</span> <span class="title">packets</span> <span class="title">based</span> <span class="title">on</span> <span class="title">traffic</span> <span class="title">control</span> <span class="title">index</span>. <span class="title">See</span></span></span><br><span class="line"><span class="class">              <span class="title">tc</span>-<span class="title">tcindex</span>(8).</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">       <span class="title">u32</span>    <span class="title">Generic</span> <span class="title">filtering</span> <span class="title">on</span> <span class="title">arbitrary</span> <span class="title">packet</span> <span class="title">data</span>, <span class="title">assisted</span> <span class="title">by</span></span></span><br><span class="line"><span class="class">              <span class="title">syntax</span> <span class="title">to</span> <span class="title">abstract</span> <span class="title">common</span> <span class="title">operations</span>. <span class="title">See</span> <span class="title">tc</span>-<span class="title">u32</span>(8) <span class="title">for</span></span></span><br><span class="line"><span class="class">              <span class="title">details</span>.</span></span><br><span class="line"><span class="class">    <span class="title">matchall</span></span></span><br><span class="line"><span class="class">              <span class="title">Traffic</span> <span class="title">control</span> <span class="title">filter</span> <span class="title">that</span> <span class="title">matches</span> <span class="title">every</span> <span class="title">packet</span>. <span class="title">See</span></span></span><br><span class="line"><span class="class">              <span class="title">tc</span>-<span class="title">matchall</span>(8) <span class="title">for</span> <span class="title">details</span>.</span></span><br><span class="line"><span class="class"><span class="title">eg</span>:</span></span><br><span class="line">#使用u32创建过滤器</span><br><span class="line">tc filter add dev eth0 protocol ip parent <span class="number">1</span>:<span class="number">0</span> prio <span class="number">1</span> u32 match ip sport <span class="number">22</span> flowid <span class="number">1</span>:<span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>在内核中的结构：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Fast access part */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span> __<span class="title">rcu</span>	*<span class="title">next</span>;</span><span class="comment">//将多个过滤器连接起来</span></span><br><span class="line">	<span class="keyword">void</span> __rcu		*root;</span><br><span class="line">	<span class="keyword">int</span>			(*classify)(struct sk_buff *,</span><br><span class="line">					    <span class="keyword">const</span> struct tcf_proto *,</span><br><span class="line">					    struct tcf_result *); <span class="comment">//报文分类函数--&gt; tcf_proto_ops上</span></span><br><span class="line">	__be16			protocol;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* All the rest */</span></span><br><span class="line">	u32			prio;</span><br><span class="line">	u32			classid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span>		*<span class="title">q</span>;</span></span><br><span class="line">	<span class="keyword">void</span>			*data;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto_ops</span>	*<span class="title">ops</span>;</span><span class="comment">//过滤器操作函数接口</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="qdisc的例子：-pfifo-ftb等"><a href="#qdisc的例子：-pfifo-ftb等" class="headerlink" title="qdisc的例子： pfifo ,ftb等"></a>qdisc的例子： pfifo ,ftb等</h3><p>通过fifo学习如何实现一个规则；<br>默认情况下是pfifo，这个通过dev_open挂到设备上；如果需要其他的，通过tc后-&gt;netlink再操作到dev结构等上；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> <span class="title">noop_qdisc</span> = &#123;</span></span><br><span class="line">	.enqueue	=	noop_enqueue,</span><br><span class="line">	.dequeue	=	noop_dequeue,</span><br><span class="line">	.flags		=	TCQ_F_BUILTIN,</span><br><span class="line">	.ops		=	&amp;noop_qdisc_ops,</span><br><span class="line">	.<span class="built_in">list</span>		=	LIST_HEAD_INIT(noop_qdisc.<span class="built_in">list</span>),</span><br><span class="line">	.q.lock		=	__SPIN_LOCK_UNLOCKED(noop_qdisc.q.lock),</span><br><span class="line">	.dev_queue	=	&amp;noop_netdev_queue,</span><br><span class="line">	.running	=	SEQCNT_ZERO(noop_qdisc.running),</span><br><span class="line">	.busylock	=	__SPIN_LOCK_UNLOCKED(noop_qdisc.busylock),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qdisc_ops</span> <span class="title">pfifo_fast_ops</span> __<span class="title">read_mostly</span> = &#123;</span></span><br><span class="line">	.id		=	<span class="string">"pfifo_fast"</span>,</span><br><span class="line">	.priv_size	=	<span class="keyword">sizeof</span>(struct pfifo_fast_priv),</span><br><span class="line">	.enqueue	=	pfifo_fast_enqueue,</span><br><span class="line">	.dequeue	=	pfifo_fast_dequeue,</span><br><span class="line">	.peek		=	pfifo_fast_peek,</span><br><span class="line">	.init		=	pfifo_fast_init,</span><br><span class="line">	.reset		=	pfifo_fast_reset,</span><br><span class="line">	.dump		=	pfifo_fast_dump,</span><br><span class="line">	.owner		=	THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="tc工具的netlink接口"><a href="#tc工具的netlink接口" class="headerlink" title="tc工具的netlink接口"></a>tc工具的netlink接口</h3><p>定义在sch_api.c，主要操作排队规则中的类和过滤器；<br>tc是通过netlink向内核通信，从而实现创建，修改qos等功能</p>
<p>本文只是给了一个流程和具体认知，通过本文来知道tc大致原理和框架，从而为进一步提供便利和查找依据；</p>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_tc</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_netdevicelayer</title>
    <url>/2021/05/22/linux-netdevicelayer/</url>
    <content><![CDATA[<h3 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h3><h4 id="描述linux网络协议栈结构："><a href="#描述linux网络协议栈结构：" class="headerlink" title="描述linux网络协议栈结构："></a>描述linux网络协议栈结构：</h4><p>1) 常规的方式：传统的单机网络结构：<br>   一个服务器(server)上，运行一个linux系统，linux系统之上运行一个协议栈，支持相关上层应用；<br>   服务器的下方(硬件设备)，接一个或多个网卡，代表这个系统可能支持多个ip，多个出口等；每个网卡NIC接不同的交换机(路由器),来连接到可能不同的<br>   运营商物理网络，如下图：在这种情况下一个服务器为一个单点的物理机；<a id="more"></a></p>
<p>2) 虚拟机虚拟网络架构：<br>   一个服务器，其实可能会是个多核比如32核的cpu,运算能力强，也配了一个或多个网卡，可以运行多个虚拟机(操作系统)，像vmware,virtualbox,kvm,qemu<br>   等软件支持的虚拟机，可以运行多个不同操作系统的虚拟机，各个虚拟机之间相互隔离；<br>   这个虚拟机架构需要网络架构上支持，称虚拟网络架构，每个虚拟机有各自的虚拟网卡，每个虚拟机之间的通信，通过将每个虚拟网卡连接到多个虚拟交换机上(虚拟交换机也是在这个服务器上),从而分成几个隔离的虚拟网络；最后需要经过物理网络出口入口时，由虚拟交换机接出；<br>   虚拟机架构：Hypervisor: 一种模拟器，常见的实现有vmward,virtualbox,qemu,kvm,半虚拟化的virtio等等<br>   虚拟交换机架构： open vSwitch<br>   虚拟网卡： 有tap/tun的实现例子<br>   虚拟lan: VLANS, macvlan,ipvlan等<br>   硬件加速：intel虚拟化技术： VT-d  </p>
<p>3) openstack：<br>   可以说是云计算的开源架构吧，它可以实现为一套软件，如目前的laaS(Infrastructure as a Service基础设施即服务)/Paas/SaaS<br>   基础设施资源，主要包括三个方面：计算、存储、网络。说通俗点，就是CPU，硬盘，网卡。<br>   OpenStack对资源进行管理，并且以服务的形式提供给上层应用或者用户去使用。<br>   laaS: 厂商管理网络，存储，服务器，虚拟化，即厂商提供docker或其他的类型的虚拟云主机(容器云等)，由使用者用户管理虚拟机上的操作系统，中间件，运行时环境，数据以及应用程序<br>   PaaS: 厂商管理网络，存储，服务器，虚拟化，操作系统，中间件和运行时环境，而用户只需要部署其数据和应用程序就好了；<br>   SaaS:全部都由厂商来管理；</p>
<h4 id="这里先不讨论虚拟化的网络架构，先看传统的结构："><a href="#这里先不讨论虚拟化的网络架构，先看传统的结构：" class="headerlink" title="这里先不讨论虚拟化的网络架构，先看传统的结构："></a>这里先不讨论虚拟化的网络架构，先看传统的结构：</h4><h5 id="1-描述这一层的位置，具体含义。"><a href="#1-描述这一层的位置，具体含义。" class="headerlink" title="1 描述这一层的位置，具体含义。"></a>1 描述这一层的位置，具体含义。</h5><p>网络设备分为物理网络设备和虚拟网络设备，这里将网络设备都简化为只讨论网卡；</p>
<ul>
<li>对网卡而言：有它的特性：<br>带宽，速度： 即它是千兆网卡还是其他，这个可以通过指令拿到：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo ethtool eth0</span><br><span class="line">Settings <span class="keyword">for</span> eth0:</span><br><span class="line">	Supported ports: [ TP ]</span><br><span class="line">	Supported link modes:   <span class="number">10b</span>aseT/Half <span class="number">10b</span>aseT/Full </span><br><span class="line">	                        <span class="number">100b</span>aseT/Half <span class="number">100b</span>aseT/Full </span><br><span class="line">	                        <span class="number">1000b</span>aseT/Full </span><br><span class="line">	Supported pause frame use: Symmetric</span><br><span class="line">	Supports <span class="keyword">auto</span>-negotiation: Yes</span><br><span class="line">	Advertised link modes:  <span class="number">10b</span>aseT/Half <span class="number">10b</span>aseT/Full </span><br><span class="line">	                        <span class="number">100b</span>aseT/Half <span class="number">100b</span>aseT/Full </span><br><span class="line">	                        <span class="number">1000b</span>aseT/Full </span><br><span class="line">	Advertised pause frame use: Symmetric</span><br><span class="line">	Advertised <span class="keyword">auto</span>-negotiation: Yes</span><br><span class="line">	Speed: <span class="number">1000</span>Mb/s  千兆网卡</span><br><span class="line">	Duplex: Full</span><br><span class="line">	Port: Twisted Pair</span><br><span class="line">	PHYAD: <span class="number">1</span></span><br><span class="line">	Transceiver: internal</span><br><span class="line">	Auto-negotiation: on</span><br><span class="line">	MDI-X: on</span><br><span class="line">	Supports Wake-on: pumbg</span><br><span class="line">	Wake-on: g</span><br><span class="line">	Current message level: <span class="number">0x00000007</span> (<span class="number">7</span>)</span><br><span class="line">			       drv probe link</span><br><span class="line">	Link detected: yes</span><br></pre></td></tr></table></figure>
<p>其他特性： 网卡支持的工作模式，是否支持多队列等等；<br>其中多队列的特性比较重要，即意味着它支不支持RSS:</p>
<ul>
<li>关于RSS,RPS,RFS等：</li>
<li>RSS：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">支持多队列的NIC的驱动程序通常提供一个内核模块参数来指定要配置的硬件队列的数量。例如，在bnx2x驱动程序中，这个参数被称为num_queues。典型的RSS配置是，如果设备支持足够的队列，那么每个CPU都有一个接收队列，或者至少每个内存域有一个接收队列，其中内存域是一组共享特定内存级别(L1、L2、NUMA节点等)的CPU。</span><br><span class="line">RSS设备的间接表(通过屏蔽散列解析队列)通常是由驱动程序在初始化时编写的。默认的映射是将队列均匀地分布在表中，但是可以在运行时使用ethtool命令(——show-rxfh-indir和——<span class="built_in">set</span>-rxfh-indir)检索和修改间接表。可以通过修改间接表来为不同的队列指定不同的相对权重。</span><br><span class="line">RSS irq 配置</span><br><span class="line">每个接收队列都有一个与之相关联的独立IRQ。当新包到达给定队列时，NIC会触发此操作通知CPU。PCIe设备的信令路径使用消息信号中断(MSI-X)，它可以将每个中断路由到特定的CPU。队列到irq的活动映射可以从/proc/interrupts中确定。默认情况下，IRQ可以在任何CPU上处理。因为数据包处理中不可忽略的一部分发生在接收中断处理中，所以在cpu之间分散接收中断是有利的。手动调整每个interru的IRQ亲和力</span><br><span class="line"></span><br><span class="line">推荐配置，即中断打散：</span><br><span class="line">当考虑延迟或接收中断处理形成瓶颈时，应该启用RSS。在cpu之间分散负载会减少队列长度。对于低延迟网络，最佳设置是分配与系统中cpu数量相同的队列(如果更低，则为网卡最大值)。最有效的高速率配置可能是接收队列数量最少的配置，其中没有由于CPU饱和而导致的接收队列溢出，因为在启用中断合并的默认模式下，中断的聚合数量(因此工作)会随着每增加一个而增加</span><br><span class="line">可以使用mpstat实用程序观察每个CPU的负载，但是请注意，在具有超线程(HT)的处理器上，每个超线程都表示为一个单独的CPU。对于中断处理，HT在最初的测试中没有显示出任何好处，因此将队列的数量限制在系统中的CPU内核的数量。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>内核代码实现中，将支持此种特性时，用MSI-X来表示，可以看相关函数名；<br>查看网卡队列：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ethtool -l eth1</span><br><span class="line">Channel parameters <span class="keyword">for</span> eth1:</span><br><span class="line">Pre-<span class="built_in">set</span> maximums:</span><br><span class="line">RX:		<span class="number">0</span></span><br><span class="line">TX:		<span class="number">0</span></span><br><span class="line">Other:		<span class="number">1</span></span><br><span class="line">Combined:	<span class="number">32</span>  <span class="comment">//网卡支持的</span></span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:		<span class="number">0</span></span><br><span class="line">TX:		<span class="number">0</span></span><br><span class="line">Other:		<span class="number">1</span></span><br><span class="line">Combined:	<span class="number">20</span> <span class="comment">//当前配置的</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>RPS：<br>对于单队列网卡，可以通过RPS (receive packet steering)或RFS (receive flow steering)两种方式模拟多队列模式，但效果不如启用RSS的多队列网卡<br>接收包转向(Receive packet steering, RPS)在cpu之间平衡软中断的负载.  网卡驱动程序通过使用一个四联体(SIP、SPORT、DIP和DPORT)计算每个流的哈希ID，中断处理程序将哈希ID分配给相应的CPU，从而充分利用多核能力<br>RPS通常是通过软件来模拟多队列网卡的功能。当网卡支持多队列时，RPS无效。RPS主要用于多cpu环境中的单队列网卡。如果一个网卡支持多个队列，可以通过配置SMP IRQ亲和性直接将硬中断绑定到cpu。</p>
</li>
<li><p>RFS:<br>RPS只是将数据包分配到不同的cpu上。当使用不同的CPU运行应用程序和处理软中断时，这会大大降低CPU缓存的利用率。在这种情况下，RFS确保使用一个CPU来运行应用程序和处理软中断，以充分利用CPU缓存。RPS和RFS通常一起使用以获得最好的结果。它们主要用于多cpu环境中的单队列网卡。<br>即RFS和应用绑定一起，确保该cpu上收到的包，就是被该cpu上运行的应用处理的，仔细看下面两个图，前面是RPS，data3-&gt;app8了，无关联，但是后面的是RFS，data3-&gt;app3，都是3</p>
</li>
</ul>
<p>接收流导向(Receive flow steering, RFS)与RPS一起，将数据包插入指定CPU的backlog队列中，并唤醒CPU执行。<br>IRQbalance适用于大多数场景。但在对网络性能要求较高的场景下，建议手动绑定中断。<br>IRQbalance在运行过程中可能会出现以下问题:a)计算值有时不合适，无法实现cpu之间的负载均衡。(b)当系统处于空闲状态，irq处于省电模式时，IRQbalance将所有中断分配到第一个CPU，使其他空闲CPU休眠，降低能耗。当负载突然上升时，可能会由于调整滞后而导致性能下降。(c)指定处理中断的CPU频繁变化，导致更多的上下文切换。(d)启用IRQbalance但不生效，即没有指定处理中断的CPU。</p>
<p>more:<a href="https://01.org/linuxgraphics/gfx-docs/drm/networking/scaling.html" target="_blank" rel="noopener">https://01.org/linuxgraphics/gfx-docs/drm/networking/scaling.html</a></p>
<h5 id="2-关于网络设备层：网络收发时的总体流程，以及这一层的流程；并贴上大致的函数调用接口"><a href="#2-关于网络设备层：网络收发时的总体流程，以及这一层的流程；并贴上大致的函数调用接口" class="headerlink" title="2 关于网络设备层：网络收发时的总体流程，以及这一层的流程；并贴上大致的函数调用接口"></a>2 关于网络设备层：网络收发时的总体流程，以及这一层的流程；并贴上大致的函数调用接口</h5><p>Linux内核中有一个网络设备管理层，处于网络设备驱动和协议栈之间，负责衔接它们之间的数据交互。驱动不需要了解协议栈的细节，协议栈也不需要了解设备驱动的细节。<br>对于一个网络设备来说，就像一个管道（pipe）一样，有两端，从其中任意一端收到的数据将从另一端发送出去。<br>比如一个物理网卡eth0，它的两端分别是内核协议栈（通过内核网络设备管理模块间接的通信）和外面的物理网络，从物理网络收到的数据，会转发给内核协议栈，而应用程序从协议栈发过来的数据将会通过物理网络发送出去。</p>
<ul>
<li><p>网络设备层收包流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">                   +-----+</span><br><span class="line">                   |     |                            Memroy</span><br><span class="line">+--------+   <span class="number">1</span>     |     |  <span class="number">2</span>  DMA     +--------+--------+--------+--------+</span><br><span class="line">| Packet |--------&gt;| NIC |------------&gt;| Packet | Packet | Packet | ...... |</span><br><span class="line">+--------+         |     |             +--------+--------+--------+--------+</span><br><span class="line">                   |     |&lt;--------+</span><br><span class="line">                   +-----+         |</span><br><span class="line">                      |            +---------------+</span><br><span class="line">                      |                            |</span><br><span class="line">                    <span class="number">3</span> | Raise IRQ                  | Disable IRQ</span><br><span class="line">                      |                          <span class="number">5</span> |</span><br><span class="line">                      |                            |</span><br><span class="line">                      ↓                            |</span><br><span class="line">                   +-----+                   +------------+</span><br><span class="line">                   |     |  Run IRQ handler  |            |</span><br><span class="line">                   | CPU |------------------&gt;| NIC Driver |</span><br><span class="line">                   |     |       <span class="number">4</span>           |            |</span><br><span class="line">                   +-----+                   +------------+</span><br><span class="line">                                                   |</span><br><span class="line">                                                <span class="number">6</span>  | Raise soft IRQ</span><br><span class="line">                                                   |</span><br><span class="line">                                                   ↓</span><br><span class="line"><span class="comment">//来源：https://segmentfault.com/a/1190000008836467</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>具体步骤<br>0) 网卡初始化和启动：在开机时module_init初始化部分，然后在pci或其他总线发现设备时，调用probe进一步真正初始化；在类似ifconfig up的指令启动网卡后，<br>会调用到网卡的xxx_open函数，进行如中断注册，使能等操作；这个时候，设备就可以开始工作了；  </p>
</li>
</ul>
<p>1) 数据包从外面的网络进入物理网卡。这个时候网卡芯片自身的逻辑(固件),会判断如果目的mac地址不是该网卡的，且该网卡没有开启混杂模式，该包会被网卡丢弃，这里发生在网卡固件逻辑上，没在驱动做处理。先代网卡分以太网卡，和wifi网卡，又根据接口不同，有pci接口的，和usb接口的，比如常见的usbwifi网卡；<br>   以太网的物理头和wifi物理头(802.11头)，不一样，或者说支持的协议不同，根源是物理环境不同；wifi的环境是空气；  </p>
<p>2) 网卡将数据包通过DMA的方式写入到指定的内存地址，该地址由网卡驱动分配并初始化。注： 老的网卡可能不支持DMA，不过新的网卡一般都支持。<br>3) 网卡通过硬件中断（IRQ）通知CPU，告诉它有数据来了<br>4）CPU根据中断表，调用已经注册的中断函数，这个中断函数会调到驱动程序（NIC Driver）中相应的函数<br>5) 对NAPI模式： 驱动先禁用网卡的中断，表示驱动程序已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知CPU了，这样可以提高效率，避免CPU不停的被中断。<br>6) 对非NAPI的模式，驱动是每次中断处理接收数据，然后写到内存的；这里NAPI的N是new的意思；<br>7) 启动软中断。这步结束后，硬件中断处理函数就结束返回了。由于硬中断处理程序执行的过程中不能被中断，所以如果它执行时间过长，会导致CPU没法响应其它硬件的中断，于是内核引入软中断，这样可以将硬中断处理函数中耗时的部分移到软中断处理函数里面来慢慢处理。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                                            +-----+</span><br><span class="line">                                    <span class="number">17</span>      |     |</span><br><span class="line">                               +-----------&gt;| NIC |</span><br><span class="line">                               |            |     |</span><br><span class="line">                               |Enable IRQ  +-----+</span><br><span class="line">                               |</span><br><span class="line">                               |</span><br><span class="line">                         +------------+                                      Memroy</span><br><span class="line">                         |            |        Read           +--------+--------+--------+--------+</span><br><span class="line">        +---------------&gt;| NIC Driver |&lt;--------------------- | Packet | Packet | Packet | ...... |</span><br><span class="line">        |                |            |          <span class="number">9</span>            +--------+--------+--------+--------+</span><br><span class="line">        |                +------------+</span><br><span class="line">        |                      |    |        skb</span><br><span class="line">   Poll | <span class="number">8</span>      Raise softIRQ | <span class="number">6</span>  +-----------------+</span><br><span class="line">        |                      |             <span class="number">10</span>       |</span><br><span class="line">        |                      ↓                      ↓</span><br><span class="line">+---------------+  Call  +-----------+        +------------------+        +--------------------+  <span class="number">12</span>  +---------------------+</span><br><span class="line">| net_rx_action |&lt;-------| ksoftirqd |        | napi_gro_receive |-------&gt;| enqueue_to_backlog |-----&gt;| CPU input_pkt_queue |</span><br><span class="line">+---------------+   <span class="number">7</span>    +-----------+        +------------------+   <span class="number">11</span>   +--------------------+      +---------------------+</span><br><span class="line">                                                      |                                                      | <span class="number">13</span></span><br><span class="line">                                                   <span class="number">14</span> |        + - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">                                                      ↓        ↓</span><br><span class="line">                                           +--------------------------+    <span class="number">15</span>      +------------------------+</span><br><span class="line">                                           | __netif_receive_skb_core |-----------&gt;| packet taps(AF_PACKET) |</span><br><span class="line">                                           +--------------------------+            +------------------------+</span><br><span class="line">                                                      |</span><br><span class="line">                                                      | <span class="number">16</span></span><br><span class="line">                                                      ↓</span><br><span class="line">                                             +-----------------+</span><br><span class="line">                                             | protocol layers |</span><br><span class="line">                                             +-----------------+</span><br></pre></td></tr></table></figure>
<p>8) 内核中的ksoftirqd进程专门负责软中断的处理，当它收到软中断后，就会调用相应软中断所对应的处理函数，对于上面第7步中是网卡驱动模块抛出的软中断，ksoftirqd会调用网络模块的net_rx_action函数,这个函数是在初始化时，注册到指定的网络接收软中断上的；<br>9) net_rx_action调用网卡驱动里的poll函数来一个一个的处理数据包<br>10) 在poll函数中，驱动会一个接一个的读取网卡写到内存中的数据包，内存中数据包的格式只有驱动知道<br>11) 驱动程序将内存中的数据包转换成内核网络模块能识别的skb格式，然后调用napi_gro_receive函数<br>12) napi_gro_receive会处理GRO相关的内容，也就是将可以合并的数据包进行合并，这样就只需要调用一次协议栈。然后判断是否开启了RPS，如果开启了，将会调用enqueue_to_backlog<br>13) 在enqueue_to_backlog函数中，会将数据包放入CPU的softnet_data结构体的input_pkt_queue中，然后返回，如果input_pkt_queue满了的话，该数据包将会被丢弃，queue的大小可以通过net.core.netdev_max_backlog来配置<br>14) CPU会接着在自己的软中断上下文中处理自己input_pkt_queue里的网络数据（调用<strong>netif_receive_skb_core）<br>15） 如果没开启RPS，napi_gro_receive会直接调用</strong>netif_receive_skb_core<br>16)  看是不是有AF_PACKET类型的socket（也就是我们常说的原始套接字），如果有的话，拷贝一份数据给它。tcpdump抓包就是抓的这里的包。<br>17) 调用协议栈相应的函数，将数据包交给协议栈处理。<br>18) 待内存中的所有数据包被处理完成后（即poll函数执行完成），启用网卡的硬中断，这样下次网卡再收到数据的时候就会通知CPU<br>接着传递给协议栈；  </p>
<ul>
<li>NAPI和非NAPI的区别：以下两篇写得不错，我就不重复写了；<br><a href="http://www.hyuuhit.com/2018/07/25/receive-packet/" target="_blank" rel="noopener">http://www.hyuuhit.com/2018/07/25/receive-packet/</a><br><a href="http://cxd2014.github.io/2017/10/15/linux-napi/" target="_blank" rel="noopener">http://cxd2014.github.io/2017/10/15/linux-napi/</a></li>
</ul>
<h5 id="网络设备层发包流程："><a href="#网络设备层发包流程：" class="headerlink" title="网络设备层发包流程："></a>网络设备层发包流程：</h5><p>网络数据包通过协议栈后，经过邻居子系统，接着都会调用dev_queue_xmit 进入网络设备层进行发包；<br>期间经过流量控制系统tc,再到发包软中断等，最后在合适的时机，通过设备对应的驱动的发送函数发送出去；<br>整体流程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                        |</span><br><span class="line">                        |</span><br><span class="line">                        ↓</span><br><span class="line">                 +----------------+</span><br><span class="line">+----------------| dev_queue_xmit |</span><br><span class="line">|                +----------------+</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">|                       ↓</span><br><span class="line">|              +-----------------+</span><br><span class="line">|              | Traffic Control |</span><br><span class="line">|              +-----------------+</span><br><span class="line">| loopback              |</span><br><span class="line">|   <span class="keyword">or</span>                  +--------------------------------------------------------------+</span><br><span class="line">| IP tunnels            ↓                                                              |</span><br><span class="line">|                       ↓                                                              |</span><br><span class="line">|            +---------------------+  Failed   +----------------------+         +---------------+</span><br><span class="line">+-----------&gt;| dev_hard_start_xmit |----------&gt;| raise NET_TX_SOFTIRQ |- - - - &gt;| net_tx_action |</span><br><span class="line">             +---------------------+           +----------------------+         +---------------+</span><br><span class="line">                        |</span><br><span class="line">                        +----------------------------------+</span><br><span class="line">                        |                                  |</span><br><span class="line">                        ↓                                  ↓</span><br><span class="line">                +----------------+              +------------------------+</span><br><span class="line">                | ndo_start_xmit |              | packet taps(AF_PACKET) |</span><br><span class="line">                +----------------+              +------------------------+</span><br></pre></td></tr></table></figure>
<p>explanation:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dev_queue_xmit： netdevice子系统的入口函数，在该函数中，会先获取设备对应的qdisc，如果没有的话（如loopback或者IP tunnels），就直接调用dev_hard_start_xmit，否则数据包将经过Traffic Control模块进行处理</span><br><span class="line">Traffic Control： 这里主要是进行一些过滤和优先级处理，在这里，如果队列满了的话，数据包会被丢掉，详情请参考文档，这步完成后也会走到dev_hard_start_xmit</span><br><span class="line"></span><br><span class="line">dev_hard_start_xmit： 该函数中，首先是拷贝一份skb给“packet taps”，tcpdump就是从这里得到数据的，然后调用ndo_start_xmit。如果dev_hard_start_xmit返回错误的话（大部分情况可能是NETDEV_TX_BUSY），调用它的函数会把skb放到一个地方，然后抛出软中断NET_TX_SOFTIRQ，交给软中断处理程序net_tx_action稍后重试（如果是loopback或者IP tunnels的话，失败后不会有重试的逻辑）</span><br><span class="line"></span><br><span class="line">ndo_start_xmit： 这是一个函数指针，会指向具体驱动发送数据的函数</span><br></pre></td></tr></table></figure></p>
<h5 id="ethernet网卡，e1000-igb-i350为例子解释"><a href="#ethernet网卡，e1000-igb-i350为例子解释" class="headerlink" title="ethernet网卡，e1000,igb i350为例子解释"></a>ethernet网卡，e1000,igb i350为例子解释</h5><p>以简单的只有单队列的千兆网卡e1000为例：e1000是<br>e1000_main.c</p>
<ul>
<li><p>pci_scan-&gt;probe: 网卡初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e1000_probe:</span><br><span class="line">    结构： </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span>;</span> <span class="comment">//每个网络设备都有</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_adapter</span> *<span class="title">adapter</span>;</span><span class="comment">//网卡适配器结构，每个网卡有自己的adapter结构，包括napi结构，是否为多队列结构，tx,rx相关属性等；</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_hw</span> *<span class="title">hw</span>;</span><span class="comment">//表示一些硬件属性</span></span><br><span class="line">    流程：主要是初始化以上三个结构</span><br><span class="line">    <span class="comment">/*e1000_probe initializes an adapter identified by a pci_dev structure.</span></span><br><span class="line"><span class="comment"> * The OS initialization, configuring of the adapter private structure,</span></span><br><span class="line"><span class="comment"> * and a hardware reset occur.*/</span></span><br><span class="line">    	netif_napi_add(netdev, &amp;adapter-&gt;napi, e1000_clean, <span class="number">64</span>); --初始化poll函数，为e1000_clean</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动网卡：ifconfig up/call open func </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 启动设备，分配相关结构，向操作系统注册中断，看门狗启动，协议栈被通知接口已ready</span></span><br><span class="line"><span class="comment">The open entry point is called when a network interface is made</span></span><br><span class="line"><span class="comment">* active by the system (IFF_UP).  At this point all resources needed</span></span><br><span class="line"><span class="comment">* for transmit and receive operations are allocated, the interrupt</span></span><br><span class="line"><span class="comment">* handler is registered with the OS, the watchdog task is started,</span></span><br><span class="line"><span class="comment">* and the stack is notified that the interface is ready.</span></span><br><span class="line"><span class="comment">**/</span>/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>函数不长，可以看看：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">e1000_open</span><span class="params">(struct net_device *netdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_adapter</span> *<span class="title">adapter</span> = <span class="title">netdev_priv</span>(<span class="title">netdev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_hw</span> *<span class="title">hw</span> = &amp;<span class="title">adapter</span>-&gt;<span class="title">hw</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* disallow open during test */</span></span><br><span class="line">	<span class="keyword">if</span> (test_bit(__E1000_TESTING, &amp;adapter-&gt;flags))</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	netif_carrier_off(netdev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate transmit descriptors */</span></span><br><span class="line">	err = e1000_setup_all_tx_resources(adapter);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_setup_tx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate receive descriptors */</span></span><br><span class="line">	err = e1000_setup_all_rx_resources(adapter);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_setup_rx;</span><br><span class="line"></span><br><span class="line">	e1000_power_up_phy(adapter);</span><br><span class="line"></span><br><span class="line">	adapter-&gt;mng_vlan_id = E1000_MNG_VLAN_NONE;</span><br><span class="line">	<span class="keyword">if</span> ((hw-&gt;mng_cookie.status &amp;</span><br><span class="line">			  E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT)) &#123;</span><br><span class="line">		e1000_update_mng_vlan(adapter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* before we allocate an interrupt, we must be ready to handle it.</span></span><br><span class="line"><span class="comment">	 * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt</span></span><br><span class="line"><span class="comment">	 * as soon as we call pci_request_irq, so we have to setup our</span></span><br><span class="line"><span class="comment">	 * clean_rx handler before we do so.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	e1000_configure(adapter);</span><br><span class="line"></span><br><span class="line">	err = e1000_request_irq(adapter);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_req_irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* From here on the code is the same as e1000_up() */</span></span><br><span class="line">	clear_bit(__E1000_DOWN, &amp;adapter-&gt;flags);</span><br><span class="line"></span><br><span class="line">	napi_enable(&amp;adapter-&gt;napi);</span><br><span class="line"></span><br><span class="line">	e1000_irq_enable(adapter);</span><br><span class="line"></span><br><span class="line">	netif_start_queue(netdev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fire a link status change interrupt to start the watchdog */</span></span><br><span class="line">	ew32(ICS, E1000_ICS_LSC);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> E1000_SUCCESS;</span><br><span class="line"></span><br><span class="line">err_req_irq:</span><br><span class="line">	e1000_power_down_phy(adapter);</span><br><span class="line">	e1000_free_all_rx_resources(adapter);</span><br><span class="line">err_setup_rx:</span><br><span class="line">	e1000_free_all_tx_resources(adapter);</span><br><span class="line">err_setup_tx:</span><br><span class="line">	e1000_reset(adapter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从这里可以看到中断处理程序：e1000_intr</span></span><br><span class="line">	<span class="keyword">irq_handler_t</span> handler = e1000_intr;</span><br><span class="line">	<span class="keyword">int</span> irq_flags = IRQF_SHARED;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = request_irq(adapter-&gt;pdev-&gt;irq, handler, irq_flags, netdev-&gt;name,</span><br><span class="line">			  netdev);</span><br></pre></td></tr></table></figure>
<ul>
<li>接收数据包的中断处理：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__napi_schedule(&amp;adapter-&gt;napi); <span class="comment">//这里是napi的，直接进入调度---&gt;__raise_softirq_irqoff(NET_RX_SOFTIRQ);</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">net_rx_action</span><span class="params">(struct softirq_action *h)</span></span></span><br><span class="line">--&gt;budget -= napi_poll(n, &amp;repoll);从设备拉数据</span><br><span class="line">  ---&gt;work = n-&gt;poll(n, weight);从设备拉数据</span><br><span class="line">    --&gt;从上面可以看到poll为e1000_clean</span><br><span class="line">	 --&gt;napi_complete_done   ---dev.c: 通用设备无关函数</span><br><span class="line">	  --&gt;napi_gro_flush==&gt;napi_gro_complete--&gt; 处理gro</span><br><span class="line">	   --&gt;netif_receive_skb_internal --如果打开了RPS,放到对应的cpu队列：enqueue_to_backlog</span><br><span class="line">	     --&gt;__netif_receive_skb --传递到协议栈</span><br></pre></td></tr></table></figure>
<ul>
<li>发送：<br>先看看定义的可供上层调用的函数接口：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> <span class="title">e1000_netdev_ops</span> = &#123;</span></span><br><span class="line">	.ndo_open		= e1000_open,</span><br><span class="line">	.ndo_stop		= e1000_close,</span><br><span class="line">	.ndo_start_xmit		= e1000_xmit_frame,</span><br><span class="line">	.ndo_get_stats		= e1000_get_stats,</span><br><span class="line">	.ndo_set_rx_mode	= e1000_set_rx_mode,<span class="comment">//设置接收模式，混杂模式或其他</span></span><br><span class="line">	.ndo_set_mac_address	= e1000_set_mac,<span class="comment">//设置mac地址</span></span><br><span class="line">	.ndo_tx_timeout		= e1000_tx_timeout,</span><br><span class="line">	.ndo_change_mtu		= e1000_change_mtu,</span><br><span class="line">	.ndo_do_ioctl		= e1000_ioctl,</span><br><span class="line">	.ndo_validate_addr	= eth_validate_addr,</span><br><span class="line">	.ndo_vlan_rx_add_vid	= e1000_vlan_rx_add_vid,</span><br><span class="line">	.ndo_vlan_rx_kill_vid	= e1000_vlan_rx_kill_vid,</span><br><span class="line">#ifdef CONFIG_NET_POLL_CONTROLLER</span><br><span class="line">	.ndo_poll_controller	= e1000_netpoll,</span><br><span class="line">#endif</span><br><span class="line">	.ndo_fix_features	= e1000_fix_features,</span><br><span class="line">	.ndo_set_features	= e1000_set_features,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到发送函数：e1000_xmit_frame<br>具体代码流程涉及较多设备相关的函数，暂不分析；</p>
<h6 id="wifi网卡-RTL8180解释"><a href="#wifi网卡-RTL8180解释" class="headerlink" title="wifi网卡 RTL8180解释"></a>wifi网卡 RTL8180解释</h6><p>wifi比较特殊，它有比较复杂的扫描和连接四次握手的流程，这块流程不属于数据包的处理，而是控制包的处理，linux内核将它交给了另一套流程，而上层应用用<br>wpa_supplicant来处理；</p>
<p>1) rtl8187 网卡驱动，是一个usb设备的；<br>它的一些相关函数定义在 drivers/…rtl8187/dev.c下<br>看下它支持的操作函数ops<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ieee80211_ops</span> <span class="title">rtl8187_ops</span> = &#123;</span></span><br><span class="line">	.tx			= rtl8187_tx,</span><br><span class="line">	.start			= rtl8187_start,</span><br><span class="line">	.stop			= rtl8187_stop,</span><br><span class="line">	.add_interface		= rtl8187_add_interface,</span><br><span class="line">	.remove_interface	= rtl8187_remove_interface,</span><br><span class="line">	.config			= rtl8187_config,</span><br><span class="line">	.bss_info_changed	= rtl8187_bss_info_changed,</span><br><span class="line">	.prepare_multicast	= rtl8187_prepare_multicast,</span><br><span class="line">	.configure_filter	= rtl8187_configure_filter,</span><br><span class="line">	.conf_tx		= rtl8187_conf_tx,</span><br><span class="line">	.rfkill_poll		= rtl8187_rfkill_poll,</span><br><span class="line">	.get_tsf		= rtl8187_get_tsf,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>start函数初始化了usb驱动需要的东西，并设置了接收数据的回调函数，可以理解为类似接收中断处理函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rtl8187_start</span><br><span class="line">    rtl8187_init_urbs(dev);</span><br><span class="line">        <span class="keyword">while</span> (skb_queue_len(&amp;priv-&gt;rx_queue) &lt; <span class="number">32</span>) &#123;</span><br><span class="line">		skb = __dev_alloc_skb(RTL8187_MAX_RX, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		entry = usb_alloc_urb(<span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		usb_fill_bulk_urb(entry, priv-&gt;udev,</span><br><span class="line">				  usb_rcvbulkpipe(priv-&gt;udev,</span><br><span class="line">				  priv-&gt;is_rtl8187b ? <span class="number">3</span> : <span class="number">1</span>),</span><br><span class="line">				  skb_tail_pointer(skb),</span><br><span class="line">				  RTL8187_MAX_RX, rtl8187_rx_cb, skb);<span class="comment">//接收的回调，这里接收到从usb输入的数据，可能是网络数据</span></span><br><span class="line">		info = (struct rtl8187_rx_info *)skb-&gt;cb;</span><br><span class="line">		info-&gt;urb = entry;</span><br><span class="line">		info-&gt;dev = dev;</span><br><span class="line">		skb_queue_tail(&amp;priv-&gt;rx_queue, skb);</span><br><span class="line">		usb_anchor_urb(entry, &amp;priv-&gt;anchored);</span><br><span class="line">		ret = usb_submit_urb(entry, GFP_KERNEL);<span class="comment">//提交后，usb设备核心在数据到达后，会调用回调函数，rx_cb</span></span><br><span class="line">		usb_put_urb(entry);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			skb_unlink(skb, &amp;priv-&gt;rx_queue);</span><br><span class="line">			usb_unanchor_urb(entry);</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">接收数据：</span><br><span class="line"></span><br><span class="line">rtl8187_rx_cb 收到包后：</span><br><span class="line">          skb = dev_alloc_skb(RTL8187_MAX_RX);<span class="comment">//分配skb</span></span><br><span class="line">          ieee80211_rx_irqsafe(dev, skb);</span><br><span class="line">          tasklet_schedule(&amp;local-&gt;tasklet);</span><br><span class="line">这里用的是tasklet来处理下半部：</span><br><span class="line">而这个是在ieee80211层处理的，在初始化这个模块时：</span><br><span class="line"><span class="function">struct ieee80211_hw *<span class="title">ieee80211_alloc_hw_nm</span><span class="params">(<span class="keyword">size_t</span> priv_data_len,</span></span></span><br><span class="line"><span class="function"><span class="params">    初始化：赋值软中断中半部</span></span></span><br><span class="line"><span class="function"><span class="params">tasklet_init(&amp;local-&gt;tx_pending_tasklet, ieee80211_tx_pending,</span></span></span><br><span class="line">		     (unsigned long)local);</span><br><span class="line"></span><br><span class="line">	tasklet_init(&amp;local-&gt;tasklet,</span><br><span class="line">		     ieee80211_tasklet_handler,</span><br><span class="line">		     (<span class="keyword">unsigned</span> <span class="keyword">long</span>) local);<span class="comment">//初始化了tasklet的handler，这样在usb接收到数据后能进入tasklet任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ieee80211_rx_irqsafe</span><span class="params">(struct ieee80211_hw *hw, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ieee80211_local</span> *<span class="title">local</span> = <span class="title">hw_to_local</span>(<span class="title">hw</span>);</span></span><br><span class="line"></span><br><span class="line">	BUILD_BUG_ON(<span class="keyword">sizeof</span>(struct ieee80211_rx_status) &gt; <span class="keyword">sizeof</span>(skb-&gt;cb));</span><br><span class="line"></span><br><span class="line">	skb-&gt;pkt_type = IEEE80211_RX_MSG;</span><br><span class="line">	skb_queue_tail(&amp;local-&gt;skb_queue, skb);</span><br><span class="line">	tasklet_schedule(&amp;local-&gt;tasklet);<span class="comment">//这里会进入</span></span><br><span class="line">&#125;</span><br><span class="line">--&gt; 进入到这个处理的handler:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ieee80211_tasklet_handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ieee80211_local</span> *<span class="title">local</span> = (<span class="title">struct</span> <span class="title">ieee80211_local</span> *) <span class="title">data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((skb = skb_dequeue(&amp;local-&gt;skb_queue)) ||</span><br><span class="line">	       (skb = skb_dequeue(&amp;local-&gt;skb_queue_unreliable))) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (skb-&gt;pkt_type) &#123;</span><br><span class="line">		<span class="keyword">case</span> IEEE80211_RX_MSG:</span><br><span class="line">			<span class="comment">/* Clear skb-&gt;pkt_type in order to not confuse kernel</span></span><br><span class="line"><span class="comment">			 * netstack. */</span></span><br><span class="line">			skb-&gt;pkt_type = <span class="number">0</span>;</span><br><span class="line">			ieee80211_rx(&amp;local-&gt;hw, skb);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> IEEE80211_TX_STATUS_MSG:</span><br><span class="line">			skb-&gt;pkt_type = <span class="number">0</span>;</span><br><span class="line">			ieee80211_tx_status(&amp;local-&gt;hw, skb);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			WARN(<span class="number">1</span>, <span class="string">"mac80211: Packet is of unknown type %d\n"</span>,</span><br><span class="line">			     skb-&gt;pkt_type);</span><br><span class="line">			dev_kfree_skb(skb);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">调用流程：</span><br><span class="line">ieee80211_tasklet_handler</span><br><span class="line">    ieee80211_rx</span><br><span class="line">调用流程： </span><br><span class="line">ieee80211_rx</span><br><span class="line">ieee80211_rx_napi</span><br><span class="line">__ieee80211_rx_handle_packet</span><br><span class="line">ieee80211_prepare_and_rx_handle</span><br><span class="line">ieee80211_invoke_rx_handlers</span><br><span class="line">ieee80211_rx_handlers</span><br><span class="line">ieee80211_rx_handlers_result</span><br><span class="line">ieee80211_rx_cooked_monitor--&gt;netif_receive_skb(skb);</span><br></pre></td></tr></table></figure>
<h5 id="rtl8180-pci接口的wifi网卡"><a href="#rtl8180-pci接口的wifi网卡" class="headerlink" title="rtl8180,pci接口的wifi网卡"></a>rtl8180,pci接口的wifi网卡</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8180</span>有中断处理：也一样；</span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">rtl8180_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"><span class="title">ieee80211_rx_irqsafe</span><span class="params">(dev, skb)</span></span>;</span><br></pre></td></tr></table></figure>
<p>ref:<br>参考资料：<br><a href="http://landley.net/kdocs/Documentation/DocBook/xhtml-nochunks/80211.html" target="_blank" rel="noopener">http://landley.net/kdocs/Documentation/DocBook/xhtml-nochunks/80211.html</a><br><a href="https://zhuanlan.zhihu.com/p/68425080" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68425080</a><br><a href="https://www.zhihu.com/question/31878199" target="_blank" rel="noopener">https://www.zhihu.com/question/31878199</a><br><a href="https://zhuanlan.zhihu.com/p/100616192" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/100616192</a></p>
<h4 id="虚拟网卡-tun例子"><a href="#虚拟网卡-tun例子" class="headerlink" title="虚拟网卡 tun例子"></a>虚拟网卡 tun例子</h4><p>ref:<br><a href="https://segmentfault.com/a/1190000009249039" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009249039</a><br>实现：<a href="http://vtun.sourceforge.net/" target="_blank" rel="noopener">http://vtun.sourceforge.net/</a><br>ifb也是一个虚拟网卡<br>和tun一样，ifb也是在数据包来自的地方和去往的地方做文章。对于tun而言，数据包在xmit中发往字符设备，而从字符设备写下来的数据包则在tun网卡上模拟一个rx操作，对于ifb而言，情况和这类似。<br>       ifb驱动太简单，以至于很短的话就可以将其说清，然后上一幅全景图，最后留下一点如何使用它的技巧，本文就完了。<br>       ifb驱动模拟一块虚拟网卡，它可以被看作是一个只有TC过滤功能的虚拟网卡，说它只有过滤功能，是因为它并不改变数据包的方向，即对于往外发的数据包被重定向到ifb之后，经过ifb的TC过滤之后，依然是通过重定向之前的网卡发出去，对于一个网卡接收的数据包，被重定向到ifb之后，经过ifb的TC过滤之后，依然被重定向之前的网卡继续进行接收处理，不管是从一块网卡发送数据包还是从一块网卡接收数据包，重定向到ifb之后，都要经过一个经由ifb虚拟网卡的dev_queue_xmit操作。</p>
<h3 id="如何调试linux收发内核问题；"><a href="#如何调试linux收发内核问题；" class="headerlink" title="如何调试linux收发内核问题；"></a>如何调试linux收发内核问题；</h3><p>连通性：<br>step:<br>1) 检查外部网络是否ok,比如其他机器是否正常等，本机物理网卡是否ok: 物理接口的连接，led灯,网线是否连接正常，wifi是否已完成扫描连接；<br>2) 检查基本的配置，ip,mac地址，网关等配置，这些影响数据的基本输入<br>3) 通过ping，上网工具如浏览器等，来判断整体网络连通情况，至此网络连通性检查基本完成，若不行，检查路由表，dns解析情况，尝试用纯ip进行访问；<br>4) 如果3)的检查不行，则尝试抓包，这个时候数据不经过协议栈，可以排除协议栈的影响，而考虑驱动，物理网络的影响；可以从相关设备驱动层的配置和特性如gro等考虑；  </p>
<p>收：以igb为例：在通过基本常规上层手段排除不出来问题时，可以从以下方面入手：<br>step: 介绍数据从设备-&gt;用户的基本流程等，并提供排查的基本手段；<br>1) 检查驱动程序是否已加载，初始化，start/open: 通过检查ifconfig，ethtool dev的状态，最极端的就是查日志；<br>2）检查硬件中断，软件中断是否运行正常，硬件中断查看cat /proc/interputs 软中断： /proc/softirqs<br>3) 查看ksoftirqd守护进程是否运行正常，每个cpu上都会运行一个，用来进行软中断poll数据；<br>4) 检查网卡多队列是否支持，若不支持，尽量提供RPS，RFS特性的启动；避免cpu高载导致网络收包延迟或丢包；尽量让收包处理分散在多个cpu上；<br>查看各网络接口的收发包情况：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cat /proc/net/dev</span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">  eth0: <span class="number">110346752214</span> <span class="number">597737500</span>    <span class="number">0</span>    <span class="number">2</span>    <span class="number">0</span>     <span class="number">0</span>          <span class="number">0</span>  <span class="number">20963860</span> <span class="number">990024805984</span> <span class="number">6066582604</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">    lo: <span class="number">428349463836</span> <span class="number">1579868535</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>          <span class="number">0</span>         <span class="number">0</span> <span class="number">428349463836</span> <span class="number">1579868535</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">查看网卡设备驱动和多队列配置等：</span><br><span class="line">ethtool -l eth0</span><br><span class="line">ethtool eth0</span><br><span class="line">ethtool -i eth0</span><br><span class="line">以及调整 具体man ethtool</span><br><span class="line">ethtool是设备驱动程序向上提供的接口，一般会有个单独的文件来实现，如e1000就有e1000_ethtool.c</span><br><span class="line">查硬中断是否为多队列多中断号：</span><br><span class="line">cat /proc/interrupts</span><br><span class="line">            CPU0       CPU1       CPU2       CPU3</span><br><span class="line">   <span class="number">0</span>:         <span class="number">46</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-IO-APIC-edge      timer</span><br><span class="line">   <span class="number">1</span>:          <span class="number">3</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-IO-APIC-edge      i8042</span><br><span class="line">  <span class="number">30</span>: <span class="number">3361234770</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-IO-APIC-fasteoi   aacraid</span><br><span class="line">  <span class="number">64</span>:          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> DMAR_MSI-edge      dmar0</span><br><span class="line">  <span class="number">65</span>:          <span class="number">1</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-PCI-MSI-edge      eth0</span><br><span class="line">  <span class="number">66</span>:  <span class="number">863649703</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-PCI-MSI-edge      eth0-TxRx<span class="number">-0</span></span><br><span class="line">  <span class="number">67</span>:  <span class="number">986285573</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-PCI-MSI-edge      eth0-TxRx<span class="number">-1</span></span><br><span class="line">  <span class="number">68</span>:         <span class="number">45</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-PCI-MSI-edge      eth0-TxRx<span class="number">-2</span></span><br><span class="line">  <span class="number">69</span>:        <span class="number">394</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-PCI-MSI-edge      eth0-TxRx<span class="number">-3</span></span><br><span class="line">查软中断收包情况：</span><br><span class="line">cat /proc/softirqs</span><br><span class="line">                    CPU0       CPU1       CPU2       CPU3</span><br><span class="line">          HI:          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">       TIMER: <span class="number">2831512516</span> <span class="number">1337085411</span> <span class="number">1103326083</span> <span class="number">1423923272</span></span><br><span class="line">      NET_TX:   <span class="number">15774435</span>     <span class="number">779806</span>     <span class="number">733217</span>     <span class="number">749512</span></span><br><span class="line">      NET_RX: <span class="number">1671622615</span> <span class="number">1257853535</span> <span class="number">2088429526</span> <span class="number">2674732223</span></span><br><span class="line">       BLOCK: <span class="number">1800253852</span>    <span class="number">1466177</span>    <span class="number">1791366</span>     <span class="number">634534</span></span><br><span class="line">设置cpu亲和性：</span><br><span class="line">eg:  sudo bash -c 'echo 1 &gt; /proc/irq/8/smp_affinity'</span><br><span class="line">设置包到net_rx_action时的budget值，会影响一次从设备中poll包的最大值</span><br><span class="line">sudo sysctl -w net.core.netdev_budget=<span class="number">600</span></span><br><span class="line">检查和调整GRO</span><br><span class="line">ethtool -k eth0 | grep generic-receive-offload</span><br><span class="line">generic-receive-offload: on</span><br><span class="line"></span><br><span class="line">开启和关闭RPS/RFS/..</span><br></pre></td></tr></table></figure>
<p>5) 包到达每个cpu的情况：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> /proc/net/softnet_stat:</span><br><span class="line"><span class="number">6</span>dcad223 <span class="number">00000000</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure></p>
<p>参数解释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Each line of /proc/net/softnet_stat corresponds to a <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> <span class="title">structure</span>, <span class="title">of</span> <span class="title">which</span> <span class="title">there</span> <span class="title">is</span> 1 <span class="title">per</span> <span class="title">CPU</span>.</span></span><br><span class="line"><span class="class"><span class="title">The</span> <span class="title">values</span> <span class="title">are</span> <span class="title">separated</span> <span class="title">by</span> <span class="title">a</span> <span class="title">single</span> <span class="title">space</span> <span class="title">and</span> <span class="title">are</span> <span class="title">displayed</span> <span class="title">in</span> <span class="title">hexadecimal</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">The</span> <span class="title">first</span> <span class="title">value</span>, <span class="title">sd</span>-&gt;<span class="title">processed</span>, <span class="title">is</span> <span class="title">the</span> <span class="title">number</span> <span class="title">of</span> <span class="title">network</span> <span class="title">frames</span> <span class="title">processed</span>. <span class="title">This</span> <span class="title">can</span> <span class="title">be</span> <span class="title">more</span> <span class="title">than</span> <span class="title">the</span> <span class="title">total</span> <span class="title">number</span> <span class="title">of</span> <span class="title">network</span> <span class="title">frames</span> <span class="title">received</span> <span class="title">if</span> <span class="title">you</span> <span class="title">are</span> <span class="title">using</span> <span class="title">ethernet</span> <span class="title">bonding</span>. <span class="title">There</span> <span class="title">are</span> <span class="title">cases</span> <span class="title">where</span> <span class="title">the</span> <span class="title">ethernet</span> <span class="title">bonding</span> <span class="title">driver</span> <span class="title">will</span> <span class="title">trigger</span> <span class="title">network</span> <span class="title">data</span> <span class="title">to</span> <span class="title">be</span> <span class="title">re</span>-<span class="title">processed</span>, <span class="title">which</span> <span class="title">would</span> <span class="title">increment</span> <span class="title">the</span> <span class="title">sd</span>-&gt;<span class="title">processed</span> <span class="title">count</span> <span class="title">more</span> <span class="title">than</span> <span class="title">once</span> <span class="title">for</span> <span class="title">the</span> <span class="title">same</span> <span class="title">packet</span>.</span></span><br><span class="line"><span class="class">第一列，是<span class="title">sd</span>-&gt;<span class="title">processed</span>,即处理的网络帧数；</span></span><br><span class="line"><span class="class"> __<span class="title">netif_receive_skb_core</span></span></span><br><span class="line"><span class="class">    __<span class="title">this_cpu_inc</span>(<span class="title">softnet_data</span>.<span class="title">processed</span>);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The second value, sd-&gt;dropped, is the number of network frames dropped because there was no room on the processing <span class="built_in">queue</span>. More on <span class="keyword">this</span> later.</span><br><span class="line"> enqueue_to_backlog(</span><br><span class="line">	  sd-&gt;dropped++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The third value, sd-&gt;time_squeeze, is (as we saw) the number of times the net_rx_action loop terminated because the budget was consumed <span class="keyword">or</span> the time limit was reached, but more work could have been. Increasing the budget as explained earlier can help reduce <span class="keyword">this</span>.</span><br><span class="line">The next <span class="number">5</span> values are always <span class="number">0.</span></span><br><span class="line">即在netif_rx_action过程中，异常中断的次数：</span><br><span class="line">		<span class="comment">/* If softirq window is exhausted then punt.</span></span><br><span class="line"><span class="comment">		 * Allow this to run for 2 jiffies since which will allow</span></span><br><span class="line"><span class="comment">		 * an average latency of 1.5/HZ.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(budget &lt;= <span class="number">0</span> ||</span><br><span class="line">			     time_after_eq(jiffies, time_limit))) &#123;</span><br><span class="line">			sd-&gt;time_squeeze++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The ninth value, sd-&gt;cpu_collision, is a count of the number of times a collision occurred when trying to obtain a device lock when transmitting packets. This article is about receive, so <span class="keyword">this</span> statistic will <span class="keyword">not</span> be seen below.</span><br><span class="line">发送的时候，cpu异常？ 这个目前都设置为<span class="number">0</span> 了，在最新的版本；</span><br><span class="line"></span><br><span class="line">The tenth value, sd-&gt;received_rps, is a count of the number of times <span class="keyword">this</span> CPU has been woken up to process packets via an Inter-processor Interrupt</span><br><span class="line">通过rps方式，即软中断打散的次数：</span><br><span class="line"><span class="comment">/* Called from hardirq (IPI) context */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> rps_trigger_softirq(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct softnet_data *sd = data;</span><br><span class="line"></span><br><span class="line">	____napi_schedule(sd, &amp;sd-&gt;backlog);</span><br><span class="line">	sd-&gt;received_rps++;</span><br><span class="line">&#125;</span><br><span class="line">The last value, flow_limit_count, is a count of the number of times the flow limit has been reached. Flow limiting is an optional Receive Packet Steering feature that will be examined shortly.超过flow最大限制的次数</span><br></pre></td></tr></table></figure>
<p>6) 数据包到达协议栈，会通过路由子系统，netfilter框架(防火墙)，或者用户自己开发的防火墙模块，包可能在这里被丢掉，需要检查；<br><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">$ cat /<span class="keyword">proc</span>/net/snmp</span><br><span class="line">Ip:<span class="title"> Forwarding</span> DefaultTTL<span class="title"> InReceives</span> InHdrErrors<span class="title"> InAddrErrors</span> ForwDatagrams<span class="title"> InUnknownProtos</span> InDiscards<span class="title"> InDelivers</span> OutRequests<span class="title"> OutDiscards</span> OutNoRoutes<span class="title"> ReasmTimeout</span> ReasmReqds<span class="title"> ReasmOKs</span> ReasmFails<span class="title"> FragOKs</span> FragFails<span class="title"> FragCreates</span></span><br><span class="line"><span class="title">Ip:</span> 1 64 25922988125 0 0 15771700 0 0 25898327616 22789396404 12987882 51 1 10129840 2196520 1 0 0 0</span><br><span class="line">统计了几个协议层的数据情况</span><br></pre></td></tr></table></figure></p>
<p>7) 包顺利进入到ip层；<br>ref:<br><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank" rel="noopener">https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/</a><br>收-图：<br><a href="https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/" target="_blank" rel="noopener">https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/</a><br>发<br><a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/" target="_blank" rel="noopener">https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/</a></p>
<h3 id="关于TSO-GSO-GRO等"><a href="#关于TSO-GSO-GRO等" class="headerlink" title="关于TSO ,GSO ,GRO等"></a>关于TSO ,GSO ,GRO等</h3><p>需要网卡支持<br>TSO(TCP Segmentation Offload)，是利用网卡对TCP数据包分片，减轻CPU负荷的一种技术，也有人叫 LSO (Large segment offload) ，TSO是针对TCP的，UFO是针对UDP的。如果硬件支持 TSO功能，同时也需要硬件支持的TCP校验计算和分散/聚集 (Scatter Gather) 功能。如果网卡支持TSO/GSO，可以把最多64K大小的TCP payload直接往下传给协议栈，此时IP层也不会进行segmentation，网卡会生成TCP/IP包头和帧头，这样可以offload很多协议栈上的内存操作，节省CPU资源，当然如果都是小包，那么功能基本就没啥用了。</p>
<p>GSO(Generic Segmentation Offload)，GSO是TSO的增强 ，GSO不只针对TCP，对任意协议。比TSO更通用，推迟数据分片直至发送到网卡驱动之前，此时会检查网卡是否支持分片功能（如TSO、UFO）,如果支持直接发送到网卡，如果不支持就进行分片后再发往网卡。</p>
<p>LRO(Large Receive Offload)，通过将接收到的多个TCP数据聚合成一个大的数据包，然后传递给网络协议栈处理，以减少上层协议栈处理 开销，提高系统接收TCP数据包的能力。</p>
<p>GRO(Generic Receive Offload)，跟LRO类似，克服了LRO的一些缺点，更通用。后续的驱动都使用GRO的接口，而不是LRO。<br>在系统中可以通过ethtool命令来进行查看，如下：</p>
<p>＃ethtool -k eth0</p>
<p>generic-segmentation-offload: on</p>
<p>generic-receive-offload: on</p>
<p>TSO、UFO、GSO是对应网络发送， LRO、GRO是在接收方向上</p>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_device</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_neighbor</title>
    <url>/2021/05/22/linux-neighbor/</url>
    <content><![CDATA[<h4 id="linux下邻居子系统的实现："><a href="#linux下邻居子系统的实现：" class="headerlink" title="linux下邻居子系统的实现："></a>linux下邻居子系统的实现：</h4><h5 id="什么是邻居子系统："><a href="#什么是邻居子系统：" class="headerlink" title="什么是邻居子系统："></a>什么是邻居子系统：</h5><p>在linux下，是一个用来管理网络中，二层的数据正确发送的系统，维护着二层地址相关结构，以及和三层地址映射等结构，<br>并提供更新，查询等缓存和接口；形成一个系统；供在发送数据时查询并正确发送到指定的机器上；<br><a id="more"></a></p>
<h5 id="邻居子系统的系统参数分类和总结："><a href="#邻居子系统的系统参数分类和总结：" class="headerlink" title="邻居子系统的系统参数分类和总结："></a>邻居子系统的系统参数分类和总结：</h5><ul>
<li><p>参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">base_reachable_time_ms: 邻居项有效期初始值，这个值会被来自更高协议正反馈延长；</span><br><span class="line">delay_first_probe_time: 邻居项过期后发送第一个探测之前的延迟时间，默认<span class="number">5</span>s</span><br><span class="line">gc_stale_time: 确定多久检测一次邻居项过期，默认<span class="number">60</span>s</span><br><span class="line">gc_interval:垃圾回收处理邻居项的时间间隔，默认<span class="number">30</span>s</span><br><span class="line"></span><br><span class="line">echo <span class="number">30</span> &gt; /proc/sys/net/ipv4/neigh/<span class="keyword">default</span>/gc_stale_time</span><br><span class="line">echo <span class="number">175</span> &gt; /proc/sys/net/ipv4/route/gc_timeout</span><br><span class="line">echo <span class="number">20000</span> &gt; /proc/sys/net/ipv4/neigh/<span class="keyword">default</span>/base_reachable_time_ms</span><br><span class="line">echo <span class="number">30</span> &gt; /proc/sys/net/ipv4/route/gc_interval</span><br><span class="line"></span><br><span class="line">pherricoxide@midigaurd:~$ ip -s neighbor <span class="built_in">list</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.42</span><span class="number">.1</span> dev eth0 lladdr <span class="number">00</span>:<span class="number">25</span>:<span class="number">90</span>:<span class="number">7</span>d:<span class="number">7</span>e:cd ref <span class="number">2</span> used <span class="number">184</span>/<span class="number">184</span>/<span class="number">139</span> probes <span class="number">4</span> STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.10</span><span class="number">.2</span> dev eth0 lladdr <span class="number">00</span>:<span class="number">1</span>c:<span class="number">23</span>:cf:<span class="number">0b</span>:<span class="number">6</span>a ref <span class="number">3</span> used <span class="number">33</span>/<span class="number">28</span>/<span class="number">0</span> probes <span class="number">1</span> REACHABLE</span><br><span class="line"><span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span> dev eth0 lladdr <span class="number">00</span>:<span class="number">17</span>:c5:d8:<span class="number">90</span>:a4 ref <span class="number">219</span> used <span class="number">275</span>/<span class="number">4</span>/<span class="number">121</span> probes <span class="number">1</span> REACHABLE</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数定义和使用的位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">---- base_reachable_time_ms Matches (8 in 4 files) ----</span><br><span class="line">ndisc_ifinfo_sysctl_change in ndisc.c (net\ipv6) : 		 (<span class="built_in">strcmp</span>(ctl-&gt;procname, <span class="string">"base_reachable_time_ms"</span>) == <span class="number">0</span>))</span><br><span class="line">neigh_proc_base_reachable_time in neighbour.c (net\core) : 	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ctl-&gt;procname, <span class="string">"base_reachable_time_ms"</span>) == <span class="number">0</span>)</span><br><span class="line">neighbour.c (net\core) line <span class="number">3076</span> : 		NEIGH_SYSCTL_MS_JIFFIES_REUSED_ENTRY(BASE_REACHABLE_TIME_MS, BASE_REACHABLE_TIME, <span class="string">"base_reachable_time_ms"</span>),</span><br><span class="line">neigh_sysctl_register in neighbour.c (net\core) : 		t-&gt;neigh_vars[NEIGH_VAR_BASE_REACHABLE_TIME_MS].proc_handler = handler;</span><br><span class="line">neigh_sysctl_register in neighbour.c (net\core) : 		t-&gt;neigh_vars[NEIGH_VAR_BASE_REACHABLE_TIME_MS].proc_handler =</span><br><span class="line">neighbour.h (include\net) line <span class="number">59</span> : 	NEIGH_VAR_BASE_REACHABLE_TIME_MS, <span class="comment">/* same data as NEIGH_VAR_BASE_REACHABLE_TIME */</span></span><br><span class="line">sysctl_binary.c (kernel) line <span class="number">285</span> : 	&#123; CTL_INT,	NET_NEIGH_REACHABLE_TIME_MS,	<span class="string">"base_reachable_time_ms"</span> &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">neigh_table</span> *<span class="title">neigh_tables</span>[<span class="title">NEIGH_NR_TABLES</span>] __<span class="title">read_mostly</span>;</span></span><br><span class="line">neigh_table_init(<span class="keyword">int</span> index, struct neigh_table *tbl)</span><br><span class="line">neigh_tables[index] = tbl;</span><br><span class="line"></span><br><span class="line">一个邻居协议，对应一个neigh_table表实例：多个邻居协议实例，放在上面的数组中，</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">neigh_table</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>			family;<span class="comment">//邻居协议所属的地址簇，如ARP为ipv4 ,AF_INET</span></span><br><span class="line">	<span class="keyword">int</span>			entry_size;<span class="comment">//邻居表中有多个邻居项，这个是邻居项结构的大小，对arp_tbl来说，初始化为sizeof(neighbour+4);</span></span><br><span class="line">                                                        <span class="comment">//因为在ARP中neighbour结构的最后一个成员primary_key，实际指向一个ipv4地址，4为ipv4地址长度；</span></span><br><span class="line">	<span class="keyword">int</span>			key_len;<span class="comment">//哈希函数用的key长度，key一般是三层协议地址，所以一般是4</span></span><br><span class="line">	__be16			protocol;</span><br><span class="line">	__u32			(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *pkey,  <span class="comment">//哈希函数，用来计算哈希值，arp为arp_hash()</span></span><br><span class="line">					<span class="keyword">const</span> struct net_device *dev,</span><br><span class="line">					__u32 *hash_rnd);</span><br><span class="line">	<span class="keyword">bool</span>			(*key_eq)(<span class="keyword">const</span> struct neighbour *, <span class="keyword">const</span> <span class="keyword">void</span> *pkey);</span><br><span class="line">	<span class="keyword">int</span>			(*constructor)(struct neighbour *);<span class="comment">//邻居项初始化函数，用于初始化一个新的neighbour结构中的相关字段，arp</span></span><br><span class="line">                                                                                <span class="comment">//为arp_constructor</span></span><br><span class="line">	<span class="keyword">int</span>			(*pconstructor)(struct pneigh_entry *);</span><br><span class="line">	<span class="keyword">void</span>			(*pdestructor)(struct pneigh_entry *); <span class="comment">//创建和释放一个代理项时被调用，ipv4没用，ipv6用了</span></span><br><span class="line">	<span class="keyword">void</span>			(*proxy_redo)(struct sk_buff *skb);<span class="comment">//用来处理neigh_table-&gt;proxy_queue缓存队列中的代理arp报文</span></span><br><span class="line">	<span class="keyword">char</span>			*id;<span class="comment">// 用来分配neighbour实例的缓冲池名字符串，arp为arp_cache</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neigh_parms</span>	<span class="title">parms</span>;</span>   <span class="comment">//存储一些和协议相关的可调节参数，如重传超时时间，proxy_queue队列长</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">parms_list</span>;</span></span><br><span class="line">	<span class="keyword">int</span>			gc_interval;<span class="comment">//垃圾回收时钟gc_timer的到期间隔时间，即到期时触发一次垃圾回收，初始值是30s</span></span><br><span class="line">	<span class="keyword">int</span>			gc_thresh1;</span><br><span class="line">	<span class="keyword">int</span>			gc_thresh2;</span><br><span class="line">	<span class="keyword">int</span>			gc_thresh3; <span class="comment">//这三个阈值对应内存对邻居项作垃圾回收处理的不同级别，若缓存邻居项数少于gc_thresh1,则不执行删除，超过gc_thresh2则在新建邻居项时若超过5s为刷新，则立即刷新，并做强制回收处理，超过gc_thresh3则，新建邻居项时，立即刷新并强制垃圾回收</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		last_flush;<span class="comment">//记录最近一次调用neigh_forced_gc强制刷新邻居表的时间；用于判断是否回收</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">gc_work</span>;</span><span class="comment">//垃圾回收的相关结构，包括垃圾回收定时器</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> 	<span class="title">proxy_timer</span>;</span> <span class="comment">//处理proxy_queue队列的定时器，当proxy_queue为空，则第一个arp报文加入队列时，会启动这个定时器；在neigh_table_init中初始化，处理在neigh_proxy_process中处理；</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>	<span class="title">proxy_queue</span>;</span><span class="comment">//对于接收到需要进行代理的arp报文，需要先缓存到这个队列，在定时器处理函数中再处理它；</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		entries; <span class="comment">//整个邻居表中邻居项的数目</span></span><br><span class="line">	<span class="keyword">rwlock_t</span>		lock; <span class="comment">//用于控制邻居表的读写锁 如look_up只需要读，而neigh_periodic_timer需要写</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		last_rand; <span class="comment">//用于记录neigh_params结构中的reachable_time成员最近一次被更新的时间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neigh_statistics</span>	__<span class="title">percpu</span> *<span class="title">stats</span>;</span> <span class="comment">//各类统计数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neigh_hash_table</span> __<span class="title">rcu</span> *<span class="title">nht</span>;</span> <span class="comment">// 见下</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pneigh_entry</span>	**<span class="title">phash_buckets</span>;</span><span class="comment">//见下</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	NEIGH_ARP_TABLE = <span class="number">0</span>,</span><br><span class="line">	NEIGH_ND_TABLE = <span class="number">1</span>,</span><br><span class="line">	NEIGH_DN_TABLE = <span class="number">2</span>,</span><br><span class="line">	NEIGH_NR_TABLES,</span><br><span class="line">	NEIGH_LINK_TABLE = NEIGH_NR_TABLES <span class="comment">/* Pseudo table for neigh_xmit */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	neighbour table manipulation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEIGH_NUM_HASH_RND	4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">neigh_hash_table</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neighbour</span> __<span class="title">rcu</span>	**<span class="title">hash_buckets</span>;</span> <span class="comment">//用于存储邻居项的散列表，改散列表在分配邻居项时，若邻居项数量超过散列表容量，可以动态扩容</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		hash_shift;</span><br><span class="line">	__u32			hash_rnd[NEIGH_NUM_HASH_RND];<span class="comment">//随机数，用来在hash_buckets散列表扩容时计算关键字，以避免受到arp攻击</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pneigh_entry</span> &#123;</span> <span class="comment">//存储arp代理三层协议地址的散列表，在neigh_table_init_no_netlink中完成初始化</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pneigh_entry</span>	*<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">possible_net_t</span>		net;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>	*<span class="title">dev</span>;</span></span><br><span class="line">	u8			flags;</span><br><span class="line">	u8			key[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">邻居表中一个邻居项的表示的结构体：</span><br><span class="line">邻居项存储了邻居相关信息，包括状态，二层，三层协议地址，提供给三层协议的函数指针，定时器和缓存的二层首部等；注意一个邻居不代表一个主机，而是一个三层协议地址，因为对于配置了多接口的主机，一个主机将对应多个三层地址;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">neighbour</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neighbour</span> __<span class="title">rcu</span>	*<span class="title">next</span>;</span> <span class="comment">//通过next串起来邻居表的所有邻居项</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neigh_table</span>	*<span class="title">tbl</span>;</span><span class="comment">//指向所属的邻居表的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neigh_parms</span>	*<span class="title">parms</span>;</span> <span class="comment">//用于调节邻居协议的参数，在创建邻居项的neigh_create中会调用alloc分配，其中会进行初始化，接着调constructor进行设置</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		confirmed;<span class="comment">//记录最近一次确认该邻居可达性的时间，用来描述邻居可达性；接收到回复时更新；传输层通过neigh_confirm来更新，而邻居子系统则通过neigh_update来更新</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		updated;<span class="comment">//记录最近一次被neigh_update更新的时间；和confirm不同；他们针对不同的特性</span></span><br><span class="line">	<span class="keyword">rwlock_t</span>		lock; <span class="comment">//用来控制访问邻居项的读写锁</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		refcnt;<span class="comment">//引用计数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>	<span class="title">arp_queue</span>;</span><span class="comment">//当邻居项状态处于无效时，用来缓存要发送的报文。若处于INCOMPLETE时，发送第一个要更新的；。。。</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		arp_queue_len_bytes;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>	<span class="title">timer</span>;</span><span class="comment">//管理多种超时情况的定时器</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		used;<span class="comment">//最近一次被使用时间，不同状态下被不同函数更新，如neigh_event_send()和gc_timer</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		probes; <span class="comment">//尝试发送请求报文而未能得到应答的次数；在定时器中被检测，当达到阈值时 ，进入NUD_FAILED状态</span></span><br><span class="line">	__u8			flags; <span class="comment">//记录一些标志和特性</span></span><br><span class="line">	__u8			nud_state; <span class="comment">//邻居项状态</span></span><br><span class="line">	__u8			type; <span class="comment">//邻居地址的类型：对arp: RTN_UNICAST，RIN_LOCAL等</span></span><br><span class="line">	__u8			dead;<span class="comment">//生存标志，为1则表示正被删除</span></span><br><span class="line">	<span class="keyword">seqlock_t</span>		ha_lock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>		ha[ALIGN(MAX_ADDR_LEN, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>))]; <span class="comment">//与存储在primary_key中的三层地址对应的二进制二层硬件地址；6B,其他链路可能更长，以太网是6B</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hh_cache</span>		<span class="title">hh</span>;</span><span class="comment">//缓存的二层协议首部hh_cache</span></span><br><span class="line">	<span class="keyword">int</span>			(*output)(struct neighbour *, struct sk_buff *);<span class="comment">//输出函数，用来将报文输出到该邻居；在邻居项生命周期中，由于其状态不断变化，所以该函数指针会指向不同的输出函数，如可达时调用neigh_connect()将output置为 neigh_ops--&gt;connected_output</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">neigh_ops</span>	*<span class="title">ops</span>;</span><span class="comment">//指向邻居项函数指针实例</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>	*<span class="title">dev</span>;</span>  <span class="comment">//通过此网络设备可访问到该邻居；对每个邻居而言，只有一个</span></span><br><span class="line">	u8			primary_key[<span class="number">0</span>];<span class="comment">//存储哈希函数使用的三层协议地址；</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">neigh_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>			family;</span><br><span class="line">	<span class="keyword">void</span>			(*solicit)(struct neighbour *, struct sk_buff *);<span class="comment">//发送请求报文函数，在发送第一个报文时，需要新的邻居项，发送的报文会被缓存到arp_queue中，然后调用solicit()发送请求报文</span></span><br><span class="line">	<span class="keyword">void</span>			(*error_report)(struct neighbour *, struct sk_buff *);<span class="comment">//当邻居项缓存着未发送的数据报文时，而该邻居项又不可达，被调用来向三层报告错误的函数，如arp_error_report(),最后会向报文发送方发送一个主机不可达的icmp差错报文</span></span><br><span class="line">	<span class="keyword">int</span>			(*output)(struct neighbour *, struct sk_buff *);<span class="comment">//最通用的output函数，可用于所有情况；实现了完整的输出过程，此函数消耗资源。注意不要将neigh_ops-&gt;output和neighbour-&gt;output混淆</span></span><br><span class="line">	<span class="keyword">int</span>			(*connected_output)(struct neighbour *, struct sk_buff *);<span class="comment">//邻居可达时，即状态为NUD_CONNECTED时；只是简单的加二层头，所以比上面的output快</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">neigh_parms</span> &#123;</span><span class="comment">//邻居协议参数配置块，用来存储可调节的邻居协议参数，如重传超时时间，proxy_queueu长度等；</span></span><br><span class="line">	<span class="keyword">possible_net_t</span> net;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">int</span>	(*neigh_setup)(struct neighbour *);<span class="comment">//提供给老式接口设备的初始化和销毁接口，注意区分net_device中的setup成员函数</span></span><br><span class="line">	<span class="keyword">void</span>	(*neigh_cleanup)(struct neighbour *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neigh_table</span> *<span class="title">tbl</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>	*sysctl_table;<span class="comment">//邻居表的sysctl表 ，arp_init中初始化，这样用户可以通过proc来读写</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> dead;</span><br><span class="line">	<span class="keyword">atomic_t</span> refcnt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>	reachable_time;</span><br><span class="line">	<span class="keyword">int</span>	data[NEIGH_VAR_DATA_MAX];</span><br><span class="line">	DECLARE_BITMAP(data_state, NEIGH_VAR_DATA_MAX);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pneigh_entry</span> &#123;</span><span class="comment">//用来保存允许代理的条件，只有和结构中的接收设备以及目标地址相匹配才能代理，保存在phash_buckets散列表中，称为代理项，可以通过ip neigh add proxy命令添加；</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pneigh_entry</span>	*<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">possible_net_t</span>		net;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>	*<span class="title">dev</span>;</span><span class="comment">//通过该设备接收到的arp请求报文才能代理</span></span><br><span class="line">	u8			flags;</span><br><span class="line">	u8			key[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//统计数据：一个该结构实例对应一个网络设备上的一种邻居协议</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">neigh_statistics</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> allocs;		<span class="comment">/* number of allocated neighs */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> destroys;		<span class="comment">/* number of destroyed neighs */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hash_grows;	<span class="comment">/* number of hash resizes */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> res_failed;	<span class="comment">/* number of failed resolutions */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> lookups;		<span class="comment">/* number of lookups */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hits;		<span class="comment">/* number of hits (among lookups) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rcv_probes_mcast;	<span class="comment">/* number of received mcast ipv6 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rcv_probes_ucast; <span class="comment">/* number of received ucast ipv6 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> periodic_gc_runs;	<span class="comment">/* number of periodic GC runs */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> forced_gc_runs;	<span class="comment">/* number of forced GC runs */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> unres_discards;	<span class="comment">/* number of unresolved drops */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> table_fulls;      <span class="comment">/* times even gc couldn't help */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hh_cache定义在netdevice.h中，是用来缓存二层首部的，这样可以复制而不是逐个设置，加快输出报文</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hh_cache</span> &#123;</span></span><br><span class="line">	u16		hh_len;</span><br><span class="line">	u16		__pad;</span><br><span class="line">	<span class="keyword">seqlock_t</span>	hh_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cached hardware header; allow for machine alignment needs.        */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HH_DATA_MOD	16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HH_DATA_OFF(__len) \</span></span><br><span class="line">	(HH_DATA_MOD - (((__len - <span class="number">1</span>) &amp; (HH_DATA_MOD - <span class="number">1</span>)) + <span class="number">1</span>))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HH_DATA_ALIGN(__len) \</span></span><br><span class="line">	(((__len)+(HH_DATA_MOD<span class="number">-1</span>))&amp;~(HH_DATA_MOD - <span class="number">1</span>))</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	hh_data[HH_DATA_ALIGN(LL_MAX_HEADER) / <span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>邻居表的初始化：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">neigh_table_init</span><span class="params">(<span class="keyword">int</span> index, struct neigh_table *tbl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> now = jiffies;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> phsize;</span><br><span class="line">           <span class="comment">//就是将表中的字段复制到项中</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;tbl-&gt;parms_list);</span><br><span class="line">	list_add(&amp;tbl-&gt;parms.<span class="built_in">list</span>, &amp;tbl-&gt;parms_list);</span><br><span class="line">	write_pnet(&amp;tbl-&gt;parms.net, &amp;init_net);</span><br><span class="line">	atomic_set(&amp;tbl-&gt;parms.refcnt, <span class="number">1</span>);</span><br><span class="line">	tbl-&gt;parms.reachable_time =</span><br><span class="line">			  neigh_rand_reach_time(NEIGH_VAR(&amp;tbl-&gt;parms, BASE_REACHABLE_TIME));</span><br><span class="line"></span><br><span class="line">	tbl-&gt;stats = alloc_percpu(struct neigh_statistics);</span><br><span class="line">	<span class="keyword">if</span> (!tbl-&gt;stats)</span><br><span class="line">		panic(<span class="string">"cannot create neighbour cache statistics"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="keyword">if</span> (!proc_create_data(tbl-&gt;id, <span class="number">0</span>, init_net.proc_net_stat,</span><br><span class="line">			      &amp;neigh_stat_seq_fops, tbl))</span><br><span class="line">		panic(<span class="string">"cannot create neighbour proc dir entry"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	RCU_INIT_POINTER(tbl-&gt;nht, neigh_hash_alloc(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">	phsize = (PNEIGH_HASHMASK + <span class="number">1</span>) * <span class="keyword">sizeof</span>(struct pneigh_entry *);</span><br><span class="line">	tbl-&gt;phash_buckets = kzalloc(phsize, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tbl-&gt;nht || !tbl-&gt;phash_buckets)</span><br><span class="line">		panic(<span class="string">"cannot allocate neighbour cache hashes"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tbl-&gt;entry_size)</span><br><span class="line">		tbl-&gt;entry_size = ALIGN(offsetof(struct neighbour, primary_key) +</span><br><span class="line">					tbl-&gt;key_len, NEIGH_PRIV_ALIGN);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		WARN_ON(tbl-&gt;entry_size % NEIGH_PRIV_ALIGN);</span><br><span class="line">           <span class="comment">//建立定时器，并初始化定时器，包括两个定时器，老化(垃圾回收)定时器和proxy代理定时器</span></span><br><span class="line">	rwlock_init(&amp;tbl-&gt;lock);</span><br><span class="line">	INIT_DEFERRABLE_WORK(&amp;tbl-&gt;gc_work, neigh_periodic_work);<span class="comment">//老化定时器对应的处理函数是neigh_periodic_work</span></span><br><span class="line">	queue_delayed_work(system_power_efficient_wq, &amp;tbl-&gt;gc_work,</span><br><span class="line">			tbl-&gt;parms.reachable_time);</span><br><span class="line">	setup_timer(&amp;tbl-&gt;proxy_timer, neigh_proxy_process, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)tbl);<span class="comment">//proxy_timer对应的处理函数是neigh_proxy_process</span></span><br><span class="line">	skb_queue_head_init_class(&amp;tbl-&gt;proxy_queue,</span><br><span class="line">			&amp;neigh_table_proxy_queue_class);</span><br><span class="line"></span><br><span class="line">	tbl-&gt;last_flush = now;</span><br><span class="line">	tbl-&gt;last_rand	= now + tbl-&gt;parms.reachable_time * <span class="number">20</span>;</span><br><span class="line">           <span class="comment">//放到全局数组中</span></span><br><span class="line">	neigh_tables[index] = tbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>邻居表的老化定时器和对应的状态机：<br>邻居表项有一个对于管理和维护邻居表来说很重要的成员： nud_state; 表示邻居项当前的状态；7种；<br>邻居表老化定时器定时扫描所有邻居表项，然后进行如下的状态迁移和处理<br>图+各个状态解释</li>
</ul>
<ul>
<li>邻居项的创建： 分配和创建初始化；<br>neigh_create: neigh_alloc</li>
</ul>
<ul>
<li><p>邻居表项扩容：<br>static struct neigh_hash_table <em>neigh_hash_grow(struct neigh_table </em>tbl,</p>
<pre><code>unsigned long new_shift)
</code></pre></li>
<li><p>邻居表的各种操作：<br>邻居项的查找： neigh_look_up 查找频繁，添加和删除等都需要先查找<br>邻居项的更新： neigh_update: 更新内容：硬件地址和状态，并根据状态更新输出函数<br>垃圾回收：<br>同步回收： 在创建新的邻居项时，达到条件触发；<br>异步回收： 定时检测并看是否触发回收<br>外部事件的通知和处理：当网络设备NETDEV_UNREGISTER事件发生时，若邻居协议模块对此感兴趣，会调用此接口：neigh_ifdown;<br>如arp: arp_ifdown-&gt;neigh_ifdown; 另外还有neigh_changeaddr  </p>
</li>
<li><p>每个邻居项的定时函数：<br>邻居项的状态中，有些属于定时状态； 每个邻居项都有一个定时器，在创建邻居项时被初始化</p>
</li>
<li><p>关于代理项：phash_buckets<br>查找： pneigh_lookup  删除 pneigh_delete<br>延时处理代理的请求报文：pneigh_enqueue</p>
</li>
<li><p>关于输出函数：<br>丢弃： neigh_blackhole();<br>慢速发送：neigh_resolve_output<br>快速发送： dst_output后–&gt; neigh_hh_output / neigh_connected_output</p>
</li>
<li><p>关于邻居代理，arp代理：<br>arp代理：<br>对一个二层协议，在一个局域网内，则使用二层地址寻找，当不在此局域网了，则通过路由器网关转发出去；<br>但是可能在一个局域网内有多个子网，通过路由器或交换机转发，但是主机不知道，所以这个时候依然用相同的方式去发送arp请求，当处于不同子网的两个主机arp时，<br>则此时需要依赖路由器打开arp代理转发功能，若开启，则会在收到arp请求时，返回自己的mac地址，这样相当于转发功能，会收到数据，转发给对方主机，然后从对方主机收到后又进行转发；</p>
</li>
</ul>
<p>注意到整个流程：<br>   arp会缓存数据包，然后等到arp邻居项可用了，再把数据包发出去；</p>
<ul>
<li>arp外部事件通知：<br> 当一个设备的ip地址发生变化，arp模块通过注册到通知链中arp_netdev_notifier收到通知，调用arp_netdev_event来处理NETDEV_CHANGEADDR事件；删除释放与禁用网络设备相关的邻居项；等</li>
</ul>
<ul>
<li>路由表项与邻居项的绑定：<br>  在路由模块中，每当添加一条输出路由或是单播转发路由时，会尝试将 该路由与该路由目的地址相对应的邻居项绑定；<br>arp_bind_neighbour 实现了路由表项与邻居绑定的功能；在绑定过程中，若对应的邻居项不存在，则新建一个邻居项后绑定；之后 再输出报文时就可以通过路由缓存找到<br>输出函数了；</li>
</ul>
<h4 id="内核中的arp实现："><a href="#内核中的arp实现：" class="headerlink" title="内核中的arp实现："></a>内核中的arp实现：</h4><ul>
<li><p>arp收包：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Receive an arp request from the device layer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">arp_rcv</span><span class="params">(struct sk_buff *skb, struct net_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">		   struct packet_type *pt, struct net_device *orig_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">arphdr</span> *<span class="title">arp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do not tweak dropwatch on an ARP we will ignore */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;flags &amp; IFF_NOARP ||</span><br><span class="line">	    skb-&gt;pkt_type == PACKET_OTHERHOST ||</span><br><span class="line">	    skb-&gt;pkt_type == PACKET_LOOPBACK)</span><br><span class="line">		<span class="keyword">goto</span> consumeskb;</span><br><span class="line"></span><br><span class="line">	skb = skb_share_check(skb, GFP_ATOMIC);<span class="comment">//检测并返回skb,当被检测的skb被引用多次时，则克隆此skb,并返回克隆得到的skb;</span></span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">goto</span> out_of_mem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ARP header, plus 2 device addresses, plus 2 IP addresses.  */</span></span><br><span class="line">	<span class="keyword">if</span> (!pskb_may_pull(skb, arp_hdr_len(dev)))<span class="comment">// 在skb中加4个地址？</span></span><br><span class="line">		<span class="keyword">goto</span> freeskb;</span><br><span class="line">           /这个函数的解释： pskb_may_pull(..)</span><br><span class="line">             <span class="comment">/* Moves tail of skb head forward, copying data from fragmented part,</span></span><br><span class="line"><span class="comment"> * when it is necessary.</span></span><br><span class="line"><span class="comment"> * 1. It may fail due to malloc failure.</span></span><br><span class="line"><span class="comment"> * 2. It may change skb pointers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is pretty complicated. Luckily, it is called only in exceptional cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">       /</span><br><span class="line"></span><br><span class="line">	arp = arp_hdr(skb);  <span class="comment">//从skb中拿arp头，然后下面做检测</span></span><br><span class="line">	<span class="keyword">if</span> (arp-&gt;ar_hln != dev-&gt;addr_len || arp-&gt;ar_pln != <span class="number">4</span>)</span><br><span class="line">		<span class="keyword">goto</span> freeskb;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(NEIGH_CB(skb), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct neighbour_cb));<span class="comment">//把skb中的cb字段清空，见下的解释 control buffer</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_ARP, NF_ARP_IN,</span><br><span class="line">		       dev_net(dev), <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">		       arp_process); <span class="comment">//通过netfilter 处理后再转到arp_process</span></span><br><span class="line"></span><br><span class="line">consumeskb:</span><br><span class="line">	consume_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line">freeskb:</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">out_of_mem:</span><br><span class="line">	<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">The control buffer is an e­junkyard that can be used as a scratch pad during processing by a given</span><br><span class="line">layer of the protocol.   Its main use is by the IP layer to compile header options.</span><br><span class="line"> <span class="number">265</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 266 * This is the control buffer. It is free to use for every</span></span><br><span class="line"><span class="comment"> 267 * layer. Please put your private variables there. If you</span></span><br><span class="line"><span class="comment"> 268 * want to keep them across layers you have to skb_clone()</span></span><br><span class="line"><span class="comment"> 269 * first. This is owned by whoever has the skb queued ATM.</span></span><br><span class="line"><span class="comment"> 270 */</span></span><br><span class="line"> <span class="number">271</span> <span class="keyword">char</span> cb[<span class="number">48</span>];</span><br><span class="line"> <span class="number">272</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来进入到arp_process，主要做arp包的头的校验及：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Process an arp request.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">arp_process</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">skb</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_device</span> *<span class="title">in_dev</span> = __<span class="title">in_dev_get_rcu</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arphdr</span> *<span class="title">arp</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *arp_ptr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *sha;</span><br><span class="line">	__be32 sip, tip;</span><br><span class="line">	u16 dev_type = dev-&gt;type;</span><br><span class="line">	<span class="keyword">int</span> addr_type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neighbour</span> *<span class="title">n</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dst_entry</span> *<span class="title">reply_dst</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> is_garp = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* arp_rcv below verifies the ARP header and verifies the device</span></span><br><span class="line"><span class="comment">	 * is ARP'able.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!in_dev)</span><br><span class="line">		<span class="keyword">goto</span> out_free_skb;</span><br><span class="line">           <span class="comment">//拿到arp的头</span></span><br><span class="line">	arp = arp_hdr(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (dev_type) &#123;</span><br><span class="line">	<span class="keyword">default</span>:    <span class="comment">//三层一样的，所以先做检测三层协议格式是不是ip,以及二层的和dev的是不是一样</span></span><br><span class="line">		<span class="keyword">if</span> (arp-&gt;ar_pro != htons(ETH_P_IP) ||</span><br><span class="line">		    htons(dev_type) != arp-&gt;ar_hrd)</span><br><span class="line">			<span class="keyword">goto</span> out_free_skb;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//检查二层的格式</span></span><br><span class="line">	<span class="keyword">case</span> ARPHRD_ETHER:</span><br><span class="line">	<span class="keyword">case</span> ARPHRD_FDDI:</span><br><span class="line">	<span class="keyword">case</span> ARPHRD_IEEE802:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * ETHERNET, and Fibre Channel (which are IEEE 802</span></span><br><span class="line"><span class="comment">		 * devices, according to RFC 2625) devices will accept ARP</span></span><br><span class="line"><span class="comment">		 * hardware types of either 1 (Ethernet) or 6 (IEEE 802.2).</span></span><br><span class="line"><span class="comment">		 * This is the case also of FDDI, where the RFC 1390 says that</span></span><br><span class="line"><span class="comment">		 * FDDI devices should accept ARP hardware of (1) Ethernet,</span></span><br><span class="line"><span class="comment">		 * however, to be more robust, we'll accept both 1 (Ethernet)</span></span><br><span class="line"><span class="comment">		 * or 6 (IEEE 802.2)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((arp-&gt;ar_hrd != htons(ARPHRD_ETHER) &amp;&amp;</span><br><span class="line">		     arp-&gt;ar_hrd != htons(ARPHRD_IEEE802)) ||</span><br><span class="line">		    arp-&gt;ar_pro != htons(ETH_P_IP))</span><br><span class="line">			<span class="keyword">goto</span> out_free_skb;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ARPHRD_AX25:</span><br><span class="line">		<span class="keyword">if</span> (arp-&gt;ar_pro != htons(AX25_P_IP) ||</span><br><span class="line">		    arp-&gt;ar_hrd != htons(ARPHRD_AX25))</span><br><span class="line">			<span class="keyword">goto</span> out_free_skb;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ARPHRD_NETROM:</span><br><span class="line">		<span class="keyword">if</span> (arp-&gt;ar_pro != htons(AX25_P_IP) ||</span><br><span class="line">		    arp-&gt;ar_hrd != htons(ARPHRD_NETROM))</span><br><span class="line">			<span class="keyword">goto</span> out_free_skb;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Understand only these message types */</span></span><br><span class="line">            <span class="comment">//这里只会处理arp请求和回复</span></span><br><span class="line">	<span class="keyword">if</span> (arp-&gt;ar_op != htons(ARPOP_REPLY) &amp;&amp;</span><br><span class="line">	    arp-&gt;ar_op != htons(ARPOP_REQUEST))</span><br><span class="line">		<span class="keyword">goto</span> out_free_skb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Extract fields</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	arp_ptr = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)(arp + <span class="number">1</span>);</span><br><span class="line">	sha	= arp_ptr;</span><br><span class="line">	arp_ptr += dev-&gt;addr_len;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;sip, arp_ptr, <span class="number">4</span>);</span><br><span class="line">	arp_ptr += <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">switch</span> (dev_type) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_FIREWIRE_NET)</span></span><br><span class="line">	<span class="keyword">case</span> ARPHRD_IEEE1394:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		arp_ptr += dev-&gt;addr_len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;tip, arp_ptr, <span class="number">4</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Check for bad requests for 127.x.x.x and requests for multicast</span></span><br><span class="line"><span class="comment"> *	addresses.  If this is one such, delete it.</span></span><br><span class="line"><span class="comment"> */</span>         <span class="comment">//对本地环回的不需要处理？</span></span><br><span class="line">	<span class="keyword">if</span> (ipv4_is_multicast(tip) ||</span><br><span class="line">	    (!IN_DEV_ROUTE_LOCALNET(in_dev) &amp;&amp; ipv4_is_loopback(tip)))</span><br><span class="line">		<span class="keyword">goto</span> out_free_skb;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *	For some 802.11 wireless deployments (and possibly other networks),</span></span><br><span class="line"><span class="comment">  *	there will be an ARP proxy and gratuitous ARP frames are attacks</span></span><br><span class="line"><span class="comment">  *	and thus should not be accepted.</span></span><br><span class="line"><span class="comment">  */</span>        <span class="comment">//对80211无线网络，可能是arp攻击，所以也不接受</span></span><br><span class="line">	<span class="keyword">if</span> (sip == tip &amp;&amp; IN_DEV_ORCONF(in_dev, DROP_GRATUITOUS_ARP))</span><br><span class="line">		<span class="keyword">goto</span> out_free_skb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     Special case: We must set Frame Relay source Q.922 address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">if</span> (dev_type == ARPHRD_DLCI)</span><br><span class="line">		sha = dev-&gt;broadcast;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Process entry.  The idea here is we want to send a reply if it is a</span></span><br><span class="line"><span class="comment"> *  request for us or if it is a request for someone else that we hold</span></span><br><span class="line"><span class="comment"> *  a proxy for.  We want to add an entry to our cache if it is a reply</span></span><br><span class="line"><span class="comment"> *  to us or if it is a request for our address.</span></span><br><span class="line"><span class="comment"> *  (The assumption for this last is that if someone is requesting our</span></span><br><span class="line"><span class="comment"> *  address, they are probably intending to talk to us, so it saves time</span></span><br><span class="line"><span class="comment"> *  if we cache their address.  Their address is also probably not in</span></span><br><span class="line"><span class="comment"> *  our cache, since ours is not in their cache.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Putting this another way, we only care about replies if they are to</span></span><br><span class="line"><span class="comment"> *  us, in which case we add them to the cache.  For requests, we care</span></span><br><span class="line"><span class="comment"> *  about those for us and those for our proxies.  We reply to both,</span></span><br><span class="line"><span class="comment"> *  and in the case of requests for us we add the requester to the arp</span></span><br><span class="line"><span class="comment"> *  cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">           <span class="comment">//对arp请求的处理</span></span><br><span class="line">	<span class="keyword">if</span> (arp-&gt;ar_op == htons(ARPOP_REQUEST) &amp;&amp; skb_metadata_dst(skb))</span><br><span class="line">		reply_dst = (struct dst_entry *)</span><br><span class="line">			    iptunnel_metadata_reply(skb_metadata_dst(skb),</span><br><span class="line">						    GFP_ATOMIC);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Special case: IPv4 duplicate address detection packet (RFC2131) */</span></span><br><span class="line">	<span class="keyword">if</span> (sip == <span class="number">0</span>) &#123;<span class="comment">//请求报文的源ip为0，则该arp报文是用来检测ipv4地址冲突的 rfc2131,因此在确定请求报文的目标ip地址为本地ip后，以该ip地址为源地址及目标地址发送arp应答报文</span></span><br><span class="line">		<span class="keyword">if</span> (arp-&gt;ar_op == htons(ARPOP_REQUEST) &amp;&amp;</span><br><span class="line">		    inet_addr_type_dev_table(net, dev, tip) == RTN_LOCAL &amp;&amp;</span><br><span class="line">		    !arp_ignore(in_dev, sip, tip))</span><br><span class="line">			arp_send_dst(ARPOP_REPLY, ETH_P_ARP, sip, dev, tip,</span><br><span class="line">				     sha, dev-&gt;dev_addr, sha, reply_dst);</span><br><span class="line">		<span class="keyword">goto</span> out_consume_skb;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arp-&gt;ar_op == htons(ARPOP_REQUEST) &amp;&amp; <span class="comment">//若为arp请求报文且能找到目的ip地址tip对应的路由</span></span><br><span class="line">	    ip_route_input_noref(skb, tip, sip, <span class="number">0</span>, dev) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		rt = skb_rtable(skb);</span><br><span class="line">		addr_type = rt-&gt;rt_type;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (addr_type == RTN_LOCAL) &#123;<span class="comment">//若是本地接收的</span></span><br><span class="line">			<span class="keyword">int</span> dont_send;</span><br><span class="line"></span><br><span class="line">			dont_send = arp_ignore(in_dev, sip, tip);</span><br><span class="line">			<span class="keyword">if</span> (!dont_send &amp;&amp; IN_DEV_ARPFILTER(in_dev))</span><br><span class="line">				dont_send = arp_filter(sip, tip, dev);<span class="comment">//过滤</span></span><br><span class="line">			<span class="keyword">if</span> (!dont_send) &#123;</span><br><span class="line">				n = neigh_event_ns(&amp;arp_tbl, sha, &amp;sip, dev);<span class="comment">//调用来更新邻居项</span></span><br><span class="line">				<span class="keyword">if</span> (n) &#123;</span><br><span class="line">					arp_send_dst(ARPOP_REPLY, ETH_P_ARP,<span class="comment">//发送arp应答报文</span></span><br><span class="line">						     sip, dev, tip, sha,</span><br><span class="line">						     dev-&gt;dev_addr, sha,</span><br><span class="line">						     reply_dst);</span><br><span class="line">					neigh_release(n);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">goto</span> out_consume_skb;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IN_DEV_FORWARD(in_dev)) &#123;<span class="comment">//若不是发送给本地的，看看是否要做代理缓存</span></span><br><span class="line">			<span class="keyword">if</span> (addr_type == RTN_UNICAST  &amp;&amp;</span><br><span class="line">			    (arp_fwd_proxy(in_dev, dev, rt) ||</span><br><span class="line">			     arp_fwd_pvlan(in_dev, dev, rt, sip, tip) ||</span><br><span class="line">			     (rt-&gt;dst.dev != dev &amp;&amp;</span><br><span class="line">			      pneigh_lookup(&amp;arp_tbl, net, &amp;tip, dev, <span class="number">0</span>)))) &#123;</span><br><span class="line">				n = neigh_event_ns(&amp;arp_tbl, sha, &amp;sip, dev);</span><br><span class="line">				<span class="keyword">if</span> (n)</span><br><span class="line">					neigh_release(n);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (NEIGH_CB(skb)-&gt;flags &amp; LOCALLY_ENQUEUED ||</span><br><span class="line">				    skb-&gt;pkt_type == PACKET_HOST ||</span><br><span class="line">				    NEIGH_VAR(in_dev-&gt;arp_parms, PROXY_DELAY) == <span class="number">0</span>) &#123;</span><br><span class="line">					arp_send_dst(ARPOP_REPLY, ETH_P_ARP,</span><br><span class="line">						     sip, dev, tip, sha,</span><br><span class="line">						     dev-&gt;dev_addr, sha,</span><br><span class="line">						     reply_dst);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					pneigh_enqueue(&amp;arp_tbl,</span><br><span class="line">						       in_dev-&gt;arp_parms, skb);</span><br><span class="line">					<span class="keyword">goto</span> out_free_dst;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">goto</span> out_consume_skb;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update our ARP tables */</span></span><br><span class="line">            <span class="comment">//下面做更新arp表的操作</span></span><br><span class="line">	n = __neigh_lookup(&amp;arp_tbl, &amp;sip, dev, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IN_DEV_ARP_ACCEPT(in_dev)) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> addr_type = inet_addr_type_dev_table(net, dev, sip);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Unsolicited ARP is not accepted by default.</span></span><br><span class="line"><span class="comment">		   It is possible, that this option should be enabled for some</span></span><br><span class="line"><span class="comment">		   devices (strip is candidate)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		is_garp = arp-&gt;ar_op == htons(ARPOP_REQUEST) &amp;&amp; tip == sip &amp;&amp;</span><br><span class="line">			  addr_type == RTN_UNICAST;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!n &amp;&amp;</span><br><span class="line">		    ((arp-&gt;ar_op == htons(ARPOP_REPLY)  &amp;&amp;</span><br><span class="line">				addr_type == RTN_UNICAST) || is_garp))</span><br><span class="line">			n = __neigh_lookup(&amp;arp_tbl, &amp;sip, dev, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n) &#123;</span><br><span class="line">		<span class="keyword">int</span> state = NUD_REACHABLE;</span><br><span class="line">		<span class="keyword">int</span> override;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If several different ARP replies follows back-to-back,</span></span><br><span class="line"><span class="comment">		   use the FIRST one. It is possible, if several proxy</span></span><br><span class="line"><span class="comment">		   agents are active. Taking the first reply prevents</span></span><br><span class="line"><span class="comment">		   arp trashing and chooses the fastest router.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		override = time_after(jiffies,</span><br><span class="line">				      n-&gt;updated +</span><br><span class="line">				      NEIGH_VAR(n-&gt;parms, LOCKTIME)) ||</span><br><span class="line">			   is_garp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Broadcast replies and request packets</span></span><br><span class="line"><span class="comment">		   do not assert neighbour reachability.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (arp-&gt;ar_op != htons(ARPOP_REPLY) ||</span><br><span class="line">		    skb-&gt;pkt_type != PACKET_HOST)</span><br><span class="line">			state = NUD_STALE;</span><br><span class="line">		neigh_update(n, sha, state,</span><br><span class="line">			     override ? NEIGH_UPDATE_F_OVERRIDE : <span class="number">0</span>);</span><br><span class="line">		neigh_release(n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_consume_skb:</span><br><span class="line">	consume_skb(skb);</span><br><span class="line"></span><br><span class="line">out_free_dst:</span><br><span class="line">	dst_release(reply_dst);</span><br><span class="line">	<span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line"></span><br><span class="line">out_free_skb:</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>arp发送时和发送接口：<br>1) 一些发送接口；注意是发送arp请求的，不是数据包</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arp_send</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> ptype, __be32 dest_ip,</span></span></span><br><span class="line"><span class="function"><span class="params">	      struct net_device *dev, __be32 src_ip,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest_hw, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *src_hw,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *target_hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	arp_send_dst(type, ptype, dest_ip, dev, src_ip, dest_hw, src_hw,  --有三个接口会调用它：arp_send/arp_solicit/arp_process</span><br><span class="line">		     target_hw, <span class="literal">NULL</span>); ---会调用arp_create创建+arp_xmit发送</span><br><span class="line">&#125;</span><br><span class="line">创建arp报文：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Create an arp packet. If dest_hw is not set, we create a broadcast</span></span><br><span class="line"><span class="comment"> *	message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct sk_buff *<span class="title">arp_create</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> ptype, __be32 dest_ip,</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2）三层发送数据包时：<br>三层发送需要时会把数据包缓存起来，arp邻居项状态达到connected时发送；</p>
<ul>
<li>arp老化定时器：结合图</li>
<li><p>邻居表老化定时器<br>neigh_periodic_work</p>
</li>
<li><p>邻居项定时器：<br>neigh_timer_handler</p>
</li>
<li><p>代理项定时器<br>neigh_proxy_process</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>neighbor</tag>
      </tags>
  </entry>
  <entry>
    <title>interrupt</title>
    <url>/2021/04/17/interrupt/</url>
    <content><![CDATA[<h3 id="中断概述"><a href="#中断概述" class="headerlink" title="中断概述"></a>中断概述</h3><p>除了系统调用外，中断也是一种内核活动；系统调用不是在用户态和系统状态之间切换的唯一途径<br>中断的处理往往会涉及到汇编等和硬件相关的代码，但是中断处理部分随着时间的演化，已经达到了这样一种状态：高层代码和底层的硬件交互代码，已经尽可能有效而干净<br>地分隔开了。<a id="more"></a></p>
<h3 id="中断框架："><a href="#中断框架：" class="headerlink" title="中断框架："></a>中断框架：</h3><p>老版本的linux，中断代码比较杂乱，新版本，因为其中引入了一个用于中断和IRQ的通用框架。各个平台现在只负责在最低层次上与硬件交互。所有其他功能都由通用代码提供</p>
<h4 id="中断类型："><a href="#中断类型：" class="headerlink" title="中断类型："></a>中断类型：</h4><p>同步中断和异步中断，两者都是通过中断服务程序（ISR中断处理程序）来处理的</p>
<h5 id="同步中断和异常"><a href="#同步中断和异常" class="headerlink" title="同步中断和异常"></a>同步中断和异常</h5><p>由cpu产生，针对当前执行的程序，比如除0，内核可能通过信号机制通知进程，进程做默认或注册行为比如输出错误信息，或者直接结束；<br>异常情况也可能是如缺页异常，这种由内核自动修复，进程往往无感知；</p>
<h5 id="异步中断"><a href="#异步中断" class="headerlink" title="异步中断"></a>异步中断</h5><p>经典的中断，由外部设备产生，可能发生在任意时间。不同于同步中断，<br>异步中断并不与特定进程关联。它们可能发生在任何时间，而不牵涉系统当前执行的活动。 ①<br>网卡通过发出一个相关的中断来报告新分组的到达。因为数据可能在任意时刻到达系统，所<br>以当前执行的很可能是与数据无关的某个进程或其他东西。为避免损害该进程，内核必须确<br>保中断能够尽快处理完毕（通过缓冲数据），使得CPU时间能够返还给当前进程。这也是内核<br>需要延期操作机制的原因</p>
<h5 id="中断的一些其他逻辑："><a href="#中断的一些其他逻辑：" class="headerlink" title="中断的一些其他逻辑："></a>中断的一些其他逻辑：</h5><ul>
<li>禁用中断，应尽量避免；</li>
<li>设备共享中断编号–中断共享</li>
</ul>
<h3 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h3><p>由系统自身和与之连接的外设自动产生。它们用于支持更高效地实现设备驱动程序，也用于引起处理器自身对异常或错误的关注，这些是需要与内核代码进行交互的。<br>中断不能由处理器外部的外设直接产生，而必须借助于一个称为中断控制器(interrupt controller)的标准组件来请求，该组件存在于每个系统中。<br>/proc/interrupts 这个文件可以查看系统的中断编号和对应中断；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~/c++/ptrace$ cat /proc/interrupts </span><br><span class="line">           CPU0       CPU1       </span><br><span class="line">  <span class="number">0</span>:         <span class="number">39</span>          <span class="number">0</span>   IO-APIC   <span class="number">2</span>-edge      timer</span><br><span class="line">  <span class="number">1</span>:       <span class="number">3038</span>          <span class="number">0</span>   IO-APIC   <span class="number">1</span>-edge      i8042</span><br><span class="line">  <span class="number">8</span>:          <span class="number">0</span>          <span class="number">0</span>   IO-APIC   <span class="number">8</span>-edge      rtc0</span><br><span class="line">  <span class="number">9</span>:          <span class="number">0</span>          <span class="number">0</span>   IO-APIC   <span class="number">9</span>-fasteoi   acpi</span><br><span class="line"> <span class="number">12</span>:       <span class="number">3144</span>          <span class="number">0</span>   IO-APIC  <span class="number">12</span>-edge      i8042</span><br><span class="line"> <span class="number">14</span>:          <span class="number">0</span>          <span class="number">0</span>   IO-APIC  <span class="number">14</span>-edge      ata_piix</span><br><span class="line"> <span class="number">15</span>:       <span class="number">9824</span>          <span class="number">0</span>   IO-APIC  <span class="number">15</span>-edge      ata_piix</span><br><span class="line"> <span class="number">18</span>:          <span class="number">0</span>          <span class="number">0</span>   IO-APIC  <span class="number">18</span>-fasteoi   vmwgfx</span><br><span class="line"> <span class="number">19</span>:        <span class="number">129</span>       <span class="number">7562</span>   IO-APIC  <span class="number">19</span>-fasteoi   eth0</span><br><span class="line"> <span class="number">20</span>:      <span class="number">18055</span>          <span class="number">0</span>   IO-APIC  <span class="number">20</span>-fasteoi   vboxguest</span><br><span class="line"> <span class="number">21</span>:      <span class="number">46875</span>          <span class="number">0</span>   IO-APIC  <span class="number">21</span>-fasteoi   <span class="number">0000</span>:<span class="number">00</span>:<span class="number">0</span>d<span class="number">.0</span>, snd_intel8x0</span><br><span class="line"> <span class="number">22</span>:         <span class="number">27</span>          <span class="number">0</span>   IO-APIC  <span class="number">22</span>-fasteoi   ohci_hcd:usb1</span><br><span class="line">NMI:          <span class="number">0</span>          <span class="number">0</span>   Non-maskable interrupts</span><br><span class="line">LOC:     <span class="number">257382</span>     <span class="number">487413</span>   Local timer interrupts</span><br><span class="line">SPU:          <span class="number">0</span>          <span class="number">0</span>   Spurious interrupts</span><br><span class="line">PMI:          <span class="number">0</span>          <span class="number">0</span>   Performance monitoring interrupts</span><br><span class="line">IWI:          <span class="number">0</span>          <span class="number">0</span>   IRQ work interrupts</span><br><span class="line">RTR:          <span class="number">0</span>          <span class="number">0</span>   APIC ICR read retries</span><br><span class="line">RES:     <span class="number">299362</span>     <span class="number">323826</span>   Rescheduling interrupts</span><br><span class="line">CAL:       <span class="number">2173</span>      <span class="number">26988</span>   Function call interrupts</span><br><span class="line">TLB:       <span class="number">1760</span>       <span class="number">1871</span>   TLB shootdowns</span><br><span class="line">TRM:          <span class="number">0</span>          <span class="number">0</span>   Thermal event interrupts</span><br><span class="line">THR:          <span class="number">0</span>          <span class="number">0</span>   Threshold APIC interrupts</span><br><span class="line">DFR:          <span class="number">0</span>          <span class="number">0</span>   Deferred Error APIC interrupts</span><br><span class="line">MCE:          <span class="number">0</span>          <span class="number">0</span>   Machine check exceptions</span><br><span class="line">MCP:         <span class="number">35</span>         <span class="number">35</span>   Machine check polls</span><br><span class="line">ERR:          <span class="number">0</span></span><br><span class="line">MIS:          <span class="number">0</span></span><br><span class="line">PIN:          <span class="number">0</span>          <span class="number">0</span>   Posted-interrupt notification event</span><br><span class="line">PIW:          <span class="number">0</span>          <span class="number">0</span>   Posted-interrupt wakeup event</span><br></pre></td></tr></table></figure></p>
<h4 id="硬件中断的处理"><a href="#硬件中断的处理" class="headerlink" title="硬件中断的处理"></a>硬件中断的处理</h4><h5 id="进入和退出任务："><a href="#进入和退出任务：" class="headerlink" title="进入和退出任务："></a>进入和退出任务：</h5><p>首先，必须建立一个适当的环境，使得处理程序函数能够在其中执行，接下来调用处理程序自身，最后将系统复原（在当前程序看来）到中断之前的状态。<br>进入是从用户态切到核心太，退出是从核心态到用户态，而且需要通过调度器是否选择新进程替代旧进程；中断到达时也可能处于核心态，所以这个时候需要判断；</p>
<h5 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h5><ul>
<li>特点：<br>可以禁用中断来防止被打断，但是只能短时间使用，处理过程短暂；<br>可以在其他ISR执行期间调用的中断处理程序，不能彼此干扰<br>可延期的处理，不用在中断处理程序中实现，可以放到类似下半部的软中断；或者tasklet</li>
</ul>
<h4 id="中断相关数据结构："><a href="#中断相关数据结构：" class="headerlink" title="中断相关数据结构："></a>中断相关数据结构：</h4><ul>
<li>总的数组：<br>在kernel/irq/handle.c,kernel/irq/irqdesc.c:可以看到初始化的中断处理数组；每个都被处理为handle_bad_irq;此时还没赋值；<br>赋值发生在驱动程序或模块初始化时调用request_irq等类似函数进行注册；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> <span class="title">irq_desc</span>[<span class="title">NR_IRQS</span>] __<span class="title">cacheline_aligned_in_smp</span> = &#123;</span></span><br><span class="line">	[<span class="number">0</span> ... NR_IRQS<span class="number">-1</span>] = &#123;</span><br><span class="line">		.handle_irq	= handle_bad_irq,</span><br><span class="line">		.depth		= <span class="number">1</span>,</span><br><span class="line">		.lock		= __RAW_SPIN_LOCK_UNLOCKED(irq_desc-&gt;lock),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但IRQ的最大可能数目是通过一个平台相关的常数NR_IRQS指定的。大多数体系结构下，该常数定义在处理器相关的头文件include/asm-generic/irq.h中<br>不同处理器可能支持的不同；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NR_IRQS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_IRQS 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>数组每个元素：<br>看下中断处理数组中每个元素的结构：每个irq都可以由该结构完全描述<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct irq_desc - interrupt descriptor</span></span><br><span class="line"><span class="comment"> * @irq_common_data:	per irq and chip data passed down to chip functions</span></span><br><span class="line"><span class="comment"> * @kstat_irqs:		irq stats per cpu</span></span><br><span class="line"><span class="comment"> * @handle_irq:		highlevel irq-events handler</span></span><br><span class="line"><span class="comment"> 电流层ISR由handle_irq提供。 handler_data可以指向任意数据，该数据可以是特定于IRQ</span></span><br><span class="line"><span class="comment">或处理程序的。每当发生中断时，特定于体系结构的代码都会调用handle_irq。该函数负责</span></span><br><span class="line"><span class="comment">使用chip中提供的特定于控制器的方法，进行处理中断所必需的一些底层操作。用于不同中</span></span><br><span class="line"><span class="comment">断类型的默认函数由内核提供。 </span></span><br><span class="line"><span class="comment"> * @preflow_handler:	handler called before the flow handler (currently used by sparc)</span></span><br><span class="line"><span class="comment"> * @action:		the irq action chain    irq操作列表</span></span><br><span class="line"><span class="comment"> action提供了一个操作链，需要在中断发生时执行。由中断通知的设备驱动程序，可以将与</span></span><br><span class="line"><span class="comment">之相关的处理程序函数放置在此处。有一个专门的数据结构用于表示这些操作</span></span><br><span class="line"><span class="comment"> * @status:		status information      irq状态</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit masks for irq_common_data.state_use_accessors</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IRQD_TRIGGER_MASK		- Mask for the trigger type bits</span></span><br><span class="line"><span class="comment"> * IRQD_SETAFFINITY_PENDING	- Affinity setting is pending</span></span><br><span class="line"><span class="comment"> * IRQD_NO_BALANCING		- Balancing disabled for this IRQ</span></span><br><span class="line"><span class="comment"> * IRQD_PER_CPU			- Interrupt is per cpu</span></span><br><span class="line"><span class="comment"> * IRQD_AFFINITY_SET		- Interrupt affinity was set</span></span><br><span class="line"><span class="comment"> * IRQD_LEVEL			- Interrupt is level triggered</span></span><br><span class="line"><span class="comment"> * IRQD_WAKEUP_STATE		- Interrupt is configured for wakeup</span></span><br><span class="line"><span class="comment"> *				  from suspend</span></span><br><span class="line"><span class="comment"> * IRDQ_MOVE_PCNTXT		- Interrupt can be moved in process</span></span><br><span class="line"><span class="comment"> *				  context</span></span><br><span class="line"><span class="comment"> * IRQD_IRQ_DISABLED		- Disabled state of the interrupt</span></span><br><span class="line"><span class="comment"> * IRQD_IRQ_MASKED		- Masked state of the interrupt</span></span><br><span class="line"><span class="comment"> * IRQD_IRQ_INPROGRESS		- In progress state of the interrupt</span></span><br><span class="line"><span class="comment"> * IRQD_WAKEUP_ARMED		- Wakeup mode armed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">enum &#123;</span></span><br><span class="line"><span class="comment">	IRQD_TRIGGER_MASK		= 0xf,</span></span><br><span class="line"><span class="comment">	IRQD_SETAFFINITY_PENDING	= (1 &lt;&lt;  8),</span></span><br><span class="line"><span class="comment">	IRQD_NO_BALANCING		= (1 &lt;&lt; 10),</span></span><br><span class="line"><span class="comment">	IRQD_PER_CPU			= (1 &lt;&lt; 11),</span></span><br><span class="line"><span class="comment">	IRQD_AFFINITY_SET		= (1 &lt;&lt; 12),</span></span><br><span class="line"><span class="comment">	IRQD_LEVEL			= (1 &lt;&lt; 13),</span></span><br><span class="line"><span class="comment">	IRQD_WAKEUP_STATE		= (1 &lt;&lt; 14),</span></span><br><span class="line"><span class="comment">	IRQD_MOVE_PCNTXT		= (1 &lt;&lt; 15),</span></span><br><span class="line"><span class="comment">	IRQD_IRQ_DISABLED		= (1 &lt;&lt; 16),</span></span><br><span class="line"><span class="comment">	IRQD_IRQ_MASKED			= (1 &lt;&lt; 17),</span></span><br><span class="line"><span class="comment">	IRQD_IRQ_INPROGRESS		= (1 &lt;&lt; 18),</span></span><br><span class="line"><span class="comment">	IRQD_WAKEUP_ARMED		= (1 &lt;&lt; 19),</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* @core_internal_state__do_not_mess_with_it: core internal status information</span></span><br><span class="line"><span class="comment"> * @depth:		disable-depth, for nested irq_disable() calls</span></span><br><span class="line"><span class="comment"> * @wake_depth:		enable depth, for multiple irq_set_irq_wake() callers</span></span><br><span class="line"><span class="comment"> * @irq_count:		stats field to detect stalled irqs</span></span><br><span class="line"><span class="comment"> * @last_unhandled:	aging timer for unhandled count</span></span><br><span class="line"><span class="comment"> * @irqs_unhandled:	stats field for spurious unhandled interrupts</span></span><br><span class="line"><span class="comment"> * @threads_handled:	stats field for deferred spurious detection of threaded handlers</span></span><br><span class="line"><span class="comment"> * @threads_handled_last: comparator field for deferred spurious detection of theraded handlers</span></span><br><span class="line"><span class="comment"> * @lock:		locking for SMP</span></span><br><span class="line"><span class="comment"> * @affinity_hint:	hint to user space for preferred irq affinity</span></span><br><span class="line"><span class="comment"> * @affinity_notify:	context for notification of affinity changes</span></span><br><span class="line"><span class="comment"> * @pending_mask:	pending rebalanced interrupts</span></span><br><span class="line"><span class="comment"> * @threads_oneshot:	bitfield to handle shared oneshot threads</span></span><br><span class="line"><span class="comment"> * @threads_active:	number of irqaction threads currently running</span></span><br><span class="line"><span class="comment"> * @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers</span></span><br><span class="line"><span class="comment"> * @nr_actions:		number of installed actions on this descriptor</span></span><br><span class="line"><span class="comment"> * @no_suspend_depth:	number of irqactions on a irq descriptor with</span></span><br><span class="line"><span class="comment"> *			IRQF_NO_SUSPEND set</span></span><br><span class="line"><span class="comment"> * @force_resume_depth:	number of irqactions on a irq descriptor with</span></span><br><span class="line"><span class="comment"> *			IRQF_FORCE_RESUME set</span></span><br><span class="line"><span class="comment"> * @dir:		/proc/irq/ procfs entry</span></span><br><span class="line"><span class="comment"> * @name:		flow handler name for /proc/interrupts output</span></span><br><span class="line"><span class="comment">  name指定了电流层处理程序的名称，将显示在/proc/interrupts中。对边沿触发中断，通常</span></span><br><span class="line"><span class="comment">是“edge”，对电平触发中断，通常是“level”。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>	<span class="title">irq_common_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>		<span class="title">irq_data</span>;</span> <span class="comment">//其中包含了irq_chip成员：用于表示一个IRQ控制器抽象的具体特征；</span></span><br><span class="line"><span class="comment">//通常在一个系统上只有一种类型的中断控制器会占据支配地位（当然，并没有什么约束条件阻止多个控制器并存），所有irq_desc的 irq_data的chip成员都指向irq_chip的同一实例</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> __percpu	*kstat_irqs;</span><br><span class="line">	<span class="keyword">irq_flow_handler_t</span>	handle_irq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IRQ_PREFLOW_FASTEOI</span></span><br><span class="line">	<span class="keyword">irq_preflow_handler_t</span>	preflow_handler;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">action</span>;</span>	<span class="comment">/* IRQ action list */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		status_use_accessors;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		core_internal_state__do_not_mess_with_it;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		depth;		<span class="comment">/* nested irq disables */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		wake_depth;	<span class="comment">/* nested wake enables */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		irq_count;	<span class="comment">/* For detecting broken IRQs */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		last_unhandled;	<span class="comment">/* Aging timer for unhandled count */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		irqs_unhandled;</span><br><span class="line">	<span class="keyword">atomic_t</span>		threads_handled;</span><br><span class="line">	<span class="keyword">int</span>			threads_handled_last;</span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>		*<span class="title">percpu_enabled</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>	*<span class="title">affinity_hint</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_affinity_notify</span> *<span class="title">affinity_notify</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_PENDING_IRQ</span></span><br><span class="line">	<span class="keyword">cpumask_var_t</span>		pending_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		threads_oneshot;</span><br><span class="line">	<span class="keyword">atomic_t</span>		threads_active;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span>       wait_for_threads;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		nr_actions;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		no_suspend_depth;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cond_suspend_depth;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		force_resume_depth;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span>			parent_irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一些结构的解释：</p>
<ul>
<li>irq控制器抽象：<br>struct irq_data        irq_data; //其中包含了irq_chip成员：用于表示一个IRQ控制器抽象的具体特征；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct irq_chip - hardware interrupt chip descriptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @name:		name for /proc/interrupts</span></span><br><span class="line"><span class="comment"> * @irq_startup:	start up the interrupt (defaults to -&gt;enable if NULL)</span></span><br><span class="line"><span class="comment"> * @irq_shutdown:	shut down the interrupt (defaults to -&gt;disable if NULL)</span></span><br><span class="line"><span class="comment"> * @irq_enable:		enable the interrupt (defaults to chip-&gt;unmask if NULL)</span></span><br><span class="line"><span class="comment"> * @irq_disable:	disable the interrupt</span></span><br><span class="line"><span class="comment"> * @irq_ack:		start of a new interrupt</span></span><br><span class="line"><span class="comment"> * @irq_mask:		mask an interrupt source</span></span><br><span class="line"><span class="comment"> * @irq_mask_ack:	ack and mask an interrupt source</span></span><br><span class="line"><span class="comment"> * @irq_unmask:		unmask an interrupt source</span></span><br><span class="line"><span class="comment"> * @irq_eoi:		end of interrupt</span></span><br><span class="line"><span class="comment"> * @irq_set_affinity:	set the CPU affinity on SMP machines</span></span><br><span class="line"><span class="comment"> * @irq_retrigger:	resend an IRQ to the CPU</span></span><br><span class="line"><span class="comment"> * @irq_set_type:	set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ</span></span><br><span class="line"><span class="comment"> * @irq_set_wake:	enable/disable power-management wake-on of an IRQ</span></span><br><span class="line"><span class="comment"> * @irq_bus_lock:	function to lock access to slow bus (i2c) chips</span></span><br><span class="line"><span class="comment"> * @irq_bus_sync_unlock:function to sync and unlock slow bus (i2c) chips</span></span><br><span class="line"><span class="comment"> * @irq_cpu_online:	configure an interrupt source for a secondary CPU</span></span><br><span class="line"><span class="comment"> * @irq_cpu_offline:	un-configure an interrupt source for a secondary CPU</span></span><br><span class="line"><span class="comment"> * @irq_suspend:	function called from core code on suspend once per chip</span></span><br><span class="line"><span class="comment"> * @irq_resume:		function called from core code on resume once per chip</span></span><br><span class="line"><span class="comment"> * @irq_pm_shutdown:	function called from core code on shutdown once per chip</span></span><br><span class="line"><span class="comment"> * @irq_calc_mask:	Optional function to set irq_data.mask for special cases</span></span><br><span class="line"><span class="comment"> * @irq_print_chip:	optional to print special chip info in show_interrupts</span></span><br><span class="line"><span class="comment"> * @irq_request_resources:	optional to request resources before calling</span></span><br><span class="line"><span class="comment"> *				any other callback related to this irq</span></span><br><span class="line"><span class="comment"> * @irq_release_resources:	optional to release resources acquired with</span></span><br><span class="line"><span class="comment"> *				irq_request_resources</span></span><br><span class="line"><span class="comment"> * @irq_compose_msi_msg:	optional to compose message content for MSI</span></span><br><span class="line"><span class="comment"> * @irq_write_msi_msg:	optional to write message content for MSI</span></span><br><span class="line"><span class="comment"> * @irq_get_irqchip_state:	return the internal state of an interrupt</span></span><br><span class="line"><span class="comment"> * @irq_set_irqchip_state:	set the internal state of a interrupt</span></span><br><span class="line"><span class="comment"> * @flags:		chip specific flags</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 结构需要考虑内核中出现的各个IRQ实现的所有特性。因而，一个该结构的特定实例，通常只</span><br><span class="line">定义所有可能方法的一个子集</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>	*name;<span class="comment">//表示硬件控制器，</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*irq_startup)</span><span class="params">(struct irq_data *data)</span></span>;<span class="comment">//用于第一次初始化一个IRQ</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_shutdown)(struct irq_data *data);<span class="comment">//完全关闭一个中断源</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_enable)(struct irq_data *data);<span class="comment">//用于激活一个IRQ</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_disable)(struct irq_data *data);<span class="comment">//禁用IRQ</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_ack)(struct irq_data *data);</span><br><span class="line">    <span class="comment">//在某些模型中， IRQ请求的到达（以及在处理器的对应中</span></span><br><span class="line">断）必须显式确认，后续的请求才能进行处理。如果芯片组没有这样的要求，该指针可以指</span><br><span class="line">向一个空函数，或<span class="literal">NULL</span>指针。 ack_and_mask确认一个中断，并在接下来屏蔽该中断。</span><br><span class="line">	<span class="keyword">void</span>		(*irq_mask)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_mask_ack)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_unmask)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_eoi)(struct irq_data *data);<span class="comment">//eoi表示end of interrupt，即中断结束</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_affinity)(struct irq_data *data, <span class="keyword">const</span> struct cpumask *dest, <span class="keyword">bool</span> force);</span><br><span class="line">	<span class="keyword">int</span>		(*irq_retrigger)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_type)(struct irq_data *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> flow_type);</span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_wake)(struct irq_data *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> on);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_bus_lock)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_bus_sync_unlock)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_cpu_online)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_cpu_offline)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_suspend)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_resume)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_pm_shutdown)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_calc_mask)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);</span><br><span class="line">	<span class="keyword">int</span>		(*irq_request_resources)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_release_resources)(struct irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*irq_get_irqchip_state)(struct irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="keyword">bool</span> *state);</span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_irqchip_state)(struct irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="keyword">bool</span> state);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>找一个例子看看：/arch/x86/kernel/i8295.c:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> <span class="title">i8259A_chip</span> = &#123;</span></span><br><span class="line">	.name		= <span class="string">"XT-PIC"</span>,</span><br><span class="line">	.irq_mask	= disable_8259A_irq,</span><br><span class="line">	.irq_disable	= disable_8259A_irq,</span><br><span class="line">	.irq_unmask	= enable_8259A_irq,</span><br><span class="line">	.irq_mask_ack	= mask_and_ack_8259A,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>处理程序函数的表示：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct irqaction - per interrupt action descriptor</span></span><br><span class="line"><span class="comment"> * @handler:	interrupt handler function</span></span><br><span class="line"><span class="comment"> * @name:	name of the device</span></span><br><span class="line"><span class="comment"> * @dev_id:	cookie to identify the device</span></span><br><span class="line"><span class="comment"> * @percpu_dev_id:	cookie to identify the device</span></span><br><span class="line"><span class="comment"> * @next:	pointer to the next irqaction for shared interrupts</span></span><br><span class="line"><span class="comment"> * @irq:	interrupt number</span></span><br><span class="line"><span class="comment"> * @flags:	flags (see IRQF_* above)</span></span><br><span class="line"><span class="comment"> * @thread_fn:	interrupt handler function for threaded interrupts</span></span><br><span class="line"><span class="comment"> * @thread:	thread pointer for threaded interrupts</span></span><br><span class="line"><span class="comment"> * @thread_flags:	flags related to @thread</span></span><br><span class="line"><span class="comment"> * @thread_mask:	bitmask for keeping track of @thread activity</span></span><br><span class="line"><span class="comment"> * @dir:	pointer to the proc/irq/NN/name entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">	<span class="keyword">irq_handler_t</span>		handler;<span class="comment">//函数指针，指向中断处理程序</span></span><br><span class="line">	<span class="keyword">void</span>			*dev_id;</span><br><span class="line">	<span class="keyword">void</span> __percpu		*percpu_dev_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">next</span>;</span><span class="comment">//用于实现共享的IRQ处理程序，几个irqaction实例聚集到一个链表中。链表的所有元素都</span></span><br><span class="line"><span class="comment">//必须处理同一IRQ编号（处理不同编号的实例，位于irq_desc数组中不同的位置）,在发生一个共享中断时，内核扫描该链表找出中断实际上的来源设备。</span></span><br><span class="line">	<span class="keyword">irq_handler_t</span>		thread_fn;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		irq;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;&lt;interrupt.h&gt;中定义了</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		thread_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		thread_mask;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>name和dev_id唯一地标识一个中断处理程序。 name是一个短字符串，用于标识设备（例如，<br>“e100”、“ncr53c8xx”，等等），而dev_id是一个指针，指向在所有内核数据结构中唯一标识了该设<br>备的数据结构实例，例如网卡的net_device实例。</p>
<p>上面的flag:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These flags used only by the kernel as part of the</span></span><br><span class="line"><span class="comment"> * irq handling routines.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IRQF_SHARED - allow sharing the irq among several devices表示有多于一个设备使用该IRQ电路。</span></span><br><span class="line"><span class="comment"> * IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur</span></span><br><span class="line"><span class="comment"> * IRQF_TIMER - Flag to mark this interrupt as timer interrupt</span></span><br><span class="line"><span class="comment"> * IRQF_PERCPU - Interrupt is per cpu</span></span><br><span class="line"><span class="comment"> * IRQF_NOBALANCING - Flag to exclude this interrupt from irq balancing</span></span><br><span class="line"><span class="comment"> * IRQF_IRQPOLL - Interrupt is used for polling (only the interrupt that is</span></span><br><span class="line"><span class="comment"> *                registered first in an shared interrupt is considered for</span></span><br><span class="line"><span class="comment"> *                performance reasons)</span></span><br><span class="line"><span class="comment"> * IRQF_ONESHOT - Interrupt is not reenabled after the hardirq handler finished.</span></span><br><span class="line"><span class="comment"> *                Used by threaded interrupts which need to keep the</span></span><br><span class="line"><span class="comment"> *                irq line disabled until the threaded handler has been run.</span></span><br><span class="line"><span class="comment"> * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend.  Does not guarantee</span></span><br><span class="line"><span class="comment"> *                   that this interrupt will wake the system from a suspended</span></span><br><span class="line"><span class="comment"> *                   state.  See Documentation/power/suspend-and-interrupts.txt</span></span><br><span class="line"><span class="comment"> * IRQF_FORCE_RESUME - Force enable it on resume even if IRQF_NO_SUSPEND is set</span></span><br><span class="line"><span class="comment"> * IRQF_NO_THREAD - Interrupt cannot be threaded</span></span><br><span class="line"><span class="comment"> * IRQF_EARLY_RESUME - Resume IRQ early during syscore instead of at device</span></span><br><span class="line"><span class="comment"> *                resume time.</span></span><br><span class="line"><span class="comment"> * IRQF_COND_SUSPEND - If the IRQ is shared with a NO_SUSPEND user, execute this</span></span><br><span class="line"><span class="comment"> *                interrupt handler after suspending interrupts. For system</span></span><br><span class="line"><span class="comment"> *                wakeup devices users need to implement wakeup detection in</span></span><br><span class="line"><span class="comment"> *                their interrupt handlers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_SHARED		0x00000080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_PROBE_SHARED	0x00000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __IRQF_TIMER		0x00000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_PERCPU		0x00000400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_NOBALANCING	0x00000800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_IRQPOLL		0x00001000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_ONESHOT		0x00002000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_NO_SUSPEND		0x00004000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_FORCE_RESUME	0x00008000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_NO_THREAD		0x00010000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_EARLY_RESUME	0x00020000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_COND_SUSPEND	0x00040000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQF_TIMER		(__IRQF_TIMER | IRQF_NO_SUSPEND | IRQF_NO_THREAD)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="中断处理的相关操作："><a href="#中断处理的相关操作：" class="headerlink" title="中断处理的相关操作："></a>中断处理的相关操作：</h4><ul>
<li><p>设置控制器硬件：<br>irq.h:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set/get chip/data for an IRQ: */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">irq_set_chip</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, struct irq_chip *chip)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">irq_set_handler_data</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">irq_set_chip_data</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">irq_set_irq_type</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">unsigned</span> <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">irq_set_msi_desc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, struct msi_desc *entry)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">irq_set_msi_desc_off</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq_base, <span class="keyword">unsigned</span> <span class="keyword">int</span> irq_offset,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct msi_desc *entry)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化和分配irq:<br>1) 注册irq：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kernel/irq/manage.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">irqreturn_t</span> handler,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> irqflags, <span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line">往往在设备驱动程序初始化时会做这个request_irq操作把处理程序注册进去；</span><br><span class="line">setup_irq</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2）释放irq:<br>free_irq</p>
<p>3) 注册中断：</p>
<ul>
<li>中断到达后：找到正确的中断处理程序的通用函数：do_IRQ,此时若处理器在用户态，需要切换到核心态；<br>linux中do_IRQ是和体系结构相关的函数：<br>例如：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AMD:</span><br><span class="line">irq.c:</span><br><span class="line">do_IRQ</span><br><span class="line">  --&gt; set_irq_regs</span><br><span class="line">  --&gt; irq_enter</span><br><span class="line">  --&gt; generic_handle_irq --&gt;.... handle_irq</span><br><span class="line">  --&gt; irq_exit</span><br><span class="line">  --&gt; set_irq_regs</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>关键处理：<br>handle_irq_event<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">irqreturn_t</span> handle_irq_event(struct irq_desc *desc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span> = <span class="title">desc</span>-&gt;<span class="title">action</span>;</span></span><br><span class="line">	<span class="keyword">irqreturn_t</span> ret;</span><br><span class="line"></span><br><span class="line">	desc-&gt;istate &amp;= ~IRQS_PENDING;</span><br><span class="line">	irqd_set(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line">	raw_spin_unlock(&amp;desc-&gt;lock);</span><br><span class="line"></span><br><span class="line">	ret = handle_irq_event_percpu(desc, action);<span class="comment">//---&gt;res = action-&gt;handler(irq, action-&gt;dev_id);</span></span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;desc-&gt;lock);</span><br><span class="line">	irqd_clear(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>IRQ栈：通过内核栈处理不够，所以又衍生了用于硬件IRQ处理的栈和用于软件IRQ处理的栈；<br>常规的内核栈对每个进程都会分配，而这两个额外的栈是针对各CPU分别分配的。在硬件中断发<br>生时（或处理软中断时），内核需要切换到适当的栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">下列数组提供了指向额外的栈的指针：</span><br><span class="line">arch/x86/kernel/irq_32.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> irq_ctx *hardirq_ctx[NR_CPUS] __read_mostly;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> irq_ctx *softirq_ctx[NR_CPUS] __read_mostly;</span><br><span class="line"></span><br><span class="line">用作栈的数据结构并不复杂：</span><br><span class="line">arch/x86/kernel/irq_32.c</span><br><span class="line"><span class="keyword">union</span> irq_ctx &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">tinfo</span>;</span></span><br><span class="line">u32 <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(u32)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于中断处理程序：<br>1) 中断是异步执行的。换句话说，它们可以在任何时间发生。<br>2) 例如，对网络驱动程序来说，不能将接收的数据直接转发到等待的应用程序。毕竟，内核无法确定等待数据的应用程序此时是否在运行（事实上，这种可能性很低）。<br>3) 中断上下文中不能调用调度器。因而不能自愿地放弃控制权。<br>4) 处理程序例程不能进入睡眠状态。<br>中断处理程序类型：irqreturn_t (<em>handler)(int irq, void </em>dev_id, struct pt_regs *regs)<br>一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">一个例子：tg3.c这个有napi形式的，故用这个：</span><br><span class="line">```c</span><br><span class="line">module_init(tg3_init);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">tg3_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pci_module_init(&amp;tg3_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">tg3_driver</span> = &#123;</span></span><br><span class="line">	.name		= DRV_MODULE_NAME,</span><br><span class="line">	.id_table	= tg3_pci_tbl,</span><br><span class="line">	.probe		= tg3_init_one,</span><br><span class="line">	.remove		= __devexit_p(tg3_remove_one),</span><br><span class="line">	.suspend	= tg3_suspend,</span><br><span class="line">	.resume		= tg3_resume</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">devinit <span class="title">tg3_init_one</span><span class="params">(struct pci_dev *pdev,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">const</span> struct pci_device_id *ent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> tg3_version_printed = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> tg3reg_base, tg3reg_len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tg3</span> *<span class="title">tp</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i, err, pci_using_dac, pm_cap;</span><br><span class="line">                    ...</span><br><span class="line"><span class="comment">//在init中没有申请中断，直到open时才申请：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tg3_open</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tg3</span> *<span class="title">tp</span> = <span class="title">dev</span>-&gt;<span class="title">priv</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">                    ...</span><br><span class="line">                    err = request_irq(dev-&gt;irq, tg3_interrupt,</span><br><span class="line">			  SA_SHIRQ, dev-&gt;name, dev);</span><br><span class="line">                   </span><br><span class="line"><span class="comment">//来看中断处理程序：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">tg3_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">dev_id</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tg3</span> *<span class="title">tp</span> = <span class="title">dev</span>-&gt;<span class="title">priv</span>;</span></span><br><span class="line">                    <span class="comment">//这里使用新式接口napi:</span></span><br><span class="line">	<span class="keyword">if</span> (likely(tg3_has_work(dev, tp)))</span><br><span class="line">	       netif_rx_schedule(dev);		<span class="comment">/* schedule NAPI poll */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="重要的中断处理程序："><a href="#重要的中断处理程序：" class="headerlink" title="重要的中断处理程序："></a>重要的中断处理程序：</h4><ul>
<li><p>电流处理： typedef void fastcall (<em>irq_flow_handler_t)(unsigned int irq,<br>struct irq_desc </em>desc);</p>
</li>
<li><p>边沿触发中断<br>handle_edge_irq，chip.c</p>
</li>
<li><p>电平触发中断：<br>handle_level_irq,</p>
</li>
</ul>
<h3 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h3><p>用于有效实现内核中的延期操作。完全用软件来实现，但是运作方式和硬件中断类似；softIRQ;<br>不管是哪种体系结构的do_IRQ,其结尾都会去处理所有待决的软中断，确保软中断可以定期处理；</p>
<h4 id="软中断表"><a href="#软中断表" class="headerlink" title="软中断表"></a>软中断表</h4><p>一个包含也许是32个softirq_action类型的数据表；<br>interrupt.h:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">void</span>	(*action)(struct softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="软中断的流程："><a href="#软中断的流程：" class="headerlink" title="软中断的流程："></a>软中断的流程：</h4><ul>
<li>先注册，内核才能执行：<br>open_softirq函数用于注册： 就是往上述表中填入action<br>kernel/softirq.c:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">void open_softirq(int nr, void (*action)(struct softirq_action *))</span><br><span class="line">&#123;</span><br><span class="line">	softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>各个软中断都有一个唯一的编号，这表明软中断是相对稀缺的资源，使用其必须谨慎，不能由各种设备驱动程序和内核组件随意使用。<br>这个数组也是被定义在softirq.c中；<br>static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;<br>可以看枚举知道先有的以这种方式注册的软中断：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">	HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">	TIMER_SOFTIRQ,</span><br><span class="line">	NET_TX_SOFTIRQ, 网络的发送</span><br><span class="line">	NET_RX_SOFTIRQ, 网络接收</span><br><span class="line">	BLOCK_SOFTIRQ,块处理</span><br><span class="line">	BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">	TASKLET_SOFTIRQ,</span><br><span class="line">	SCHED_SOFTIRQ,调度器</span><br><span class="line">	HRTIMER_SOFTIRQ,</span><br><span class="line">	RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">	NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>只有重要的情况才能用软中断，其他可以使用tasklet,工作队列或内核定时器的方式来达到延期处理的目的；</p>
<ul>
<li>发起中断：<br>硬件中断需要通过硬件设备触发中断控制器向cpu发起中断，然后进入中断处理程序处理，软中断没有这个机制，需要通过软件的方式发起中断：<br>void raise_softirq(unsigned int nr) 用于引发一个软中断；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_softirq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	raise_softirq_irqoff(nr);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function must run with irqs disabled!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">raise_softirq_irqoff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__raise_softirq_irqoff(nr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we're in an interrupt or softirq, we're done</span></span><br><span class="line"><span class="comment">	 * (this also catches softirq-disabled code). We will</span></span><br><span class="line"><span class="comment">	 * actually run the softirq once we return from</span></span><br><span class="line"><span class="comment">	 * the irq or softirq.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Otherwise we wake up ksoftirqd to make sure we</span></span><br><span class="line"><span class="comment">	 * schedule the softirq soon.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!in_interrupt())</span><br><span class="line">		wakeup_softirqd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不在中断上下文调用raise_softirq，则调用wakeup_softirqd来唤醒软中断守护进程，这</span></span><br><span class="line"><span class="comment">//是开启软中断处理的两个可选方法之一。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该函数设置各CPU变量irq_stat[smp_processor_id].__softirq_pending中的对应比特位。<br>该函数将相应的软中断标记为执行，但这个执行是延期执行。通过使用特定于处理器的位图，内核确<br>保几个软中断（甚至是相同的）可以同时在不同的CPU上执行。</p>
<ul>
<li>流程：<br>在注册了软中断后，若引发软中断且处理软中断的handler时，就会匹配到对应的函数，进行处理；<br>软中断处理被归结到do_softirq函数：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">do_softirq</span><br><span class="line"> --&gt;local_softirq_pending</span><br><span class="line"> --&gt;__do_softirq</span><br><span class="line"> --&gt;h-&gt;action--循环处理</span><br><span class="line"> --&gt; local_softirq_pending且重启次数没有超过次数-&gt;重启软中断</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因为软中断大部分是用来延迟硬中断的后续处理，所以需要一个软中断守护进程来进行异步执行软中断，一方面不和硬中断冲突，另一方面确保软中断的及时执行；<br>系统为每个处理器都分配了自身的守护进程： ksoftirqd，为软中断守护进程；<br>所以实际上raise_softirq是为了唤醒这个守护进程，进行处理软件中断，进行及时处理；</p>
<ul>
<li>软中断守护进程：ksoftirqd<br>软中断守护进程的任务是，与其余内核代码异步执行软中断。为此，系统中的每个处理器都分配了自身的守护进程，名为ksoftirqd<br>内核中有两处调用wakeup_softirqd唤醒了该守护进程。<br>1) 在do_softirq中，如前所述。<br>2) 在raise_softirq_irqoff末尾。该函数由raise_softirq在内部调用，如果内核当前停用了<br>中断，也可以直接使用。<br>唤醒函数本身只需要几行代码。首先，借助于一些宏，从一个各CPU变量读取指向当前CPU软中<br>断守护进程的task_struct的指针。如果该进程当前的状态不是TASK_RUNNING，则通过wake_up_<br>process将其放置到就绪进程的列表末尾（参见第2章）。尽管这并不会立即开始处理所有待决软中断，<br>但只要调度器没有更好的选择，就会选择该守护进程（优先级为19）来执行。<br>(1) 软中断守护进程的初始化和启动：<br>在系统启动时用initcall机制调用init后，就创建了系统的软中断守护进程，初始化后，各个守护进程进行无限循环：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kernel/softirq.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ksoftirqd</span><span class="params">(<span class="keyword">void</span> * __bind_cpu)</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (!kthread_should_stop()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!local_softirq_pending()) &#123;</span><br><span class="line">schedule();</span><br><span class="line">&#125;</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"><span class="keyword">while</span> (local_softirq_pending()) &#123;</span><br><span class="line">do_softirq();</span><br><span class="line">cond_resched();</span><br><span class="line">&#125;</span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="tasklet-另一种轻量的软中断"><a href="#tasklet-另一种轻量的软中断" class="headerlink" title="tasklet ,另一种轻量的软中断"></a>tasklet ,另一种轻量的软中断</h3><p>软中断是将操作推迟到未来时刻执行的最有效的方法。但该延期机制处理起来非常复杂。因为多<br>个处理器可以同时且独立地处理软中断，同一个软中断的处理程序例程可以在几个CPU上同时运行。<br>对软中断的效率来说，这是一个关键，多处理器系统上的网络实现显然受惠于此。</p>
<p>但处理程序例程的设计必须是完全可重入且线程安全的。 另外， 临界区必须用自旋锁保护（或其他IPC机制），<br>而这需要大量审慎的考虑。</p>
<p>tasklet是“小进程”，执行一些迷你任务，对这些任务使用全功能进程可能比较浪费</p>
<h4 id="创建tasklet"><a href="#创建tasklet" class="headerlink" title="创建tasklet:"></a>创建tasklet:</h4><p>各个tasklet的中枢数据结构称作tasklet_struct，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">interrupt.h:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span><span class="comment">//用于建立tasklet_struct实例的链表。这容许几个任务排队执行。</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> state;<span class="comment">//state表示任务的当前状态，类似于真正的进程。但只有两个选项，分别由state中的一个比特</span></span><br><span class="line"><span class="comment">//位表示，这也是二者可以独立设置/清除的原因。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在tasklet注册到内核，等待调度执行时，将设置TASKLET_STATE_SCHED。</span></span><br><span class="line"><span class="comment">    TASKLET_STATE_RUN表示tasklet当前正在执行。</span></span><br><span class="line"><span class="comment">    第二个状态只在SMP系统上有用。用于保护tasklet在多个处理器上并行执行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="comment">//原子计数器count用于禁用已经调度的tasklet。如果其值不等于0，在接下来执行所有待决的tasklet时，将忽略对应的tasklet。</span></span><br><span class="line">	<span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);<span class="comment">//执行函数地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> data;<span class="comment">//data用作该函数执行时的参数。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>tasklet_vec 是一个pcpu变量，也就是每一个cpu上上的tasklet组成一个list.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> **<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct tasklet_head, tasklet_vec)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="注册tasklet"><a href="#注册tasklet" class="headerlink" title="注册tasklet"></a>注册tasklet</h4><p>要使用它，首先必须注册它；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_init</span><span class="params">(struct tasklet_struct *t,</span></span></span><br><span class="line">		  void (*func)(unsigned long), unsigned long data)</span><br><span class="line">&#123;</span><br><span class="line">	t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	t-&gt;state = <span class="number">0</span>;</span><br><span class="line">	atomic_set(&amp;t-&gt;count, <span class="number">0</span>);</span><br><span class="line">	t-&gt;func = func;</span><br><span class="line">	t-&gt;data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="执行："><a href="#执行：" class="headerlink" title="执行："></a>执行：</h4><p>tasklet基于软中断实现，它们总是在处理软中断时执行。<br>tasklet关联到TASKLET_SOFTIRQ软中断。因而，调用raise_softirq(TASKLET_SOFTIRQ)，即可<br>在下一个适当的时机执行当前处理器的tasklet。<br>interrupt.h:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_schedule</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">		__tasklet_schedule(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> __tasklet_schedule(struct tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	*__this_cpu_read(tasklet_vec.tail) = t;</span><br><span class="line">	__this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next));</span><br><span class="line">	raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内核使用tasklet_action作为该软中断的action函数<br>该函数首先确定特定于CPU的链表，其中保存了标记为将要执行的各个tasklet。它接下来将表头<br>重定向到函数局部的一个数据项，相当于从外部公开的链表删除了所有表项。接下来，函数在以下循<br>环中逐一处理各个tasklet：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tasklet_action</span><span class="params">(struct softirq_action *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	<span class="built_in">list</span> = __this_cpu_read(tasklet_vec.head);</span><br><span class="line">	__this_cpu_write(tasklet_vec.head, <span class="literal">NULL</span>);</span><br><span class="line">	__this_cpu_write(tasklet_vec.tail, this_cpu_ptr(&amp;tasklet_vec.head));</span><br><span class="line">	local_irq_enable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> = <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tasklet_trylock(t)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!atomic_read(&amp;t-&gt;count)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!test_and_clear_bit(TASKLET_STATE_SCHED,</span><br><span class="line">							&amp;t-&gt;state))</span><br><span class="line">					BUG();</span><br><span class="line">				t-&gt;func(t-&gt;data);</span><br><span class="line">				tasklet_unlock(t);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			tasklet_unlock(t);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		local_irq_disable();</span><br><span class="line">		t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		*__this_cpu_read(tasklet_vec.tail) = t;</span><br><span class="line">		__this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next));</span><br><span class="line">		__raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">		local_irq_enable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在while循环中执行tasklet，类似于处理软中断使用的机制。<br>因为一个tasklet只能在一个处理器上执行一次，但其他的tasklet可以并行运行，所以需要特定于<br>tasklet 的 锁 。 state 状 态 用 作 锁 变 量 。 在 执 行 一 个 tasklet 的 处 理 程 序 函 数 之 前 ， 内 核 使 用<br>tasklet_trylock检查tasklet的状态是否为TASKLET_STATE_RUN。换句话说，它是否已经在系<br>统的另一个处理器上运行：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;interrupt.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tasklet_trylock</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !test_and_set_bit(TASKLET_STATE_RUN, &amp;(t)-&gt;state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了普通的tasklet之外，内核还使用了另一种tasklet，它具有“较高”的优先级。除以下修改之<br>外，其实现与普通的tasklet完全相同。<br>1) 使用HI_SOFTIRQ作为软中断，而不是TASKLET_SOFTIRQ，相关的action函数是tasklet_<br>hi_action。<br>2) 注册的tasklet在CPU相关的变量tasklet_hi_vec中排队。这是使用tasklet_hi_schedule完<br>成的。<br>在这里，“较高优先级”是指该软中断的处理程序HI_SOFTIRQ在所有其他处理程序之前执行，<br>尤其是在构成了软中断活动主体的网络处理程序之前执行。<br>当前，大部分声卡驱动程序都利用了这一选项，因为操作延迟时间太长可能损害音频输出的音质。<br>而用于高速传输的网卡也可以得益于该机制</p>
<h3 id="等待队列和完成量；"><a href="#等待队列和完成量；" class="headerlink" title="等待队列和完成量；"></a>等待队列和完成量；</h3><p>等待队列（ wait queue）用于使进程等待某一特定事件发生，而无须频繁轮询。进程在等待期间<br>睡眠，在事件发生时由内核自动唤醒。 完成量（ completion）机制基于等待队列，内核利用该机制等<br>待某一操作结束。这两种机制使用得都比较频繁，主要用于设备驱动程序，</p>
<h4 id="等待队列："><a href="#等待队列：" class="headerlink" title="等待队列："></a>等待队列：</h4><h5 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h5><p>每个等待队列都有一个队列头：<br>wait.h:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>因为等待队列也可以在中断时修改，在操作队列之前必须获得一个自旋锁lock。<br>task_list是一个双链表，用于实现双链表最擅长表示的结构，即队列。</p>
<p>队列中的成员：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags; <span class="comment">//表示等待进程想要被独占地唤醒：则用WQ_FLAG_EXCLUSIVE</span></span><br><span class="line">	<span class="keyword">void</span>			*<span class="keyword">private</span>;<span class="comment">//指向等待进程的task_struct实例；</span></span><br><span class="line">	<span class="keyword">wait_queue_func_t</span>	func;<span class="comment">//调用func，唤醒等待进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">task_list</span>;</span><span class="comment">//用作链表元素，将wait_queue_t实例放入等待队列中；</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>等待队列的使用分为如下两部分。<br>(1) 为使当前进程在一个等待队列中睡眠，需要调用wait_event函数（或某个等价函数，在下文<br>讨论）。进程进入睡眠，将控制权释放给调度器。<br>内核通常会在向块设备发出传输数据的请求后，调用该函数。因为传输不会立即发生，而在此期<br>间又没有其他事情可做，所以进程可以睡眠，将CPU时间让给系统中的其他进程。<br>(2) 在内核中另一处，就我们的例子而言，是来自块设备的数据到达后，必须调用wake_up函数（或<br>某个等价函数，将在下文讨论）来唤醒等待队列中的睡眠进程。<br>在使用wait_event使进程睡眠之后，必须确保在内核中另一处有一个对应的wake_up调用</p>
<h5 id="使进程睡眠："><a href="#使进程睡眠：" class="headerlink" title="使进程睡眠："></a>使进程睡眠：</h5><p>add_wait_queue函数用于将一个进程增加到等待队列，该函数在获得必要的自旋锁后，将工作<br>委托给__add_wait_queue：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;wait.h&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __add_wait_queue(<span class="keyword">wait_queue_head_t</span> *head, <span class="keyword">wait_queue_t</span> *<span class="keyword">new</span>)</span><br><span class="line">&#123;</span><br><span class="line">list_add(&amp;<span class="keyword">new</span>-&gt;task_list, &amp;head-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在将新进程统计到等待队列时，除了使用标准的list_add链表函数，没有其他工作需要做。<br>内核还提供了add_wait_queue_exclusive函数。它的工作方式与add_wait_queue相同，但将<br>进程插入在队列尾部，并将其标志设置为WQ_EXCLUSIVE</p>
<p>另一种方法： prepare_to_wait也是用来使进程睡眠，比上述方法多一个参数，表示进程状态；</p>
<p>初始化一个动态分配的wait_queue_t实例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_waitqueue_entry</span><span class="params">(<span class="keyword">wait_queue_t</span> *q, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q-&gt;flags	= <span class="number">0</span>;</span><br><span class="line">	q-&gt;<span class="keyword">private</span>	= p;</span><br><span class="line">	q-&gt;func		= default_wake_function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者DEFINE_WAIT创建wait_queue_t的静态实例，它可以自动初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_WAIT_BIT(name, word, bit)				\</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wait_bit_queue</span> <span class="title">name</span> = &#123;</span>					\</span><br><span class="line">		.key = __WAIT_BIT_KEY_INITIALIZER(word, bit),		\</span><br><span class="line">		.wait	= &#123;						\</span><br><span class="line">			.<span class="keyword">private</span>	= current,			\</span><br><span class="line">			.func		= wake_bit_function,		\</span><br><span class="line">			.task_list	=				\</span><br><span class="line">				LIST_HEAD_INIT((name).wait.task_list),	\</span><br><span class="line">		&#125;,							\</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>使进程睡眠，通常不直接调用add_wait_queue,而是调用wait_event；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __wait_event(wq, condition)					\</span></span><br><span class="line">	(<span class="keyword">void</span>)___wait_event(wq, condition, TASK_UNINTERRUPTIBLE, <span class="number">0</span>, <span class="number">0</span>,	\</span><br><span class="line">			    schedule())<span class="meta">#<span class="meta-keyword">define</span> ___wait_event(wq, condition, state, exclusive, ret, cmd)	\</span></span><br><span class="line">(&#123;									\</span><br><span class="line">	__label__ __out;						\</span><br><span class="line">	<span class="keyword">wait_queue_t</span> __wait;						\</span><br><span class="line">	<span class="keyword">long</span> __ret = ret;	<span class="comment">/* explicit shadow */</span>			\</span><br><span class="line">									\</span><br><span class="line">	INIT_LIST_HEAD(&amp;__wait.task_list);				\</span><br><span class="line">	<span class="keyword">if</span> (exclusive)							\</span><br><span class="line">		__wait.flags = WQ_FLAG_EXCLUSIVE;			\</span><br><span class="line">	<span class="keyword">else</span>								\</span><br><span class="line">		__wait.flags = <span class="number">0</span>;					\</span><br><span class="line">									\</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;							\</span><br><span class="line">		<span class="keyword">long</span> __int = prepare_to_wait_event(&amp;wq, &amp;__wait, state);\</span><br><span class="line">									\</span><br><span class="line">		<span class="keyword">if</span> (condition)						\</span><br><span class="line">			<span class="keyword">break</span>;						\</span><br><span class="line">									\</span><br><span class="line">		<span class="keyword">if</span> (___wait_is_interruptible(state) &amp;&amp; __int) &#123;		\</span><br><span class="line">			__ret = __int;					\</span><br><span class="line">			<span class="keyword">if</span> (exclusive) &#123;				\</span><br><span class="line">				abort_exclusive_wait(&amp;wq, &amp;__wait,	\</span><br><span class="line">						     state, <span class="literal">NULL</span>);	\</span><br><span class="line">				<span class="keyword">goto</span> __out;				\</span><br><span class="line">			&#125;						\</span><br><span class="line">			<span class="keyword">break</span>;						\</span><br><span class="line">		&#125;							\</span><br><span class="line">									\</span><br><span class="line">		cmd;							\</span><br><span class="line">	&#125;								\</span><br><span class="line">	finish_wait(&amp;wq, &amp;__wait);					\</span><br><span class="line">__out:	__ret;								\</span><br><span class="line">&#125;)</span><br><span class="line">每次进程被唤醒时，内核都会检查指定的条件是否满足，如果条件满足则</span><br><span class="line">退出无限循环。否则，将控制转交给调度器，进程再次睡眠。</span><br></pre></td></tr></table></figure></p>
<p>在条件满足时， finish_wait将进程状态设置回TASK_RUNNING，并从等待队列的链表移除对应的项。<br>除了wait_event之外，内核还定义了其他几个函数，可以将当前进程置于等待队列中。其实现实际上等同于sleep_on：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;wait.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_event_interruptible(wq, condition)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_event_timeout(wq, condition, timeout) &#123; ... &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_event_interruptible_timeout(wq, condition, timeout)</span></span><br></pre></td></tr></table></figure></p>
<p>1) wait_event_interruptible使用的进程状态为TASK_INTERRUPTIBLE。因而睡眠进程可以通<br>过接收信号而唤醒。<br>2) wait_event_timeout等待满足指定的条件，但如果等待时间超过了指定的超时限制（按jiffies<br>指定）则停止。这防止了进程永远睡眠。<br>3) wait_event_interruptible_timeout使进程睡眠，但可以通过接收信号唤醒。它也注册了<br>一个超时限制。从内核采用的命名方式来看，一般不会有出人意料之处！</p>
<h5 id="唤醒进程："><a href="#唤醒进程：" class="headerlink" title="唤醒进程："></a>唤醒进程：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;wait.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up(x) __wake_up(x, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, 1, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_nr(x, nr) __wake_up(x, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, nr, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_all(x) __wake_up(x, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, 0, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_interruptible(x) __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_interruptible_nr(x, nr) __wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_interruptible_all(x) __wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)</span></span><br><span class="line">在获得了用于保护等待队列首部的锁之后， _wake_up将工作委托给_wake_up_common。</span><br><span class="line"></span><br><span class="line">kernel/sched.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line"><span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">wait_queue_t</span> *curr, *next;</span><br><span class="line">...</span><br><span class="line">q用于选定等待队列，而mode指定进程的状态，用于控制唤醒进程的条件。 nr_exclusive表示</span><br><span class="line">将要唤醒的设置了WQ_FLAG_EXCLUSIVE标志的进程的数目。</span><br><span class="line">内核接下来遍历睡眠进程，并调用其唤醒函数func：</span><br><span class="line">kernel/sched.c</span><br><span class="line">list_for_each_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> flags = curr-&gt;flags;</span><br><span class="line"><span class="keyword">if</span> (curr-&gt;func(curr, mode, sync, key) &amp;&amp;</span><br><span class="line">(flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br></pre></td></tr></table></figure>
<p>这里会反复扫描链表，直至没有更多进程需要唤醒，或已经唤醒的独占进程的数目达到了<br>nr_exclusive。该限制用于避免所谓的惊群（ thundering herd）问题。如果几个进程在等待独占访问<br>某一资源，那么同时唤醒所有等待进程是没有意义的，因为除了其中一个之外，其他进程都会再次睡<br>眠。 nr_exclusive推广了这一限制。<br>最常使用的wake_up函数将nr_exclusive设置为1，确保只唤醒一个独占访问的进程</p>
<h4 id="完成量"><a href="#完成量" class="headerlink" title="完成量"></a>完成量</h4><p>完成量和信号量有相似之处，但是都是基于等待队列实现的；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;completion.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> done;</span><br><span class="line"><span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>init_completion初始化一个动态分配的completion实例，而DECLARE_COMPLETION宏用来建立<br>该数据结构的静态实例。<br>进程可以用wait_for_completion添加到等待队列，进程在其中等待（以独占睡眠状态），直至<br>请求被内核的某些部分处理。这函数需要一个completion实例作为参数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;completion.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_completion</span><span class="params">(struct completion *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wait_for_completion_interruptible</span><span class="params">(struct completion *x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">wait_for_completion_timeout</span><span class="params">(struct completion *x,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">wait_for_completion_interruptible_timeout</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">struct completion *x, <span class="keyword">unsigned</span> <span class="keyword">long</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在请求由内核的另一部分处理之后，必须调用complete或complete_all来唤醒等待的进程。因<br>为每次调用只能从完成量的等待队列移除一个进程，对n个等待进程来说，必须调用该函数n次。 另一<br>方面， complete_all将唤醒所有等待该完成的进程。 complete_and_exit是一个小的包装器，首先<br>调用complete，接下来调用do_exit结束内核线程。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;completion.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(struct completion *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete_all</span><span class="params">(struct completion *)</span></span>;</span><br><span class="line">kernel/<span class="built_in">exit</span>.c</span><br><span class="line"><span class="function">NORET_TYPE <span class="keyword">void</span> <span class="title">complete_and_exit</span><span class="params">(struct completion *comp, <span class="keyword">long</span> code)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="工作队列："><a href="#工作队列：" class="headerlink" title="工作队列："></a>工作队列：</h4><p>工作队列是将操作延期执行的另一种手段：因为它们是通过守护进程在用户上下文执行，函数可<br>以睡眠任意长的时间，这与内核是无关的。在内核版本2.5开发期间，设计了工作队列，用以替换此前<br>使用的keventd机制。</p>
<p>每个工作队列都有一个数组，数组项的数目与系统中处理器的数目相同。每个数组项都列出了将<br>延期执行的任务。<br>对每个工作队列来说，内核都会创建一个新的内核守护进程，延期任务使用上文描述的等待队列<br>机制，在该守护进程的上下文中执行。</p>
<ul>
<li>创建新工作队列：<br>新的工作队列通过调用create_workqueue或create_workqueue_singlethread函数来创建。前<br>一个函数在所有CPU上都创建一个工作线程，而后者只在系统的第一个CPU上创建一个线程。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>interrupt</tag>
      </tags>
  </entry>
  <entry>
    <title>systemcall</title>
    <url>/2021/04/17/systemcall/</url>
    <content><![CDATA[<h3 id="系统调用概述"><a href="#系统调用概述" class="headerlink" title="系统调用概述"></a>系统调用概述</h3><p>内核对于用户进程来讲，是一个具备多功能的黑盒子，不仅管理设备，管理内存，管理进程等，还封装了提供进程调用的各种接口，比如打开文件，写入和读取文件等等，这些接口<a id="more"></a><br>不能在用户态运行，而需要由内核统一管理，在内核态运行；所以为了能让用户进程方便的调用，顺利的进入内核态处理，并适当的恢复用户进程运行和返回结果等等，系统调用因此而生；</p>
<p>系统调用的实现，主要是由内核提供各种内核函数，形成内核函数库，分散在各个功能目录；<br>而用户进程，一般是通过类似glibc等标准库来调用系统调用内核函数的，当然也可以不同过标准库而使用一些特殊的宏来调用，如_syscall;</p>
<p>因为用户态和内核态的不同，堆栈不同，虚拟地址空间等不同，控制权需要在用户进程和内核之间来回传递，而参数和返回值也需要，造成了一定的复杂度；<br>这里需要区分标准库和系统调用的区别，调用标准库函数不一定会触发调用系统调用，当调用标准库函数需要系统调用时，由标准库去进一步调用系统调用；</p>
<h3 id="linux系统调用的两种使用方式：c库函数和直接系统调用"><a href="#linux系统调用的两种使用方式：c库函数和直接系统调用" class="headerlink" title="linux系统调用的两种使用方式：c库函数和直接系统调用"></a>linux系统调用的两种使用方式：c库函数和直接系统调用</h3><h4 id="c库函数使用例子和追踪："><a href="#c库函数使用例子和追踪：" class="headerlink" title="c库函数使用例子和追踪："></a>c库函数使用例子和追踪：</h4><p>一个调用c库函数的典型例子如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的函数可以看到调用了标准c库的printf函数；<br>编译后进行系统调用跟踪：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strace  ./main</span><br><span class="line"></span><br><span class="line">execve(<span class="string">"./main"</span>, [<span class="string">"./main"</span>], [<span class="comment">/* 70 vars */</span>]) = <span class="number">0</span></span><br><span class="line">brk(<span class="number">0</span>)                                  = <span class="number">0x2425000</span></span><br><span class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = <span class="number">-1</span> ENOENT (No such file <span class="keyword">or</span> directory)</span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7ff4be6f0000</span></span><br><span class="line">access(<span class="string">"/etc/ld.so.preload"</span>, R_OK)      = <span class="number">-1</span> ENOENT (No such file <span class="keyword">or</span> directory)</span><br><span class="line">open(<span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">86757</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">86757</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x7ff4be6da000</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = <span class="number">-1</span> ENOENT (No such file <span class="keyword">or</span> directory)</span><br><span class="line">open(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">"\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P \2\0\0\0\0\0"</span>..., <span class="number">832</span>) = <span class="number">832</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">1840928</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">3949248</span>, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x7ff4be10b000</span></span><br><span class="line">mprotect(<span class="number">0x7ff4be2c5000</span>, <span class="number">2097152</span>, PROT_NONE) = <span class="number">0</span></span><br><span class="line">mmap(<span class="number">0x7ff4be4c5000</span>, <span class="number">24576</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0x1ba000</span>) = <span class="number">0x7ff4be4c5000</span></span><br><span class="line">mmap(<span class="number">0x7ff4be4cb000</span>, <span class="number">17088</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7ff4be4cb000</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7ff4be6d9000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7ff4be6d7000</span></span><br><span class="line">arch_prctl(ARCH_SET_FS, <span class="number">0x7ff4be6d7740</span>) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x7ff4be4c5000</span>, <span class="number">16384</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x600000</span>, <span class="number">4096</span>, PROT_READ)     = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x7ff4be6f2000</span>, <span class="number">4096</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x7ff4be6da000</span>, <span class="number">86757</span>)           = <span class="number">0</span></span><br><span class="line">fstat(<span class="number">1</span>, &#123;st_mode=S_IFCHR|<span class="number">0620</span>, st_rdev=makedev(<span class="number">136</span>, <span class="number">5</span>), ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7ff4be6ef000</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">"hello"</span>, <span class="number">5</span>hello)                    = <span class="number">5</span></span><br><span class="line">exit_group(<span class="number">0</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br></pre></td></tr></table></figure></p>
<p>可以看到，除开前面的标准库调用的基本框架，最后是调用了系统调用write函数，来进行打印操作；<br>标准库执行的大体框架，需要加载so文件，并做内存映射，为可执行，然后调用系统调用；<br>而系统调用，就通过一种机制调用到内核函数了</p>

<h4 id="直接使用使用例子和追踪："><a href="#直接使用使用例子和追踪：" class="headerlink" title="直接使用使用例子和追踪："></a>直接使用使用例子和追踪：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#define_NR_testsyscall <span class="number">191</span></span><br><span class="line"></span><br><span class="line">_syscall0(<span class="keyword">int</span>,testsyscall)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    testsyscall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="系统调用的各种标准介绍："><a href="#系统调用的各种标准介绍：" class="headerlink" title="系统调用的各种标准介绍："></a>系统调用的各种标准介绍：</h3><p>posix标准<br>system V<br>BSD</p>
<h3 id="系统调用的分类和分布位置目录："><a href="#系统调用的分类和分布位置目录：" class="headerlink" title="系统调用的分类和分布位置目录："></a>系统调用的分类和分布位置目录：</h3><p>可以从内核源码中看到所有的系统调用函数接口：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">linux <span class="number">2.</span>x:</span><br><span class="line">arch/i386/kernel/entry.s中</span><br><span class="line">.data</span><br><span class="line"><span class="number">575</span> ENTRY(sys_call_table)</span><br><span class="line"><span class="number">576</span>         .<span class="keyword">long</span> sys_restart_syscall       <span class="comment">/* 0 - old "setup()" system call, used for restarting */</span></span><br><span class="line"><span class="number">577</span>         .<span class="keyword">long</span> sys_exit</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>x之后：</span><br><span class="line">arch/x86/entry/syscalls/syscall_64.tbl</span><br><span class="line"># <span class="number">64</span>-bit system call numbers <span class="keyword">and</span> entry vectors</span><br><span class="line">#</span><br><span class="line"># The format is:</span><br><span class="line"># &lt;number&gt; &lt;abi&gt; &lt;name&gt; &lt;entry point&gt;</span><br><span class="line">#</span><br><span class="line"># The __x64_sys_*() stubs are created on-the-fly <span class="keyword">for</span> sys_*() system calls</span><br><span class="line">#</span><br><span class="line"># The abi is <span class="string">"common"</span>, <span class="string">"64"</span> <span class="keyword">or</span> <span class="string">"x32"</span> <span class="keyword">for</span> <span class="keyword">this</span> file.</span><br><span class="line">#</span><br><span class="line"><span class="number">0</span>	common	read			sys_read</span><br><span class="line"><span class="number">1</span>	common	write			sys_write</span><br><span class="line"><span class="number">2</span>	common	open			sys_open</span><br><span class="line"><span class="number">3</span>	common	close			sys_close</span><br><span class="line"><span class="number">4</span>	common	stat			sys_newstat</span><br><span class="line"><span class="number">5</span>	common	fstat			sys_newfstat</span><br><span class="line"><span class="number">6</span>	common	lstat			sys_newlstat</span><br><span class="line"><span class="number">7</span>	common	poll			sys_poll</span><br><span class="line"><span class="number">8</span>	common	lseek			sys_lseek</span><br><span class="line"><span class="number">9</span>	common	mmap			sys_mmap</span><br><span class="line"><span class="number">10</span>	common	mprotect		sys_mprotect</span><br><span class="line"><span class="number">11</span>	common	munmap			sys_munmap</span><br><span class="line"><span class="number">12</span>	common	brk			sys_brk</span><br><span class="line"><span class="number">13</span>	<span class="number">64</span>	rt_sigaction		sys_rt_sigaction</span><br><span class="line"><span class="number">14</span>	common	rt_sigprocmask		sys_rt_sigprocmask</span><br><span class="line"><span class="number">15</span>	<span class="number">64</span>	rt_sigreturn		sys_rt_sigreturn</span><br><span class="line"><span class="number">16</span>	<span class="number">64</span>	ioctl			sys_ioctl</span><br><span class="line"><span class="number">17</span>	common	pread64			sys_pread64</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><ul>
<li>创建进程：fork,vfork,clone</li>
<li>结束进程：exit</li>
<li>查询： getuid等</li>
<li>程序执行环境：personality </li>
<li>跟踪系统调用：ptrace</li>
<li>优先级设置：nice</li>
<li>设置一定的资源限制：setrlimit, getrlimit,getrusage<h4 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h4></li>
<li>读取和设置基于时间的内核变量：adjtimex</li>
<li>定时器： alarm,setitimer,getitimer</li>
<li>获取和设置系统当前时间：gettimeofday ,settimeofday</li>
<li>睡眠： sleep,nanosleep </li>
<li>返回时间戳： timer</li>
</ul>
<h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h4><ul>
<li>设置信号处理函数：signal,sigaction</li>
<li>检查进程当前是否有待决信号被阻塞：sigpending</li>
<li>将进程置于等待队列上，直至某个特定（一组信号中的一个）的信号到达 :sigsuspend</li>
<li>启用信号的阻塞机制，而getmask返回所有当前阻塞信号的列表:setmask</li>
<li>用于向一个进程发送任何信号:kill</li>
<li>还有一组处理实时信号的系统调用，但其对应的函数名带有前缀rt_。例如， rt_sigaction</li>
<li>设置一个实时信号处理程序，而rt_sigsuspend将进程置于等待状态，直至某个特定（一组</li>
<li>信号中的一个）信号到达<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4></li>
<li><p>setpriority和getpriority分别设置和获取进程的优先级，因而是用于调度目的的关键系统调用。</p>
</li>
<li><p>请注意， Linux不仅支持不同的进程优先级，还提供了多种调度类，以适应应用程序在时间方<br>面具体的行为和需求。 sched_setscheduler和sched_getscheduler分别设置和查询调度类。<br>sched_setparam和sched_getparam分别设置和查询进程的附加调度参数（当前，只使用了<br>实时优先级的参数）。</p>
</li>
<li><p>sched_yield自愿释放CPU的控制权，即使进程当前仍然有CPU时间可用。</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4></li>
<li>init_module添加一个新模块。</li>
<li>delete_module从内核移除一个模块<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4>一些系统调用被用作用户空间中同名实用程序的直接基础，用来创建和修改目录结构： chdir、<br>mkdir、 rmdir、 rename、 symlink、 getcwd、 chroot、 umask和mknod。</li>
<li>文件和目录属性可以用chown和chmod修改。</li>
<li>下列实用程序用于处理文件内容，其实现在标准库中，与对应的系统调用同名： open、 close、<br>read与readv、 write与writev、 truncate和llseek。</li>
<li>readdir和getdents读取目录结构。</li>
<li>link、 symlink和unlink创建和删除链接（或文件，如果该文件是某个硬链接的最后一个成<br>员）。 readlink读取链接的内容。</li>
<li>mount和umount用于文件系统的装载和卸载。</li>
<li>poll和select用于等待某些事件。</li>
<li>execve装载一个新进程，替换旧的进程。在与fork联合使用时，它会启动一个新的程序。<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4></li>
<li><p>就动态内存管理而言，最重要的调用是brk，它修改进程数据段的长度。调用了malloc或相似<br>函数的程序（几乎所有非平凡的代码，都符合这个条件）会频繁使用该系统调用。</p>
</li>
<li><p>mmap、 mmap2、 munmap和mremap执行内存映射、解除映射和重新映射操作，而mprotect控制<br>对虚拟内存中特定区域的访问， madvice提出对特定虚拟内存区域的使用建议。<br>mmap和mmap2的参数稍有不同，更多细节请参考手册页。默认情况下， GNU C库使用mmap2；<br>现在mmap只是一个用户层包装器函数。<br>根据malloc的实现，它在内部可以使用mmap或mmap2。这是可行的，因为匿名映射允许建立<br>没有文件作为后备存储的映射。与使用brk相比，该方法更加灵活。</p>
</li>
<li><p>swapon和swapoff分别启用和禁用外存储器设备上（附加）的交换区</p>
<h4 id="进程间通信和网络功能"><a href="#进程间通信和网络功能" class="headerlink" title="进程间通信和网络功能"></a>进程间通信和网络功能</h4></li>
<li><p>socketcall处理网络方面的问题，用于实现套接字抽象。它管理各种类型的连接和协议，总<br>共实现了17种功能， 通过SYS_ACCEPT、 SYS_SENDTO等常数来区分。参数必须以指针形式传递，<br>指向一个与函数类型相关的用户空间结构，其中保存了所需的数据。</p>
</li>
<li><p>ipc与socketcall相对应，用于处理计算机本地的连接，而不是通过网络建立的连接。因为<br>该系统调用“只”需要实现11种功能，它使用了固定数目的参数来从用户空间向内核空间传<br>递数据，总共是5个。</p>
<h4 id="系统信息和设置"><a href="#系统信息和设置" class="headerlink" title="系统信息和设置"></a>系统信息和设置</h4></li>
<li><p>syslog向系统日志写入消息，并允许设置不同的优先级（根据消息的优先级不同，用户空<br>间工具或者向持久性的日志文件发送消息，或者直接向控制台输出消息以通知用户某些关键<br>情况。</p>
</li>
<li><p>sysinfo返回有关系统状态的信息，特别有关内存使用的统计量（物理内存、缓冲区、交换区）。</p>
</li>
<li>sysctl用于“微调”内核参数。内核现在支持大量的动态可配置选项，可以使用proc文件系<br>统读取和修改</li>
</ul>
<h4 id="系统安全和能力"><a href="#系统安全和能力" class="headerlink" title="系统安全和能力"></a>系统安全和能力</h4><p>LSM（ Linux security modules， Linux安全模块）子系统提供了一个通用接口，支持内核在<br>各个位置通过挂钩调用模块函数来执行安全检查。</p>
<ul>
<li>capset和capget负责设置和查询进程的能力。</li>
<li>security是一个系统调用的多路分解器，用于实现LSM</li>
</ul>
<h3 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h3><h4 id="理论上"><a href="#理论上" class="headerlink" title="理论上"></a>理论上</h4><h5 id="系统调用的结构："><a href="#系统调用的结构：" class="headerlink" title="系统调用的结构："></a>系统调用的结构：</h5><ul>
<li>处理函数的实现：内核中实现：sys_<br>1） 每个函数的名称前缀都是sys_，将该函数唯一地标识为一个系统调用<br>2） 所有的处理程序函数都最多接受5个参数<br>3） 所有的系统调用都在核心态执行<br>在内核将控制权转移给处理程序例程后，控制流就进入了平台中立的代码，即不依赖于特定的CPU或体系结构。有少量处理程序函数是针对各个平台分别实现的</li>
<li>调用分派和参数传递：系统调用表<br>1）调用分派：<br>系统调用由内核分配的一个编号唯一标识，所有的系统调用都由一处中枢代码处理，根据调用编号和一个静态表，将调用<br>分派到具体的函数。传递的参数也由中枢代码处理，这样参数的传递独立于实际的系统调用。</li>
</ul>
<p>为容许用户态和核心态之间的切换，用户进程必须通过一条专用的机器指令，引起处理器/内核<br>对该进程的关注，这需要C标准库的协助。<br>2）参数传递：<br>在所有平台上，系统调用参数都是通过寄存器直接传递的，对具体的处理程序函数而言，参数与寄存器之间的映射是精确定义的。还需要一<br>个寄存器来定义系统调用编号，将系统调用分派给匹配的处理程序函数。比如 x86:系统调用编号通过寄存器eax传递，<br>而参数通过寄存器ebx、 ecx、 edx、 esi和edi传递。<br>3）系统调用表：eg：sys_call_table<br>如果一个用户空间程序调用open系统调<br>用，传递的系统调用编号是5。 分配器例程将编号5加到sys_call_table的基地址，得到该数组的第6<br>项，其中保存了sys_open的地址，这是独立于处理器的处理程序函数。在将保存在寄存器中的参数值<br>复制到栈上之后，内核调用处理程序例程，并切换到系统调用处理中独立于处理器的部分<br>用户态和内核态是使用两个不同的栈</p>
<ul>
<li>返回用户态<br>返回值的语义<br>通常，系统调用的返回值有如下约定：负值表示错误，而正值（和0）表示成功结束<br>在include/asm-generic/errno-base.h和include/asm-generic/errno.h中定义的符号常数<h5 id="如何访问用户空间"><a href="#如何访问用户空间" class="headerlink" title="如何访问用户空间"></a>如何访问用户空间</h5>有些情况下，内核代码必须访问用户应用程序的虚拟内存。<br>内核忙于同步执行应用程序指派的任务。因为如下两种原因，内核必须访问应用程序的地址空间。<br> 如果一个系统调用需要超过6个不同的参数，它们只能借助进程内存空间中的C结构实例来传<br>递。系统调用将借助寄存器，将指向该结构实例的一个指针传递给内核。。。</li>
</ul>
<h4 id="实际实现：linux系统调用实现流程-基于linux3-x后"><a href="#实际实现：linux系统调用实现流程-基于linux3-x后" class="headerlink" title="实际实现：linux系统调用实现流程 基于linux3.x后"></a>实际实现：linux系统调用实现流程 基于linux3.x后</h4><h5 id="glibc标准库："><a href="#glibc标准库：" class="headerlink" title="glibc标准库："></a>glibc标准库：</h5><p>查询标准库：<br>think@think-VirtualBox:~/source_linux/linux-lts-xenial-4.4.0/arch$ uname -a<br>Linux think-VirtualBox 4.4.177 #1 SMP Fri Sep 18 21:23:25 CST 2020 x86_64 x86_64 x86_64 GNU/Linux<br>这样就是arch要选择x86相关的代码；<br>基于write系统调用，来跟踪：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glibc/sysdeps/unix/sysv/linux/write.c</span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="comment">/* Write NBYTES of BUF to FD.  Return the number written, or -1.  */</span></span><br><span class="line"><span class="keyword">ssize_t</span></span><br><span class="line">__libc_write (<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> SYSCALL_CANCEL (write, fd, buf, nbytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> </span><br><span class="line">跟着这个宏，最后是：这些宏定义在：sysdep.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_CANCEL(...) \</span></span><br><span class="line">  (&#123;									     \</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> sc_ret;							     \</span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P) 						     \</span><br><span class="line">      sc_ret = INLINE_SYSCALL_CALL (__VA_ARGS__); 			     \</span><br><span class="line">    <span class="keyword">else</span>								     \</span><br><span class="line">      &#123;									     \</span><br><span class="line">	<span class="keyword">int</span> sc_cancel_oldtype = LIBC_CANCEL_ASYNC ();			     \</span><br><span class="line">	sc_ret = INLINE_SYSCALL_CALL (__VA_ARGS__);			     \</span><br><span class="line">        LIBC_CANCEL_RESET (sc_cancel_oldtype);				     \</span><br><span class="line">      &#125;									     \</span><br><span class="line">    sc_ret;								     \</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INLINE_SYSCALL_CALL(...) \</span></span><br><span class="line">  __INLINE_SYSCALL_DISP (__INLINE_SYSCALL, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL_NARGS(...) \</span></span><br><span class="line">  __INLINE_SYSCALL_NARGS_X (__VA_ARGS__,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL_DISP(b,...) \</span></span><br><span class="line">  __SYSCALL_CONCAT (b,__INLINE_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_CONCAT_X(a,b)     a##b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_CONCAT(a,b)       __SYSCALL_CONCAT_X (a, b)</span></span><br><span class="line">展开为：</span><br><span class="line">__INLINE_SYSCALL_N(xxxx);<span class="comment">//这里N是参数个数：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL0(name) \</span></span><br><span class="line">  INLINE_SYSCALL (name, <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL1(name, a1) \</span></span><br><span class="line">  INLINE_SYSCALL (name, <span class="number">1</span>, a1)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL2(name, a1, a2) \</span></span><br><span class="line">  INLINE_SYSCALL (name, <span class="number">2</span>, a1, a2)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL3(name, a1, a2, a3) \</span></span><br><span class="line">  INLINE_SYSCALL (name, <span class="number">3</span>, a1, a2, a3)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL4(name, a1, a2, a3, a4) \</span></span><br><span class="line">  INLINE_SYSCALL (name, <span class="number">4</span>, a1, a2, a3, a4)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL5(name, a1, a2, a3, a4, a5) \</span></span><br><span class="line">  INLINE_SYSCALL (name, <span class="number">5</span>, a1, a2, a3, a4, a5)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL6(name, a1, a2, a3, a4, a5, a6) \</span></span><br><span class="line">  INLINE_SYSCALL (name, <span class="number">6</span>, a1, a2, a3, a4, a5, a6)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL7(name, a1, a2, a3, a4, a5, a6, a7) \</span></span><br><span class="line">  INLINE_SYSCALL (name, <span class="number">7</span>, a1, a2, a3, a4, a5, a6, a7)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line">进入平台相关函数：</span><br><span class="line">选x86_64: sysdeps/unix/sysv/linux/x86_64</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INLINE_SYSCALL(name, nr, args...) \</span></span><br><span class="line">  (&#123;									      \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar = INTERNAL_SYSCALL (name, , nr, args);	      \</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (resultvar, )))	      \</span><br><span class="line">      &#123;									      \</span><br><span class="line">	__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		      \</span><br><span class="line">	resultvar = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) <span class="number">-1</span>;				      \</span><br><span class="line">      &#125;									      \</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar; &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_SYSCALL(name, err, nr, args...)			\</span></span><br><span class="line">	internal_syscall#<span class="meta">#nr (SYS_ify (name), err, args)</span></span><br><span class="line">也是扩展为参数个数后：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall0(number, err, dummy...)			\</span></span><br><span class="line">(&#123;									\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;					\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (							\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>							\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)							\</span><br><span class="line">    : <span class="string">"0"</span> (number)							\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);			\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;						\</span><br><span class="line">&#125;)</span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> </span><br><span class="line">调用了syscall函数</span><br><span class="line">在syscall.S中： sysdeps/unix/sys/linux/x86_64</span><br><span class="line">	.text</span><br><span class="line">ENTRY (syscall)</span><br><span class="line">	movq %rdi, %rax		<span class="comment">/* Syscall number -&gt; rax.  */</span></span><br><span class="line">	movq %rsi, %rdi		<span class="comment">/* shift arg1 - arg5.  */</span></span><br><span class="line">	movq %rdx, %rsi</span><br><span class="line">	movq %rcx, %rdx</span><br><span class="line">	movq %r8, %r10</span><br><span class="line">	movq %r9, %r8</span><br><span class="line">	movq <span class="number">8</span>(%rsp),%r9	<span class="comment">/* arg6 is on the stack.  */</span></span><br><span class="line">	syscall			<span class="comment">/* Do the system call.  */</span></span><br><span class="line">	cmpq $<span class="number">-4095</span>, %rax	<span class="comment">/* Check %rax for error.  */</span></span><br><span class="line">	jae SYSCALL_ERROR_LABEL	<span class="comment">/* Jump to error handler if error.  */</span></span><br><span class="line">	ret			<span class="comment">/* Return to caller.  */</span></span><br><span class="line"></span><br><span class="line">PSEUDO_END (syscall)</span><br></pre></td></tr></table></figure>
<h5 id="内核代码中的系统调用平台相关入口函数："><a href="#内核代码中的系统调用平台相关入口函数：" class="headerlink" title="内核代码中的系统调用平台相关入口函数："></a>内核代码中的系统调用平台相关入口函数：</h5><p>总之，上面的syscall指令跳转到存储在MSR_LSTAR模型特定寄存器(长系统目标地址寄存器)中的地址。内核负责提供自己的自定义函数来处理系统调用，并在系统启动时将这个处理函数的地址写入MSR_LSTAR寄存器。自定义函数是entry_SYSCALL_64，它在arch/x86/entry/entry_64.S中定义。在arch/x86/kernel/cpu/common.c中，这个系统调用处理函数的地址在启动时被写入MSR_LSTAR寄存器。在这个文件可以看到：linux/arch/x86/entry/entry_64.S<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Interrupts are off on entry.</span></span><br><span class="line"><span class="comment">	 * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,</span></span><br><span class="line"><span class="comment">	 * it is too small to ever cause noticeable irq latency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SWAPGS_UNSAFE_STACK</span><br><span class="line">	SWITCH_KERNEL_CR3_NO_STACK</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A hypervisor implementation might want to use a label</span></span><br><span class="line"><span class="comment">	 * after the swapgs, so that it can do the swapgs</span></span><br><span class="line"><span class="comment">	 * for the guest and jump here on syscall.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">GLOBAL(entry_SYSCALL_64_after_swapgs)</span><br><span class="line"></span><br><span class="line">	movq	%rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">	pushq	$__USER_DS			<span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">	<span class="function">pushq	<span class="title">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>	<span class="comment">/* pt_regs-&gt;sp */</span></span></span><br><span class="line"><span class="function">	<span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">	 * Re-enable interrupts.</span></span></span><br><span class="line"><span class="function"><span class="comment">	 * We use 'rsp_scratch' as a scratch space, hence irq-off block above</span></span></span><br><span class="line"><span class="function"><span class="comment">	 * must execute atomically in the face of possible interrupt-driven</span></span></span><br><span class="line"><span class="function"><span class="comment">	 * task preemption. We must enable interrupts only after we're done</span></span></span><br><span class="line"><span class="function"><span class="comment">	 * with using rsp_scratch:</span></span></span><br><span class="line"><span class="function"><span class="comment">	 */</span></span></span><br><span class="line"><span class="function">	<span class="title">ENABLE_INTERRUPTS</span><span class="params">(CLBR_NONE)</span></span></span><br><span class="line">	pushq	%r11				/* pt_regs-&gt;flags */</span><br><span class="line">	pushq	$__USER_CS			<span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">	pushq	%rcx				<span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">	pushq	%rax				<span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">	pushq	%rdi				<span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">	pushq	%rsi				<span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">	pushq	%rdx				<span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">	pushq	%rcx				<span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">	pushq	$-ENOSYS			<span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">	pushq	%r8				<span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">	pushq	%r9				<span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">	pushq	%r10				<span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">	pushq	%r11				<span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">	sub	$(<span class="number">6</span>*<span class="number">8</span>), %rsp			<span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br><span class="line"></span><br><span class="line">	ENABLE_IBRS</span><br><span class="line"></span><br><span class="line">	testl	$_TIF_WORK_SYSCALL_ENTRY, ASM_THREAD_INFO(TI_flags, %rsp, SIZEOF_PTREGS)</span><br><span class="line">	jnz	tracesys</span><br><span class="line">entry_SYSCALL_64_fastpath:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __SYSCALL_MASK == ~0</span></span><br><span class="line">	cmpq	$NR_syscalls, %rax</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	andl	$__SYSCALL_MASK, %eax</span><br><span class="line">	cmpl	$NR_syscalls, %eax</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	jae	<span class="number">1f</span>				<span class="comment">/* return -ENOSYS (already in pt_regs-&gt;ax) */</span></span><br><span class="line">	sbb	%rcx, %rcx			<span class="comment">/* array_index_mask_nospec() */</span></span><br><span class="line">	<span class="keyword">and</span>	%rcx, %rax</span><br><span class="line">	movq	%r10, %rcx</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RETPOLINE</span></span><br><span class="line">	movq	sys_call_table(, %rax, 8), %rax</span><br><span class="line">	call	__x86_indirect_thunk_rax</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="function">call	*<span class="title">sys_call_table</span><span class="params">(, %rax, <span class="number">8</span>)</span> <span class="comment">//这里选择到了系统调用表中的对应函数指针；</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">	movq	%rax, RAX(%rsp)</span><br></pre></td></tr></table></figure></p>
<p>调用了*sys_call_table(, %rax, 8)，传入了系统调用号；</p>
<h5 id="内核代码平台无关函数和数组初始化；"><a href="#内核代码平台无关函数和数组初始化；" class="headerlink" title="内核代码平台无关函数和数组初始化；"></a>内核代码平台无关函数和数组初始化；</h5><p>在linux3.x之后，系统调用由sys_call_table函数指针数组管理：<br>初始化如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">实际上是通过一个数组维护的，在：</span><br><span class="line">/arch/x86/entry/syscall_64.c sys_call_table <span class="built_in">array</span></span><br><span class="line">如何初始化这个表：</span><br><span class="line">asmlinkage <span class="keyword">const</span> <span class="keyword">sys_call_ptr_t</span> sys_call_table[__NR_syscall_max+<span class="number">1</span>] = &#123;</span><br><span class="line">    [<span class="number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall, 初始化的这个函数指针其实啥也没做：</span><br><span class="line">    #include &lt;<span class="keyword">asm</span>/syscalls_64.h&gt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sys_call_ptr_t</span>)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_ni_syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -ENOSYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如何赋值这个表：<br>We can do it with a GCC compiler extension called - Designated Initializers. This extension allows us to initialize elements in non-fixed order.<br>我们可以看到，在上面的初始化中，最后一行贴了#include&lt;asm/syscalls_64.h&gt;<br>就可以看到：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/arch/x86/include/generated/<span class="keyword">asm</span>$ vim syscalls_64.h</span><br><span class="line">__SYSCALL_COMMON(<span class="number">0</span>, sys_read, sys_read)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">1</span>, sys_write, sys_write)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">2</span>, sys_open, sys_open)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">3</span>, sys_close, sys_close)</span><br><span class="line">。。。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_COMMON(nr, sym, compat) __SYSCALL_64(nr, sym, compat)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_64(nr, sym, compat) [nr] = sym,</span></span><br><span class="line">所以之后就初始化好了；</span><br><span class="line">asmlinkage <span class="keyword">const</span> <span class="keyword">sys_call_ptr_t</span> sys_call_table[__NR_syscall_max+<span class="number">1</span>] = &#123;</span><br><span class="line">    [<span class="number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall,</span><br><span class="line">    [<span class="number">0</span>] = sys_read,</span><br><span class="line">    [<span class="number">1</span>] = sys_write,</span><br><span class="line">    [<span class="number">2</span>] = sys_open,</span><br></pre></td></tr></table></figure></p>
<p>而这个文件 asm/syscalls_64.h:是在内核编译时根据syscalls目录中的脚本syscalltbl.sh和系统调用号定义文件syscall_64.tbl生成的。<br>syscallhdr.sh脚本用于生成unistd_64.h等文件</p>
<p>这里就可以看到，初始化和赋值了该系统调用数组，所以其实标准库就是最后找到了这个系统调用函数进行调用；</p>
<h5 id="syscall"><a href="#syscall" class="headerlink" title="_syscall"></a>_syscall</h5><p>/arch/parisc/include/asm/unistd.h 不太确定<br>可以看到在这个文件下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall0(type,name)						\</span></span><br><span class="line">type name(void)								\</span><br><span class="line">&#123;									\</span><br><span class="line">    <span class="keyword">return</span> K_INLINE_SYSCALL(name, <span class="number">0</span>);	                                \</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall1(type,name,type1,arg1)					\</span></span><br><span class="line">type name(type1 arg1)							\</span><br><span class="line">&#123;									\</span><br><span class="line">    <span class="keyword">return</span> K_INLINE_SYSCALL(name, <span class="number">1</span>, arg1);	                        \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> K_INLINE_SYSCALL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K_INLINE_SYSCALL(name, nr, args...)	(&#123;			\</span></span><br><span class="line">	<span class="keyword">long</span> __sys_res;							\</span><br><span class="line">	&#123;								\</span><br><span class="line">		<span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __res __asm__(<span class="string">"r28"</span>);		\</span><br><span class="line">		K_LOAD_ARGS_#<span class="meta">#nr(args)					\</span></span><br><span class="line">		<span class="comment">/* <span class="doctag">FIXME:</span> HACK stw/ldw r19 around syscall */</span>		\</span><br><span class="line">		__<span class="function">asm__ <span class="title">volatile</span><span class="params">(					\</span></span></span><br><span class="line"><span class="function"><span class="params">			K_STW_ASM_PIC					\</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="string">"	ble  0x100(%%sr2, %%r0)\n"</span>		\</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="string">"	ldi %1, %%r20\n"</span>			\</span></span></span><br><span class="line"><span class="function"><span class="params">			K_LDW_ASM_PIC					\</span></span></span><br><span class="line">			: "=r" (__res)					\</span><br><span class="line">			: <span class="string">"i"</span> (SYS_ify(name)) K_ASM_ARGS_#<span class="meta">#nr   	\</span></span><br><span class="line">			: <span class="string">"memory"</span>, K_CALL_CLOB_REGS K_CLOB_ARGS_#<span class="meta">#nr	\</span></span><br><span class="line">		);							\</span><br><span class="line">		__sys_res = (<span class="keyword">long</span>)__res;				\</span><br><span class="line">	&#125;								\</span><br><span class="line">	<span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">long</span>)__sys_res &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">-4095</span> )&#123;	\</span><br><span class="line">		errno = -__sys_res;		        		\</span><br><span class="line">		__sys_res = <span class="number">-1</span>;						\</span><br><span class="line">	&#125;								\</span><br><span class="line">	__sys_res;							\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>经过这个系统调用接口，可以不用经过glibc等标准库：<br>eg:<br><a href="https://man7.org/linux/man-pages/man2/_syscall.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/_syscall.2.html</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;       /* for _syscallX macros/related stuff */</span></span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;       /* for struct sysinfo */</span></span></span><br><span class="line"></span><br><span class="line">      _syscall1(<span class="keyword">int</span>, sysinfo, struct sysinfo *, info);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span></span><br><span class="line">      main(<span class="keyword">void</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">s_info</span>;</span></span><br><span class="line">          <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">          error = sysinfo(&amp;s_info);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"code error = %d\n"</span>, error);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Uptime = %lds\nLoad: 1 min %lu / 5 min %lu / 15 min %lu\n"</span></span><br><span class="line">                 <span class="string">"RAM: total %lu / free %lu / shared %lu\n"</span></span><br><span class="line">                 <span class="string">"Memory in buffers = %lu\nSwap: total %lu / free %lu\n"</span></span><br><span class="line">                 <span class="string">"Number of processes = %d\n"</span>,</span><br><span class="line">                 s_info.uptime, s_info.loads[<span class="number">0</span>],</span><br><span class="line">                 s_info.loads[<span class="number">1</span>], s_info.loads[<span class="number">2</span>],</span><br><span class="line">                 s_info.totalram, s_info.freeram,</span><br><span class="line">                 s_info.sharedram, s_info.bufferram,</span><br><span class="line">                 s_info.totalswap, s_info.freeswap,</span><br><span class="line">                 s_info.procs);</span><br><span class="line">          <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  Sample output</span><br><span class="line">      code error = <span class="number">0</span></span><br><span class="line">      uptime = <span class="number">502034</span>s</span><br><span class="line">      Load: <span class="number">1</span> min <span class="number">13376</span> / <span class="number">5</span> min <span class="number">5504</span> / <span class="number">15</span> min <span class="number">1152</span></span><br><span class="line">      RAM: total <span class="number">15343616</span> / <span class="built_in">free</span> <span class="number">827392</span> / shared <span class="number">8237056</span></span><br><span class="line">      Memory in buffers = <span class="number">5066752</span></span><br><span class="line">      Swap: total <span class="number">27881472</span> / <span class="built_in">free</span> <span class="number">24698880</span></span><br><span class="line">      Number of processes = <span class="number">40</span></span><br></pre></td></tr></table></figure></p>
<h3 id="实现一个系统调用；"><a href="#实现一个系统调用；" class="headerlink" title="实现一个系统调用；"></a>实现一个系统调用；</h3><h4 id="定义一个内核系统调用函数：可以通过模块传入："><a href="#定义一个内核系统调用函数：可以通过模块传入：" class="headerlink" title="定义一个内核系统调用函数：可以通过模块传入："></a>定义一个内核系统调用函数：可以通过模块传入：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inculde(linux/kernel.h)</span></span><br><span class="line"><span class="meta">#inculde(linux/module.h)</span></span><br><span class="line"><span class="meta">#inculde(linux/modversions.h)</span></span><br><span class="line"><span class="meta">#inculde(linux/sched.h)</span></span><br><span class="line"><span class="meta">#inculde(asm/uaccess.h)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_testsyscall 191</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> viod *sys_call_table[];</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">testsyscall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    sys_call_table[_NR_tsetsyscall]=testsyscall;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"system call testsyscall() loaded success\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里也把数组初始化好了，如果不经过glibc库的话，这里已经可以用了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line">#define_NR_testsyscall <span class="number">191</span></span><br><span class="line">_syscall0(<span class="keyword">int</span>,testsyscall)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    testsyscall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想通过glibc调用，可以通过增加glibc代码，编译后替换所使用的glibc库：<br>通过ldd main可以知道链接了哪个glibc</p>
<p>在网上找对应的版本，修改和编译后替换，具体修改，这里暂时不提供，有兴趣自己探索；</p>
<h3 id="追踪系统调用"><a href="#追踪系统调用" class="headerlink" title="追踪系统调用"></a>追踪系统调用</h3><h4 id="关于ptrace"><a href="#关于ptrace" class="headerlink" title="关于ptrace"></a>关于ptrace</h4><h4 id="如何用ptrace追踪指定的系统调用"><a href="#如何用ptrace追踪指定的系统调用" class="headerlink" title="如何用ptrace追踪指定的系统调用"></a>如何用ptrace追踪指定的系统调用</h4><p>ptrace是一个内核提供的一个可以用来追踪进程运行情况，甚至控制进程运行行为的系统调用，并提供了对应的接口，strace和gdb就是利用ptrace制成的；<br>ptrace本质上是一个用于读取和修改进程地址空间中的值的工具，不能用于直接跟踪系统调用。只有从正确的位置提取出所需的信息，才能跟踪进<br>程并就进行的系统调用得出结论。</p>
<p>ptrace的系统调用： sys_ptrace ,实现：arch/arch/kernel/ptrace.c<br>内核源码中有四个参数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;syscalls.h&gt;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_ptrace</span><span class="params">(<span class="keyword">long</span> request, <span class="keyword">long</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> data)</span></span>;</span><br><span class="line">pid标识了要追踪的进程，可以在进程开始时或者运行中；</span><br><span class="line">addr,data则向内核传递了一个内存地址和附加信息；因选择的操作而不同；</span><br><span class="line"></span><br><span class="line">request用于选择一个操作，由ptrace执行；在ptrace.h中有列出：</span><br><span class="line">PTRACE_TRACEME：tracee表明自己想要被追踪，这会自动与父进程建立追踪关系，这也是唯一能被tracee使用的request，其他的request都由tracer指定。</span><br><span class="line">PTRACE_ATTACH：tracer用来附着一个进程tracee，以建立追踪关系，并向其发送`SIGSTOP`信号使其暂停。</span><br><span class="line">PTRACE_SEIZE：像PTRACE_ATTACH附着进程，但它不会让tracee暂停，addr参数须为<span class="number">0</span>，data参数指定一位ptrace选项。</span><br><span class="line">PTRACE_DETACH：解除追踪关系，tracee将继续运行。</span><br><span class="line">PEEKTEXT、 PEEKDATA和PEEKUSR从进程地址空间读取数据。 PEEKUSR读取普通的CPU寄存</span><br><span class="line">器和使用的任何其他调试寄存器①（当然，会根据标识符只读取一个寄存器的内容，而不是</span><br><span class="line">读取整个寄存器集合的内容）。 PEEKEXT和PEEKDATA从进程的代码段和数据段读取任意字，可以向对应区域写入值，从而操作进程空间的内容；</span><br><span class="line">PTRACE_SYSCALL，如果用该选项激活ptrace，那么内核将开始执行进程，直至调用一个系统调用。</span><br><span class="line">。。。。</span><br></pre></td></tr></table></figure></p>
<p>一个例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/user.h&gt;   /* For constants</span></span></span><br><span class="line">                                   ORIG_EAX etc */</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">pid_t</span> child;</span><br><span class="line">    <span class="keyword">long</span> orig_eax;</span><br><span class="line">    child = fork();</span><br><span class="line">    <span class="keyword">if</span>(child == <span class="number">0</span>) &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        orig_eax = ptrace(PTRACE_PEEKUSER,</span><br><span class="line">                          child, <span class="number">4</span> * ORIG_EAX,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The child made a "</span></span><br><span class="line">               <span class="string">"system call %ld\n"</span>, orig_eax);</span><br><span class="line">        ptrace(PTRACE_CONT, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他：重启系统调用"><a href="#其他：重启系统调用" class="headerlink" title="其他：重启系统调用"></a>其他：重启系统调用</h3><p>当系统调用和信号发生冲突时，有问题：<br>以下内容，引用自 深入linux内核架构：</p>
<p>如果在一个进程执行系统调用时，向该进程发送一个信号，那么在处理时，二者的优先级如何分配呢？应该等到系统调用结束再处理信号，还是<br>中断系统调用，以便尽快将信号投递到该进程？第一种方案导致的问题显然比较少，也是比较简单的<br>方案。遗憾的是，只有在所有系统调用都能够快速结束、不会让进程等待太长时间的情况下，这个方<br>案才能正确运作（信号投递的时机，总是在进程处理完一个系统调用、返回到用户<br>态的时候）。情况不总是这样。系统调用不仅需要一定的执行时间，而且在最坏情况下，很可能使进<br>程睡眠（例如，没有数据可供读取时）。对同时发生的信号而言，这意味着信号投递的严重延迟。因<br>而，必须不惜任何代价防止这种情况</p>
<p>如果一个正在执行的系统调用被中断，内核应该向应用程序返回什么样的值？在通常的场景下，<br>只有两种情况：调用成功或者失败。在出错的情况下，将返回一个错误码，使用户进程能够确定错误<br>的原因，并适当地做出反应。倘若系统调用被中断，则发生了第三种情况：必须通知应用程序，如果<br>系统调用在执行期间没有被信号中断，那么系统调用已经成功结束。在这种情况下， Linux（和其他<br>System V变体）下将使用-EINTR常数</p>
<p>该过程的负面效应是很明显的。尽管该方案易于实现，但它迫使用户空间应用程序的程序员必须<br>明确检查所有系统调用的返回值，并在返回值为-EINTR的情况下，重新启动被中断的系统调用，直至<br>该调用不再被信号中断。用这种方法重启的系统调用称作可重启系统调用（ restartable system call），<br>该技术则称为重启（ restarting）。<br>该行为第一次引入是在System V UNIX中。该方案将新信号的快速投递和系统调用的中断组合起<br>来，但它并非是唯一的组合方式， BSD所采用的方法即可证实这一点。我们来考察BSD内核在系统调<br>用被信号中断时，会做出何种反应。<br>BSD内核将中断系统调用的执行并切换到用户态执行信号处理程序。在发生这种情况时，该系统<br>调用不会有返回值，内核在信号处理程序结束后将自动重启该调用。因为该行为对用户应用程序是透<br>明的，也不再需要重复实现对-EINTR返回值的检查和调用的重启，所以与System V方法相比，这种方<br>案更受程序员的欢迎。<br>Linux通过SA_RESTART标志支持BSD方案，可以在安装信号处理例程时按需对具体信号指定该标<br>志。 System V提议的机制用作默认方案，因为BSD机制偶尔会导致一些困难，如下列例子所示（取自<br>[ME02]第229页）。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> signaled = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span> <span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"signaled called\n"</span>);</span><br><span class="line">signaled = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigact</span>;</span></span><br><span class="line">sigact.sa_handler = handler;</span><br><span class="line">sigact.sa_flags = SA_RESTART;</span><br><span class="line">sigaction(SIGINT, &amp;sigact, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (read(STDIN_FILENO, &amp;ch, <span class="number">1</span>) != <span class="number">1</span> &amp;&amp; !signaled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个简短的C程序在一个while循环中等待，直至用户通过标准输入键入了一个字符，或者程序<br>被SIGINT信号中断（可使用kill-INT发送该信号，也可以按键CTRL+C）。我们来考察其代码的控制<br>流。如果用户点了一个普通的按键，没有导致发送SIGINT，那么read将得到一个正的返回值，即读<br>取字符的数目。<br>要结束while循环，循环的控制条件必须在逻辑上为false。这里的控制条件是由逻辑与（ &amp;&amp;）<br>运算连接的两个表达式，要结束循环，需要二者之一为false，或全部为false，如下。<br>1 按下了一个键， read返回1，检查read返回不等于1的表达式，其值为false。<br>2 signaled变量设置为1，该变量的反（ !signaled）也将为false值。<br>这些条件意味着，程序要结束，或者需要等到键盘输入，或者需要SIGINT信号到达。<br>为在上述代码中应用Linux默认实现的System V行为，需要取消SA_RESTART标志的设置。换句话<br>说， sigact.sa_flags = SA_RESTART一行需要删除或注释掉。在这样做之后，程序将按上面的描述<br>运行，在按下一个键或接收到SIGINT时结束。<br>如果激活了BSD行为模式，而read被SIGINT信号中断，那么示例程序的情况将更为有趣。在这<br>种情况下，将调用信号处理程序，将signaled设置为1，并输出一个消息表示接收到了SIGINT，但程<br>序不会结束。为什么?在运行处理程序之后， BSD机制将重启read调用，并再次等待输入一个字符。<br>这种情况使得while循环控制条件中的!signaled部分无法进行求值，导致循环不能结束。因而该程<br>序不能通过向其发送SIGNIT信号结束，尽管在表面上，代码的语义确实如此。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>systemcall</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile_use</title>
    <url>/2021/04/03/makefile-use/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>以下文档参考：<br><a href="https://www.gnu.org/software/make/manual/make.html#toc-Overview-of-make" target="_blank" rel="noopener">https://www.gnu.org/software/make/manual/make.html#toc-Overview-of-make</a><br><a href="https://seisman.github.io/how-to-write-makefile/introduction.html" target="_blank" rel="noopener">https://seisman.github.io/how-to-write-makefile/introduction.html</a></p>
<p>这个文件记录了GNU make实用程序，它自动地确定一个大型程序的哪些部分需要重新编译，并发出重新编译它们的命令<br>适用版本：<br>This is Edition 0.75, last updated 17 January 2020, of The GNU Make Manual, for GNU make version 4.3.</p>
<h3 id="make的基本功能和使用简介："><a href="#make的基本功能和使用简介：" class="headerlink" title="make的基本功能和使用简介："></a>make的基本功能和使用简介：<a id="more"></a></h3><p>make实用程序自动确定大型程序的哪些部分需要重新编译，并发出命令重新编译它们。本手册描述了由Richard Stallman和Roland McGrath实现的GNU make。从3.76版本开始的开发由Paul D. Smith负责</p>
<p>GNU make符合IEEE标准1003.2-1992 (POSIX.2)第6.2节。<br>我们的例子展示了C程序，因为它们是最常见的，但是您可以使用make与任何可以用shell命令运行编译器的编程语言一起使用。事实上，make并不局限于程序。您可以使用它来描述任何任务，其中一些文件必须在其他文件发生更改时自动更新其他文件。</p>
<h4 id="makefile是什么样的文件："><a href="#makefile是什么样的文件：" class="headerlink" title="makefile是什么样的文件："></a>makefile是什么样的文件：</h4><p>make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。</p>
<p>要准备使用make，您必须编写一个名为makefile的文件，该文件描述程序中文件之间的关系，并提供用于更新每个文件的命令。通常，在一个程序中，可执行文件从目标文件中更新，而目标文件又通过编译源文件而生成。</p>
<p>一旦有了合适的makefile，每次你修改一些源文件时，这个简单的shell命令: make<br>足够执行所有必要的重新编译。make程序使用makefile数据库和文件的最后修改时间来决定哪些文件需要更新。对于这些文件中的每一个，它都会发出在数据库中记录的recipes</p>
<h4 id="makefiles介绍："><a href="#makefiles介绍：" class="headerlink" title="makefiles介绍："></a>makefiles介绍：</h4><p>您需要一个名为makefile的文件来告诉make做什么。通常，makefile告诉make如何编译和链接程序。<br>1  若一个头文件变了，那每个包含该头文件的c源文件必须被重新编译<br>2  当make开始重新编译时，每个改变过的c源文件必须被重新编译；<br>3  每个编译过程产生一个目标文件关联源文件；<br>4  最后，若任一源文件发生重编，全部目标文件，必须重新连接产生新的可执行目标程序，不管这个时候是新产生还是覆盖之前的编译保存的；  </p>
<h4 id="makefile中的规则："><a href="#makefile中的规则：" class="headerlink" title="makefile中的规则："></a>makefile中的规则：</h4><p>每个规则由以下三部分组成：<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">target … : prerequisites …</span><br><span class="line">        recipe</span><br><span class="line">        …</span><br><span class="line">        …</span><br><span class="line">目标：</span><br><span class="line">A target is usually <span class="keyword">the</span> name <span class="keyword">of</span> <span class="keyword">a</span> <span class="built_in">file</span> that is generated <span class="keyword">by</span> <span class="keyword">a</span> program;examples <span class="keyword">of</span> targets are executable <span class="keyword">or</span> object <span class="built_in">files</span>.</span><br><span class="line">A target can also be <span class="keyword">the</span> name <span class="keyword">of</span> <span class="keyword">an</span> action <span class="built_in">to</span> carry out, such <span class="keyword">as</span> ‘clean’ (see Phony Targets).</span><br><span class="line">A target depends <span class="keyword">on</span> <span class="title">several</span> <span class="title">files</span>.</span><br><span class="line">命令：</span><br><span class="line">A recipe may have more than <span class="literal">one</span> <span class="keyword">command</span>, <span class="title">either</span> <span class="title">on</span> <span class="title">the</span> <span class="title">same</span> <span class="title">line</span> <span class="title">or</span> <span class="title">each</span> <span class="title">on</span> <span class="title">its</span> <span class="title">own</span> <span class="title">line</span>.</span><br><span class="line"><span class="built_in">put</span> <span class="keyword">a</span> <span class="literal">tab</span> <span class="keyword">character</span> <span class="keyword">at</span> <span class="keyword">the</span> beginning <span class="keyword">of</span> every recipe <span class="built_in">line</span>!</span><br><span class="line">RECIPEPREFIX 用于设置不用<span class="literal">tab</span>而用别的字符</span><br><span class="line">依赖文件：</span><br><span class="line">prerequisites:是依赖的文件，它存在是为了在文件更新时，重新执行recipe以重新生成目标的作用；</span><br><span class="line"> 因为若是不需要：则直接类似clean， </span><br><span class="line"> clean： </span><br><span class="line">    rm -rf main 类似这样的写法； </span><br><span class="line">main: </span><br><span class="line">    gcc -o main main.cpp 就可以，</span><br><span class="line">    但是这样main.cpp更新的时候，make不会重新生成 </span><br><span class="line">main: main.cpp </span><br><span class="line">    gcc -o main main.cpp hh.cpp </span><br><span class="line">    这样hh.cpp变更的时候，make也是不会更新的，必须也把hh.cpp写到prerequisites 中</span><br><span class="line"></span><br><span class="line">clean’ does <span class="keyword">not</span> have prerequisites.</span><br><span class="line">总的来讲，规则：</span><br><span class="line">A rule, <span class="keyword">then</span>,  explains how <span class="keyword">and</span> when <span class="built_in">to</span> remake certain <span class="built_in">files</span> which are <span class="keyword">the</span> targets <span class="keyword">of</span> <span class="keyword">the</span> particular rule</span><br><span class="line">A rule can also explain how <span class="keyword">and</span> when <span class="built_in">to</span> carry out <span class="keyword">an</span> action.</span><br><span class="line">A makefile may contain other <span class="keyword">text</span> besides rules</span><br></pre></td></tr></table></figure></p>
<h4 id="一个简单的例子："><a href="#一个简单的例子：" class="headerlink" title="一个简单的例子："></a>一个简单的例子：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">edit</span> : <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">kbd</span><span class="selector-class">.o</span> <span class="selector-tag">command</span><span class="selector-class">.o</span> <span class="selector-tag">display</span><span class="selector-class">.o</span> \</span><br><span class="line">       <span class="selector-tag">insert</span><span class="selector-class">.o</span> <span class="selector-tag">search</span><span class="selector-class">.o</span> <span class="selector-tag">files</span><span class="selector-class">.o</span> <span class="selector-tag">utils</span><span class="selector-class">.o</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-o</span> <span class="selector-tag">edit</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">kbd</span><span class="selector-class">.o</span> <span class="selector-tag">command</span><span class="selector-class">.o</span> <span class="selector-tag">display</span><span class="selector-class">.o</span> \</span><br><span class="line">                   <span class="selector-tag">insert</span><span class="selector-class">.o</span> <span class="selector-tag">search</span><span class="selector-class">.o</span> <span class="selector-tag">files</span><span class="selector-class">.o</span> <span class="selector-tag">utils</span><span class="selector-class">.o</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.o</span> : <span class="selector-tag">main</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">main</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">kbd</span><span class="selector-class">.o</span> : <span class="selector-tag">kbd</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span> <span class="selector-tag">command</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">kbd</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">command</span><span class="selector-class">.o</span> : <span class="selector-tag">command</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span> <span class="selector-tag">command</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">command</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">display</span><span class="selector-class">.o</span> : <span class="selector-tag">display</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span> <span class="selector-tag">buffer</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">display</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">insert</span><span class="selector-class">.o</span> : <span class="selector-tag">insert</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span> <span class="selector-tag">buffer</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">insert</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">search</span><span class="selector-class">.o</span> : <span class="selector-tag">search</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span> <span class="selector-tag">buffer</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">search</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">files</span><span class="selector-class">.o</span> : <span class="selector-tag">files</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span> <span class="selector-tag">buffer</span><span class="selector-class">.h</span> <span class="selector-tag">command</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">files</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">utils</span><span class="selector-class">.o</span> : <span class="selector-tag">utils</span><span class="selector-class">.c</span> <span class="selector-tag">defs</span><span class="selector-class">.h</span></span><br><span class="line">        <span class="selector-tag">cc</span> <span class="selector-tag">-c</span> <span class="selector-tag">utils</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">clean</span> :</span><br><span class="line">        <span class="selector-tag">rm</span> <span class="selector-tag">edit</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> <span class="selector-tag">kbd</span><span class="selector-class">.o</span> <span class="selector-tag">command</span><span class="selector-class">.o</span> <span class="selector-tag">display</span><span class="selector-class">.o</span> \</span><br><span class="line">           <span class="selector-tag">insert</span><span class="selector-class">.o</span> <span class="selector-tag">search</span><span class="selector-class">.o</span> <span class="selector-tag">files</span><span class="selector-class">.o</span> <span class="selector-tag">utils</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>In fact, each ‘.o’ file is both a target and a prerequisite.<br>Recipes include ‘cc -c main.c’ and ‘cc -c kbd.c’.<br>main.o 也可以通过make main.o生成<br>什么时候会真的重编译链接：注意当一个目标是文件时，若任何它的依赖改变，它需要被重新编译或链接；<br>并且：任何依赖自身也应该先被自动更新再生成；<br>When a target is a file, it needs to be recompiled or relinked if any of its prerequisites change<br>In addition, any prerequisites that are themselves automatically generated should be updated first.  </p>
<p>生成规则是由使用者定的，make会执行给定的规则中的每一行：<br>比如下面给了两行，当main.o发生改变时，make的时候就会执行下面两个gcc   </p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">main: main<span class="selector-class">.o</span> </span><br><span class="line">    gcc -c main<span class="selector-class">.cpp</span> </span><br><span class="line">    gcc -o main main.o</span><br></pre></td></tr></table></figure>
<p>phony targets<br>虚假目标的概念，不依赖其他文件，执行时需要明确指出目标如： make clean </p>
<p>default goal.<br>make会把第一个目标当成默认目标，则 注意位置：  </p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">hh<span class="selector-class">.o</span>: hh<span class="selector-class">.cpp</span> hh<span class="selector-class">.h</span> </span><br><span class="line">    gcc -c hh<span class="selector-class">.cpp</span> </span><br><span class="line">main: main<span class="selector-class">.cpp</span> hh<span class="selector-class">.cpp</span> </span><br><span class="line">    gcc -o main main<span class="selector-class">.cpp</span> hh.cpp</span><br></pre></td></tr></table></figure>
<p>这样make的时候，是只会执行gcc -c hh.cpp 注意这里hh.o不依赖main </p>
<ul>
<li>规则的递归依赖重生成 解释下：makefile如下 重要！！！<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~/c++$ cat makefile </span><br><span class="line">main: hh<span class="selector-class">.o</span> main.o</span><br><span class="line">	gcc -o main main<span class="selector-class">.o</span> hh.o</span><br><span class="line">hh<span class="selector-class">.o</span>: hh<span class="selector-class">.cpp</span> hh.h</span><br><span class="line">	gcc -c hh.cpp</span><br><span class="line">main<span class="selector-class">.o</span>: main.cpp</span><br><span class="line">	gcc -c main.cpp</span><br><span class="line">首次make</span><br><span class="line">think@think-VirtualBox:~/c++$ make </span><br><span class="line">gcc -c main.cpp</span><br><span class="line">gcc -o main main<span class="selector-class">.o</span> hh.o</span><br><span class="line">改变hh<span class="selector-class">.h</span>,重新生成hh.o和main</span><br><span class="line">think@think-VirtualBox:~/c++$ vim hh.h</span><br><span class="line">think@think-VirtualBox:~/c++$ make </span><br><span class="line">gcc -c hh.cpp</span><br><span class="line">gcc -o main main<span class="selector-class">.o</span> hh.o</span><br><span class="line">删除main<span class="selector-class">.o</span> make重新生成main.o和main，不改变hh.o</span><br><span class="line">think@think-VirtualBox:~/c++$ rm -rf main.o</span><br><span class="line">think@think-VirtualBox:~/c++$ make </span><br><span class="line">gcc -c main.cpp</span><br><span class="line">gcc -o main main<span class="selector-class">.o</span> hh.o</span><br><span class="line">修改main.cpp，重新生成main.o和main</span><br><span class="line">think@think-VirtualBox:~/c++$ vim main<span class="selector-class">.cpp</span> </span><br><span class="line">think@think-VirtualBox:~/c++$ make </span><br><span class="line">gcc -c main.cpp</span><br><span class="line">gcc -o main main<span class="selector-class">.o</span> hh.o</span><br><span class="line">think@think-VirtualBox:~/c++$</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>But make would update automatically generated C programs, such as those made by Bison or Yacc, by their own rules at this time.<br>特例，暂时没用上<br>Thus, if we change the file insert.c and run make, make will compile that file to update insert.o, and then link edit. If we change the file<br>command.h and run make, make will recompile the object files kbd.o, command.o and files.o and then link the file edit.</p>
<h4 id="makefile中的变量使用："><a href="#makefile中的变量使用：" class="headerlink" title="makefile中的变量使用："></a>makefile中的变量使用：</h4><p>We would define such a variable objects with a line like this in the makefile:<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">objects = main.<span class="keyword">o</span> kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">display</span>.<span class="keyword">o</span> \</span><br><span class="line">          <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> utils.<span class="keyword">o</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">edit</span> : $(objects)</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">o</span> <span class="keyword">edit</span> $(objects)</span><br><span class="line">main.<span class="keyword">o</span> : main.<span class="keyword">c</span> defs.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> main.<span class="keyword">c</span></span><br><span class="line">kbd.<span class="keyword">o</span> : kbd.<span class="keyword">c</span> defs.h <span class="keyword">command</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> kbd.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">command</span>.<span class="keyword">o</span> : <span class="keyword">command</span>.<span class="keyword">c</span> defs.h <span class="keyword">command</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">command</span>.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">display</span>.<span class="keyword">o</span> : <span class="keyword">display</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">display</span>.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">insert</span>.<span class="keyword">o</span> : <span class="keyword">insert</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">insert</span>.<span class="keyword">c</span></span><br><span class="line"><span class="built_in">search</span>.<span class="keyword">o</span> : <span class="built_in">search</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="built_in">search</span>.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">files</span>.<span class="keyword">o</span> : <span class="keyword">files</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h <span class="keyword">command</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">files</span>.<span class="keyword">c</span></span><br><span class="line">utils.<span class="keyword">o</span> : utils.<span class="keyword">c</span> defs.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> utils.<span class="keyword">c</span></span><br><span class="line">clean :</span><br><span class="line">        rm <span class="keyword">edit</span> $(objects)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>makefile中的隐式规则：<br>上述的可以简化为：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">implicit rule <span class="keyword">for</span> updating <span class="keyword">a</span> ‘.<span class="keyword">o</span>’ <span class="keyword">file</span> from <span class="keyword">a</span> correspondingly named ‘.<span class="keyword">c</span>’ <span class="keyword">file</span> using <span class="keyword">a</span> ‘<span class="keyword">cc</span> -<span class="keyword">c</span>’ <span class="keyword">command</span>.</span><br><span class="line">objects = main.<span class="keyword">o</span> kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">display</span>.<span class="keyword">o</span> \</span><br><span class="line">          <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> utils.<span class="keyword">o</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">edit</span> : $(objects)</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">o</span> <span class="keyword">edit</span> $(objects)</span><br><span class="line"></span><br><span class="line">main.<span class="keyword">o</span> : defs.h</span><br><span class="line">kbd.<span class="keyword">o</span> : defs.h <span class="keyword">command</span>.h</span><br><span class="line"><span class="keyword">command</span>.<span class="keyword">o</span> : defs.h <span class="keyword">command</span>.h</span><br><span class="line"><span class="keyword">display</span>.<span class="keyword">o</span> : defs.h <span class="keyword">buffer</span>.h</span><br><span class="line"><span class="keyword">insert</span>.<span class="keyword">o</span> : defs.h <span class="keyword">buffer</span>.h</span><br><span class="line"><span class="built_in">search</span>.<span class="keyword">o</span> : defs.h <span class="keyword">buffer</span>.h</span><br><span class="line"><span class="keyword">files</span>.<span class="keyword">o</span> : defs.h <span class="keyword">buffer</span>.h <span class="keyword">command</span>.h</span><br><span class="line">utils.<span class="keyword">o</span> : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">        rm <span class="keyword">edit</span> $(objects)</span><br></pre></td></tr></table></figure>
</li>
<li><p>继续简化：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">objects = main.<span class="keyword">o</span> kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">display</span>.<span class="keyword">o</span> \</span><br><span class="line">          <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> utils.<span class="keyword">o</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">edit</span> : $(objects)</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">o</span> <span class="keyword">edit</span> $(objects)</span><br><span class="line"></span><br><span class="line">$(objects) : defs.h</span><br><span class="line">kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> : <span class="keyword">command</span>.h</span><br><span class="line"><span class="keyword">display</span>.<span class="keyword">o</span> <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> : <span class="keyword">buffer</span>.h</span><br></pre></td></tr></table></figure>
</li>
<li><p>伪目标的意义：<br>.PHONY : clean<br>声明clean是伪目标<br>This prevents make from getting confused by an actual file called clean and causes it to continue in spite of errors from rm.<br>(See Phony Targets, and Errors in Recipes.)  </p>
</li>
</ul>
<h3 id="如何写makefile？"><a href="#如何写makefile？" class="headerlink" title="如何写makefile？"></a>如何写makefile？</h3><p>make依赖读取一个叫makefile的数据库中的信息来知道怎么重新编译一个系统</p>
<h4 id="makefile文件包含什么："><a href="#makefile文件包含什么：" class="headerlink" title="makefile文件包含什么："></a>makefile文件包含什么：</h4><ul>
<li>组成：显示规则，隐式规则，变量定义，指令和注释<br>显示规则：说明什么时候和怎么去重新make一个或多个称为目标的文件；它列出了目标依赖的所有文件，即prerequisites，它也给出怎么创建和更新目标的指令如gcc<br>隐式规则：说明什么时候和怎么去重新make一类文件基于他们的名字，它描述了目标如何依赖于名称与目标类似的文件，并给出了创建或更新这样一个目标的方法。<br>变量：是为以后可以替换到文本中的变量指定文本字符串值的一行。<br>指令是哪些呢？  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读取另一个makefile  </span><br><span class="line">类似条件判断，忽略一部分逻辑  </span><br><span class="line">从包含多行的逐字字符串定义变量</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>关于注释： # 开头，\ 可以跨行注释，不能在变量中用#，# 可以起到在字符中转义的作用；</p>
<ul>
<li>makefile对行的处理：<br>makefile使用一种“基于行”的语法，其中换行符是特殊的，并标记语句的结束。GNU make对语句行的长度没有限制，直到您计算机中的内存大小。<br>通过\反斜杠转义内部的换行符，从而延长一个行；以换行符结束(不管是否转义)作为物理行，以完整语句直到非转义换行符作为逻辑行；<br>eg:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    main: edit.o main.o \  物理行</span><br><span class="line">        k.o   # 逻辑行</span><br><span class="line">        gcc -o main main.o k.o edit.o</span><br><span class="line"></span><br><span class="line">注意：指令行：recipe行可能处理有点不同，对非指令行来讲，换行时多个连续的空格会被压缩成一个；</span><br><span class="line">一个小技巧：</span><br><span class="line">若你不想在通过\续行后，出现空格，比如：</span><br><span class="line">var := one\</span><br><span class="line">       word</span><br><span class="line">后解析为：</span><br><span class="line">var := one word</span><br><span class="line">则可以写成这样：</span><br><span class="line">var := one$\</span><br><span class="line">       word</span><br><span class="line">这样会得到：</span><br><span class="line">var := oneword</span><br><span class="line">原因：美元符号加\ 在make将\和前面的空格压缩为一个空格后为： one$ word， 而之后，'$ '会被make识别为' '为名的变量，而这个变量不存在，就会用空字符串替代</span><br><span class="line">变成 var := oneword</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="makefile文件的命名；"><a href="#makefile文件的命名；" class="headerlink" title="makefile文件的命名；"></a>makefile文件的命名；</h4><p>makefile文件可以命名为：makefile/Makefile/GNUmakefile,推荐第二种；不推荐第三种，因为其他make程序不认；<br>如果不想用默认的，即make时会默认找上面的三种文件，找不到又没有指定，则无法make，可以通过-f /–file 来指定make的文件；<br>如make -f mymakefile;还可以指定多个： make -f mymakefile -f yourmakefile;  </p>
<h4 id="一个makefile文件如何使用其他makefile文件"><a href="#一个makefile文件如何使用其他makefile文件" class="headerlink" title="一个makefile文件如何使用其他makefile文件"></a>一个makefile文件如何使用其他makefile文件</h4><p>语法：<br>include filename…<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">include foo *<span class="selector-class">.mk</span> $(bar)</span><br><span class="line">include aa<span class="selector-class">.mk</span> bish bash</span><br><span class="line">include aa<span class="selector-class">.mk</span> bb.mk</span><br><span class="line">include /user/local/m.mk</span><br></pre></td></tr></table></figure></p>
<p>如果指定的名称不以斜杠开头，并且在当前目录中找不到该文件，则会搜索其他几个目录。<br>首先，搜索使用’ -I ‘或’——include-dir ‘选项指定的任何目录。<br>然后搜索以下目录(如果它们存在的话)，顺序如下:prefix/include(通常是/usr/local/include 1) /usr/gnu/include， /usr/local/include， 找不到则警告，若不想要警告信息，可以用这个语法：<br>-include filenames…  </p>
<h4 id="MAKEFILES变量；类似于include"><a href="#MAKEFILES变量；类似于include" class="headerlink" title="MAKEFILES变量；类似于include"></a>MAKEFILES变量；类似于include</h4><p>如果你的当前环境中定义了环境变量 MAKEFILES ，那么，make会把这个变量中的值做一个类似于 include 的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和 include 不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>
<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。<br>在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<h4 id="overrding-makefiles"><a href="#overrding-makefiles" class="headerlink" title="overrding makefiles"></a>overrding makefiles</h4><p>有时，拥有一个与另一个makefile基本相同的makefile是很有用的。<br>你可以经常使用’ include ‘指令将一个包含到另一个中，并添加更多的目标或变量定义。但是，两个makefile为同一个目标提供不同的recipes(指令)是无效的。但还有另一种方法。</p>
<h4 id="make如何读取makefile"><a href="#make如何读取makefile" class="headerlink" title="make如何读取makefile"></a>make如何读取makefile</h4><p>GNU的make工作时的执行步骤如下：（想来其它的make也是类似）  </p>
<p>1 读入所有的Makefile。<br>2 读入被include的其它Makefile。<br>3 初始化文件中的变量。<br>4 推导隐晦规则，并分析所有规则。<br>5 为所有的目标文件创建依赖关系链。<br>6 根据依赖关系，决定哪些目标要重新生成。<br>7 执行生成命令。<br>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。  </p>
<p>当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>
<h4 id="make如何解析makefile"><a href="#make如何解析makefile" class="headerlink" title="make如何解析makefile"></a>make如何解析makefile</h4><h4 id="How-and-when-secondary-expansion-is-performed"><a href="#How-and-when-secondary-expansion-is-performed" class="headerlink" title="How and when secondary expansion is performed."></a>How and when secondary expansion is performed.</h4><h3 id="makefile的规则书写"><a href="#makefile的规则书写" class="headerlink" title="makefile的规则书写"></a>makefile的规则书写</h3><p>如果默认目标没有指定，则默认第一个规则的第一个目标为默认目标，有两个例外，以句号开头的目标除非包含/ ;<br>所以我们经常用第一个规则来编整个程序或者以all: 描述整个程序；</p>
<h4 id="Rule的例子"><a href="#Rule的例子" class="headerlink" title="Rule的例子"></a>Rule的例子</h4><p>一个例子和解释：<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">foo.o : foo.<span class="keyword">c</span> defs.h       # <span class="keyword">module</span> for twiddling the frobs</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> -g foo.<span class="keyword">c</span></span><br></pre></td></tr></table></figure></p>
<p>这个规则说明：<br>1) 如何确定foo.o过期了： 它不存在或者foo.c/defs.h 比它更新<br>2) 如何更新foo.o: 通过运行cc，这个规则没有显示指定defs.h,但是c文件肯定包含，需要加到依赖；  </p>
<h4 id="Rule语法"><a href="#Rule语法" class="headerlink" title="Rule语法"></a>Rule语法</h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">targets : <span class="type">prerequisites</span></span><br><span class="line">        recipe</span><br><span class="line">        …</span><br><span class="line"><span class="keyword">or</span> like:</span><br><span class="line">targets : <span class="type">prerequisites</span> ; recipe</span><br><span class="line">        recipe</span><br><span class="line">        …</span><br></pre></td></tr></table></figure>
<ul>
<li>目标: 一般是文件名，由空格分割，可以使用通配符，并且a(m)代表归档文件中a中的成员m,通常一个规则一个目标，也可能有多个；  </li>
<li>规则: 以tab开头，可以是上面的两种方式，注意分号；  </li>
<li>变量：因为变量是以美元符号$开头的，所以若要在目标和依赖中写$,则必须用两个$,如$$.若已经使用了二次扩展，且想在其中放$,则要用四个$  </li>
<li>反斜杠用来延长行；  </li>
<li>指令其实不止是gcc,还可以是其他shell指令  </li>
</ul>
<h4 id="依赖文件的类型"><a href="#依赖文件的类型" class="headerlink" title="依赖文件的类型"></a>依赖文件的类型</h4><p>一般的任何依赖更新了，目标都要更新；</p>
<h4 id="Wildcards-通配符-用法"><a href="#Wildcards-通配符-用法" class="headerlink" title="Wildcards(通配符)用法"></a>Wildcards(通配符)用法</h4><p>单个文件名可以使用通配符匹配多个文件,在make中，通配符有：<em>,?,[…]等，和shell相同，如</em>.c表示所有.c结尾的文件；<br>文件名开头的“~”字符也具有特殊意义，~/bin表示主目录下的bin,~joh/bin表示/home/joh/bin，即主目录名为joh<br>通配符扩展由make在目标和先决条件中自动执行。在recipes中，shell负责通配符扩展。在其他情况下，通配符扩展只有在使用通配符函数显式请求时才会发生<br>可以通过反斜杠来转义通配符；<br>这里用的是os中的shell所支持的通配符；</p>
<h5 id="通配符的例子："><a href="#通配符的例子：" class="headerlink" title="通配符的例子："></a>通配符的例子：</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">在指令中使用，由shell扩展：</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -f *.o</span><br><span class="line">在依赖中：</span><br><span class="line"><span class="section">print: *.c</span></span><br><span class="line">        lpr -p <span class="variable">$?</span>  </span><br><span class="line">        touch print</span><br><span class="line">定义变量，变量中使用比较特殊：</span><br><span class="line">objects = *.o 这个是错误的，需要用：objects := <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br></pre></td></tr></table></figure>
<h5 id="通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；"><a href="#通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；" class="headerlink" title="通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；"></a>通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；</h5><h5 id="通配符函数："><a href="#通配符函数：" class="headerlink" title="通配符函数："></a>通配符函数：</h5><p>通配符扩展在规则中自动发生。但是，当设置了变量或函数的参数时，通配符展开通常不会发生。如果你想在这些地方进行通配符扩展，你需要使用通配符函数，像这样:<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern…)</span></span><br></pre></td></tr></table></figure></p>
<p>一般我们可以使用“$(wildcard <em>.c)”来获取工作目录下的所有的.c文件列表。复杂一些用法；可以使用“$(patsubst %.c,%.o,$(wildcard </em>.c))”，<br>首先使用“wildcard”函数获取工作目录下的.c文件列表；之后将列表中所有文件名的后缀.c替换为.o。这样我们就可以得到在当前目录可生成的.o文件列表。<br>因此在一个目录下可以使用如下内容的Makefile来将工作目录下的所有的.c文件进行编译并最后连接成为一个可执行文件：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line"> </span><br><span class="line">foo : <span class="variable">$(objects)</span></span><br><span class="line">cc -o foo <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="目录搜索，为源文件搜索其他路径"><a href="#目录搜索，为源文件搜索其他路径" class="headerlink" title="目录搜索，为源文件搜索其他路径"></a>目录搜索，为源文件搜索其他路径</h4><p>对一些大型系统，常常将源文件放在各种分离的目录下，则目录搜索作为make的一个有用特性，可以轻易搜索一些目录，自动找到依赖；当在这些目录中重新分配文件时，不需要改规则，只需要改搜索路径；<br>需要注意的是，make的搜索，和指令中的编译器等搜索不同，虽然你在make中指定了，但是如果头文件在不同的目录，使用gcc时，<br>或者通过#include的时候，协商所有路径，否则，需要指定-I gcc -I dir  </p>
<p>make这里的搜索，更多的体现在依赖文件，指令中指定的文件等</p>
<h5 id="整体搜索"><a href="#整体搜索" class="headerlink" title="整体搜索"></a>整体搜索</h5><p>具体化一个搜索路径应用到所有依赖；<br>make uses VPATH as a search list for both prerequisites and targets of rules.<br>所以，如果列在目标或依赖中的文件不在当前的目录，make会在VPATH定义的目录里面找文件名，找到就算；仿佛它们存在当前的目录一样；<br>VPATH定义的目录，由空格或冒号隔开：<br>eg: VPATH = src:../headers<br>所以假设没有在当前目录找到，在src中找到，则：这样的规则：<br> foo.o:foo.c ===&gt; foo.o:src/foo.c<br>注意顺序，即会先从本地找，没有再src找，没有再../headers中找；</p>
<h5 id="选择性搜索"><a href="#选择性搜索" class="headerlink" title="选择性搜索"></a>选择性搜索</h5><p>为一类名字具体化一个搜索路径<br>使用vpath，注意是小写，允许你具体化一类文件名，只要匹配上具体的模式；因此你可以指定一类名字匹配这个目录，其他名字匹配其他目录：<br>有三种组成：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">1) <span class="keyword">vpath</span> pattern directories : 具体化搜索目录为那些匹配上这个pattern的文件名；注意目录间隔是冒号</span><br><span class="line">2) <span class="keyword">vpath</span> pattern : 清除这个pattern的搜索路径关联</span><br><span class="line">3) <span class="keyword">vpath</span> :清除所有的<span class="keyword">vpath</span> 指定</span><br><span class="line">一个<span class="keyword">vpath</span>是一个包含%的字符串，字符串必须匹配正在搜索的先决条件的文件名，' % '字符匹配任何0个或多个字符的序列(如模式规则;参见定义和重新定义模式规则)</span><br><span class="line">例如，%.h匹配以.h结尾的文件。(如果没有' % '，则模式必须完全匹配先决条件，这通常是不太有用的</span><br><span class="line">作用： 当一个依赖中的文件在当前目录不存在时，并且文件名匹配上面的模式时，就会去搜索被<span class="keyword">vpath</span>指定的目录；</span><br><span class="line"><span class="section">eg:</span></span><br><span class="line">    <span class="keyword">vpath</span> %.h ../headers</span><br><span class="line">如果有多个目录，则一个接一个进行搜索：</span><br><span class="line"><span class="keyword">vpath</span> %.c foo</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br><span class="line"><span class="keyword">vpath</span> %.c bar</span><br><span class="line">先foo，再blish，再bar</span><br><span class="line"><span class="keyword">vpath</span> %.c foo:bar</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br><span class="line">先foo,再bar,再blish</span><br></pre></td></tr></table></figure></p>
<h5 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h5><p>搜索路径什么时候，如何被应用；<br>当通过目录搜索找到先决条件时，不管类型是什么(通用的还是选择性的)，所找到的路径名可能不是make在先决条件列表中实际提供给您的路径名。有时，通过目录搜索发现的路径被丢弃。<br>make通过如下的信息来决定是否保持和丢弃一个路径：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)如果在makefile中指定的路径上不存在目标文件，则执行目录搜索。</span><br><span class="line"><span class="number">2</span>)如果目录搜索成功，则保留该路径，并暂时将该文件存储为目标。</span><br><span class="line"><span class="number">3</span>)使用相同的方法检查此目标的所有先决条件。</span><br><span class="line"><span class="number">4</span>)处理完先决条件后，可能需要也可能不需要重建目标</span><br><span class="line">   a 如果不需要重新构建目标，在目录搜索期间找到的文件的路径将用于包含该目标的任何先决条件列表。简而言之，如果make不需要重新构建目标，那么您可以使用通过目录搜索找到的路径。</span><br><span class="line">   b 如果目标确实需要重新构建(已过期)，则丢弃在目录搜索期间找到的路径名，并使用makefile中指定的文件名重新构建目标。简而言之，如果make必须重新生成，则在本地重新生成目标，而不是在通过目录搜索找到的目录中。</span><br></pre></td></tr></table></figure></p>
<p>对其他版本的make也是类似的，如果想要做到在搜索到的路径下生成目标：如：<br>如果文件不存在，并且通过目录搜索找到了它，那么无论是否需要构建目标，都会使用该路径名。因此，如果重新构建目标，则在目录搜索期间发现的路径名处创建目标。<br>则使用GPATH:<br>具有与VPATH相同的语法和格式(即以空格或冒号分隔的路径名列表)。如果通过目录搜索在GPATH中也出现的目录中找到一个过期的目标，那么该路径名不会被丢弃。使用扩展的路径重新生成目标。  </p>
<h5 id="指令搜索：-如何写一个指令能和搜索路径一起工作"><a href="#指令搜索：-如何写一个指令能和搜索路径一起工作" class="headerlink" title="指令搜索： 如何写一个指令能和搜索路径一起工作"></a>指令搜索： 如何写一个指令能和搜索路径一起工作</h5><p>比如：你的依赖通过目录搜索在其他路径中被找到，但是在指令中，写的依赖文件的路径还是原来的，那么如何改变使得make可以在指令执行时找到正确的依赖呢？<br>这是通过自动变量完成的，比如’ $^ ‘(参见自动变量)。例如，’ $^ ‘的值是规则的所有先决条件的列表，包括在其中找到它们的目录名，’ $@ ‘的值是目标<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">        cc -c $(CFLAGS) $^ -o $@</span><br></pre></td></tr></table></figure></p>
<p>如果你只想要依赖中的第一个文件，比如下面的不要依赖头文件，则：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">VPATH = src:../headers</span><br><span class="line">foo.o : foo.c defs.h hack.h</span><br><span class="line">        cc -c $(CFLAGS) $&lt; -o $@</span><br></pre></td></tr></table></figure></p>
<h5 id="隐式规则索索；"><a href="#隐式规则索索；" class="headerlink" title="隐式规则索索；"></a>隐式规则索索；</h5><p>搜索路径如何影响隐式规则，如果没有声明显示规则，那make会使用隐式规则，若在当前目录找不到，则会去VPATH/vpath指定的路径搜索，找到则会被应用；</p>
<h5 id="链接库搜索；"><a href="#链接库搜索；" class="headerlink" title="链接库搜索；"></a>链接库搜索；</h5><p>链接库的目录搜索，当依赖中有库文件时，可以使用-lname的方式来指定依赖：<br>当依赖中的名字有类似 ‘-lname’,则make会在特别的在当前目录搜索文件libname.so,如果找不到，就在当前目录找libname.a；然后找不到继续在VPATH/vpath/ /usr/lib等找；<br>比如：有文件/usr/lib/libcurses.a ，但是没有so则<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">foo : foo.c -lcurses</span><br><span class="line">        cc $^ -o $@</span><br></pre></td></tr></table></figure></p>
<p>会找到.a ,执行‘cc foo.c /usr/lib/libcurses.a -o foo’<br>解释下：尽管要搜索的默认文件集是libname。所以,库名.a，这是通过. libpatterns变量定制的。这个变量值中的每个单词都是一个模式字符串。<br>当看到像’ -lname ‘这样的先决条件时，make将用name替换列表中每个模式中的百分比，并使用每个库文件名执行上述目录搜索。<br>.LIBPATTERNS is ‘lib%.so lib%.a’</p>
<h4 id="伪目标，强制目标-空目标-特殊目标，多目标"><a href="#伪目标，强制目标-空目标-特殊目标，多目标" class="headerlink" title="伪目标，强制目标 空目标 特殊目标，多目标"></a>伪目标，强制目标 空目标 特殊目标，多目标</h4><h5 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h5><p>虚假目标不是真正的文件名;相反，它只是在发出显式请求时要执行的配方的名称。使用假目标有两个原因:避免与同名文件的冲突，以及提高性能。<br>因为rm命令不会创建一个名为clean的文件，所以可能永远不会存在这样的文件。因此，每当您说“make clean”时，rm命令将被执行。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">        rm *<span class="selector-class">.o</span> temp</span><br></pre></td></tr></table></figure></p>
<p>在本例中，如果在此目录中创建了一个名为clean的文件，则clean目标将不能正常工作。因为它没有先决条件，<br>所以clean总是被认为是最新的，它的指令不会被执行。为了避免这个问题，您可以显式地声明目标为假的，方法是将它作为特殊目标.PHONY的依赖，如下所示:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.PHONY</span>: clean</span><br><span class="line">clean:</span><br><span class="line">        rm *<span class="selector-class">.o</span> temp</span><br></pre></td></tr></table></figure></p>
<p>一旦完成，’ make clean ‘将运行指令，而不管是否有一个名为clean的文件<br>假目标在与make的递归调用结合使用时也很有用(请参阅make的递归使用)。在这种情况下，<br>makefile通常会包含一个变量，其中列出了许多要构建的子目录。用一个循环来处理，像这样:<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">SUBDIRS = foo bar baz</span><br><span class="line"></span><br><span class="line"><span class="symbol">subdirs:</span></span><br><span class="line">        <span class="keyword">for</span> dir <span class="keyword">in</span> <span class="variable">$(</span>SUBDIRS); <span class="keyword">do</span> \</span><br><span class="line">          <span class="variable">$(</span>MAKE) -C <span class="variable">$$</span>dir; \</span><br><span class="line">        done</span><br></pre></td></tr></table></figure></p>
<p>然而，这种方法存在一些问题。首先，在子make中检测到的任何错误都会被该规则忽略，所以即使有一个失败了，它也会继续构建其余的目录。这可以通过添加shell命令来注意错误和退出来克服，<br>但是即使使用-k选项调用make，它也会这样做，这是不幸的。其次，也许是更重要的一点，您不能利用make的能力并行构建目标(请参阅并行执行)，因为只有一条规则。<br>通过声明子目录为.PHONY目标(你必须这样做，因为子目录显然总是存在的;否则它不会被建立)你可以移除上述问题:<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SUBDIRS = foo bar baz</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: subdirs $(SUBDIRS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">subdirs: <span class="variable">$(SUBDIRS)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(SUBDIRS)</span>:</span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: baz</span></span><br></pre></td></tr></table></figure></p>
<p>这样的话，就需要baz先完成，才能完成foo;<br>以上也可以用伪目标来实现：<br>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，<br>但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">all : prog1 prog2 prog3</span><br><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">    cc -o prog1 prog1.o utils.o</span><br><span class="line"></span><br><span class="line">prog2 : prog2.o</span><br><span class="line">    cc -o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">    cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure></p>
<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于默认目标的特性是，总是被执行的，但由于“all”又是一个伪目标，<br>伪目标只是一个标签不会生成文件，所以不会有“all”文件产生。于是，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。 .PHONY :<br>all 声明了“all”这个目标为“伪目标”。（注：这里的显式“.PHONY : all” 不写的话一般情况也可以正确的执行，这样make可通过隐式规则推导出， “all” 是一个伪目标，<br>执行make不会生成“all”文件，而执行后面的多个目标。建议：显式写出是一个好习惯。）</p>
<p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.PHONY : cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">    rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">    rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">    rm *.diff</span><br></pre></td></tr></table></figure></p>
<p>“make cleanall”将清除所有要被清除的文件。<br>“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。</p>
<h5 id="强制目标：没有依赖或规则的目标："><a href="#强制目标：没有依赖或规则的目标：" class="headerlink" title="强制目标：没有依赖或规则的目标："></a>强制目标：没有依赖或规则的目标：</h5><p>如果一个规则没有依赖或指令，并且规则的目标是一个不存在的文件，那么make就假设这个目标在其规则运行时已被更新。这意味着依赖于此的所有目标都将始终运行它们的指令。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean: FORCE</span></span><br><span class="line">        rm <span class="variable">$(objects)</span></span><br><span class="line"><span class="section">FORCE:</span></span><br></pre></td></tr></table></figure>
<p>在这里，目标“FORCE”满足了特殊条件，所以依赖于它的目标clean将被迫运行其指令。“FORCE”这个名称并没有什么特别之处，但这是一个常用的名称。</p>
<h5 id="空目标文件用来记录事件"><a href="#空目标文件用来记录事件" class="headerlink" title="空目标文件用来记录事件"></a>空目标文件用来记录事件</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>: foo.<span class="built_in">c</span> bar.<span class="built_in">c</span></span><br><span class="line">        lpr -p $?</span><br><span class="line">        touch <span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<p>有了这个规则，如果任何一个源文件在上次’ make print ‘之后发生了变化，’ make print ‘将执行lpr命令。自动变量’ $?’仅用于打印那些已更改的文件</p>
<h5 id="具体的内建目标名"><a href="#具体的内建目标名" class="headerlink" title="具体的内建目标名"></a>具体的内建目标名</h5><p>.PHONY/.SUFFIXES/.DEFAULT/.PRECIOUS/.INTERMEDIATE/.SECONDARY/.SECONDEXPANSION/…</p>
<h5 id="一个规则中的多个目标"><a href="#一个规则中的多个目标" class="headerlink" title="一个规则中的多个目标"></a>一个规则中的多个目标</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">eg：</span><br><span class="line">bigoutput littleoutput : text<span class="variable">.g</span></span><br><span class="line">        <span class="keyword">generate</span> text<span class="variable">.g</span> -$(subst <span class="keyword">output</span>,,$@) &gt; $@</span><br><span class="line">和下面的相同</span><br><span class="line">bigoutput : text<span class="variable">.g</span></span><br><span class="line">        <span class="keyword">generate</span> text<span class="variable">.g</span> -big &gt; bigoutput</span><br><span class="line">littleoutput : text<span class="variable">.g</span></span><br><span class="line">        <span class="keyword">generate</span> text<span class="variable">.g</span> -little &gt; littleoutput</span><br></pre></td></tr></table></figure>
<h4 id="多个规则"><a href="#多个规则" class="headerlink" title="多个规则"></a>多个规则</h4><p>一个目标，多个规则；<br>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，<br>多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个自动化变量 $@ （关于自动化变量，将在后面讲述），<br>这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。<br><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">bigoutput littleoutput : text<span class="variable">.g</span></span><br><span class="line">    <span class="keyword">generate</span> text<span class="variable">.g</span> -$(subst <span class="keyword">output</span>,,$@) &gt; $@</span><br><span class="line">上述规则等价于：</span><br><span class="line"></span><br><span class="line">bigoutput : text<span class="variable">.g</span></span><br><span class="line">    <span class="keyword">generate</span> text<span class="variable">.g</span> -big &gt; bigoutput</span><br><span class="line">littleoutput : text<span class="variable">.g</span></span><br><span class="line">    <span class="keyword">generate</span> text<span class="variable">.g</span> -little &gt; littleoutput</span><br><span class="line"></span><br><span class="line">其中， -$(subst <span class="keyword">output</span>,,$@) 中的 $ 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思，</span><br><span class="line"> $@ 表示目标的集合，就像一个数组， $@ 依次取出目标，并执于命令。</span><br></pre></td></tr></table></figure></p>
<h4 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h4><h5 id="静态模式规则的语法："><a href="#静态模式规则的语法：" class="headerlink" title="静态模式规则的语法："></a>静态模式规则的语法：</h5><p>当需要定义多个目标规则，且他们都类似时，可以用静态模式避免写很多规则，就像正则表达式一样;<br>它的语法：<br><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;targets ...&gt;</span> : <span class="params">&lt;target-pattern&gt;</span> : <span class="params">&lt;prereq-patterns ...&gt;</span></span><br><span class="line">    <span class="params">&lt;commands&gt;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="symbol">targets:</span> 定义了一系列的目标文件，可以有通配符。是目标的一个集合。</span><br><span class="line">target-pattern: 是指明了targets的模式，也就是的目标集模式。</span><br><span class="line">prereq-patterns : 是目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。</span><br><span class="line">解释下：如果我们的<span class="params">&lt;target-pattern&gt;</span>定义成 %.o ，意思是我们的<span class="params">&lt;target&gt;</span>;集合中都是以 .o 结尾的，而如果我们的<span class="params">&lt;prereq-patterns&gt;</span>定义成 %.c ，</span><br><span class="line">意思是对<span class="params">&lt;target-pattern&gt;</span>所形成的目标集进行二次定义，其计算方法是，取<span class="params">&lt;target-pattern&gt;</span>模式中的 % （也就是去掉了 .o 这个结尾），并为其加上 .c 这个结尾，形成的新集合。</span><br><span class="line">所以，我们的“目标模式”或是“依赖模式”中都应该有 % 这个字符，如果你的文件名中有 % 那么你可以使用反斜杠 \ 进行转义，来标明真实的 % 字符。</span><br></pre></td></tr></table></figure></p>
<p>eg:<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure></p>
<p>上面的例子中，指明了我们的目标从$object中获取， %.o 表明要所有以 .o 结尾的目标，也就是 foo.o bar.o ，也就是变量 $object 集合的模式，而依赖模式 %.c 则取模式 %.o 的 % ，<br>也就是 foo bar ，并为其加下 .c 的后缀，于是，我们的依赖目标就是 foo.c bar.c 。而命令中的 $&lt; 和 $@ 则是自动化变量， $&lt; 表示第一个依赖文件， $@ 表示目标集（也就是“foo.o bar.o”）。<br>于是，上面的规则展开后等价于下面的规则：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">foo<span class="selector-class">.o</span> : foo.c</span><br><span class="line">    $(CC) -c $(CFLAGS) foo<span class="selector-class">.c</span> -o foo.o</span><br><span class="line">bar<span class="selector-class">.o</span> : bar.c</span><br><span class="line">    $(CC) -c $(CFLAGS) bar<span class="selector-class">.c</span> -o bar.o</span><br></pre></td></tr></table></figure></p>
<p>所以对于很多需要这样生成的，可以省去很多，提高效率<br>另一个例子：eg:<br><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line">$(<span class="keyword">filter</span> %.o,$(files)): %.o: %.c</span><br><span class="line">    $(CC) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line">$(<span class="keyword">filter</span> %.elc,$(files)): %.elc: %.el</span><br><span class="line">    emacs -f batch-byte-compile $&lt;</span><br></pre></td></tr></table></figure></p>
<p>$(filter %.o,$(files))表示调用Makefile的filter函数，过滤“$files”集，只要其中模式为“%.o”的内容。</p>
<h4 id="自动化生成先决条件：How-to-automatically-generate-rules-giving-prerequisites-from-source-files-themselves"><a href="#自动化生成先决条件：How-to-automatically-generate-rules-giving-prerequisites-from-source-files-themselves" class="headerlink" title="自动化生成先决条件：How to automatically generate rules giving prerequisites from source files themselves."></a>自动化生成先决条件：How to automatically generate rules giving prerequisites from source files themselves.</h4><p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句 #include “defs.h” ，那么我们的依赖关系应该是：<br>main.o : main.c defs.h<br>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。<br>为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。<br>例如，如果我们执行下面的命令:<br>cc -M main.c<br>输出：<br>main.o : main.c defs.h<br>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用 -MM 参数，不然，<br> -M 参数会把一些标准库的头文件也包含进来。<br>gcc -M main.c的输出是:<br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">main.<span class="symbol">o:</span> main.c defs.h /usr/<span class="keyword">include</span>/stdio.h /usr/<span class="keyword">include</span>/features.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/sys/cdefs.h /usr/<span class="keyword">include</span>/gnu/stubs.h \</span><br><span class="line">    /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>-<span class="title">lib</span>/<span class="title">i486</span>-<span class="title">suse</span>-<span class="title">linux</span>/2.95.3/<span class="title">include</span>/<span class="title">stddef</span>.<span class="title">h</span> \</span></span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/types.h /usr/<span class="keyword">include</span>/bits/pthreadtypes.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/sched.h /usr/<span class="keyword">include</span>/libio.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/_G_config.h /usr/<span class="keyword">include</span>/wchar.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/wchar.h /usr/<span class="keyword">include</span>/gconv.h \</span><br><span class="line">    /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>-<span class="title">lib</span>/<span class="title">i486</span>-<span class="title">suse</span>-<span class="title">linux</span>/2.95.3/<span class="title">include</span>/<span class="title">stdarg</span>.<span class="title">h</span> \</span></span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/stdio_lim.h</span><br></pre></td></tr></table></figure></p>
<p>gcc -MM main.c的输出则是:main.o: main.c defs.h<br>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让 Makefile自已依赖于源文件？这个功能并不现实，<br>不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 name.c 的文件都生成一个 name.d 的Makefile文件，<br>.d 文件中就存放对应 .c 文件的依赖关系。</p>
<p>于是，我们可以写出 .c 文件和 .d 文件的依赖关系，并让make自动更新或生成 .d 文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。<br>这里，我们给出了一个模式规则来产生 .d 文件：<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">%.d: %.c</span><br><span class="line">    @<span class="keyword">set</span> -e; rm -f <span class="symbol">$</span>@; \</span><br><span class="line">    <span class="symbol">$</span>(CC) -M <span class="symbol">$</span>(CPPFLAGS) <span class="symbol">$</span>&lt; &gt; <span class="symbol">$</span>@.<span class="symbol">$</span><span class="symbol">$</span><span class="symbol">$</span><span class="symbol">$</span>; \</span><br><span class="line">    sed <span class="string">'s,\($*\)\.o[ :]*,\1.o $@ : ,g'</span> &lt; <span class="symbol">$</span>@.<span class="symbol">$</span><span class="symbol">$</span><span class="symbol">$</span><span class="symbol">$</span> &gt; <span class="symbol">$</span>@; \</span><br><span class="line">    rm -f <span class="symbol">$</span>@.<span class="symbol">$</span><span class="symbol">$</span><span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></p>
<p>这个规则的意思是，所有的 .d 文件依赖于 .c 文件， rm -f $@ 的意思是删除所有的目标，也就是 .d 文件，第二行的意思是，为每个依赖文件 $&lt; ，也就是 .c 文件生成依赖文件，<br>$@ 表示模式 %.d 文件，如果有一个C文件是name.c，那么 % 就是 name ， $$$$ 意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，<br>关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。<br>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入 .d 文件的依赖，即把依赖关系：<br>main.o : main.c defs.h<br>转成<br>main.o main.d : main.c defs.h<br>于是，我们的 .d 文件也会自动更新了，并会自动生成了，当然，你还可以在这个 .d 文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 .d 文件都包含一个完赖的规则。<br>一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">sources = foo<span class="selector-class">.c</span> bar.c</span><br><span class="line"></span><br><span class="line">include $(sources:.c=.d)</span><br></pre></td></tr></table></figure></p>
<p>上述语句中的 $(sources:.c=.d) 中的 .c=.d 的意思是做一个替换，把变量 $(sources) 所有 .c 的字串都替换成 .d ，关于这个“替换”的内容，在后面我会有更为详细的讲述。<br>当然，你得注意次序，因为include是按次序来载入文件，最先载入的 .d 文件中的目标会成为默认目标。</p>
<p>一个综合的例子：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#VPATH =</span></span><br><span class="line"><span class="keyword">vpath</span> %.h .:../commonlib/huyacommon:../commonlib/log4cplus/<span class="keyword">include</span>:srt/<span class="keyword">include</span>/srt/</span><br><span class="line"><span class="keyword">vpath</span> %.cpp .:../commonlib/huyacommon</span><br><span class="line"><span class="keyword">vpath</span> %.c .:../commonlib/huyacommon</span><br><span class="line"></span><br><span class="line">INCLUDE_DIR	+= -I . -I ../commonlib/huyacommon/ -I ../commonlib/log4cplus/<span class="keyword">include</span>/ -I srt/<span class="keyword">include</span>/srt/</span><br><span class="line">LIB_DIR += ../commonlib/json/libjson.a ../commonlib/huyacommon/common.a</span><br><span class="line"></span><br><span class="line">CC	= gcc</span><br><span class="line">CPP = g++</span><br><span class="line">CFLAGS = -g -Wall -fPIC -c</span><br><span class="line">CPPFLAGS = -g -Wall -fPIC  -c -std=c++0x -Wno-invalid-offsetof -Wextra -Wno-reorder -Wno-strict-aliasing -std=c++0x -Wno-sign-compare </span><br><span class="line"></span><br><span class="line">SOURCES += <span class="variable">$(<span class="built_in">wildcard</span> ./*.cpp)</span></span><br><span class="line"><span class="comment">#SOURCES += $(wildcard ../commonlib/*.cpp)</span></span><br><span class="line"><span class="comment">#SOURCES += $(wildcard ../netlayer/*.cpp)</span></span><br><span class="line"><span class="comment">#SOURCES += $(wildcard yyprotocol/*.cpp)</span></span><br><span class="line"></span><br><span class="line">objects = <span class="variable">$(<span class="built_in">patsubst</span> ./%.cpp,%.o,<span class="variable">$(SOURCES)</span>)</span></span><br><span class="line">objectsd = <span class="variable">$(<span class="built_in">patsubst</span> ./%.cpp,%.d,<span class="variable">$(SOURCES)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:dfiles afiles</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="comment">#先更新d文件，即可能依赖改变了</span></span><br><span class="line">dfiles : <span class="variable">$(objectsd)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成.d文件,到.d的目录下</span></span><br><span class="line"><span class="variable">$(objectsd)</span>:%.d:%.cpp</span><br><span class="line">	<span class="variable">$(CPP)</span> -MM -w --std=c++0x  -fpermissive  <span class="variable">$&lt;</span> <span class="variable">$(INCLUDE_DIR)</span>  &gt; dfile/<span class="variable">$@</span></span><br><span class="line">	@echo <span class="variable">$(objectsd)</span></span><br><span class="line">	@echo <span class="string">"	<span class="variable">$(CPP)</span> -c <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(INCLUDE_DIR)</span> <span class="variable">$&lt;</span>"</span> &gt;&gt; dfile/<span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行依赖文件指令，这样保证依赖的头文件和实现文件只要改变，就能重新生成</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(<span class="built_in">patsubst</span> %.d,dfile/%.d,<span class="variable">$(objectsd)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后在生成o最新文件的基础上封装为a库</span></span><br><span class="line">afiles : netlayer.a</span><br><span class="line"></span><br><span class="line"><span class="section">netlayer.a:<span class="variable">$(objects)</span></span></span><br><span class="line">	ar rvs netlayer.a <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf netlayer.a *.o</span><br></pre></td></tr></table></figure></p>
<h3 id="规则中指令如何写？"><a href="#规则中指令如何写？" class="headerlink" title="规则中指令如何写？"></a>规则中指令如何写？</h3><p>指令是一个或多个可以执行的shell命令行组成，按顺序执行。而执行的结果，一般就是更新目标文件；<br>使用者使用很多不同的shell指令，但在makefile中总是被/bin/sh解释，除非被配置其他；</p>
<h4 id="指令语法–指令语法特性和陷阱"><a href="#指令语法–指令语法特性和陷阱" class="headerlink" title="指令语法–指令语法特性和陷阱"></a>指令语法–指令语法特性和陷阱</h4><p>tab开头(或者由.RECIPEPREFIX 定义的字符，#开头为注释<br>makefiles中其实有两个不同的语法，一个是make自己的，一个是shell,其实只会在解释指令时，make做很小的解释后，交给shell</p>
<ul>
<li><p>有几个个共同的特性：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 空格开头的空白行，不是一个空行，是一个空指令</span><br><span class="line"><span class="number">2</span>) 一个注释不是make的注释，是make传递给<span class="keyword">shell</span><span class="bash">，shell会根据自己的语法，来判断它是不是注释</span></span><br><span class="line"><span class="bash">3) 在指令中(rule context)中定义的变量，不是make的变量，是被当做rule的一部分，被传递到shell中；</span></span><br><span class="line"><span class="bash">4) 条件表达式表现也和3)一样</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如何换行(同个逻辑行物理行换行)<br>在makefile中，反斜杠也可以在指令中使用，但是是传递给shell去判断的，所以支持与否取决于你的shell工具<br>一个例子：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">ksance<span class="number">0</span><span class="variable">@ubuntu</span><span class="symbol">:~/makefiletest</span><span class="variable">$ </span>make </span><br><span class="line">no hspace</span><br><span class="line">notother</span><br><span class="line">ksance<span class="number">0</span><span class="variable">@ubuntu</span><span class="symbol">:~/makefiletest</span><span class="variable">$ </span>cat makefile </span><br><span class="line"><span class="symbol">all:</span></span><br><span class="line">	<span class="variable">@echo</span> no h\</span><br><span class="line">space</span><br><span class="line">	<span class="variable">@echo</span> <span class="keyword">not</span>\</span><br><span class="line">other</span><br><span class="line">ksance<span class="number">0</span><span class="variable">@ubuntu</span><span class="symbol">:~/makefiletest</span>$</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意如果反斜杠在字符串中，则可能会被忽略；</p>
<ul>
<li>如何在指令中使用变量：<br>指令中的变量和函数引用与makefile中其他地方的引用具有相同的语法和语义。他们也有相同的引用规则，如果你想在指令中使用$符号，你需要使用双$如下，<br>因为在make中引用要用$,在传递给shell前剥离$，但在shell中引用也需要$,所以这里要用双$<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LIST</span> = <span class="keyword">one</span> <span class="keyword">two</span> three</span><br><span class="line">all:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="keyword">LIST</span>); <span class="keyword">do</span> \</span><br><span class="line">            echo $<span class="variable">$i</span>; \</span><br><span class="line">        done</span><br><span class="line">解释后；</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">one</span> <span class="keyword">two</span> three; <span class="keyword">do</span> \</span><br><span class="line">    echo <span class="variable">$i</span>; \</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"><span class="keyword">one</span></span><br><span class="line"><span class="keyword">two</span></span><br><span class="line">three</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="如何控制什么时候指令回显"><a href="#如何控制什么时候指令回显" class="headerlink" title="如何控制什么时候指令回显"></a>如何控制什么时候指令回显</h4><ul>
<li><p>make中可以使用echo指令，默认情况下，make会把要执行的指令打印到屏幕上，但当使用@echo时，只会显示echo后面的字符如：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@echo</span> xxxx</span><br><span class="line">make执行时： 输出：xxxx</span><br><span class="line">而当去掉<span class="variable">@echo</span>时，则输出：</span><br><span class="line">echo xxxx</span><br><span class="line">xxxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>-n和–just-print参数：使用时不会执行命令而是只显示命令</p>
</li>
<li>-s或–silent或–quiet，则是全面禁止指令的显示；</li>
</ul>
<h4 id="指令是如何执行的"><a href="#指令是如何执行的" class="headerlink" title="指令是如何执行的"></a>指令是如何执行的</h4><p>当更新目标时，会执行指令，指令是由shell指令构成的，会执行指令中的每个子shell;.ONESHELL会影响具体的目标;<br>而一个注意的是： cd ,会影响指令的运行环境，比如cd到别的目录执行；不过若想要cd影响到下个指令，需要将下个指令和cd放在同一行;<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">foo:</span> bar/lose</span><br><span class="line">        cd  <span class="variable">$(</span>&lt;D) &amp;&amp; gobble <span class="variable">$(</span>&lt;F) &gt; ../<span class="variable">$@</span></span><br></pre></td></tr></table></figure></p>
<p>这里使用的&amp;&amp; ，所以当cd失败时，整个指令会失败；注意不会执行&amp;&amp;后面的指令；<br>关于.ONESHELL：<br>声明这个后，指令中的多行指令会按单行指令执行，会有以上cd的影响；同时 特殊字符只会在第一行被去掉；比如 @,这可能造成影响，详细见文档；<br>eg:<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">.<span class="string">ONESHELL:</span></span><br><span class="line">SHELL = <span class="regexp">/usr/</span>bin/perl</span><br><span class="line">.SHELLFLAGS = -e</span><br><span class="line"><span class="string">show :</span></span><br><span class="line">        my <span class="meta">@f</span> = qw(a b c);</span><br><span class="line">        print <span class="string">"@f\n"</span>;</span><br></pre></td></tr></table></figure></p>
<p>关于Choosing the Shell选择shell:<br>默认使用/bin/sh ，如果.SHELL没被设置的话；<br>而.SHELLFLAGS默认是-c或-ec<br>这个在DOS和win下比较常见；  </p>
<h4 id="指令如何同时执行"><a href="#指令如何同时执行" class="headerlink" title="指令如何同时执行"></a>指令如何同时执行</h4><p>通常make是顺序执行一条一条指令的，当make -j时，会同时并行执行多个指令；所以为了make更快，可以采用这种形式；若-j后是一个整数，则按整数个同时执行的job来运行，<br>否是是1，串行执行；  </p>
<p>如果一个指令失败(被一个信号杀死或以非零状态退出)，并且不会忽略该指令的错误(请参阅配方中的错误)，那么重新构建同一目标的剩余配方行将不会运行。<br>如果指令失败，并且没有给出’ -k ‘或’——keep-going ‘选项(参见选项摘要)，则make aborts执行。如果make由于任何原因(包括信号)终止了子进程，它会在实际退出之前等待子进程结束。  </p>
<p>当系统负载较重时，您可能希望比负载较轻时运行更少的作业。您可以使用’ -l ‘选项告诉make根据平均负载限制一次运行的作业数量。选项’ -l ‘或’——max-load ‘后面跟着一个浮点数。例如, -l 2.5  </p>
<p>如果平均负载超过2.5，将不会让make启动一个以上的作业。-l后面无数字指定则无效<br>更准确地说，当make启动一个作业时，并且它已经有至少一个作业在运行时，它会检查当前的平均负载;如果它不低于’ -l ‘所给出的极限，则make等待，直到平均负载低于该极限，或直到所有其他作业完成。</p>
<p>默认的，是没有负载限制的；</p>
<ul>
<li>关于并行执行的输出<br>当并行执行的时候，输出信息很难读；为了避免这个，可以用–output-sync选项；该选项指示make保存它调用的命令的输出，并在命令完成后全部打印输出。<br>此外，如果有多个递归make调用并行运行，它们将进行通信，以便每次只生成其中一个输出。  </li>
</ul>
<p>如果启用了工作目录打印(参见’——print-directory ‘选项)，enter/leave消息将围绕每个输出分组打印。如果不希望看到这些消息，可以在MAKEFLAGS中添加’——no-print-directory ‘选项。  </p>
<p>在同步输出时，有四种级别的粒度，通过给选项一个参数来指定(例如，’ -Oline ‘或’——output-sync=recurse ‘)。<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">none:</span>默认的，不同步直接输出  </span><br><span class="line"><span class="symbol">line:</span>每行指令单独分组和打印，当这行指令完成；若一个指令包含多行，可能混合；</span><br><span class="line"><span class="symbol">target:</span>按照每个目标分组打印，和--output-sync/-O效果相同</span><br><span class="line"><span class="symbol">recurse:</span>每次递归调用make的输出都会分组并在递归调用完成后打印</span><br></pre></td></tr></table></figure></p>
<ul>
<li>关于并行执行的输入<br>两个进程不能同时从同一设备获取输入。为了确保一次只有一个配方尝试从终端获取输入，make将使所有正在运行的配方的标准输入流失效。如果另一个配方试图从标准输入读取，它通常会导致一个致命的错误(“断管道”信号)。</li>
</ul>
<h4 id="指令执行失败后会怎么样；"><a href="#指令执行失败后会怎么样；" class="headerlink" title="指令执行失败后会怎么样；"></a>指令执行失败后会怎么样；</h4><p>每行指令会返回成功与否的状态值，成功为0 ，成功时会自动执行下一行，直到规则结束；，若碰到异常，非0值，则make会放弃当前的规则，或者可能所有的规则；<br>有时候指令的失败不代表是一个问题，例如mkdir;目录已存在；为了忽略这行指令的错误，则使用-，如：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">clean</span>： </span><br><span class="line">        <span class="selector-tag">-rm</span> <span class="selector-tag">-f</span> *<span class="selector-class">.o</span></span><br></pre></td></tr></table></figure></p>
<p>这样即使这行rm失败也能继续执行；<br>如果执行make的时候指定-i,或者–ignore-errors,则会忽略全部的异常，和在makefile中声明.IGNORE效果类似；当用在无依赖的规则下比较有用；<br>上述情况下，虽然返回成功，但它会打印出一条消息，告诉您shell退出时使用的状态代码，并告诉您该错误已被忽略。<br>当错误发生时，make没有被告知要忽略它，这意味着当前目标不能被正确地重新创建，任何直接或间接依赖于它的其他目标也不能正确地重新创建。不会对这些目标执行进一步的配方，因为它们的先决条件还没有实现。<br>通常make在这种情况下立即放弃，返回一个非零状态。但是，如果指定了’ -k ‘或’——keep-going ‘标志，make将继续考虑挂起目标的其他先决条件，并在必要时重新生成它们，然后放弃并返回非零状态。<br>例如，在编译一个目标文件时出现错误后，’ make -k ‘将继续编译其他目标文件，即使它已经知道不可能链接它们。  </p>
<h4 id="指令被中断会怎么样"><a href="#指令被中断会怎么样" class="headerlink" title="指令被中断会怎么样"></a>指令被中断会怎么样</h4><p>如果make在shell执行时获得一个致命信号，它可能会删除配方要更新的目标文件。如果目标文件的最后一次修改时间在第一次检查之后发生了改变，就会这样做。</p>
<ul>
<li><p>为什么呢：<br>删除目标的目的是确保在下一次运行make时从头重新创建目标。这是为什么呢?假设您在编译器运行时输入Ctrl-c，并且编译器已经开始编写一个对象文件foo.o。Ctrl-c杀死编译器，导致一个不完整的文件，<br>它的最后修改时间比源文件foo.c更新。但是make也会接收Ctrl-c信号并删除这个不完整的文件。如果make没有这样做，下一次调用make时会认为foo.o不需要更新—当链接器试图链接一个文件时，会产生一个奇怪的错误消息  </p>
</li>
<li><p>如何设置例外？<br>您可以通过使特殊的目标.PRECIOUS 依赖于它来防止以这种方式删除目标文件。在重新创建目标之前，检查它是否在. precious的先决条件下出现，从而决定在信号发生时是否应该删除目标。<br>这样做的一些原因是，目标是以某种原子方式更新的，或者目标的存在只是为了记录修改时间(其内容并不重要)，或者目标必须一直存在以防止其他类型的麻烦</p>
</li>
<li><p>无法覆盖全部：<br>尽管make尽力清理，但在某些情况下，清理是不可能的。例如，make可能会被一个无法捕获的信号杀死。或者，某个程序make调用可能被杀死或崩溃，留下一个最新的但已损坏的目标文件:make不会意识到这个故障需要清除目标文件。或者使自己可能遇到bug而崩溃。</p>
</li>
<li><p>防御：<br>由于这些原因，最好编写防御性指令，这样即使失败了，也不会留下损坏的目标。通常，这些指令会创建临时文件，而不是直接更新目标，然后将临时文件重命名为最终的目标名称。有些编译器已经采用了这种方式，因此您不需要编写防御性指令。</p>
</li>
</ul>
<h4 id="递归；指令中调用makefiles-通过make"><a href="#递归；指令中调用makefiles-通过make" class="headerlink" title="递归；指令中调用makefiles 通过make"></a>递归；指令中调用makefiles 通过make</h4><p>有时候，我们在一个makefile中，编译后，想接着编译其他目录的内容，但是又不想退出重新make，这个时候可以利用makefile中调用make的功能；也叫递归<br>make的递归使用意味着将make作为makefile中的命令使用。当您需要为组成较大系统的各种子系统单独生成文件时，这种技术非常有用。<br>例如，假设您有一个子目录subdir，它有自己的makefile，并且您希望包含目录的makefile在子目录上运行make。你可以这样写<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">        cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br><span class="line">等同于：</span><br><span class="line"><span class="section">subsystem:</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure></p>
<p>结合将目标声明为.PHONY会更有效；<br>为方便起见，当GNU make启动时(在它处理了任何-C选项之后)，它将变量CURDIR设置为当前工作目录的路径名。make不会再碰这个值:<br>特别要注意，如果包含其他目录的文件，CURDIR的值不会改变。<br>这个值与在makefile中设置的值具有相同的优先级(默认情况下，环境变量CURDIR不会覆盖这个值)。注意，设置这个变量对make的操作没有影响(例如，它不会导致make更改其工作目录)。</p>
<ul>
<li>make指令变量如何工作<br>递归的make命令应该总是使用变量make，而不是显式的命令名’ make ‘，如下所示<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">subsystem:</span></span><br><span class="line"><span class="keyword"> </span>       cd <span class="keyword">subdir </span>&amp;&amp; $(MAKE)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该变量的值是调用make时使用的文件名，如果这个文件名是/bin/make，那么执行的配方是’ cd subdir &amp;&amp; /bin/make ‘。如果使用make的特殊版本来运行顶级makefile，则对于递归调用将执行相同的特殊版本。<br>作为一个特殊特性，在规则的指令中使用变量MAKE会改变’ -t ‘(‘——touch ‘)、’ -n ‘(‘——just-print ‘)或’ -q ‘(‘——question ‘)选项的效果。<br>使用MAKE变量的效果与在recipe行开头使用“+”字符的效果相同<br>只有当MAKE变量直接出现在指令中时才启用此特殊特性:如果通过展开另一个变量引用MAKE变量，则不适用此特性。在后一种情况下，您必须使用“+”标记来获得这些特殊效果。</p>
<p>考虑上面示例中的命令’ make -t ‘。(“-t”选项将目标标记为最新，无需实际运行任何指令;看，而不是执行。)遵循’ -t ‘的通常定义，<br>示例中的’ make -t ‘命令将创建一个名为subsystem的文件，不做其他事情。你真正想要做的是运行’ cd subdir &amp;&amp; make -t ‘;但这需要执行指令，而“-t”表示不执行指令。</p>
<p>所以在这种情况下，make做了特殊处理，即在指令中若存在MAKE变量，则，当外部make时传入 -t/ -n/-q时，不传到这里的make ,这样对指令中的make可以正常运行；<br>而其实通常情况下，外部的make带的参数是会传递到这里的；</p>
<ul>
<li>子make之间如何交互 export unexport<br>顶级make的变量值可以通过显式请求通过环境传递给子make，这些变量在子make中定义为默认值，但它们不会覆盖子make使用的makefile中定义的变量，除非你使用’ -e ‘开关。<br>为了传递或导出变量，make将变量及其值添加到环境中，以便运行指令的每一行。子make依次使用环境来初始化其变量值表。<br>除非是通过显式请求，否则只有在环境中初始定义或在命令行中设置了导出变量，并且它的名称仅由字母、数字和下划线组成时，才可以将导出设置为变量。有些shell不能处理由字母、数字和下划线以外的字符组成的环境变量名。</li>
</ul>
<p>不导出make变量SHELL的值。相反，调用环境中的SHELL变量的值被传递给子make。您可以使用下面描述的export指令强制make为SHELL导出它的值。<br>特殊变量MAKEFLAGS总是被导出(除非您反导出它)。如果您将其设置为任何内容，则会导出MAKEFILES。<br>make通过将在命令行中定义的变量值放入MAKEFLAGS变量中，自动传递这些值。</p>
<p>如果变量是由make默认创建的，那么它们通常不会被传递(参见隐式规则使用的变量)。子make将为自己定义这些。<br>如果你想导出特定的变量到子make中，使用export指令，像这样:<br>export variable …<br>如果你想阻止一个变量被导出，使用unexport指令，像这样<br>unexport variable …<br>在这两种形式中，export和unexport的参数都是展开的，因此可以是展开为要(un)导出的变量名(列表)的变量或函数。<br>为了方便，你可以定义一个变量并同时导出它，方法如下:<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">export <span class="keyword">variable</span> = <span class="keyword">value</span></span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">variable</span> = <span class="keyword">value</span></span><br><span class="line">export <span class="keyword">variable</span></span><br><span class="line">相当于</span><br><span class="line">export <span class="keyword">variable</span> := <span class="keyword">value</span></span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">variable</span> := <span class="keyword">value</span></span><br><span class="line">export <span class="keyword">variable</span></span><br><span class="line">相当于</span><br><span class="line">export <span class="keyword">variable</span> += <span class="keyword">value</span></span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">variable</span> += <span class="keyword">value</span></span><br><span class="line">export <span class="keyword">variable</span></span><br></pre></td></tr></table></figure></p>
<p>您可能会注意到，export和unexport指令在make中的工作方式与它们在shell sh中的工作方式相同。<br>如果你想在默认情况下导出所有变量，你可以单独使用export:<br>export<br>unexport也是类似的效果</p>
<p>关于MAKELEVEL变量:<br>作为一个特殊的特性，变量MAKELEVEL在从一个级别传递到另一个级别时发生了变化。这个变量的值是一个字符串，它以十进制数字表示级别的深度。<br>顶级make的值是’ 0 ‘;sub-make是’ 1 ‘，sub-sub-make是’ 2 ‘，以此类推。当make为配方设置环境时发生增量<br>MAKELEVEL的主要用途是在一个条件指令中测试它(参见Makefiles的条件部分);通过这种方式，您可以编写一个makefile，递归运行时采用一种方式，直接运行时采用另一种方式。</p>
<p>关于MAKEFILES变量<br>您可以使用变量MAKEFILES使所有子make命令使用额外的makefile。MAKEFILES的值是一个以空格分隔的文件名列表。这个变量，如果定义在外部的makefile中，将通过环境传递;然后，它作为额外makefile的列表，供子make在通常的或指定的makefile之前读取。</p>
<ul>
<li>将选项传递给子make<br>像-s,-k这种会直接通过变量MAKEFLAGS传递给子make. 这个变量由make自动设置，以包含make received的标志字母。因此，如果您使用’ make -ks ‘，那么MAKEFLAGS将获得值’ ks ‘。<br>因此，每个子make在它的环境中都会得到MAKEFLAGS的值。作为响应，它从该值中获取标记并处理它们，就像它们被作为参数给出一样。</li>
</ul>
<p>同样，在命令行中定义的变量也通过MAKEFLAGS传递给子make。包含’ = ‘的MAKEFLAGS值中的单词，将处理作为变量定义，就像它们出现在命令行中一样。<br>选项’ -C ‘， ‘ -f ‘， ‘ -o ‘和’ -W ‘不会被放入MAKEFLAGS中;这些选项没有传递下去。<br>‘ -j ‘选项是一种特殊情况(参见并行执行)。如果你将它设置为一些数值’ N ‘并且你的操作系统支持它(大多数UNIX系统都会支持;其他的通常不会)，父make和所有子make将进行通信，以确保它们之间只有“N”个作业同时运行。</p>
<p>如果您的操作系统不支持上述通信，那么没有’ -j ‘添加到MAKEFLAGS，以便子make运行在非并行模式<br>如果你不想传递其他标志，你必须改变MAKEFLAGS的值，像这样:<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">subsystem:</span></span><br><span class="line"><span class="keyword"> </span>       cd <span class="keyword">subdir </span>&amp;&amp; $(MAKE) MAKEFLAGS=</span><br></pre></td></tr></table></figure></p>
<p>命令行变量定义实际出现在变量MAKEOVERRIDES中，并且MAKEFLAGS包含对该变量的引用。如果你想正常传递标志，但不想传递命令行变量定义，你可以重置MAKEOVERRIDES为空，像这样:<br>MAKEOVERRIDES =<br>这样做通常是没有用的。然而，一些系统对环境的大小有一个很小的固定限制，将如此多的信息放入MAKEFLAGS的值中可能会超过这个限制。</p>
<p>为了历史兼容性，也存在一个类似的变量MFLAGS。它有相同的值作为MAKEFLAGS除了它不包含命令行变量定义,它总是开始于一个连字符,除非它是空的(MAKEFLAGS以连字符开始只有当它开始于一个选项,<br>没有单字符版本,如“——warn-undefined-variables”)。MFLAGS传统上是在递归的make命令中显式使用的，像这样:<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">        cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> <span class="variable">$(MFLAGS)</span></span><br></pre></td></tr></table></figure></p>
<p>如果您希望拥有某些选项，比如在每次运行make时设置’ -k ‘(请参阅选项摘要)，那么MAKEFLAGS变量也很有用。您只需将MAKEFLAGS的值放入您的环境中。您还可以在makefile中设置MAKEFLAGS，<br>以指定对该makefile也有效的附加标志。(注意你不能这样使用MFLAGS。设置该变量只是为了兼容;make不会以任何方式解释你为它设置的值。)<br>…</p>
<ul>
<li>打印目录的指令<br>如果您使用多个层次的递归make调用，则’ -w ‘或’——print-directory ‘选项可以使输出更容易理解，<br>因为它将每个目录显示为make开始处理它和make完成处理它。例如，如果’ make -w ‘在目录/u/gnu/make中运行，make将打印下面的一行:<br>make: Entering directory `/u/gnu/make’.<br>before doing anything else, and a line of the form:</li>
</ul>
<p>make: Leaving directory `/u/gnu/make’.<br>when processing is completed.<br>通常，你不需要指定这个选项，因为’ make ‘会替你指定:当你使用’ -C ‘选项时，’ -w ‘会自动打开，在子make中也是如此。make不会自动打开’ -w ‘，如果你也使用’ -s ‘，它表示静默，或者如果你使用’——no-print-directory ‘来显式禁用它。</p>
<h4 id="定义指令集"><a href="#定义指令集" class="headerlink" title="定义指令集"></a>定义指令集</h4><p>当相同的命令序列在创建各种目标时有用时，可以使用define指令将其定义为固定序列，并从这些目标的配方中引用固定序列。这个固定序列实际上是一个变量，所以这个名称不能与其他变量名称冲突。<br>例如：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc =</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure></p>
<p>这里，run-yacc是被定义的变量的名称;endef表示定义的结束;中间的行是命令。define指令不会以固定的顺序展开变量引用和函数调用;’ $ ‘字符、圆括号、变量名等等都成为要定义的变量值的一部分。<br>要使用固定序列，请将变量替换到规则的指令中。您可以像替换其他变量一样替换它(。因为define定义的变量是递归展开的变量，所以在define中编写的所有变量引用现在都展开了。例如:<br>foo.c : foo.y<br>        $(run-yacc)<br>当变量“ $ ^”以run-yacc的值出现时，“ foo.y”将被替换，变量“ $ @”将被“ foo.c”替换。</p>
<h4 id="定义有用的没，没做任何事的指令；"><a href="#定义有用的没，没做任何事的指令；" class="headerlink" title="定义有用的没，没做任何事的指令；"></a>定义有用的没，没做任何事的指令；</h4><p>有时定义不做任何事情的指令是很有用的。这可以通过提供一个只包含空格的指令来实现。例如:<br>target: ;<br>这样做的一个原因是防止目标获取隐式指令规则<br>空的指令也可以用来避免错误为目标创建另一个指令的副作用:如果目标不存在空配方确保让不会抱怨不知道如何建立目标,并使假设目标是过时了。</p>
<h3 id="如何使用变量"><a href="#如何使用变量" class="headerlink" title="如何使用变量"></a>如何使用变量</h3><p>一个变量是一个定义在makefile中用来表示一个文本中的字符串的名字，这个字符串是变量的值；<br>这些变量是可以被显示替换目标，依赖和指令，以及makefile中的其他部分；在其他版本的makefile中也叫宏；<br>makefile中所有部分的变量和函数在读取时都是展开的，除了在recipes中，变量定义的右边使用’ = ‘，变量定义的主体使用define指令。<br>变量可以表示文件名列表、传递给编译器的选项、要运行的程序、要查找源文件的目录、要写入输出的目录，或者您可以想象的任何其他内容。</p>
<p>变量名可以是不包含’:’、’ # ‘、’ = ‘或空格的任意字符序列。然而，包含字母、数字和下划线以外的字符的变量名应该仔细考虑，因为在某些shell中，它们不能通过环境传递给子make(请参阅通信变量到子make)。<br>变量名以`开头。在未来的make版本中，大写字母可能会被赋予特殊的含义。<br>变量名区分大小写。名字’ foo ‘， ‘ foo ‘和’ foo ‘都指不同的变量。<br>传统使用大写字母的变量名,但我们建议使用小写字母的变量名内部用途的makefile,并保留大写参数控制隐性规则或命令选项的参数,用户应该覆盖(见最重要的变量)。<br>一些变量的名称可以是单个标点字符，也可以是几个字符。这些是自动变量，它们有特殊的用途。看到自动变量。</p>
<h4 id="如何使用变量的值"><a href="#如何使用变量的值" class="headerlink" title="如何使用变量的值"></a>如何使用变量的值</h4><p>通过$符号可以引用变量的值，用两种方式： $(foo)或${foo},如果要用包含$字符，需要用两个$;<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">objects = <span class="function"><span class="keyword">program</span>.<span class="title">o</span></span> foo.o utils.o</span><br><span class="line"><span class="function"><span class="keyword">program</span></span> : $(objects)</span><br><span class="line">        cc -o <span class="function"><span class="keyword">program</span></span> $(objects)</span><br><span class="line"></span><br><span class="line">$(objects) : defs.h</span><br></pre></td></tr></table></figure></p>
<p>变量按严格的文本替换：<br><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">foo = c</span><br><span class="line">prog.o : prog.$<span class="comment">(foo)</span></span><br><span class="line">        $<span class="comment">(foo)</span>$<span class="comment">(foo)</span> -$<span class="comment">(foo)</span> prog.$<span class="comment">(foo)</span></span><br><span class="line">可以用来编译一个C程序。因为在变量赋值时变量值前面的空格会被忽略，所以foo的值就是<span class="string">' c '</span>。<span class="comment">(不要这样写你的makefile !)</span></span><br></pre></td></tr></table></figure></p>
<p>一个美元符号后面跟着一个不是美元符号、开括号或开括号的字符作为变量名。因此，你可以用’ $x ‘引用变量x。然而，这种做法可能会导致混淆(例如，’ $foo ‘指的是变量f后面跟着字符串oo)，所以我们建议在所有变量周围使用圆括号或大括号，<br>即使是单字母的变量，除非省略它们可以显著提高可读性。可读性经常得到提高的一个地方是自动变量(参见自动变量)。</p>
<h4 id="两种赋值变量的方式："><a href="#两种赋值变量的方式：" class="headerlink" title="两种赋值变量的方式： = /:="></a>两种赋值变量的方式： = /:=</h4><p>= 原封不动的拷贝，可以进行递归赋值，如：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:;echo <span class="variable">$(foo)</span></span></span><br></pre></td></tr></table></figure></p>
<p>所以可以这样使用：这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = <span class="variable">$(include_dirs)</span> -O</span><br><span class="line">include_dirs = -Ifoo -Ibar</span><br><span class="line">但是一下这种方式会导致无穷递归：</span><br><span class="line">CFLAGS = <span class="variable">$(CFLAGS)</span> -O </span><br><span class="line">make会上报错误</span><br><span class="line">另一个缺点是，另一个缺点是，定义中引用的任何函数都将在每次扩展变量时执行。</span><br><span class="line">这使得make跑得更慢;更糟糕的是，它会导致通配符和shell函数给出不可预知的结果，因为您无法轻松控制何时调用它们，甚至调用多少次。所以不要这么做；</span><br></pre></td></tr></table></figure></p>
<ul>
<li>另一种：”:=”<br>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是 := 操作符，如：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br><span class="line">其等价于：</span><br><span class="line"></span><br><span class="line">y := foo bar</span><br><span class="line">x := later</span><br><span class="line">值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：</span><br><span class="line"></span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := foo</span><br><span class="line">那么，y的值是“bar”，而不是“foo bar”。</span><br><span class="line">下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</span><br><span class="line"></span><br><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br><span class="line">nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“<span class="comment">#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</span></span><br><span class="line"></span><br><span class="line">dir := /foo/bar    <span class="comment"># directory to put the frobs in</span></span><br><span class="line">dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“<span class="variable">$(dir)</span>/file”那么就完蛋了。</span><br><span class="line"></span><br><span class="line">还有一个比较有用的操作符是 ?= ，先看示例：</span><br><span class="line"></span><br><span class="line">FOO ?= bar</span><br><span class="line">其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> FOO)</span>, undefined)</span><br><span class="line">    FOO = bar</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="引用一个变量的高级特性"><a href="#引用一个变量的高级特性" class="headerlink" title="引用一个变量的高级特性"></a>引用一个变量的高级特性</h4><h5 id="变量值的替换"><a href="#变量值的替换" class="headerlink" title="变量值的替换"></a>变量值的替换</h5><p>们可以替换变量中的共有的部分，其格式是 $(var:a=b) 或是 ${var:a=b} ，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</p>
<p>还是看一个示例吧：<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">foo := a.o b.o <span class="keyword">c</span>.o</span><br><span class="line">bar := $(foo:.o=.<span class="keyword">c</span>)</span><br><span class="line">这个示例中，我们先定义了一个 $(foo) 变量，而第二行的意思是把 $(foo) 中所有以 .o 字串“结尾”全部替换成 .<span class="keyword">c</span> ，所以我们的 $(bar) 的值就是“a.<span class="keyword">c</span> b.<span class="keyword">c</span> <span class="keyword">c</span>.<span class="keyword">c</span>”。</span><br><span class="line"></span><br><span class="line">另外一种变量替换的技术是以“静态模式”，如：</span><br><span class="line"></span><br><span class="line">foo := a.o b.o <span class="keyword">c</span>.o</span><br><span class="line">bar := $(foo:<span class="symbol">%.o</span>=<span class="symbol">%.c</span>)</span><br><span class="line">这依赖于被替换字串中的有相同的模式，模式中必须包含一个 % 字符，这个例子同样让 $(bar) 变量的值为“a.<span class="keyword">c</span> b.<span class="keyword">c</span> <span class="keyword">c</span>.<span class="keyword">c</span>”。</span><br></pre></td></tr></table></figure></p>
<h5 id="把变量的值再当成变量"><a href="#把变量的值再当成变量" class="headerlink" title="把变量的值再当成变量"></a>把变量的值再当成变量</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br><span class="line">在这个例子中，<span class="variable">$(x)</span>的值是“y”，所以$(<span class="variable">$(x)</span>)就是<span class="variable">$(y)</span>，于是<span class="variable">$(a)</span>的值就是“z”。（注意，是“x=y”，而不是“x=<span class="variable">$(y)</span>”）</span><br><span class="line"></span><br><span class="line">我们还可以使用更多的层次：</span><br><span class="line"></span><br><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">z = u</span><br><span class="line">a := $($(<span class="variable">$(x)</span>))</span><br><span class="line">这里的 <span class="variable">$(a)</span> 的值是“u”，相关的推导留给读者自己去做吧。</span><br><span class="line"></span><br><span class="line">让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：</span><br><span class="line"></span><br><span class="line">x = <span class="variable">$(y)</span></span><br><span class="line">y = z</span><br><span class="line">z = Hello</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br><span class="line">这里的 $(<span class="variable">$(x)</span>) 被替换成了 $(<span class="variable">$(y)</span>) ，因为 <span class="variable">$(y)</span> 值是“z”，所以，最终结果是： a:=<span class="variable">$(z)</span> ，也就是“Hello”。</span><br><span class="line"></span><br><span class="line">再复杂一点，我们再加上函数：</span><br><span class="line"></span><br><span class="line">x = variable1</span><br><span class="line">variable2 := Hello</span><br><span class="line">y = <span class="variable">$(<span class="built_in">subst</span> 1,2,<span class="variable">$(x)</span>)</span></span><br><span class="line">z = y</span><br><span class="line">a := $($(<span class="variable">$(z)</span>))</span><br><span class="line">这个例子中， $($(<span class="variable">$(z)</span>)) 扩展为 $(<span class="variable">$(y)</span>) ，而其再次被扩展为 $(<span class="variable">$(<span class="built_in">subst</span> 1,2,<span class="variable">$(x)</span>)</span>) 。 <span class="variable">$(x)</span> 的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成 “variable2”，再取其值，所以，最终， <span class="variable">$(a)</span> 的值就是 <span class="variable">$(variable2)</span> 的值——“Hello”。（喔，好不容易）</span><br><span class="line"></span><br><span class="line">在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：</span><br><span class="line"></span><br><span class="line">first_second = Hello</span><br><span class="line">a = first</span><br><span class="line">b = second</span><br><span class="line">all = $($a_$b)</span><br><span class="line">这里的 $a_$b 组成了“first_second”，于是， <span class="variable">$(all)</span> 的值就是“Hello”。</span><br><span class="line"></span><br><span class="line">再来看看结合第一种技术的例子：</span><br><span class="line"></span><br><span class="line">a_objects := a.o b.o c.o</span><br><span class="line">1_objects := 1.o 2.o 3.o</span><br><span class="line"></span><br><span class="line">sources := $(<span class="variable">$(a1)</span>_objects:.o=.c)</span><br><span class="line">这个例子中，如果 <span class="variable">$(a1)</span> 的值是“a”的话，那么， <span class="variable">$(sources)</span> 的值就是“a.c b.c c.c”；如果 <span class="variable">$(a1)</span> 的值是“1”，那么 <span class="variable">$(sources)</span> 的值是“1.c 2.c 3.c”。</span><br><span class="line"></span><br><span class="line">再来看一个这种技术和“函数”与“条件语句”一同使用的例子：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> do_sort</span><br><span class="line">    func := sort</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    func := strip</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">bar := a d b g q c</span><br><span class="line"></span><br><span class="line">foo := $(<span class="variable">$(func)</span> <span class="variable">$(bar)</span>)</span><br><span class="line">这个示例中，如果定义了“do_sort”，那么： foo := <span class="variable">$(<span class="built_in">sort</span> a d b g q c)</span> ，于是 <span class="variable">$(foo)</span> 的值就是 “a b c d g q”，而如果没有定义“do_sort”，那么： foo := <span class="variable">$(<span class="built_in">strip</span> a d b g q c)</span> ，调用的就是strip函数。</span><br><span class="line"></span><br><span class="line"><span class="section">当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边:</span></span><br><span class="line"></span><br><span class="line">dir = foo</span><br><span class="line"><span class="variable">$(dir)</span>_sources := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span></span><br><span class="line"><span class="keyword">define</span> <span class="variable">$(dir)</span>_print</span><br><span class="line">lpr $(<span class="variable">$(dir)</span>_sources)</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line">这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。</span><br></pre></td></tr></table></figure>
<h4 id="如何在一个变量中基于旧值添加更多内容–追加"><a href="#如何在一个变量中基于旧值添加更多内容–追加" class="headerlink" title="如何在一个变量中基于旧值添加更多内容–追加"></a>如何在一个变量中基于旧值添加更多内容–追加</h4><p>+=<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">objects += another.o</span><br><span class="line">一个例子： </span><br><span class="line">objects = main<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span> utils.o</span><br><span class="line">objects += another.o</span><br><span class="line">则objects为：</span><br><span class="line">main<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span> utils<span class="selector-class">.o</span> another.o</span><br><span class="line">效果相当于：</span><br><span class="line">objects = main<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span> utils.o</span><br><span class="line">objects := $(objects) another.o</span><br><span class="line">如果变量之前没有定义过，那么， += 会自动变成 = ，如果前面有变量定义，那么 += 会继承于前次操作的赋值符。如果前一次的是 := ，那么 += 会以 := 作为其赋值符，如：</span><br><span class="line"></span><br><span class="line">variable := value</span><br><span class="line">variable += more</span><br><span class="line">等价于：</span><br><span class="line"></span><br><span class="line">variable := value</span><br><span class="line">variable := $(variable) more</span><br><span class="line">但如果是这种情况：</span><br><span class="line"></span><br><span class="line">variable = value</span><br><span class="line">variable += more</span><br><span class="line">由于前次的赋值符是 = ，所以 += 也会以 = 来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</span><br></pre></td></tr></table></figure></p>
<h4 id="如何在makefile中设置一个变量，即使之前已经被设置；"><a href="#如何在makefile中设置一个变量，即使之前已经被设置；" class="headerlink" title="如何在makefile中设置一个变量，即使之前已经被设置；"></a>如何在makefile中设置一个变量，即使之前已经被设置；</h4><p>如果有变量是通过make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">override <span class="tag">&lt;<span class="name">variable</span>&gt;</span>; = <span class="tag">&lt;<span class="name">value</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line">override <span class="tag">&lt;<span class="name">variable</span>&gt;</span>; := <span class="tag">&lt;<span class="name">value</span>&gt;</span>;</span><br></pre></td></tr></table></figure></p>
<p>当然，你还可以追加:</p>
<p>override <variable>; += <more text="">;<br>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用override指示符，如:<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">define</span> foo</span><br><span class="line">bar</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure></more></variable></p>
<h4 id="一个设置多行字符串变量的可选方式"><a href="#一个设置多行字符串变量的可选方式" class="headerlink" title="一个设置多行字符串变量的可选方式"></a>一个设置多行字符串变量的可选方式</h4><p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。</p>
<p>define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束。其工作方式和“=”操作符一样。<br>变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以 Tab 键开头，那么make 就不会把其认为是命令。</p>
<p>下面的这个示例展示了define的用法:<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">define <span class="literal">two</span>-<span class="keyword">lines</span></span><br><span class="line">echo foo</span><br><span class="line">echo $(bar)</span><br><span class="line">endef</span><br><span class="line">When used <span class="keyword">in</span> <span class="keyword">a</span> recipe, <span class="keyword">the</span> previous example is functionally equivalent <span class="built_in">to</span> this:</span><br><span class="line"></span><br><span class="line"><span class="literal">two</span>-<span class="keyword">lines</span> = echo foo; echo $(bar)</span><br></pre></td></tr></table></figure></p>
<h4 id="如何去定义一个变量，使它未被赋值"><a href="#如何去定义一个变量，使它未被赋值" class="headerlink" title="如何去定义一个变量，使它未被赋值"></a>如何去定义一个变量，使它未被赋值</h4><p>如果要清除一个变量，通常将其值设置为空就足够了。展开这样的变量将产生相同的结果(空字符串)，而不管它是否被设置。但是，如果您正在使用flavor(参见flavor函数)和origin(参见origin函数)函数，<br>则从未设置的变量和空值的变量之间存在差异。在这种情况下，你可能想要使用undefine指令使一个变量看起来像从未设置过一样。例如:<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo := foo</span><br><span class="line">bar = bar</span><br><span class="line"></span><br><span class="line"><span class="keyword">undefine</span> foo</span><br><span class="line"><span class="keyword">undefine</span> bar</span><br><span class="line"></span><br><span class="line"><span class="variable">$(info $(<span class="built_in">origin</span> foo)</span>)</span><br><span class="line"><span class="variable">$(info $(<span class="built_in">flavor</span> bar)</span>)</span><br><span class="line">This example will print “undefined” for both variables.</span><br><span class="line">如果你想取消命令行变量定义，你可以使用<span class="keyword">override</span>指令和<span class="keyword">undefine</span>，类似于变量定义</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">undefine</span> CFLAGS</span><br></pre></td></tr></table></figure></p>
<h4 id="来自环境的变量值；"><a href="#来自环境的变量值；" class="headerlink" title="来自环境的变量值；"></a>来自环境的变量值；</h4><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了 CFLAGS 环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。</p>
<p>当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p>
<p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>
<h4 id="变量值可以在每个目标的基础上定义"><a href="#变量值可以在每个目标的基础上定义" class="headerlink" title="变量值可以在每个目标的基础上定义"></a>变量值可以在每个目标的基础上定义</h4><p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如 $&lt; 等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我也同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：<br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">&lt;target <span class="params">...</span>&gt; : &lt;<span class="built_in">variable</span><span class="params">-assignment</span>&gt;;</span><br><span class="line"></span><br><span class="line">&lt;target <span class="params">...</span>&gt; : overide &lt;<span class="built_in">variable</span><span class="params">-assignment</span>&gt;</span><br><span class="line">&lt;<span class="built_in">variable</span><span class="params">-assignment</span>&gt;;可以是前面讲过的各种赋值表达式，如 = 、 := 、 += <span class="string">``</span> 或是 <span class="string">``</span>?= 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</span><br></pre></td></tr></table></figure></p>
<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar.o</span><br><span class="line">    $(CC) $(CFLAGS) prog<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar.o</span><br><span class="line"></span><br><span class="line">prog<span class="selector-class">.o</span> : prog.c</span><br><span class="line">    $(CC) $(CFLAGS) prog.c</span><br><span class="line"></span><br><span class="line">foo<span class="selector-class">.o</span> : foo.c</span><br><span class="line">    $(CC) $(CFLAGS) foo.c</span><br><span class="line"></span><br><span class="line">bar<span class="selector-class">.o</span> : bar.c</span><br><span class="line">    $(CC) $(CFLAGS) bar.c</span><br><span class="line">在这个示例中，不管全局的 $(CFLAGS) 的值是什么，在prog目标，以及其所引发的所有规则中（prog<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar.o的规则）， $(CFLAGS) 的值都是 -g</span><br></pre></td></tr></table></figure></p>
<h4 id="特定于目标的变量值可以应用于匹配模式的一组目标。"><a href="#特定于目标的变量值可以应用于匹配模式的一组目标。" class="headerlink" title="特定于目标的变量值可以应用于匹配模式的一组目标。"></a>特定于目标的变量值可以应用于匹配模式的一组目标。</h4><p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的“模式”一般是至少含有一个 % 的，所以，我们可以以如下方式给所有以 .o 结尾的目标定义目标变量：<br>%.o : CFLAGS = -O<br>同样，模式变量的语法和“目标变量”一样：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pattern</span> <span class="attr">...</span>&gt;</span>; : <span class="tag">&lt;<span class="name">variable-assignment</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span> <span class="attr">...</span>&gt;</span>; : override <span class="tag">&lt;<span class="name">variable-assignment</span>&gt;</span>;</span><br><span class="line">override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</span><br></pre></td></tr></table></figure></p>
<h4 id="抑制变量的继承"><a href="#抑制变量的继承" class="headerlink" title="抑制变量的继承"></a>抑制变量的继承</h4><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">EXTRA_CFLAGS =</span><br><span class="line"></span><br><span class="line"><span class="symbol">prog:</span> <span class="keyword">private</span> EXTRA_CFLAGS = -L/usr/local/<span class="class"><span class="keyword">lib</span></span></span><br><span class="line"><span class="symbol">prog:</span> a.o b.o</span><br></pre></td></tr></table></figure>
<p>由于private修饰符，a.o和b.o不会从prog目标继承EXTRA_CFLAGS变量赋值。</p>
<h4 id="具有特殊意义或行为的变量。"><a href="#具有特殊意义或行为的变量。" class="headerlink" title="具有特殊意义或行为的变量。"></a>具有特殊意义或行为的变量。</h4><p>.VARIABLES<br>。。。</p>
<h3 id="如何使用条件语句"><a href="#如何使用条件语句" class="headerlink" title="如何使用条件语句"></a>如何使用条件语句</h3><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h4 id="条件例子"><a href="#条件例子" class="headerlink" title="条件例子"></a>条件例子</h4><p>下面的例子，判断 $(CC) 变量是否 gcc ，如果是的话，则使用GNU函数编译目标。<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<p>可见，在上面示例的这个规则中，目标 foo 可以根据变量 $(CC) 值来选取不同的函数库来编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字： ifeq 、 else 和 endif 。 ifeq 的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。 else 表示条件表达式为假的情况。 endif 表示一个条件语句的结束，任何一个条件表达式都应该以 endif 结束。</p>
<p>当我们的变量 $(CC) 值是 gcc 时，目标 foo 的规则是：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line">而当我们的变量 <span class="variable">$(CC)</span> 值不是 gcc 时（比如 cc ），目标 foo 的规则是：</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line">当然，我们还可以把上面的那个例子写得更简洁一些：</span><br><span class="line"></span><br><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="条件的语法"><a href="#条件的语法" class="headerlink" title="条件的语法"></a>条件的语法</h4><p>条件表达式的语法为:<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;<span class="built_in">text</span>-<span class="keyword">if</span>-<span class="literal">true</span>&gt;</span><br><span class="line">endif</span><br><span class="line">以及:</span><br><span class="line"></span><br><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;<span class="built_in">text</span>-<span class="keyword">if</span>-<span class="literal">true</span>&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&lt;<span class="built_in">text</span>-<span class="keyword">if</span>-<span class="literal">false</span>&gt;</span><br><span class="line">endif</span><br><span class="line">其中 &lt;conditional-directive&gt; 表示条件关键字，如 ifeq 。这个关键字有四个。</span><br></pre></td></tr></table></figure></p>
<p>第一个是我们前面所见过的 ifeq<br><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">ife<span class="string">q (&lt;arg1&gt;, &lt;arg2&gt;)</span></span><br><span class="line">ifeq <span class="string">'&lt;arg1&gt;'</span> <span class="string">'&lt;arg2&gt;'</span></span><br><span class="line">ifeq <span class="string">"&lt;arg1&gt;"</span> <span class="string">"&lt;arg2&gt;"</span></span><br><span class="line">ifeq <span class="string">"&lt;arg1&gt;"</span> <span class="string">'&lt;arg2&gt;'</span></span><br><span class="line">ifeq <span class="string">'&lt;arg1&gt;'</span> <span class="string">"&lt;arg2&gt;"</span></span><br><span class="line">比较参数 arg1 和 arg2 的值是否相同。当然，参数中我们还可以使用make的函数。如:</span><br><span class="line"></span><br><span class="line">ife<span class="string">q ($(strip $(foo)</span>),)</span><br><span class="line">&lt;text-<span class="keyword">if</span>-empty&gt;</span><br><span class="line">endif</span><br><span class="line">这个示例中使用了 strip 函数，如果这个函数的返回值是空（Empty），那么 &lt;text-<span class="keyword">if</span>-empty&gt; 就生效。</span><br></pre></td></tr></table></figure></p>
<p>第二个条件关键字是 ifneq 。语法是：<br><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">ifne<span class="string">q (&lt;arg1&gt;, &lt;arg2&gt;)</span></span><br><span class="line">ifneq <span class="string">'&lt;arg1&gt;'</span> <span class="string">'&lt;arg2&gt;'</span></span><br><span class="line">ifneq <span class="string">"&lt;arg1&gt;"</span> <span class="string">"&lt;arg2&gt;"</span></span><br><span class="line">ifneq <span class="string">"&lt;arg1&gt;"</span> <span class="string">'&lt;arg2&gt;'</span></span><br><span class="line">ifneq <span class="string">'&lt;arg1&gt;'</span> <span class="string">"&lt;arg2&gt;"</span></span><br><span class="line">其比较参数 arg1 和 arg2 的值是否相同，如果不同，则为真。和 ifeq 类似。</span><br></pre></td></tr></table></figure></p>
<p>第三个条件关键字是 ifdef 。语法是：</p>
<p>ifdef <variable-name><br>如果变量 <variable-name> 的值非空，那到表达式为真。否则，表达式为假。当然， <variable-name> 同样可以是一个函数的返回值。注意， ifdef 只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</variable-name></variable-name></variable-name></p>
<p>示例一：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">示例二：</span><br><span class="line"></span><br><span class="line">foo =</span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<p>第一个例子中， $(frobozz) 值是 yes ，第二个则是 no。</p>
<p>第四个条件关键字是 ifndef 。其语法是：<br><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">ifndef <span class="params">&lt;variable-name&gt;</span></span><br><span class="line">这个我就不多说了，和 ifdef 是相反的意思。</span><br><span class="line"></span><br><span class="line">在 <span class="params">&lt;conditional-directive&gt;</span> 这一行上，多余的空格是被允许的，但是不能以 Tab 键作为开始（不然就被认为是命令）。而注释符 <span class="meta"># 同样也是安全的。 <span class="meta-keyword">else</span> 和 <span class="meta-keyword">endif</span> 也一样，只要不是以 Tab 键开始就行了。</span></span><br></pre></td></tr></table></figure></p>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如 $@ 等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<p>而且为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h4 id="测试标志"><a href="#测试标志" class="headerlink" title="测试标志"></a>测试标志</h4><p>TODO</p>
<h3 id="如何使用函数"><a href="#如何使用函数" class="headerlink" title="如何使用函数"></a>如何使用函数</h3><p>函数允许您在makefile中进行文本处理，以计算要操作的文件或在指令中使用的命令。<br>在函数调用中使用函数，其中提供函数的名称和一些文本(参数)供函数操作。函数处理的结果在调用时被替换到makefile中，就像变量可能被替换一样。</p>
<h4 id="函数的语法，如何写一个函数调用"><a href="#函数的语法，如何写一个函数调用" class="headerlink" title="函数的语法，如何写一个函数调用"></a>函数的语法，如何写一个函数调用</h4><p>函数调用类似于变量引用。它可以出现在变量引用可能出现的任何地方，并且使用与变量引用相同的规则展开它。函数调用是这样的:<br>$(function arguments)<br>或<br>${function arguments}<br>这里的function是指一个函数名，一部分是make中的，你也可以通过call关键字自己创建函数，<arguments> 为函数的参数，参数间以逗号 , 分隔，而函数名和参数之间以“空格”分隔。<br>函数调用以 $ 开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？<br>函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用 $(subst a,b,$(x)) 这样的形式，而不是 $(subst a,b, ${x}) 的形式。</arguments></p>
<p>通过替换变量和函数调用来处理为每个参数编写的文本，以生成参数值，该参数值是函数作用的文本。替换按参数出现的顺序进行。<br>逗号和不匹配的括号或大括号不能像所写的那样出现在参数的文本中;前导空格不能像所写的那样出现在第一个参数的文本中。可以通过变量替换将这些字符放入参数值中。<br>首先定义变量逗号和空格，它们的值是孤立的逗号和空格字符，然后在需要这些字符的地方替换这些变量，像这样:<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br><span class="line"><span class="comment"># bar is now ‘a,b,c’.</span></span><br></pre></td></tr></table></figure></p>
<p>这里，subst函数通过foo的值用逗号替换每个空格，并替换结果</p>
<h4 id="Functions-for-String-Substitution-and-Analysis-字符串操作函数列表"><a href="#Functions-for-String-Substitution-and-Analysis-字符串操作函数列表" class="headerlink" title="Functions for String Substitution and Analysis  字符串操作函数列表"></a>Functions for String Substitution and Analysis  字符串操作函数列表</h4><p>字符串处理函数<br>subst<br>$(subst <from>,<to>,<text>)<br>名称：字符串替换函数<br>功能：把字串 <text> 中的 <from> 字符串替换成 <to> 。<br>返回：函数返回被替换过后的字符串。<br>示例：<br>$(subst ee,EE,feet on the street)<br>把 feet on the street 中的 ee 替换成 EE ，返回结果是 fEEt on the strEEt 。</to></from></text></text></to></from></p>
<p>patsubst<br>$(patsubst <pattern>,<replacement>,<text>)<br>名称：模式字符串替换函数。<br>功能：查找 <text> 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式 <pattern> ，如果匹配的话，则以 <replacement> 替换。这里， <pattern> 可以包括通配符 % ，表示任意长度的字串。如果 <replacement> 中也包含 % ，那么， <replacement> 中的这个 % 将是 <pattern> 中的那个 % 所代表的字串。（可以用 \ 来转义，以 \% 来表示真实含义的 % 字符）<br>返回：函数返回被替换过后的字符串。<br>示例：<br>$(patsubst %.c,%.o,x.c.c bar.c)<br>把字串 x.c.c bar.c 符合模式 %.c 的单词替换成 %.o ，返回结果是 x.c.o bar.o<br>备注：这和我们前面“变量章节”说过的相关知识有点相似。如 $(var:<pattern>=<replacement>;) 相当于 $(patsubst <pattern>,<replacement>,$(var)) ，而 $(var: <suffix>=<replacement>) 则相当于 $(patsubst %<suffix>,%<replacement>,$(var)) 。<br>例如有:<br>objects = foo.o bar.o baz.o，<br>那么， $(objects:.o=.c) 和 $(patsubst %.o,%.c,$(objects)) 是一样的。</replacement></suffix></replacement></suffix></replacement></pattern></replacement></pattern></pattern></replacement></replacement></pattern></replacement></pattern></text></text></replacement></pattern></p>
<p>strip<br>$(strip <string>)<br>名称：去空格函数。<br>功能：去掉 <string> 字串中开头和结尾的空字符。<br>返回：返回被去掉空格的字符串值。<br>示例：<br>$(strip a b c )<br>把字串 a b c <code>去到开头和结尾的空格，结果是</code>a b c 。</string></string></p>
<p>findstring<br>$(findstring <find>,<in>)<br>名称：查找字符串函数<br>功能：在字串 <in> 中查找 <find> 字串。<br>返回：如果找到，那么返回 <find> ，否则返回空字符串。<br>示例：<br>$(findstring a,a b c)<br>$(findstring a,b c)<br>第一个函数返回 a 字符串，第二个返回空字符串</find></find></in></in></find></p>
<p>filter<br>$(filter &lt;pattern…&gt;,<text>)<br>名称：过滤函数<br>功能：以 <pattern> 模式过滤 <text> 字符串中的单词，保留符合模式 <pattern> 的单词。可以有多个模式。<br>返回：返回符合模式 <pattern> 的字串。<br>示例：<br>sources := foo.c bar.c baz.s ugh.h<br>foo: $(sources)<br>    cc $(filter %.c %.s,$(sources)) -o foo<br>$(filter %.c %.s,$(sources)) 返回的值是 foo.c bar.c baz.s 。</pattern></pattern></text></pattern></text></p>
<p>filter-out<br>$(filter-out &lt;pattern…&gt;,<text>)<br>名称：反过滤函数<br>功能：以 <pattern> 模式过滤 <text> 字符串中的单词，去除符合模式 <pattern> 的单词。可以有多个模式。<br>返回：返回不符合模式 <pattern> 的字串。<br>示例：<br>objects=main1.o foo.o main2.o bar.o<br>mains=main1.o main2.o<br>$(filter-out $(mains),$(objects)) 返回值是 foo.o bar.o 。</pattern></pattern></text></pattern></text></p>
<p>sort<br>$(sort <list>)<br>名称：排序函数<br>功能：给字符串 <list> 中的单词排序（升序）。<br>返回：返回排序后的字符串。<br>示例： $(sort foo bar lose) 返回 bar foo lose 。<br>备注： sort 函数会去掉 <list> 中相同的单词。</list></list></list></p>
<p>word<br>$(word <n>,<text>)<br>名称：取单词函数<br>功能：取字符串 <text> 中第 <n> 个单词。（从一开始）<br>返回：返回字符串 <text> 中第 <n> 个单词。如果 <n> 比 <text> 中的单词数要大，那么返回空字符串。<br>示例： $(word 2, foo bar baz) 返回值是 bar 。</text></n></n></text></n></text></text></n></p>
<p>wordlist<br>$(wordlist <ss>,<e>,<text>)<br>名称：取单词串函数<br>功能：从字符串 <text> 中取从 <ss> 开始到 <e> 的单词串。 <ss> 和 <e> 是一个数字。<br>返回：返回字符串 <text> 中从 <ss> 到 <e> 的单词字串。如果 <ss> 比 <text> 中的单词数要大，那么返回空字符串。如果 <e> 大于 <text> 的单词数，那么返回从 <ss> 开始，到 <text> 结束的单词串。<br>示例： $(wordlist 2, 3, foo bar baz) 返回值是 bar baz 。</text></ss></text></e></text></ss></e></ss></text></e></ss></e></ss></text></text></e></ss></p>
<p>words<br>$(words <text>)<br>名称：单词个数统计函数<br>功能：统计 <text> 中字符串中的单词个数。<br>返回：返回 <text> 中的单词数。<br>示例： $(words, foo bar baz) 返回值是 3 。<br>备注：如果我们要取 <text> 中最后的一个单词，我们可以这样： $(word $(words <text>),<text>) 。</text></text></text></text></text></text></p>
<p>firstword<br>$(firstword <text>)<br>名称：首单词函数——firstword。<br>功能：取字符串 <text> 中的第一个单词。<br>返回：返回字符串 <text> 的第一个单词。<br>示例： $(firstword foo bar) 返回值是 foo。<br>备注：这个函数可以用 word 函数来实现： $(word 1,<text>) 。<br>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用 VPATH 变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 CFLAGS ，如：</text></text></text></text></p>
<p>override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))<br>如果我们的 $(VPATH) 值是 src:../headers ，那么 $(patsubst %,-I%,$(subst :, ,$(VPATH))) 将返回 -Isrc -I../headers ，这正是cc或gcc搜索头文件路径的参数。</p>
<h4 id="如何用函数操作文件名"><a href="#如何用函数操作文件名" class="headerlink" title="如何用函数操作文件名"></a>如何用函数操作文件名</h4><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p>
<p>dir<br>$(dir &lt;names…&gt;)<br>名称：取目录函数——dir。<br>功能：从文件名序列 <names> 中取出目录部分。目录部分是指最后一个反斜杠（ / ）之前的部分。如果没有反斜杠，那么返回 ./ 。<br>返回：返回文件名序列 <names> 的目录部分。<br>示例： $(dir src/foo.c hacks) 返回值是 src/ ./ 。</names></names></p>
<p>notdir<br>$(notdir &lt;names…&gt;)<br>名称：取文件函数——notdir。<br>功能：从文件名序列 <names> 中取出非目录部分。非目录部分是指最後一个反斜杠（ / ）之后的部分。<br>返回：返回文件名序列 <names> 的非目录部分。<br>示例: $(notdir src/foo.c hacks) 返回值是 foo.c hacks 。</names></names></p>
<p>suffix<br>$(suffix &lt;names…&gt;)<br>名称：取後缀函数——suffix。<br>功能：从文件名序列 <names> 中取出各个文件名的后缀。<br>返回：返回文件名序列 <names> 的后缀序列，如果文件没有后缀，则返回空字串。<br>示例： $(suffix src/foo.c src-1.0/bar.c hacks) 返回值是 .c .c。</names></names></p>
<p>basename<br>$(basename &lt;names…&gt;)<br>名称：取前缀函数——basename。<br>功能：从文件名序列 <names> 中取出各个文件名的前缀部分。<br>返回：返回文件名序列 <names> 的前缀序列，如果文件没有前缀，则返回空字串。<br>示例： $(basename src/foo.c src-1.0/bar.c hacks) 返回值是 src/foo src-1.0/bar hacks 。</names></names></p>
<p>addsuffix<br>$(addsuffix <suffix>,&lt;names…&gt;)<br>名称：加后缀函数——addsuffix。<br>功能：把后缀 <suffix> 加到 <names> 中的每个单词后面。<br>返回：返回加过后缀的文件名序列。<br>示例： $(addsuffix .c,foo bar) 返回值是 foo.c bar.c 。</names></suffix></suffix></p>
<p>addprefix<br>$(addprefix <prefix>,&lt;names…&gt;)<br>名称：加前缀函数——addprefix。<br>功能：把前缀 <prefix> 加到 <names> 中的每个单词后面。<br>返回：返回加过前缀的文件名序列。<br>示例： $(addprefix src/,foo bar) 返回值是 src/foo src/bar 。</names></prefix></prefix></p>
<p>join<br>$(join <list1>,<list2>)<br>名称：连接函数——join。<br>功能：把 <list2> 中的单词对应地加到 <list1> 的单词后面。如果 <list1> 的单词个数要比 <list2> 的多，那么， <list1> 中的多出来的单词将保持原样。如果 <list2> 的单词个数要比 <list1> 多，那么， <list2> 多出来的单词将被复制到 <list1> 中。<br>返回：返回连接过后的字符串。<br>示例： $(join aaa bbb , 111 222 333) 返回值是 aaa111 bbb222 333 。</list1></list2></list1></list2></list1></list2></list1></list1></list2></list2></list1></p>
<p>wildcard<br>$(wildcard pattern)<br>参数模式是一个文件名模式，通常包含通配符(如shell文件名模式)。通配符的结果是一个与模式匹配的现有文件名称的以空格分隔的列表。<br>eg:<br>objects := $(wildcard *.o)</p>
<p>realpath<br>$(realpath names…)<br>对于names中的每个文件名，返回规范的绝对名称。规范名称不包含任何内容。或. .组件，或任何重复路径分隔符(/)或符号链接。如果失败，则返回空字符串。</p>
<p>abspath<br>$(abspath names…)<br>对于names中的每个文件名，返回一个不包含任何内容的绝对名称。或. .组件，或任何重复路径分隔符(/)。<br>注意，与realpath函数不同，abspath不解析符号链接，也不要求文件名引用现有的文件或目录。使用通配符函数来测试是否存在。</p>
<h4 id="实现条件的函数"><a href="#实现条件的函数" class="headerlink" title="实现条件的函数"></a>实现条件的函数</h4><p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">if</span> &lt;condition&gt;,&lt;<span class="keyword">then</span>-<span class="built_in">part</span>&gt;)</span><br><span class="line">或是</span><br><span class="line"></span><br><span class="line">$(<span class="keyword">if</span> &lt;condition&gt;,&lt;<span class="keyword">then</span>-<span class="built_in">part</span>&gt;,&lt;<span class="keyword">else</span>-<span class="built_in">part</span>&gt;)</span><br><span class="line">可见，<span class="keyword">if</span>函数可以包含“<span class="keyword">else</span>”部分，或是不含。即<span class="keyword">if</span>函数的参数可以是两个，也可以是三个。 &lt;condition&gt; 参数是<span class="keyword">if</span>的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是， &lt;<span class="keyword">then</span>-<span class="built_in">part</span>&gt; 会被计算，否则 &lt;<span class="keyword">else</span>-<span class="built_in">part</span>&gt; 会被计算。</span><br></pre></td></tr></table></figure></p>
<p>而if函数的返回值是，如果 <condition> 为真（非空字符串），那个 <then-part> 会是整个函数的返回值，如果 <condition> 为假（空字符串），那么 <else-part> 会是整个函数的返回值，此时如果 <else-part> 没有被定义，那么，整个函数返回空字串。<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">所以， &lt;<span class="keyword">then</span>-part&gt; 和 &lt;<span class="keyword">else</span>-part&gt; 只会有一个被计算。</span><br><span class="line">此外，还有两种形式，少用</span><br><span class="line">$(<span class="keyword">or</span> condition1[,condition2[,condition3…]])</span><br><span class="line"></span><br><span class="line">$(<span class="keyword">and</span> condition1[,condition2[,condition3…]])</span><br></pre></td></tr></table></figure></else-part></else-part></condition></then-part></condition></p>
<h4 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h4><p>foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span><br><span class="line">这个函数的意思是，把参数 &lt;list&gt; 中的单词逐一取出放到参数 &lt;var&gt; 所指定的变量中，然后再执行 &lt;text&gt; 所包含的表达式。每一次 &lt;text&gt; 会返回一个字符串，循环过程中， &lt;text&gt; 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， &lt;text&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</span><br><span class="line"></span><br><span class="line">所以， &lt;var&gt; 最好是一个变量名， &lt;list&gt; 可以是一个表达式，而 &lt;text&gt; 中一般会使用 &lt;var&gt; 这个参数来依次枚举 &lt;list&gt; 中的单词。举个例子：</span><br><span class="line"></span><br><span class="line">names := <span class="selector-tag">a</span> <span class="selector-tag">b</span> c d</span><br><span class="line">files := $(foreach n,$(names),$(n).o)</span><br><span class="line">上面的例子中， $(name) 中的单词会被挨个取出，并存到变量 n 中， $(n)<span class="selector-class">.o</span> 每次根据 $(n) 计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以， $(files) 的值是 <span class="selector-tag">a</span><span class="selector-class">.o</span> <span class="selector-tag">b</span><span class="selector-class">.o</span> c<span class="selector-class">.o</span> d<span class="selector-class">.o</span> 。</span><br></pre></td></tr></table></figure></p>
<p>注意，foreach中的 <var> 参数是一个临时的局部变量，foreach函数执行完后，参数 <var> 的变量将不在作用，其作用域只在foreach函数当中。<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">eg2:</span></span><br><span class="line"></span><br><span class="line">find_files = <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*)</span></span><br><span class="line">dirs := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(dirs)</span>,<span class="variable">$(find_files)</span>)</span></span><br><span class="line">这里我们以这种方式使用变量find_files。我们使用普通的' = '来定义递归展开变量，这样它的值就包含了一个实际的函数调用，在foreach的控制下重新展开;简单展开的变量是不行的，因为通配符只在定义find_files时被调用一次。</span><br><span class="line"></span><br><span class="line">eg3：</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> Esta-escrito-en-espanol!,b c ch,<span class="variable">$(find_files)</span>)</span></span><br></pre></td></tr></table></figure></var></var></p>
<h4 id="文件相关函数：写文本到一个文件中"><a href="#文件相关函数：写文本到一个文件中" class="headerlink" title="文件相关函数：写文本到一个文件中"></a>文件相关函数：写文本到一个文件中</h4><p>file函数允许makefile写出到文件或从文件读取；支持两种模式的写入： 覆盖写，从文件的开始写，覆盖存在的内容；追加，即追加到存在文件的末尾；<br>两种模式都是文件不存在就创建，有一个致命错误就是当文件不能打开去写时，或者写操作失败；当写入文件时，file函数展开为空字符串。<br>从文件中读取时，file函数展开为文件的逐字内容，但最后的换行(如果有的话)将被删除。试图从不存在的文件中读取将展开为空字符串。<br>语法：<br>$(file op filename[,text])<br>当对文件函数求值时，首先展开它的所有参数，然后将以op描述的模式打开由filename指定的文件。<br>运算符op可以是&gt;，表示文件将被新的内容覆盖，&gt;&gt;表示文件的当前内容将被追加，或者&lt;表示文件的内容将被读入。文件名指定要写入或读取的文件。在操作符和文件名之间可以有空格。<br>读取文件时，提供text的值是错误的。<br>当写入文件时，文本text将写入文件。如果文本text还没有以换行符结束，则将写入最后的换行符(即使文本是空字符串)。如果根本没有给出text参数，则不会写入任何内容。<br>eg:<br><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">例如，如果构建系统的命令行大小有限，并且指令运行的命令也可以接受文件中的参数，那么<span class="keyword">file</span>函数就很有用。</span><br><span class="line">许多命令都使用了这样的约定:以@作为参数前缀的参数指定一个包含更多参数的文件。那么你可以这样写你的指令:</span><br><span class="line">program: $(OBJECTS)</span><br><span class="line">        $(<span class="keyword">file</span> &gt;$@.<span class="keyword">in</span>,$^)</span><br><span class="line">        $(CMD) $(CMDFLAGS) @$@.<span class="keyword">in</span></span><br><span class="line">        @rm $@.<span class="keyword">in</span></span><br><span class="line">如果命令要求每个参数在输入文件的单独一行上，您可以这样写您的指令:</span><br><span class="line">program: $(OBJECTS)</span><br><span class="line">        $(<span class="keyword">file</span> &gt;$@.<span class="keyword">in</span>) $(foreach O,$^,$(<span class="keyword">file</span> &gt;&gt;$@.<span class="keyword">in</span>,$O))</span><br><span class="line">        $(CMD) $(CMDFLAGS) @$@.<span class="keyword">in</span></span><br><span class="line">        @rm $@.<span class="keyword">in</span></span><br></pre></td></tr></table></figure></p>
<h4 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h4><p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以call函数来向这个表达式传递参数。其语法是：</p>
<p>$(call <expression>,<parm1>,<parm2>,…,<parmn>)<br>当make执行这个函数时， <expression> 参数中的变量，如 $(1) 、 $(2) 等，会被参数 <parm1> 、 <parm2> 、 <parm3> 依次取代。而 <expression> 的返回值就是 call 函数的返回值。例如：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">reverse =  $(1) $(2)</span><br><span class="line"></span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br><span class="line">那么， foo 的值就是 a b 。当然，参数的次序是可以自定义的，不一定是顺序的，如：</span><br><span class="line"></span><br><span class="line">reverse =  $(2) $(1)</span><br><span class="line"></span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br><span class="line">此时的 foo 的值就是 b a 。</span><br></pre></td></tr></table></figure></expression></parm3></parm2></parm1></expression></parmn></parm2></parm1></expression></p>
<p>需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向call函数提供参数时，最安全的做法是去除所有多余的空格。</p>
<h4 id="value函数"><a href="#value函数" class="headerlink" title="value函数"></a>value函数</h4><p>alue函数提供了一种方法，可以使用变量的值，而不必将其展开。请注意，这不会撤销已经发生的展开;<br>例如，如果您创建了一个简单展开的变量，它的值会在定义过程中展开;在这种情况下，value函数将返回与直接使用变量相同的结果。<br>语法：<br><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">$(value variable)</span><br><span class="line">variables是变量名，不是变量的引用；因此，在写它的时候，你通常不会使用<span class="string">' $ '</span>或圆括号。</span><br><span class="line">（但是，如果你不希望名字是常量，你可以在名字中使用变量引用。）</span><br><span class="line">这个函数的结果是一个包含variable值的字符串，不会发生任何展开。例如，在这个makefile中:</span><br><span class="line">FOO = $PATH</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        @echo $(FOO)</span><br><span class="line">        @echo $(value FOO)</span><br><span class="line">第一行输出将是ATH，因为“$P”将被展开为make变量(假设有)，而第二行输出将是$PATH环境变量的当前值，因为value函数避免了展开。</span><br><span class="line">value函数最常与<span class="keyword">eval</span>函数一起使用(请参阅<span class="keyword">eval</span>函数)。</span><br></pre></td></tr></table></figure></p>
<h4 id="eval函数：Evaluate-the-arguments-as-makefile-syntax"><a href="#eval函数：Evaluate-the-arguments-as-makefile-syntax" class="headerlink" title="eval函数：Evaluate the arguments as makefile syntax"></a>eval函数：Evaluate the arguments as makefile syntax</h4><p>eval函数非常特别，它允许你定义一个新的makefile构造非常规的；<br>这是对其他变量和函数求值的结果。eval函数的参数被展开，然后将展开的结果作为makefile语法进行解析。扩展的结果可以定义新的make变量、目标、隐式或显式规则等。<br>eval函数的结果总是空字符串;因此，它可以放在makefile中的任何位置，而不会导致语法错误。<br>重要的是要意识到eval参数被展开了两次;首先是eval函数，然后在作为makefile语法解析时再次展开该展开的结果。<br>这意味着在使用eval时，可能需要为“$”字符提供额外级别的转义。值value函数有时在这些情况下很有用，可以避免不必要的展开。</p>
<p>下面是如何使用eval的示例;这个示例结合了许多概念和其他函数。尽管在本例中使用eval似乎过于复杂，而不只是写出规则，但要考虑两件事:<br>首先，模板定义(PROGRAM_template中)可能需要比这里复杂得多;<br>其次，您可以将这个示例中复杂的“通用”部分放入另一个makefile中，然后将其包含在所有单独的makefile中。现在，您的单个makefile非常简单。<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PROGRAMS    = server client</span><br><span class="line"></span><br><span class="line">server_OBJS = server.o server_priv.o server_access.o</span><br><span class="line">server_LIBS = priv protocol</span><br><span class="line"></span><br><span class="line">client_OBJS = client.o client_api.o client_mem.o</span><br><span class="line">client_LIBS = protocol</span><br><span class="line"></span><br><span class="line"><span class="comment"># Everything after this is generic</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: <span class="variable">$(PROGRAMS)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> PROGRAM_template =</span><br><span class="line"> $(1): $$($(1)_OBJS) $$($(1)_LIBS:%=-l%)</span><br><span class="line"> ALL_OBJS   += $$($(1)_OBJS)</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> prog,<span class="variable">$(PROGRAMS)</span>,$(<span class="built_in">eval</span> $(<span class="built_in">call</span> PROGRAM_template,<span class="variable">$(prog)</span>)</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable">$(PROGRAMS)</span>:</span><br><span class="line">        $(LINK.o) <span class="variable">$^</span> <span class="variable">$(LDLIBS)</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -f <span class="variable">$(ALL_OBJS)</span> <span class="variable">$(PROGRAMS)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="origin函数：寻找一个变量并拿它的值"><a href="#origin函数：寻找一个变量并拿它的值" class="headerlink" title="origin函数：寻找一个变量并拿它的值"></a>origin函数：寻找一个变量并拿它的值</h4><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span>(origin &lt;<span class="keyword">variable</span>&gt;)</span><br><span class="line">注意， &lt;<span class="keyword">variable</span>&gt; 是变量的名字，不应该是引用。所以你最好不要在 &lt;<span class="keyword">variable</span>&gt; 中使用</span><br><span class="line">$ 字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</span><br><span class="line">undefined</span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 从来没有定义过，origin函数返回这个值 undefined</span><br><span class="line">default</span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</span><br><span class="line">environment</span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 是一个环境变量，并且当Makefile被执行时， -e 参数没有被打开。</span><br><span class="line">file</span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 这个变量被定义在Makefile中。</span><br><span class="line">command <span class="comment">line</span></span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 这个变量是被命令行定义的。</span><br><span class="line">override</span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 是被override指示符重新定义的。</span><br><span class="line">automatic</span><br><span class="line">如果 &lt;<span class="keyword">variable</span>&gt; 是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</span><br><span class="line">这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件 Make.def，在 Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</span><br><span class="line"></span><br><span class="line">ifdef <span class="comment">bletch</span></span><br><span class="line">    ifeq <span class="comment">"$(origin bletch)"</span> <span class="comment">"environment"</span></span><br><span class="line">        bletch <span class="comment">= barf, gag, etc.</span></span><br><span class="line">    endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure></p>
<p>当然，你也许会说，使用 override 关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用 override 是可以达到这样的效果，可是 override 过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的</p>
<h4 id="flavor函数"><a href="#flavor函数" class="headerlink" title="flavor函数"></a>flavor函数</h4><p>flavor函数，像origin函数一样，不作用于变量的值而是告诉你关于变量的一些东西。具体来说，它告诉您变量的特性(<br>语法：<br>$(flavor variable)<br>注意，variable是要查询的变量的名称，而不是对该变量的引用。因此，在写它的时候，你通常不会使用’ $ ‘或圆括号。(不过，如果希望名称不是常量，也可以在名称中使用变量引用。)<br>结果是以下的形式：<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">‘undefined’</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">variable</span> was never defined.</span><br><span class="line"></span><br><span class="line">‘recursive’</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">variable</span> <span class="keyword">is</span> a recursively expanded <span class="keyword">variable</span>.</span><br><span class="line"></span><br><span class="line">‘simple’</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">variable</span> <span class="keyword">is</span> a simply expanded <span class="keyword">variable</span>.</span><br></pre></td></tr></table></figure></p>
<h4 id="控制make运行的函数"><a href="#控制make运行的函数" class="headerlink" title="控制make运行的函数"></a>控制make运行的函数</h4><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> &lt;text ...&gt;)</span></span><br><span class="line">产生一个致命的错误， &lt;text ...&gt; 是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</span><br><span class="line"></span><br><span class="line">示例一：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> ERROR_001</span><br><span class="line">    <span class="variable">$(<span class="built_in">error</span> <span class="built_in">error</span> is <span class="variable">$(ERROR_001)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">示例二：</span><br><span class="line"></span><br><span class="line">ERR = <span class="variable">$(<span class="built_in">error</span> found an <span class="built_in">error</span>!)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: err</span></span><br><span class="line"></span><br><span class="line"><span class="section">err: <span class="variable">$(ERR)</span></span></span><br><span class="line">示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> &lt;text ...&gt;)</span></span><br><span class="line">这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</span><br></pre></td></tr></table></figure></p>
<h4 id="shelll函数"><a href="#shelll函数" class="headerlink" title="shelll函数"></a>shelll函数</h4><p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br><span class="line">files := <span class="variable">$(<span class="built_in">shell</span> echo *.c)</span></span><br></pre></td></tr></table></figure></p>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<h4 id="guile函数"><a href="#guile函数" class="headerlink" title="guile函数"></a>guile函数</h4><p>如果GNU make在构建时支持将GNU Guile作为嵌入式扩展语言，那么Guile函数将可用。guile函数接受一个参数，这个参数首先由make以正常方式展开，然后传递给GNU guile计算器。求值器的结果被转换成一个字符串，并在makefile中用作guile函数的展开。关于在Guile中编写扩展的详细信息，请参阅GNU Guile Integration。<br>你可以通过检查Guile这个词的. .FEATURES变量来决定是否支持GNU Guile。</p>
<h3 id="如何运行make"><a href="#如何运行make" class="headerlink" title="如何运行make"></a>如何运行make</h3><p>makefile的执行，一般是直接make就可以了；make会针对过期的文件重新编译，但是你可能想去只更新部分文件；你可能想使用不同的编译器或者<br>编译器选项；你可能只想找出过期文件而不想更新改变它们；<br>通过运行make的时候给定参数，你可以做下这些事以及许多其他：<br>make的退出状态值总是这三个：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">The <span class="keyword">exit</span> status is zero <span class="keyword">if</span> make is successful.</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line">The <span class="keyword">exit</span> status is two <span class="keyword">if</span> make encounters any errors. It will print messages describing the particular errors.</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line">The <span class="keyword">exit</span> status is one <span class="keyword">if</span> you use the ‘-q’ flag and make determines that some target is not already up to date. </span><br><span class="line">See Instead of Executing Recipes.</span><br></pre></td></tr></table></figure></p>
<h4 id="如何具体化哪个makefile被使用"><a href="#如何具体化哪个makefile被使用" class="headerlink" title="如何具体化哪个makefile被使用"></a>如何具体化哪个makefile被使用</h4><p>使用-f/–file参数：<br>make -f almake / make  –file almake<br>即以almake文件来执行make；<br>如果不指定，则使用默认的文件：GNUmakefile, makefile, and Makefile</p>
<h4 id="Golas"><a href="#Golas" class="headerlink" title="Golas"></a>Golas</h4><p>如何指定生成的目标：默认的，目标是makefile文件中的第一个目标；因此一般makefile文件总是以第一个目标来生成整个程序；<br>如果第一个规则由几个目标，只有第一个目标会是默认目标，而不是整个列表；当然你也可以使用.DEFAULT_GOAL来改变默认目标；<br>也可以通过显性指定make的目标来生成对应的目标：若你指定多个模板，则make会按序执行生成他们；<br>makefile中的任何目标都可以指定为目标(除非它以’ - ‘开头或包含’ = ‘，在这种情况下，它将分别被解析为switch或变量定义)。<br>即使目标不在makefile中也可以指定，如果make可以找到规定如何创建它们的隐式规则的话。<br>Make将特殊变量MAKECMDGOALS设置为您在命令行上指定的目标列表。如果在命令行上没有给出目标，则此变量为空。注意，这个变量应该只在特殊情况下使用。<br>一个合适的例子是，为了避免在clean的时候删除.d 文件；所以make不会仅仅为了立即删除它们而创建它们<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(MAKECMDGOALS)</span>,clean)</span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<p>指定目标的一种用法是只编译程序的一部分，或者只编译几个程序中的一个。将希望重制的每个文件指定为目标。<br>例如，考虑一个包含几个程序的目录，其makefile开头是这样的:<br>.PHONY: all<br>all: size nm ld ar as<br>若你只想生成size，你可以执行make size<br>指定目标的另一种用法可能是，不是常规的生成文件，而是一个文件用于调试信息的输出，或者一个测试版本的生成；<br>指定目标的另一种用法可能是，指定假的目标，比如make clean ;<br>有以下几种类型，直接贴原文：<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">all</span><br><span class="line">Make all <span class="keyword">the</span> top-level targets <span class="keyword">the</span> makefile knows about.</span><br><span class="line"></span><br><span class="line">clean</span><br><span class="line">Delete all <span class="built_in">files</span> that are normally created <span class="keyword">by</span> running make.</span><br><span class="line"></span><br><span class="line">mostlyclean</span><br><span class="line">Like ‘clean’, but may refrain <span class="built_in">from</span> deleting <span class="keyword">a</span> few <span class="built_in">files</span> that people normally don’t want <span class="built_in">to</span> recompile. For example, <span class="keyword">the</span> ‘mostlyclean’ target <span class="keyword">for</span> GCC does <span class="keyword">not</span> <span class="built_in">delete</span> libgcc.<span class="keyword">a</span>, because recompiling <span class="keyword">it</span> is rarely necessary <span class="keyword">and</span> takes <span class="keyword">a</span> lot <span class="keyword">of</span> <span class="built_in">time</span>.</span><br><span class="line"></span><br><span class="line">distclean</span><br><span class="line">realclean</span><br><span class="line">clobber</span><br><span class="line">Any <span class="keyword">of</span> these targets might be defined <span class="built_in">to</span> <span class="built_in">delete</span> more <span class="built_in">files</span> than ‘clean’ does. For example, this would <span class="built_in">delete</span> configuration <span class="built_in">files</span> <span class="keyword">or</span> links that you would normally <span class="built_in">create</span> <span class="keyword">as</span> preparation <span class="keyword">for</span> compilation, even <span class="keyword">if</span> <span class="keyword">the</span> makefile itself cannot <span class="built_in">create</span> these <span class="built_in">files</span>.</span><br><span class="line"></span><br><span class="line">install</span><br><span class="line">Copy <span class="keyword">the</span> executable <span class="built_in">file</span> <span class="keyword">into</span> <span class="keyword">a</span> <span class="built_in">directory</span> that users typically search <span class="keyword">for</span> commands; copy <span class="keyword">any</span> auxiliary <span class="built_in">files</span> that <span class="keyword">the</span> executable uses <span class="keyword">into</span> <span class="keyword">the</span> <span class="built_in">directories</span> where <span class="keyword">it</span> will look <span class="keyword">for</span> them.</span><br><span class="line"></span><br><span class="line">print</span><br><span class="line">Print listings <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">files</span> that have changed.</span><br><span class="line"></span><br><span class="line">tar</span><br><span class="line">Create <span class="keyword">a</span> tar <span class="built_in">file</span> <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">files</span>.</span><br><span class="line"></span><br><span class="line">shar</span><br><span class="line">Create <span class="keyword">a</span> <span class="built_in">shell</span> archive (shar <span class="built_in">file</span>) <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">files</span>.</span><br><span class="line"></span><br><span class="line">dist</span><br><span class="line">Create <span class="keyword">a</span> distribution <span class="built_in">file</span> <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">files</span>. This might be <span class="keyword">a</span> tar <span class="built_in">file</span>, <span class="keyword">or</span> <span class="keyword">a</span> shar <span class="built_in">file</span>, <span class="keyword">or</span> <span class="keyword">a</span> compressed <span class="built_in">version</span> <span class="keyword">of</span> <span class="literal">one</span> <span class="keyword">of</span> <span class="keyword">the</span> above, <span class="keyword">or</span> even more than <span class="literal">one</span> <span class="keyword">of</span> <span class="keyword">the</span> above.</span><br><span class="line"></span><br><span class="line">TAGS</span><br><span class="line">Update <span class="keyword">a</span> tags table <span class="keyword">for</span> this program.</span><br><span class="line"></span><br><span class="line">check</span><br><span class="line">test</span><br><span class="line">Perform self tests <span class="keyword">on</span> <span class="title">the</span> <span class="title">program</span> <span class="title">this</span> <span class="title">makefile</span> <span class="title">builds</span>.</span><br></pre></td></tr></table></figure></p>
<h4 id="除了执行"><a href="#除了执行" class="headerlink" title="除了执行"></a>除了执行</h4><p>除了生成，更新目标文件之外，还可以有别的活动，比如打印等：<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">‘-n’</span><br><span class="line">‘<span class="comment">--just-print’</span></span><br><span class="line">‘<span class="comment">--dry-run’</span></span><br><span class="line">‘<span class="comment">--recon’</span></span><br><span class="line">“No-op”. Causes make <span class="keyword">to</span> print <span class="keyword">the</span> recipes <span class="keyword">that</span> are needed <span class="keyword">to</span> make <span class="keyword">the</span> targets up <span class="keyword">to</span> <span class="built_in">date</span>, <span class="keyword">but</span> <span class="keyword">not</span> actually execute them. </span><br><span class="line">Note <span class="keyword">that</span> <span class="keyword">some</span> recipes are still executed, even <span class="keyword">with</span> this flag (see How <span class="keyword">the</span> MAKE Variable Works).</span><br><span class="line">Also any recipes needed <span class="keyword">to</span> update included makefiles are still executed (see How Makefiles Are Remade).</span><br><span class="line"></span><br><span class="line">‘-t’</span><br><span class="line">‘<span class="comment">--touch’</span></span><br><span class="line">“Touch”. Marks targets <span class="keyword">as</span> up <span class="keyword">to</span> <span class="built_in">date</span> <span class="keyword">without</span> actually changing them.</span><br><span class="line"> In other <span class="built_in">words</span>, make pretends <span class="keyword">to</span> update <span class="keyword">the</span> targets <span class="keyword">but</span> <span class="keyword">does</span> <span class="keyword">not</span> really change their <span class="built_in">contents</span>;</span><br><span class="line">  instead only their modified <span class="keyword">times</span> are updated.</span><br><span class="line"></span><br><span class="line">‘-q’</span><br><span class="line">‘<span class="comment">--question’</span></span><br><span class="line">“Question”. Silently check whether <span class="keyword">the</span> targets are up <span class="keyword">to</span> <span class="built_in">date</span>, <span class="keyword">but</span> do <span class="keyword">not</span> execute recipes;</span><br><span class="line"> <span class="keyword">the</span> <span class="keyword">exit</span> code shows whether any updates are needed.</span><br><span class="line"></span><br><span class="line">‘-W <span class="built_in">file</span>’</span><br><span class="line">‘<span class="comment">--what-if=file’</span></span><br><span class="line">‘<span class="comment">--assume-new=file’</span></span><br><span class="line">‘<span class="comment">--new-file=file’</span></span><br><span class="line"><span class="string">"what if"</span> .每个' -W '标志后面都跟着一个文件名。</span><br><span class="line">make将给定文件的修改时间记录为当前时间，但实际的修改时间保持不变。您可以将' -W '标志与' -n '标志结合使用，看看如果要修改特定的文件会发生什么。</span><br></pre></td></tr></table></figure></p>
<h4 id="避免重编译指定的文件"><a href="#避免重编译指定的文件" class="headerlink" title="避免重编译指定的文件"></a>避免重编译指定的文件</h4><p>有时候你可能已经改变了一些源文件，但是你不想重新编译依赖它的全部文件；例如：假设你添加了一个宏或者一个声明在一个头文件中，很多<br>其他文件依赖这个头文件；保守的，make假设头文件的任何改变都需要重新编译所有的依赖它的文件，但你知道他们不需要重新编译，你可能不想浪费时间等待他们的编译；</p>
<p>如果你期望上面的文件得到解决，你可以使用-t ,make -t,这个flag告诉make不要运行规则中的指令；但是改变目标文件的最后修改时间；<br>为了避免异常，你最好按一下步骤进行：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 先<span class="keyword">make</span>执行重编译你需要重编译的文件；</span><br><span class="line"><span class="number">2</span> 改变头文件</span><br><span class="line"><span class="number">3</span> 对依赖头文件的文件，你不想重编译它，就用<span class="keyword">make</span> -t</span><br><span class="line">但是如果来不及了，即你已经改了头文件，但是有部分文件需要重新编译； 这种情况下，你可以使用-<span class="keyword">o</span> <span class="keyword">file</span> ，即它会标记一个具体的文件为旧的；</span><br><span class="line">这意味着这个文件本身不会被重生成，其他任何依赖它的文件也不会被重新生成；遵循以下步骤：</span><br><span class="line"><span class="number">1</span> 使用<span class="string">' make -o headerfile '</span>重新编译那些因特定头文件之外的原因而需要编译的源文件。如果涉及多个头文件，则对每个头文件使用单独的<span class="string">' -o '</span>选项。</span><br><span class="line"><span class="number">2</span> 对所有目标文件使用<span class="keyword">make</span> -t</span><br></pre></td></tr></table></figure></p>
<h4 id="覆盖变量："><a href="#覆盖变量：" class="headerlink" title="覆盖变量："></a>覆盖变量：</h4><p>一个包含=的参数，具体化一个变量的值： v=x ,设置变量v的值是x,如果你具体化一个值，按照这种方式，makefile中相同变量的所有普通赋值都会被忽略;我们说它们已经被命令行参数覆盖了<br>最常见的方式就是传递额外的flag给编译器：例如：<br>CFLAGS<br>cc -c $(CFLAGS) foo.c<br>这个变量被包含在每个指令中，被C编译器运行采纳；因此，为CFLAGS设置的任何值都会影响每次发生的编译。makefile可能会指定常用的CFLAGS值，如下所示:<br>CFLAGS=-g<br>每次运行make时，如果愿意，可以重写这个值。例如，如果你说’ make CFLAGS=’-g -O’ “，每一次C编译都将使用’ cc -c -g -O’来完成。<br>(这也说明了在覆盖变量时，如何在shell中使用引号将空格和其他特殊字符括在变量值中。)<br>变量CFLAGS只是众多标准变量中的一个，您可以通过这种方式更改它们。请参阅隐式规则使用的变量的完整列表<br>您还可以对makefile进行编程，以查看您自己的附加变量，从而使用户能够通过更改变量来控制makefile工作方式的其他方面<br>当使用命令行参数覆盖变量时，可以定义递归展开的变量或简单展开的变量。上面的例子是递归展开的变量;要创建一个简单展开的变量，可以使用’:= ‘或’::= ‘来代替’ = ‘。<br>但是，除非您希望在指定的值中包含变量引用或函数调用，否则创建哪种类型的变量没有区别。<br>makefile有一种方法可以更改已覆盖的变量。这是使用override指令，它是这样一行:’ override variable = value ‘</p>
<h4 id="测试标志-测试一个程序的编译"><a href="#测试标志-测试一个程序的编译" class="headerlink" title="测试标志,测试一个程序的编译"></a>测试标志,测试一个程序的编译</h4><p>通常，当一个错误反生在执行shell指令时，make会立即放弃，并返回一个非0值；不会继续执行来生成任何目标；<br>这个错误，暗示着目标无法正确重新生成，make会报告它；<br>当你正在编译一个你刚刚改变过的程序时，上面的结果可能不是你想要的；相反，你可能想要make 去尝试编译每个可以尝试的文件不中断，然后尽可能多的生成编译错误；</p>
<p>在这些场景下，你应该使用-k or –keep-going 标志，这告诉make在放弃并返回非零状态之前继续考虑目标的其他先决条件，并在必要时重新生成它们<br>例如，在编译一个目标文件时出现错误后，’ make -k ‘将继续编译其他目标文件，即使它已经知道不可能链接它们。</p>
<p>除了在shell命令失败后继续执行之外，在发现不知道如何创建目标文件或先决文件时，’ make -k ‘还将尽可能地继续执行。这将总是导致一个错误消息，但如果没有’ -k ‘，它将是一个致命错误<br>make的通常行为是假定你的目的是更新目标;一旦make知道这是不可能的，它不妨立即报告失败。’ -k ‘标志表示，真正的目的是尽可能多地测试程序中所做的更改，<br>可能是找到几个独立的问题，以便在下一次尝试编译之前纠正它们。这就是Emacs的M-x编译命令在默认情况下传递’ -k ‘标志的原因。</p>
<h4 id="选项总结；"><a href="#选项总结；" class="headerlink" title="选项总结；"></a>选项总结；</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">-B / <span class="comment">--always-make: 不管先决条件是否过期，目标是否过期，总是重新生成目标；</span></span><br><span class="line">-c dir / <span class="comment">--directory=dir 改变make的工作目录；</span></span><br><span class="line">-d / <span class="comment">--debug[=options] （a/b/v/i/j/m/n:all/basic/verbose/implicit/jobs/makefile/none):(全部类型的/基本的/基本之上/包括隐式规则/包括子命令/..)</span></span><br><span class="line">    打印除正常处理外的调试信息。调试信息表明哪些文件正在考虑重做，哪些文件时间正在比较，以及与什么结果相比较，哪些文件实际上需要重做，考虑了哪些隐式规则，哪些应用了——关于make如何决定做什么的所有有趣的事情。</span><br><span class="line">    -d选项等价于'——debug=a '</span><br><span class="line">-e / ‘<span class="comment">--environment-overrides’: 让取自环境的变量优先于makefile中的变量</span></span><br><span class="line">-E string / '<span class="comment">--eval=string’:将字符串作为makefile语法计算。这是eval函数的命令行版本(请参阅eval函数)。计算是在定义了默认规则和变量之后，但在读取任何makefile之前执行的。</span></span><br><span class="line">-f file /<span class="comment">--file=file’/ ‘--makefile=file’: 指定makefile文件</span></span><br><span class="line">-h /<span class="comment">--help: 打印帮助</span></span><br><span class="line">-i /<span class="comment">--ignore-errors: 忽略重编时指令中的所有错误</span></span><br><span class="line">‘-I dir’/‘<span class="comment">--include-dir=dir’:指定一个目录dir来搜索所包含的makefile。参见包含其他makefile。如果使用多个' -I '选项指定多个目录，则按照指定的顺序搜索目录。</span></span><br><span class="line">‘-j [jobs]’/‘<span class="comment">--jobs[=jobs]’ 多少个线程多线程执行</span></span><br><span class="line">-k / <span class="comment">--keep-going :继续执行，即使发生错误</span></span><br><span class="line">‘-l [<span class="keyword">load</span>]’/‘<span class="comment">--load-average[=load]’/‘--max-load[=load]’: 指定若有其他指令在执行，且加载的平均值至少为load，则不应启动新指令，用于控制make的多线程负载</span></span><br><span class="line">‘-L’/‘<span class="comment">--check-symlink-times’:</span></span><br><span class="line">在支持符号链接的系统上，除了这些链接引用的文件上的时间戳之外，这个选项还会导致make考虑任何符号链接上的时间戳。当提供此选项时，文件和符号链接中最近的时间戳将作为此目标文件的修改时间。</span><br><span class="line">‘-n’/‘<span class="comment">--just-print’/‘--dry-run’/‘--recon’: 打印要执行的指令，但是不要执行它，即只是查看它；</span></span><br><span class="line">‘-o <span class="keyword">file</span>’/‘<span class="comment">--old-file=file’/‘--assume-old=file’</span></span><br><span class="line">不要重做文件文件，即使它比它的先决条件旧，也不要重做任何文件中的变化。本质上，该文件被视为非常老的文件，其规则被忽略。</span><br><span class="line">‘-O[<span class="keyword">type</span>]’/‘<span class="comment">--output-sync[=type]’:指示多线程执行的时候怎么打印信息，上文有，不赘述</span></span><br><span class="line">‘-p’/‘<span class="comment">--print-data-base’: </span></span><br><span class="line">打印从makefile读取的数据库：然后按照常规方式执行，要打印数据库而不重新创建任何文件，请使用<span class="string">' make -qp '</span>。要打印预定义规则和变量的数据库，</span><br><span class="line">请使用<span class="string">' make -p -f /dev/null '</span>。数据库输出包含指令和变量定义的文件名和行号信息，因此它在复杂环境中是一个有用的调试工具。</span><br><span class="line">‘-q’/‘<span class="comment">--question’:</span></span><br><span class="line">不要运行任何指令，或打印任何东西;如果指定的目标已经是最新的，则只返回一个退出状态为0;如果需要重新制作，则返回一个;如果遇到错误，则返回两个</span><br><span class="line">‘-r’/‘<span class="comment">--no-builtin-rules’:避免使用内置的隐式规则</span></span><br><span class="line">“- r”/“——no-builtin-variables”:避免使用内置的特定于规则的变量</span><br><span class="line">‘-s’/‘<span class="comment">--silent’/‘--quiet’: 静默模式，不输出任何信息，在执行的过程中；</span></span><br><span class="line">‘-S’/‘<span class="comment">--no-keep-going’/‘--stop’:</span></span><br><span class="line">取消' -k '选项的效果。这从来没有必要，除非在递归make中，' -k '可能从顶级make中继承通过MAKEFLAGS(参见递归使用make)，或者如果你在你的环境中的MAKEFLAGS中设置了' -k '。</span><br><span class="line">‘-t’/‘<span class="comment">--touch’:只是标记文件为最新，而不是真的生成目标文件</span></span><br><span class="line">‘<span class="comment">--trace’ ：显示make执行的跟踪信息。</span></span><br><span class="line">‘-v’/‘<span class="comment">--version’: 打印版本号</span></span><br><span class="line">‘-w’/‘<span class="comment">--print-directory’: 打印工作目录</span></span><br><span class="line">‘-W file’</span><br><span class="line">‘<span class="comment">--what-if=file’</span></span><br><span class="line">‘<span class="comment">--new-file=file’</span></span><br><span class="line">‘<span class="comment">--assume-new=file’</span></span><br><span class="line">假设目标文件刚刚被修改。当与' -n '标志一起使用时，这将显示如果要修改该文件会发生什么。如果没有' -n '，在运行make之前在给定的文件上运行touch命令几乎是一样的，除了修改时间只是在make的想象中改变。</span><br></pre></td></tr></table></figure>
<h3 id="如何使用隐式规则"><a href="#如何使用隐式规则" class="headerlink" title="如何使用隐式规则"></a>如何使用隐式规则</h3><p>remake目标文件的确定的标准方法经常被使用。例如，一种make目标文件的习惯方法是使用C编译器cc从C源文件中获取目标文件。<br>隐式规则，告诉make如何使用习惯的技术，以便于你不用具体化他们的细节，当你想要用他们的时候；例如：<br>这是一个为C编译使用的隐式规则：文件名决定了哪种隐式规则被运行；例如，c编译典型就是用.c文件生成.o文件; 所以make为此应用了隐式规则，当他看到这种字符结尾的文件；<br>一系列的隐式规则可以按顺序应用;例如，make将通过.c文件从.y文件重制一个.o文件。<br>内置的隐式规则在其方法中使用几个变量，因此，通过更改变量的值，可以更改隐式规则的工作方式。例如，变量CFLAGS控制C编译的隐式规则给C编译器的标志。<br>您可以通过编写模式规则来定义自己的隐式规则。</p>
<p>后缀规则是定义隐式规则的一种更有限的方式。模式规则更加通用和清晰，但后缀规则保留以保持兼容性</p>
<h4 id="使用隐式规则"><a href="#使用隐式规则" class="headerlink" title="使用隐式规则"></a>使用隐式规则</h4><p>为了让make找到更新目标文件的常用方法，您所需要做的就是避免自己指定指令。<br>要么写一个没有指令的规则，要么根本不写规则。然后，make将根据存在或可以创建哪种源文件来确定使用哪种隐式规则<br>例如，有个makefile如下：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">foo : foo<span class="selector-class">.o</span> bar.o</span><br><span class="line">        cc -o foo foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span> $(CFLAGS) $(LDFLAGS)</span><br></pre></td></tr></table></figure></p>
<p>这里因为你提到了foo.o,但是却没有给一个规则，所以make自动的寻找一个隐式规则来告知如何更新它；这个事情的发生不管当前是否有foo.o存在；</p>
<p>如果一个隐式规则被找到，它能应用到一个指令和一个或多个依赖(源文件)。如果你需要具体化格外的依赖文件比如头文件，你可以写一个只包含依赖文件的，不包含指令的<br>规则；</p>
<p>每个隐式规则由一个目标模板和一个依赖模板。可能有许多隐式规则用相同的目标模板；例如： 生成.o的，可以是.c,.p,等等，对应的c和pascal编译器。<br>这个规则实际上应用在依赖存在的目标上，或者能被生成；所以如果你有一个foo.c文件，make将运行c编译器，否则，如果有foo.p，make可能会运行pascal编译器来生成<br>;以此类推；</p>
<p>当然，当你写makefile,你得知道哪些隐式规则你想让make使用，并且你知道它会选择哪些依赖文件，那些依赖文件存在等等；<br>上面，我们说过，如果必要的先决条件“存在或可以建立”，就应用隐式规则。如果在makefile中显式地提到文件作为目标或先决条件，<br>或者可以递归地找到创建文件的隐式规则，则“可以创建”文件。当一个隐式前提是另一个隐式规则的结果时，我们说链接正在发生。</p>
<p>一般而言，make会为每个目标，每个只有冒号但是没有指令的目标寻找隐式规则；一个文件只在依赖中被提到也会被当做目标，这个时候它也没有具体化目标；<br>所以隐式规则寻找这里也会发生；</p>
<p>要注意显示规则不会影响到隐式规则的寻找：如<br>foo.o:foo.p<br>注意这里，依赖是foo.p,并不意味着make会依据隐式规则来从foo.p生成foo.o,例如，如果foo.c存在，则会从foo.c生成foo.o ,因为在<br>隐式规则列表中，c这个存在于p之前；</p>
<p>如果您不希望隐式规则用于没有指令的目标，可以通过编写分号为该目标提供一个空配方</p>
<h4 id="内建规则清单"><a href="#内建规则清单" class="headerlink" title="内建规则清单"></a>内建规则清单</h4><p>下面是一组预定义的隐式规则，它们总是可用的，除非makefile显式地覆盖或取消它们。<br>有关取消或重写隐式规则的信息，请参阅取消隐式规则。选项’ -r ‘或’——no-built -rules ‘取消所有预定义的规则。</p>
<p>本手册仅记录基于posix的操作系统上可用的默认规则。其他操作系统，如VMS、Windows、OS/2等可能有不同的默认规则集。<br>要查看您版本的GNU make中可用的默认规则和变量的完整列表，请在一个没有makefile的目录中运行’ make -p ‘。</p>
<p>当然，即使是我们指定了 -r 参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有 “后缀列表”（也就一系统定义在目标 .SUFFIXES 的依赖目标），<br>那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<p>编译C程序的隐含规则。</p>
<p><n>.o 的目标的依赖目标会自动推导为 <n>.c ，并且其生成命令是 $(CC) –c $(CPPFLAGS) $(CFLAGS)</n></n></p>
<p>编译C++程序的隐含规则。</p>
<p><n>.o 的目标的依赖目标会自动推导为 <n>.cc 或是 <n>.C ，并且其生成命令是 $(CXX) –c $(CPPFLAGS) $(CFLAGS) 。（建议使用 .cc 作为C++源文件的后缀，而不是 .C ）</n></n></n></p>
<p>编译Pascal程序的隐含规则。</p>
<p><n>.o 的目标的依赖目标会自动推导为 <n>.p ，并且其生成命令是 $(PC) –c  $(PFLAGS) 。</n></n></p>
<p>编译Fortran/Ratfor程序的隐含规则。</p>
<p><n>.o 的目标的依赖目标会自动推导为 <n>.r 或 <n>.F 或 <n>.f ，并且其生成命令是:<br>.f $(FC) –c  $(FFLAGS)<br>.F $(FC) –c  $(FFLAGS) $(CPPFLAGS)<br>.f $(FC) –c  $(FFLAGS) $(RFLAGS)<br>预处理Fortran/Ratfor程序的隐含规则。</n></n></n></n></p>
<p><n>.f 的目标的依赖目标会自动推导为 <n>.r 或 <n>.F 。这个规则只是转换Ratfor 或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：<br>.F $(FC) –F $(CPPFLAGS) $(FFLAGS)<br>.r $(FC) –F $(FFLAGS) $(RFLAGS)<br>编译Modula-2程序的隐含规则。</n></n></n></p>
<p><n>.sym 的目标的依赖目标会自动推导为 <n>.def ，并且其生成命令是： $(M2C) $(M2FLAGS) $(DEFFLAGS) 。 <n>.o 的目标的依赖目标会自动推导为 <n>.mod ，并且其生成命令是： $(M2C) $(M2FLAGS) $(MODFLAGS) 。</n></n></n></n></p>
<p>汇编和汇编预处理的隐含规则。</p>
<p><n>.o 的目标的依赖目标会自动推导为 <n>.s ，默认使用编译器 as ，并且其生成命令是： $ (AS) $(ASFLAGS) 。 <n>.s 的目标的依赖目标会自动推导为 <n>.S ，默认使用C预编译器 cpp ，并且其生成命令是： $(AS) $(ASFLAGS) 。</n></n></n></n></p>
<p>链接Object文件的隐含规则。</p>
<p><n> 目标依赖于 <n>.o ，通过运行C的编译器来运行链接程序生成（一般是 ld ），其生成命令是： $(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS) 。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:</n></n></n></p>
<p>x : y.o z.o<br>并且 x.c 、 y.c 和 z.c 都存在时，隐含规则将执行如下命令:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">cc -c x<span class="selector-class">.c</span> -o x.o</span><br><span class="line">cc -c y<span class="selector-class">.c</span> -o y.o</span><br><span class="line">cc -c z<span class="selector-class">.c</span> -o z.o</span><br><span class="line">cc x<span class="selector-class">.o</span> y<span class="selector-class">.o</span> z<span class="selector-class">.o</span> -o x</span><br><span class="line">rm -f x.o</span><br><span class="line">rm -f y.o</span><br><span class="line">rm -f z.o</span><br></pre></td></tr></table></figure></p>
<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<p>Yacc C程序时的隐含规则。</p>
<p><n>.c 的依赖文件被自动推导为 n.y （Yacc生成的文件），其生成命令是： $(YACC) $(YFALGS) 。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</n></p>
<p>Lex C程序时的隐含规则。</p>
<p><n>.c 的依赖文件被自动推导为 n.l （Lex生成的文件），其生成命令是： $(LEX) $(LFALGS) 。（关于“Lex”的细节请查看相关资料）</n></p>
<p>Lex Ratfor程序时的隐含规则。</p>
<p><n>.r 的依赖文件被自动推导为 n.l （Lex生成的文件），其生成命令是： $(LEX) $(LFALGS) 。</n></p>
<p>从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</p>
<p><n>.ln （lint生成的文件）的依赖文件被自动推导为 n.c ，其生成命令是： $(LINT) $(LINTFALGS) $(CPPFLAGS) -i 。对于 <n>.y 和 <n>.l 也是同样的规则。</n></n></n></p>
<p>更多参考文档</p>
<h4 id="隐式规则中变量的使用："><a href="#隐式规则中变量的使用：" class="headerlink" title="隐式规则中变量的使用："></a>隐式规则中变量的使用：</h4><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的 -R 或 –no–builtin-variables 参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是 $(CC) –c $(CFLAGS) $(CPPFLAGS) 。Make默认的编译命令是 cc ，如果你把变量 $(CC) 重定义成 gcc ，把变量 $(CFLAGS) 重定义成 -g ，那么，隐含规则中的命令全部会以 gcc –c -g $(CPPFLAGS) 的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如 CC ；一种是参数相的关，如 CFLAGS 。下面是所有隐含规则中会用到的变量：</p>
<p>关于命令的变量。<br>AR : 函数库打包程序。默认命令是 ar<br>AS : 汇编语言编译程序。默认命令是 as<br>CC : C语言编译程序。默认命令是 cc<br>CXX : C++语言编译程序。默认命令是 g++<br>CO : 从 RCS文件中扩展文件程序。默认命令是 co<br>CPP : C程序的预处理器（输出是标准输出设备）。默认命令是 $(CC) –E<br>FC : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 f77<br>GET : 从SCCS文件中扩展文件的程序。默认命令是 get<br>LEX : Lex方法分析器程序（针对于C或Ratfor）。默认命令是 lex<br>PC : Pascal语言编译程序。默认命令是 pc<br>YACC : Yacc文法分析器（针对于C程序）。默认命令是 yacc<br>YACCR : Yacc文法分析器（针对于Ratfor程序）。默认命令是 yacc –r<br>MAKEINFO : 转换Texinfo源文件（.texi）到Info文件程序。默认命令是 makeinfo<br>TEX : 从TeX源文件创建TeX DVI文件的程序。默认命令是 tex<br>TEXI2DVI : 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是 texi2dvi<br>WEAVE : 转换Web到TeX的程序。默认命令是 weave<br>CWEAVE : 转换C Web 到 TeX的程序。默认命令是 cweave<br>TANGLE : 转换Web到Pascal语言的程序。默认命令是 tangle<br>CTANGLE : 转换C Web 到 C。默认命令是 ctangle<br>RM : 删除文件命令。默认命令是 rm –f<br>关于命令参数的变量<br>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<p>ARFLAGS : 函数库打包程序AR命令的参数。默认值是 rv<br>ASFLAGS : 汇编语言编译器参数。（当明显地调用 .s 或 .S 文件时）<br>CFLAGS : C语言编译器参数。<br>CXXFLAGS : C++语言编译器参数。<br>COFLAGS : RCS命令参数。<br>CPPFLAGS : C预处理器参数。（ C 和 Fortran 编译器也会用到）。<br>FFLAGS : Fortran语言编译器参数。<br>GFLAGS : SCCS “get”程序参数。<br>LDFLAGS : 链接器参数。（如： ld ）<br>LFLAGS : Lex文法分析器参数。<br>PFLAGS : Pascal语言编译器参数。<br>RFLAGS : Ratfor 程序的Fortran 编译器参数。<br>YFLAGS : Yacc文法分析器参数。</p>
<h4 id="隐式规则链："><a href="#隐式规则链：" class="headerlink" title="隐式规则链："></a>隐式规则链：</h4><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个 .o 的文件生成，可能会是先被 Yacc的[.y]文件先成 .c ，然后再被C的编译器生成。<br>我们把这一系列的隐含规则叫做“隐含规则链”。</p>
<p>在上面的例子中，如果文件 .c 存在，那么就直接调用C的编译器的隐含规则，如果没有 .c 文件，但有一个 .y 文件，那么Yacc的隐含规则会被调用，生成 .c 文件，<br>然后，再调用C编译的隐含规则最终由 .c 生成 .o 文件，达到目标。</p>
<p>我们把这种 .c 的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，<br>其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的 makefile发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，<br>那么，产生最终目标过程中，所产生的中间目标文件会被以 rm -f 删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标 .INTERMEDIATE 来强制声明。<br>（如： .INTERMEDIATE : mid ）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标 .SECONDARY 来强制声明（如： .SECONDARY : sec ）。你还可以把你的目标，<br>以模式的方式来指定（如： %.o ）成伪目标 .PRECIOUS 的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件 foo.c 生成目标程序 foo ，按道理，make会编译生成中间文件 foo.o ，然后链接成 foo ，<br>但在实际情况下，这一动作可以被一条 cc 的命令完成（ cc –o foo foo.c ），于是优化过的规则就不会生成中间文件。</p>
<h4 id="如何定义新的隐式规则"><a href="#如何定义新的隐式规则" class="headerlink" title="如何定义新的隐式规则"></a>如何定义新的隐式规则</h4><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有 % 字符。 % 的意思是表示一个或多个任意字符。<br>在依赖目标中同样可以使用 % ，只是依赖目标中的 % 的取值，取决于其目标。</p>
<p>有一点需要注意的是， % 的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入 Makefile时，而模式规则中的 % 则发生在运行时。</p>
<p>模式规则介绍<br>模式规则中，至少在规则的目标定义中要包含 % ，否则，就是一般的规则。目标中的 % 定义表示对文件名的匹配， % 表示长度任意的非空字符串。<br>例如： %.c 表示以 .c 结尾的文件名（文件名的长度至少为3），而 s.%.c 则表示以 s. 开头， .c 结尾的文件名（文件名的长度至少为5）。</p>
<p>如果 % 定义在目标中，那么，目标中的 % 的值决定了依赖目标中的 % 的值，也就是说，目标中的模式的 % 决定了依赖目标中 % 的样子。例如有一个模式规则如下：</p>
<p>%.o : %.c ; <command ......="">;<br>其含义是，指出了怎么从所有的 .c 文件生成相应的 .o 文件的规则。如果要生成的目标是 a.o b.o ，那么 %c 就是 a.c b.c 。</p>
<p>一旦依赖目标中的 % 模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，<br>目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>
<h5 id="模式规则示例"><a href="#模式规则示例" class="headerlink" title="模式规则示例"></a>模式规则示例</h5><p>下面这个例子表示了,把所有的 .c 文件都编译成 .o 文件.</p>
<p>%.o : %.c<br>    $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@<br>其中， $@ 表示所有的目标的挨个值， $&lt; 表示了所有依赖目标的挨个值。这些奇怪的变量我们叫“自动化变量”，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的：</p>
<p>%.tab.c %.tab.h: %.y<br>    bison -d $&lt;<br>这条规则告诉make把所有的 .y 文件都以 bison -d <n>.y 执行，然后生成 <n>.tab.c 和 <n>.tab.h 文件。（其中， <n> 表示一个任意字符串）。如果我们的执行程序 foo 依赖于文件 parse.tab.o 和 scan.o ，并且文件 scan.o 依赖于文件 parse.tab.h ，如果 parse.y 文件被更新了，那么根据上述的规则， bison -d parse.y 就会被执行一次，于是， parse.tab.o 和 scan.o 的依赖文件就齐了。（假设， parse.tab.o 由 parse.tab.c 生成，和 scan.o 由 scan.c 生成，而 foo 由 parse.tab.o 和 scan.o 链接生成，而且 foo 和其 .o 文件的依赖关系也写好，那么，所有的目标都会得到满足）</n></n></n></n></p>
<h5 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h5><p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明：<br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$@ : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， $@ 就是匹配于目标中模式定义的集合。</span><br><span class="line">$% : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 foo.a(bar.o) ，那么， $% 就是 bar.o ， $@ 就是 foo.a 。如果目标不是函数库文件（Unix下是 .a ，Windows下是 .<span class="keyword">lib</span> ），那么，其值为空。</span><br><span class="line">$&lt; : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 $&lt; 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</span><br><span class="line">$? : 所有比目标新的依赖目标的集合。以空格分隔。</span><br><span class="line">$^ : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</span><br><span class="line">$+ : 这个变量很像 $^ ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</span><br><span class="line">$* : 这个变量表示目标模式中 % 及其之前的部分。如果目标是 dir/a.foo.b ，并且目标的模式是 a.%.b ，那么， $* 的值就是 dir/a.foo 。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么 $* 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 $* 就是除了后缀的那一部分。例如：如果目标是 foo.c ，因为 .c 是make所能识别的后缀名，所以， $* 的值就是 foo 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 $* ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 $* 就是空值。</span><br><span class="line">当你希望只对更新过的依赖文件进行操作时， $? 在显式规则中很有用，例如，假设有一个函数库文件叫 <span class="class"><span class="keyword">lib</span> ，其由其它几个<span class="title">object</span>文件更新。那么把<span class="title">object</span>文件打包的比较有效率的<span class="title">Makefile</span>规则是：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">lib</span> : <span class="title">foo</span>.<span class="title">o</span> <span class="title">bar</span>.<span class="title">o</span> <span class="title">lose</span>.<span class="title">o</span> <span class="title">win</span>.<span class="title">o</span></span></span><br><span class="line">    ar r <span class="class"><span class="keyword">lib</span> $?</span></span><br><span class="line">在上述所列出来的自动量变量中。四个变量（ $@ 、 $&lt; 、 $% 、 $* ）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上 D 或 F 字样。这是GNU make中老版本的特性，在新版本中，我们使用函数 dir 或 notdir 就可以做到了。 D 的含义就是Directory，就是目录， F 的含义就是File，就是文件。</span><br></pre></td></tr></table></figure></p>
<p>下面是对于上面的七个变量分别加上 D 或是 F 的含义：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">$(@D)</span><br><span class="line">表示 $@ 的目录部分（不以斜杠作为结尾），如果 $@ 值是 dir/foo.o ，那么 $(@D) 就是 dir ，而如果 $@ 中没有包含斜杠的话，其值就是 . （当前目录）。</span><br><span class="line">$(@F)</span><br><span class="line">表示 $@ 的文件部分，如果 $@ 值是 dir/foo.o ，那么 $(@F) 就是 foo.o ， $(@F) 相当于函数 $(notdir $@) 。</span><br><span class="line">$(*D), $(*F)</span><br><span class="line">和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， $(*D) 返回 dir ，而 $(*F) 返回 foo</span><br><span class="line">$(%D), $(%F)</span><br><span class="line">分别表示了函数包文件成员的目录部分和文件部分。这对于形同 archive(member) 形式的目标中的 member 中包含了不同的目录很有用。</span><br><span class="line">$(&lt;D), $(&lt;F)</span><br><span class="line">分别表示依赖文件的目录部分和文件部分。</span><br><span class="line">$(^D), $(^F)</span><br><span class="line">分别表示所有依赖文件的目录部分和文件部分。（无相同的）</span><br><span class="line">$(+D), $(+F)</span><br><span class="line">分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</span><br><span class="line">$(<span class="string">?D</span>), $(<span class="string">?F</span>)</span><br><span class="line">分别表示被更新的依赖文件的目录部分和文件部分。</span><br><span class="line">最后想提醒一下的是，对于 $&lt; ，为了避免产生不必要的麻烦，我们最好给 $ 后面的那个特定字符都加上圆括号，比如， $(&lt;) 就要比 $&lt; 要好一些。</span><br></pre></td></tr></table></figure></p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是“显式规则”和“静态模式规则”（参见前面“书写规则”一章）。其在隐含规则中并没有意义。</p>
<h5 id="模式的匹配"><a href="#模式的匹配" class="headerlink" title="模式的匹配"></a>模式的匹配</h5><p>一般来说，一个目标的模式有一个有前缀或是后缀的 % ，或是没有前后缀，直接就是一个 % 。因为 % 代表一个或多个字符，所以在定义好了的模式中，我们把 % 所匹配的内容叫做“茎”，例如 %.c 所匹配的文件“test.c”中“test”就是“茎”。因为在目标和依赖目标中同时有 % 时，依赖目标的“茎”会传给目标，当做目标中的“茎”。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式 e%t ，文件 src/eat 匹配于该模式，于是 src/a 就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式 c%r ，那么，目标就是 src/car 。（“茎”被传递）</p>
<h5 id="重载内建隐含规则"><a href="#重载内建隐含规则" class="headerlink" title="重载内建隐含规则"></a>重载内建隐含规则</h5><p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：<br><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">    $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(<span class="keyword">date</span>)</span><br></pre></td></tr></table></figure></p>
<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>
<p>%.o : %.s<br>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h4 id="老式风格的隐式规则"><a href="#老式风格的隐式规则" class="headerlink" title="老式风格的隐式规则"></a>老式风格的隐式规则</h4><p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。<br>为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：“双后缀”和“单后缀”。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如 .c.o 相当于 %o : %c 。单后缀规则只定义一个后缀，也就是源文件的后缀。<br>如 .c 相当于 % : %.c 。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。<br>例如： .c 和 .o 都是make所知道。因而，如果你定义了一个规则是 .c.o 那么其就是双后缀规则，意义就是 .c 是源文件的后缀， .o 是目标文件的后缀。如下示例：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.c.o:</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</span><br><span class="line"></span><br><span class="line"><span class="section">.c.o: foo.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">这个例子，就是说，文件 .c.o 依赖于文件 foo.h ，而不是我们想要的这样：</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c foo.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</span><br><span class="line"></span><br><span class="line">而要让make知道一些特定的后缀，我们可以使用伪目标 .SUFFIXES 来定义或是删除，如：</span><br><span class="line"></span><br><span class="line"><span class="section">.SUFFIXES: .hack .win</span></span><br><span class="line">把后缀 .hack 和 .win 加入后缀列表中的末尾。</span><br><span class="line"></span><br><span class="line"><span class="section">.SUFFIXES:              # 删除默认的后缀</span></span><br><span class="line"><span class="section">.SUFFIXES: .c .o .h   # 定义自己的后缀</span></span><br><span class="line">先清除默认后缀，后定义自己的后缀列表。</span><br></pre></td></tr></table></figure></p>
<p>make的参数 -r 或 -no-builtin-rules 也会使用得默认的后缀列表为空。而变量 SUFFIXE 被用来定义默认的后缀列表，你可以用 .SUFFIXES 来改变后缀列表，<br>但请不要改变变量 SUFFIXE 的值。</p>
<h4 id="隐式规则的搜索算法"><a href="#隐式规则的搜索算法" class="headerlink" title="隐式规则的搜索算法"></a>隐式规则的搜索算法</h4><p>比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，<br>原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是 archive(member) 的函数库文件模式，那么这个算法会被运行两次，<br>第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把 member 当作T来搜索。</p>
<p>1 把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是 src/foo.o ，那么，D就是 src/ ，N就是 foo.o ）<br>2 创建所有匹配于T或是N的模式规则列表。<br>3 如果在模式规则列表中有匹配所有文件的模式，如 % ，那么从列表中移除其它的模式。<br>4 移除列表中没有命令的规则。<br>5 对于第一个在列表中的模式规则：<br>   1) 推导其“茎”S，S应该是T或是N匹配于模式中 % 非空的部分。<br>   2) 计算依赖文件。把依赖文件中的 % 都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。<br>   3) 测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）<br>   4) 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。<br>6 如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：<br>   1) 如果规则是终止规则，那就忽略它，继续下一条模式规则。<br>   2) 计算依赖文件。（同第5步）<br>   3) 测试所有的依赖文件是否存在或是理当存在。<br>   4) 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。<br>   5) 如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。<br>   6) 如果没有隐含规则可以使用，查看 .DEFAULT 规则，如果有，采用，把 .DEFAULT 的命令给T使用。<br>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。  </p>
<h3 id="使用make更新archive文件"><a href="#使用make更新archive文件" class="headerlink" title="使用make更新archive文件"></a>使用make更新archive文件</h3><p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令 ar 来完成打包工作。<br>Archive files are files containing named sub-files called members; they are maintained with the program ar and their main use is as subroutine libraries for linking.</p>
<h4 id="archive-members"><a href="#archive-members" class="headerlink" title="archive members"></a>archive members</h4><p>一个函数库文件由多个文件组成。你可以用如下格式指定函数库文件及其组成:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">archive</span><span class="params">(member)</span></span></span><br><span class="line">这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了 ar 命令来服务的。如:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foolib</span><span class="params">(hack.o)</span></span> : hack.o</span><br><span class="line">    ar cr foolib hack.o</span><br><span class="line">如果要指定多个member，那就以空格分开，如:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foolib</span><span class="params">(hack.o kludge.o)</span></span></span><br><span class="line">其等价于:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foolib</span><span class="params">(hack.o)</span></span> foolib(kludge.o)</span><br><span class="line">你还可以使用Shell的文件通配符来定义，如:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foolib</span><span class="params">(*.o)</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="archive后缀规则"><a href="#archive后缀规则" class="headerlink" title="archive后缀规则"></a>archive后缀规则</h4><p>函数库成员的隐含规则<br>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是 a(m) 形式的，其会把目标变成 (m) 。于是，如果我们的成员是 %.o 的模式定义，并且如果我们使用 make foo.a(bar.o) 的形式调用Makefile时，隐含规则会去找 bar.o 的规则，如果没有定义 bar.o 的规则，那么内建隐含规则生效，make会去找 bar.c 文件来生成 bar.o ，如果找得到的话，make执行的命令大致如下:<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">cc</span> -c <span class="keyword">bar.c </span>-o <span class="keyword">bar.o</span></span><br><span class="line"><span class="keyword">ar </span>r foo.a <span class="keyword">bar.o</span></span><br><span class="line"><span class="keyword">rm </span>-f <span class="keyword">bar.o</span></span><br><span class="line"><span class="keyword">还有一个变量要注意的是 </span>$% ，这是专属函数库文件的自动化变量，有关其说明请参见“自动化变量”一节。</span><br></pre></td></tr></table></figure></p>
<p>函数库文件的后缀规则<br>你可以使用“后缀规则”和“隐含规则”来生成函数库打包文件，如：<br><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">.c.a:</span><br><span class="line">    $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o</span><br><span class="line">    $(AR) r $@ $*.o</span><br><span class="line">    $(RM) $*.o</span><br><span class="line">其等效于：</span><br><span class="line"></span><br><span class="line">(%.o) : %.c</span><br><span class="line">    $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o</span><br><span class="line">    $(AR) r $@ $*.o</span><br><span class="line">    $(RM) $*.o</span><br></pre></td></tr></table></figure></p>
<h4 id="陷阱："><a href="#陷阱：" class="headerlink" title="陷阱："></a>陷阱：</h4><p>在进行函数库打包文件生成时，请小心使用make的并行机制（ -j 参数）。如果多个 ar 命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。<br>所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。<br>但就目前而言，你还是应该不要尽量不要使用 -j 参数  </p>
<h3 id="如何扩展gnu-make-这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；"><a href="#如何扩展gnu-make-这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；" class="headerlink" title="如何扩展gnu make 这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；"></a>如何扩展gnu make 这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；</h3><h4 id="Guile-Integration"><a href="#Guile-Integration" class="headerlink" title="Guile Integration"></a>Guile Integration</h4><h4 id="Loading-Objects"><a href="#Loading-Objects" class="headerlink" title="Loading Objects"></a>Loading Objects</h4><h3 id="更多参考ref"><a href="#更多参考ref" class="headerlink" title="更多参考ref"></a>更多参考ref</h3>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_type</title>
    <url>/2021/04/03/cpp-type/</url>
    <content><![CDATA[<p>c++数据类型：</p>
<h3 id="数据类型概览"><a href="#数据类型概览" class="headerlink" title="数据类型概览"></a>数据类型概览</h3><p>1) 类型无处不在，注意表达式也有类型，一些语句本身也是某个类型的值，以下这些都有类型属性<br>    对象的类型和基本类型<br>    引用的类型<br>    函数的类型(返回值类型)<br>    函数模板特化<br>    表达式的值类型<a id="more"></a><br>2) 类型如何分类以及复合类型<br>    内建类型：<br>    void,<br>    nullptr_t(c++),<br>    arithmetic 类型(整数数值)<br>    浮点数<br>    整数：<br>       bool<br>       字符<br>       有符号整数<br>       无符号整数<br>    复合类型：引用，指针，类的成员指针，数组，函数，枚举，类类型<br>3) 关于类型的命名，类型在使用时，并不是严格的按照既定名称来的，比如vector<int> 也可以作为一个类型来使用（c++)<br>    eg:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;               <span class="comment">// declaration of a pointer to int</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(p); <span class="comment">// type-id is "int*"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];   <span class="comment">// declaration of an array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">// type-id is "int[3]" (called new-type-id)</span></span><br></pre></td></tr></table></figure></int></p>
<p>4) 静态类型： 编译期确定，运行时无法改变； 动态类型：运行时动态指定，比如多态（c++）；<br>5) 未完成的类型，一些本身就是未完成的类型如void，还有是类类型中没有定义所有的函数(c++)；</p>
<h3 id="类型的分类："><a href="#类型的分类：" class="headerlink" title="类型的分类："></a>类型的分类：</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><h5 id="void"><a href="#void" class="headerlink" title="void:"></a>void:</h5><ul>
<li>1) 概念简介：void类型不能定义变量，因为是一种未完成的类型；同样不能定义数组，引用，但是可以定义void 指针以及函数返回类型也可以是void *；</li>
<li><p>2) 用法注意：<br>A: void 可以是指针类型，可以将void <em>类型的指针转换为任意类型的指针；<br>B: 既然void可以定义指针类型，也就说明这个指针是任意类型的指针，在内存中分配了8字节/4字节的地址，但是没有指定类型，也就是说其可以访问的内存范围无法确定，也就是说不能对void指针做取值操作如void </em>a; <em>a=3;/printf(</em>a);<br>void* 类型只能在转型后才能访问指向的内存地址；  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *a;</span><br><span class="line">        a=<span class="number">3</span>;<span class="comment">//这里对a赋值没问题</span></span><br><span class="line">        <span class="keyword">int</span> *b=<span class="number">0</span>;</span><br><span class="line">        a=b;<span class="comment">//这里是可以的；这样将a赋值为int 类型的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">32</span>;</span><br><span class="line">        b=&amp;c;</span><br><span class="line">        a=b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);<span class="comment">//访问a就不需要转型，毕竟指针都是固</span></span><br><span class="line">定字节的；</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*(<span class="keyword">int</span>*)a);<span class="comment">//访问*a就需要转型，即使前面</span></span><br><span class="line">赋值也没用；</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*b=3;</span></span><br><span class="line"><span class="comment">       *b=32;</span></span><br><span class="line"><span class="comment">       printf("%d\n",*b);</span></span><br><span class="line"><span class="comment">       */</span><span class="comment">//这么用回出现段错误</span></span><br><span class="line">        a = (<span class="keyword">char</span>*)a;</span><br><span class="line">        <span class="keyword">char</span> *p=<span class="string">"aaaaa"</span>;</span><br><span class="line">        a=p;</span><br><span class="line">        a=(<span class="keyword">void</span>*)a;</span><br><span class="line">        <span class="comment">//printf("%c",*a);//这里就不行，因为*操作不知道拿多</span></span><br><span class="line">少内存</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,a);<span class="comment">//这种方式倒是可以成功输出,因为不是对void *做取值，而是取其指针值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3)函数返回值void *意味着它可以接受任何类型的返回指针类型；毕竟只是返回一个指针值；</p>
</li>
<li>4)一些库函数，参数是void<em> 的，意味着可以不受限制传入任意的指定类型，但是实际上内部实现是需要做类型转换的，比如转为char</em> 除非只是对指针做透传；</li>
</ul>
<h5 id="nullptr-t"><a href="#nullptr-t" class="headerlink" title="nullptr_t"></a>nullptr_t</h5><p>std::nullptr_t (c++11)<br>Defined in header <cstddef><br>typedef decltype(nullptr) nullptr_t;<br>nullptr_t是空指针字面量nullptr的类型。它是一种特别的类型，本身不是指针类型或指向成员类型的指针。<br>nullptr_t is available in the global namespace when &lt;stddef.h&gt; is included, even if it is not a part of C.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pointer to integer overload\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pointer to double overload\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"null pointer overload\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* pi &#123;&#125;; <span class="keyword">double</span>* pd &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    f(pi);</span><br><span class="line">    f(pd);</span><br><span class="line">    f(<span class="literal">nullptr</span>); <span class="comment">// would be ambiguous without void f(nullptr_t)</span></span><br><span class="line">    <span class="comment">// f(0);    // ambiguous call: all three functions are candidates</span></span><br><span class="line">    <span class="comment">// f(NULL); // ambiguous if NULL is an integral null pointer constant </span></span><br><span class="line">                <span class="comment">// (as is the case in most implementations)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></cstddef></p>
<h4 id="数学类型：数值："><a href="#数学类型：数值：" class="headerlink" title="数学类型：数值："></a>数学类型：数值：</h4><h5 id="bool布尔类型："><a href="#bool布尔类型：" class="headerlink" title="bool布尔类型："></a>bool布尔类型：</h5><p>布尔类型只有两个值，true和false;<br>实际例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> bbo = (<span class="keyword">bool</span>)<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; bbo &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> testnum = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">bool</span>)testnum &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">bool</span> tt = testnum;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; tt &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> tye = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; tye &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//true   //noboolalpha 按数值打印</span></span><br></pre></td></tr></table></figure></p>
<h5 id="字符类型-char-系列：char-signed-char-unsigned-char"><a href="#字符类型-char-系列：char-signed-char-unsigned-char" class="headerlink" title="字符类型:char 系列：char *,signed char,unsigned char"></a>字符类型:char 系列：char *,signed char,unsigned char</h5><ul>
<li><p>1) char:char是八位一个字节的类型，<br>   本身赋值可以容纳任何的八位二进制而不管符号；<br>   但是输出时则对应输出ASCII码，当不匹配任何ASCII码时，则输出乱码；<br>   内存中的值：8位值；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//实际存放的值，在小于等于2的八次方 255(全1）时，按补码方式存放，即正数时为原码，负数时为除符号位外取反加1；</span></span><br><span class="line">    <span class="keyword">char</span> a=<span class="number">-43</span>;<span class="comment">//实际存放：</span></span><br><span class="line">    <span class="keyword">char</span> b=<span class="number">0</span>;<span class="comment">//实际存放：00000000</span></span><br><span class="line">    <span class="keyword">char</span> c=<span class="number">0b11111111</span>;<span class="comment">//11111111//255</span></span><br><span class="line">    <span class="keyword">char</span> d=<span class="number">127</span>;<span class="comment">//0111 1111</span></span><br><span class="line">    <span class="keyword">char</span> e=<span class="number">0b10000000</span>;<span class="comment">//1000 0000//128</span></span><br><span class="line">    <span class="keyword">char</span> f=<span class="number">-128</span>;<span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n%c\n%c\n%c\n%c\n%c\n"</span>,a,b,c,d,e,f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------------\n"</span>);</span><br><span class="line">    <span class="comment">//读取的时候，则按补码方式读，即如10000000，则判断符号位</span></span><br><span class="line"><span class="number">1</span>，则为负数，再取反加<span class="number">1</span>则为<span class="number">-128</span>；</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n%d\n%d\n%d\n%d\n"</span>,a,b,c,d,e,f);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">-43</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">-128</span></span><br><span class="line"><span class="number">-128</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>signed和unsigned关键字含义：<br>2) signed char:其实内部存储和读取同char,可用于表示单字节有符号数；<br>3) unsigned char:即存储时还是按照补码存储，但是读取时是原码无符号取；所以存负数时，读取为正数；可用于存储单字节的无符号数；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ua=<span class="number">-21</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ub=<span class="number">23</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> uc =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ud = <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ue = <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> uf = <span class="number">128</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n%d\n%d\n%d\n%d\n"</span>,ua,ub,uc,ud,ue,uf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    输出：</span><br><span class="line">       <span class="number">235</span> (存补码：<span class="number">-23</span>-&gt;(<span class="number">1001</span> <span class="number">0101</span>-&gt;<span class="number">1110</span> <span class="number">1011</span>)-&gt;读出时按无符号：<span class="number">11101011</span>==<span class="number">235</span>）</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">255</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">128</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>4) char *:char指针若是初始化为字符串，则这个字符串是存放在常量数据区，不是在栈区，所以不能够改动，但是可以改动指针的值；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p =<span class="string">"ddd"</span>;</span><br><span class="line">*(p+<span class="number">1</span>)=<span class="string">'3'</span>;编译报错；</span><br><span class="line">      <span class="keyword">char</span> *p = <span class="string">"abcdef"</span>;</span><br><span class="line">      <span class="keyword">char</span> *p2 = p;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p2);</span><br><span class="line">      <span class="keyword">char</span> p3[]=<span class="string">"dddd"</span>;</span><br><span class="line">      p=p3;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p3);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br></pre></td></tr></table></figure>
</li>
<li><p>5）关于c++的 宽char类型： char16_t char32_t w_char</p>
</li>
</ul>
<h5 id="整数类型-short-int-long-等"><a href="#整数类型-short-int-long-等" class="headerlink" title="整数类型:short ,int ,long ,等"></a>整数类型:short ,int ,long ,等</h5><ul>
<li>short(short int)，short和short int是一样的类型，size也一样</li>
<li>short,int，long，long long 默认是有符号的，若想更清晰的使用，可以带unsigned这种；<br>不同的位数系统下，整数类型的size也不相同，有如下系统情况：<br>32 bit systems:<br>LP32 or 2/4/4 (int is 16-bit, long and pointer are 32-bit)<br>Win16 API<br>ILP32 or 4/4/4 (int, long, and pointer are 32-bit);<br>Win32 API<br>Unix and Unix-like systems (Linux, macOS)  </li>
</ul>
<p>64 bit systems:<br>LLP64 or 4/4/8 (int and long are 32-bit, pointer is 64-bit)<br>Win64 API<br>LP64 or 4/8/8 (int is 32-bit, long and pointer are 64-bit)<br>Unix and Unix-like systems (Linux, macOS)  </p>
<p>Other models are very rare. For example, ILP64 (8/8/8: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. UNICOS on Cray).</p>
<img src="/2021/04/03/cpp-type/typeint.png" title="type">
<h5 id="浮点数类型：float-double"><a href="#浮点数类型：float-double" class="headerlink" title="浮点数类型：float,double"></a>浮点数类型：float,double</h5><ul>
<li>float: 单精度浮点数</li>
<li>double :双精度浮点数</li>
<li>long double: 扩展精度的浮点数类型；<br>浮点数的一些特性：<br>1) 正数负数的无穷数<br>2) 负0.0<br>3) NaN not a number<br>数值范围表参考：</li>
</ul>
<img src="/2021/04/03/cpp-type/type1.png" title="type">
<h4 id="复合类型："><a href="#复合类型：" class="headerlink" title="复合类型："></a>复合类型：</h4><h5 id="引用类型：一个已存在的对象或函数的别名"><a href="#引用类型：一个已存在的对象或函数的别名" class="headerlink" title="引用类型：一个已存在的对象或函数的别名"></a>引用类型：一个已存在的对象或函数的别名</h5><ul>
<li>初始化：一个引用要求被一个有效的对象或函数初始化；<br>引用的存储：引用不是对象，所以没必要性占用存储，尽管编译器在必要时可以分配存储空间来实现所需的语义(例如，引用类型的非静态数据成员通常会增加类的大小，以满足存储内存地址的需要)。<br>哪些没有引用：因为引用不是对象，所以没有void的引用，也没有引用的引用，没有指向引用的指针，也没有引用的数组；  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; a[<span class="number">3</span>]; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">int</span>&amp;* p;   <span class="comment">// error</span></span><br><span class="line"><span class="keyword">int</span>&amp; &amp;r;   <span class="comment">// error</span></span><br><span class="line">这些全错；</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>引用类型不能在最高级别上符合cv要求;在声明中没有这方面的语法，如果将限定符添加到typedef-name或decltype说明符或类型模板参数中，则会忽略它</p>
<ul>
<li>引用折叠(缩写)<br>允许通过模板或typedefs中的类型操作形成对引用的引用，这种情况下引用折叠规则适用:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>&amp;  lref;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>&amp;&amp; rref;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">lref&amp;  r1 = n; <span class="comment">// type of r1 is int&amp;</span></span><br><span class="line">lref&amp;&amp; r2 = n; <span class="comment">// type of r2 is int&amp;</span></span><br><span class="line">rref&amp;  r3 = n; <span class="comment">// type of r3 is int&amp;</span></span><br><span class="line">rref&amp;&amp; r4 = <span class="number">1</span>; <span class="comment">// type of r4 is int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这一点，以及在函数模板中使用T&amp;&amp;时用于模板实参推导的特殊规则，形成了使std::forward成为可能的规则</p>
<ul>
<li>左引用<br>1） 左引用可以使用在一个已存在的对象，可选不同的cv限定<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"Ex"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; r1 = s;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; r2 = s;</span><br><span class="line"> </span><br><span class="line">    r1 += <span class="string">"ample"</span>;           <span class="comment">// modifies s</span></span><br><span class="line"><span class="comment">//  r2 += "!";               // error: cannot modify through reference to const</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r2 &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints s, which now holds "Example"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2）它也可以使用在函数参数上：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_string</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    s += s; <span class="comment">// 's' is the same object as main()'s 'str'</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Test"</span>;</span><br><span class="line">    double_string(str);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3）当函数的返回值是左引用时，则函数调用表达式也可以成为表达式的左值：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">char</span>&amp; <span class="title">char_number</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; s, <span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.at(n); <span class="comment">// string::at() returns a reference to char</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Test"</span>;</span><br><span class="line">    char_number(str, <span class="number">1</span>) = <span class="string">'a'</span>; <span class="comment">// the function call is lvalue, can be assigned to</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果： Tast</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>右引用<br>1) 右值引用是用来扩展临时对象的生命周期的；而const类型的左值引用也可以扩展临时对象的声明周期，但是不能被改变；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">"Test"</span>;</span><br><span class="line"><span class="comment">//  std::string&amp;&amp; r1 = s1;           // error: can't bind to lvalue</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; r2 = s1 + s1; <span class="comment">// okay: lvalue reference to const extends lifetime</span></span><br><span class="line"><span class="comment">//  r2 += "Test";                    // error: can't modify through reference to const</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; r3 = s1 + s1;      <span class="comment">// okay: rvalue reference extends lifetime</span></span><br><span class="line">    r3 += <span class="string">"Test"</span>;                    <span class="comment">// okay: can modify through reference to non-const</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r3 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2)更重要的是，当一个函数同时具有右值引用和左值引用时，右值引用重载绑定到右值(包括prvalues和xvalues)，而左值引用重载绑定到左值:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue reference overload f("</span> &lt;&lt; x &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue reference to const overload f("</span> &lt;&lt; x &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue reference overload f("</span> &lt;&lt; x &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">2</span>;</span><br><span class="line">    f(i);  <span class="comment">// calls f(int&amp;)</span></span><br><span class="line">    f(ci); <span class="comment">// calls f(const int&amp;)</span></span><br><span class="line">    f(<span class="number">3</span>);  <span class="comment">// calls f(int&amp;&amp;)</span></span><br><span class="line">           <span class="comment">// would call f(const int&amp;) if f(int&amp;&amp;) overload wasn't provided</span></span><br><span class="line">    f(<span class="built_in">std</span>::move(i)); <span class="comment">// calls f(int&amp;&amp;)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// rvalue reference variables are lvalues when used in expressions</span></span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; x = <span class="number">1</span>;</span><br><span class="line">    f(x);            <span class="comment">// calls f(int&amp; x)</span></span><br><span class="line">    f(<span class="built_in">std</span>::move(x)); <span class="comment">// calls f(int&amp;&amp; x)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3）这允许在合适的时候自动选择移动构造函数、移动赋值操作符和其他支持移动的函数(例如std::vector::push_back())。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="built_in">std</span>::move(v)); <span class="comment">// binds an rvalue reference to v</span></span><br><span class="line">assert(v.empty());</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>fowarding references<br>转发引用是一种特殊类型的引用，它保留了函数参数的值类别，使得可以通过std::forward转发它。转发引用可以是:<br>1)函数模板的函数形参声明为对同一函数模板cv- qualified类型的右值引用:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">f</span>(<span class="title">T</span>&amp;&amp; <span class="title">x</span>) &#123;</span>                    <span class="comment">// x is a forwarding reference</span></span><br><span class="line">    <span class="keyword">return</span> g(<span class="built_in">std</span>::forward&lt;T&gt;(x)); <span class="comment">// and so can be forwarded</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    f(i); <span class="comment">// argument is lvalue, calls f&lt;int&amp;&gt;(int&amp;), std::forward&lt;int&amp;&gt;(x) is lvalue</span></span><br><span class="line">    f(<span class="number">0</span>); <span class="comment">// argument is rvalue, calls f&lt;int&gt;(int&amp;&amp;), std::forward&lt;int&gt;(x) is rvalue</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">g</span>(<span class="title">const</span> <span class="title">T</span>&amp;&amp; <span class="title">x</span>);</span> <span class="comment">// x is not a forwarding reference: const T is not cv-unqualified</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">A</span>(<span class="title">T</span>&amp;&amp; <span class="title">x</span>, <span class="title">U</span>&amp;&amp; <span class="title">y</span>, <span class="title">int</span>* <span class="title">p</span>);</span> <span class="comment">// x is not a forwarding reference: T is not a</span></span><br><span class="line">                             <span class="comment">// type template parameter of the constructor,</span></span><br><span class="line">                             <span class="comment">// but y is a forwarding reference</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)<span class="keyword">auto</span>&amp;&amp; except when deduced from a brace-enclosed initializer <span class="built_in">list</span>:</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; vec = foo();       <span class="comment">// foo() may be lvalue or rvalue, vec is a forwarding reference</span></span><br><span class="line"><span class="keyword">auto</span> i = <span class="built_in">std</span>::begin(vec); <span class="comment">// works either way</span></span><br><span class="line">(*i)++;                   <span class="comment">// works either way</span></span><br><span class="line">g(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(vec)&gt;(vec)); <span class="comment">// forwards, preserving value category</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; x: f()) &#123;</span><br><span class="line">  <span class="comment">// x is a forwarding reference; this is the safest way to use range for loops</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; z = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// *not* a forwarding reference (special case for initializer lists)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Dangling references 悬挂引用：<br>尽管引用一旦初始化，总是引用有效的对象或函数，但是可以创建一个被引用对象的生命周期结束但引用仍可访问的程序(悬空)。访问这样的引用是未定义的行为。一个常见的例子是函数返回对自动变量(局部)的引用:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"Example"</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// exits the scope of s:</span></span><br><span class="line">              <span class="comment">// its destructor is called and its storage deallocated</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; r = f(); <span class="comment">// dangling reference</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r;       <span class="comment">// undefined behavior: reads from a dangling reference</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = f();  <span class="comment">// undefined behavior: copy-initializes from a dangling reference</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="指针类型-32位操作系统为4字节，64位操作系统为8字节"><a href="#指针类型-32位操作系统为4字节，64位操作系统为8字节" class="headerlink" title="指针类型:32位操作系统为4字节，64位操作系统为8字节"></a>指针类型:32位操作系统为4字节，64位操作系统为8字节</h5><p>注意指针也是一个变量，那么也可以传值和返回值；<br>一个指针的值：指向对象或函数，或一个对象的结尾(即对象位置的下一个位置) ,或空指针，或一个无效指针；<br>对多字节的类型，指向它的指针，是指向它的第一个字节，即第一个字节的位置；而指向一个对象的结尾，是指指向这个对象结尾后的第一个字节；<br>Note that two pointers that represent the same address may nonetheless have different values.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">  6 &#123;</span></span><br><span class="line">  <span class="number">7</span>     <span class="keyword">int</span> x,y;</span><br><span class="line">  <span class="number">8</span> &#125; c;</span><br><span class="line">  <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 10 </span>&#123;</span><br><span class="line"> <span class="number">11</span>     <span class="keyword">int</span> *px = &amp;c.x;</span><br><span class="line"> <span class="number">12</span>     <span class="keyword">int</span> *pxe = px+<span class="number">1</span>;</span><br><span class="line"> <span class="number">13</span>     <span class="keyword">int</span> *py = &amp;c.y;</span><br><span class="line"> <span class="number">14</span>     assert(pxe == py);</span><br><span class="line"> <span class="number">15</span>     *pxe = <span class="number">1</span>;<span class="comment">//// undefined behavior even if the assertion does not fire 最好不要这么操作；</span></span><br><span class="line"> <span class="number">16</span>     <span class="built_in">cout</span>&lt;&lt; *pxe&lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"> <span class="number">17</span>     <span class="built_in">cout</span> &lt;&lt; c.y &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"> <span class="number">18</span>     <span class="built_in">cout</span> &lt;&lt; c.x &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0</span></span><br><span class="line"> <span class="number">19</span>     <span class="built_in">cout</span> &lt;&lt; *(px+<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"> <span class="number">20</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">21</span> &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1) 指向普通对象的类型 ，和指针的引用：<br>(1) 语法: S* D;<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>* np = &amp;n; <span class="comment">// pointer to int</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span>* npp = &amp;np; <span class="comment">// non-const pointer to const pointer to non-const int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> (*ap)[<span class="number">2</span>] = &amp;a; <span class="comment">// pointer to array of int</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span> <span class="keyword">int</span> n; &#125;;</span><br><span class="line">S s = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* sp = &amp;s.n; <span class="comment">// pointer to the int that is a member of s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;n;     <span class="comment">// pointer to n</span></span><br><span class="line"><span class="keyword">int</span>&amp; r = *p;     <span class="comment">// reference is bound to the lvalue expression that identifies n ，注意这里是p指向的值的引用</span></span><br><span class="line">r = <span class="number">7</span>;           <span class="comment">// stores the int 7 in n</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p; <span class="comment">// lvalue-to-rvalue implicit conversion reads the value from n 输出为7</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(2) 指针的引用: int n;int <em>p = &n;int </em>&amp;r = p;<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="keyword">int</span> m_value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = &amp;m_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以根据你的需求分配内存</span></span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *p = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;n;</span><br><span class="line">    <span class="keyword">int</span> *&amp;r = p;</span><br><span class="line">    r=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0 </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *pn = &amp;n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    func(pn);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pn &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(3) 一些说明：<br>指向数组的第一个成员的指针可以是用数组初始化，含隐式转换；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span>* p1 = a; <span class="comment">// pointer to the first element a[0] (an int) of the array a</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> b[<span class="number">6</span>][<span class="number">3</span>][<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">3</span>][<span class="number">8</span>] = b; <span class="comment">// pointer to the first element b[0] of the array b,</span></span><br><span class="line">                     <span class="comment">// which is an array of 3 arrays of 8 ints</span></span><br><span class="line">同样的，基类和派生类也是：支持多态</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Derived d;</span><br><span class="line">Base* p = &amp;d;</span><br></pre></td></tr></table></figure></p>
<p>(4) 指向void的指针：<br>指向任何类型对象的指针都可以隐式转换为指向void的指针(可选cv限定);指针值没有改变。反向转换需要static_cast或显式类型转换，会产生原始指针值:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* p1 = &amp;n;</span><br><span class="line"><span class="keyword">void</span>* pv = p1;</span><br><span class="line"><span class="keyword">int</span>* p2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pv);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p2 &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 1</span></span><br></pre></td></tr></table></figure></p>
<p>如果原始指针指向某个多态类型对象中的基类子对象，dynamic_cast可用于获得指向派生类型的完整对象的void<em>。<br>指向void的指针用于传递未知类型的对象，这在C接口中很常见:pthread_create期望用户提供的回调函数接受并返回void</em>。在所有情况下，调用者都有责任在使用之前将指针转换为正确的类型。</p>
<ul>
<li>2) 指向函数的类型:<br>(1) 函数指针可以用非成员函数或静态成员函数的地址进行初始化。由于函数到指针的隐式转换，寻址操作符是可选的:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> (*p1)(<span class="keyword">int</span>) = &amp;f;</span><br><span class="line"><span class="keyword">void</span> (*p2)(<span class="keyword">int</span>) = f; <span class="comment">// same as &amp;f</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>不像函数和函数的引用，函数指针是对象，因此可以进行拷贝，存储在数组和分配等  </p>
<p>(2)函数指针的一些例子<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Syntax	meaning</span><br><span class="line">int (* f)()	f is a pointer to a function with prototype int func().</span><br><span class="line">int (* f())()	f is a function taking no inputs and returning a pointer to a function with prototype int func().</span><br><span class="line">int * f()	f is a function returning a pointer-to-int.</span><br><span class="line">int (* a[])()	a is an array of pointers to functions each with prototype int func().</span><br><span class="line"><span class="keyword">int</span> (* f())[]	f is a function returning a pointer to an <span class="built_in">array</span>.</span><br><span class="line"><span class="keyword">int</span> (f[])()	Not allowed. Can't have an <span class="built_in">array</span> of functions.</span><br><span class="line">int * const *(*g)(float)	g is pointer to a function with prototype int * const * func(float) where its return value int * const * is a pointer to a read-only pointer-to-int.</span><br></pre></td></tr></table></figure></p>
<p>(3)模板和函数指针：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">f</span><span class="params">(T n)</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*p)(<span class="keyword">int</span>) = f; <span class="comment">// instantiates and selects f&lt;int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>3) 指向类成员变量的类型<br>(1) 指向非静态成员对象m的指针是C类的成员，可以用表达式&amp;C::m进行初始化。像&amp;(C::m)或&amp;m这样的表达式在C的成员函数中不构成指向成员的指针。<br>这样的指针可以用作指针到成员访问操作符的右操作数。<em>操作符- &gt; </em>:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">语法：S C::* D; <span class="comment">//C是类类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> //<span class="title">or</span> <span class="title">struct</span> ,<span class="title">same</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">    &#125; ;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> C::* p= &amp;C::m;<span class="comment">//按照对指针的理解，初看下，是指p是int C::m 这种类型的指针，但是在使用时需要赋值</span></span><br><span class="line">        C c = &#123;<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.*p &lt;&lt; <span class="string">'\n'</span>;<span class="comment">//但是实际上不是，因为可以直接输出，而且可以用c.的形式，说明是它的成员；</span></span><br><span class="line">    </span><br><span class="line">        C b = &#123;<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; b.*p &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//而不同对象输出不同，说明这个指针是对象持有</span></span><br><span class="line">    </span><br><span class="line">        C* cp = &amp;c;</span><br><span class="line">        cp-&gt;m= <span class="number">10</span> ;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;cp-&gt;*p &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">       <span class="comment">// std::cout &lt;&lt;sizeof(struct C) &lt;&lt; endl;//4 not include *p</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="keyword">sizeof</span>(c) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//4 not include *p ,size的时候，还是4，说明这里的形式可能不是简单的塞在结构里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(2)指向可访问的无二义性非虚基类数据成员的指针可以隐式转换为指向派生类相同数据成员的指针:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span> <span class="keyword">int</span> m; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Base::* bp = &amp;Base::m;<span class="comment">//先定义一个指向Base::m的指针，这个作为了Base的"成员"</span></span><br><span class="line">    <span class="keyword">int</span> Derived::* dp = bp;<span class="comment">//赋值后，Derived的"成员"指针，也指向了bp,Base::m</span></span><br><span class="line">    Derived d;</span><br><span class="line">    d.m = <span class="number">1</span>;<span class="comment">//对m赋值后</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d.*dp &lt;&lt; <span class="string">' '</span> &lt;&lt; d.*bp &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 1 1 ,取出的两个都是实际值是m</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(3)在相反的方向转化,从一个指向派生类的数据成员指针明确非虚拟基类的数据成员,允许static_cast和显式类型转换,即使基类没有成员(但最终派生类,当指针用于访问):<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123; <span class="keyword">int</span> m; &#125;;<span class="comment">//派生类有这个成员，但是基类没有</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Derived::* dp = &amp;Derived::m; <span class="comment">//派生类的指针</span></span><br><span class="line">    <span class="keyword">int</span> Base::* bp = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> Base::*&gt;(dp);<span class="comment">//基类上要动态转换，但是即使这样</span></span><br><span class="line"> </span><br><span class="line">    Derived d;</span><br><span class="line">    d.m = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d.*bp &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// okay: prints 7</span></span><br><span class="line"> </span><br><span class="line">    Base b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.*bp &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// undefined behavior，也无法访问到派生类"成员指针"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(4)指向成员的指针类型可以是指向成员的指针本身:指向成员的指针可以是多级的，在每一级都可以有不同的cv限定。也允许指针和指针到成员的混合多层次组合: 这代码看着贼恶心了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">// const pointer to non-const member</span></span><br><span class="line">    <span class="keyword">int</span> A::* <span class="keyword">const</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// non-const pointer to data member which is a const pointer to non-const member</span></span><br><span class="line">    <span class="keyword">int</span> A::* <span class="keyword">const</span> A::* p1 = &amp;A::p;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> A a = &#123;<span class="number">1</span>, &amp;A::m&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.*(a.*p1) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// regular non-const pointer to a const pointer-to-member</span></span><br><span class="line">    <span class="keyword">int</span> A::* <span class="keyword">const</span>* p2 = &amp;a.p;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.**p2 &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>4) 指向类成员函数的类型：<br>指向非静态成员函数f的指针是类C的成员，可以完全用表达式&amp;C::f进行初始化。C成员函数中的&amp;(C::f)或&amp;f这样的表达式不构成指向成员函数的指针。<br>这样的指针可以用作指针到成员访问操作符的右操作数。- &gt; <em>和. </em>。结果表达式只能用作函数调用操作符的左操作数:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (C::* p)(<span class="keyword">int</span>) = &amp;C::f; <span class="comment">// pointer to member function f of class C</span></span><br><span class="line">    C c;</span><br><span class="line">    (c.*p)(<span class="number">1</span>);                  <span class="comment">// prints 1</span></span><br><span class="line">    C* cp = &amp;c;</span><br><span class="line">    (cp-&gt;*p)(<span class="number">2</span>);                <span class="comment">// prints 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>指向基类成员函数的指针可以隐式转换为指向派生类相同成员函数的指针:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (Base::* bp)(<span class="keyword">int</span>) = &amp;Base::f;</span><br><span class="line">    <span class="keyword">void</span> (Derived::* dp)(<span class="keyword">int</span>) = bp;</span><br><span class="line">    Derived d;</span><br><span class="line">    (d.*dp)(<span class="number">1</span>);</span><br><span class="line">    (d.*bp)(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在相反的方向转化,从一个指向派生类的成员函数指针明确非虚拟基类的成员函数,允许static_cast和显式类型转换,即使基类没有成员函数(但最终派生类,当指针用于访问):就是未定义行为：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (Derived::* dp)(<span class="keyword">int</span>) = &amp;Derived::f;</span><br><span class="line">    <span class="keyword">void</span> (Base::* bp)(<span class="keyword">int</span>) = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> (Base::*)(<span class="keyword">int</span>)&gt;(dp);</span><br><span class="line"> </span><br><span class="line">    Derived d;</span><br><span class="line">    (d.*bp)(<span class="number">1</span>); <span class="comment">// okay: prints 1</span></span><br><span class="line"> </span><br><span class="line">    Base b;</span><br><span class="line">    (b.*bp)(<span class="number">2</span>); <span class="comment">// undefined behavior</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>成员函数的指针可以用作回调函数或函数对象，通常在应用了std::mem_fn或std::bind之后使用。</p>
<ul>
<li><p>5) 关于空指针的值和空指针的作用<br>(1) 值和初始化：每种类型的指针都有一个特殊的值，称为该类型的空指针值。值为null的指针不指向对象或函数(对空指针进行解引用是未定义的行为)，它与值为null的所有相同类型的指针进行比较。<br> 要初始化指向null的指针或将null值赋给现有指针，可以使用空指针字面量nullptr、空指针常量null或从整数值0的隐式转换。零初始化和值初始化也初始化指向空值的指针。<br>(2) 作用：空指针可以用来表示没有对象(例如function::target())，或者作为其他错误条件指示器(例如dynamic_cast)。通常，接收指针参数的函数几乎总是需要检查值是否为空，并以不同的方式处理这种情况(例如，当传递空指针时，delete表达式不做任何操作)。</p>
</li>
<li><p>6) 关于cv修饰指针：<br>If cv appears before <em> in the pointer declaration, it is part of decl-specifier-seq and applies to the pointed-to object. 在</em>前面，则为修饰变量<br>If cv appears after <em> in the pointer declaration, it is part of declarator and applies to the pointer that’s being declared. 在</em>后面，则为修饰指针  </p>
</li>
</ul>
<p>Syntax           meaning<br>const T<em>         pointer to constant object<br>T const</em>         pointer to constant object<br>T<em> const         constant pointer to object<br>const T</em> const   constant pointer to constant object<br>T const* const   constant pointer to constant object</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="comment">// pc is a non-const pointer to const int</span></span><br><span class="line"><span class="comment">// cpc is a const pointer to const int</span></span><br><span class="line"><span class="comment">// ppc is a non-const pointer to non-const pointer to const int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">10</span>, *pc = &amp;ci, *<span class="keyword">const</span> cpc = pc, **ppc;</span><br><span class="line"><span class="comment">// p is a non-const pointer to non-const int</span></span><br><span class="line"><span class="comment">// cp is a const pointer to non-const int</span></span><br><span class="line"><span class="keyword">int</span> i, *p, *<span class="keyword">const</span> cp = &amp;i;</span><br><span class="line"> </span><br><span class="line">i = ci;    <span class="comment">// okay: value of const int copied into non-const int</span></span><br><span class="line">*cp = ci;  <span class="comment">// okay: non-const int (pointed-to by const pointer) can be changed</span></span><br><span class="line">pc++;      <span class="comment">// okay: non-const pointer (to const int) can be changed</span></span><br><span class="line">pc = cpc;  <span class="comment">// okay: non-const pointer (to const int) can be changed</span></span><br><span class="line">pc = p;    <span class="comment">// okay: non-const pointer (to const int) can be changed</span></span><br><span class="line">ppc = &amp;pc; <span class="comment">// okay: address of pointer to const int is pointer to pointer to const int</span></span><br><span class="line"> </span><br><span class="line">ci = <span class="number">1</span>;    <span class="comment">// error: const int cannot be changed</span></span><br><span class="line">ci++;      <span class="comment">// error: const int cannot be changed</span></span><br><span class="line">*pc = <span class="number">2</span>;   <span class="comment">// error: pointed-to const int cannot be changed</span></span><br><span class="line">cp = &amp;ci;  <span class="comment">// error: const pointer (to non-const int) cannot be changed</span></span><br><span class="line">cpc++;     <span class="comment">// error: const pointer (to const int) cannot be changed</span></span><br><span class="line">p = pc;    <span class="comment">// error: pointer to non-const int cannot point to const int</span></span><br><span class="line">ppc = &amp;p;  <span class="comment">// error: pointer to pointer to const int cannot point to</span></span><br><span class="line">           <span class="comment">// pointer to non-const int</span></span><br></pre></td></tr></table></figure>
<ul>
<li>7) 关于智能指针</li>
<li>8) 关于stl中的迭代器，替代指针的方案；</li>
<li>9) 扩展：关于c++的cv概念：<a href="https://en.cppreference.com/w/cpp/language/cv" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/cv</a> 即const 和volatile</li>
<li>10）为了辅助指针的类型判断，提供了这类函数：std::is_member_pointer<br><a href="https://en.cppreference.com/w/cpp/types/is_member_pointer" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/types/is_member_pointer</a></li>
</ul>
<h5 id="数组类型：-数组可以容纳所有内建类型，字符，指针，int等数字类型；"><a href="#数组类型：-数组可以容纳所有内建类型，字符，指针，int等数字类型；" class="headerlink" title="数组类型： 数组可以容纳所有内建类型，字符，指针，int等数字类型；"></a>数组类型： 数组可以容纳所有内建类型，字符，指针，int等数字类型；</h5><ul>
<li>1）数组索引，数组元素支持和不支持，cv限定，内存情况：存放内建类型，连续物理地址存放；访问时++索引或地址即可；<br>数组索引：声明的形式T [N];,声明一个数组对象,由连续N 个T类型的对象，分配一个数组的元素编号0,…,N - 1,和可能访问下标运算符[],在[0],…,(N - 1)。<br>数组元素类型：数组可以从任何基本类型(void除外)、指针、指向成员的指针、类、枚举，或者从其他已知边界的数组(在这种情况下，该数组被称为多维数组)构造。换句话说，<br>除了未知范围的数组类型之外，只有对象类型才能成为数组类型的元素类型。不完整元素类型的数组类型也是不完整类型。 不支持引用的数组和函数的数组；<br>cv限定：将cv限定符应用于数组类型(通过类型定义或模板类型操作)将限定符应用于元素类型，但是任何元素属于cv限定类型的数组类型都被认为具有相同的cv限定符  </li>
<li><p>2)  数组的赋值：<br>数组类型的对象不能作为一个整体被修改:即使它们是左值(例如数组的地址可以被取走)，它们也不能出现在赋值操作符的左边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, b[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = &amp;a; <span class="comment">// okay: address of a can be taken</span></span><br><span class="line">a = b;            <span class="comment">// error: a is an array</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> c[<span class="number">3</span>]; &#125; s1, s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">s1 = s2; <span class="comment">// okay: implicity-defined copy assignment operator</span></span><br><span class="line">         <span class="comment">// can assign data members of array type</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3）数组和指针之间的隐式转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"> </span><br><span class="line">void g(int (&amp;a)[3])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* p = a;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> a &lt;&lt; <span class="string">'\n'</span>  <span class="comment">// prints size of array</span></span><br><span class="line">              &lt;&lt; <span class="keyword">sizeof</span> p &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints size of a pointer</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// where arrays are acceptable, but pointers aren't, only arrays may be used</span></span><br><span class="line">    g(a); <span class="comment">// okay: function takes an array by reference</span></span><br><span class="line"><span class="comment">//  g(p); // error</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n: a)              <span class="comment">// okay: arrays can be used in range-for loops</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>; <span class="comment">// prints elements of the array</span></span><br><span class="line"><span class="comment">//  for(int n: p)              // error</span></span><br><span class="line"><span class="comment">//      std::cout &lt;&lt; n &lt;&lt; ' ';</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::iota(<span class="built_in">std</span>::begin(a), <span class="built_in">std</span>::end(a), <span class="number">7</span>); <span class="comment">// okay: begin and end take arrays</span></span><br><span class="line"><span class="comment">//  std::iota(std::begin(p), std::end(p), 7); // error</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// where pointers are acceptable, but arrays aren't, both may be used:</span></span><br><span class="line">    f(a); <span class="comment">// okay: function takes a pointer</span></span><br><span class="line">    f(p); <span class="comment">// okay: function takes a pointer</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="string">'\n'</span> <span class="comment">// prints the first element</span></span><br><span class="line">              &lt;&lt; *p &lt;&lt; <span class="string">'\n'</span> <span class="comment">// same</span></span><br><span class="line">              &lt;&lt; *(a + <span class="number">1</span>) &lt;&lt; <span class="string">' '</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>  <span class="comment">// prints the second element</span></span><br><span class="line">              &lt;&lt; *(p + <span class="number">1</span>) &lt;&lt; <span class="string">' '</span> &lt;&lt; p[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// same</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4）数组的数组，数组存放struct<br>数组的数组：多维数组其实在内存中的存放也是连续的，就是数组的每个元素是一个数组，这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dualarray[<span class="number">2</span>][<span class="number">5</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> *pp=&amp;dualarray[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//指向数组元素的指针</span></span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">5</span>]=dualarray; <span class="comment">//使用行指针，指向二维数组的行；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">10</span>;n++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*pp);</span><br><span class="line">            pp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("%d \n",**p);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">数组存放的是<span class="class"><span class="keyword">struct</span>:</span>在内存中实际上也是连续存储的，但是在取值的时候，往往因为类型不同而不能直接取；</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">cc</span> <span class="title">x</span>[3];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cc</span> <span class="title">sa</span>;</span></span><br><span class="line">    sa.a=<span class="number">1</span>;</span><br><span class="line">    sa.b=<span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cc</span> <span class="title">sb</span>;</span></span><br><span class="line">    sb.a=<span class="number">3</span>;</span><br><span class="line">    sb.b=<span class="number">4</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cc</span> <span class="title">sc</span>;</span></span><br><span class="line">    sc.a=<span class="number">5</span>;</span><br><span class="line">    sc.b=<span class="number">6</span>;</span><br><span class="line">    x[<span class="number">0</span>]=sa;</span><br><span class="line">    x[<span class="number">1</span>]=sb;</span><br><span class="line">    x[<span class="number">2</span>]=sc;</span><br><span class="line">    <span class="comment">//struct cc *sp = &amp;x[0];</span></span><br><span class="line">    <span class="keyword">int</span> *sp=&amp;x[<span class="number">0</span>].a;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">7</span>;n++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*sp);</span><br><span class="line">            sp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        输出：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>5) 未知边界的数组：<br>如果在数组的声明中省略了维度值，则声明的类型为“未知维度T的数组”，这是一种不完全类型，除非在带有初始化式的声明中使用 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x[];      <span class="comment">// the type of x is "array of unknown bound of int"</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// the type of a is "array of 3 int"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因为数组元素不能是未知边界的数组，所以多维数组除了第一个维度之外，不能有未知边界:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a[][<span class="number">2</span>]; <span class="comment">// okay: array of unknown bound of arrays of 2 int</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b[<span class="number">2</span>][]; <span class="comment">// error: array has incomplete element type</span></span><br></pre></td></tr></table></figure></p>
<p>指向未知边界数组的指针不能参与指针算术，也不能在下标操作符的左侧使用，但可以解引用。指向未知边界数组的指针和引用不能用于函数形参。<br>数组和指针，引用的隐式转换：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a1[];</span><br><span class="line"><span class="keyword">int</span> (&amp;r1)[] = a1;  <span class="comment">// okay</span></span><br><span class="line"><span class="keyword">int</span> (*p1)[] = &amp;a1; <span class="comment">// okay</span></span><br><span class="line"><span class="keyword">int</span> (*q)[<span class="number">2</span>] = &amp;a1; <span class="comment">// error (but okay in C)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;r2)[] = a2;  <span class="comment">// error</span></span><br><span class="line"><span class="keyword">int</span> (*p2)[] = &amp;a2; <span class="comment">// error (but okay in C)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>6)  指针数组：数组元素是指针</li>
<li>7)  数组和右值：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"> </span><br><span class="line">void f(int (&amp;&amp;x)[2][3])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">&#125; x;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> identity = T;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; sizeof X().i &lt;&lt; '\n';           // size of the array</span><br><span class="line">    f(X().i);                                    <span class="comment">// okay: binds to xvalue</span></span><br><span class="line"><span class="comment">//  f(x.i);                                      // error: cannot bind to lvalue</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    f(<span class="built_in">std</span>::move(a));                             <span class="comment">// okay: binds to xvalue</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">arr_t</span> = <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    f(<span class="keyword">arr_t</span>&#123;&#125;);                                  <span class="comment">// okay: binds to prvalue</span></span><br><span class="line">    f(identity&lt;<span class="keyword">int</span>[][<span class="number">3</span>]&gt;&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;); <span class="comment">// okay: binds to prvalue</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="函数类型："><a href="#函数类型：" class="headerlink" title="函数类型："></a>函数类型：</h5><ul>
<li>1) 函数的声明语法<br>一个函数的声明是介绍函数的名字和类型；函数声明可能出现在任何的scope.在类中的声明是表明一个类成员函数(友元函数除外);<br>函数的类型由返回值类型表明；<br>c++或高版本的c在传统的函数声明上加了其他语法，所以对c++ 来说：<br>(1)传统的函数声明语法<br>(2)扩展的返回值声明：这个字段被放在最外面在这种情况下，decl-specifier-seq必须包含关键字auto  </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">noptr-declarator ( parameter-<span class="built_in">list</span> ) cv(optional) ref(optional) except(optional) attr(optional)	(<span class="number">1</span>)	</span><br><span class="line">noptr-declarator ( parameter-<span class="built_in">list</span> ) cv(optional) ref(optional) except(optional) attr(optional) -&gt; trailing	(<span class="number">2</span>)	(since C++<span class="number">11</span>)</span><br><span class="line">一个函数声明由以下几部分组成：</span><br><span class="line">noptr-declarator - 任何有效的声明，但是若开始于*,&amp;,或&amp;&amp; ,则必须用小括号括起来：<span class="keyword">int</span>（*pf)(<span class="keyword">double</span> x); /<span class="keyword">int</span> (*pf)(<span class="keyword">double</span>); --这里应该指的是函数指针的声明，因为其他带&amp;这几个符号的没见需要小括号的；TODO;</span><br><span class="line">parameter-<span class="built_in">list</span>:  - 参数列表，可能为空；</span><br><span class="line">attr(c++<span class="number">11</span>): 可选的属性列表，它作用于函数的类型而不是函数本身，它标识于函数声明的最后，和函数声明的开头相关联；</span><br><span class="line">cv: --<span class="keyword">const</span>/<span class="keyword">volatile</span>: 只作用于非静态成员函数的声明；</span><br><span class="line">ref:-- 引用声明，只作用于非静态成员函数的声明；</span><br><span class="line">eg:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> &amp;</span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue object\n"</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> &amp;&amp;</span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue object\n"</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> &amp;&amp;</span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"g rvalue  boject\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">except:不属于函数类型的一部分，是异常抛出相关字段；</span><br><span class="line">trailing(c++<span class="number">11</span>): 扩展的返回类型：当返回类型依赖于参数名时很有用：eg:<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">U</span>&gt; <span class="title">auto</span> <span class="title">add</span>(<span class="title">T</span> <span class="title">t</span>, <span class="title">U</span> <span class="title">u</span>) -&gt; <span class="title">decltype</span>(<span class="title">t</span> + <span class="title">u</span>);</span></span><br><span class="line">(PS: c++<span class="number">20</span> 中还支持： requires <span class="literal">true</span>在后面，具体见参考文档)</span><br></pre></td></tr></table></figure>
<p>用法：函数的声明可以和其他声明混合在一起如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// declares an int, an int*, a function, and a pointer to a function</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, *p = <span class="literal">NULL</span>, f(), (*pf)(<span class="keyword">double</span>);</span><br><span class="line"><span class="comment">// decl-specifier-seq is int</span></span><br><span class="line"><span class="comment">// declarator f() declares (but doesn't define)</span></span><br><span class="line"><span class="comment">//                a function taking no arguments and returning int</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    virtual int f(char) const, g(int) &amp;&amp;; // declares two non-static member functions</span><br><span class="line">    virtual int f(char), x; // compile-time error: virtual (in decl-specifier-seq)</span><br><span class="line">                            <span class="comment">// is only allowed in declarations of non-static</span></span><br><span class="line">                            <span class="comment">// member functions</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>2) 函数的返回值<br>函数的返回值不能是一个函数或者数组，但是可以是一个指针或者引用指向他们<br>(1) 使用auto c++11 类型推论<br>文档描述：<br>If the decl-specifier-seq of the function declaration contains the keyword auto, trailing return type may be omitted, and will be deduced by the compiler from the type of the expression used in the return statement. If the return type does not use decltype(auto), the deduction follows the rules of template argument deduction.<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;        <span class="comment">// return type is int</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125; <span class="comment">// return type is const int&amp;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当返回值类型有多种情况时，会被归结为一种类型：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val) <span class="keyword">return</span> <span class="number">123</span>; <span class="comment">// deduces return type int</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3.14f</span>;   <span class="comment">// error: deduces return type float 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当返回值无类型，即为void时，则auto也可以用，decltype(auto)也可以用，但是注意以下情况：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;              <span class="comment">// returns void</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f(); &#125; <span class="comment">// returns void</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span>* <span class="title">x</span><span class="params">()</span> </span>&#123;&#125;             <span class="comment">// error: cannot deduce auto* from void</span></span><br></pre></td></tr></table></figure></p>
<p>当返回值能被推算是归结到相同类型，则允许：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> i;              <span class="comment">// sum’s return type is int</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> sum(i - <span class="number">1</span>) + i; <span class="comment">// okay: sum’s return type is already known</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当返回值类型是初始化列表时，不允许：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125; <span class="comment">// error</span></span><br><span class="line">虚函数和协程不允许使用<span class="keyword">auto</span>推论( c++<span class="number">14</span>/c++<span class="number">20</span>)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125; <span class="comment">// error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当一个函数已经使用auto 类型推论，则不能使用确定类型的声明和decltype，即使是相同类型：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span></span>;               <span class="comment">// declared, not yet defined</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125; <span class="comment">// defined, return type is int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;                <span class="comment">// error: cannot use the deduced type</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) f();     <span class="comment">// error: different kind of deduction</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span></span>;               <span class="comment">// okay: re-declared</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="function"><span class="keyword">friend</span> T <span class="title">frf</span><span class="params">(T)</span></span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">frf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i; &#125; <span class="comment">// not a friend of A&lt;int&gt;</span></span><br><span class="line">                当函数模板使用时：</span><br><span class="line">                <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">auto</span> <span class="title">f</span>(<span class="title">T</span> <span class="title">t</span>) &#123;</span> <span class="keyword">return</span> t; &#125;</span><br><span class="line">typedef decltype(f(1)) fint_t;    // instantiates f&lt;int&gt; to deduce return type</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">auto</span> <span class="title">f</span>(<span class="title">T</span>* <span class="title">t</span>) &#123;</span> <span class="keyword">return</span> *t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> (*p)(<span class="keyword">int</span>*) = &amp;f; &#125; <span class="comment">// instantiates both fs to determine return types,</span></span><br><span class="line">                                  <span class="comment">// chooses second template overload</span></span><br></pre></td></tr></table></figure></p>
<p>当函数模板的特化使用时，必须和返回值相同类型：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">return</span> t; &#125; <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>)</span></span>;      <span class="comment">// okay: return type is int</span></span><br><span class="line"><span class="comment">//template char g(char);     // error: no matching template</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// okay: forward declaration with unknown return type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">g</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">return</span> t; &#125; <span class="comment">// okay: not equivalent to #1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">char</span> <span class="title">g</span><span class="params">(<span class="keyword">char</span>)</span></span>;     <span class="comment">// okay: now there is a matching template</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span>)</span></span>;    <span class="comment">// still matches #1</span></span><br><span class="line"><span class="comment">//void h() &#123; return g(42); &#125; // error: ambiguous</span></span><br></pre></td></tr></table></figure></p>
<p>(2) 使用decltype c++11  用于从参数判断类型<br>int x = 1;<br>decltype(auto) f() { return x; }  // return type is int, same as decltype(x)<br>decltype(auto) f() { return(x); } // return type is int&amp;, same as decltype((x))</p>
<ul>
<li>3) 函数的参数列表<br>(1) 有如下5种语法情况：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">attr(optional) decl-specifier-seq declarator	(1)	int f(int a, int *p, int (*(*x)(double))[3]);</span><br><span class="line">attr(optional) decl-specifier-seq declarator = initializer	(<span class="number">2</span>)	<span class="keyword">int</span> f(<span class="keyword">int</span> a = <span class="number">7</span>, <span class="keyword">int</span> *p = <span class="literal">nullptr</span>, <span class="keyword">int</span> (*(*x)(<span class="keyword">double</span>))[<span class="number">3</span>] = <span class="literal">nullptr</span>);</span><br><span class="line">attr(optional) decl-specifier-seq abstract-declarator(optional)	(3)	int f(int, int *, int (*(*)(double))[3]);</span><br><span class="line">attr(optional) decl-specifier-seq abstract-declarator(optional) = initializer	(<span class="number">4</span>)	<span class="keyword">int</span> f(<span class="keyword">int</span> = <span class="number">7</span>, <span class="keyword">int</span> * = <span class="literal">nullptr</span>, <span class="keyword">int</span> (*(*)(<span class="keyword">double</span>))[<span class="number">3</span>] = <span class="literal">nullptr</span>);</span><br><span class="line">void	(5)	空参数，int f(void)和int f()一样，但是不能用cv描述，</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>, <span class="keyword">int</span>)</span></span>;(不应该只有<span class="keyword">int</span>吗) <span class="function"><span class="keyword">and</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>)</span></span>; 都是错误的,<span class="keyword">void</span>*则可以，在函数模板中，则不能被实例为T=<span class="keyword">void</span></span><br><span class="line">函数可选参数列表可以看：variadic function:手册有实例；</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(2) 关于新特性<br>c++20：如果函数的任何形参使用了占位符(auto或概念类型)，则函数声明将改为缩写的函数模板声明:</p>
<p>(3) 关于函数参数名：仅仅是为了文档化，自我说明；参数被这样解析：<br>首先，类型确定：若是T数组或未只边界的T，则被指向T的指针替代，若是函数类型F，则被指向函数F的指针替代；而对于CV限定，则只会影响函数类型，不会影响参数类型(因为函数只是传递值)：<br>因此： int f(const int p,decltype(p)<em>);和int f(int,const int</em>);是相同的声明；<br>以下声明是一样的：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> s[<span class="number">3</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>* s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">volatile</span> s)</span></span>;</span><br><span class="line">这两个也一样：</span><br><span class="line">int f(int());</span><br><span class="line">int f(int (*g)());</span><br></pre></td></tr></table></figure></p>
<p>形参类型不能是包含引用或指向未知绑定数组的指针(包括此类类型的多层次指针/数组)的类型，也不能是指向形参为此类类型的函数的指针。</p>
<p>而指示可变参数的省略号不必在前面加逗号，即使它跟在指示参数包扩展的省略号后面，因此以下函数模板是完全相同的:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Args..., ...)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Args... ...)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Args......)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>使用这种声明的一个例子是std::is_function的实现</p>
<ul>
<li>4) 函数的定义<br>非成员函数定义只能出现在命名空间作用域中(没有嵌套函数)。成员函数定义也可以出现在类定义体中。它们的语法如下:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">attr(optional) decl-specifier-seq(optional) declarator virt-specifier-seq(optional) function-body</span><br><span class="line">where function-body is one of the following</span><br><span class="line"></span><br><span class="line">ctor-initializer(optional) compound-statement	(<span class="number">1</span>)(初始化式）	</span><br><span class="line">function-<span class="keyword">try</span>-block	(<span class="number">2</span>)	</span><br><span class="line">= <span class="keyword">delete</span> ;	(<span class="number">3</span>)	(since C++<span class="number">11</span>)</span><br><span class="line">= <span class="keyword">default</span> ;	(<span class="number">4</span>)	(since C++<span class="number">11</span>)</span><br><span class="line">即：</span><br><span class="line"><span class="number">1</span>) regular function body</span><br><span class="line"><span class="number">2</span>) function-<span class="keyword">try</span>-block (which is a regular function body wrapped in a <span class="keyword">try</span>/<span class="keyword">catch</span> block)</span><br><span class="line"><span class="number">3</span>) explicitly deleted function definition</span><br><span class="line"><span class="number">4</span>) explicitly defaulted function definition, <span class="function">only allowed <span class="keyword">for</span> special member functions <span class="keyword">and</span> comparison <span class="keyword">operator</span> <span class="title">functions</span> <span class="params">(since C++<span class="number">20</span>)</span></span></span><br><span class="line">attr(C++11)	-	optional list of attributes. These attributes are combined with the attributes after the identifier in the declarator (see top of this page), if any.</span><br><span class="line">decl-specifier-seq	-	the <span class="keyword">return</span> type with specifiers, as in the declaration grammar</span><br><span class="line">declarator	-	function declarator, same as in the function declaration grammar above. as with function declaration, it may be followed by a requires-clause (since C++<span class="number">20</span>)</span><br><span class="line">virt-specifier-seq(C++<span class="number">11</span>)	-	override, final, <span class="keyword">or</span> their combination in any order (only allowed <span class="keyword">for</span> non-<span class="keyword">static</span> member functions)  notice</span><br><span class="line">ctor-initializer	-	member initializer <span class="built_in">list</span>, only allowed in constructors</span><br><span class="line">compound-statement	-	the brace-enclosed sequence of statements that constututes the body of a function</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>eg:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (a &gt; b)? a : b;</span><br><span class="line">    <span class="keyword">return</span> (m &gt; c)? m : c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// decl-specifier-seq is "int"</span></span><br><span class="line"><span class="comment">// declarator is "max(int a, int b, int c)"</span></span><br><span class="line"><span class="comment">// body is &#123; ... &#125;函数体是一个复合语句(由0条或多条语句组成的由一对花括号括起来的序列)，在进行函数调用时执行。</span></span><br><span class="line">说明：</span><br><span class="line">形参类型以及函数定义的返回类型不能是不完整的类类型，除非函数定义为deleted(自c++ <span class="number">11</span>以来)。完整性检查是在函数体的上下文中进行的，这允许成员函数返回定义它们的类(或其外围类)，即使它在定义点是不完整的(在函数体中是完整的)。在函数定义的声明符中声明的参数在函数体的作用域中。如果在函数体中没有使用参数，则不需要对其命名(使用抽象声明符就足够了)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span> <span class="comment">// second parameter is not used</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line">尽管形参上的顶级cv限定符在函数声明中被丢弃，但它们将形参的类型修改为函数体中可见的类型:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> <span class="comment">// declares function of type void(int)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// but in the body, the type of n is const int</span></span><br><span class="line">&#125;这样就防止一些函数体内的修改(主要是引用等时，定义者来根据这个判断)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>5) 删除的函数：<br>If, instead of a function body, the special syntax = delete ; is used, the function is defined as deleted. Any use of a deleted function is ill-formed (the program will not compile). This includes calls, both explicit (with a function call operator) and implicit (a call to deleted overloaded operator, special member function, allocation function etc), constructing a pointer or pointer-to-member to a deleted function, and even the use of a deleted function in an unevaluated expression. However, implicit ODR-use of a non-pure virtual member function that happens to be deleted is allowed.</li>
</ul>
<p>If the function is overloaded, overload resolution takes place first, and the program is only ill-formed if the deleted function was selected.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sometype</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line">sometype* p = <span class="keyword">new</span> sometype; <span class="comment">// error: attempts to call deleted sometype::operator new</span></span><br><span class="line"></span><br><span class="line">删除的函数定义必须是翻译单元中的第一个声明:之前声明的函数不能被重新声明为已删除:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sometype</span> &#123;</span> sometype(); &#125;;</span><br><span class="line">sometype::sometype() = <span class="keyword">delete</span>; <span class="comment">// error: must be deleted on the first declaration</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>6) <strong>func</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Within the function body, the function-local predefined variable __func__ is defined as <span class="keyword">if</span> by</span><br><span class="line">k@VM<span class="number">-180</span><span class="number">-38</span>-ubuntu:~$ g++ -o test test.cpp </span><br><span class="line">test.cpp:<span class="number">8</span>:<span class="number">22</span>: warning: ‘__func__’ is <span class="keyword">not</span> defined outside of function scope</span><br><span class="line">    <span class="number">8</span> | <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s=__func__)</span></span>;</span><br><span class="line">      |                      ^~~~~~~~</span><br><span class="line">k@VM<span class="number">-180</span><span class="number">-38</span>-ubuntu:~$ ./test </span><br><span class="line">s:top level</span><br><span class="line">k@VM<span class="number">-180</span><span class="number">-38</span>-ubuntu:~$ cat test.cpp </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static const char __func__[]="functime name";</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s=__func__)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"s:%s\n"</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="枚举类型："><a href="#枚举类型：" class="headerlink" title="枚举类型："></a>枚举类型：</h5><p>枚举类型是一种特殊的类型，他的值被限定在一个范围内，可能会包含几个显示的命名常量表，常量的值是整数的类型<br>定义语法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">enum-key attr(optional) enum-name(optional) enum-base(optional)(C++11) &#123; enumerator-list(optional) &#125;</span><br><span class="line">enum-key attr(optional) enum-name enum-base(optional) ; since c++11</span><br><span class="line"><span class="keyword">enum</span>-key: 枚举关键字： <span class="keyword">enum</span> ,<span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> 或 <span class="title">enum</span> <span class="title">struct</span>其中的一个，后两者<span class="title">since</span> <span class="title">c</span>++11</span></span><br><span class="line"><span class="class"><span class="title">attr</span>(<span class="title">c</span>++11) :</span> 可选，任意数量属性的序列号</span><br><span class="line"><span class="keyword">enum</span>-name: 枚举名称，</span><br><span class="line"></span><br><span class="line">+ 大类型<span class="number">1</span>：unscoped <span class="keyword">enum</span>: 即是<span class="keyword">enum</span>修饰的<span class="keyword">enum</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>1）语法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> <span class="title">name</span><span class="params">(optional)</span> </span>&#123; enumerator = <span class="keyword">constexpr</span> , enumerator = <span class="keyword">constexpr</span> , ... &#125;	(<span class="number">1</span>)	</span><br><span class="line"><span class="keyword">enum</span> name(optional) : type &#123; enumerator = <span class="keyword">constexpr</span> , enumerator = <span class="keyword">constexpr</span> , ... &#125;	(<span class="number">2</span>)	(since C++<span class="number">11</span>)</span><br><span class="line"><span class="keyword">enum</span> name : type ;	(<span class="number">3</span>)	(since C++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color &#123; red, green, blue &#125;;</span><br><span class="line">Color r = red;</span><br><span class="line"><span class="keyword">switch</span>(r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> red  : <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"red\n"</span>;   <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> green: <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"green\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> blue : <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"blue\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2)  枚举中的值，隐式和显式指定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Foo &#123; a, b, c = <span class="number">10</span>, d, e = <span class="number">1</span>, f, g = f + c &#125;;</span><br><span class="line"><span class="comment">//a = 0, b = 1, c = 10, d = 11, e = 1, f = 2, g = 12</span></span><br><span class="line">而且名字可以省略：</span><br><span class="line"><span class="keyword">enum</span> &#123; a, b, c = <span class="number">0</span>, d = a + <span class="number">2</span> &#125;; <span class="comment">// defines a = 0, b = 1, c = 0, d = 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3)  和int的隐试转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> color &#123; red, yellow, green = <span class="number">20</span>, blue &#125;;</span><br><span class="line">color col = red;</span><br><span class="line"><span class="keyword">int</span> n = blue; <span class="comment">// n == 21</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>4）枚举和其他类型的显示转换：<br>整型、浮点型和枚举类型的值可以通过static_cast或显式cast转换为任何枚举类型。如果基础类型不是固定的，并且源值超出范围，则结果是未指定的(直到c++ 17)undefined(因为c++ 17)。(如果源值能够容纳足够容纳目标枚举的所有枚举数的最小位字段，则源值在范围内，如果源值为浮点数则转换为枚举的基础类型。)否则，其结果与隐式转换到底层类型的结果相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">access_t</span> &#123; read = <span class="number">1</span>, write = <span class="number">2</span>, exec = <span class="number">4</span> &#125;; <span class="comment">// enumerators: 1, 2, 4 range: 0..7</span></span><br><span class="line"><span class="keyword">access_t</span> rwe = <span class="keyword">static_cast</span>&lt;<span class="keyword">access_t</span>&gt;(<span class="number">7</span>);</span><br><span class="line">assert((rwe &amp; read) &amp;&amp; (rwe &amp; write) &amp;&amp; (rwe &amp; exec));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">access_t</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">access_t</span>&gt;(<span class="number">8.0</span>); <span class="comment">// undefined behavior since C++17</span></span><br><span class="line"><span class="keyword">access_t</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">access_t</span>&gt;(<span class="number">8</span>); <span class="comment">// undefined behavior since C++17</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> foo &#123; a = <span class="number">0</span>, b = UINT_MAX &#125;; <span class="comment">// range: [0, UINT_MAX]</span></span><br><span class="line">foo x= foo(<span class="number">-1</span>); <span class="comment">// undefined behavior since C++17, even if foo's underlying type is unsigned int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>5)  类中枚举的使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> direction &#123; left = <span class="string">'l'</span>, right = <span class="string">'r'</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line">X* p = &amp;x;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a = X::direction::left; <span class="comment">// allowed only in C++11 and later</span></span><br><span class="line"><span class="keyword">int</span> b = X::left;</span><br><span class="line"><span class="keyword">int</span> c = x.left;</span><br><span class="line"><span class="keyword">int</span> d = p-&gt;left;</span><br></pre></td></tr></table></figure>
</li>
<li><p>大类型2：scoped enum:即是enum class 或enum struct修饰的enum<br>和unscoped enum的区别在于，修饰符号不同+不能和int做隐试转换+可以使用类的一些用法：</p>
</li>
<li><p>1) 语法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">struct</span>|<span class="title">class</span> <span class="title">name</span> &#123;</span> enumerator = <span class="keyword">constexpr</span> , enumerator = <span class="keyword">constexpr</span> , ... &#125;	(<span class="number">1</span>)	</span><br><span class="line"><span class="keyword">enum</span> struct|class name : type &#123; enumerator = <span class="keyword">constexpr</span> , enumerator = <span class="keyword">constexpr</span> , ... &#125;	(<span class="number">2</span>)	</span><br><span class="line"><span class="keyword">enum</span> struct|class name ;	(<span class="number">3</span>)	</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">struct</span>|<span class="title">class</span> <span class="title">name</span> :</span> type ;	(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2) 不能和int做隐式转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span> red, green = <span class="number">20</span>, blue &#125;;</span><br><span class="line">Color r = Color::blue;</span><br><span class="line"><span class="keyword">switch</span>(r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> Color::red  : <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"red\n"</span>;   <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Color::green: <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"green\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Color::blue : <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"blue\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int n = r; // error: no scoped enum to int conversion</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(r); <span class="comment">// OK, n = 21</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3) 如果满足以下条件，则unscoped和scoped都可以用以下初始化式：<br>初始化是直接列表初始化，<br>初始化器列表只有一个元素，<br>unscoped或scoped的枚举是固定的基础类型，<br>转换是非缩小的  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> byte : <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123;&#125;; <span class="comment">// byte is a new integer type</span></span><br><span class="line">byte b &#123; <span class="number">42</span> &#125;; <span class="comment">// OK as of C++17 (direct-list-initialization)</span></span><br><span class="line">byte c = &#123; <span class="number">42</span> &#125;; <span class="comment">// error</span></span><br><span class="line">byte d = byte&#123; <span class="number">42</span> &#125;; <span class="comment">// OK as of C++17; same value as b</span></span><br><span class="line">byte e &#123; <span class="number">-1</span> &#125;; <span class="comment">// error</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> byte b; &#125;;</span><br><span class="line">A a1 = &#123; &#123; <span class="number">42</span> &#125; &#125;; <span class="comment">// error (copy-list-initialization of a constructor parameter)</span></span><br><span class="line">A a2 = &#123; byte&#123; <span class="number">42</span> &#125; &#125;; <span class="comment">// OK as of C++17</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(byte)</span></span>;</span><br><span class="line">f(&#123; <span class="number">42</span> &#125;); <span class="comment">// error (copy-list-initialization of a function parameter)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Handle</span> :</span> <span class="built_in">std</span>::<span class="keyword">uint32_t</span> &#123; Invalid = <span class="number">0</span> &#125;;</span><br><span class="line">Handle h &#123; <span class="number">42</span> &#125;; <span class="comment">// OK as of C++17</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>4) 作为一种类型，它也可以这样使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> Direction&amp; rhs) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> dir;</span><br><span class="line">  <span class="keyword">switch</span> (rhs) &#123;</span><br><span class="line">    <span class="keyword">case</span> Direction::NORTH: dir = <span class="string">"NORTH"</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Direction::EAST:  dir = <span class="string">"EAST"</span>;  <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Direction::SOUTH: dir = <span class="string">"SOUTH"</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Direction::WEST:  dir = <span class="string">"WEST"</span>;  <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>c++20开始，可以用using-enum-declaration:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">enum</span> nested-name-specifier(optional) name ;</span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">fruit</span> &#123;</span> orange, apple &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">enum</span> fruit; <span class="comment">// OK: introduces orange and apple into S</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    s.orange;  <span class="comment">// OK: names fruit::orange</span></span><br><span class="line">    S::orange; <span class="comment">// OK: names fruit::orange</span></span><br><span class="line">&#125;</span><br><span class="line">名字冲突导致无法使用：</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">fruit</span> &#123;</span> orange, apple &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">color</span> &#123;</span> red, orange &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">enum</span> fruit; <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// using enum color; // error: color::orange and fruit::orange conflict</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="联合："><a href="#联合：" class="headerlink" title="联合："></a>联合：</h5><p>共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。<br>eg:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="keyword">union</span> S</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">int32_t</span> n;     <span class="comment">// occupies 4 bytes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">uint16_t</span> s[<span class="number">2</span>]; <span class="comment">// occupies 4 bytes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">uint8_t</span> c;     <span class="comment">// occupies 1 byte</span></span><br><span class="line">&#125;;                      <span class="comment">// the whole union occupies 4 bytes</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s = &#123;<span class="number">0x12345678</span>&#125;; <span class="comment">// initializes the first member, s.n is now the active member</span></span><br><span class="line">    <span class="comment">// at this point, reading from s.s or s.c is undefined behavior</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; <span class="string">"s.n = "</span> &lt;&lt; s.n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    s.s[<span class="number">0</span>] = <span class="number">0x0011</span>; <span class="comment">// s.s is now the active member</span></span><br><span class="line">    <span class="comment">// at this point, reading from n or c is UB but most compilers define it</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"s.c is now "</span> &lt;&lt; +s.c &lt;&lt; <span class="string">'\n'</span> <span class="comment">// 11 or 00, depending on platform</span></span><br><span class="line">              &lt;&lt; <span class="string">"s.n is now "</span> &lt;&lt; s.n &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 12340011 or 00115678</span></span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">s.n = <span class="number">12345678</span></span><br><span class="line">s.c is now <span class="number">0</span></span><br><span class="line">s.n is now <span class="number">115678</span></span><br></pre></td></tr></table></figure></p>
<p>类和结构类型struct：和类相关，初始化，位运算</p>
<h4 id="更多类型："><a href="#更多类型：" class="headerlink" title="更多类型："></a>更多类型：</h4><p>c++的类型远不止这些，c++可以允许用户定义自己的类型；以及一些声明中出现的临时类型，总的来说：<br>c++允许这样定义类型：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">declaration</span>;</span></span><br><span class="line"><span class="keyword">union</span> declaration;</span><br><span class="line"><span class="keyword">enum</span> declaration;</span><br><span class="line"><span class="keyword">typedef</span> declaration;</span><br><span class="line">type alias declaration.</span><br><span class="line">还有一些在声明中出现的，c++把它们称为type-id:</span><br><span class="line">在c++程序中，通常需要引用没有名称的类型;其语法称为type-id。id类型名称类型T的语法就是声明一个变量或函数的语法类型的T,标识符中,除了decl-specifier-seq type-specifier-seq声明语法的限制,并且可以定义新类型只有在id类型出现在右边non-<span class="keyword">template</span>类型别名声明。</span><br><span class="line"><span class="keyword">int</span>* p;               <span class="comment">// declaration of a pointer to int</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(p); <span class="comment">// type-id is "int*"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];   <span class="comment">// declaration of an array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">// type-id is "int[3]" (called new-type-id)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> (*(*x[<span class="number">2</span>])())[<span class="number">3</span>];      <span class="comment">// declaration of an array of 2 pointers to functions</span></span><br><span class="line">                          <span class="comment">// returning pointer to array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> (<span class="keyword">int</span> (*(*[<span class="number">2</span>])())[<span class="number">3</span>]); <span class="comment">// type-id is "int (*(*[2])())[3]"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;                    <span class="comment">// declaration of a function taking int and returning void</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; x = f; <span class="comment">// type template parameter is a type-id "void(int)"</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">auto</span>(<span class="keyword">int</span>) -&gt; <span class="keyword">void</span>&gt; y = f; <span class="comment">// same</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;       <span class="comment">// declaration of a vector of int</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;); <span class="comment">// type-id is "std::vector&lt;int&gt;"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> x; &#125; b;         <span class="comment">// creates a new type and declares an object b of that type</span></span><br><span class="line"><span class="keyword">sizeof</span>(struct&#123; <span class="keyword">int</span> x; &#125;);    <span class="comment">// error: cannot define new types in a sizeof expression</span></span><br><span class="line"><span class="keyword">using</span> t = struct &#123; <span class="keyword">int</span> x; &#125;; <span class="comment">// creates a new type and declares t as an alias of that type</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">static</span> <span class="keyword">int</span>); <span class="comment">// error: storage class specifiers not part of type-specifier-seq</span></span><br><span class="line">std::function&lt;inline void(int)&gt; f; // error: neither are function specifiers</span><br><span class="line">声明语法中删除名称的声明器部分被称为抽象声明器。</span><br><span class="line">Type-id可用于以下情况:</span><br><span class="line">to specify the target type in cast expressions;</span><br><span class="line">as arguments to <span class="keyword">sizeof</span>, <span class="keyword">alignof</span>, alignas, <span class="keyword">new</span>, <span class="keyword">and</span> <span class="keyword">typeid</span>;</span><br><span class="line">on the right-hand side of a type alias declaration;</span><br><span class="line">as the trailing <span class="keyword">return</span> type of a function declaration;</span><br><span class="line">as the <span class="keyword">default</span> argument of a <span class="keyword">template</span> type parameter;</span><br><span class="line">as the <span class="keyword">template</span> argument <span class="keyword">for</span> a <span class="keyword">template</span> type parameter;</span><br><span class="line">in dynamic exception specification.</span><br></pre></td></tr></table></figure></p>
<p>其他： 关于静态类型，动态类型和未完成的类型；</p>
<h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><p>c位段结构：<br>位段结构中位段的定义格式为：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> &lt;成员名&gt;:&lt;二进制位数&gt;</span><br><span class="line">例如：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bytedata</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">unsigned</span> a:<span class="number">2</span>;   <span class="comment">/*位段a，占2位*/</span></span><br><span class="line"> <span class="keyword">unsigned</span>:<span class="number">6</span>;  <span class="comment">/*无名位段，占6位，但不能访问*/</span></span><br><span class="line"> <span class="keyword">unsigned</span>:<span class="number">0</span>;     <span class="comment">/*无名位段，占0位，表下一位段从下一字边界开始*/</span></span><br><span class="line"> <span class="keyword">unsigned</span> b:<span class="number">10</span>;  <span class="comment">/*位段b，占10位*/</span></span><br><span class="line"> <span class="keyword">int</span> i;          <span class="comment">/*成员i，从下一字边界开始*/</span></span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure></p>
<p>位段数据的引用:<br>同结构体成员中的数据引用一样，但应注意位段的最大取值范围不要超出二进制位数定的范围，否则超出部分会丢弃。<br>例如：data.a=2;   但  data.a=10;就超出范围（a占2位，最大3）<br>应用：tcpip头等的应用 </p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_type</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_init</title>
    <url>/2021/03/20/tcpip-init/</url>
    <content><![CDATA[<h3 id="linux内核网络子系统的初始化介绍"><a href="#linux内核网络子系统的初始化介绍" class="headerlink" title="linux内核网络子系统的初始化介绍"></a>linux内核网络子系统的初始化介绍</h3><p>基于linux4.8,版本其实现在已经是5.12了，但是因为我装的linux源码版本是4.8，为方便调试，都在这个版本分析，差别不会很大；<br>以下的内核都指的这个linux4.8的内核；环境都在这个上的；<a id="more"></a><br>相关地址：<br>源码查阅：<a href="https://elixir.bootlin.com/linux/latest/source" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/latest/source</a></p>
<h4 id="linux内核网络子系统初始化组成"><a href="#linux内核网络子系统初始化组成" class="headerlink" title="linux内核网络子系统初始化组成"></a>linux内核网络子系统初始化组成</h4><ul>
<li>内核的初始化和各种init函数集合</li>
<li>网络文件系统等初始化：sock_init</li>
<li>协议栈及相关函数结构初始化：inet_init</li>
<li>设备相关初始化</li>
</ul>
<h4 id="内核的初始化过程整体和init函数集合"><a href="#内核的初始化过程整体和init函数集合" class="headerlink" title="内核的初始化过程整体和init函数集合"></a>内核的初始化过程整体和init函数集合</h4><p>内核的初始化，其实就是对应的启动linux的时候，各种数据结构，设备等等初始化的过程；更具体的涉及更多复杂细节，这里只展示关键部分；<br>内核启动时，会进入到head.S/head.c,这个和架构有关，每种linux支持的架构都会有对应的实现文件：<br>在源码查阅中可以看到：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/arch/alpha/kernel/head.S</span><br><span class="line">/arch/arm/kernel/head.S</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>在这些文件中，都能找到其调用start_kernel，这个函数就是用来启动内核；<br>arch/x86/kernel/head64.c, line 195为例：<br>可以看到调用启动内核的函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">start_kernel();</span><br><span class="line">进而找到：</span><br><span class="line">    init/main.c</span><br><span class="line">    简单分析start_kernel函数：截取其中的片段，可以看到其调用各种关键系统的初始化函数：</span><br><span class="line">    setup_log_buf(<span class="number">0</span>);</span><br><span class="line">	pidhash_init();</span><br><span class="line">	vfs_caches_init_early();</span><br><span class="line">	sort_main_extable();</span><br><span class="line">	trap_init();</span><br><span class="line">	mm_init();</span><br><span class="line">    ...</span><br><span class="line">    cred_init();</span><br><span class="line">	fork_init();</span><br><span class="line">	proc_caches_init();</span><br><span class="line">	buffer_init();</span><br><span class="line">	key_init();</span><br><span class="line">	security_init();</span><br><span class="line">	dbg_late_init();</span><br><span class="line">	vfs_caches_init(totalram_pages);</span><br><span class="line">	signals_init();</span><br><span class="line">    ...</span><br><span class="line">    rest_init();</span><br><span class="line">    从名字大概可以知道是初始化哪部分内容，这里每部分深入进去都是很长的内容，这里只去找网络相关的，看起来在rest_init部分了；</span><br><span class="line">    rest_init:</span><br><span class="line">    &#123;</span><br><span class="line">        .... <span class="comment">//可以看到转门新建了一个内核线程来初始化；</span></span><br><span class="line">        kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">	    numa_default_policy();</span><br><span class="line">	    pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">	    rcu_read_lock();</span><br><span class="line"></span><br><span class="line">        kernel_init</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化各种init函数</span></span><br><span class="line">            kernel_init_freeable();</span><br><span class="line">               -&gt;do_basic_setup</span><br><span class="line">                 -&gt;driver_init();</span><br><span class="line">                  --&gt;do_initcalls(); <span class="comment">//这里会通过依赖编译器的方式，寻找到内核中所有的_init 表识的函数，如sock_init,inet_init函数等</span></span><br><span class="line">                  ‘static int __init sock_init(void)’ </span><br><span class="line">                     从而能初始化各种init函数，这种机制，涉及到ld链接脚本，gcc编译器本身的机制，以及elf文件结构，内容较多，等有机会再具体写写</span><br><span class="line">                    这里截取一段：通过objdump vmlinux后看到的能找到的init函数</span><br><span class="line">                    ffffffff820a48e8 l     O .init.data	<span class="number">0000000000000008</span> __initcall_sock_init1 关键函数<span class="number">1</span></span><br><span class="line">                    ffffffff820a4e18 l     O .init.data	<span class="number">0000000000000008</span> __initcall_proto_init4</span><br><span class="line">                    ffffffff820a48f0 l     O .init.data	<span class="number">0000000000000008</span> __initcall_net_inuse_init1</span><br><span class="line">                    ffffffff820a4788 l     O .init.data	<span class="number">0000000000000008</span> __initcall_net_ns_init0</span><br><span class="line">                    ffffffff820a48f8 l     O .init.data	<span class="number">0000000000000008</span> __initcall_net_defaults_init1</span><br><span class="line">                    ffffffff820a4900 l     O .init.data	<span class="number">0000000000000008</span> __initcall_init_default_flow_dissectors1</span><br><span class="line">                    ffffffff820a5020 l     O .init.data	<span class="number">0000000000000008</span> __initcall_sysctl_core_init5</span><br><span class="line">                    ffffffff820a4e20 l     O .init.data	<span class="number">0000000000000008</span> __initcall_net_dev_init4 关键函数<span class="number">2</span></span><br><span class="line">                    ffffffff820a4e28 l     O .init.data	<span class="number">0000000000000008</span> __initcall_neigh_init4</span><br><span class="line">                    ffffffff820a5030 l     O .init.data	<span class="number">0000000000000008</span> __initcall_inet_init5 关键函数<span class="number">3</span></span><br><span class="line">            <span class="comment">//拉取init进程</span></span><br><span class="line">            <span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">		    ret = run_init_process(execute_command);</span><br><span class="line">		    <span class="keyword">if</span> (!ret)</span><br><span class="line">		    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		    panic(<span class="string">"Requested init %s failed (error %d)."</span>,</span><br><span class="line">		          execute_command, ret);</span><br><span class="line">	        &#125;</span><br><span class="line">	    <span class="keyword">if</span> (!try_to_run_init_process(<span class="string">"/sbin/init"</span>) ||</span><br><span class="line">	        !try_to_run_init_process(<span class="string">"/etc/init"</span>) ||</span><br><span class="line">	        !try_to_run_init_process(<span class="string">"/bin/init"</span>) ||</span><br><span class="line">	        !try_to_run_init_process(<span class="string">"/bin/sh"</span>))</span><br><span class="line">	    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="网络文件系统等初始化：sock-init"><a href="#网络文件系统等初始化：sock-init" class="headerlink" title="网络文件系统等初始化：sock_init"></a>网络文件系统等初始化：sock_init</h4><h5 id="代码流程分析"><a href="#代码流程分析" class="headerlink" title="代码流程分析"></a>代码流程分析</h5><h6 id="整体代码："><a href="#整体代码：" class="headerlink" title="整体代码："></a>整体代码：</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">sock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *      Initialize the network sysctl infrastructure.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	err = net_sysctl_init();</span><br><span class="line">    <span class="comment">//初始化网络相关的/proc/sys/下的目录：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    /* Avoid limitations in the sysctl implementation by</span></span><br><span class="line"><span class="comment">	 * registering "/proc/sys/net" as an empty directory not in a</span></span><br><span class="line"><span class="comment">	 * network namespace.</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">	net_header = register_sysctl("net", empty);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//初始化网络空间相关操作等，网络空间用于docker时，每个docker容器之间的网络隔离，类似的还有文件系统隔离等带来的文件系统空间等等；</span></span><br><span class="line">    <span class="comment">//ret = register_pernet_subsys(&amp;sysctl_pernet_ops);</span></span><br><span class="line">    <span class="comment">//register_sysctl_root(&amp;net_sysctl_root);</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *      Initialize skbuff SLAB cache</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	skb_init();</span><br><span class="line">    <span class="comment">//其实就是调用了kmem_cache_create初始化了skbuff,方便之后直接用kmem_cache_alloc分配skbuff</span></span><br><span class="line">    <span class="comment">//关于kmem_cache_create使用：https://docs.oracle.com/cd/E36784_01/html/E36886/kmem-cache-alloc-9f.html</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *      Initialize the protocols module.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    </span><br><span class="line">	init_inodecache();</span><br><span class="line">    <span class="comment">//初始化：kmem_cache_create: socket_alloc:</span></span><br><span class="line">    <span class="comment">/*sock_inode_cachep = kmem_cache_create("sock_inode_cache",</span></span><br><span class="line"><span class="comment">					      sizeof(struct socket_alloc),</span></span><br><span class="line"><span class="comment">					      0,</span></span><br><span class="line"><span class="comment">					      (SLAB_HWCACHE_ALIGN |</span></span><br><span class="line"><span class="comment">					       SLAB_RECLAIM_ACCOUNT |</span></span><br><span class="line"><span class="comment">					       SLAB_MEM_SPREAD | SLAB_ACCOUNT),</span></span><br><span class="line"><span class="comment">					      init_once);</span></span><br><span class="line"><span class="comment">    可以看到这个结构体，是包含了 socket和inode:所有操作网络的接口fd可以通过write等文件系统的函数和socket的特定函数send等</span></span><br><span class="line"><span class="comment">    struct socket_alloc &#123;</span></span><br><span class="line"><span class="comment">	struct socket socket;</span></span><br><span class="line"><span class="comment">	struct inode vfs_inode;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	err = register_filesystem(&amp;sock_fs_type);<span class="comment">//注册socketfs网络文件系统</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_fs;</span><br><span class="line">	sock_mnt = kern_mount(&amp;sock_fs_type);<span class="comment">//挂载网络文件系统，主要调用了通用的接口：vfs_kern_mount(type, MS_KERNMOUNT, type-&gt;name, data);</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(sock_mnt)) &#123;</span><br><span class="line">		err = PTR_ERR(sock_mnt);</span><br><span class="line">		<span class="keyword">goto</span> out_mount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The real protocol initialization is performed in later initcalls.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NETFILTER</span></span><br><span class="line">	err = netfilter_init();<span class="comment">//若配置了netfilter，需要进一步初始化</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	ptp_classifier_init();</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">out_mount:</span><br><span class="line">	unregister_filesystem(&amp;sock_fs_type);</span><br><span class="line">out_fs:</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要真正理解上面的代码，需要了解：<br>1 内存管理相关的，理解kmem_cache高速缓存  –已独立文章分析<br>2 文件系统相关的，理解socketfs是什么存在，以及如何管理sockinode; –有独立文章分析文件系统，待分析socketfs<br>这里简单分析：socketfs是一种特殊的文件系统<br>特殊文件系统：通常是Linux为了方便计算机管理或者提供某些服务而编写。典型的有proc、tmpfs、pipefs、sockfs等。<br>所以sockfs就是为了套接字而设计的伪文件系统，在socket.c中  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">sock_fs_type</span> = &#123;</span></span><br><span class="line">         .name    =  <span class="string">"sockfs"</span>,</span><br><span class="line">         .mount   =  sockfs_mount,</span><br><span class="line">         .kill_sb =  kill_anon_super,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从平常对套接字的使用，如可以用协议栈相关函数connect,bind accept,还可以用read,write进行发送和接收等，很明显后者是读写文件的函数；<br>从这里可以看到socket套接字兼顾两种特性；  sockfs是一个文件系统，自然支持inode，同时socket本身的结构支持协议栈函数；  </p>
<p>使用socket函数创建socket时：<br>socket结构初始化：从alloc_inode -&gt;调用sock_alloc_inode:创建如下结构体：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_alloc</span> &#123;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> <span class="title">socket</span>;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到包含socket,和inode,同时socket结构包含file结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">        …</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">        …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>socket 成员面向的是协议栈，而 vfs_inode 成员面向的是文件系统，这体现了套接字的双重属性。struct file 则是将两者联系起来的枢纽，其面向的是进程。这样就把内核中的套接字，抽象成为一个简单的文件描述符，提供给用户空间使用。  </p>
<p>struct inode由于代表了文件系统中一个实际的文件在内存中的反映，已经不属于进程的范畴，所以 struct inode 不会有上面所谓的共享问题。但是 struct inode 只会在必要的时候创建，在允许的情况下销毁。  </p>
<p>3 sysctl相关的，如何 /proc/net/目录 </p>
<h5 id="数据结构图"><a href="#数据结构图" class="headerlink" title="数据结构图"></a>数据结构图</h5><p>这部分涉及到几个数据结构：<br>1 skbuff: kmem_cache_create后产生的两个头：skbuff_head_cache，skbuff_fclone_cache<br>为后面分配skbuff做准备；<br>2 sysctl:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">proc_sysctl.c</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table_root</span> <span class="title">sysctl_table_root</span> = &#123;</span></span><br><span class="line">	.default_set.dir.header = &#123;</span><br><span class="line">		&#123;&#123;.count = <span class="number">1</span>,</span><br><span class="line">		  .nreg = <span class="number">1</span>,</span><br><span class="line">		  .ctl_table = root_table &#125;&#125;,</span><br><span class="line">		.ctl_table_arg = root_table,</span><br><span class="line">		.root = &amp;sysctl_table_root,</span><br><span class="line">		.<span class="built_in">set</span> = &amp;sysctl_table_root.default_set,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>3 socketfs相关：<br>sock_fs_type</p>
<h4 id="协议栈及相关函数结构初始化：inet-init"><a href="#协议栈及相关函数结构初始化：inet-init" class="headerlink" title="协议栈及相关函数结构初始化：inet_init"></a>协议栈及相关函数结构初始化：inet_init</h4><p>用户层通过socket函数创建socket,会传入三个参数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">domain:</span><br><span class="line">指定协议簇，ipv4/ipv6..</span><br><span class="line">AF_INET      IPv4 Internet protocols </span><br><span class="line"></span><br><span class="line">type: </span><br><span class="line">指定udp/tcp</span><br><span class="line">SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based byte streams.  </span><br><span class="line">                An out-of-band data transmission mechanism may be supported.</span><br><span class="line">SOCK_DGRAM      Supports datagrams (connectionless, unreliable messages of a fixed maximum length).</span><br><span class="line"></span><br><span class="line">protocol:</span><br><span class="line">通常只存在一个协议来支持 给定协议族中的特定套接字类型，在这种情况下，protocol可以指定为<span class="number">0</span>。</span><br></pre></td></tr></table></figure></p>
<p>然后会返回一个fd来唯一标识这个socket，那内核如何根据传入的三个参数，来选择正确的匹配协议和传输协议类型的相关函数呢？<br>在收到包后，如何根据收到的包，找到匹配的协议相关函数呢？<br>在下面的inet_init初始化后，就搭建好了这个基本的协议栈函数；  </p>
<h5 id="代码结构分析"><a href="#代码结构分析" class="headerlink" title="代码结构分析"></a>代码结构分析</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">inet_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">r</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rc = -EINVAL;</span><br><span class="line"></span><br><span class="line">	sock_skb_cb_check_size(<span class="keyword">sizeof</span>(struct inet_skb_parm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将tcp_prot,udp_prot，注册到(添加到)prot_list链表中；</span></span><br><span class="line">    <span class="comment">//list_add(&amp;prot-&gt;node, &amp;proto_list); 将prot结构挂到链表上；</span></span><br><span class="line">	rc = proto_register(&amp;tcp_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	rc = proto_register(&amp;udp_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_tcp_proto;</span><br><span class="line"></span><br><span class="line">	rc = proto_register(&amp;raw_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_udp_proto;</span><br><span class="line"></span><br><span class="line">	rc = proto_register(&amp;ping_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_raw_proto;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Tell SOCKET that we are alive...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     </span><br><span class="line">	(<span class="keyword">void</span>)sock_register(&amp;inet_family_ops);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //将inet_family_ops注册到地址簇列表中</span></span><br><span class="line"><span class="comment">	(void)sock_register(&amp;inet_family_ops);</span></span><br><span class="line"><span class="comment">    rcu_assign_pointer(net_families[ops-&gt;family], ops); //其实就是把ops放到对应的表net_family中，这个是全局变量，下面会解释</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSCTL</span></span><br><span class="line">	ip_static_sysctl_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Add all the base protocols.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//下面填充 inet_protos[protocol]=struct net_protocol结构；</span></span><br><span class="line">	<span class="keyword">if</span> (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; <span class="number">0</span>)</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot add ICMP protocol\n"</span>, __func__);</span><br><span class="line">	<span class="keyword">if</span> (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; <span class="number">0</span>)</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot add UDP protocol\n"</span>, __func__);</span><br><span class="line">	<span class="keyword">if</span> (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; <span class="number">0</span>)</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot add TCP protocol\n"</span>, __func__);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IP_MULTICAST</span></span><br><span class="line">	<span class="keyword">if</span> (inet_add_protocol(&amp;igmp_protocol, IPPROTO_IGMP) &lt; <span class="number">0</span>)</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot add IGMP protocol\n"</span>, __func__);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//初始化和注册 inetsw[]</span></span><br><span class="line">	<span class="comment">/* Register the socket-side information for inet_create. */</span></span><br><span class="line">	<span class="keyword">for</span> (r = &amp;inetsw[<span class="number">0</span>]; r &lt; &amp;inetsw[SOCK_MAX]; ++r)</span><br><span class="line">		INIT_LIST_HEAD(r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</span><br><span class="line">		inet_register_protosw(q);</span><br><span class="line">    /# 这个函数展开看看,主要是将inetws_array中的元素添加到全局静态链表中inetsw，注意linux特殊的链表连接方式，是结构中的成员为一个结点；</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inet_register_protosw</span><span class="params">(struct inet_protosw *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">lh</span>;</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line">	    <span class="keyword">int</span> protocol = p-&gt;protocol;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">last_perm</span>;</span></span><br><span class="line">    </span><br><span class="line">	    spin_lock_bh(&amp;inetsw_lock);</span><br><span class="line">    </span><br><span class="line">	    <span class="keyword">if</span> (p-&gt;type &gt;= SOCK_MAX)</span><br><span class="line">	    	<span class="keyword">goto</span> out_illegal;</span><br><span class="line">    </span><br><span class="line">	    <span class="comment">/* If we are trying to override a permanent protocol, bail. */</span></span><br><span class="line">	    last_perm = &amp;inetsw[p-&gt;type];<span class="comment">//取出结构</span></span><br><span class="line">	    list_for_each(lh, &amp;inetsw[p-&gt;type]) &#123;</span><br><span class="line">	    	answer = list_entry(lh, struct inet_protosw, <span class="built_in">list</span>);</span><br><span class="line">	    	<span class="comment">/* Check only the non-wild match. */</span></span><br><span class="line">	    	<span class="keyword">if</span> ((INET_PROTOSW_PERMANENT &amp; answer-&gt;flags) == <span class="number">0</span>)</span><br><span class="line">	    		<span class="keyword">break</span>;</span><br><span class="line">	    	<span class="keyword">if</span> (protocol == answer-&gt;protocol)</span><br><span class="line">	    		<span class="keyword">goto</span> out_permanent;</span><br><span class="line">	    	last_perm = lh;</span><br><span class="line">	    &#125;</span><br><span class="line">    </span><br><span class="line">	    <span class="comment">/* Add the new entry after the last permanent entry if any, so that</span></span><br><span class="line"><span class="comment">	     * the new entry does not override a permanent entry when matched with</span></span><br><span class="line"><span class="comment">	     * a wild-card protocol. But it is allowed to override any existing</span></span><br><span class="line"><span class="comment">	     * non-permanent entry.  This means that when we remove this entry, the</span></span><br><span class="line"><span class="comment">	     * system automatically returns to the old behavior.</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    list_add_rcu(&amp;p-&gt;<span class="built_in">list</span>, last_perm);<span class="comment">//将p-&gt;list加到取出的结构中</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    #/</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Set the ARP module up</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//初始化arp和arp_packet_type注册：dev_add_pack(&amp;arp_packet_type);</span></span><br><span class="line">	arp_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Set the IP module up</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//ip路由表初始化</span></span><br><span class="line">	ip_init();</span><br><span class="line">    <span class="comment">//tcp hashinfo相关初始化</span></span><br><span class="line">	tcp_v4_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup TCP slab cache for open requests. */</span></span><br><span class="line">	tcp_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup UDP memory threshold */</span></span><br><span class="line">	udp_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add UDP-Lite (RFC 3828) */</span></span><br><span class="line">	udplite4_register();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ping_table相关初始化</span></span><br><span class="line">	ping_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Set the ICMP layer up</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (icmp_init() &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"Failed to create the ICMP control socket.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Initialise the multicast router</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IP_MROUTE)</span></span><br><span class="line">	<span class="keyword">if</span> (ip_mr_init())</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot init ipv4 mroute\n"</span>, __func__);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (init_inet_pernet_ops())</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot init ipv4 inet pernet ops\n"</span>, __func__);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Initialise per-cpu ipv4 mibs</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (init_ipv4_mibs())</span><br><span class="line">		pr_crit(<span class="string">"%s: Cannot init ipv4 mibs\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">	ipv4_proc_init();</span><br><span class="line"></span><br><span class="line">	ipfrag_init();</span><br><span class="line">    <span class="comment">//注册ip_packet_type</span></span><br><span class="line">	dev_add_pack(&amp;ip_packet_type);</span><br><span class="line"></span><br><span class="line">	rc = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">out_unregister_raw_proto:</span><br><span class="line">	proto_unregister(&amp;raw_prot);</span><br><span class="line">out_unregister_udp_proto:</span><br><span class="line">	proto_unregister(&amp;udp_prot);</span><br><span class="line">out_unregister_tcp_proto:</span><br><span class="line">	proto_unregister(&amp;tcp_prot);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数据结构图-1"><a href="#数据结构图-1" class="headerlink" title="数据结构图"></a>数据结构图</h5><p>int socket(int domain, int type, int protocol);//先放着参考 协议簇，协议类型，协议号<br>上述涉及几个结构，从发送和接收的方向来解释：<br>发送方向：</p>
<ul>
<li>net_families[]:<br>net_families[PF_INET]=inet_family_ops 上面主要初始化了这个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> = &#123;</span></span><br><span class="line">	.family = PF_INET,</span><br><span class="line">	.create = inet_create,</span><br><span class="line">	.owner	= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  但是其实还有如：<br>  /<em> Protocol families, same as address families. </em>/</p>
<pre><code>#define PF_UNSPEC    AF_UNSPEC
#define PF_UNIX        AF_UNIX
#define PF_LOCAL    AF_LOCAL
#define PF_INET        AF_INET
#define PF_AX25        AF_AX25
#define PF_IPX        AF_IPX
int socket(int domain, int type, int protocol);
...
还有这些协议簇，其实对应了上面socket函数传入的参数1；
当我们调用socket创建socket套接字时：
</code></pre><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __sock_create(struct net *net, <span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol,</span><br><span class="line">struct socket **res, <span class="keyword">int</span> kern)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line">     ...</span><br><span class="line">     pf = rcu_dereference(net_families[family]);<span class="comment">//通过传入的第一个参数找到对应的ops</span></span><br><span class="line">     err = pf-&gt;create(net, sock, protocol, kern);<span class="comment">//调用ops的create函数来创建socket</span></span><br><span class="line">     进而调用到套接口层的create函数创建套接口；</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>inetsw，inetsw_array:<br>定义：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">inetsw</span>[<span class="title">SOCK_MAX</span>];</span></span><br><span class="line"><span class="comment">/* This is used to register socket interfaces for IP protocols.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* These two fields form the lookup key.  */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>	 type;	   <span class="comment">/* This is the 2nd argument to socket(2). */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>	 protocol; <span class="comment">/* This is the L4 protocol number.  */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto</span>	 *<span class="title">prot</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	 flags;      <span class="comment">/* See INET_PROTOSW_* below.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>后者初始化了一个静态的写死的表：<br>af_inet.c:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Upon startup we insert all the elements in inetsw_array[] into</span></span><br><span class="line"><span class="comment"> * the linked list inetsw.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	&#123;</span><br><span class="line">		.type =       SOCK_STREAM,</span><br><span class="line">		.protocol =   IPPROTO_TCP,</span><br><span class="line">		.prot =       &amp;tcp_prot,</span><br><span class="line">		.ops =        &amp;inet_stream_ops,</span><br><span class="line">		.flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">			      INET_PROTOSW_ICSK,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.type =       SOCK_DGRAM,</span><br><span class="line">		.protocol =   IPPROTO_UDP,</span><br><span class="line">		.prot =       &amp;udp_prot,</span><br><span class="line">		.ops =        &amp;inet_dgram_ops,</span><br><span class="line">		.flags =      INET_PROTOSW_PERMANENT,</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">		.type =       SOCK_DGRAM,</span><br><span class="line">		.protocol =   IPPROTO_ICMP,</span><br><span class="line">		.prot =       &amp;ping_prot,</span><br><span class="line">		.ops =        &amp;inet_dgram_ops,</span><br><span class="line">		.flags =      INET_PROTOSW_REUSE,</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">	       .type =       SOCK_RAW,</span><br><span class="line">	       .protocol =   IPPROTO_IP,	<span class="comment">/* wild card */</span></span><br><span class="line">	       .prot =       &amp;raw_prot,</span><br><span class="line">	       .ops =        &amp;inet_sockraw_ops,</span><br><span class="line">	       .flags =      INET_PROTOSW_REUSE,</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line">以udp为例：</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">inet_dgram_ops</span> = &#123;</span></span><br><span class="line">	.family		   = PF_INET,</span><br><span class="line">	.owner		   = THIS_MODULE,</span><br><span class="line">	.release	   = inet_release,</span><br><span class="line">	.bind		   = inet_bind,</span><br><span class="line">	.connect	   = inet_dgram_connect,</span><br><span class="line">	.socketpair	   = sock_no_socketpair,</span><br><span class="line">	.accept		   = sock_no_accept,</span><br><span class="line">	.getname	   = inet_getname,</span><br><span class="line">	.poll		   = udp_poll,</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">struct proto udp_prot = &#123;</span><br><span class="line">	.name		   = <span class="string">"UDP"</span>,</span><br><span class="line">	.owner		   = THIS_MODULE,</span><br><span class="line">	.close		   = udp_lib_close,</span><br><span class="line">	.connect	   = ip4_datagram_connect,</span><br><span class="line">	.disconnect	   = udp_disconnect,</span><br><span class="line">	.ioctl		   = udp_ioctl,</span><br><span class="line">	.destroy	   = udp_destroy_sock,</span><br><span class="line">	.setsockopt	   = udp_setsockopt,</span><br><span class="line">	.getsockopt	   = udp_getsockopt,</span><br><span class="line">	.sendmsg	   = udp_sendmsg,</span><br><span class="line">	.recvmsg	   = udp_recvmsg,</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结构的作用，是对传入的参数2： type 协议类型进行函数匹配：<br>继续上面的，调用到create，其实是：inet_create函数；<br>这个函数会创建sock结构，并将从 inetsw_array匹配到的 SOCK_DGRAM/SOCK_STREAM/..对应的ops，进行赋值等；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_create</span><span class="params">(struct net *net, struct socket *sock, <span class="keyword">int</span> protocol,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">int</span> kern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">answer_prot</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> answer_flags;</span><br><span class="line">    ...</span><br><span class="line">    list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</span><br><span class="line"></span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* Check the non-wild match. */</span></span><br><span class="line">		<span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line">			<span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Check for the two wild cases. */</span></span><br><span class="line">			<span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">				protocol = answer-&gt;protocol;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		err = -EPROTONOSUPPORT;</span><br><span class="line">	&#125;</span><br><span class="line">    sock-&gt;ops = answer-&gt;ops;<span class="comment">//关键步骤，所以之后的函数，可以通过ops找到</span></span><br><span class="line">	answer_prot = answer-&gt;prot;<span class="comment">//关键步骤，所以之后的函数，可以通过prot找到</span></span><br><span class="line">	answer_flags = answer-&gt;flags;</span><br><span class="line">    sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot);</span><br></pre></td></tr></table></figure></p>
<p>接收方向：</p>
<ul>
<li>ptype_base,ptype_all,arp_packet_type,ip_packet_type<br>在接收到skbuff后确定是哪种三层包，ip还是arp;,从而找到对应的接收函数；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> <span class="title">arp_packet_type</span> __<span class="title">read_mostly</span> = &#123;</span></span><br><span class="line">	.type =	cpu_to_be16(ETH_P_ARP),</span><br><span class="line">	.func =	arp_rcv,</span><br><span class="line">&#125;;</span><br><span class="line">dev_add_pack(&amp;ip_packet_type);</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> <span class="title">ip_packet_type</span> __<span class="title">read_mostly</span> = &#123;</span></span><br><span class="line">	.type = cpu_to_be16(ETH_P_IP),</span><br><span class="line">	.func = ip_rcv,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>主要是：全局变量：<br>static struct list_head ptype_base[16];    /<em> 16 way hashed list </em>/  dev.c<br>是以下十六个三层协议的列表，每种协议都由，packet_type数据结构表示，列表中的每个元素指向这个结构，<br>形成一个hash表，在dev_add_pack函数时添加到列表中<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *		0800	IP</span></span><br><span class="line"><span class="comment"> *		8100    802.1Q VLAN</span></span><br><span class="line"><span class="comment"> *		0001	802.3</span></span><br><span class="line"><span class="comment"> *		0002	AX.25</span></span><br><span class="line"><span class="comment"> *		0004	802.2</span></span><br><span class="line"><span class="comment"> *		8035	RARP</span></span><br><span class="line"><span class="comment"> *		0005	SNAP</span></span><br><span class="line"><span class="comment"> *		0805	X.25</span></span><br><span class="line"><span class="comment"> *		0806	ARP</span></span><br><span class="line"><span class="comment"> *		8137	IPX</span></span><br><span class="line"><span class="comment"> *		0009	Localtalk</span></span><br><span class="line"><span class="comment"> *		86DD	IPv6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">而  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptype_all</span>;</span>		<span class="comment">/* Taps */</span> 对应了ETH_P_ALL</span><br><span class="line">在skbuff向上传递时；</span><br><span class="line">dev.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __netif_receive_skb_core(struct sk_buff *skb, <span class="keyword">bool</span> pfmemalloc)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">type = skb-&gt;protocol;</span><br><span class="line"><span class="comment">/* deliver only exact match when indicated */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!deliver_exact)) &#123;</span><br><span class="line">		deliver_ptype_list_skb(skb, &amp;pt_prev, orig_dev, type,</span><br><span class="line">				       &amp;ptype_base[ntohs(type) &amp;</span><br><span class="line">						   PTYPE_HASH_MASK]);</span><br><span class="line">....</span><br><span class="line">基于此能传递到正确的三层处理函数；</span><br></pre></td></tr></table></figure></p>
<ul>
<li>inet_protos<br>extern const struct net_protocol __rcu *inet_protos[MAX_INET_PROTOS];<br>inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) //通过类似函数添加；<br>inet_protos[IPPROTO_UDP]=udp_protocol<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> <span class="title">udp_protocol</span> = &#123;</span></span><br><span class="line">	.early_demux =	udp_v4_early_demux,</span><br><span class="line">	.handler =	udp_rcv,</span><br><span class="line">	.err_handler =	udp_err,</span><br><span class="line">	.no_policy =	<span class="number">1</span>,</span><br><span class="line">	.netns_ok =	<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>进而能找到对应的四层函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ip_local_deliver_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__skb_pull(skb, skb_network_header_len(skb));</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> protocol = ip_hdr(skb)-&gt;protocol;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> *<span class="title">ipprot</span>;</span></span><br><span class="line">		<span class="keyword">int</span> raw;</span><br><span class="line"></span><br><span class="line">	resubmit:</span><br><span class="line">		raw = raw_local_deliver(skb, protocol);</span><br><span class="line"></span><br><span class="line">		ipprot = rcu_dereference(inet_protos[protocol]);<span class="comment">//这里去找；</span></span><br><span class="line">		<span class="keyword">if</span> (ipprot) &#123;</span><br></pre></td></tr></table></figure></p>
<p>其他：</p>
<ul>
<li>prot_list:<br>这个结构原先以为会也是类似net_family的作用，但是查了下引用的位置，这个全局的静态链表，inet域支持的所有协议全部在这个链表中，它只是用于在/proc/net/protocols文件中输出当前系统所支持的所有协议。没有其他功能；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sock.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">下面是proc相关的函数；</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">proto_seq_start</span><span class="params">(struct seq_file *seq, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function">	__<span class="title">acquires</span><span class="params">(proto_list_mutex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mutex_lock(&amp;proto_list_mutex);</span><br><span class="line">	<span class="keyword">return</span> seq_list_start_head(&amp;proto_list, *pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">proto_seq_next</span><span class="params">(struct seq_file *seq, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> seq_list_next(v, &amp;proto_list, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一个问题抛出来：<br>接收方向skbuff如何准确传递到正确的socket进而传递数据给对应的用户？<br>关于路由表相关和具体协议相关的结构，等到时候再分析；</p>
<h4 id="设备相关初始化"><a href="#设备相关初始化" class="headerlink" title="设备相关初始化"></a>设备相关初始化</h4><p>设备相关的初始化，是比较复杂的内容，linux很大一部分代码就是各种设备驱动程序代码；在2.6后，采用了通用设备模型来管理设备；<br>网络设备时比较特殊的设备之一；<br>涉及以下几个方面：<br>1 网络设备的表示，一个网络设备通过net_device结构实例来表示，内核通过net_device管理和控制，连接到实际网络设备驱动程序，进而控制设备；<br>2 网络设备的驱动程序；网络设备多种多样，有wifi网卡，有线网卡等，而且跟具体芯片型号等有关，不同种类的设备驱动程序不同；而发送和接收都需要通过驱动程序<br>  处理，并进而交互到设备的固件firmware，从而发送和接收；网络设备驱动程序本质上就是分配和初始化net_device的过程，并提供了各种操作设备的函数；<br>3 网络设备初始化的基本过程：<br>  （1）注册：一个网络设备可用，就必须被内核认可，并且关联正确的驱动程序；驱动程序把驱动设备所需要的所有信息存储在私有数据结构中，然后与其他需要此设备的内核组件交互；<br>  （2）网络设备驱动程序如何分配 设备与内核通信的资源<br>  网络设备驱动程序如何分配 建立设备/内核通信所需要的资源：<br>    即主要是包括：<br>    1) IRQ线初始化，虚拟设备不需要<br>        网络设备NIC必须被分配一个IRQ:然后再必要时如rx,提醒内核； –涉及请求和释放irq线，从/proc/interrupts文件可知当前分配状态；<br>    2)IO端口和内存注册：设备程序将其设备的一个内存区域如其配置寄存器映射到系统内存，这样驱动程序的读写可以通过系统内存进行；<br>        映射函数：request_region,release_region<br>    3)关键知识：<br>      内核和设备之间的交互：<br>      中断或轮询<br>硬件中断：<br>       每一个中断都会运行一个中断处理程序，这些中断响应程序都是设备驱动为设备量身定做的。一般而言，当设备注册一个NIC时，它首先会请求并分配一个IRQ，然后要为IRQ注册（如果设备被卸载了，则需要注销）一个IRQ响应程序。相应的内核代码在kernel/irq/manage.c和arch/XXX/kernel/irq.c。（其中XXX为处理器架构）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_threaded_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler,                                            </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">irq_handler_t</span> thread_fn, <span class="keyword">unsigned</span> <span class="keyword">long</span> irqflags,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line">    注意：irq的注册和释放函数都带有参数dev_id。因为IRQ是可以共享的，因此需要IRQ number和dev_id共同来唯一表示中断。</span><br><span class="line">    另，在注册IRQ时，必须保证IRQ还未有设备请求，除非所有设备都支持IRQ共享。</span><br><span class="line">    内核接收到一个中断信号时，会通过IRQ number调用关联的中断响应程序。IRQ number与中断响应程序以表的形式保存。由于多个设备可能共享IRQ的关系，IRQ number与中断响应程序的关系可能是一对多的。</span><br><span class="line">    中断类型：接收到数据帧、帧传输失败、DMA传输已成功完成、设备已经有足够内存来创建新的传输会话（可用NIC可用内存达到一定数值&lt;一般为设备MTU&gt;时产生一个中断）</span><br><span class="line">    为了防止内核在设备内存不足时多次提交传输请求，设备驱动可以关闭内核出口队列，待到资源足够是才重启。下面是一个范例：</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">netdev_tx_t</span></span><br><span class="line">el3_start_xmit(struct sk_buff *skb, struct net_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    netif_stop_queue (dev);</span><br><span class="line">    ……</span><br><span class="line">    dev-&gt;trans_start = jiffies;</span><br><span class="line">    <span class="keyword">if</span> (inw(ioaddr + TX_FREE) &gt; <span class="number">1536</span>)</span><br><span class="line">        netif_start_queue(dev);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* Interrupt us when the FIFO has room for max-sized packet. */</span></span><br><span class="line">        outw(SetTxThreshold + <span class="number">1536</span>, ioaddr + EL3_CMD);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"> IRQ共享：IRQ线是很有限的资源，为了让一个系统能支持更多的设备，只能让多个设备共享IRQ线。IRQ共享的机制是这样的，内核收到中断请求，然后调用所有与该中断相关联的响应例程，然后有各个响应例程自行判断过滤是否对这个中断进行处理。（注意，IRQ与响应程序是一对多的，发生一个IRQ，哪些响应程序要处理，哪些不需要不是有内核去判断，而是各个中断响应程序自己判断，内核则是调用所有的响应程序。）</span><br><span class="line">IRQ与IRQ响应程序的组织：用全局的<span class="built_in">vector</span>：irq_desc来组织，irq_desc包含所有IRQ，每个IRQ对应自己的链表，链表中是该IRQ关联的所有响应程序。只有IRQ共享时，IRQ链表的节点才会超过一个。</span><br></pre></td></tr></table></figure></p>
<p>  （3）网络设备结构net_device的分配和初始化<br>      module_init和probe<br>     注册和初始化任务的一部分由内核负责（module_init)，其他部分则由设备驱动程序负责(pci扫描到的具体的probe函数)；<br>     部分由内核完成，部分由驱动程序完成（决定如何分配建立设备/内核通信所需资源：irq,IO端口）<br>           1) 通过一组函数指针和驱动设备函数交互<br>           2) 这个结构的初始化部分由内核完成，部分由设备驱动函数完成</p>
<p>4 网络设备相关的初始化相关重要函数：<br>  (1)subsys_init(net_dev_init) 对应抽象设备层(核心模块)<br>  下面的(2)(3)对应特定设备驱动程序<br>  (2)device_init(module_init)<br>  (3)pci_scan(probe) 真正的和真实设备挂钩的初始化，设备模型 kobject pci，这样管理所有设备，并调用xxx_probe–&gt;xxx_setup初始化net_device或其他设备实例；  </p>
<p>  关于抽象设备层解释：<br>  这一层主要提供一些设备无关的处理流程，也提供一些公用的函数给底层的 device driver 调用。<br>它为网络协议提供统一的发送、接收接口。这主要是通过 net_device 结构。是上层的、与设备无关的，<br>这部分根据输入输出请求，通过特定设备驱动程序接口，来与设备进行通信。<br>subsys_initcall(net_dev_init);<br>这个宏定义请参见前面说的 init.h，它被定义为： define_initcall(“4”,fn)<br>所以它是在 core_initcall 和 fs_initcall 之后被调用的。 </p>
<p>  关于特定设备驱动程序解释：<br> 是一种下层的、与设备有关的，常称为设备驱动程序，它直接与相应设备打<br>交道，并且向上层提供一组访问接口； 当一个网络设备的初始化程序被调用时，它返回一个状态指<br>示它所驱动的控制器是否有一个实例。<br>主要包括module_init和probe函数，即最终都是对net_deivce结构的初始化  </p>
<h5 id="代码结构分析-net-dev-init"><a href="#代码结构分析-net-dev-init" class="headerlink" title="代码结构分析 -net_dev_init"></a>代码结构分析 -net_dev_init</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *       This is called single threaded during boot, so no need</span></span><br><span class="line"><span class="comment"> *       to take the rtnl semaphore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">net_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, rc = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!dev_boot_phase);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev_proc_init())<span class="comment">//在/proc/net目录下创建四个proc条目（分别为dev、softnet_stat、ptype和wireless） </span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (netdev_kobject_init())<span class="comment">//暂时不太清除</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;ptype_all);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PTYPE_HASH_SIZE; i++)</span><br><span class="line">		INIT_LIST_HEAD(&amp;ptype_base[i]);<span class="comment">//前面有提到，不赘述</span></span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;offload_base);()</span><br><span class="line">	<span class="keyword">if</span> (register_pernet_subsys(&amp;netdev_net_ops))<span class="comment">//将全局变量netdev_net_ops注册到链表(static struct list_head *first_device = &amp;pernet_list;)上</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Initialise the packet receive queues.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//对于多CPU的系统来说，每个CPU都有一个各自的接收队列，并且使用各自的softnet_data结构体变量*sd来管理网络数据包的收发流量（通过per_cpu函数）。</span></span><br><span class="line">	<span class="comment">//初始化两个sk_buff_head结构体变量process_queue和input_pkt_queue。</span></span><br><span class="line">    for_each_possible_cpu(i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> = &amp;<span class="title">per_cpu</span>(<span class="title">softnet_data</span>, <span class="title">i</span>);</span></span><br><span class="line"></span><br><span class="line">		skb_queue_head_init(&amp;sd-&gt;input_pkt_queue);</span><br><span class="line">		skb_queue_head_init(&amp;sd-&gt;process_queue);</span><br><span class="line">		INIT_LIST_HEAD(&amp;sd-&gt;poll_list);</span><br><span class="line">		sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line">		sd-&gt;csd.func = rps_trigger_softirq;</span><br><span class="line">		sd-&gt;csd.info = sd;</span><br><span class="line">		sd-&gt;cpu = i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		sd-&gt;backlog.poll = process_backlog;</span><br><span class="line">		sd-&gt;backlog.weight = weight_p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev_boot_phase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The loopback device is special if any other network devices</span></span><br><span class="line"><span class="comment">	 * is present in a network namespace the loopback device must</span></span><br><span class="line"><span class="comment">	 * be present. Since we now dynamically allocate and free the</span></span><br><span class="line"><span class="comment">	 * loopback device ensure this invariant is maintained by</span></span><br><span class="line"><span class="comment">	 * keeping the loopback device as the first device on the</span></span><br><span class="line"><span class="comment">	 * list of network devices.  Ensuring the loopback devices</span></span><br><span class="line"><span class="comment">	 * is the first device that appears and the last network device</span></span><br><span class="line"><span class="comment">	 * that disappears.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">//注册网络命令空间设备，确保loopback设备在所有网络设备中最先出现和最后消失</span></span><br><span class="line">	<span class="keyword">if</span> (register_pernet_device(&amp;loopback_net_ops))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (register_pernet_device(&amp;default_device_ops))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">//分别注册网络设备数据包接收和发送的软中断处理程序 </span></span><br><span class="line">	open_softirq(NET_TX_SOFTIRQ, net_tx_action);</span><br><span class="line">	open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br><span class="line">    <span class="comment">//注册回调处理函数dev_cpu_callback </span></span><br><span class="line">	hotcpu_notifier(dev_cpu_callback, <span class="number">0</span>);</span><br><span class="line">	dst_init();<span class="comment">//和通知链相关的初始化</span></span><br><span class="line">	rc = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先备知识：<br>1) 中断相关，软中断和硬中断<br>2) 通知链相关<br>3) 设备模型<br>4) softnet_data相关，这里先不解释；<br>5) other:用户空间辅助程序：<br>    /sbin/modprobe 在内核需要加载某个模块时调用，判断内核传递的模块是不是/etc/modprobe.conf文件中定义的别名<br>    /sbin/hotplug 在内核检测到一个新设备插入或拔出系统时调用，它的任务是根据设备标识加载正确的驱动  </p>
<h5 id="代码结构分析-module-init"><a href="#代码结构分析-module-init" class="headerlink" title="代码结构分析 -module_init:"></a>代码结构分析 -module_init:</h5><p>module_init是一大类的函数，几乎所有的设备都有实现这个函数：xxx_init_module为module_init类型；<br>凡是被 module_init()“修饰”过的函数只能在两种 情况下被调用：一种是被 do_initcalls 调用，一种是<br>在模块插入到系统中时被调用（如果它是模块方式）。每个模块只有一个被 module_init 修饰的函数入口<br>eg: 78. #define module_init(x) __initcall(x);<br>对第一种情况：<br>开机流程初始化有init_call机制，会做几乎所有的init,会包含一个初始化所有设备的module_init,自然就包括了net_device在module_init中的初始化；<br>eg:对回环设备：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~/source_linux/linux-lts-xenial<span class="number">-4.4</span><span class="number">.0</span>$ objdump  -t vmlinux| grep loopback</span><br><span class="line"><span class="number">0000000000000000</span> l    df *ABS*	<span class="number">0000000000000000</span> loopback.c</span><br><span class="line">ffffffff815ec3a0 l     F .text	<span class="number">00000000000000</span>a8 loopback_setup</span><br><span class="line">ffffffff81aa91c0 l     O .rodata	<span class="number">0000000000000198</span> loopback_ethtool_ops</span><br><span class="line">ffffffff81aa8f80 l     O .rodata	<span class="number">0000000000000238</span> loopback_ops</span><br><span class="line">ffffffff815ec450 l     F .text	<span class="number">0000000000000036</span> loopback_dev_free</span><br><span class="line">ffffffff815ec490 l     F .text	<span class="number">0000000000000081</span> loopback_get_stats64</span><br><span class="line">ffffffff815ec520 l     F .text	<span class="number">000000000000009</span>e loopback_xmit</span><br><span class="line">ffffffff815ec5c0 l     F .text	<span class="number">000000000000007</span>d loopback_dev_init</span><br><span class="line">ffffffff815ec640 l     F .text	<span class="number">000000000000009</span>d loopback_net_init <span class="comment">//这个函数</span></span><br></pre></td></tr></table></figure></p>
<p>module_init只是对设备结构等做一个基本的初始化，这个时候还不能使用；或者说linux支持很多种设备，在开机初始化时做的module_init只是一个对支持的设备的初始化，对这个机器是否插入这个硬件设备不依赖，也不代表就可以用了；而要等到pci扫描设备后，对真正存在的设备调用对应的probe函数，读取和初始化真正设备，之后才能使用；<br>具体过程如下：</p>
<h5 id="代码结构分析-module-init-1"><a href="#代码结构分析-module-init-1" class="headerlink" title="代码结构分析 -module_init:"></a>代码结构分析 -module_init:</h5><ul>
<li>pci子系统的基本介绍：<br>内核中的PCI子系统（PCI层）提供各种PCI设备驱动程序共同的所有通用功能；PCI电源管理和网络唤醒<br>1、几个数据结构：/include/linux/mod_devicetable.h<br>A:pci_device_id 设备标示符；<br>B:pci_dev 每个pci上的设备都会分配一个pci_dev实例，如同网络设备会被分配net_device一样，这个结构由内核使用，以引用一个PCi设备；<br>C:pci_driver:定义pci层和设备驱动程序之间的接口；由函数指针构成， 所有pci上的设备都会使用这个结构；<br>D:char <em>name:驱动程序名称；总线上的；<br>E:const struct pci_deivce_id </em>id_table:Id向量，内核用于把一些设备关联到此驱动程序；<br>F:int (<em>probe)当pci层发现他正在搜寻驱动程序设备id和前面的id_table匹配，就会调用此函数。来做类似开启硬件，分配net_deivce结构，初始化并注册新设备；<br> void (</em>remove)和上面相反；<br>G: suspend resume函数和电源管理有关；  </li>
</ul>
<p>2、PCI NIC 设备驱动程序的注册；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_device_id</span> &#123;</span></span><br><span class="line">	__u32 vendor, device;		<span class="comment">/* Vendor and device ID or PCI_ANY_ID*/</span></span><br><span class="line">	__u32 subvendor, subdevice;	<span class="comment">/* Subsystem ID's or PCI_ANY_ID */</span></span><br><span class="line">	__u32 <span class="class"><span class="keyword">class</span>, <span class="title">class_mask</span>;</span>	<span class="comment">/* (class,subclass,prog-if) triplet */</span></span><br><span class="line">	<span class="keyword">kernel_ulong_t</span> driver_data;	<span class="comment">/* Data private to the driver */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>用于独一无二识别pci设备；<br> 每个设备驱动程序都会把一个pci_device_id实例的向量注册到内核；这个实例向量列出了其所能处理的设备ID<br>3、pci设备本身的注册等；<br>4、pci的探测分静态和动态  </p>
<ul>
<li>pci总线系统在开机引导期间：<br>例如linux现在支持PCI域，每个PCI域可以占用多大256个总线，每个总线占用32个设备；<br>1) 系统引导时会建立一种数据库，把每个总线都关联到一份已侦测到而使用该总线的设备列表；如一个总线上挂了多个设备；<br>2)总线上的设备如何注册<br> 当设备驱动程序A（对应总线上的设备A）被加载时，会调用pci_register_driver并提供pci_driver实例而与pci层注册。<br> pci_driver结构中内含一个此驱动程序能驱动的pci设备id的向量（ *id_table),。<br> 接着，pci层使用这个表去查看已侦测到的pci上设备列表中与哪些设备匹配；于是就会建立该驱动程序的设备列表；<br> 接着，对每个匹配的设备，pci层会调用相匹配的驱动程序中的pci_driver结构中提供的probe函数；<br>接着，probe函数会建立并注册相关联的网络设备；接着调用到xx_setup函数；<br>3) 总线上设备除名：<br>当驱动程序稍后卸载时，该模块的module_exit函数会调用pci_unregister_driver，接着由于其数据库，使得pci能遍历所有与该驱动程序相关联的设备；并<br> 启动该设备的remove函数；从网络设备除名；  </li>
</ul>
<h5 id="几个问题："><a href="#几个问题：" class="headerlink" title="几个问题："></a>几个问题：</h5><p>0、module_init和probe函数中都会对net_device结果做更新和初始化，他们怎么调用的？<br>   开机流程初始化有init_call机制，会做几乎所有的init,会包含一个初始化所有设备的module_init,自然就包括了net_device在module_init中的初始化；<br>而开机会做pci扫描，这个时候配置好设备后，会调用对应的probe,过程太过复杂，待研究，只学习较理论方面，见 linux设备模型中的设备驱动模型例子_PCI总线为例，通过扫描pci，接着注册后会调用到各个pci设备的probe函数，进而也调用到了网络设备的probe函数  </p>
<p>1、module_init修饰的函数什么时候调用？<br>凡是被 module_init()“修饰”过的函数只能在两种 情况下被调用：一种是被 do_initcalls 调用，一种是<br>在模块插入到系统中时被调用（如果它是模块方式）。每个模块只有一个被 module_init 修饰的函数入口</p>
<ol start="78">
<li>#define module_init(x) __initcall(x);  </li>
</ol>
<p>所以真正的初始化是 probe函数调用时；  </p>
<h5 id="数据结构图-2"><a href="#数据结构图-2" class="headerlink" title="数据结构图"></a>数据结构图</h5><p>略<br>net_device结构介绍：ref 深入理解linux网络内幕<br>1、介绍：<br>net_device数据结构存储着特定网络设备的所有信息，每个网络设备对应一个net_device结构实例，无论是真实设备(如NIC)或者是虚拟设备(Bonding或VLAN)，并由驱动程序调用相关内核函数进行分配和注册，内核做一些初始化；<br>驱动程序，对这个设备的ops函数做初始化，并定义了相关函数赋值，这样内核通过统一的函数接口就可以掉用到对应的驱动函数；<br>可以说net_device是内核和驱动的桥梁；<br>所有设备的net_device结构放在一个全局变量 dev_base所指的全局列表中，在include/linux/netdevice.h中定义<br>网络设备可以分成几种类型，如Ethernet卡和Token Ring卡；对同一类型的所有设备，会设置某些字段为相同的值，有些则根据设备模型做不同的设置；<br>为了改善性能，驱动程序还可以改写一些已由内核初始化过的字段；<br>1_2: 结构组成：<br>net_device结构的字段可以分成以下几种类型：<br>标识符：net_device有三个标识符，不能搞混：<br>    int ifindex: 独一无二的ID,当设备以dev_new_index注册时分派给每个设备；<br>    int iflink: 这个字段主要是由(虚拟)隧道设备使用，可用于标识抵达隧道另一端的真实设备；<br>    unsigned short dev_id: 目前在zSeries OSA NIC上由IPv6使用，此字段用于区别可由不同OS同时共享的同一种设备的诸多设虚拟实例；见net/ipv6/addrconf.c的注释；  </p>
<p>配置<br>统计数据<br>设备状态<br>列表管理<br>流量管理<br>功能专用<br>通用<br>函数指针  </p>
<p>2、ref 深入理解linux网络内幕：设备注册和初始化：net_device<br>(1) 网络设备何时以及如何在内核注册：静态，热插拔<br>(2) 网络设备如何利用网络设备数据库注册，并指派一个net_device结构的实例<br>(3) net_device结构如何组织到hash表和列表，以便于做各种查询；<br>(4) net_device实例如何初始化，一部分由内核核心函数完成，一部分由其设备驱动程序完成，如ops结构中的函数指针；<br>(5）就注册而言，虚拟设备和真实设备有和区别；  </p>
<p>3、正文：<br>nic（网卡）可用之前，其相关联的net_deivce数据结构必须先初始化，添加到内核网络设备数据库，配置并开启；<br>注册/除名 和开启/关闭 是不同的，前者可以理解为注册和加载驱动/卸载驱动，后者可以理解为开启和关闭网络设备，即关闭相关进程；<br>(1)网络设备注册之时：<br>   A:开机时，加载nic设备驱动程序，insmod类似动作或者调用module_init这种；或者在运行时进行insmod动态加载；<br>           这种情况下，可能会是通过总线设备驱动程序进行pci_driver-&gt;probe的调用，来负责设备注册；<br>  <strong>这里详细说明下：通过pci检测设备并调用probe函数，这个函数是由驱动提供，通过.probe=xxx_probe来实现，并做与module_init相同的事情；</strong><br>  <strong>那么什么时候会用probe函数什么时候用module_init函数？前者是自动检测是用的，后者是运行时动态加载时使用的；</strong>–这个是查询的，需要再确认；<br><strong> 可以看到 若调用probe函数，则为XX_probe–&gt;alloc_dev–&gt;xxx_setup</strong><br>例子：net/wireless/airo.c<br>   B:插入热插拔设备；此时内核会通知其驱动程序，驱动程序再注册该设备；<br>  网络设备除名之时：pci_driver-&gt;remove<br>   1:关机时或者运行时做rmmod，即卸载设备驱动<br>   2:拔出热插拔设备，此时做删除等动作；  </p>
<p>(2)分配net_deivce结构：<br>使用在net/core/dev.c中的alloc_netdev分配，而一般由设备驱动程序进行调用；<br>这个函数的三个参数：由驱动程序提供实参<br>  私有数据结构大小:是驱动程序会使用的私有结构大小<br> ，设备名称，一个字符串，类似于eth0,eth1<br>设置函数：初始化函数指针，用来设置net_device结构的剩余部分；<br>返回值是指向已分配的net_device结构指针；<br>此外，内核也提供一组内含alloc_netdev的包裹函数，可用于为一组通用设备类型提供正确参数给alloc_netdev<br>好几个  </p>
<p>(3)Nic注册和除名的架构（设备驱动程序加载和卸载相关联）<br>依赖于总线；<br>其余部分则是网络设备驱动程序的架构；<br>    结构：私有数据结构+net_deivce+ops<br>    初始化：alloc_dev+register net_device and ops中的函数集合+setup函数以及其他初始化函数；<br>    卸载清理函数；<br>    module_init,module_exit;/xxx_probe xxx_remove_one<br>例子见上；注意一下几点：<br>A:驱动程序可能会使用包裹函数，并只提供其私有数据区大小；<br>B:包裹函数会使用驱动程序提供的参数（包括设备名加初始化函数）来调用alloc_netdev<br>C:alloc_netdev所分配的内存块大小包括net_device结构和驱动程序私有数据块以及强制对齐所补的空白空间；<br>D:有些驱动程序会调用netdev_boot_setup_check函数减产加载内核时用户是否提供了任何引导期间参数；<br>E:新的net_device实例会利用register_netdevice来插入设备数据库；  </p>
<p>(4)设备初始化，包含xxx_setup函数，驱动程序传入的指针对于的函数，会对net_device等做一些初始化；<br>设备初始化包含以下三类：<br>   设备驱动程序的初始化，包括但不止xxx_setup（init函数里面可能也会做一些初始化)，<br>   设备类型：由xxx_setup函数负责;<br>   各种功能：可选和强制功能也必须初始化如队列规则；  </p>
<p>注意：xxx_setup是设备驱动程序传给内核的，但会被设备模型（总线）通过xxx_probe调用到<br>xxx_setup也会做类似于设置mtu,macaddr,hard_head_len,等值；</p>
<p>(5) net_deivce 结构组织介绍：仅说明一些点；<br> 览:net_device数据结构插在一个全局列表和两张hash表中；这些结构可以让内核按需求浏览和查询net_deivce数据库；<br> A: dev_base是一个指针，指向net_deivce链表的头，net_device中的next结果将整个全部设备串起来，这样内核通过这个结构可以轻易浏览设备；取得关键数据等；<br> B: dev_name_head:是一张hash表，以设备名为索引，可以让类似ioctl进行操作；<br> C:dev_index_head:是一张hash表，以设备ID:dev-&gt;ifindex为索引，指向net_device结构指针；如ip,netlink时就是通过dev-&gt;ifindex来索引的；<br>上面两张表，就可以提供获取设备的接口如：dev_get_by_name()和dev_get_by_index; 也可能根据设备类型和mac地址搜寻net_device，此时用的是dev_base<br>    上述三个结构通过dev_base_lock锁保护，所有查询函数在net/core/dev.c中  </p>
<p>(6)设备状态：<br>net_device中有各种字段可以定义设备当前状态；<br>如： flags:开启或关闭,reg_state:注册状态；state:用于队列规则；<br>队列规则状态：<br>每个网络设备都会分配一种队列规则，流量控制并以此来实现其Qos机制；<br>state就是用于这个，是位域，在include/linux/netdeivce.h中；<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">netdev_state_t</span></span><br><span class="line">&#123;</span><br><span class="line">	__LINK_STATE_XOFF=<span class="number">0</span>,</span><br><span class="line">	__LINK_STATE_START, 设备开启，此标示可以由netif_running检查</span><br><span class="line">	__LINK_STATE_PRESENT,</span><br><span class="line">	__LINK_STATE_SCHED,</span><br><span class="line">	__LINK_STATE_NOCARRIER,</span><br><span class="line">	__LINK_STATE_RX_SCHED,</span><br><span class="line">	__LINK_STATE_LINKWATCH_PENDING</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注册状态：<br>reg_state:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* register/unregister state machine */</span></span><br><span class="line"><span class="keyword">enum</span> &#123; NETREG_UNINITIALIZED=<span class="number">0</span>,</span><br><span class="line">       NETREG_REGISTERING,	<span class="comment">/* called register_netdevice */</span></span><br><span class="line">       NETREG_REGISTERED,	<span class="comment">/* completed register todo */</span></span><br><span class="line">       NETREG_UNREGISTERING,	<span class="comment">/* called unregister_netdevice */</span></span><br><span class="line">       NETREG_UNREGISTERED,	<span class="comment">/* completed unregister todo */</span></span><br><span class="line">       NETREG_RELEASED,		<span class="comment">/* called free_netdev */</span></span><br><span class="line">&#125; reg_state;</span><br></pre></td></tr></table></figure></p>
<p>(7)注册函数和除名函数过程：<br>net/core/dev.c中：<br>调用netdev_run_todo处理；书里面将的调用情况，先忽略<br>A:注册详情：即注册时做了什么<br>  注册不仅仅是将net_device插入上述三个结构中，而还有其他动作：如一般有；<br>   1) net_device的一些字段初始化；<br>   2) 内核支持divert功能时，分配配置；<br>   3) 执行xxx_setup函数<br>   4)执行dev_new_index分配一个独一无二的标识码给设备；<br>   5)将net_device加入上面三个结构中；<br>   6)检查，设置状态和标识，初始化队列规则等；<br>   7)调用通知链相关函数；  </p>
<p>B:除名详情，即反注册时做了什么：<br>上面的反过程</p>
<p>(8)设备注册状态的通知：<br>内核组件和用户空间应用程序可能都想知道何时发生网络设备注册，除名，关闭或者开启之事，这类事件的通知通过两种通道传送：<br>  A:netdev_chain:注册通知链；<br>  B:Netlink的RTMGRP_LINK多播群组；<br>A:所有的netdev_chain报告的NETDEV_XXX事件都列在include/linux/notifier.h中；通知链怎么用见前文<br>   如对上面NETDEV_XXX事件感兴趣的可以通过register_netdevice_notifier和unregister_netdevice_notifier注册和反注册，就可以监听到消息；<br>   目前如：路由，防火墙，协议代码，虚拟设备等内核组件都在netdev_chain注册了；</p>
<p>(9) 引用计数：<br>net_device结构无法释放除非所有的引用都已释放；dev-&gt;refcnt中；<br>netdev_wait_allrefs;  </p>
<p>(10)开启和关闭网络设备；<br>设备一旦注册就可以用，但是除非用户或用户应用程序明确开启，否则还是无法传输接收数据<br>net/core/dev.c中dev_open负责；<br>开启设备：<br>   A：dev-&gt;open;<br>  B:设置dev-&gt;state<br>  C:设置flag<br>  D:初始化流量控制队列规则等；<br>  E:通知链调用；<br>关闭设备：<br>相反</p>
<p>(11)和电源管理之间的交互：<br>  当内核支持电源管理时，若进入挂起模式，则NIC设备驱动程序会接到通知，通过pci pci_driver结构的suspend,resume；<br>会影响到网络设备，如net-&gt;state,并调用相关函数挂起设备或重新继续；netif_device_detach/netif_device_attach<br>其他：  </p>
<p>(12)链路状态变更检测：<br>A：驱动程序检测载波或者信号是否存在；  netif_carrier_on/netif_carrier_off;<br>B:  调度并处理链路状态变更事件；<br>C:链接监看标示  </p>
<p>(13)从用户空间配置设备相关信息；<br>ifconfig,ethool,ip link;通过ioctl或netlink下去；<br>媒介独立接口：MII<br>(14)虚拟设备注意<br>(15)上锁  </p>
<h5 id="probe等函数例子："><a href="#probe等函数例子：" class="headerlink" title="probe等函数例子："></a>probe等函数例子：</h5><p>driver/net/xxx/xxx 具体设备相关文件；  </p>
<h5 id="以wifi芯片举例："><a href="#以wifi芯片举例：" class="headerlink" title="以wifi芯片举例："></a>以wifi芯片举例：</h5><pre><code> (data数据网络：ap侧：手机cpu modem侧：modem芯片)  
 (wifi网络：ap侧：固件wifi芯片  host端：手机cpu）  
 网卡NIC如无线网卡，内部是由程序在运行，在网卡中运行的程序叫做固件，对wifi而言也称为AP侧，而在PC端运行的用于控制和相应网卡中断的称为driver（驱动）或host侧；  
驱动程序往往以ko的形式，被内核加载和运行  
固件以bin或其他形式(mtk:bin,qcom:mpb)，被push到设备指定目录中，并最后push到设备内存中运行；  
</code></pre><h6 id="ldd3上一个虚拟设备的例子：贴过来仅供参考；"><a href="#ldd3上一个虚拟设备的例子：贴过来仅供参考；" class="headerlink" title="ldd3上一个虚拟设备的例子：贴过来仅供参考；"></a>ldd3上一个虚拟设备的例子：贴过来仅供参考；</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * snull.c --  the Simple Network Utility</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2001 O'Reilly &amp; Associates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The source code in this file can be freely used, adapted,</span></span><br><span class="line"><span class="comment"> * and redistributed in source or binary form, so long as an</span></span><br><span class="line"><span class="comment"> * acknowledgment appears in derived source files.  The citation</span></span><br><span class="line"><span class="comment"> * should list that the code comes from the book "Linux Device</span></span><br><span class="line"><span class="comment"> * Drivers" by Alessandro Rubini and Jonathan Corbet, published</span></span><br><span class="line"><span class="comment"> * by O'Reilly &amp; Associates.   No warranty is attached;</span></span><br><span class="line"><span class="comment"> * we cannot take responsibility for errors or fitness for use.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * $Id: snull.c,v 1.21 2004/11/05 02:36:03 rubini Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt; /* printk() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt; /* kmalloc() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;  /* error codes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;  /* size_t */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt; /* mark_bh */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netdevice.h&gt;   /* struct device, and other headers */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/etherdevice.h&gt; /* eth_type_trans */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;          /* struct iphdr */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;         /* struct tcphdr */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"snull.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in6.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/checksum.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">"Alessandro Rubini, Jonathan Corbet"</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Transmitter lockup simulation, normally disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lockup = <span class="number">0</span>;</span><br><span class="line">module_param(lockup, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> timeout = SNULL_TIMEOUT;</span><br><span class="line">module_param(timeout, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do we run in NAPI mode?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> use_napi = <span class="number">0</span>;</span><br><span class="line">module_param(use_napi, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A structure representing an in-flight packet.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span>	datalen;</span><br><span class="line">	u8 data[ETH_DATA_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pool_size = <span class="number">8</span>;</span><br><span class="line">module_param(pool_size, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is private to each device. It is used to pass</span></span><br><span class="line"><span class="comment"> * packets in and out, so there is place for a packet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> &#123;</span><span class="comment">//这个网络设备的私有数据结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">ppool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">rx_queue</span>;</span>  <span class="comment">/* List of incoming packets */</span></span><br><span class="line">	<span class="keyword">int</span> rx_int_enabled;</span><br><span class="line">	<span class="keyword">int</span> tx_packetlen;</span><br><span class="line">	u8 *tx_packetdata;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一些net_deivce需要的函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">snull_tx_timeout</span><span class="params">(struct net_device *dev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*snull_interrupt)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span> *, struct pt_regs *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up a device's packet pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_setup_pool</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">pkt</span>;</span></span><br><span class="line"></span><br><span class="line">	priv-&gt;ppool = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool_size; i++) &#123;</span><br><span class="line">		pkt = kmalloc (<span class="keyword">sizeof</span> (struct snull_packet), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (pkt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			printk (KERN_NOTICE <span class="string">"Ran out of memory allocating packet pool\n"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pkt-&gt;dev = dev;</span><br><span class="line">		pkt-&gt;next = priv-&gt;ppool;</span><br><span class="line">		priv-&gt;ppool = pkt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_teardown_pool</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">pkt</span>;</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> ((pkt = priv-&gt;ppool)) &#123;</span><br><span class="line">		priv-&gt;ppool = pkt-&gt;next;</span><br><span class="line">		kfree (pkt);</span><br><span class="line">		<span class="comment">/* FIXME - in-flight packets ? */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Buffer/pool management.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct snull_packet *<span class="title">snull_get_tx_buffer</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">pkt</span>;</span></span><br><span class="line">    </span><br><span class="line">	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span><br><span class="line">	pkt = priv-&gt;ppool;</span><br><span class="line">	priv-&gt;ppool = pkt-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;ppool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk (KERN_INFO <span class="string">"Pool empty\n"</span>);</span><br><span class="line">		netif_stop_queue(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> pkt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_release_buffer</span><span class="params">(struct snull_packet *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">pkt</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line">	</span><br><span class="line">	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span><br><span class="line">	pkt-&gt;next = priv-&gt;ppool;</span><br><span class="line">	priv-&gt;ppool = pkt;</span><br><span class="line">	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (netif_queue_stopped(pkt-&gt;dev) &amp;&amp; pkt-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">		netif_wake_queue(pkt-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_enqueue_buf</span><span class="params">(struct net_device *dev, struct snull_packet *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span><br><span class="line">	pkt-&gt;next = priv-&gt;rx_queue;  <span class="comment">/* FIXME - misorders packets */</span></span><br><span class="line">	priv-&gt;rx_queue = pkt;</span><br><span class="line">	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct snull_packet *<span class="title">snull_dequeue_buf</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">pkt</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span><br><span class="line">	pkt = priv-&gt;rx_queue;</span><br><span class="line">	<span class="keyword">if</span> (pkt != <span class="literal">NULL</span>)</span><br><span class="line">		priv-&gt;rx_queue = pkt-&gt;next;</span><br><span class="line">	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> pkt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Enable and disable receive interrupts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">snull_rx_ints</span><span class="params">(struct net_device *dev, <span class="keyword">int</span> enable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	priv-&gt;rx_int_enabled = enable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Open and close</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_open</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* request_region(), request_irq(), ....  (like fops-&gt;open) */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Assign the hardware address of the board: use "\0SNULx", where</span></span><br><span class="line"><span class="comment">	 * x is 0 or 1. The first byte is '\0' to avoid being a multicast</span></span><br><span class="line"><span class="comment">	 * address (the first byte of multicast addrs is odd).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(dev-&gt;dev_addr, <span class="string">"\0SNUL0"</span>, ETH_ALEN);</span><br><span class="line">	<span class="keyword">if</span> (dev == snull_devs[<span class="number">1</span>])</span><br><span class="line">		dev-&gt;dev_addr[ETH_ALEN<span class="number">-1</span>]++; <span class="comment">/* \0SNUL1 */</span></span><br><span class="line">	netif_start_queue(dev);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_release</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* release ports, irq and such -- like fops-&gt;close */</span></span><br><span class="line"></span><br><span class="line">	netif_stop_queue(dev); <span class="comment">/* can't transmit any more */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Configuration changes (passed on by ifconfig)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_config</span><span class="params">(struct net_device *dev, struct ifmap *<span class="built_in">map</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;flags &amp; IFF_UP) <span class="comment">/* can't act on a running interface */</span></span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don't allow changing the I/O address */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>-&gt;base_addr != dev-&gt;base_addr) &#123;</span><br><span class="line">		printk(KERN_WARNING <span class="string">"snull: Can't change I/O address\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow changing the IRQ */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>-&gt;irq != dev-&gt;irq) &#123;</span><br><span class="line">		dev-&gt;irq = <span class="built_in">map</span>-&gt;irq;</span><br><span class="line">        	<span class="comment">/* request_irq() is delayed to open-time */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ignore other fields */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Receive a packet: retrieve, encapsulate and pass over to upper levels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_rx</span><span class="params">(struct net_device *dev, struct snull_packet *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The packet has been retrieved from the transmission</span></span><br><span class="line"><span class="comment">	 * medium. Build an skb around it, so upper layers can handle it</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	skb = dev_alloc_skb(pkt-&gt;datalen + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		<span class="keyword">if</span> (printk_ratelimit())</span><br><span class="line">			printk(KERN_NOTICE <span class="string">"snull rx: low on mem - packet dropped\n"</span>);</span><br><span class="line">		priv-&gt;stats.rx_dropped++;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	skb_reserve(skb, <span class="number">2</span>); <span class="comment">/* align IP on 16B boundary */</span>  </span><br><span class="line">	<span class="built_in">memcpy</span>(skb_put(skb, pkt-&gt;datalen), pkt-&gt;data, pkt-&gt;datalen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write metadata, and then pass to the receive level */</span></span><br><span class="line">	skb-&gt;dev = dev;</span><br><span class="line">	skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; <span class="comment">/* don't check it */</span></span><br><span class="line">	priv-&gt;stats.rx_packets++;</span><br><span class="line">	priv-&gt;stats.rx_bytes += pkt-&gt;datalen;</span><br><span class="line">	netif_rx(skb);</span><br><span class="line">  out:</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The poll implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snull_poll</span><span class="params">(struct net_device *dev, <span class="keyword">int</span> *budget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> npackets = <span class="number">0</span>, quota = min(dev-&gt;quota, *budget);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">pkt</span>;</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (npackets &lt; quota &amp;&amp; priv-&gt;rx_queue) &#123;</span><br><span class="line">		pkt = snull_dequeue_buf(dev);</span><br><span class="line">		skb = dev_alloc_skb(pkt-&gt;datalen + <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (! skb) &#123;</span><br><span class="line">			<span class="keyword">if</span> (printk_ratelimit())</span><br><span class="line">				printk(KERN_NOTICE <span class="string">"snull: packet dropped\n"</span>);</span><br><span class="line">			priv-&gt;stats.rx_dropped++;</span><br><span class="line">			snull_release_buffer(pkt);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		skb_reserve(skb, <span class="number">2</span>); <span class="comment">/* align IP on 16B boundary */</span>  </span><br><span class="line">		<span class="built_in">memcpy</span>(skb_put(skb, pkt-&gt;datalen), pkt-&gt;data, pkt-&gt;datalen);</span><br><span class="line">		skb-&gt;dev = dev;</span><br><span class="line">		skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">		skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; <span class="comment">/* don't check it */</span></span><br><span class="line">		netif_receive_skb(skb);</span><br><span class="line">		</span><br><span class="line">        	<span class="comment">/* Maintain stats */</span></span><br><span class="line">		npackets++;</span><br><span class="line">		priv-&gt;stats.rx_packets++;</span><br><span class="line">		priv-&gt;stats.rx_bytes += pkt-&gt;datalen;</span><br><span class="line">		snull_release_buffer(pkt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* If we processed all packets, we're done; tell the kernel and reenable ints */</span></span><br><span class="line">	*budget -= npackets;</span><br><span class="line">	dev-&gt;quota -= npackets;</span><br><span class="line">	<span class="keyword">if</span> (! priv-&gt;rx_queue) &#123;</span><br><span class="line">		netif_rx_complete(dev);</span><br><span class="line">		snull_rx_ints(dev, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* We couldn't process everything. */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">	    </span><br><span class="line">        </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The typical interrupt entry point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">snull_regular_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> statusword;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">pkt</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * As usual, check the "device" pointer to be sure it is</span></span><br><span class="line"><span class="comment">	 * really interrupting.</span></span><br><span class="line"><span class="comment">	 * Then assign "struct device *dev"</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">net_device</span> *)<span class="title">dev_id</span>;</span></span><br><span class="line">	<span class="comment">/* ... and check with hw if it's really ours */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* paranoid */</span></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lock the device */</span></span><br><span class="line">	priv = netdev_priv(dev);</span><br><span class="line">	spin_lock(&amp;priv-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* retrieve statusword: real netdevices use I/O instructions */</span></span><br><span class="line">	statusword = priv-&gt;status;</span><br><span class="line">	priv-&gt;status = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (statusword &amp; SNULL_RX_INTR) &#123;</span><br><span class="line">		<span class="comment">/* send it to snull_rx for handling */</span></span><br><span class="line">		pkt = priv-&gt;rx_queue;</span><br><span class="line">		<span class="keyword">if</span> (pkt) &#123;</span><br><span class="line">			priv-&gt;rx_queue = pkt-&gt;next;</span><br><span class="line">			snull_rx(dev, pkt);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (statusword &amp; SNULL_TX_INTR) &#123;</span><br><span class="line">		<span class="comment">/* a transmission is over: free the skb */</span></span><br><span class="line">		priv-&gt;stats.tx_packets++;</span><br><span class="line">		priv-&gt;stats.tx_bytes += priv-&gt;tx_packetlen;</span><br><span class="line">		dev_kfree_skb(priv-&gt;skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unlock the device and we are done */</span></span><br><span class="line">	spin_unlock(&amp;priv-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (pkt) snull_release_buffer(pkt); <span class="comment">/* Do this outside the lock! */</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A NAPI interrupt handler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">snull_napi_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> statusword;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * As usual, check the "device" pointer for shared handlers.</span></span><br><span class="line"><span class="comment">	 * Then assign "struct device *dev"</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">net_device</span> *)<span class="title">dev_id</span>;</span></span><br><span class="line">	<span class="comment">/* ... and check with hw if it's really ours */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* paranoid */</span></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lock the device */</span></span><br><span class="line">	priv = netdev_priv(dev);</span><br><span class="line">	spin_lock(&amp;priv-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* retrieve statusword: real netdevices use I/O instructions */</span></span><br><span class="line">	statusword = priv-&gt;status;</span><br><span class="line">	priv-&gt;status = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (statusword &amp; SNULL_RX_INTR) &#123;</span><br><span class="line">		snull_rx_ints(dev, <span class="number">0</span>);  <span class="comment">/* Disable further interrupts */</span></span><br><span class="line">		netif_rx_schedule(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (statusword &amp; SNULL_TX_INTR) &#123;</span><br><span class="line">        	<span class="comment">/* a transmission is over: free the skb */</span></span><br><span class="line">		priv-&gt;stats.tx_packets++;</span><br><span class="line">		priv-&gt;stats.tx_bytes += priv-&gt;tx_packetlen;</span><br><span class="line">		dev_kfree_skb(priv-&gt;skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unlock the device and we are done */</span></span><br><span class="line">	spin_unlock(&amp;priv-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Transmit a packet (low level interface)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">snull_hw_tx</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> len, struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This function deals with hw details. This interface loops</span></span><br><span class="line"><span class="comment">	 * back the packet to the other snull interface (if any).</span></span><br><span class="line"><span class="comment">	 * In other words, this function implements the snull behaviour,</span></span><br><span class="line"><span class="comment">	 * while all other procedures are rather device-independent</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ih</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dest</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span>;</span></span><br><span class="line">	u32 *saddr, *daddr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_packet</span> *<span class="title">tx_buffer</span>;</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* I am paranoid. Ain't I? */</span></span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="keyword">sizeof</span>(struct ethhdr) + <span class="keyword">sizeof</span>(struct iphdr)) &#123;</span><br><span class="line">		printk(<span class="string">"snull: Hmm... packet too short (%i octets)\n"</span>,</span><br><span class="line">				len);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="comment">/* enable this conditional to look at the data */</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		PDEBUG(<span class="string">"len is %i\n"</span> KERN_DEBUG <span class="string">"data:"</span>,len);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">14</span> ; i&lt;len; i++)</span><br><span class="line">			printk(<span class="string">" %02x"</span>,buf[i]&amp;<span class="number">0xff</span>);</span><br><span class="line">		printk(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ethhdr is 14 bytes, but the kernel arranges for iphdr</span></span><br><span class="line"><span class="comment">	 * to be aligned (i.e., ethhdr is unaligned)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ih = (struct iphdr *)(buf+<span class="keyword">sizeof</span>(struct ethhdr));</span><br><span class="line">	saddr = &amp;ih-&gt;saddr;</span><br><span class="line">	daddr = &amp;ih-&gt;daddr;</span><br><span class="line"></span><br><span class="line">	((u8 *)saddr)[<span class="number">2</span>] ^= <span class="number">1</span>; <span class="comment">/* change the third octet (class C) */</span></span><br><span class="line">	((u8 *)daddr)[<span class="number">2</span>] ^= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	ih-&gt;check = <span class="number">0</span>;         <span class="comment">/* and rebuild the checksum (ip needs it) */</span></span><br><span class="line">	ih-&gt;check = ip_fast_csum((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)ih,ih-&gt;ihl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev == snull_devs[<span class="number">0</span>])</span><br><span class="line">		PDEBUGG(<span class="string">"%08x:%05i --&gt; %08x:%05i\n"</span>,</span><br><span class="line">				ntohl(ih-&gt;saddr),ntohs(((struct tcphdr *)(ih+<span class="number">1</span>))-&gt;source),</span><br><span class="line">				ntohl(ih-&gt;daddr),ntohs(((struct tcphdr *)(ih+<span class="number">1</span>))-&gt;dest));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		PDEBUGG(<span class="string">"%08x:%05i &lt;-- %08x:%05i\n"</span>,</span><br><span class="line">				ntohl(ih-&gt;daddr),ntohs(((struct tcphdr *)(ih+<span class="number">1</span>))-&gt;dest),</span><br><span class="line">				ntohl(ih-&gt;saddr),ntohs(((struct tcphdr *)(ih+<span class="number">1</span>))-&gt;source));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ok, now the packet is ready for transmission: first simulate a</span></span><br><span class="line"><span class="comment">	 * receive interrupt on the twin device, then  a</span></span><br><span class="line"><span class="comment">	 * transmission-done on the transmitting device</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dest = snull_devs[dev == snull_devs[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>];</span><br><span class="line">	priv = netdev_priv(dest);</span><br><span class="line">	tx_buffer = snull_get_tx_buffer(dev);</span><br><span class="line">	tx_buffer-&gt;datalen = len;</span><br><span class="line">	<span class="built_in">memcpy</span>(tx_buffer-&gt;data, buf, len);</span><br><span class="line">	snull_enqueue_buf(dest, tx_buffer);</span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;rx_int_enabled) &#123;</span><br><span class="line">		priv-&gt;status |= SNULL_RX_INTR;</span><br><span class="line">		snull_interrupt(<span class="number">0</span>, dest, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv = netdev_priv(dev);</span><br><span class="line">	priv-&gt;tx_packetlen = len;</span><br><span class="line">	priv-&gt;tx_packetdata = buf;</span><br><span class="line">	priv-&gt;status |= SNULL_TX_INTR;</span><br><span class="line">	<span class="keyword">if</span> (lockup &amp;&amp; ((priv-&gt;stats.tx_packets + <span class="number">1</span>) % lockup) == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">/* Simulate a dropped transmit interrupt */</span></span><br><span class="line">		netif_stop_queue(dev);</span><br><span class="line">		PDEBUG(<span class="string">"Simulate lockup at %ld, txp %ld\n"</span>, jiffies,</span><br><span class="line">				(<span class="keyword">unsigned</span> <span class="keyword">long</span>) priv-&gt;stats.tx_packets);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		snull_interrupt(<span class="number">0</span>, dev, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Transmit a packet (called by the kernel)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_tx</span><span class="params">(struct sk_buff *skb, struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">char</span> *data, shortpkt[ETH_ZLEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	</span><br><span class="line">	data = skb-&gt;data;</span><br><span class="line">	len = skb-&gt;len;</span><br><span class="line">	<span class="keyword">if</span> (len &lt; ETH_ZLEN) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(shortpkt, <span class="number">0</span>, ETH_ZLEN);</span><br><span class="line">		<span class="built_in">memcpy</span>(shortpkt, skb-&gt;data, skb-&gt;len);</span><br><span class="line">		len = ETH_ZLEN;</span><br><span class="line">		data = shortpkt;</span><br><span class="line">	&#125;</span><br><span class="line">	dev-&gt;trans_start = jiffies; <span class="comment">/* save the timestamp */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remember the skb, so we can free it at interrupt time */</span></span><br><span class="line">	priv-&gt;skb = skb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* actual deliver of data is device-specific, and not shown here */</span></span><br><span class="line">	snull_hw_tx(data, len, dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Our simple device can not fail */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Deal with a transmit timeout.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_tx_timeout</span> <span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	PDEBUG(<span class="string">"Transmit timeout at %ld, latency %ld\n"</span>, jiffies,</span><br><span class="line">			jiffies - dev-&gt;trans_start);</span><br><span class="line">        <span class="comment">/* Simulate a transmission interrupt to get things moving */</span></span><br><span class="line">	priv-&gt;status = SNULL_TX_INTR;</span><br><span class="line">	snull_interrupt(<span class="number">0</span>, dev, <span class="literal">NULL</span>);</span><br><span class="line">	priv-&gt;stats.tx_errors++;</span><br><span class="line">	netif_wake_queue(dev);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ioctl commands </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_ioctl</span><span class="params">(struct net_device *dev, struct ifreq *rq, <span class="keyword">int</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PDEBUG(<span class="string">"ioctl\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return statistics to the caller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct net_device_stats *<span class="title">snull_stats</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">return</span> &amp;priv-&gt;stats;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called to fill up an eth header, since arp is not</span></span><br><span class="line"><span class="comment"> * available on the interface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_rebuild_header</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = (<span class="title">struct</span> <span class="title">ethhdr</span> *) <span class="title">skb</span>-&gt;<span class="title">data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">skb</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">    </span><br><span class="line">	<span class="built_in">memcpy</span>(eth-&gt;h_source, dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">	<span class="built_in">memcpy</span>(eth-&gt;h_dest, dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">	eth-&gt;h_dest[ETH_ALEN<span class="number">-1</span>]   ^= <span class="number">0x01</span>;   <span class="comment">/* dest is us xor 1 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_header</span><span class="params">(struct sk_buff *skb, struct net_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">short</span> type, <span class="keyword">void</span> *daddr, <span class="keyword">void</span> *saddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = (<span class="title">struct</span> <span class="title">ethhdr</span> *)<span class="title">skb_push</span>(<span class="title">skb</span>,<span class="title">ETH_HLEN</span>);</span></span><br><span class="line"></span><br><span class="line">	eth-&gt;h_proto = htons(type);</span><br><span class="line">	<span class="built_in">memcpy</span>(eth-&gt;h_source, saddr ? saddr : dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">	<span class="built_in">memcpy</span>(eth-&gt;h_dest,   daddr ? daddr : dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">	eth-&gt;h_dest[ETH_ALEN<span class="number">-1</span>]   ^= <span class="number">0x01</span>;   <span class="comment">/* dest is us xor 1 */</span></span><br><span class="line">	<span class="keyword">return</span> (dev-&gt;hard_header_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The "change_mtu" method is usually not needed.</span></span><br><span class="line"><span class="comment"> * If you need it, it must be like this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_change_mtu</span><span class="params">(struct net_device *dev, <span class="keyword">int</span> new_mtu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> *lock = &amp;priv-&gt;lock;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* check ranges */</span></span><br><span class="line">	<span class="keyword">if</span> ((new_mtu &lt; <span class="number">68</span>) || (new_mtu &gt; <span class="number">1500</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do anything you need, and the accept the value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	spin_lock_irqsave(lock, flags);</span><br><span class="line">	dev-&gt;mtu = new_mtu;</span><br><span class="line">	spin_unlock_irqrestore(lock, flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* success */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The init function (sometimes called probe).</span></span><br><span class="line"><span class="comment"> * It is invoked by register_netdev()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这个是setup函数，用于初始化net_device部分结构，并作为alloc_netdev的第三个参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_init</span><span class="params">(struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snull_priv</span> *<span class="title">priv</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make the usual checks: check_region(), probe irq, ...  -ENODEV</span></span><br><span class="line"><span class="comment">	 * should be returned if no device found.  No resource should be</span></span><br><span class="line"><span class="comment">	 * grabbed: this is done on open(). </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Then, assign other fields in dev, using ether_setup() and some</span></span><br><span class="line"><span class="comment">	 * hand assignments</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ether_setup(dev); <span class="comment">/* assign some of the fields */</span></span><br><span class="line"></span><br><span class="line">	dev-&gt;open            = snull_open;</span><br><span class="line">	dev-&gt;stop            = snull_release;</span><br><span class="line">	dev-&gt;set_config      = snull_config;</span><br><span class="line">	dev-&gt;hard_start_xmit = snull_tx;</span><br><span class="line">	dev-&gt;do_ioctl        = snull_ioctl;</span><br><span class="line">	dev-&gt;get_stats       = snull_stats;</span><br><span class="line">	dev-&gt;change_mtu      = snull_change_mtu;  </span><br><span class="line">	dev-&gt;rebuild_header  = snull_rebuild_header;</span><br><span class="line">	dev-&gt;hard_header     = snull_header;</span><br><span class="line">	dev-&gt;tx_timeout      = snull_tx_timeout;</span><br><span class="line">	dev-&gt;watchdog_timeo = timeout;</span><br><span class="line">	<span class="keyword">if</span> (use_napi) &#123;</span><br><span class="line">		dev-&gt;poll        = snull_poll;</span><br><span class="line">		dev-&gt;weight      = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* keep the default flags, just add NOARP */</span></span><br><span class="line">	dev-&gt;flags           |= IFF_NOARP;</span><br><span class="line">	dev-&gt;features        |= NETIF_F_NO_CSUM;</span><br><span class="line">	dev-&gt;hard_header_cache = <span class="literal">NULL</span>;      <span class="comment">/* Disable caching */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Then, initialize the priv field. This encloses the statistics</span></span><br><span class="line"><span class="comment">	 * and a few private fields.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	priv = netdev_priv(dev);</span><br><span class="line">	<span class="built_in">memset</span>(priv, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct snull_priv));</span><br><span class="line">	spin_lock_init(&amp;priv-&gt;lock);</span><br><span class="line">	snull_rx_ints(dev, <span class="number">1</span>);		<span class="comment">/* enable receive interrupts */</span></span><br><span class="line">	snull_setup_pool(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The devices</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">snull_devs</span>[2];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Finally, the module stuff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//驱动卸载时调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snull_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>;  i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (snull_devs[i]) &#123;</span><br><span class="line">			unregister_netdev(snull_devs[i]);<span class="comment">//反注册net_deivce</span></span><br><span class="line">			snull_teardown_pool(snull_devs[i]);</span><br><span class="line">			free_netdev(snull_devs[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动加载时的初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snull_init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result, i, ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	snull_interrupt = use_napi ? snull_napi_interrupt : snull_regular_interrupt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate the devices */</span></span><br><span class="line">	snull_devs[<span class="number">0</span>] = alloc_netdev(<span class="keyword">sizeof</span>(struct snull_priv), <span class="string">"sn%d"</span>,<span class="comment">//调用的分配net_deivce函数</span></span><br><span class="line">			snull_init);</span><br><span class="line">	snull_devs[<span class="number">1</span>] = alloc_netdev(<span class="keyword">sizeof</span>(struct snull_priv), <span class="string">"sn%d"</span>,<span class="comment">//这里"sn%d"内核会使用dev_alloc_name以完成该名字，次函数会把%d换成该设备类型中头一个未分配的数字</span></span><br><span class="line">			snull_init);</span><br><span class="line">	<span class="keyword">if</span> (snull_devs[<span class="number">0</span>] == <span class="literal">NULL</span> || snull_devs[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	ret = -ENODEV;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>;  i++)</span><br><span class="line">		<span class="keyword">if</span> ((result = register_netdev(snull_devs[i])))<span class="comment">//注册net_device</span></span><br><span class="line">			printk(<span class="string">"snull: error %i registering device \"%s\"\n"</span>,</span><br><span class="line">					result, snull_devs[i]-&gt;name);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line">   out:</span><br><span class="line">	<span class="keyword">if</span> (ret) </span><br><span class="line">		snull_cleanup();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(snull_init_module);</span><br><span class="line">module_exit(snull_cleanup);</span><br></pre></td></tr></table></figure>
<h4 id="其他部分，如子系统的初始化，等分析到了再写"><a href="#其他部分，如子系统的初始化，等分析到了再写" class="headerlink" title="其他部分，如子系统的初始化，等分析到了再写"></a>其他部分，如子系统的初始化，等分析到了再写</h4>]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_init</tag>
      </tags>
  </entry>
  <entry>
    <title>filesystem</title>
    <url>/2021/03/12/filesystem/</url>
    <content><![CDATA[<h2 id="文件系统："><a href="#文件系统：" class="headerlink" title="文件系统："></a>文件系统：</h2><h3 id="关于信息记载和存储的历史，现状和未来展望"><a href="#关于信息记载和存储的历史，现状和未来展望" class="headerlink" title="关于信息记载和存储的历史，现状和未来展望"></a>关于信息记载和存储的历史，现状和未来展望</h3><ul>
<li>本能信息存储：在原始时期，信息被基因记载，并向下传递，个体发生基因突变后，存活下来的个体，能将突变的基因信息保存下来，传递下来，从而进化；</li>
<li>口口相传：人类发明语言或者是类似的东西，然后将经验和信息一代代传递下来，通过人本身作为记录和存储；</li>
<li>文字的出现：直到文字和记载载体出现，比如帛书，纸等，文字以语句，文章，数字等被记录成竹简或书本，保存下来；</li>
<li>磁带记录：磁带的出现，提高了信息记载的便利性；<a id="more"></a></li>
<li>硬盘存储：硬盘的出现使得载体变多，而记录的形式也增强了，有文件系统，数据库等存储不同类型的媒介，而媒介也多种多样：文字，图片，视频等等；</li>
<li>现在出现了很多类型的文件系统，存储也不再是单机，有云，网络，使得存储的性能和效率得到进一步的提升；</li>
<li>未来：一方面随着信息的爆炸，往快，久，量大的方向继续进化；另一方面，针对不同的媒介有不同的存储支持；畅想，未来，存储可能会<br>变成像手机或其他智能硬件一样，成为人类通过外部工具进行进化的一种手段，而人类，可能也不再受限于记忆；</li>
<li>PS: 人类的意识存在，前世今生，和记忆存储关联密切，对失忆的人来讲，就像重新活过一样；</li>
</ul>
<h3 id="现代信息记载和存储分类：数据库和文件系统"><a href="#现代信息记载和存储分类：数据库和文件系统" class="headerlink" title="现代信息记载和存储分类：数据库和文件系统"></a>现代信息记载和存储分类：数据库和文件系统</h3><p>现代信息记载，效率高的主要是数据库和文件系统，前者提高了数据存储的效率，以及支持数据以某个形式方式组织，更有利于有效存取；<br>而后者，是比较原始的，支持的信息媒介更多，也支持各种系统，限制比较小，但是不利于数据的查阅；</p>
<h4 id="文件系统的分类："><a href="#文件系统的分类：" class="headerlink" title="文件系统的分类："></a>文件系统的分类：</h4><ul>
<li>单机文件系统</li>
<li>网络文件系统</li>
<li>分布式文件系统</li>
<li>并行文件系统等等；</li>
</ul>
<h3 id="文件系统的关注点：性能数据，IO，进程并发等；"><a href="#文件系统的关注点：性能数据，IO，进程并发等；" class="headerlink" title="文件系统的关注点：性能数据，IO，进程并发等；"></a>文件系统的关注点：性能数据，IO，进程并发等；</h3><ul>
<li>IO:</li>
<li>磁盘分配单位</li>
<li>碎片处理机制</li>
<li>带宽利用率</li>
<li>对多进程并发读写和交互式访问的性能，以及聚合读写带宽的能力；</li>
<li>文件的组织形式和访问方式：比如硬盘如何分区，文件如何组织等等，和存储硬件本身限制的关联，会影响硬件操作性能；<br>比如说<br>候选的磁盘分区方案：<br>  方案一： 255个盘面，C盘是0-100盘面， D盘是101-200个盘面,……<br>  方案二：3263个柱面，C盘0-1000个柱面，D盘1001-20001个柱面,……</li>
</ul>
<h3 id="硬盘的组成和读写机制"><a href="#硬盘的组成和读写机制" class="headerlink" title="硬盘的组成和读写机制"></a>硬盘的组成和读写机制</h3><h4 id="硬盘简介"><a href="#硬盘简介" class="headerlink" title="硬盘简介"></a>硬盘简介</h4><p>1、硬盘的物理结构一般由磁头与碟片、电动机、主控芯片与排线等部件组成；当主电动机带动碟片旋转时，副电动机带动一组（磁头）到相对应的碟片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与碟片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容。所有的盘片都固定在一个旋转轴上，这个轴即盘片主轴。而所有盘片之间是绝对平行的，在每个盘片的存储面上都有一个磁头，磁头与盘片之间的距离比头发 丝的直径还小。所有的磁头连在一个磁头控制器上，由磁头控制器负责各个磁头的运动。磁头可沿盘片的半径方向动作，而盘片以每分钟数千转到上万转的速度在高 速旋转，这样磁头就能对盘片上的指定位置进行数据的读写操作。</p>
<img src="/2021/03/12/filesystem/disk1.png" title="disk1 about">
<h4 id="磁道（Track）"><a href="#磁道（Track）" class="headerlink" title="磁道（Track）"></a>磁道（Track）</h4><p>当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。信息以脉冲串的形式记录在这些轨迹中，这些同心圆不是连续记录数据，而是被划分成一段段的圆弧（扇区），这些圆弧 的角速度一样。</p>
<h4 id="柱面-（Cylinder）"><a href="#柱面-（Cylinder）" class="headerlink" title="柱面 （Cylinder）"></a>柱面 （Cylinder）</h4><p>在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。所有盘面上的同一磁道构成一个圆柱，通常称做柱面（Cylinder），每个圆柱上的磁头由上而下从“0”开始编号。数据的读/写按柱面进行，即磁 头读/写数据时首先在同一柱面内从“0”磁头开始进行操作，依次向下在同一柱面的不同盘面即磁头上进行操作，只在同一柱面所有的磁头全部读/写完毕后磁头 才转移到下一柱面，因为选取磁头只需通过电子切换即可，而选取柱面则必须通过机械切换。电子切换相当快，比在机械上磁头向邻近磁道移动快得多，所以，数据 的读/写按柱面进行，而不按盘面进行。也就是说，一个磁道写满数据后，就在同一柱面的下一个盘面来写，一个柱面写满后，才移到下一个磁道开始写数据。读数 据也按照这种方式进行，这样就提高了硬盘的读/写效率。</p>
<h4 id="扇区（Sector）"><a href="#扇区（Sector）" class="headerlink" title="扇区（Sector）"></a>扇区（Sector）</h4><p>磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。<strong>硬盘的第一个扇区，叫做引导扇区</strong>。操作系统以扇区（Sector）形式将信息存储在硬盘上，每个扇区包括512个字节的数据和一些其他信息。注意扇区不是指的扇形那个区域，而是磁道的一段弧线；由下计算存储空间大小公式可知；</p>
<h4 id="磁头（Head）"><a href="#磁头（Head）" class="headerlink" title="磁头（Head）"></a>磁头（Head）</h4><p>在硬盘系 统中，硬盘的每一个盘片都有两个盘面（Side），即上、下盘面，一般每个盘面都会利 用，都可以存储数据。盘面号又叫磁头号，因为每一个有效盘面都有一个对应的读写磁头。<br><img src="/2021/03/12/filesystem/disk2.png" title="disk2 about"></p>
<h4 id="如何计算存储大小："><a href="#如何计算存储大小：" class="headerlink" title="如何计算存储大小："></a>如何计算存储大小：</h4><p>硬盘的大小是使用”磁头数 x 柱面数 x 扇区数 x 每个扇区的大小”这样的公式来计算的。其中，磁头数（Heads）表示硬盘共有几个磁头，也可以理解为硬盘有几个盘面，然后乘以 2；柱面数（Cylinders）表示硬盘每面盘片有几条磁道；扇区数（Sectors）表示每条磁道上有几个扇区；每个扇区的大小一般是 512Byte。<br>举个例子：在ubuntu上</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">root@ksance-ThinkPad-X201:~<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 320.1 GB,<span class="number"> 320072933376 </span>bytes</span><br><span class="line">255 heads,<span class="number"> 63 </span>sectors/track,<span class="number"> 38913 </span>cylinders, total<span class="number"> 625142448 </span>sectors</span><br><span class="line">Units = sectors of<span class="number"> 1 </span>*<span class="number"> 512 </span>=<span class="number"> 512 </span>bytes</span><br><span class="line">Sector size (logical/physical):<span class="number"> 512 </span>bytes /<span class="number"> 512 </span>bytes</span><br><span class="line">I/O size (minimum/optimal):<span class="number"> 512 </span>bytes /<span class="number"> 512 </span>bytes</span><br><span class="line">Disk identifier: 0x000e6df5</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *       <span class="number"> 2048 </span> <span class="number"> 617170943 </span> <span class="number"> 308584448 </span> <span class="number"> 83 </span> Linux</span><br><span class="line">/dev/sda2      <span class="number"> 617172990 </span> <span class="number"> 625141759 </span>   <span class="number"> 3984385 </span>  <span class="number"> 5 </span> Extended</span><br><span class="line">/dev/sda5      <span class="number"> 617172992 </span> <span class="number"> 625141759 </span>   <span class="number"> 3984384 </span> <span class="number"> 82 </span> Linux swap / Solaris</span><br><span class="line">该磁盘有255个heads，也就是说共有255个盘面。38913个柱面（cylinders），也就是说每个盘面上都有38913个磁道，<span class="number"> 63 </span>sectors/track说的是每个磁道上共有63个扇区。命令结果也给出了Sector size的值是512bytes。</span><br><span class="line">255盘面  * 38913柱面 * 63扇区 * 每个扇区512bytes = 320072933376bytes</span><br></pre></td></tr></table></figure>
<h4 id="磁盘的读写原理："><a href="#磁盘的读写原理：" class="headerlink" title="磁盘的读写原理："></a>磁盘的读写原理：</h4><p>系统将文件存储到磁盘上时，按柱面、磁头、扇区的方式进行，即最先是第1磁道的第一磁头下（也就是第1盘面的第一磁道）的所有扇区，然后，是同一柱面的下一磁头，……，一个柱面存储满后就推进到下一个柱面，直到把文件内容全部写入磁盘。  </p>
<p>系统也以相同的顺序读出数据。读出数据时通过告诉磁盘控制器要读出扇区所在的柱面号、磁头号和扇区号（物理地址的三个组成部分）进行。磁盘控制器则直接使磁头部件步进到相应的柱面，选通相应的磁头，等待要求的扇区移动到磁头下。在扇区到来时，磁盘控制器读出每个扇区的头标，把这些头标中的地址信息与 期待检出的磁头和柱面号做比较（即寻道），然后，寻找要求的扇区号。待磁盘控制器找到该扇区头标时，根据其任务是写扇区还是读扇区，来决定是转换写电路， 还是读出数据和尾部记录。找到扇区后，磁盘控制器必须在继续寻找下一个扇区之前对该扇区的信息进行后处理。如果是读数据，控制器计算此数据的ECC码，然 后，把ECC码与已记录的ECC码相比较。如果是写数据，控制器计算出此数据的ECC码，与数据一起存储。在控制器对此扇区中的数据进行必要处理期间，磁 盘继续旋转。其实我们的文件大多数的时候都是破碎的，在文件没有破碎的时候,摇臂只需要寻找1次磁道并由磁头进行读取,只需要1次就可以成功读取;但是如果文件破碎成11处,那么摇臂要来回寻找11次磁道磁头进行11次读取才能完整的读取这个文件,读取时间相对没有破碎的时候就变得冗长。   </p>
<p>因此，磁盘IO时的过程包括：</p>
<pre><code>第一步，首先是磁头径向移动来寻找数据所在的磁道。这部分时间叫寻道时间。  
第二步，找到目标磁道后通过盘面旋转，将目标扇区移动到磁头的正下方。  
第三步，向目标扇区读取或者写入数据。到此为止，一次磁盘IO完成，故：  
</code></pre><p>所以，单次磁盘IO时间 = 寻道时间 + 旋转延迟 + 存取时间。   </p>
<pre><code>对于旋转延时，现在主流服务器上经常使用的是1W转/分钟的磁盘，每旋转一周所需的时间为60*1000/10000=6ms，故其旋转延迟为（0-6ms）。
对于存取时间，一般耗时较短，为零点几ms。
对于寻道时间，现代磁盘大概在3-15ms，其中寻道时间大小主要受磁头当前所在位置和目标磁道所在位置相对距离的影响。
</code></pre><h4 id="如何分区："><a href="#如何分区：" class="headerlink" title="如何分区："></a>如何分区：</h4><p>候选的磁盘分区方案：  </p>
<pre><code>方案一： 255个盘面，C盘是0-100盘面， D盘是101-200个盘面,……
方案二：3263个柱面，C盘0-1000个柱面，D盘1001-20001个柱面,……
</code></pre><p>其实采用哪一种，最主要看的是那种方式性能更快。因为同一分区下的数据经常会一起读取，假如采用第一种，那么这样磁头就需要在3000多个track间不停地跳来跳去，这样磁盘的寻道时间就会翻倍，磁盘性能就会下降。而对于方案二，假如对于磁盘C，只需要在磁头在1-1000个磁道间移动就可以了，大大降低了寻道时间。（实际上分区并不是从0开始的，磁盘的第一个磁道对应的柱面会被用来安装引导加载程序以及磁盘分区表）。所以，方案二的分区方式可以降低磁盘IO时间中的寻道时间部分，所以所有的操作系统采用的都是方案二，没有用方案一的。</p>
<h4 id="几类硬盘"><a href="#几类硬盘" class="headerlink" title="几类硬盘"></a>几类硬盘</h4><p>几类硬盘：<br>磁盘种类     最大IOPS     最大响应时间<br>ATA/IDE     70     15ms<br>FC/SAS     140~160     10ms<br>SSD/EFD     2500     1ms<br>即IDE–&gt;SCSI即目前的机械硬盘-&gt;ssd即固态硬盘</p>
<h3 id="系统如何分区，格式化文件系统"><a href="#系统如何分区，格式化文件系统" class="headerlink" title="系统如何分区，格式化文件系统"></a>系统如何分区，格式化文件系统</h3><p>Linux 下磁盘命名和分区<br>在为主机添加硬盘前，首先要了解Linux系统下对硬盘和分区的命名方法。   </p>
<h4 id="1-磁盘命名"><a href="#1-磁盘命名" class="headerlink" title="1 磁盘命名"></a>1 磁盘命名</h4><p>在Linux下对 SCSI 和 SATA 设备是以 sd 命名的，第一个 scsi 设备是 sda，第二个是 sdb，依此类推。一般主板上有两个SCSI接口，因此一共可以安装四个SCSI设备。主 SCSI 上的两个设备分别对应 sda 和 sdb，第二个 SCSI 口上的两个设备对应 sdc 和 sdd。一般硬盘安装在主 SCSI 的主接口上，所以是 sda 或者 sdb，而光驱一般安装在第二个SCSI的主接口上，所以是 sdc。(IDE接口设备是用 hd 命名的，第一个设备是hda，第二个是hdb，依此类推。)</p>
<p>IDE 磁盘     描述    配置<br>/dev/hda     1st (Primary) IDE controller     Master<br>/dev/hdb     1st (Primary) IDE controller     Slave<br>/dev/hdc     2nd (Secondary) IDE controller     Master<br>/dev/hdd     2nd (Secondary) IDE controller     Slave  </p>
<h4 id="2磁盘分区"><a href="#2磁盘分区" class="headerlink" title="2磁盘分区"></a>2磁盘分区</h4><p>所谓的磁盘分区指的是告诉操作系统『我这颗磁盘在此分割槽可以存取的区域是由 A 磁柱到 B 磁柱之间的区块』， 如此一来操作系统就能够知道他可以在所指定的区块内进行文件数据的读/写/搜寻等动作了。 也就是说，磁盘分区意即指定分割槽的启始与结束磁柱就是了。  </p>
<p>分区表用于记录分区的信息<br>一个硬盘，有两种类型的分区表，一种传统流行的MBR，一种是GPT:<br>ref:<a href="http://www.newskj.org/kjxx/2017062994604.html" target="_blank" rel="noopener">http://www.newskj.org/kjxx/2017062994604.html</a><br><strong>MBR</strong><br>（Master Boot Record，缩写：MBR），又叫做主引导扇区（主引导记录），是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。<br>MBR是由分区程序（如Fdisk，Parted）所产生的，它不依赖任何操作系统，而且硬盘引导程序也是可以改变的，从而能够实现多系统引导.<br>一个扇区是512字节，因此MBR的大小也是512字 节，其具体数据结构是：446个字节的引导代码、64个字节的分区表及2个字节的签名值”55AA”。<br>由于MBR的分区表只有64个字节，这决定了它只能 存储4个分区记录。这就是为什么一块硬盘最多只能有4个“主分区”的原因。  </p>
<p>我们已经知道了MBR中的分表区只能存放4个分区（即4个主分区），那系统是如何划分出4个以上的分区的呢？一种直白而简单的思路就是把其中一个主分区再进 行细分，衍生出一个二级分区表。对的，这个被用来二次分区的主分区就是“扩展分区”，它下面的二级分区就是“逻辑分区”  </p>
<h4 id="3linux和Windows"><a href="#3linux和Windows" class="headerlink" title="3linux和Windows:"></a>3linux和Windows:</h4><p>一个硬盘主分区至少有1个，最多4个，扩展分区可以没有，最多1个。且主分区+扩展分区总共不能超过4个。逻辑分区可以有若干个。<br>扩展分区是我们对逻辑分区的总称，只是一中称呼，通过分区助手等工具可以看到如E,F盘为逻辑分区；</p>
<p>在windows下激活的主分区是硬盘的启动分区，他是独立的，也是硬盘的第一个分区，正常分的话就是C区。<br> 在linux下主分区和逻辑分区都可以用来放系统，引导os开机，grub会兼容windows系统开机启动。<br>分出主分区后，其余的部分可以分成扩展分区，一般是剩下的部分全部分成扩展分区，也可以不全分，那剩的部分就浪费了。<br>但扩展分区是不能直接用的，他是以逻辑分区的方式来使用的，所以说扩展分区可分成若干逻辑分区。他们的关系是包含的关系，所有的逻辑分区都是扩展分区的一部分。<br>在linux中第一块硬盘分区为hda分区，主分区编号为hda1-4，逻辑分区从5开始。<br>硬盘的容量=主分区的容量+扩展分区的容量<br>扩展分区的容量=各个逻辑分区的容量之和，1个扩展分区-&gt;24个逻辑分区  </p>
<h4 id="4linux下进行分区的方法"><a href="#4linux下进行分区的方法" class="headerlink" title="4linux下进行分区的方法"></a>4linux下进行分区的方法</h4><p>当我们买到一块硬盘，里面空空如也，或者通过虚拟机进行创建虚拟硬盘时，如何进行分区？<br>当接入硬盘后：<br>1、通过ls /dev/sd* 查看所有硬盘  找到sdb或其他如hd等（根据硬盘类型来）<br>2、通过fdisk -l (root权限下) 查看未进行分区的硬盘<br>3、通过fdisk /dev/sdn(对应未分区的硬盘名）进行分区，依次选择后，完成；<br>4、格式化分区：mkfs.ext4 -L disk2 /dev/sdb 即对该分区创建文件系统；<br>5、挂载该分区 sudo mount -t ext4 /dev/sdb1/ /mnt/  </p>
<p>过程总结：<br>    创建：以某种方式格式化磁盘的过程就是在其之上建立一个文件系统的过程。创建文件系统时，会在磁盘的特定位置写入关于该文件系统的控制信息。<br>    注册：向内核报到，声明自己能被内核支持。一般在编译内核的时侯注册；也可以加载模块的方式手动注册。注册过程实 际上是将表示各实际文件系统的数据结构struct file_system_type 实例化。<br>    安装：也就是我们熟悉的mount操作，将文件系统加入到 Linux 的根文件系统的目录树结构上；这样文件系统才能被访问。<br>开机直接挂载<br>编辑 /etc/fstab 文件，添加：/dev/sda1 /test ext3 defaults 1 1，重启则发选已经挂载上去。  </p>
<h4 id="5-linux和windows文件系统和分区关系"><a href="#5-linux和windows文件系统和分区关系" class="headerlink" title="5 linux和windows文件系统和分区关系"></a>5 linux和windows文件系统和分区关系</h4><p>每块硬盘都分为若干个分区，每个分区都有自己的文件系统。Windows为这些文件系统各自指定了一个字母。不过 GNU/Linux 使用唯一的树形结构来管理文件，而每个文件系统都挂载于树形结构的某个位置。<br>正如 Windows 需要有 C: 驱动器一样，GNU/Linux 必须能够将根文件系统挂载于文件树的根(/)上。当根挂载完成之后，您就可以将其它文件系统挂载于树形结构各种挂载点上。根结构下的任何目录都可以作为挂载点，而您也可以将同一文件系统同时挂载于不同的挂载点上。挂载点实际上就是linux中的磁盘文件系统的入口目录：  </p>
<p>总结：从上面看，分区创建后需要格式化为某个类型的文件系统，所以分区和文件系统是一一对应的关系；</p>
<h3 id="linux文件系统架构："><a href="#linux文件系统架构：" class="headerlink" title="linux文件系统架构："></a>linux文件系统架构：</h3><h4 id="文件系统的概念和功能"><a href="#文件系统的概念和功能" class="headerlink" title="文件系统的概念和功能"></a>文件系统的概念和功能</h4><h5 id="wiki"><a href="#wiki" class="headerlink" title="wiki:"></a>wiki:</h5><p>计算机的文件系统是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易，文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。在写入新数据之前，用户不必关心硬盘上的那个块地址没有被使用，硬盘上的存储空间管理（分配和释放）功能由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中。<br>严格地说，文件系统是一套实现了数据的存储、分级组织、访问和获取等操作的抽象数据类型（Abstract data type）</p>
<h5 id="总结文件系统的功能："><a href="#总结文件系统的功能：" class="headerlink" title="总结文件系统的功能："></a>总结文件系统的功能：</h5><p>1、文件是放在硬盘中的，由物理作用写入的东西，而存放的东西需要管理，在使用时通过内存读入管理信息就能知道存放的内容，并进行进一步使用，<br>这个“管理” 就是文件系统；<br>2、文件系统提供：<br>     1) 硬盘文件的基本信息，文件基本信息，包括属性等；<br>     2) 提供管理文件接口，如删除，增加文件等等；  </p>
<p>3、从功能上可以这样分：从底层到用户层：<br>  1) 高速缓冲区的管理程序  –对硬盘等块设备的数据高速存取函数  driver层<br>  2) 文件系统低层通用函数 –对文件索引节点的管理，磁盘数据块的分配和释放以及文件名和i节点的转换算法<br>  3) 对文件中数据进行读写操作，包括对字符设备，管道，块读写文件中数据的访问<br>  4) 文件系统调用接口的实现；–涉及文件打开，关闭，创建以及有关文件目录操作等的系统调用； VFS  </p>
<h5 id="查看："><a href="#查看：" class="headerlink" title="查看："></a>查看：</h5><p>我们在使用文件系统时，用到的大多是目录，文件，并不会去考虑实际的文件系统类型等，只有当比如插u盘的时候因为系统不支持u盘的文件系统显示不出来，才会去考虑这个问题；<br>那文件系统，和目录，文件是什么关系和区别？linux支持多种文件系统，比如ext系列，以及内存文件系统如procfs,它挂载在/proc下，也就是说，/proc这个路径和/usr这个路径是不同的文件系统；<br>比如通过如下命令，可以知道路径对应的文件系统</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~$ mount | column -t</span><br><span class="line">/dev/sda1   on  /                        <span class="built_in"> type </span> ext4             (rw,<span class="attribute">errors</span>=remount-ro)</span><br><span class="line">proc        on  /proc                    <span class="built_in"> type </span> proc             (rw,noexec,nosuid,nodev)</span><br><span class="line">sysfs       on  /sys                     <span class="built_in"> type </span> sysfs            (rw,noexec,nosuid,nodev)</span><br><span class="line">none        on  /sys/fs/cgroup           <span class="built_in"> type </span> tmpfs            (rw)</span><br><span class="line">none        on  /sys/fs/fuse/connections <span class="built_in"> type </span> fusectl          (rw)</span><br><span class="line">none        on  /sys/kernel/<span class="builtin-name">debug</span>        <span class="built_in"> type </span> debugfs          (rw)</span><br><span class="line">none        on  /sys/kernel/security     <span class="built_in"> type </span> securityfs       (rw)</span><br><span class="line">udev        on  /dev                     <span class="built_in"> type </span> devtmpfs         (rw,<span class="attribute">mode</span>=0755)</span><br><span class="line">devpts      on  /dev/pts                 <span class="built_in"> type </span> devpts           (rw,noexec,nosuid,<span class="attribute">gid</span>=5,mode=0620)</span><br><span class="line">tmpfs       on  /<span class="builtin-name">run</span>                     <span class="built_in"> type </span> tmpfs            (rw,noexec,nosuid,<span class="attribute">size</span>=10%,mode=0755)</span><br><span class="line">none        on  /run/lock                <span class="built_in"> type </span> tmpfs            (rw,noexec,nosuid,nodev,<span class="attribute">size</span>=5242880)</span><br><span class="line">none        on  /run/shm                 <span class="built_in"> type </span> tmpfs            (rw,nosuid,nodev)</span><br><span class="line">none        on  /run<span class="built_in">/user </span>               <span class="built_in"> type </span> tmpfs            (rw,noexec,nosuid,nodev,<span class="attribute">size</span>=104857600,mode=0755)</span><br><span class="line">none        on  /sys/fs/pstore           <span class="built_in"> type </span> pstore           (rw)</span><br><span class="line">systemd     on  /sys/fs/cgroup/systemd   <span class="built_in"> type </span> cgroup           (rw,noexec,nosuid,nodev,none,<span class="attribute">name</span>=systemd)</span><br><span class="line">gvfsd-fuse  on  /run/user/1000/gvfs      <span class="built_in"> type </span> fuse.gvfsd-fuse  (rw,nosuid,nodev,<span class="attribute">user</span>=think)</span><br><span class="line"></span><br><span class="line">以及：</span><br><span class="line">think@think-VirtualBox:~$ df -H</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            2.0G  4.1k  2.0G   1% /dev</span><br><span class="line">tmpfs           415M  926k  414M   1% /run</span><br><span class="line">/dev/sda1        28G   25G  1.6G  95% /</span><br><span class="line">none            4.1k     0  4.1k   0% /sys/fs/cgroup</span><br><span class="line">none            5.3M     0  5.3M   0% /run/lock</span><br><span class="line">none            2.1G   78k  2.1G   1% /run/shm</span><br><span class="line">none            105M   66k  105M   1% /run/user</span><br></pre></td></tr></table></figure>
<h4 id="文件系统架构"><a href="#文件系统架构" class="headerlink" title="文件系统架构"></a>文件系统架构</h4><img src="/2021/03/12/filesystem/vfs0.png" title="vfs0 about">
<p>VFS本质是什么？<br>linux为了支持各种文件系统，且在同时允许访问其他操作系统文件，linux内核在用户进程(或c库）和文件系统实现之间引入了一个抽象层，这个抽象层称为VFS;<br>VFS的任务：<br>一方面，提供一种操作文件，目录和其他对象的统一方法，另一方面，它必须能够与各种方法给出的具体文件系统达成妥协；<br>用户空间包含一些应用程序（例如，文件系统的使用者）和 GNU C 库（glibc），它们为文件系统调用（打开、读取、写和关闭）提供用户接口。系统调用接口的作用就像是交换器，它将系统调用从用户空间发送到内核空间中的适当端点。  </p>
<h4 id="文件系统的分类：-1"><a href="#文件系统的分类：-1" class="headerlink" title="文件系统的分类："></a>文件系统的分类：</h4><p>文件系统分3种：<br>1) 基于磁盘的文件系统：如Ext2/3/4,Reiserfs,FAT,等，都是面向块的介质，需解决：如何将文件内容与结构信息存于目录层次结构上；从文件系统角度看，底层设备无非是存储块组成的一个列表，文件系统相当于对该列表实施一个适当的组织方案；<br>2) 虚拟文件系统：内核中生成，允许用户程序和内核信息通信的方法：/proc等；是内核在内存上建立的一个层次化的文件结构，文件大小为0；<br>3) 网络文件系统；这种文件系统允许访问另一个计算机的数据；数据存储于其他计算机上，内核无须关注文件存取等细节，而是通过命令和特定的协议如FTP等，而由于VFS抽象层，所以用户进程体会不到区别；  </p>
<h4 id="文件系统的组成（通用文件模型）概述："><a href="#文件系统的组成（通用文件模型）概述：" class="headerlink" title="文件系统的组成（通用文件模型）概述："></a>文件系统的组成（通用文件模型）概述：</h4><ul>
<li>概述：<br>VFS提供了一种结构模型，包含了一个强大文件系统所应具备的所有组件，该模型只存在于虚拟中，必须使用各种对象和函数指针与每种文件系统适配；</li>
<li>文件的概念：<br>在处理文件时，内核空间和用户空间使用的主要对象不同，用户程序而言，是一个fd,在所有关于文件操作中该整数作为标识文件的参数。文件描述符是在打开文件时由内核分配，只<br>在一个进程内部有效；两个不同的进程可以用同样的文件描述符，但是二者不是指向同一个文件。所以基于同一个fd来共享文件是不可能的；<br>对应到进程结构，是task_struct-&gt;file struct来表示一个文件结构的；</li>
<li>内核空间的文件：inode,每个文件(和目录)都有且只有一个对应的inode;inode包含很多文件信息除了文件名；<br>inode结构中的成员分类：<br>(1）描述文件状态的元数据，如访问权限或上次修改的日期<br>(2) 保存实际文件内容的数据段，用于保存文件<br>一个例子：/usr/bin/emacs的inode查找：<br>(1)setp1：根目录的inode/,其数据段不保存文件数据而是根目录下的各个目录项，表示文件或目录，每个目录项由inode编号(唯一）和文件或目录名称构成；<br>(2)step2: 查找子目录usr的inode,即在/对应的inode的数据段查找各个目录项，匹配usr,找到后在usr重复此过程，不过查找的是bin<br>(3)step3: 查找bin的目录项(目录项可能对应的是文件或目录),直到匹配上emacs,到此结束，emacs的inode的数据段指向的是文件内容；  </li>
</ul>
<img src="/2021/03/12/filesystem/inode1.png" title="inode1 about">  
<ul>
<li>链接和编程接口<br>链接：软链接和硬链接：<br> 软链接：即符号链接，删除链接文件不会影响源文件，软链接文件用一个独立的inode，数据段保存一个字符串给出链接目标路径；<br> 硬链接：无法区分哪个文件先创建，因为创建的目录项使用了一个现存的ino de编号；假设A是B的硬链接文件，删除A时，会删除A和B共享的inode,导致B也不能用了，当然，在inode中加入一个计数器即可防止这种情况；++直到计数器为0才删除inode<br>编程接口：<br> open/write<br> struct file和文件描述符  </li>
<li>万物皆文件：  <h4 id="VFS的结构组成："><a href="#VFS的结构组成：" class="headerlink" title="VFS的结构组成："></a>VFS的结构组成：</h4></li>
<li>结构概观：VFS由两个部分组成：文件和文件系统；<br>文件的表示和其他关联结构如下：包含结构和操作函数指针集合；<br>图：<img src="/2021/03/12/filesystem/vfs.png" title="vfs1 about">
</li>
</ul>
<p>结构分类：inode,超级块，目录，file</p>
<h5 id="inode-表示一个具体的文件"><a href="#inode-表示一个具体的文件" class="headerlink" title="inode:表示一个具体的文件"></a>inode:表示一个具体的文件</h5><p>inode操作：创建链接，文件重命名，目录中生存新文件，删除文件<br>前面有提到inode表示文件，即一个文件用一个inode表示，而文件关联的数据块信息，在inode中保存；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inode:</span><br><span class="line">    i_op:指向inode的操作函数</span><br><span class="line">    i_fop:指向inode对应的file的操作集合；</span><br><span class="line">    i_mapping:指向</span><br><span class="line">    i_sb:执行超级块</span><br><span class="line">    i_list:可以将inode存于一个链表中，总共<span class="number">3</span>种inode状态：</span><br><span class="line">                   <span class="number">1</span>-inode未关联到任何文件也为活动；对应inode_unuserd全局链表</span><br><span class="line">                   <span class="number">2</span>-inode所有使用但未改变得inode : inode_in_use全局链表</span><br><span class="line">                   <span class="number">3</span>-inode已经使用，且被改变，即与存储介质上的内容不同个，即脏inode:保存于一个特定于超级块的链表中；s_inodes;</span><br></pre></td></tr></table></figure>
<p>1) inode操作函数集合：<br>i_op: 即inode_operations:即用于负责管理结构性的操作，比如删除一个文件和文件相关的元数据，如属性；<br>i_fop: 和file结构，都是指向一个file_operations结构的指针，用于操作文件中包含的数据，比如读数据，写数据  </p>
<p>2) 在VFS中，内核通过三个全局链表来管理所有的inode:<br>(1) 每个inode都有一个i_list成员，可以将inode存储在一个链表中，根据inode的状态，他可能有3种主要的情况：<br>inode存在于内存中，未关联到任何文件，也不处于活动使用状态；<br>inode结构在内存中，正在由一个或多个进程使用，通常表示一个文件，两个计数器(i_count和i_nlink)都必须大于0；即上次与存储介质同步后，该inode没有改变过；<br>inode处于活动状态，其数据内容已经改变，与介质内容不同，即是脏的；  </p>
<p>(2) 在fs/inode.c中有两个全局变量做表头：<br>inode_unused,即上述第一类<br>inode_in_use:即第二类<br>而脏的第三类，在一个特定于超级块的链表中；  </p>
<p>(3) 还有一种情况就是，当移动介质改变时，此时所有的inode都无效了；无效的inode存在一个本地的链表中；  </p>
<p>(4) 除了上面的和状态有关的全局结构，还有一个散列表，用来支持根据inode编号和超级块快速访问inode; fs/inode.c: inode_hashtable;<br>    另外在超级表中，还有一个s_inodes表头的，i_sb_list做链表元素的链表；</p>
<p>总结来讲，就是每个文件有个关联的inode,vfs内核将所有的inode通过链表和散列表管理起来；通过inode编号等可以找到对应的inode</p>
<h5 id="file：表示一个与进程相关联的已打开的文件，和inode区别在，不同进程共享一个inode-但是不同进程各自维护file对象"><a href="#file：表示一个与进程相关联的已打开的文件，和inode区别在，不同进程共享一个inode-但是不同进程各自维护file对象" class="headerlink" title="file：表示一个与进程相关联的已打开的文件，和inode区别在，不同进程共享一个inode;但是不同进程各自维护file对象"></a>file：表示一个与进程相关联的已打开的文件，和inode区别在，不同进程共享一个inode;但是不同进程各自维护file对象</h5><p>fd用于在一个进程内唯一表示打开的文件；而在进程结构中，包含了一个file结构，来对应这个fd;<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* filesystem information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line"><span class="comment">/* open file information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Open file table structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * read mostly part</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * written part on a separate cache line in SMP</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">	<span class="keyword">int</span> next_fd; <span class="comment">//下一次打开新文件时使用的文件描述符</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec_init[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> open_fds_init[<span class="number">1</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span><span class="comment">//封装了文件名和inode之间的关联，以及文件所在文件系统的信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span><span class="comment">//指向了所有的文件操作接口，如打开文件，读写文件，其中的open用于打开一个文件，相当于将一个file对象关联到inode</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="keyword">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> 		f_flags;</span><br><span class="line">	<span class="keyword">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="keyword">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_ep_links</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure></p>
<p>files包含当前进程的各个文件描述符<br>file_operations    *f_op;//指向了所有的文件操作接口，如打开文件，读写文件，其中的open用于打开一个文件，相当于将一个file对象关联到inode,<br>不同的文件系统，设备，用不同的操作函数更新如：<br>fs/block_dev.c:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">def_blk_fops</span> = &#123;</span></span><br><span class="line">	.open		= blkdev_open,</span><br><span class="line">	.release	= blkdev_close,</span><br><span class="line">	.llseek		= block_llseek,</span><br><span class="line">	.read_iter	= blkdev_read_iter,</span><br><span class="line">	.write_iter	= blkdev_write_iter,</span><br><span class="line">	.mmap		= generic_file_mmap,</span><br><span class="line">	.fsync		= blkdev_fsync,</span><br><span class="line">	.unlocked_ioctl	= block_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">	.compat_ioctl	= compat_blkdev_ioctl,</span><br><span class="line">#endif</span><br><span class="line">	.splice_read	= generic_file_splice_read,</span><br><span class="line">	.splice_write	= iter_file_splice_write,</span><br><span class="line">&#125;;</span><br><span class="line">fs/ext3/file.c:</span><br><span class="line">是不同的初始化函数，具体不赘述；</span><br></pre></td></tr></table></figure></p>
<h5 id="关于超级块：superblock对象：-表示一个具体的可封装的文件系统，相当于书的封面"><a href="#关于超级块：superblock对象：-表示一个具体的可封装的文件系统，相当于书的封面" class="headerlink" title="关于超级块：superblock对象： 表示一个具体的可封装的文件系统，相当于书的封面"></a>关于超级块：superblock对象： 表示一个具体的可封装的文件系统，相当于书的封面</h5><p>整个文件系统的第一块空间，包含整个文件系统的基本信息，如块大小，指向空间的inode和数据块的指针等相关信息<br>VFS支持的文件系统类型通过一种特殊的内核对象连接进来，该对象提供了一种读取超级块的方法；<br>超级块信息：文件系统关键信息如块长度，最大文件长，读，写，操作inode的函数指针；<br>内核建立了一个链表，存储所有活动文件系统的超级块实例<br>超级块还有一个重要成员列表，包括相关文件系统中所有修改过的inode；  </p>
<h5 id="关于目录：目录信息，目录项缓存，命名空间，dentry-表示一个目录条目，或路径中的一个分量；"><a href="#关于目录：目录信息，目录项缓存，命名空间，dentry-表示一个目录条目，或路径中的一个分量；" class="headerlink" title="关于目录：目录信息，目录项缓存，命名空间，dentry: 表示一个目录条目，或路径中的一个分量；"></a>关于目录：目录信息，目录项缓存，命名空间，dentry: 表示一个目录条目，或路径中的一个分量；</h5><p>（1）在进程结构task_struct中，还有一个成员，用来维护和目录相关的信息：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">root</span>,<span class="title">pwd</span>,<span class="title">altroot</span>...//指定了相关进程的根目录,当前工作目录和特性目录</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">vfsmount</span> *<span class="title">rootmnt</span>，<span class="title">pwdmnt</span>,.:</span><span class="comment">//指定了相关进程的文件系统；当前工作目录的文件系统的vfsmount结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）VFS命名空间：<br>是为容器实现提供了可能，即每个容器分别跟踪装载的文件系统。VFS命名空间是所有已装载，构成某个容器目录树的文件系统的集合<br>对应的struct task_struct中的nsproxy<br>(3) 目录项缓存；<br>因为在inode查找时，即使设备数据已经在页缓存中，仍然会每次都重复整个查找操作，所以用目录项缓存(dentry缓存)来快速访问此前的查找结果；<br>     创建：内核在读取一个目录项（文件或目录）的数据后，就会创建一个dentry实例，以缓存找到的数据；可以从上图看到，file结构和inode结构都有一个相关的指针指向此结构；<br>     dentry结构：<br>     dentry缓存的组织：一个散列表：dentry_hashtable包含了所有的dentry对象<br>     dentry的操作函数集合：dentry_operations;<br>     dentry的一些标准函数操作  </p>
<h5 id="文件系统中的文件操作，如何将上述结构关联："><a href="#文件系统中的文件操作，如何将上述结构关联：" class="headerlink" title="文件系统中的文件操作，如何将上述结构关联："></a>文件系统中的文件操作，如何将上述结构关联：</h5><ul>
<li>open文件： int open(const char *pathname, int flags, mode_t mode);<br>最重要的参数是pathname,而返回的fd是后续执行的关键：<br>在fs/open.c:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(open, <span class="keyword">const</span> <span class="keyword">char</span> __user *, filename, <span class="keyword">int</span>, flags, <span class="keyword">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">		flags |= O_LARGEFILE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_sys_open</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *filename, <span class="keyword">int</span> flags, <span class="keyword">umode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">open_flags</span> <span class="title">op</span>;</span></span><br><span class="line">	<span class="keyword">int</span> fd = build_open_flags(flags, mode, &amp;op);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd)</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">    <span class="comment">//使用相关函数从用户空间得到文件名</span></span><br><span class="line">	tmp = getname(filename);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tmp))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(tmp);</span><br><span class="line">    <span class="comment">//分配一个fd，并做相关初始化</span></span><br><span class="line">	fd = get_unused_fd_flags(flags);</span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> = <span class="title">do_filp_open</span>(<span class="title">dfd</span>, <span class="title">tmp</span>, &amp;<span class="title">op</span>);</span></span><br><span class="line">        <span class="comment">//1 获取分配struct file,</span></span><br><span class="line">        <span class="comment">//2 查找文件名对应的inode：path_lookup,link_path_walk,do_follow_link</span></span><br><span class="line">        <span class="comment">// 内核试图在dentry缓存中找inode，并检查缓存是否有效，主要是操作dentry;</span></span><br><span class="line">        <span class="comment">//3 调用f_op-&gt;open函数,从而执行到设备层面的打开</span></span><br><span class="line">        <span class="comment">//4 返回file结构</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(f)) &#123;</span><br><span class="line">			put_unused_fd(fd);</span><br><span class="line">			fd = PTR_ERR(f);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fsnotify_open(f);</span><br><span class="line">			fd_install(fd, f);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	putname(tmp);</span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>中可以看到，open的基本过程<br>1 根据文件名查找inode, 若文件存在，则通过文件系统找到对应的inode，若文件不存在，则创建文件和关联；<br>2 初始化fd等结构，<br>3 执行底层的open函数；<br>注意：inode是初始化时就创建了，而创建文件，是将文件和inode关联起来；<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</span><br><span class="line">每个inode节点的大小，一般是<span class="number">128</span>字节或<span class="number">256</span>字节。inode节点的总数，在格式化时就给定，一般是每<span class="number">1</span>KB或每<span class="number">2</span>KB就设置一个inode。假定在一块<span class="number">1</span>GB的硬盘中，每个inode节点的大小为<span class="number">128</span>字节，每<span class="number">1</span>KB就设置一个inode，那么inode table的大小就会达到<span class="number">128</span>MB，占整块硬盘的<span class="number">12.8</span>%。</span><br><span class="line">查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</span><br><span class="line">由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~$ df -i</span><br><span class="line">Filesystem      Inodes  IUsed   IFree IUse% Mounted on</span><br><span class="line">udev           <span class="number"> 482138 </span>  <span class="number"> 475 </span><span class="number"> 481663 </span>   1% /dev</span><br><span class="line">tmpfs          <span class="number"> 505829 </span>  <span class="number"> 437 </span><span class="number"> 505392 </span>   1% /run</span><br><span class="line">/dev/sda1     <span class="number"> 1703936 </span>481526<span class="number"> 1222410 </span>  29% /</span><br><span class="line">none           <span class="number"> 505829 </span>    <span class="number"> 2 </span><span class="number"> 505827 </span>   1% /sys/fs/cgroup</span><br><span class="line">none           <span class="number"> 505829 </span>    <span class="number"> 3 </span><span class="number"> 505826 </span>   1% /run/lock</span><br><span class="line">none           <span class="number"> 505829 </span>    <span class="number"> 4 </span><span class="number"> 505825 </span>   1% /run/shm</span><br><span class="line">none           <span class="number"> 505829 </span>   <span class="number"> 28 </span><span class="number"> 505801 </span>   1% /run/user</span><br></pre></td></tr></table></figure>
<ul>
<li>read文件</li>
<li>write文件：</li>
</ul>
<h5 id="VFS对象的操作：-即关于创建和操作文件系统，注册，挂载等"><a href="#VFS对象的操作：-即关于创建和操作文件系统，注册，挂载等" class="headerlink" title="VFS对象的操作： 即关于创建和操作文件系统，注册，挂载等"></a>VFS对象的操作： 即关于创建和操作文件系统，注册，挂载等</h5><p>在创建文件系统和挂在文件系统时，主要涉及以下结构和操作：</p>
<ul>
<li>结构：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file_system_type:用于描述文件系统的结构</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">//文件系统名：eg: procfs</span></span><br><span class="line">	<span class="keyword">int</span> fs_flags;<span class="comment">//使用标志，如只读庄子，禁止setuid等</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_REQUIRES_DEV		1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_BINARY_MOUNTDATA	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_HAS_SUBTYPE		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_MOUNT		8	<span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_DEV_MOUNT	16 <span class="comment">/* A userns mount does not imply MNT_NODEV */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_VISIBLE	32	<span class="comment">/* FS must already be visible */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_RENAME_DOES_D_MOVE	32768	<span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="title">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>,</span></span><br><span class="line"><span class="class">		       <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span><span class="comment">//挂载时使用</span></span><br><span class="line">	<span class="keyword">void</span> (*kill_sb) (struct super_block *);<span class="comment">//不再需要此文件系统时的清理</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">//以模块加载时使用</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span><span class="comment">//各个可用的文件系统通过这个链接起来</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span>同一文件系统类型可能对应多个超级块结构，所以通过这个结构聚集在一个链表中；这个是表头</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>vfsmount: 维护挂载点相关信息等<br>super_block: 超级块以及它的操作函数集合，主要是对inode的管理，注意inode是fs层面的，和进程本身没有太大关系；  </p>
<ul>
<li><p>操作：<br>注册文件系统: register_filesystem;<br>装载文件系统：mount<br>卸载文件系统：umount  </p>
</li>
<li><p>所以，若想创建一个新的文件系统类型，需要自己初始化上面结构的值，以及对应的操作函数集合ops,同时调用注册，装载，等函数；<br>这里新的是，如何管理和分配，读写inode的接口，新的超级块，挂载结构vfsmount和文件系统结构file_system_type 实例；<br>这里不变的，是inode，dentry等文件相关的结构及其设备相关的操作集合；若想变，需要做更大的支持和改动；</p>
</li>
</ul>
<h5 id="从inode到具体的设备操作函数："><a href="#从inode到具体的设备操作函数：" class="headerlink" title="从inode到具体的设备操作函数："></a>从inode到具体的设备操作函数：</h5><ul>
<li><p>块设备和硬盘，分区的对应关系：<br>将一个磁盘添加到系统中时，内核将读取并分析底层块设备上的分区信息，但并不会对各个分区创建block_device(块设备结构)实例。为此，内核使用以下数据结构，对已经分区的<br>硬盘提供了一种表示：<br>&lt;genhd.h&gt; struct gendisk{<br>  int major: 主设备号<br>}<br>块设备，通用硬盘和分区之间的关联,todo </p>
</li>
<li><p>块设备的操作和请求队列等相关结构<br>虚拟文件系统中的每个文件都关联到恰好一个inode,用于管理文件的属性等；inode结构有设备相关的成员，如i_rdev,i_mode,i_fops,i_bdev,i_cdev等；<br>inode中有f_ops结构，被初始化为设备对应的操作函数集合，不同的设备，有不同的ops；<br>而inode中也有设备相关的字段，主要是主设备号和从设备号，通过这两个可以确定操作的文件对应的设备，并通过这两个设备号<br>拿到对应的设备操作函数集合，从而正确的操作；<br>inode,cdev,file,ops之间的关系；  </p>
</li>
<li>向系统添加磁盘和分区–其实就是对上面gendisk及其关联结构的创建和操作等 TD  </li>
</ul>
<h4 id="创建一个小的文件系统："><a href="#创建一个小的文件系统：" class="headerlink" title="创建一个小的文件系统："></a>创建一个小的文件系统：</h4><p>上面有提到，用户接口如何初始化一个分区格式为一个文件系统：<br>这里是介绍如何实现一个小的文件系统；<br><a href="https://github.com/accelazh/hellofs" target="_blank" rel="noopener">https://github.com/accelazh/hellofs</a><br>这里有一个github上实现的简单的文件系统，但是和笔者想的不太一样，这个不免粗暴了些；而且有些重要的接口反而没有实现，比如alloc_inode等inode管理的<br>函数；<br>待有时间再实现；  </p>
<h4 id="文件系统的内核接口"><a href="#文件系统的内核接口" class="headerlink" title="文件系统的内核接口"></a>文件系统的内核接口</h4><p>参考：网络socketfs等等实现；<br><a href="http://reader.epubee.com/books/mobile/eb/eba6bf6a9f551ecdf3cf131e59937e41/text00037.html" target="_blank" rel="noopener">http://reader.epubee.com/books/mobile/eb/eba6bf6a9f551ecdf3cf131e59937e41/text00037.html</a>  </p>
<h4 id="文件系统的用户接口"><a href="#文件系统的用户接口" class="headerlink" title="文件系统的用户接口"></a>文件系统的用户接口</h4><p>略，详细可以查相关资料；  </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>filesystem</tag>
      </tags>
  </entry>
  <entry>
    <title>memory_overiew</title>
    <url>/2021/03/06/memory-overiew/</url>
    <content><![CDATA[<h3 id="linux内存系统概述"><a href="#linux内存系统概述" class="headerlink" title="linux内存系统概述"></a>linux内存系统概述</h3><p>linux的内存系统是一个很复杂的系统，需要从几个角度去分析，里面包含多种机制，比如虚拟地址和物理地址的转换等等；本文是一个系统性的大局观来从几个方面分析内存系统的记录：<a id="more"></a><br>1 linux内存系统的地址空间：主要解释虚拟内存空间的机制和地址转换关系；<br>2 liunx内存系统的物理内存相关结构和虚拟内存相关结构：主要解释内核用什么样的数据结构来管理内存<br>3 linux内存初始化<br>4 linux内存系统的分配路线：从kernel和用户进程两路分配出发，最后都用到伙伴系统分配内存页；<br>5 linux内存的回收机制简单分析；<br>6 linux下内存的查看等：<br>其中涉及的调试方法和模块代码例子等等，包含在各个子节中；  </p>
<h3 id="linux内存系统的地址空间："><a href="#linux内存系统的地址空间：" class="headerlink" title="linux内存系统的地址空间："></a>linux内存系统的地址空间：</h3><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>一般来说，linux系统在使用时，只要一块物理内存，或者说，即使外部插入多个内存，最后再使用时，也是一个物理内存的地址空间;最开始的系统，使用内存都是直接通过取物理地址写入读取的;<br>而演变为采用虚拟地址空间，并通过MMU地址转换为物理地址，再访问真正的物理内存，其作用，一方面是进一步保护内存防止滥用和增加控制，另一方面，也对每个进程之间起到隔离作用，加强保护；<br>另外，还可以避免因为直接操作物理内存的情况下，不同进程操作时地址的不连续性带来更高的复杂度，更多作用，我想通过进一步学习，可以加深理解；</p>
<h4 id="虚拟地址空间："><a href="#虚拟地址空间：" class="headerlink" title="虚拟地址空间："></a>虚拟地址空间：</h4><ul>
<li>简介：<br>一般来说，linux内核把处理器的虚拟地址空间分为两个部分，底部比较大的部分用于用户进程，顶部则是专用于内核；所以在两个用户进程上下文切换的时候，只会改变下半部分；<br>而内核部分总是不变；所以不同的用户进程，有不同的虚拟地址空间，也就是说，两个不同的进程中的两个变量可以有相同的虚拟地址，但是实际物理内存确是不同的；<br>划分比如4G的内存，1G给到内核，3G给到用户空间；当然可以通过配置修改这种比例；  </li>
<li>举例<br>内核和用户进程，在操作时，变量等结构，函数等打印出来的指针(地址)，是虚拟地址，而实际写入和读取的数据是放在物理内存的，是有唯一的物理内存地址的，那虚拟地址是如何对应到物理内存地址的呢？<br>这个涉及到虚拟地址到物理地址的转换–MMU,借助MMU，linux可以把虚拟地址通过某种映射转换为物理地址；</li>
<li>MMU(内存管理单元):<br>是计算机系统的一个物理部件，通常是CPU的一部分(但不一定)， linux的MMU是一个很复杂的模块，本文暂时不会进行详细的分析，等后面有时间再深入研究：<br>关于MMU是如何将虚拟地址转换为物理地址的过程，可以参考下图：<img src="/2021/03/06/memory-overiew/MMU.png" title="MMU about">
</li>
</ul>
<h3 id="linux内存系统的相关结构："><a href="#linux内存系统的相关结构：" class="headerlink" title="linux内存系统的相关结构："></a>linux内存系统的相关结构：</h3><p>主要分为这几个部分：</p>
<ul>
<li>基础的，物理内存：</li>
<li>和MMU相关的</li>
<li>和虚拟内存相关的：和内核相关的，和用户进程相关的；<h4 id="基础的，物理内存："><a href="#基础的，物理内存：" class="headerlink" title="基础的，物理内存："></a>基础的，物理内存：</h4></li>
<li>NUMA概念：VM中流行的第一个主要概念是非均匀内存访问(NUMA)。在大型机器中，内存可能被根据与处理器的“距离”而产生不同的存取成本，划分为多个部分(结点)。例如，可能有一个内存库分配给每个CPU或一个内存库非常适合DMA近设备卡。每个部分称为一个node,由挂在同一个CPU下的一片连续的物理内存组成，在内核中使用pg_data_t进行抽象.<br>可以从linux/mmzone.h来找到相关结构：<img src="/2021/03/06/memory-overiew/NUMA.png" title="NUMA about">
</li>
</ul>
<ul>
<li>NUMA的结点node和相关的结构：zone:  <img src="/2021/03/06/memory-overiew/numa_zone.png" title="numa_zone about">
由于一些特殊的应用场景，导致只能分配特定地址范围内的内存（比如老式的ISA设备DMA时只能使用前16M内存；比如kmalloc只能分配低端内存，而不能分配高端内存），因此在node中又将内存细分为zone。<br>zone 有以下几种类型，由zone结构中的flags标识；<br> 1) ZONE_DMA：定义适合DMA的内存域，该区域的长度依赖于处理器类型。比如ARM所有地址都可以进行DMA，所以该值可以很大，或者干脆不定义DMA类型的内存域。而在IA-32的处理器上，一般定义为16M。<br> 2) ZONE_DMA32：只在64位系统上有效，为一些32位外设DMA时分配内存。如果物理内存大于4G，该值为4G，否则与实际的物理内存大小相同。<br> 3) ZONE_NORMAL：定义可直接映射到内核空间的普通内存域。在64位系统上，如果物理内存小于4G，该内存域为空。而在32位系统上，该值最大为896M。<br> 4) ZONE_HIGHMEM：只在32位系统上有效，标记超过896M范围的内存。在64位系统上，由于地址空间巨大，超过4G的内存都分布在ZONE_NORMA内存域。<br> 5) ZONE_MOVABLE：伪内存域，为了实现减小内存碎片的机制。</li>
</ul>
<ul>
<li><p>zone结构下的free_area,free_list和伙伴系统：<br>简单的说，就是zone下维护的free_area,是维护2^n个page的内存块的链表的数据结构，用来方便分配指定大小的内存页以及进行合并，拆分等，解决页外碎片的机制：<br>更详细可以参考：<a href="http://blog.chinaunix.net/uid-30282771-id-5185451.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-30282771-id-5185451.html</a><br>或者翻阅资料；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cat /proc/buddyinfo </span><br><span class="line">Node <span class="number">0</span>, zone      DMA      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">3</span> </span><br><span class="line">Node <span class="number">0</span>, zone    DMA32      <span class="number">4</span>      <span class="number">2</span>      <span class="number">3</span>     <span class="number">28</span>    <span class="number">149</span>     <span class="number">21</span>     <span class="number">13</span>      <span class="number">8</span>      <span class="number">1</span>      <span class="number">2</span>    <span class="number">178</span> </span><br><span class="line">Node <span class="number">0</span>, zone   Normal      <span class="number">2</span>     <span class="number">84</span>     <span class="number">46</span>     <span class="number">23</span>     <span class="number">13</span>     <span class="number">13</span>     <span class="number">15</span>     <span class="number">21</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>page：即物理页，物理内存是按页为单元进行分配管理的，一页通常是4k</p>
</li>
<li>以下是在linux4.8中以上各个数据结构的定义：<br>linux/mmzone.h pg_data_t:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">	<span class="keyword">int</span> nr_zones;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP	<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_NO_BOOTMEM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must be held any time you expect node_start_pfn, node_present_pages</span></span><br><span class="line"><span class="comment">	 * or node_spanned_pages stay constant.  Holding this will also</span></span><br><span class="line"><span class="comment">	 * guarantee that any pfn_valid() stays that way.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment">	 * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_pfn;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_spanned_pages; <span class="comment">/* total size of physical page</span></span><br><span class="line"><span class="comment">					     range, including holes */</span></span><br><span class="line">	<span class="keyword">int</span> node_id;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>	<span class="comment">/* Protected by</span></span><br><span class="line"><span class="comment">					   mem_hotplug_begin/end() */</span></span><br><span class="line">	<span class="keyword">int</span> kswapd_order;</span><br><span class="line">	<span class="keyword">enum</span> zone_type kswapd_classzone_idx;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="keyword">int</span> kcompactd_max_order;</span><br><span class="line">	<span class="keyword">enum</span> zone_type kcompactd_classzone_idx;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">	<span class="comment">/* Lock serializing the migrate rate limiting window */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> numabalancing_migrate_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Rate limiting time interval */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> numabalancing_migrate_next_window;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of pages migrated during the rate limiting time interval */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> numabalancing_migrate_nr_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a per-node reserve of pages that are not available</span></span><br><span class="line"><span class="comment">	 * to userspace allocations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line">	<span class="keyword">spinlock_t</span>		lru_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">	 * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> split_queue_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">split_queue</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> split_queue_len;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>		<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on</span></span><br><span class="line"><span class="comment">	 * this node's LRU.  Maintained by the pageout code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> inactive_ratio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-node vmstats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br><span class="line"><span class="keyword">pg_data_t</span>中描述了node的所有基本元素：</span><br><span class="line">    <span class="number">1</span>) node_zones: 该node包含的内存域zone</span><br><span class="line">    <span class="number">2</span>) node_zonelists：该node的备选节点及内存域列表，后面会详细说明。</span><br><span class="line">    <span class="number">3</span>) node_mem_map：linux为每个物理页分配了一个<span class="class"><span class="keyword">struct</span> <span class="title">page</span>的管理结构体，并形成了一个结构体数组，<span class="title">node_mem_map</span>即为数组的指针；<span class="title">pfn_to_page</span>和<span class="title">page_to_pfn</span>都借助该数组实现。</span></span><br><span class="line"><span class="class">    4) <span class="title">node_start_pfn</span>：该<span class="title">node</span>中内存的起始页帧号</span></span><br><span class="line"><span class="class">    5) <span class="title">node_present_pages</span>：该<span class="title">node</span>中所有的物理<span class="title">page</span>页数</span></span><br><span class="line"><span class="class">    6) <span class="title">node_spanned_pages</span>：该<span class="title">node</span>地址范围内的所有<span class="title">page</span>页数，包括空洞；目前还不清楚什么情况导致与<span class="title">node_present_pages</span>不同。</span></span><br><span class="line"><span class="class">    7) <span class="title">kswapd</span>：负责回收该<span class="title">node</span>内存的内核线程，每个<span class="title">node</span>对应一个内核线程<span class="title">kswapd</span>。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>zone:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> watermark[NR_WMARK];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We don't know if the memory that we're going to allocate will be freeable</span></span><br><span class="line"><span class="comment">	 * or/and it will be released eventually, so to avoid totally wasting several</span></span><br><span class="line"><span class="comment">	 * GB of ram we must reserve some of the lower zone memory (otherwise we risk</span></span><br><span class="line"><span class="comment">	 * to run OOM on the lower zones despite there's tons of freeable ram</span></span><br><span class="line"><span class="comment">	 * on the higher zones). This array is recalculated at runtime if the</span></span><br><span class="line"><span class="comment">	 * sysctl_lowmem_reserve_ratio sysctl changes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on</span></span><br><span class="line"><span class="comment">	 * this zone's LRU.  Maintained by the pageout code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> inactive_ratio;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a per-zone reserve of pages that should not be</span></span><br><span class="line"><span class="comment">	 * considered dirtyable memory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		dirty_balance_reserve;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment">	 * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		zone_start_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">	 * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">	 * 	spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">	 * is calculated as:</span></span><br><span class="line"><span class="comment">	 *	present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">	 * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">	 * bootmem allocator):</span></span><br><span class="line"><span class="comment">	 *	managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">	 * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">	 * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">	 * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">	 * and thresholds.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Locking rules:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">	 * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">	 * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">	 * quite infrequently.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">	 * frequently read in proximity to zone-&gt;lock.  It's good to</span></span><br><span class="line"><span class="comment">	 * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">	 * mem_hotplug_begin/end(). Any reader who can't tolerant drift of</span></span><br><span class="line"><span class="comment">	 * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Read access to managed_pages should be safe because it's unsigned</span></span><br><span class="line"><span class="comment">	 * long. Write access to zone-&gt;managed_pages and totalram_pages are</span></span><br><span class="line"><span class="comment">	 * protected by managed_page_count_lock at runtime. Idealy only</span></span><br><span class="line"><span class="comment">	 * adjust_managed_page_count() should be used instead of directly</span></span><br><span class="line"><span class="comment">	 * touching zone-&gt;managed_pages and totalram_pages.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		managed_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		spanned_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		present_pages;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of MIGRATE_RESERVE page block. To maintain for just</span></span><br><span class="line"><span class="comment">	 * optimization. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span>			nr_migrate_reserve_block;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment">	 * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment">	 * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">	<span class="keyword">seqlock_t</span>		span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * wait_table		-- the array holding the hash table</span></span><br><span class="line"><span class="comment">	 * wait_table_hash_nr_entries	-- the size of the hash table array</span></span><br><span class="line"><span class="comment">	 * wait_table_bits	-- wait_table_size == (1 &lt;&lt; wait_table_bits)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The purpose of all these is to keep track of the people</span></span><br><span class="line"><span class="comment">	 * waiting for a page to become available and make them</span></span><br><span class="line"><span class="comment">	 * runnable again when possible. The trouble is that this</span></span><br><span class="line"><span class="comment">	 * consumes a lot of space, especially when so few things</span></span><br><span class="line"><span class="comment">	 * wait on pages at a given time. So instead of using</span></span><br><span class="line"><span class="comment">	 * per-page waitqueues, we use a waitqueue hash table.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The bucket discipline is to sleep on the same queue when</span></span><br><span class="line"><span class="comment">	 * colliding and wake all in that wait queue when removing.</span></span><br><span class="line"><span class="comment">	 * When something wakes, it must check to be sure its page is</span></span><br><span class="line"><span class="comment">	 * truly available, a la thundering herd. The cost of a</span></span><br><span class="line"><span class="comment">	 * collision is great, but given the expected load of the</span></span><br><span class="line"><span class="comment">	 * table, they should be so rare as to be outweighed by the</span></span><br><span class="line"><span class="comment">	 * benefits from the saved space.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __wait_on_page_locked() and unlock_page() in mm/filemap.c, are the</span></span><br><span class="line"><span class="comment">	 * primary users of these fields, and in mm/page_alloc.c</span></span><br><span class="line"><span class="comment">	 * free_area_init_core() performs the initialization of them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span>	*wait_table;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		wait_table_hash_nr_entries;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		wait_table_bits;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line">	<span class="comment">/* free areas of different sizes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone flags, see below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lru_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>		<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Evictions &amp; activations on the inactive file list */</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		inactive_age;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">	 * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">	 * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_cached_free_pfn;</span><br><span class="line">	<span class="comment">/* pfn where async and sync compaction migration scanner should start */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_cached_migrate_pfn[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">	 * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">	 * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		compact_considered;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		compact_defer_shift;</span><br><span class="line">	<span class="keyword">int</span>			compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">	<span class="keyword">bool</span>			compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad3_)</span><br><span class="line">	<span class="comment">/* Zone statistics */</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure></p>
<p>free_area:注意在zone定义中数组大小只有11，意味着是只支持到2^10个页大小的内存块<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">/include/linux/mm_types.h</span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each physical page in the system has a struct page associated with</span></span><br><span class="line"><span class="comment"> * it to keep track of whatever it is we are using the page for at the</span></span><br><span class="line"><span class="comment"> * moment. Note that we have no way to track which tasks are using</span></span><br><span class="line"><span class="comment"> * a page, though if it is a pagecache page, rmap structures can tell us</span></span><br><span class="line"><span class="comment"> * who is mapping it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The objects in struct page are organized in double word blocks in</span></span><br><span class="line"><span class="comment"> * order to allows us to use atomic double word operations on portions</span></span><br><span class="line"><span class="comment"> * of struct page. That is currently only used by slub but the arrangement</span></span><br><span class="line"><span class="comment"> * allows the use of atomic double word operations on the flags/mapping</span></span><br><span class="line"><span class="comment"> * and lru list pointers also.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="comment">/* First double word block */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;		<span class="comment">/* Atomic flags, some possibly</span></span><br><span class="line"><span class="comment">					 * updated asynchronously */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span>	<span class="comment">/* If low bit clear, points to</span></span><br><span class="line"><span class="comment">						 * inode address_space, or NULL.</span></span><br><span class="line"><span class="comment">						 * If page mapped as anonymous</span></span><br><span class="line"><span class="comment">						 * memory, low bit is set, and</span></span><br><span class="line"><span class="comment">						 * it points to anon_vma object:</span></span><br><span class="line"><span class="comment">						 * see PAGE_MAPPING_ANON below.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">		<span class="keyword">void</span> *s_mem;			<span class="comment">/* slab first object */</span></span><br><span class="line">		<span class="keyword">atomic_t</span> compound_mapcount;	<span class="comment">/* first tail page */</span></span><br><span class="line">		<span class="comment">/* page_deferred_list().next	 -- second tail page */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Second double word */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">union</span> &#123;</span><br><span class="line">			<span class="keyword">pgoff_t</span> index;		<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">			<span class="keyword">void</span> *freelist;		<span class="comment">/* sl[aou]b first free object */</span></span><br><span class="line">			<span class="comment">/* page_deferred_list().prev	-- second tail page */</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line">	defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span><br><span class="line">			<span class="comment">/* Used for cmpxchg_double in slub */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> counters;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Keep _count separate from slub cmpxchg_double data.</span></span><br><span class="line"><span class="comment">			 * As the rest of the double word is protected by</span></span><br><span class="line"><span class="comment">			 * slab_lock but _count is not.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> counters;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">union</span> &#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * Count of ptes mapped in mms, to show</span></span><br><span class="line"><span class="comment">					 * when page is mapped &amp; limit reverse</span></span><br><span class="line"><span class="comment">					 * map searches.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					<span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* SLUB */</span></span><br><span class="line">						<span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">						<span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">						<span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">					&#125;;</span><br><span class="line">					<span class="keyword">int</span> units;	<span class="comment">/* SLOB */</span></span><br><span class="line">				&#125;;</span><br><span class="line">				<span class="keyword">atomic_t</span> _count;		<span class="comment">/* Usage count, see below. */</span></span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> active;	<span class="comment">/* SLAB */</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Third double word block</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * WARNING: bit 0 of the first word encode PageTail(). That means</span></span><br><span class="line"><span class="comment">	 * the rest users of the storage space MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">	 * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>	<span class="comment">/* Pageout list, eg. active_list</span></span><br><span class="line"><span class="comment">					 * protected by zone-&gt;lru_lock !</span></span><br><span class="line"><span class="comment">					 * Can be used as a generic list</span></span><br><span class="line"><span class="comment">					 * by the page owner.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span> <span class="comment">/* ZONE_DEVICE pages are never on an</span></span><br><span class="line"><span class="comment">					    * lru or handled by a slab</span></span><br><span class="line"><span class="comment">					    * allocator, this points to the</span></span><br><span class="line"><span class="comment">					    * hosting device page map.</span></span><br><span class="line"><span class="comment">					    */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>		<span class="comment">/* slub per cpu partial pages */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span>	<span class="comment">/* Next partial slab */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">			<span class="keyword">int</span> pages;	<span class="comment">/* Nr of partial slabs left */</span></span><br><span class="line">			<span class="keyword">int</span> pobjects;	<span class="comment">/* Approximate # of objects */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line">			<span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span>	<span class="comment">/* Used by SLAB</span></span><br><span class="line"><span class="comment">						 * when destroying via RCU</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">		<span class="comment">/* Tail pages of compound page */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head; <span class="comment">/* If bit zero is set */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* First tail page only */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * On 64 bit system we have enough space in struct page</span></span><br><span class="line"><span class="comment">			 * to encode compound_dtor and compound_order with</span></span><br><span class="line"><span class="comment">			 * unsigned int. It can help compiler generate better or</span></span><br><span class="line"><span class="comment">			 * smaller code on some archtectures.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> compound_dtor;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> compound_dtor;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> __pad;	<span class="comment">/* do not overlay pmd_huge_pte</span></span><br><span class="line"><span class="comment">						 * with compound_head to avoid</span></span><br><span class="line"><span class="comment">						 * possible bit 0 collision.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">			<span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">		&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remainder is not double word aligned */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;		<span class="comment">/* Mapping-private opaque data:</span></span><br><span class="line"><span class="comment">					 	 * usually used for buffer_heads</span></span><br><span class="line"><span class="comment">						 * if PagePrivate set; used for</span></span><br><span class="line"><span class="comment">						 * swp_entry_t if PageSwapCache;</span></span><br><span class="line"><span class="comment">						 * indicates order in the buddy</span></span><br><span class="line"><span class="comment">						 * system if PG_buddy is set.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SPLIT_PTE_PTLOCKS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">		<span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span>	<span class="comment">/* SL[AU]B: Pointer to slab */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment">	 * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment">	 * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment">	 * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment">	 * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment">	 * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">virtual</span>;			<span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">					   not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * kmemcheck wants to track the status of each byte in a page; this</span></span><br><span class="line"><span class="comment">	 * is a pointer to such a status block. NULL if not tracked.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">	<span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The struct page can be forced to be double word aligned so that atomic ops</span></span><br><span class="line"><span class="comment"> * on double words work. The SLUB allocator can make use of such a feature.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAVE_ALIGNED_STRUCT_PAGE</span></span><br><span class="line">	__aligned(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">;</span><br></pre></td></tr></table></figure></p>
<h5 id="实践：操作zone等："><a href="#实践：操作zone等：" class="headerlink" title="实践：操作zone等："></a>实践：操作zone等：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">  * Author: ksx</span></span><br><span class="line"><span class="comment">  * File name: sysctl_example.c</span></span><br><span class="line"><span class="comment">  * Description: sysctl example</span></span><br><span class="line"><span class="comment">  * Date: 2021-02-26</span></span><br><span class="line"><span class="comment">  *********************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/swap.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/topology.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/mm_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">pages</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">sysctl_example_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    pages = alloc_pages(GFP_KERNEL,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(!pages) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        printk(<span class="string">"alloc_pages Successfully!\n"</span>); </span><br><span class="line">        printk(<span class="string">"page_address(pages) = 0x%lx\n"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_address(pages));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">arr</span> = <span class="title">NODE_DATA</span>(<span class="title">numa_node_id</span>())-&gt;<span class="title">node_zones</span>;</span></span><br><span class="line">   <span class="comment">// printk(KERN_INFO,"zone: some:%ld\n",z1.managed_pages);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zoneli</span> = <span class="title">node_zonelist</span>(<span class="title">numa_node_id</span>(),<span class="title">GFP_KERNEL</span>);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> free_areasize = <span class="keyword">sizeof</span>(arr-&gt;free_area)/<span class="keyword">sizeof</span>(arr-&gt;free_area[<span class="number">0</span>]);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">fa</span> = <span class="title">arr</span>-&gt;<span class="title">free_area</span>;</span></span><br><span class="line">    <span class="keyword">int</span> freearea0_nrfree = arr-&gt;free_area[<span class="number">0</span>].nr_free;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">"sysctl registercess %ld num_node_id:%d freeareasize :%u freelist:: %ld nr_free:%d\n"</span>,nr_free_buffer_pages(),numa_node_id(),free_areasize,<span class="keyword">sizeof</span>(fa-&gt;free_list)/<span class="keyword">sizeof</span>(fa-&gt;free_list[<span class="number">0</span>]),freearea0_nrfree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">sysctl_example_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"sysctl unregister success.\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(pages) </span><br><span class="line">    &#123;</span><br><span class="line">        __free_pages(pages,<span class="number">8</span>);   <span class="comment">// 释放所分配的</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">        printk(<span class="string">"__free_pages ok!\n"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(sysctl_example_init);</span><br><span class="line">module_exit(sysctl_example_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="和MMU相关的："><a href="#和MMU相关的：" class="headerlink" title="和MMU相关的："></a>和MMU相关的：</h4><ul>
<li>TLB:<br>地址转换需要几次内存访问，内存访问相对CPU速度较慢。为了避免在地址转换上花费宝贵的处理器周期，cpu维护了一个名为翻译后备缓冲区(translation Lookaside Buffer, TLB)的此类转换缓存。</li>
<li>Huge Pages:Linux中有两种机制支持将物理内存映射到大页面。第一个是HugeTLB文件系统，或hugetlbfs。它是一个使用RAM作为后备存储的伪文件系统。对于在该文件系统中创建的文件，数据驻留在内存中，并使用大页进行映射。</li>
<li>page tables:页表,页表是用来建立用户进程虚拟地址空间和系统物理内存(页帧等)之间的关联：即通过上述图1可以看到线性(虚拟)地址和页表的关系，linux用三级甚至4级页表来管理内存页<br>通过页表，每个进程提供一致的虚拟地址空间，应用程序看到的地址空间是一个连续的内存区，该表也将虚拟内存页映射到物理内存，进而支持共享内存的实现，即几个进程共享的内存；<br>相关结构： /asm-arch/page.h  asm-arch/pgtable.h和具体的体系架构相关；  </li>
</ul>
<p>每个进程都有一个指针(mm_struct→pgd)指向它自己的页全局目录(pgd)， pgd是一个物理页帧。这个框架包含一个类型为pgd_t的数组，pgd_t是在&lt;asm/page.h&gt;中定义的架构特定类型。根据架构的不同，页表的加载方式也不同。在x86上，通过将mm_struct→pgd复制到cr3寄存器来加载进程页表，这有冲洗TLB的副作用。事实上，这就是函数__flush_tlb()在依赖于体系结构的代码中实现的方式。<br>PGD表中的每个活动条目指向一个包含pmd_t类型的页中间目录(PMD)项数组的页框架，该页框架又指向一个包含pte_t类型的页表项(PTE)的页框架，pte_t类型的页表项最终指向包含实际用户数据的页框架。如果页面被交换到后备存储，交换项将存储在PTE中，并在页面故障期间由do_swap_page()使用，以查找包含页面数据的交换项。  </p>
<p>页表项的一些操作函数:pgd_alloc(如 /arch/arm64/mm/pgd.c),pte_page,pud_alloc等等<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">页表：层次化的页表用于支持对大地址空间的快速，高效管理；</span><br><span class="line">用于建立用户进程的虚拟地址空间和系统物理内存（内存，页帧）之间的关联</span><br><span class="line">页表也用于向每个进程提供一致的虚拟地址空间，应用程序看到的地址空间是一个连续的内存区，该表也将虚拟内存页映射到物理内存，因而支持共享内存的实现；</span><br><span class="line">内核内存管理使用四级页表，不管底层处理器，一个页表有<span class="number">1024</span>项，每项对应一个页(<span class="number">4</span>K)</span><br><span class="line">内存虚拟地址的分解：</span><br><span class="line">页表格式：   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * These are used to make use of C type-checking..</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pte; &#125; <span class="keyword">pte_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pmd; &#125; <span class="keyword">pmd_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_PGTABLE_LEVELS == 4</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pud; &#125; <span class="keyword">pud_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pgd; &#125; <span class="keyword">pgd_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pgprot; &#125; <span class="keyword">pgprot_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">pgtable_t</span>;</span></span><br><span class="line"></span><br><span class="line">用于处理内存页的体系结构相关状态的函数以及页表项操作函数</span><br></pre></td></tr></table></figure></p>
<img src="/2021/03/06/memory-overiew/pgtable.png" title="pgtable about">
<img src="/2021/03/06/memory-overiew/pgtable2.png" title="pgtable about">
<p>更多参考：<a href="https://www.kernel.org/doc/gorman/html/understand/understand006.html" target="_blank" rel="noopener">https://www.kernel.org/doc/gorman/html/understand/understand006.html</a></p>
<ul>
<li>和虚拟内存相关的：<br>内核相关：<br>内核内存分配器：slab/slub/slob,具体使用场景和机制见下 内核的内存分配<br>eg:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>		<span class="comment">//slab描述符的三个双向循环链表中的一个</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff;	<span class="comment">//slab中第一个对象</span></span><br><span class="line">	<span class="keyword">void</span> *s_mem;			<span class="comment">//slab中第一个对象的地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;		<span class="comment">//当前正在使用的slab中的对象的个数</span></span><br><span class="line">	<span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;		<span class="comment">//slab中第一个空闲对象的下标。</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> nodeid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用户进程相关：具体怎么用见下 用户进程的内存分配<br>/include/linux/mm_types.h vm_area_struct<br>在 task_struct-&gt;mm_struct-&gt;vm_area_struct* 链表<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct defines a memory VMM memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task.  A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="keyword">pgprot_t</span> vm_page_prot;		<span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">	 * linkage into the address_space-&gt;i_mmap interval tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</span><br><span class="line">	&#125; shared;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">	 * list, after a COW of one of the file pages.	A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">	 * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> <span class="comment">/* Serialized by mmap_sem &amp;</span></span><br><span class="line"><span class="comment">					  * page_table_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>	<span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Information about our backing store: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">					   units */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">	<span class="keyword">void</span> * vm_private_data;		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="linux内存初始化简介："><a href="#linux内存初始化简介：" class="headerlink" title="linux内存初始化简介："></a>linux内存初始化简介：</h3><ul>
<li><p>概述：<br>初始化大都是建立全局数据结构并做初始化，设置系统状态，寄存器等等，linux内存也是大致如此；<br>linux内存初始化有个过程比较特别，就是在建立起这个内存管理之前，也要内存，但是此时是不能用内存管理接口的，那在这期间，是使用了一个额外的简化形式的内存管理模块(bootmem)<br>在初始化完成内存管理后，再丢弃掉；<br>linux内存初始化主要是体系架构相关的初始化和机器无关的初始化：前者主要是统计系统可用内存总数，以及cpu模型，结点node数量和内存域之间的分配情况，后者主要是建立起前面介绍的各个必要结构，比如pg_data_t;前者完成后，才能完成后者；<br>我们可以通过一个宏 mmzone.h: #define NODE_DATA(nid)        (&amp;contig_page_data) 来获取到对应node编号的 pg_data_t实例，进而进行操作；  </p>
</li>
<li><p>系统启动时内存的的初始化流程：<br>在初始化过程中主要包含以下几个步骤，在如下源文件中：<br>依然是从：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> arch/ia64/kernel/head.S, line <span class="number">413</span></span><br><span class="line">    arch/arm64/kernel/head.S, line <span class="number">453</span></span><br><span class="line">    等都能找到其调用start_kernel，这个函数就是用来启动内核；</span><br><span class="line">    注意这个头文件：include/linux/start_kernel.h, line <span class="number">11</span> (as a prototype)</span><br><span class="line">    和这个实现文件：init/main.c, line <span class="number">849</span> (as a function)</span><br><span class="line">```c</span><br><span class="line">    head.S -&gt;start_kernel(init/main.c)</span><br><span class="line">      lock_kernel();<span class="comment">//首先让lock_depth变量自增，然后判断结果是否为0，如果是，则进行对信号量的自减操作，类似于PV操作</span></span><br><span class="line">   start_kernel()函数会做很多init初始化，里面自然也有内存相关的初始化：</span><br><span class="line">       setup_arch 体系结构相关的初始化</span><br><span class="line">       setup_per_cpu_areas 每个cpu的初始化</span><br><span class="line">       build_all_zonelists 初始化建立结点和内存区域</span><br><span class="line">       mem_init  特定于体系结构的，用于停用bootmem分配器并迁移到内存管理函数</span><br><span class="line">       kmem_cache_init:初始化内核内部小块内存区的分配器</span><br><span class="line">       setup_per_cpu_pageset：zone下为pageset数组的第一个数组元素分配内存，分配第一个数组元素；</span><br><span class="line">关于结点和内存域初始化：</span><br><span class="line">```cpp</span><br><span class="line">在page_alloc.c 中</span><br><span class="line">void __init build_all_zonelists(void)遍历所有结点进行初始化</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; numnodes ; i++)</span><br><span class="line">		build_zonelists(NODE_DATA(i));<span class="comment">//通过这个结构可以拿到所有的node_data[] pg_data_t</span></span><br><span class="line">	printk(<span class="string">"Built %i zonelists\n"</span>, numnodes);</span><br><span class="line">&#125;</span><br><span class="line">free_area: mmzone.h </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过模块类似的获取机制，来获取当前系统的页详情，以及分配时的动态变化；<br>build_zonelists：这个函数任务为：在当前处理的结点的内存域和其他结点的内存域之间建立一个等级次序，并下来按这种次序分配内存；<br>等级次序例子：内存要分配高端内存，则首先企图在当前结点的高端内存中找一个大小合适的空闲段，若失败，则查看该结点的普通内存域，若还是失败，则看<br>该结点的DMA内存域进行分配，还失败就去找其他结点；备选结点要尽量靠近主结点；<br>层次结构：<br>首先分配高端内存：廉价，在于内核没有任何部分依赖该内存域分配的内存；<br>接着普通内存：许多内核数据结构必须保存在该区域，而不能放置在高端内存域；普通内存用尽就紧急；<br>最后是DMA内存域，它用于外设和系统的数据传输；<br>没有再考虑其他内存结点 ；备选结点也有一个等级次序；<br><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">在初始化后，物理内存大致是这样分布的：</span><br><span class="line">&#123;% asset_img memlayout.png memlayout %&#125;</span><br><span class="line">我们也可以在procfs中查看：</span><br><span class="line">```cpp</span><br><span class="line">sudo cat /<span class="keyword">proc</span>/iomem</span><br><span class="line">00000000-00000fff :<span class="title"> reserved</span></span><br><span class="line"><span class="title">00001000-0009fbff</span> :<span class="title"> System</span> RAM</span><br><span class="line">0009fc00-0009ffff :<span class="title"> reserved</span></span><br><span class="line"><span class="title">000a0000-000bffff</span> :<span class="title"> PCI</span> Bus 0000:00</span><br><span class="line">000c0000-000c7fff :<span class="title"> Video</span> ROM</span><br><span class="line">000e2000-000ef3ff :<span class="title"> Adapter</span> ROM</span><br><span class="line">000f0000-000fffff :<span class="title"> reserved</span></span><br><span class="line"><span class="title"></span>  000f0000-000fffff :<span class="title"> System</span> ROM</span><br><span class="line">00100000-dffeffff :<span class="title"> System</span> RAM</span><br><span class="line">  01000000-0182e000 :<span class="title"> Kernel</span> code</span><br><span class="line">  0182e001-01f4dfff :<span class="title"> Kernel</span> data</span><br><span class="line">  020cd000-02207fff :<span class="title"> Kernel</span> bss</span><br><span class="line">dfff0000-dfffffff :<span class="title"> ACPI</span> Tables</span><br><span class="line">e0000000-fdffffff :<span class="title"> PCI</span> Bus 0000:00</span><br><span class="line"><span class="title">  e0000000-e0ffffff</span> : 0000:00:02.0</span><br><span class="line"><span class="title">    e0000000-e0ffffff</span> :<span class="title"> vmwgfx</span> probe</span><br><span class="line"><span class="title">  f0000000-f01fffff</span> : 0000:00:02.0</span><br><span class="line"><span class="title">    f0000000-f01fffff</span> :<span class="title"> vmwgfx</span> probe</span><br><span class="line"><span class="title">  f0200000-f021ffff</span> : 0000:00:03.0</span><br><span class="line"><span class="title">    f0200000-f021ffff</span> :<span class="title"> e1000</span></span><br><span class="line"><span class="title"></span> <span class="title"> f0400000-f07fffff</span> : 0000:00:04.0</span><br><span class="line"><span class="title">    f0400000-f07fffff</span> :<span class="title"> vboxguest</span></span><br><span class="line"><span class="title"></span> <span class="title"> f0800000-f0803fff</span> : 0000:00:04.0</span><br><span class="line"><span class="title">  f0804000-f0804fff</span> : 0000:00:06.0</span><br><span class="line"><span class="title">    f0804000-f0804fff</span> :<span class="title"> ohci_hcd</span></span><br><span class="line"><span class="title"></span> <span class="title"> f0806000-f0807fff</span> : 0000:00:0d.0</span><br><span class="line"><span class="title">    f0806000-f0807fff</span> :<span class="title"> ahci</span></span><br><span class="line"><span class="title">fec00000-fec00fff</span> :<span class="title"> reserved</span></span><br><span class="line"><span class="title"></span> <span class="title"> fec00000-fec003ff</span> :<span class="title"> IOAPIC</span> 0</span><br><span class="line">fee00000-fee00fff :<span class="title"> Local</span> APIC</span><br><span class="line"><span class="title">  fee00000-fee00fff</span> :<span class="title"> reserved</span></span><br><span class="line"><span class="title">fffc0000-ffffffff</span> :<span class="title"> reserved</span></span><br><span class="line"><span class="title">100000000-11fffffff</span> :<span class="title"> System</span> RAM</span><br><span class="line"></span><br><span class="line">如果想看BIOS等占用的物理内存情况，也可以</span><br><span class="line"><span class="title"> dmesg|</span> grep<span class="title"> BIOS</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> e820:</span> BIOS-provided<span class="title"> physical</span> RAM<span class="title"> map:</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x0000000000000000-0x000000000009fbff]<span class="title"> usable</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x000000000009fc00-0x000000000009ffff]<span class="title"> reserved</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000000f0000-0x00000000000fffff]<span class="title"> reserved</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x0000000000100000-0x00000000dffeffff]<span class="title"> usable</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000dfff0000-0x00000000dfffffff]<span class="title"> ACPI</span> data</span><br><span class="line">[    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000fec00000-0x00000000fec00fff]<span class="title"> reserved</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000fee00000-0x00000000fee00fff]<span class="title"> reserved</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000fffc0000-0x00000000ffffffff]<span class="title"> reserved</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x0000000100000000-0x000000011fffffff]<span class="title"> usable</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> SMBIOS</span> 2.5<span class="title"> present.</span></span><br><span class="line"><span class="title">[</span>    0.000000]<span class="title"> DMI:</span> innotek<span class="title"> GmbH</span> VirtualBox/VirtualBox,<span class="title"> BIOS</span> VirtualBox 12/01/2006</span><br><span class="line">[    0.000000]<span class="title"> ACPI:</span> DSDT 0x00000000DFFF0470 002325 (v02<span class="title"> VBOX</span> <span class="title">  VBOXBIOS</span> 00000002<span class="title"> INTL</span> 20100528)</span><br><span class="line">[    0.000000]<span class="title"> Calgary:</span> detecting<span class="title"> Calgary</span> via<span class="title"> BIOS</span> EBDA<span class="title"> area</span></span><br><span class="line"><span class="title">[</span>    5.020947]<span class="title"> BIOS</span> EDD<span class="title"> facility</span> v0.16 2004-Jun-25, 0<span class="title"> devices</span> found</span><br></pre></td></tr></table></figure></p>
<p>更多见源码和其他文章参考：eg: <a href="https://www.kernel.org/doc/gorman/html/understand/understand008.html" target="_blank" rel="noopener">https://www.kernel.org/doc/gorman/html/understand/understand008.html</a></p>
<h3 id="linux内存分配："><a href="#linux内存分配：" class="headerlink" title="linux内存分配："></a>linux内存分配：</h3><h4 id="linux内存分配图谱："><a href="#linux内存分配图谱：" class="headerlink" title="linux内存分配图谱："></a>linux内存分配图谱：</h4><img src="/2021/03/06/memory-overiew/allalloc.png" title="allalloc">
<h4 id="linux内存用户进程分配"><a href="#linux内存用户进程分配" class="headerlink" title="linux内存用户进程分配:"></a>linux内存用户进程分配:</h4><h5 id="用于进程内存相关机制："><a href="#用于进程内存相关机制：" class="headerlink" title="用于进程内存相关机制："></a>用于进程内存相关机制：</h5><p> A:简介：</p>
<ul>
<li>进程的虚拟地址空间技术使得不同进程可以同时运行，而不会干扰到其他进程的内存；而所有进程的关联，在于物理内存中的页帧和所有进程虚拟地址空间中的页之间的关联：逆向映射，从虚拟内存页追踪物理页，缺页处理：从块设备读取数据填充虚拟地址空间；</li>
<li>在巨大的线性地址空间中有很少的段可以用于各个用户空间进程，这些段需要被内核管理</li>
<li>内核信任自身，不信任用户进程，所以用户进程在操作地址时需要接受权限等的检查</li>
<li>fork-exec模型：写时复制 </li>
</ul>
<p>B:进程虚拟地址空间</p>
<ul>
<li>用户进程：0–TASK_SIZE-1 ,其上是内核地址 (虚拟地址：内核1G,进程3G：32位）<br>进程地址空间布局：text段，动态库代码,全局变量和动态产生数据的堆，局部变量和实现函数的栈，环境变量和命令行参数的段，将文件内容映射到虚拟地址空间中的内存映射；（mm_type.h: 见mm_struct的定义)</li>
<li>建立内存空间布局：<br>(1) 输入./xxx文件运行时，由exec系统调用执行，并通过load_elf_binary函数装载一个ELF二进制文件，elf装载涉及太复杂流程，只看重要的；<br>(2) randomsize_via_space设置，用于启动地址随机化，可能会拖慢cpu速度<br>(3) 布局工作由arch_pick_mmap_layout完成，和体系结构相关；用户通过/proc/sys/kernel/legacy_va_layout输出得到指示，是执行新布局还是旧布局，无非是栈的上界确定和mmap的上下界确定等，最后确定栈的开始位置，mmap开始位置和堆的开始位置等等，这样便完成了布局<br>到这个时候，就会建立在task结构中的mm结构中，初始化各个段的位置，比如text段，堆栈段开始结束等；也会建立起vm_area_struct;<br>这里可能会有个疑问，就是vm_area_struct和进程中的数据段，代码段和堆栈段的关系：可能会认为一个vm_area_struct就是一个段，可能是代码段和数据段，但是实际实践发现不是；<br>vm_area_struct是进程中的内存区域，或者说是内存单元：其本身结构中的字段决定了它的大小，通常是页的整数倍，而数据段代码段等，mm_struct中已经有字段来表明边界；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/pid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">sysctl_example_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">tpid</span> = <span class="title">find_get_pid</span>(12473);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> = <span class="title">pid_task</span>(<span class="title">tpid</span>,<span class="title">PIDTYPE_PID</span>);</span></span><br><span class="line">    printk(<span class="string">"the state of the task is:%d\n"</span>,task-&gt;state);     <span class="comment">// 显示任务当前所处的状态</span></span><br><span class="line">    printk(<span class="string">"the pid of the task is:%d\n"</span>,task-&gt;pid);         <span class="comment">// 显示任务的进程号</span></span><br><span class="line">    printk(<span class="string">"the pid of current thread is:%d\n"</span>,current-&gt;pid);<span class="comment">// 显示当前进程的进程号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">mm_task</span>=<span class="title">get_task_mm</span>(<span class="title">task</span>);</span>             <span class="comment">// 获取任务的内存描述符   </span></span><br><span class="line">     printk(<span class="string">"the mm_users of the mm_struct is:%d\n"</span>,mm_task-&gt;mm_users);</span><br><span class="line">    printk(<span class="string">"the mm_count of the mm_struct is:%d\n total vm :%ld exec_vm:%ld"</span>,mm_task-&gt;mm_count,mm_task-&gt;total_vm,mm_task-&gt;exec_vm); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm</span>= <span class="title">mm_task</span>-&gt;<span class="title">mmap</span>;</span></span><br><span class="line">    printk(<span class="string">"mmap base:%016x ,task_size:%016x,start_code:%016x,end_code:%016x,start_data:%016x, end_data:%016x,start_brk:%016x,endbrk:%016x, start_stack:%016x\n"</span>,mm_task-&gt;mmap_base,mm_task-&gt;task_size,mm_task-&gt;start_code,mm_task-&gt;end_code,mm_task-&gt;start_data,mm_task-&gt;end_data,mm_task-&gt;start_brk,mm_task-&gt;brk,mm_task-&gt;start_stack);</span><br><span class="line">    printk(<span class="string">"the first vmarea:start:%016x ,end:%016x\n"</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    printk(<span class="string">"the  vmarea:start:%016x ,end:%016x\n"</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    printk(<span class="string">"the first vmarea:start:%016x ,end:%016x\n"</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    printk(<span class="string">"the first vmarea:start:%016x ,end:%016x\n"</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    printk(<span class="string">"the first vmarea:start:%016x ,end:%016x\n"</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    printk(<span class="string">"the first vmarea:start:%016x ,end:%016x\n"</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">sysctl_example_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"sysctl unregister success.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(sysctl_example_init);</span><br><span class="line">module_exit(sysctl_example_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">结果举例：dmesg</span><br><span class="line">[<span class="number">41928.340021</span>] the state of the task is:<span class="number">0</span></span><br><span class="line">[<span class="number">41928.340023</span>] the pid of the task is:<span class="number">12473</span></span><br><span class="line">[<span class="number">41928.340024</span>] the pid of current thread is:<span class="number">14907</span></span><br><span class="line">[<span class="number">41928.340025</span>] the mm_users of the mm_struct is:<span class="number">6</span></span><br><span class="line">[<span class="number">41928.340026</span>] the mm_count of the mm_struct is:<span class="number">1</span></span><br><span class="line">[<span class="number">41928.340026</span>]  total vm :<span class="number">1083</span> exec_vm:<span class="number">478</span>mmap base:<span class="number">00000000007</span>de000 ,task_size:<span class="number">00000000f</span>ffff000,start_code:<span class="number">0000000000400000</span>,end_code:<span class="number">0000000000400</span>af4,start_data:<span class="number">0000000000600e10</span>, end_data:<span class="number">0000000000601054</span>,start_brk:<span class="number">00000000014b</span>2000,endbrk:<span class="number">00000000014</span>d3000, start_stack:<span class="number">000000005</span>a04e590</span><br><span class="line">[<span class="number">41928.340029</span>] the first vmarea:start:<span class="number">0000000000400000</span> ,end:<span class="number">0000000000401000</span></span><br><span class="line">[<span class="number">41928.340030</span>] the  vmarea:start:<span class="number">00000000005b</span>2000 ,end:<span class="number">00000000005b</span>4000</span><br><span class="line">[<span class="number">41928.340031</span>] the first vmarea:start:<span class="number">0000000000600000</span> ,end:<span class="number">0000000000601000</span></span><br><span class="line">[<span class="number">41928.340033</span>] the first vmarea:start:<span class="number">00000000005b</span>4000 ,end:<span class="number">00000000005b</span>9000</span><br><span class="line">[<span class="number">41928.340034</span>] the first vmarea:start:<span class="number">000000005</span>a061000 ,end:<span class="number">000000005</span>a063000</span><br><span class="line">[<span class="number">41928.340035</span>] the first vmarea:start:<span class="number">00000000007</span>db000 ,end:<span class="number">00000000007</span>dc000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>C:内存映射原理：</p>
<ul>
<li>前言：实际上进程此时用的还是虚拟内存，那么怎么和物理页关联？实际上物理页有限，虚拟空间大，所以，只有最常用的部分才和物理页关联；大多程序也只占一小部分内存；</li>
<li>进程经常要从文件中读取数据，文件存放于磁盘上，于是，将磁盘上的文件映射到内存则很关键，涉及文件读写和磁盘文件的更新；而实际的映射过程，只是用了几页来存储文件结尾的数据，而文件开始处，则内核只需在地址空间保存相关信息如：数据位置，数据如何读取即可(PS:这些不是保存在进程中的结构吗？ ),text段也类似，只有在需要时才加载；</li>
<li>用户进程访问一个内存地址的过程：<br>虚拟地址–&gt;页表–&gt;确定物理页(有则读取)–&gt;无，出发缺页异常发送到内核-&gt;内核检查进程并找到适当的后备存储器(和文件系统相关),分配物理页并填充来自后备存储器的数据–&gt;借助页表将物理页并入用户进程地址空间，进程恢复执行；<br>– &gt;     malloc-&gt;do_brk–&gt;写时复制，缺页异常—&gt;到vm_area_struct找，vma_fault–&gt;page—&gt;没有做alloc_page ，这样的流程；</li>
</ul>
<p>D:详细阐述：数据结构mm_struct：vmarea_struct mmap虚拟内存区域列表 ; rb_root mm_rb;  vm_area_struct *mmap_cache上一个find_vma结果(上次处理的区域）<br>树和链表：每个区域都通过一个vmarea_struct实例描述，进程的各区域(如text段等)按两种方式排序：在一个单链表上(开始于mm_struct-&gt;mmap)/在一个红黑树中，根位于mm_rb; (task_struct-&gt;mm)即一个进程只有一个mm;<br><img src="/2021/03/06/memory-overiew/vmareatree.png" title="vmareatree"><br>而其实多个mm会连接起来形成全局链表：<br><img src="/2021/03/06/memory-overiew/moremm.png" title="moremm"></p>
<p>虚拟内存区域 vmarea_struct详解：<br>优先查找树结构：一个文件往往关联了多个进程：为了建立一个文件中的一个区域与该区域映射到的所有虚拟地址空间的关联，使用了优先查找树；<br>1) struct file: 每个打开的文件(和每个块设备，因为也可以和内存映射)都会表示为struct file的一个实例，该结构包含了一个指向地址空间对象struct address_space的指针(和后备存储器相关),关联是优先查找树的基础；其文件区间与其映射到的地址空间之间的关联即通过优先树建立；stuct file 和struct address_space见源码<br>2) 另外，每个文件和块设备都表示为struct inode的一个实例，struct file是通过open调用时打开的文件抽象，而inode 则是文件系统自身中的对象；<br>struct inode: address_space *i_mapping; 注意每个file是特定于给定进程的，也就是每个进程都有其file成员；<br><img src="/2021/03/06/memory-overiew/mm_file.png" title="moremm"><br>E 对区域的操作：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">将虚拟地址关联到区域:通过虚拟地址，借助find_vma函数可以查找用户地址空间中结束地址在给定地址后的第一个区域；</span><br><span class="line"><span class="function">struct vm_area_struct * <span class="title">find_vma</span><span class="params">(struct mm_struct * mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mm) &#123;</span><br><span class="line">		<span class="comment">/* Check the cache first. */</span> <span class="comment">//先检查缓存，也就是上次使用的内存；</span></span><br><span class="line">		<span class="comment">/* (Cache hit rate is typically around 35%.) */</span></span><br><span class="line">		vma = mm-&gt;mmap_cache;</span><br><span class="line">		<span class="keyword">if</span> (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123;<span class="comment">//不行再查找区域红黑树；</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> * <span class="title">rb_node</span>;</span></span><br><span class="line"></span><br><span class="line">			rb_node = mm-&gt;mm_rb.rb_node;</span><br><span class="line">			vma = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (rb_node) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vma_tmp</span>;</span></span><br><span class="line"></span><br><span class="line">				vma_tmp = rb_entry(rb_node,</span><br><span class="line">						struct vm_area_struct, vm_rb);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;</span><br><span class="line">					vma = vma_tmp;</span><br><span class="line">					<span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					rb_node = rb_node-&gt;rb_left;</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					rb_node = rb_node-&gt;rb_right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (vma)</span><br><span class="line">				mm-&gt;mmap_cache = vma;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>区域合并：当新区域被加到进程的地址空间时，内核会检查它是否可以与一个或多个现存区域合并：无非检查地址是否相邻等等<br>插入区域： insert_vm_struct函数，实际工作：将区域插入红黑树；<br>创建区域：需要检查虚拟地址空间中是否还有足够的空闲空间来插入新区域；get_unmapped_area  </p>
<p>F:地址空间：文件和进程的内存映射：可以看是文件系统对于的地址空间和用户进程虚拟地址空间的关联映射；<br>vm_operations_struct结构：用于建立两个地址空间的关联和通信；</p>
<h5 id="用户进程内存分配的流程："><a href="#用户进程内存分配的流程：" class="headerlink" title="用户进程内存分配的流程："></a>用户进程内存分配的流程：</h5><p>malloc–&gt; chunks<br>  <strong>brk:/</strong>map–&gt;<br>    sys_brk/sys_mmap_pgoff: 找vm_area_struct<br>       无：缺页异常 ，操作vm_area_struct:-&gt;ops-&gt;vm_fault-&gt;page<br>         –伙伴系统 alloc_page</p>
<img src="/2021/03/06/memory-overiew/malloc.png" title="malloc">
<h4 id="linux内存内核分配："><a href="#linux内存内核分配：" class="headerlink" title="linux内存内核分配："></a>linux内存内核分配：</h4><p>总的来说，有如下几种分配：</p>
<ul>
<li>kmalloc/kzmalloc: 小内存的分配</li>
<li>kmem_cache_alloc: 特定内存大小的内存分配</li>
<li>vmalloc:不连续的大内存分配，多个页</li>
<li>alloc_page:底层分配，分配多个页；<h5 id="slab机制"><a href="#slab机制" class="headerlink" title="slab机制"></a>slab机制</h5></li>
</ul>
<p>针对页内碎片的slab分配技术：将页拆分，分配小单元内存<br>slab分配器：分配比4K更小的内存；提供要经常分配的缓存结构如struct fs_struct;slab着色；slab分配器命名由来<br>PS：slab分配器负责完成与伙伴系统的交互，来分配所需的页</p>
<p>备选分配器：slob分配器；slub分配器</p>
<p>slab分配的原理：<br>下图：缓存即高速缓存kmem_cache 结构，也叫slab缓存由两部分组成：保存管理性数据的缓存对象(kmem_cache)和保存被管理对象的各个slab<br>(1)每个缓存只负责一种对象类型(如struct unix_sock实例，通过/proc/slabinfo可看到),或提供一般性缓冲区(kmalloc分配时用);各个缓存中slab数目各有不同<br>(2)各个缓存都保持在一个双向链表中cache_chain,内核有机会遍历他们<br><img src="/2021/03/06/memory-overiew/slab.png" title="slab"></p>
<ul>
<li>详细缓存结构(kmem_cache)<br>下图：重要成员1：<pre><code> array_cache :保存了各个cpu最后释放的对象：在分配和释放这些对象时，采用后进先出原理，内核假定刚释放的对象仍然处于CPU高速缓存中，会尽快再次分配它
                    仅当per-CPU缓存为空时，才会用slab中的空闲对象重新填充它们
 由此形成三级的分配体系：按照分配成本和操作对CPU高速缓存和TLB的负面影响逐级升高：
 (1) 仍然处于CPU高速缓存中的per-CPU对象
 (2) 现存于slab中的未使用对象
 (3)刚使用伙伴系统分配的新slab中未使用的对象
重要成员2：kmem_list3:每个内存结点都对应3个表头，用于组织slab链表；完全用尽的slab,部分空闲的slab和空闲的slab
</code></pre><img src="/2021/03/06/memory-overiew/slaball.png" title="slaball"></li>
<li><p>slab结构解释：<br>(1)对象在slab中非连续排列，用于每个对象的长度非确切大小，舍入和对齐了；<br>(2)slab创建时有两种方案对齐：1可使用标志SLAB_HWCACHE_ALIGN，slab用户可以按照要求按硬件缓存行对齐，cache_line_size返回值进行；2 不按照硬件对齐<br>(3)填充字节情况；链接了第一个对象，所以slab首部可以不用和slab对象在一起<br>(4)另外 page结构包含了一个链表元素，用于管理各种链表中的页，但是slab缓存不用，用于：<br>page-&gt;lru.next指向页驻留的缓存的管理结构  kmem_cache<br>page-&gt;lru.prev指向保存该页的slab的管理结构 slab<br>设置或读取slab信息分别由set_page_slab和get_page_slab函数完成，带有__cache后缀的函数则处理缓存信息的设置和读取：<br>mm/slab.c:2.6版本：<br>page_set_cache<br><em>page_get_cache<br>page_set_slab
</em>page_get_slab<br>此外，内核还对分配给slab分配器的各个物理页都设置标志PG_SLAB</p>
<img src="/2021/03/06/memory-overiew/slablist.png" title="slablist">
</li>
<li><p>kmem_cache_系列实现：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)数据结构详情：主要是对slab中涉及的kmem_cache,slab,kmem_list3等中的成员做详细的介绍；略</span><br><span class="line">(<span class="number">2</span>)初始化slab系统：</span><br><span class="line">    一个问题：为初始化slab数据结构，内核需要若干远小于一页的内存块（slab中的<span class="keyword">object</span>要分配内存，不然为空指针), 这些由kmalloc分配，但是kmaloc需要在slab启动后才能用；</span><br><span class="line">   解决：涉及kmalloc中的per-CPU缓存的初始化：需要一些技巧：</span><br><span class="line">       A: kmem_cache_init初始化slab分配器：在伙伴系统启动后调用：</span><br><span class="line">           创建系统中第一个slab缓存，以便为kmem_cache的实例提供内存，内核此时使用的主要是在编译时创建的静态数据，一个静态数据结构(initarray_cache)用作per-CPU数组，缓存名为cache_cache;</span><br><span class="line">           接着，初始化一般性缓存，用于kmalloc内存来源：调用kmem_cache_create，存在cache_cache需要借助kmalloc，但是kmalloc又需要借助它的问题：</span><br><span class="line">                     内核使用g_cpucache_up变量解决，类似状态机；在合适的时候才用更大的缓存</span><br><span class="line">           最后，将kmalloc动态分配的版本替换为slab对象的数据结构</span><br><span class="line">(<span class="number">3</span>)创建缓存：创建新的slab缓存必须调用kmem_cache_create；调用后可读的<span class="keyword">name</span>会出现在/proc/slabinfo中；</span><br><span class="line">(<span class="number">4</span>)分配对象：kmem_cache_alloc:用于从特定的高速缓存kmem_cache获取对象，类似于所有的malloc函数；</span><br><span class="line">(<span class="number">5</span>)释放对象：kmem_cache_free</span><br><span class="line">(<span class="number">6</span>)销毁缓存：kmem_cache_destroy</span><br></pre></td></tr></table></figure>
</li>
<li><p>通用缓存:kamlloc:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">通用缓存：若不涉及特殊对象如<span class="class"><span class="keyword">struct</span> <span class="title">unix_sock</span>,而是传统的分配/释放内存，则必须调用<span class="title">kmalloc</span>和<span class="title">kfree</span>函数，这两个函数相当于<span class="title">c</span>的<span class="title">malloc</span>和<span class="title">free</span></span></span><br><span class="line"><span class="class">          需要注意的是：这里的内存分配采用的所有可用的长度：2的幂次：</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">cache_sizes</span> <span class="title">malloc_sizes</span>[] = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHE(x) &#123;.cs_size = (x) &#125;,</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#if (PAGE_SIZE == 4096)</span></span><br><span class="line"><span class="comment">	CACHE(32)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">	CACHE(64)</span></span><br><span class="line"><span class="comment">#if L1_CACHE_BYTES &lt; 64	// L1_CACHE_BYTES = 128</span></span><br><span class="line"><span class="comment">	CACHE(96)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">	CACHE(128)</span></span><br><span class="line"><span class="comment">#if L1_CACHE_BYTES &lt; 128</span></span><br><span class="line"><span class="comment">	CACHE(192)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">	CACHE(256)</span></span><br><span class="line"><span class="comment">	CACHE(512)</span></span><br><span class="line"><span class="comment">	CACHE(1024)</span></span><br><span class="line"><span class="comment">	CACHE(2048)</span></span><br><span class="line"><span class="comment">	CACHE(4096)</span></span><br><span class="line"><span class="comment">	CACHE(8192)</span></span><br><span class="line"><span class="comment">	CACHE(16384)</span></span><br><span class="line"><span class="comment">	CACHE(32768)</span></span><br><span class="line"><span class="comment">	CACHE(65536)</span></span><br><span class="line"><span class="comment">	CACHE(131072)</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 262144</span></span><br><span class="line"><span class="comment">	CACHE(262144)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 524288</span></span><br><span class="line"><span class="comment">	CACHE(524288)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 1048576</span></span><br><span class="line"><span class="comment">	CACHE(1048576)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 2097152</span></span><br><span class="line"><span class="comment">	CACHE(2097152)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 4194304</span></span><br><span class="line"><span class="comment">	CACHE(4194304)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 8388608</span></span><br><span class="line"><span class="comment">	CACHE(8388608)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 16777216</span></span><br><span class="line"><span class="comment">	CACHE(16777216)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 33554432</span></span><br><span class="line"><span class="comment">	CACHE(33554432)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	CACHE(ULONG_MAX);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CACHE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="linux内存内核分配的选择："><a href="#linux内存内核分配的选择：" class="headerlink" title="linux内存内核分配的选择："></a>linux内存内核分配的选择：</h5><ul>
<li>概述：<br>分配小的chunks 使用 kmalloc或kmem_cache_alloc 家族函数<br>分配大的虚拟的连续区域，使用vmalloc和它的变种函数，或者你可以直接请求页，从页的分配器 with alloc_pages;分配器也可能使用的是更专业的比如 cma_alloc或 zs_malloc</li>
</ul>
<p>许多内存分配器都使用GFP flags来表达内存应该怎么被分配。 这个GFP标志是给到get free pages的，是底层的分配函数<br>分配api的多样性和众多的GFP标志使得“我应该如何分配内存?”这并不容易回答，尽管你很可能会用<br>kzalloc(<size>, GFP_KERNEL);</size></p>
<ul>
<li>关于Get Free Page FLags:<br>GFP(get free page)标志，控制分配器的行为，他们告知什么内存zones被使用，分配器应该如何努力寻找空闲内存，内存是否可以被用户空间访问等<br>内存管理api提供了GFP标志及其组合的参考文档，这里我们简要概述了它们的推荐用法:<br>1) 大多数情况下，GFP_KERNEL正是您所需要的。用于内核数据结构的内存、DMAable内存、索引节点缓存，所有这些以及许多其他分配类型都可以使用GFP_KERNEL。注意，使用GFP_KERNEL意味着GFP_RECLAIM，这意味着直接回收可能会在内存压力下触发;必须允许调用上下文休眠。</li>
</ul>
<p>2)如果分配从一个原子上下文执行，例如中断处理程序，使用GFP_NOWAIT。这个标志防止直接回收IO或文件系统操作。因此，在内存压力下，GFP_NOWAIT分配很可能失败。有合理回退的分配应该使用GFP_NOWARN。</p>
<p>3)如果你认为你访问的内存储备是合理的，且除非内核分配成功，否则会给内核带来压力的话，可以用GFP_ATOMIC;</p>
<p>4)从用户空间触发的不受信任的分配，应该被当成一个分配统计对象，并且有__GFP_ACCOUNT这个标志被设置；即GFP_KERNEL_ACCOUNT;</p>
<p>5)用户空间分配应该使用GFP_USER、GFP_HIGHUSER或 GFP_HIGHUSER_MOVABLE  ;标志名越长，限制越小；<br>GFP_HIGHUSER_MOVABLE不要求内核可以直接访问已分配的内存，这意味着数据是可移动的。<br>GFP_HIGHUSER表示所分配的内存是不可移动的，但是内核不需要直接访问它。一个例子可能是硬件分配，它将数据直接映射到用户空间，但没有寻址限制。<br>GFP_USER表示所分配的内存是不可移动的，必须由内核直接访问。</p>
<p>6)您可能注意到，现有代码中有相当多的分配指定了GFP_NOIO或GFP_NOFS。历史上，它们被用来防止由于直接内存回收调用FS或IO路径和阻塞已经占用的资源而引起的递归死锁。从4.12开始，解决这个问题的首选方法是使用FS/IO上下文中使用的GFP掩码中描述的新的作用域api。<br>7)其他遗留的GFP标志是GFP_DMA和GFP_DMA32。它们用于确保具有有限寻址能力的硬件可以访问所分配的内存。所以，除非你正在为一个有这样限制的设备编写驱动程序，否则不要使用这些标志。即使是有限制的硬件，使用dma_alloc* api也是可取的。</p>
<ul>
<li>GFP flags和它的回收内存行为，即多个和一起：<br>1)GFP_KERNEL &amp; ~<strong>GFP_RECLAIM -乐观分配，根本没有尝试释放内存。最轻的重量模式，甚至不触发后台回收。应该谨慎使用，因为它可能会耗尽内存，下一个用户可能会更主动地回收内存。<br>2)GFP_KERNEL &amp; ~</strong>GFP_DIRECT_RECLAIM(或GFP_NOWAIT)-乐观分配，不尝试从当前上下文释放内存，但可以唤醒kswapd回收内存，如果该区域低于低水位。可以在原子上下文中使用，也可以在请求进行性能优化时使用，对于慢路径有另一种退路。<br>3)(GFP_KERNEL|<strong>GFP_HIGH) &amp; ~</strong>GFP_DIRECT_RECLAIM(又名GFP_ATOMIC) -非睡眠分配，具有昂贵的回退，因此它可以访问部分内存储备。通常从中断/下半部分上下文使用一个昂贵的慢路径回退。</li>
</ul>
<p>4)GFP_KERNEL -允许后台和直接回收，并使用默认的页面分配器行为。这意味着不昂贵的分配请求基本上是不会失败的，但没有这种行为的保证，所以失败必须由调用者正确地检查(例如，OOM killer 异常是<br>允许失败的）<br>5)GFP_KERNEL | <strong>GFP_NORETRY -覆盖默认的分配器行为，所有的分配请求在早期失败，而不是导致中断回收(在这个实现中是一轮回收)。OOM杀手没有被调用。<br>6)GFP_KERNEL | </strong>GFP_RETRY_MAYFAIL -覆盖默认的分配器行为和所有的分配请求尝试真正努力。如果回收不能取得任何进展，请求将失败。OOM杀手不会被触发。</p>
<p>7)GFP_KERNEL | __GFP_NOFAIL -覆盖默认的分配器行为，所有的分配请求将不断循环，直到它们成功。这可能真的很危险，特别是对大订单来说。</p>
<ul>
<li>如何选择正确的内存分配器：<br>1 最直接的方式就是用 kmalloc，当然，安全的是初始化内存为0，如kzalloc(),若想分配给一个数组，则有kmalloc_array(),和kcalloc() ;辅助函数：struct_size(),array_size(),array3_size();用来防止溢出；<br>不过，用kmalloc分配的chunk的最大长度是被限制的，实际限制依赖于硬件和内核配置，但是好的实践是，分配的对象比页的大小小；用kmalloc分配的块的地址至少对齐到ARCH_KMALLOC_MINALIGN字节<br>对于2的幂次大小，对齐也保证至少是各自的大小。用kmalloc()分配的块可以用krealloc()调整大小。与kmalloc_array()类似:以krealloc_array()的形式提供了调整数组大小的帮助器。</li>
</ul>
<p>2 对于大的分配来说，可以用vmalloc和vzalloc，或直接用页分配器；用vmalloc和相关联的函数分配可能不是物理上连续的内存；<br>如果您不确定分配大小对于kmalloc来说是否太大，则可以使用kvmalloc()及其衍生物。它将尝试使用kmalloc分配内存，如果分配失败，它将使用vmalloc重试。对于哪些GFP标志可以用于kvmalloc有一些限制;请参阅kvmalloc_node()参考文档。注意，kvmalloc可能返回的内存不是物理上连续的。</p>
<p>3 如果你需要分配许多相同的对象，你可以使用slab缓存分配器。在使用缓存之前，应该使用kmem_cache_create()或kmem_cache_create_usercopy()来设置缓存。如果缓存的一部分可能被复制到用户空间，则应该使用第二个函数。创建缓存之后，kmem_cache_alloc()及其方便的包装器可以从缓存中分配内存。<br>当分配的内存不再需要时，必须释放它。可以对kmalloc、vmalloc和kvmalloc分配的内存使用kvfree()。slab缓存应该使用kmem_cache_free()来释放。不要忘记使用kmem_cache_destroy()来销毁缓存。</p>
<h5 id="kmalloc和kmem-cache-系列的区别："><a href="#kmalloc和kmem-cache-系列的区别：" class="headerlink" title="kmalloc和kmem_cache_系列的区别："></a>kmalloc和kmem_cache_系列的区别：</h5><p>来源于网上比较好的回答：<br>Here is the brief description about how kernel manages memory.<br>In order to manage small sized physical memory allocation, kernel uses slab<br>allocator. Slab allocator maintains two types of caches</p>
<ol>
<li>Generalized Caches of memory pools</li>
<li>Specialized caches of memory pools.</li>
</ol>
<p>Generalized caches contains small memory objects of sizes 8, 16, 32,<br>64,….512, 1024, 2048, 4096, 8192 bytes. These are named as kmalloc’ed<br>caches because kernel allocates memory from these caches when kmalloc is<br>used to to allocate memory.<br>These caches are created at the boot initialization phase. Ref<br>/proc/slabinfo for the list of kmalloc-ed caches.</p>
<p>Not always the user of the kernel will use the objects of the size<br>maintained by the generalized cache. For Eg. In case of Ethernet driver, the<br>driver has to allocate memory for the size 1500 bytes.<br>In this case, if the driver has to allocate memory using kmalloc, it has to<br>allocate a minimum of 2048 bytes per packet, thus wasting almost 550 bytes<br>for every allocation of memory per packet.<br>Hence kernel allows for the driver to create a specialized cache which<br>contains the memory objects of the size specified by user.<br>i.e. In the above example the driver can create his own cache of memory<br>objects of size 1500 bytes by using following KPIs</p>
<ol>
<li>kmem_cache_create - Creates a specialized cache</li>
<li>kmem_cache_alloc - allocates memory from a specialized cache</li>
<li>kmem_cache_free - frees memory to the speicialized cache</li>
<li>kmem_cache_destroy - destroys the specialized cache.</li>
</ol>
<p>Hence kmem_cache_alloc is used when the user of the kernel needs to allocate<br>memory from the specialized cache and kmalloc is used to allocate memory<br>from the generalized caches.</p>
<p>不过看实现，貌似后来的版本，这两个函数都基于slab/slub/slob:具体用哪个分配器，需要根据内核的默认配置； 只是前者kmalloc是可能两个模块共用一个cache，而后者则不是；<br>关于kmalloc和kmem_cache_alloc的区别：<br>kmalloc: It uses the generic slab caches available to any kernel code. so your module will share slab cache with other components in kernel.</p>
<p>kmem_cache_alloc: It will allocate objects from a dedicated slab cache created by kmem_cache_create. If you specifically want a better slab cache management dedicated to your module only, that too for a specific type of objects, use kmem_cache_create followed by kmem_cache_alloc. USB/SCSI drivers use this. kmem_cache_create takes sizeof your object you want to create slab of, a name which appears in /proc/slabinfo and flags to govern behavior of your slab cache.</p>
<h3 id="linux下内存的查看和几个问题："><a href="#linux下内存的查看和几个问题：" class="headerlink" title="linux下内存的查看和几个问题："></a>linux下内存的查看和几个问题：</h3><h4 id="linux下物理内存统计等"><a href="#linux下物理内存统计等" class="headerlink" title="linux下物理内存统计等"></a>linux下物理内存统计等</h4><p>ref:<a href="http://linuxperf.com/?cat=7" target="_blank" rel="noopener">http://linuxperf.com/?cat=7</a><br>系统当前的内存情况：<br>物理内存总数：和可用的物理内存数：<br> dmesg | grep Memory<br>[    0.000000] Memory: 3857076K/4193848K available (8375K kernel code, 1336K rwdata, 3944K rodata, 1492K init, 1260K bss, 336772K reserved, 0K cma-reserved)<br>4193848K 表示此系统物理内存大小<br>3857076K 表示在初始化时，可供kernel分配的free memory的大小，注意这个值在初始化后，实际可用会变大，因为之后还会释放一些bootmem等用完的内存；<br>后面括号的是内核的代码大小占用等等；<br>所以：一个物理内存划分：BIOS|kernel code|initdata| totalavail<br>系统启动后，totalavail为：注意是物理内存<br>$ free  执行结果的total<br>             total       used       free     shared    buffers     cached<br>Mem:       4046636    2568888    1477748      17884      70888    1764708<br>-/+ buffers/cache:     733292    3313344<br>Swap:      4191228          0    4191228<br>或：下面指令的memtotal<br>$ cat /proc/meminfo<br>MemTotal:        4046636 kB<br>MemFree:         1477676 kB<br>MemAvailable:    3113840 kB<br>Buffers:           70896 kB<br>Cached:          1764708 kB<br>SwapCached:            0 kB<br>Active:           827164 kB<br>Inactive:        1596816 kB<br>Active(anon):     589152 kB<br>Inactive(anon):    17104 kB<br>Active(file):     238012 kB<br>Inactive(file):  1579712 kB<br>Unevictable:          16 kB<br>Mlocked:              16 kB<br>SwapTotal:       4191228 kB<br>SwapFree:        4191228 kB<br>Dirty:                 0 kB<br>Writeback:             0 kB<br>AnonPages:        588396 kB<br>Mapped:           163956 kB<br>Shmem:             17884 kB<br>Slab:              61964 kB<br>SReclaimable:      42112 kB<br>SUnreclaim:        19852 kB<br>KernelStack:        5888 kB<br>PageTables:        24916 kB<br>NFS_Unstable:          0 kB<br>Bounce:                0 kB<br>WritebackTmp:          0 kB<br>CommitLimit:     6214544 kB<br>Committed_AS:    2746044 kB<br>VmallocTotal:   34359738367 kB<br>VmallocUsed:           0 kB<br>VmallocChunk:          0 kB<br>HardwareCorrupted:     0 kB<br>AnonHugePages:    407552 kB<br>CmaTotal:              0 kB<br>CmaFree:               0 kB<br>HugePages_Total:       0<br>HugePages_Free:        0<br>HugePages_Rsvd:        0<br>HugePages_Surp:        0<br>Hugepagesize:       2048 kB<br>DirectMap4k:       96192 kB<br>DirectMap2M:     4098048 kB</p>
<p>更多内核内存的查看，见ref<br>进程的物理内存使用：<br>cat /proc/{pid}/status<br>VmRSS 或 VmHWM<br>这个怎么来的：追了下，它定义在：task_mem in task_mmu.c (fs\proc) :         “VmRSS:\t%8lu kB\n”<br> get_mm_rss(mm);其实就是task_struct-&gt;&amp;mm-&gt;rss_stat.count[member]<br> 看下这个结构的解释：（看了下代码，就是在缺页等实际分配的时候做累加）<br> struct mm_rss_stat rss_stat - A set of statistics contained in struct mm_rss_stat relating to Resident Set Size (RSS), i.e. memory that has been faulted in. The structure is simply an array of atomic_long_t counts for each of: MM_FILEPAGES - number of resident pages mapping files, MM_ANONPAGES - number of resident anonymous pages, MM_SWAPENTS - number of resident swap entries, and MM_SHMEMPAGES - number of resident shared pages. Note that in the usual case where the SPLIT_RSS_COUNTING constant is set, these statistics are only updated every TASK_RSS_EVENTS_THRESH page faults (hardcoded to 64.)</p>
<p>进程的虚拟内存大小：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ sudo cat /proc/<span class="number">12473</span>/status</span><br><span class="line">Name:	task_test2</span><br><span class="line">State:	R (running)</span><br><span class="line">Tgid:	<span class="number">12473</span></span><br><span class="line">Ngid:	<span class="number">0</span></span><br><span class="line">Pid:	<span class="number">12473</span></span><br><span class="line">PPid:	<span class="number">10096</span></span><br><span class="line">TracerPid:	<span class="number">0</span></span><br><span class="line">Uid:	<span class="number">1000</span>	<span class="number">1000</span>	<span class="number">1000</span>	<span class="number">1000</span></span><br><span class="line">Gid:	<span class="number">1000</span>	<span class="number">1000</span>	<span class="number">1000</span>	<span class="number">1000</span></span><br><span class="line">FDSize:	<span class="number">256</span></span><br><span class="line">Groups:	<span class="number">4</span> <span class="number">24</span> <span class="number">27</span> <span class="number">30</span> <span class="number">46</span> <span class="number">108</span> <span class="number">124</span> <span class="number">1000</span> </span><br><span class="line">NStgid:	<span class="number">12473</span></span><br><span class="line">NSpid:	<span class="number">12473</span></span><br><span class="line">NSpgid:	<span class="number">12473</span></span><br><span class="line">NSsid:	<span class="number">10096</span></span><br><span class="line">VmPeak:	    <span class="number">4332</span> kB</span><br><span class="line">VmSize:	    <span class="number">4332</span> kB  是虚拟内存的大小，即task_struct-&gt;mm-&gt;total_vm个页，一个页是<span class="number">4</span>k;</span><br><span class="line">VmLck:	       <span class="number">0</span> kB</span><br><span class="line">VmPin:	       <span class="number">0</span> kB</span><br><span class="line">VmHWM:	     <span class="number">660</span> kB</span><br><span class="line">VmRSS:	     <span class="number">660</span> kB </span><br><span class="line">VmData:	     <span class="number">200</span> kB</span><br><span class="line">VmStk:	     <span class="number">132</span> kB</span><br><span class="line">VmExe:	       <span class="number">4</span> kB</span><br><span class="line">VmLib:	    <span class="number">1908</span> kB</span><br><span class="line">VmPTE:	      <span class="number">32</span> kB</span><br><span class="line">VmPMD:	      <span class="number">12</span> kB</span><br><span class="line">VmSwap:	       <span class="number">0</span> kB</span><br><span class="line">HugetlbPages:	       <span class="number">0</span> kB</span><br><span class="line">Threads:	<span class="number">1</span></span><br><span class="line">SigQ:	<span class="number">0</span>/<span class="number">15066</span></span><br><span class="line">SigPnd:	<span class="number">0000000000000000</span></span><br><span class="line">ShdPnd:	<span class="number">0000000000000000</span></span><br><span class="line">SigBlk:	<span class="number">0000000000000000</span></span><br><span class="line">SigIgn:	<span class="number">0000000000000000</span></span><br><span class="line">SigCgt:	<span class="number">0000000000000000</span></span><br><span class="line">CapInh:	<span class="number">0000000000000000</span></span><br><span class="line">CapPrm:	<span class="number">0000000000000000</span></span><br><span class="line">CapEff:	<span class="number">0000000000000000</span></span><br><span class="line">CapBnd:	<span class="number">0000003f</span>ffffffff</span><br><span class="line">CapAmb:	<span class="number">0000000000000000</span></span><br><span class="line">Seccomp:	<span class="number">0</span></span><br><span class="line">Speculation_Store_Bypass:	vulnerable</span><br><span class="line">Cpus_allowed:	<span class="number">3</span></span><br><span class="line">Cpus_allowed_list:	<span class="number">0</span><span class="number">-1</span></span><br><span class="line">Mems_allowed:	<span class="number">00000000</span>,<span class="number">00000001</span></span><br><span class="line">Mems_allowed_list:	<span class="number">0</span></span><br><span class="line">voluntary_ctxt_switches:	<span class="number">0</span></span><br><span class="line">nonvoluntary_ctxt_switches:	<span class="number">167165</span></span><br></pre></td></tr></table></figure></p>
<h4 id="几个问题："><a href="#几个问题：" class="headerlink" title="几个问题："></a>几个问题：</h4><ul>
<li>通过malloc分配的最小物理内存单位是页吗，就是最小的话，一定会分配一个页，那这个页是不是这个进程独占，还是可以和其他进程共享？</li>
<li>内存映射和普通的内存分配操作有什么区别？</li>
<li>通过alloc_page分配内存页的时候，是不是就是即分配物理页，而不会再通过写入才分配？<br>是，即分配物理页，可以通过模块中alloc_page接口的调用，观察free指令下内存的变化；模块例子可以在本文中搜 alloc_page,在insmod模块后观察free下的值，最好指定分配的页多些，因为free下的空闲内存在一个范围变动；</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p>深入linux内核架构等</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>procsysfs</title>
    <url>/2021/02/26/procsysfs/</url>
    <content><![CDATA[<h3 id="linux-用户空间与内核的接口—内核信息的输出和修改"><a href="#linux-用户空间与内核的接口—内核信息的输出和修改" class="headerlink" title="linux 用户空间与内核的接口—内核信息的输出和修改"></a>linux 用户空间与内核的接口—内核信息的输出和修改</h3><ul>
<li><p>linux用户与内核的接口有多种,配置内核的netlink,ioctl,等特殊系统调用，其他系统调用;用户空间指令:ifconfig,route,<br>iptable等;以及内核输出信息的procfs,sysfs和修改内核参数的sysctl接口;这里介绍最后一种;<a id="more"></a></p>
</li>
<li><p>用户空间程序常常需要知道内核一些当前状态信息，且有时为了系统的稳定性和性能等，需要改变一些内核参数信息；<br>linux提供了这样的机制，用来读取内核输出信息的内存文件系统和修改的系统调用；<br>除了常规的系统调用外，还提供了sysctl系统调用和（/proc(procfs虚拟文件系统), /sys(sysfs虚拟文件系统）</p>
</li>
</ul>
<h3 id="procfs介绍"><a href="#procfs介绍" class="headerlink" title="procfs介绍"></a>procfs介绍</h3><ul>
<li><p>介绍：<br>  procfs:是挂载在/proc的虚拟文件系统，允许内核以文件的形式向用户输出内部信息；这些信息存于内存中，可以通过cat或more及&gt;重定向输出输入<br>  它不能被编译为一个模块，配置菜单中相关内核选项为：“Filesystems-&gt;pseudo filesystems-&gt;/proc file system support”  </p>
<p>  procfs目前分为/proc/sys和/proc/其他的，前者可以通过sysctl系统调用来进行写，从而改变内核的一些参数和配置，后者只读；  </p>
<p>  如果是只读的，且是涉及更为复杂的数据结构而且需要特殊格式等如缓存和统计数据,则考虑用proc/非sys的，否则若只是简单变量，则应该使用/proc/sys  </p>
</li>
<li>实践：<br> 1）用户空间使用： 用户可以通过cat /proc/…   ls /proc等方式来进行读取/procfs的值；对于/proc/sys的，有单独的说明见下；<br> 2)  解释：关于/proc/下的各个文件目录的含义，可以查看man <a href="https://man7.org/linux/man-pages/man5/procfs.5.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man5/procfs.5.html</a>  对网络代码注册的文件，一般位于/proc/net目录下，在该目录下存在不少文件，有一种比较特殊的文件，如tcp,udp有固定的格式，就像数据库的记录一样，称为综合文件(synthetic files).所以说proc文件系统适用于它，提供了对此类文件框架的支持：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cat  /proc/net/udp:</span><br><span class="line">   sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode ref pointer drops             </span><br><span class="line">   <span class="number">6591</span>: <span class="number">00000000</span>:<span class="number">0044</span> <span class="number">00000000</span>:<span class="number">0000</span> <span class="number">07</span> <span class="number">00000000</span>:<span class="number">00000000</span> <span class="number">00</span>:<span class="number">00000000</span> <span class="number">00000000</span>     <span class="number">0</span>        <span class="number">0</span> <span class="number">14983</span> <span class="number">2</span> <span class="number">0000000000000000</span> <span class="number">0</span>         </span><br><span class="line">   <span class="number">6646</span>: <span class="number">26B</span>4450A:<span class="number">007B</span> <span class="number">00000000</span>:<span class="number">0000</span> <span class="number">07</span> <span class="number">00000000</span>:<span class="number">00000000</span> <span class="number">00</span>:<span class="number">00000000</span> <span class="number">00000000</span>     <span class="number">0</span>        <span class="number">0</span> <span class="number">28063</span> <span class="number">2</span> <span class="number">0000000000000000</span> <span class="number">0</span>         </span><br><span class="line">   <span class="number">6646</span>: <span class="number">0100007F</span>:<span class="number">007B</span> <span class="number">00000000</span>:<span class="number">0000</span> <span class="number">07</span> <span class="number">00000000</span>:<span class="number">00000000</span> <span class="number">00</span>:<span class="number">00000000</span> <span class="number">00000000</span>     <span class="number">0</span>        <span class="number">0</span> <span class="number">28061</span> <span class="number">2</span> <span class="number">0000000000000000</span> <span class="number">0</span>         </span><br><span class="line">   <span class="number">6646</span>: <span class="number">00000000</span>:<span class="number">007B</span> <span class="number">00000000</span>:<span class="number">0000</span> <span class="number">07</span> <span class="number">00000000</span>:<span class="number">00000000</span> <span class="number">00</span>:<span class="number">00000000</span> <span class="number">00000000</span>     <span class="number">0</span>        <span class="number">0</span> <span class="number">28057</span> <span class="number">2</span> <span class="number">0000000000000000</span> <span class="number">0</span>         </span><br><span class="line">   <span class="number">6660</span>: FFFF12AC:<span class="number">0089</span> <span class="number">00000000</span>:<span class="number">0000</span> <span class="number">07</span> <span class="number">00000000</span>:<span class="number">00000000</span> <span class="number">00</span>:<span class="number">00000000</span> <span class="number">00000000</span>     <span class="number">0</span>        <span class="number">0</span> <span class="number">72326708</span> <span class="number">2</span> <span class="number">0000000000000000</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>3) 内核中如何添加/proc/目录等信息：<br>eg: 大多数网络功能在初始化时，都会在/proc/net中注册一个或多个文件，无论初始化动作发生在系统启动时还是模块加载时。当用户读取某个文件时，内核会调用一组内核函数来输出相应信息：<br>代码中如何创建：<br>     proc_mkdir:创建/proc中的目录<br>     create_proc_entry/remove_proc_entry:创建和除名文件<br>     可以用包裹函数如：<br>     proc_net_fops_create/proc_net_remove:/proc/net/中文件的注册和除名<br>     现在的版本和之前的版本不同，一些接口比如底层的create_proc_entry已经没有了，所以现在一些书本的例子不能用，需要参考内核代码，等看到时，再总结出例子来更新文章  </p>
<h3 id="sysctl和-proc-sys"><a href="#sysctl和-proc-sys" class="headerlink" title="sysctl和 /proc/sys"></a>sysctl和 /proc/sys</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>sysctl:这个接口允许用户空间读取或修改内核变量的值；不能用此接口对每个内核变量进行操作，内核应明确指出哪些变量从此接口是可见的；<br>从用户空间，你可以用两种方式访问sysctl输出的变量：一种是系统调用sysctl(man sysctl),一种则是依赖procfs(因为内核会在/proc中添加一个特殊目录/proc/sys,为每个sysctl所输出的内核变量引入一个文件</li>
<li>内核配置选项：General setup-&gt;sysctl support</li>
<li>sysctl的信息大多可写，但是只有超级用户可写，一个简单内核变量或数据结构相关的一些文件</li>
</ul>
<h4 id="命令行工具sysctl和运维"><a href="#命令行工具sysctl和运维" class="headerlink" title="命令行工具sysctl和运维"></a>命令行工具sysctl和运维</h4><p>有时候需要查内核相关参数，并做调整来改变内核行为，以支持更多功能或者恢复手段等；这个时候可以使用sysctl指令：  </p>
<ul>
<li><p>展示：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ sysctl -<span class="selector-tag">a</span> 展示所有的sysctl参数</span><br><span class="line">$ sysctl vm<span class="selector-class">.swapiness</span> 展示这个的值，会打印：</span><br><span class="line">vm<span class="selector-class">.swappiness</span> = <span class="number">60</span></span><br><span class="line">sysctl命令实际上就是读取/proc/sys目录下的内容；它是一个虚拟目录，只包含当前内核参数值</span><br><span class="line">sysctl vm<span class="selector-class">.swapiness</span> 和 cat /proc/sys/vm/swapiness 是一样的效果</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ sysctl -w paramter=value  临时改变参数值，重启会恢复默认值</span><br><span class="line">eg： sysctl -w net<span class="selector-class">.ipv4</span><span class="selector-class">.ip_forward</span>=<span class="number">1</span></span><br><span class="line">如果值包括空格或特殊字符，请用双引号括起来；</span><br><span class="line">如果想要重启后也用这个值，可以：</span><br><span class="line"><span class="variable">$sysctl</span> -w net<span class="selector-class">.ipv4</span><span class="selector-class">.ip_forward</span>=<span class="number">1</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">其他临时写的方式：</span><br><span class="line">$ echo <span class="number">1</span> &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载值：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ sysctl -<span class="selector-tag">p</span> /etc/sysctl.d/file_name.conf</span><br><span class="line">当没有指定文件名：使用/etc/sysctl.conf文件；</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="用户程序如何系统调用sysctl"><a href="#用户程序如何系统调用sysctl" class="headerlink" title="用户程序如何系统调用sysctl:"></a>用户程序如何系统调用sysctl:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//man7.org/linux/man-pages/man2/sysctl.2.html</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _sysctl(struct __sysctl_args *args );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OSNAMESZ 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">sysctl_args</span> <span class="title">args</span>;</span></span><br><span class="line">    <span class="keyword">char</span> osname[OSNAMESZ];</span><br><span class="line">    <span class="keyword">size_t</span> osnamelth;</span><br><span class="line">    <span class="keyword">int</span> name[] = &#123; CTL_KERN, KERN_OSTYPE &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __sysctl_args));</span><br><span class="line">    args.name = name;</span><br><span class="line">    args.nlen = <span class="keyword">sizeof</span>(name)/<span class="keyword">sizeof</span>(name[<span class="number">0</span>]);</span><br><span class="line">    args.oldval = osname;</span><br><span class="line">    args.oldlenp = &amp;osnamelth;</span><br><span class="line"></span><br><span class="line">   osnamelth = <span class="keyword">sizeof</span>(osname);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (syscall(SYS__sysctl, &amp;args) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"_sysctl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This machine is running %*s\n"</span>, osnamelth, osname);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内核中如何添加-proc-sys下的目录和文件"><a href="#内核中如何添加-proc-sys下的目录和文件" class="headerlink" title="内核中如何添加/proc/sys下的目录和文件"></a>内核中如何添加/proc/sys下的目录和文件</h4><p>（代码中如何呈现：<br>   用户在/proc/sys下看到的一个文件，实际上是一个内核变量；就每个变量而言，内核可以定义：<br>   A:要将其放在/proc/sys的何处，与相同内核组件或功能相关联的变量，，通常位于一个目录中，如/proc/sys/net/ipv4<br>   B:命名：一般文件名和相关联的变量名相同<br>   C:权限：一般所有可读，超级可写<br>）</p>
<ul>
<li><p>简单例子1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sysctl_hello_data = <span class="number">1024</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_callback</span><span class="params">(struct ctl_table *table, <span class="keyword">int</span> write,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __user *buffer, <span class="keyword">size_t</span> *lenp, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">int</span> *data = table-&gt;data;</span><br><span class="line"> </span><br><span class="line">    printk(KERN_INFO <span class="string">"original value = %d\n"</span>, *data);</span><br><span class="line"> </span><br><span class="line">    rc = proc_dointvec(table, write, buffer, lenp, ppos);</span><br><span class="line">    <span class="keyword">if</span> (write)</span><br><span class="line">        printk(KERN_INFO <span class="string">"this is write operation, current value = %d\n"</span>, *</span><br><span class="line">data);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">hello_ctl_table</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .procname       = <span class="string">"helloctl"</span>,</span><br><span class="line">        .data           = &amp;sysctl_hello_data,</span><br><span class="line">        .maxlen         = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">        .mode           = <span class="number">0644</span>,</span><br><span class="line">        .proc_handler   = hello_callback,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* sentinel */</span> <span class="comment">//哨兵的作用，见数据结构</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table_header</span> *<span class="title">sysctl_header</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">sysctl_example_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sysctl_header = register_sysctl_table(hello_ctl_table);</span><br><span class="line">    <span class="keyword">if</span> (sysctl_header == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">"ERR: register_sysctl_table!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    printk(KERN_INFO <span class="string">"sysctl register success.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">sysctl_example_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unregister_sysctl_table(sysctl_header);</span><br><span class="line">    printk(KERN_INFO <span class="string">"sysctl unregister success.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(sysctl_example_init);</span><br><span class="line">module_exit(sysctl_example_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">  * Author: ksx</span></span><br><span class="line"><span class="comment">  * File name: sysctl_example.c</span></span><br><span class="line"><span class="comment">  * Description: sysctl example</span></span><br><span class="line"><span class="comment">  * Date: 2021-02-26</span></span><br><span class="line"><span class="comment">  *********************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> min_virdev_frags = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> max_virdev_frags = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> virdev_sum1=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> virdev_array[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sysctl_max_virdev_frags=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_default_something</span><span class="params">(struct ctl_table *table, <span class="keyword">int</span> write,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __user *buffer, <span class="keyword">size_t</span> *lenp, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      printk(KERN_INFO <span class="string">"set default something value =\n"</span>);</span><br><span class="line">      <span class="comment">//you can do other ，可以自己实现类似proc_dointvec功能的函数，其实就是赋值；参考sysctl_net_core.c</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">virdev_table1</span>[] = &#123;</span></span><br><span class="line">    &#123; </span><br><span class="line">      .procname     = <span class="string">"virdev_sum1"</span>,</span><br><span class="line">      .data         = &amp;virdev_sum1,</span><br><span class="line">      .maxlen       = <span class="keyword">sizeof</span>(virdev_sum1),</span><br><span class="line">      .mode         = <span class="number">0644</span>,</span><br><span class="line">      .proc_handler = &amp;proc_dointvec </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">		.procname	= <span class="string">"max_virdev_frags"</span>,</span><br><span class="line">		.data		= &amp;sysctl_max_virdev_frags,</span><br><span class="line">		.maxlen		= <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		.proc_handler	= proc_dointvec_minmax, <span class="comment">//若设置的值不在extra1-extra2之间，则设置失败</span></span><br><span class="line">		.extra1		= &amp;min_virdev_frags,</span><br><span class="line">		.extra2		= &amp;max_virdev_frags,</span><br><span class="line">	&#125;,</span><br><span class="line">    <span class="comment">//只是回调来设置到某个值中或者做其他事，不需要data,但回调函数也必须符合格式</span></span><br><span class="line">    &#123;</span><br><span class="line">		.procname	= <span class="string">"default_something"</span>,</span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		.maxlen		= <span class="number">16</span>,</span><br><span class="line">		.proc_handler	= set_default_something</span><br><span class="line">	&#125;,    </span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">virdev_table2</span>[] = &#123;</span></span><br><span class="line">    &#123; </span><br><span class="line">      .procname     = <span class="string">"virdev_array"</span>,</span><br><span class="line">      .data         = &amp;virdev_array,</span><br><span class="line">      .maxlen       = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="comment">//是指data的大小，而data其实是void *,不管怎样其实就是指针大小</span></span><br><span class="line">      .mode         = <span class="number">0644</span>,</span><br><span class="line">      .proc_handler = &amp;proc_dostring   <span class="comment">//会将接收到的用户传入的buff数据，解析并，写到data中，具体见实际例子；</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">virdev_dir_table</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .procname = <span class="string">"virsub1"</span>,</span><br><span class="line">        .mode     = <span class="number">0555</span>,</span><br><span class="line">        .child    = virdev_table1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .procname = <span class="string">"virsub2"</span>,</span><br><span class="line">        .mode     = <span class="number">0555</span>,</span><br><span class="line">        .child    = virdev_table2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">virdev_root_table</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .procname       = <span class="string">"virdev"</span>,</span><br><span class="line">        .mode           = <span class="number">0555</span>,</span><br><span class="line">        .child          = virdev_dir_table</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* sentinel */</span></span><br><span class="line">    &#125;, <span class="comment">//多出的一个应该是哨兵的作用，参考数据结构设计</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table_header</span> *<span class="title">sysctl_header</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">sysctl_example_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sysctl_header = register_sysctl_table(virdev_root_table);</span><br><span class="line">    <span class="keyword">if</span> (sysctl_header == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">"ERR: register_sysctl_table!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    printk(KERN_INFO <span class="string">"sysctl register success.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">sysctl_example_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unregister_sysctl_table(sysctl_header);</span><br><span class="line">    printk(KERN_INFO <span class="string">"sysctl unregister success.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(sysctl_example_init);</span><br><span class="line">module_exit(sysctl_example_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口解释：<br>1) 结构体ctl_table<br>每一个sysctl条目对应一个 struct ctl_table 结构，在该结构体定义在文件/include/linux/sysctl.h中，定义及解释如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *procname; <span class="comment">/* Text ID for /proc/sys, or zero */</span> <span class="comment">/* 表示在proc/sys/下显示的文件名称 */</span></span><br><span class="line">    <span class="keyword">void</span> *data; <span class="comment">/* 表示对应于内核中的变量名称    */</span> <span class="comment">//是一个指针，如上，可以是int,数组等</span></span><br><span class="line">    <span class="keyword">int</span> maxlen;<span class="comment">//  /* 表示条目允许的最大长度         */</span></span><br><span class="line">    <span class="keyword">mode_t</span> mode;<span class="comment">/* 条目在proc文件系统下的访问权限 */</span><span class="comment">//见 stat.h</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> *<span class="title">child</span>;</span> <span class="comment">//子目录的结构，见上面的例子，但内核代码注释不建议这样用，甚至弃用；</span></span><br><span class="line">    proc_handler *proc_handler; <span class="comment">/* Callback for text         formatting */</span><span class="comment">//当sysctl或echo等方式写时，触发这个回调函数将值写到注册的ctl_table中</span></span><br><span class="line">    <span class="keyword">void</span> *extra1;<span class="comment">//proc_dointvec_minmax等有范围的限定用，下限</span></span><br><span class="line">    <span class="keyword">void</span> *extra2;<span class="comment">//上限</span></span><br><span class="line">&#125;</span><br><span class="line">maxlen: 它主要用于字符串内核变量，以便在对该条目设置时，对超过该最大长度的字符串截掉后面超长的部分.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2) 注册和卸载：<br>注册register_sysctl_table<br>注册sysctl条目使用函数register_sysctl_table，函数原型如下：<br>struct ctl_table_header <em>register_sysctl_table(struct ctl_table </em>table)<br>第一个参数为定义的struct ctl_table结构的sysctl条目或条目数组指针；</p>
<p>卸载unregister_sysctl_table<br>当模块卸载时，需要使用函数unregister_sysctl_table，其原型：<br>void unregister_sysctl_table(struct ctl_table_header * header)<br>其中struct ctl_table_header是通过函数register_sysctl_table<br>注册时返回的结构体指针。</p>
<p>3) 关于信息和参考，如linux版本更新后，接口变化：<br>内核源码例子：/proc/sys/net/core的添加<br>socket.c :sock_init<br>net/core/sysctl_net_core.c<br>源码：<br>proc_dointvec_minmax系列函数定义：kernel/sysctl.c sysctl.h<br>也可以参考：其中的说明<br><a href="http://www.embeddedlinux.org.cn/linux_net/0596002556/understandlni-CHP-3-SECT-2.html" target="_blank" rel="noopener">http://www.embeddedlinux.org.cn/linux_net/0596002556/understandlni-CHP-3-SECT-2.html</a></p>
<h3 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h3><p> sysfs:是挂载在/sys下的虚拟文件系统：它不仅可以把设备和驱动程序的信息从内核空间导到用户空间，也可以对设备和驱动进行配置；<br>目的是将一些原本在procfs中的设备独立出来，以设备树的形式呈现给用户；最初，sysfs名driverfs; 而后来对其他子系统也有用所以就更名；<br>sysfs在用户空间使用和procfs类似，对内核中的实现和使用，和设备模型相关，等总结完设备模型后，再总结；</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux_procsysfs</tag>
      </tags>
  </entry>
  <entry>
    <title>sk_buff</title>
    <url>/2021/02/20/sk-buff/</url>
    <content><![CDATA[<h3 id="关于skb"><a href="#关于skb" class="headerlink" title="关于skb"></a>关于skb</h3><p>skb是网络协议栈中对包的底层操作结构，它需要满足以下特性：<br>1) 能方便的处理可变长缓存，因为发送和接收的数据长时不固定的<br>2）能容易实现头尾部增加和移除数据，因为这些缓存区需要在不同网络层次间进行传递<br>3）添加和移除数据能尽量避免数据的复制<a id="more"></a><br>sk_buffer定义：<br>include/linux/skbuff.h<br>net/core/skbuff.c<br>在下载的linux源码中能找到(下来看的或者是ubuntu中下来编译内核的)</p>
<p>ref:&lt;linux内核源码剖析–TCP/IP实现&gt;</p>
<h3 id="sk-buff的结构"><a href="#sk-buff的结构" class="headerlink" title="sk_buff的结构"></a>sk_buff的结构</h3><h4 id="大体结构："><a href="#大体结构：" class="headerlink" title="大体结构："></a>大体结构：</h4><p>分类：<br>1) 与skb组织相关的成员变量<br>2) 通用成员变量<br>3) 标志性变量<br>4) 与特性相关的成员变量<br>   这些与特性相关的成员，往往用#ifdef来限制，若要使用他们，需要系统定义这些宏，而这个需要在编译内核时开启，比如：<br>   编译时选中 Networking-&gt;Networking options-&gt;QoS and/or fair queueing-&gt;action，选中包分类器的功能，对应宏：<br>   CONFIG_NET_CLS_ACT<br>   注意的是：若某个内核模块包含了使用未定义的宏限制的变量，则无法被内核使用；</p>
<p>skb被哪些网络层次处理？<br>二层的mac或者其他链路层协议，三层的ip协议，四层的tcp和udp协议，某些成员会在层次间传递的时候发生改变，如四层向三层传递时会加一个ip头，<br>三层向二层传递时会加一个mac头等，反之则删除，而传递时只增加头部可以提高效率；这个需要复杂的指针操作，内核提供了一个函数： skb_reserve();<br>起到在向下传递skb前，在数据缓存区头部预留空间的作用；</p>
<h4 id="skb相关的两个链表"><a href="#skb相关的两个链表" class="headerlink" title="skb相关的两个链表"></a>skb相关的两个链表</h4><p>在正式看skb的结构之前，先看看组织skb的两个链表，来看skb的全局：<br>在数据被传递进来时，触发中断，中断处理程序会将数据传递进内核，接着一步步拷贝到skb；skb由链表组织：<br>在sk_buff中有两个成员结构：<br>struct sk_buff <em>next;<br>struct sk_buff </em>prev;<br>以此构成skb_buff双向链表；<br>为了能使每个skb都能被整个链表的头部快速找到，在第一个skb结点前加了一个辅助的sk_buff_head结构的头结点，就像链表头一样，作为<br>链表的头结点，可以由此遍历skb链表；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> &#123;</span></span><br><span class="line">	<span class="comment">/* These two members must be first. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	*<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">	__u32		qlen;</span><br><span class="line">	<span class="keyword">spinlock_t</span>	lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构组织：<br><-> sk_buff_head <-> skb1 <-> skb2 …<-> 链接到sk_buff_head形成环形双向链表</-></-></-></-></p>
<h4 id="skb结构："><a href="#skb结构：" class="headerlink" title="skb结构："></a>skb结构：</h4><p>skb结构可以被大致分为 描述符(skb本身) 和数据缓冲区 (head等成员指针指向的数据)<br>以下是内核4.4.0中的include/linux/定义的sk_buff结构：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *	struct sk_buff - socket buffer</span></span><br><span class="line"><span class="comment"> *	@next: Next buffer in list </span></span><br><span class="line"><span class="comment"> *	@prev: Previous buffer in list</span></span><br><span class="line"><span class="comment"> *	@tstamp: Time we arrived/left 接收或发送时间戳，在网络设备收到一个数据包后，由netif_receive_skb()或netif_rx()调用net_timestamp()设置</span></span><br><span class="line"><span class="comment"> *	@rbnode: RB tree node, alternative to next/prev for netem/tcp</span></span><br><span class="line"><span class="comment"> *	@sk: Socket we are owned by //skb的宿主，当源ip和目的ip都不是本机时，为NULL,否则在数据发送接收时通过这个结构传递给到上层和应有程序挂钩；</span></span><br><span class="line"><span class="comment"> *	@dev: Device we arrived on/are leaving by 从网卡接收数据时，需要分配skb接收缓存队列，这个时候分配成功，就会设置这个结构为对应网卡，发送类似，复杂些；</span></span><br><span class="line"><span class="comment"> *	@cb: Control buffer. Free for use by every layer. Put private vars here</span></span><br><span class="line"><span class="comment"> *	@_skb_refdst: destination entry (with norefcount bit) 目的路由缓存；</span></span><br><span class="line"><span class="comment"> *	@sp: the security path, used for xfrm ipsec协议用来跟踪传输信息</span></span><br><span class="line"><span class="comment"> *	@len: Length of actual data  skb实际数据部分长度，包括线性缓存区中数据长度和(data-&gt;)和SG类型的聚合分散io的数据和FRAGLIST类型的聚合分散io数据，以及传递时增加或减去的协议首部；</span></span><br><span class="line"><span class="comment"> *	@data_len: Data length SG类型的聚合分散io的数据和FRAGLIST类型的聚合分散io数据长</span></span><br><span class="line"><span class="comment"> *	@mac_len: Length of link layer header</span></span><br><span class="line"><span class="comment"> *	@hdr_len: writable header length of cloned skb</span></span><br><span class="line"><span class="comment"> *	@csum: Checksum (must include start/offset pair)</span></span><br><span class="line"><span class="comment"> *	@csum_start: Offset from skb-&gt;head where checksumming should start</span></span><br><span class="line"><span class="comment"> *	@csum_offset: Offset from csum_start where checksum should be stored</span></span><br><span class="line"><span class="comment"> *	@priority: Packet queueing priority 发送或转发数据包的Qos类别，若包本地生成，则套接口层会设置该字段；</span></span><br><span class="line"><span class="comment"> *	@ignore_df: allow local fragmentation 允许本地分片</span></span><br><span class="line"><span class="comment"> *	@cloned: Head may be cloned (check refcnt to be sure) 标记所属的skb是否已克隆</span></span><br><span class="line"><span class="comment"> *	@ip_summed: Driver fed us an IP checksum  用于标记传输层校验和的状态：CHECKSUM_NONE/CHECKSUM_PARTIAL/..</span></span><br><span class="line"><span class="comment"> *	@nohdr: Payload reference only, must not modify header payload是否被单独引用，不存在协议首部。若被单独引用，则不能修改首部，也不能由data访问首部</span></span><br><span class="line"><span class="comment"> *	@nfctinfo: Relationship of this skb to the connection </span></span><br><span class="line"><span class="comment"> *	@pkt_type: Packet class 帧类型：PACKET_HOST/PACKET_BROADCAST/PACKET_MULTICAST/PACKET_OTHERHOST/...</span></span><br><span class="line"><span class="comment"> *	@fclone: skbuff clone status 当前克隆状态：SKB_FCLONE_UNAVAILABLE/SKB_FCLONE_ORIG/SKB_FCLONE_CLONE:</span></span><br><span class="line"><span class="comment"> *	@ipvs_property: skbuff is owned by ipvs</span></span><br><span class="line"><span class="comment"> *	@peeked: this packet has been seen already, so stats have been</span></span><br><span class="line"><span class="comment"> *		done for it, don't do them again</span></span><br><span class="line"><span class="comment"> *	@nf_trace: netfilter packet trace flag </span></span><br><span class="line"><span class="comment"> *	@protocol: Packet protocol from driver，重要的字段，即链路层承载的三层协议类型，如ip ipv6 arp,在if_ether.h中有定义，这个用来确定收包时传给哪个协议处理函数，因此必须提前初始化；</span></span><br><span class="line"><span class="comment"> *	@destructor: Destruct function  析构函数</span></span><br><span class="line"><span class="comment"> *	@nfct: Associated connection, if any</span></span><br><span class="line"><span class="comment"> *	@nf_bridge: Saved data about a bridged frame - see br_netfilter.c</span></span><br><span class="line"><span class="comment"> *	@skb_iif: ifindex of device we arrived on</span></span><br><span class="line"><span class="comment"> *	@tc_index: Traffic control index  输入流量控制</span></span><br><span class="line"><span class="comment"> *	@tc_verd: traffic control verdict  输入流量控制</span></span><br><span class="line"><span class="comment"> *	@hash: the packet hash</span></span><br><span class="line"><span class="comment"> *	@queue_mapping: Queue mapping for multiqueue devices</span></span><br><span class="line"><span class="comment"> *	@xmit_more: More SKBs are pending for this queue</span></span><br><span class="line"><span class="comment"> *	@pfmemalloc: skbuff was allocated from PFMEMALLOC reserves</span></span><br><span class="line"><span class="comment"> *	@ndisc_nodetype: router type (from link layer)</span></span><br><span class="line"><span class="comment"> *	@ooo_okay: allow the mapping of a socket to a queue to be changed</span></span><br><span class="line"><span class="comment"> *	@l4_hash: indicate hash is a canonical 4-tuple hash over transport</span></span><br><span class="line"><span class="comment"> *		ports.</span></span><br><span class="line"><span class="comment"> *	@sw_hash: indicates hash was computed in software stack</span></span><br><span class="line"><span class="comment"> *	@wifi_acked_valid: wifi_acked was set</span></span><br><span class="line"><span class="comment"> *	@wifi_acked: whether frame was acked on wifi or not</span></span><br><span class="line"><span class="comment"> *	@no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS</span></span><br><span class="line"><span class="comment"> *	@dst_pending_confirm: need to confirm neighbour</span></span><br><span class="line"><span class="comment">  *	@napi_id: id of the NAPI struct this skb came from</span></span><br><span class="line"><span class="comment"> *	@secmark: security marking</span></span><br><span class="line"><span class="comment"> *	@offload_fwd_mark: fwding offload mark</span></span><br><span class="line"><span class="comment"> *	@mark: Generic packet mark</span></span><br><span class="line"><span class="comment"> *	@vlan_proto: vlan encapsulation protocol</span></span><br><span class="line"><span class="comment"> *	@vlan_tci: vlan tag control information</span></span><br><span class="line"><span class="comment"> *	@inner_protocol: Protocol (encapsulation)</span></span><br><span class="line"><span class="comment"> *	@inner_transport_header: Inner transport layer header (encapsulation) 传输层首部</span></span><br><span class="line"><span class="comment"> *	@inner_network_header: Network layer header (encapsulation) 网络层首部</span></span><br><span class="line"><span class="comment"> *	@inner_mac_header: Link layer header (encapsulation) 链路层首部，这几个首部，在层与层传输中，data会发生指向的改变；</span></span><br><span class="line"><span class="comment"> *	@transport_header: Transport layer header</span></span><br><span class="line"><span class="comment"> *	@network_header: Network layer header</span></span><br><span class="line"><span class="comment"> *	@mac_header: Link layer header </span></span><br><span class="line"><span class="comment"> *	@tail: Tail pointer</span></span><br><span class="line"><span class="comment"> *	@end: End pointer</span></span><br><span class="line"><span class="comment"> *	@head: Head of buffer</span></span><br><span class="line"><span class="comment"> *	@data: Data head pointer</span></span><br><span class="line"><span class="comment"> *	@truesize: Buffer size  整个缓存区长度 len+sizeof(sk_buff)</span></span><br><span class="line"><span class="comment"> *	@users: User count - see &#123;datagram,tcp&#125;.c 引用计数，为0时才释放此结构，否则只是单纯的递增递减，skb_get(),kfree_skb()等操作函数；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="comment">/* These two members must be first. */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">next</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">union</span> &#123;</span><br><span class="line">				<span class="keyword">ktime_t</span>		tstamp;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">skb_mstamp</span> <span class="title">skb_mstamp</span>;</span></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>		<span class="title">rbnode</span>;</span> <span class="comment">/* used in netem, ip4 defrag, and tcp stack */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sock</span>		*<span class="title">sk</span>;</span> </span><br><span class="line">		<span class="keyword">int</span>			ip_defrag_offset;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>	*<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is the control buffer. It is free to use for every</span></span><br><span class="line"><span class="comment">	 * layer. Please put your private variables there. If you</span></span><br><span class="line"><span class="comment">	 * want to keep them across layers you have to do a skb_clone()</span></span><br><span class="line"><span class="comment">	 * first. This is owned by whoever has the skb queued ATM.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span>			cb[<span class="number">48</span>] __aligned(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		_skb_refdst;</span><br><span class="line">	<span class="keyword">void</span>			(*destructor)(struct sk_buff *skb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_XFRM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">sec_path</span>	*<span class="title">sp</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span>	*<span class="title">nfct</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_BRIDGE_NETFILTER)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_bridge_info</span>	*<span class="title">nf_bridge</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		len,</span><br><span class="line">				data_len;</span><br><span class="line">	__u16			mac_len,</span><br><span class="line">				hdr_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Following fields are _not_ copied in __copy_skb_header()</span></span><br><span class="line"><span class="comment">	 * Note that queue_mapping is here mostly to fill a hole.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kmemcheck_bitfield_begin(flags1);</span><br><span class="line">	__u16			queue_mapping;</span><br><span class="line">	__u8			cloned:<span class="number">1</span>,</span><br><span class="line">				nohdr:<span class="number">1</span>,</span><br><span class="line">				fclone:<span class="number">2</span>,</span><br><span class="line">				peeked:<span class="number">1</span>,</span><br><span class="line">				head_frag:<span class="number">1</span>,</span><br><span class="line">				xmit_more:<span class="number">1</span>,</span><br><span class="line">				pfmemalloc:<span class="number">1</span>;</span><br><span class="line">	kmemcheck_bitfield_end(flags1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fields enclosed in headers_start/headers_end are copied</span></span><br><span class="line"><span class="comment">	 * using a single memcpy() in __copy_skb_header()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* private: */</span></span><br><span class="line">	__u32			headers_start[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">/* public: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* if you move pkt_type around you also must adapt those constants */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __BIG_ENDIAN_BITFIELD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PKT_TYPE_MAX	(7 &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PKT_TYPE_MAX	7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PKT_TYPE_OFFSET()	offsetof(struct sk_buff, __pkt_type_offset)</span></span><br><span class="line"></span><br><span class="line">	__u8			__pkt_type_offset[<span class="number">0</span>];</span><br><span class="line">	__u8			pkt_type:<span class="number">3</span>;</span><br><span class="line">	__u8			ignore_df:<span class="number">1</span>;</span><br><span class="line">	__u8			nfctinfo:<span class="number">3</span>;</span><br><span class="line">	__u8			nf_trace:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	__u8			ip_summed:<span class="number">2</span>;</span><br><span class="line">	__u8			ooo_okay:<span class="number">1</span>;</span><br><span class="line">	__u8			l4_hash:<span class="number">1</span>;</span><br><span class="line">	__u8			sw_hash:<span class="number">1</span>;</span><br><span class="line">	__u8			wifi_acked_valid:<span class="number">1</span>;</span><br><span class="line">	__u8			wifi_acked:<span class="number">1</span>;</span><br><span class="line">	__u8			no_fcs:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Indicates the inner headers are valid in the skbuff. */</span></span><br><span class="line">	__u8			encapsulation:<span class="number">1</span>;</span><br><span class="line">	__u8			encap_hdr_csum:<span class="number">1</span>;</span><br><span class="line">	__u8			csum_valid:<span class="number">1</span>;</span><br><span class="line">	__u8			csum_complete_sw:<span class="number">1</span>;</span><br><span class="line">	__u8			csum_level:<span class="number">2</span>;</span><br><span class="line">	__u8			csum_bad:<span class="number">1</span>;</span><br><span class="line">	__u8			dst_pending_confirm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IPV6_NDISC_NODETYPE</span></span><br><span class="line">	__u8			ndisc_nodetype:<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	__u8			ipvs_property:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	__u8			inner_protocol_type:<span class="number">1</span>;</span><br><span class="line">	__u8			remcsum_offload:<span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* 3 or 5 bit hole */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_SCHED</span></span><br><span class="line">	__u16			tc_index;	<span class="comment">/* traffic control index */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_CLS_ACT</span></span><br><span class="line">	__u16			tc_verd;	<span class="comment">/* traffic control verdict */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		__wsum		csum;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u16	csum_start;</span><br><span class="line">			__u16	csum_offset;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u32			priority;</span><br><span class="line">	<span class="keyword">int</span>			skb_iif;</span><br><span class="line">	__u32			hash;</span><br><span class="line">	__be16			vlan_proto;</span><br><span class="line">	__u16			vlan_tci;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_NET_RX_BUSY_POLL) || defined(CONFIG_XPS)</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span>	napi_id;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span>	sender_cpu;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NETWORK_SECMARK</span></span><br><span class="line">		__u32		secmark;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_SWITCHDEV</span></span><br><span class="line">		__u32		offload_fwd_mark;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		__u32		mark;</span><br><span class="line">		__u32		reserved_tailroom;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		__be16		inner_protocol;</span><br><span class="line">		__u8		inner_ipproto;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	__u16			inner_transport_header;</span><br><span class="line">	__u16			inner_network_header;</span><br><span class="line">	__u16			inner_mac_header;</span><br><span class="line"></span><br><span class="line">	__be16			protocol;</span><br><span class="line">	__u16			transport_header;</span><br><span class="line">	__u16			network_header;</span><br><span class="line">	__u16			mac_header;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* private: */</span></span><br><span class="line">	__u32			headers_end[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">/* public: */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line">	<span class="keyword">sk_buff_data_t</span>		tail;</span><br><span class="line">	<span class="keyword">sk_buff_data_t</span>		end;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>		*head,</span><br><span class="line">				*data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		truesize;</span><br><span class="line">	<span class="keyword">atomic_t</span>		users;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一张图片来表示skb的线性缓存区：发送和接收时会动态变化；<br>struct sk_buff<br>…<br>head —&gt;headroom起点<br>data —&gt;data起点<br>tail —&gt;tailroom起点<br>end  —&gt;skb_shared_info起点<br>|headroom|data|tailroom|skb_shared_info|</p>
<h3 id="skb-shared-info结构"><a href="#skb-shared-info结构" class="headerlink" title="skb_shared_info结构"></a>skb_shared_info结构</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This data is invariant across clones and lives at</span></span><br><span class="line"><span class="comment"> * the end of the header data, ie. at skb-&gt;end.</span></span><br><span class="line"><span class="comment"> */</span> <span class="comment">//即end指针指向的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	nr_frags;</span><br><span class="line">	__u8		tx_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>	gso_size;</span><br><span class="line">	<span class="comment">/* Warning: this field is not always filled in (UFO)! */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>	gso_segs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>  gso_type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	*<span class="title">frag_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_hwtstamps</span> <span class="title">hwtstamps</span>;</span></span><br><span class="line">	u32		tskey;</span><br><span class="line">	__be32          ip6_frag_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Warning : all fields before dataref are cleared in __alloc_skb()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	dataref;<span class="comment">//引用计数器：当一个数据缓存区被多个skb描述符引用时，就会设置相应的计数，如克隆一个skb</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Intermediate layers must ensure that destructor_arg</span></span><br><span class="line"><span class="comment">	 * remains valid until skb destructor */</span></span><br><span class="line">	<span class="keyword">void</span> *		destructor_arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* must be last field, see pskb_expand_head() */</span></span><br><span class="line">	<span class="keyword">skb_frag_t</span>	frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="通过网络接口在两个本地文件间传输数据下，如何避免四次拷贝"><a href="#通过网络接口在两个本地文件间传输数据下，如何避免四次拷贝" class="headerlink" title="通过网络接口在两个本地文件间传输数据下，如何避免四次拷贝"></a>通过网络接口在两个本地文件间传输数据下，如何避免四次拷贝</h4><p>在数据发送到接收时，往往send/write -&gt;recv/read 这期间会涉及四次拷贝：<br>发送app用户进程空间缓存–&gt;内核态缓存-（DMA复制)-&gt;硬件驱动 —-发送—-接收方硬件网络模块-(DMA复制)-&gt;内核态缓存–&gt;用户空间缓存；<br>如果是本地文件–网络接口—本地文件，这种也是四次拷贝，就有点耗费时间了；（或者是收到数据原封不动传输出去,这个貌似还没实现）<br>调用方式改变：从read/write====&gt;open/sendfile<br>实际路径改变：接收硬件网络模块(DMA复制)–&gt;内核态缓存—&gt; 发送硬件驱动</p>
<h4 id="什么是聚合分散io数据以及skb-shared-info中对它支持的结构；"><a href="#什么是聚合分散io数据以及skb-shared-info中对它支持的结构；" class="headerlink" title="什么是聚合分散io数据以及skb_shared_info中对它支持的结构；"></a>什么是聚合分散io数据以及skb_shared_info中对它支持的结构；</h4><p>这里的聚合分散IO相关数据成员：<br>struct sk_buff *frag_list; //FRAGLIST类型的IP分片相关结构<br>unsigned short nr_frags; //聚合分散IO分片数量<br>skb_frag_t frags[MAX_SKB_FRAGS];//聚合分散IO page相关结构指针；<br>先理解下网络发送接收和组合分片相关的流程：<br>发送：用户数据–&gt;四层tcp/udp–&gt;IP:此时包需要一层层传递组合各层头，需要进行比较多的拷贝，此时是组合；在内核传递发送报文给hard_start_xmit()之前，需要判断网络是否<br>支持NETIF_F_SG,否则只能线性化处理，是则检查nr_frags的值，确定片段数，之后进行分片聚合；<br>接受：IP分片–IP分片重组–&gt;udp/tcp–&gt;用户；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* To allow 64K frame to be packed as single skb without frag_list we</span></span><br><span class="line"><span class="comment"> * require 64K/PAGE_SIZE pages plus 1 additional page to allow for</span></span><br><span class="line"><span class="comment"> * buffers which do not start on a page boundary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since GRO uses frags we allocate at least 16 regardless of page</span></span><br><span class="line"><span class="comment"> * size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (65536/PAGE_SIZE + 1) &lt; 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SKB_FRAGS 16UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SKB_FRAGS (65536/PAGE_SIZE + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//所有最多支持64K个分片</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">skb_frag_struct</span> <span class="title">skb_frag_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_frag_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">p</span>;</span></span><br><span class="line">	&#125; page;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (BITS_PER_LONG &gt; 32) || (PAGE_SIZE &gt;= 65536)</span></span><br><span class="line">	__u32 page_offset;</span><br><span class="line">	__u32 size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	__u16 page_offset;</span><br><span class="line">	__u16 size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>frag_list的使用：<br>1) 在接受分片组后链接多个分片，组成一个完整的IP数据报；<br>2) UDP数据输出时，将待分片的SKB链接到一个SKB中，然后在输出时快速分片；<br>3) 用于存放FRAGLIST类型的聚合分散IO数据包；</li>
<li>nr_frag SG类型的聚合分散IO的使用：<br>1) 在输出时需要判断nr_frag=0? 且frag_list==NULL，则没有分片，若nr_frag不为0且frag_list为NULL,则是聚合分散IO;<br>nr_frag表示数量，内容由frags数组指出：eg:<br>nr_frag =2; frags[0].page=p1, frags[0].page_offset=0,size=S1; frags[1].page=p1,frags[1].page_offset=S1,size=S2;<br>2) 不同的skb实例中的page指向相同的内存，即共享分片结构（共享内存),这个需要两方都不去修改它；</li>
<li>FRAGLIST类型的聚合分散IO<br>frag_lsit直接指向了一个skb结构的实例；</li>
</ul>
<h4 id="关于GSO-GRO-TSO-TRO的基本概念；"><a href="#关于GSO-GRO-TSO-TRO的基本概念；" class="headerlink" title="关于GSO/GRO/TSO/TRO的基本概念；"></a>关于GSO/GRO/TSO/TRO的基本概念；</h4><h4 id="如何访问skb-shared-info结构："><a href="#如何访问skb-shared-info结构：" class="headerlink" title="如何访问skb_shared_info结构："></a>如何访问skb_shared_info结构：</h4><p>可以借助skb_info宏来访问此结构： 它其实就是简单的返回sk_buff结构的end指针的类型转换结果；</p>
<p>#define skb_shinfo(SKB) ((struct skb_shared_info*) ((SKB)-&gt;end))<br>eg: skb_shinfo(skb)-&gt;dataref++;</p>
<h3 id="skb的相关管理函数："><a href="#skb的相关管理函数：" class="headerlink" title="skb的相关管理函数："></a>skb的相关管理函数：</h3><p>内核提供了很多小函数来操作skb变量和链表等，这些函数都有两个版本：do_something和__do_something(),前者是在调用后者的情况下加上<br>锁和检查等；一般使用用前者的；这些函数定义在skbuff.h和skbuff.c中，我们称为skb的管理操作函数；<br>以下介绍每个类型的函数，并给出一些简单的例子，可以是demo或者是内核中的相关调用；</p>
<h4 id="SKB的缓存池介绍"><a href="#SKB的缓存池介绍" class="headerlink" title="SKB的缓存池介绍"></a>SKB的缓存池介绍</h4><p>在网络模块中，用告诉缓存来为skb分配空间，在初始化skb_init()中，创建了两个用来分配skb的高速缓存：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">skb_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	skbuff_head_cache = kmem_cache_create(<span class="string">"skbuff_head_cache"</span>,</span><br><span class="line">					      <span class="keyword">sizeof</span>(struct sk_buff),</span><br><span class="line">					      <span class="number">0</span>,</span><br><span class="line">					      SLAB_HWCACHE_ALIGN|SLAB_PANIC,</span><br><span class="line">					      <span class="literal">NULL</span>);</span><br><span class="line">	skbuff_fclone_cache = kmem_cache_create(<span class="string">"skbuff_fclone_cache"</span>,</span><br><span class="line">						<span class="keyword">sizeof</span>(struct sk_buff_fclones),</span><br><span class="line">						<span class="number">0</span>,</span><br><span class="line">						SLAB_HWCACHE_ALIGN|SLAB_PANIC,</span><br><span class="line">						<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Layout of fast clones : [skb1][skb2][fclone_ref] */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_fclones</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	<span class="title">skb1</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	<span class="title">skb2</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">atomic_t</span>	fclone_ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下用第一个，当在分配skb的时候知道可能被克隆，则用第二个，因为第二个中会同时分配一个后备的skb，在克隆的时候直接用后备的skb就可以，不用重新分配；<br>可以看到第二个的单位内存区域是2*size+atomic_t,后者是用来做引用计数的；引用计数取0,1,2分别代表两个都没有被引用，1表示引用了其中一个，2表示两个都被引用；</p>
<h4 id="如何分配SKB"><a href="#如何分配SKB" class="headerlink" title="如何分配SKB"></a>如何分配SKB</h4><p>1) alloc_skb()<br>skb的数据缓存区和skb本身描述符是两个不同的实体，所以在分配一个skb时，实际上需要分配两块内存：<br>一个是skb描述符，一个是数据缓存区；在4.8的内核版本可以看到：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct sk_buff *<span class="title">alloc_skb</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">gfp_t</span> priority)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __alloc_skb(size, priority, <span class="number">0</span>, NUMA_NO_NODE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数传入一个size和priority,返回一个sk_buff指针；<br>而__alloc_skb()则有四个参数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	__alloc_skb	-	allocate a network buffer</span></span><br><span class="line"><span class="comment"> *	@size: size to allocate 分配的长度</span></span><br><span class="line"><span class="comment"> *	@gfp_mask: allocation mask  分配内存的方式</span></span><br><span class="line"><span class="comment"> *	@flags: If SKB_ALLOC_FCLONE is set, allocate from fclone cache</span></span><br><span class="line"><span class="comment"> *		instead of head cache and allocate a cloned (child) skb.</span></span><br><span class="line"><span class="comment"> *		If SKB_ALLOC_RX is set, __GFP_MEMALLOC will be used for</span></span><br><span class="line"><span class="comment"> *		allocations in case the data is required for writeback </span></span><br><span class="line"><span class="comment">        预测是否会克隆，以此判断是从哪个告诉缓存中分配</span></span><br><span class="line"><span class="comment">        若 SKB_ALLOC_RX is set。。。</span></span><br><span class="line"><span class="comment"> *	@node: numa node to allocate memory on 当支持NUMA时，用于确定从哪个内存区中分配SKB</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Allocate a new &amp;sk_buff. The returned buffer has no headroom and a</span></span><br><span class="line"><span class="comment"> *	tail room of at least size bytes. The object has a reference count</span></span><br><span class="line"><span class="comment"> *	of one. The return is the buffer. On a failure the return is %NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Buffers may only be allocated from interrupts using a @gfp_mask of</span></span><br><span class="line"><span class="comment"> *	%GFP_ATOMIC.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>,</span></span><br><span class="line"><span class="class">			    <span class="title">int</span> <span class="title">flags</span>, <span class="title">int</span> <span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> *<span class="title">shinfo</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	u8 *data;</span><br><span class="line">	<span class="keyword">bool</span> pfmemalloc;</span><br><span class="line"></span><br><span class="line">	cache = (flags &amp; SKB_ALLOC_FCLONE)</span><br><span class="line">		? skbuff_fclone_cache : skbuff_head_cache;<span class="comment">//判断是用哪种高速缓存，上面已解释</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk_memalloc_socks() &amp;&amp; (flags &amp; SKB_ALLOC_RX))<span class="comment">//判断是否可以用紧急的缓存</span></span><br><span class="line">		gfp_mask |= __GFP_MEMALLOC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the HEAD */</span></span><br><span class="line">	skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~__GFP_DMA, node);<span class="comment">//从选定的告诉缓存中分配一个SKB描述符,一般在slab分配</span></span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	prefetchw(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We do our best to align skb_shared_info on a separate cache</span></span><br><span class="line"><span class="comment">	 * line. It usually works because kmalloc(X &gt; SMP_CACHE_BYTES) gives</span></span><br><span class="line"><span class="comment">	 * aligned memory blocks, unless SLUB/SLAB debug is enabled.</span></span><br><span class="line"><span class="comment">	 * Both skb-&gt;head and skb_shared_info are cache line aligned.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = SKB_DATA_ALIGN(size);<span class="comment">//给size先做下对齐</span></span><br><span class="line">	size += SKB_DATA_ALIGN(<span class="keyword">sizeof</span>(struct skb_shared_info));<span class="comment">//加上缓存区尾部的skb_shared_info结构后</span></span><br><span class="line">	data = kmalloc_reserve(size, gfp_mask, node, &amp;pfmemalloc);<span class="comment">//分配数据缓存区</span></span><br><span class="line">	<span class="keyword">if</span> (!data)</span><br><span class="line">		<span class="keyword">goto</span> nodata;</span><br><span class="line">	<span class="comment">/* kmalloc(size) might give us more room than requested.</span></span><br><span class="line"><span class="comment">	 * Put skb_shared_info exactly at the end of allocated zone,</span></span><br><span class="line"><span class="comment">	 * to allow max possible filling before reallocation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = SKB_WITH_OVERHEAD(ksize(data));</span><br><span class="line">	prefetchw(data + size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only clear those fields we need to clear, not those that we will</span></span><br><span class="line"><span class="comment">	 * actually initialise below. Hence, don't put any more fields after</span></span><br><span class="line"><span class="comment">	 * the tail pointer in struct sk_buff!</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(skb, <span class="number">0</span>, offsetof(struct sk_buff, tail));</span><br><span class="line">	<span class="comment">/* Account for allocated memory : skb + skb-&gt;head */</span></span><br><span class="line">	skb-&gt;truesize = SKB_TRUESIZE(size);</span><br><span class="line">	skb-&gt;pfmemalloc = pfmemalloc;</span><br><span class="line">	atomic_set(&amp;skb-&gt;users, <span class="number">1</span>);</span><br><span class="line">	skb-&gt;head = data;</span><br><span class="line">	skb-&gt;data = data;</span><br><span class="line">	skb_reset_tail_pointer(skb);</span><br><span class="line">	skb-&gt;end = skb-&gt;tail + size;</span><br><span class="line">	skb-&gt;mac_header = (typeof(skb-&gt;mac_header))~<span class="number">0U</span>;</span><br><span class="line">	skb-&gt;transport_header = (typeof(skb-&gt;transport_header))~<span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* make sure we initialize shinfo sequentially */</span></span><br><span class="line">	shinfo = skb_shinfo(skb);</span><br><span class="line">	<span class="built_in">memset</span>(shinfo, <span class="number">0</span>, offsetof(struct skb_shared_info, dataref));</span><br><span class="line">	atomic_set(&amp;shinfo-&gt;dataref, <span class="number">1</span>);</span><br><span class="line">	kmemcheck_annotate_variable(shinfo-&gt;destructor_arg);</span><br><span class="line">    <span class="comment">//置克隆相关位</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SKB_ALLOC_FCLONE) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_fclones</span> *<span class="title">fclones</span>;</span></span><br><span class="line"></span><br><span class="line">		fclones = container_of(skb, struct sk_buff_fclones, skb1);</span><br><span class="line"></span><br><span class="line">		kmemcheck_annotate_bitfield(&amp;fclones-&gt;skb2, flags1);</span><br><span class="line">		skb-&gt;fclone = SKB_FCLONE_ORIG;</span><br><span class="line">		atomic_set(&amp;fclones-&gt;fclone_ref, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		fclones-&gt;skb2.fclone = SKB_FCLONE_CLONE;</span><br><span class="line">		fclones-&gt;skb2.pfmemalloc = pfmemalloc;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> skb;</span><br><span class="line">nodata:</span><br><span class="line">	kmem_cache_free(cache, skb);</span><br><span class="line">	skb = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__alloc_skb);</span><br></pre></td></tr></table></figure></p>
<p>注意：<strong>alloc_skb通常不被直接调用，而是封装调用，被封装在</strong>netdev_alloc_skb(),alloc_skb(),alloc_skb_fclone()等；<br>dev_alloc_skb()也是一个缓存区分配函数，也是返回sk_buff*,通常在设备驱动中断上下文中，是一个alloc_skb()的封装函数，因为在中断处理函数中被调用，所以要求<br>原子操作(GFP_ATOMIC),4.8版本已经变了，封装的是别的函数，但是类似；</p>
<h4 id="如何释放SKB"><a href="#如何释放SKB" class="headerlink" title="如何释放SKB"></a>如何释放SKB</h4><p>dev_kfree_skb()和kfree_skb()都可以用来释放skb，把它返回给高速缓存；dev_kfree_skb()只是简单的封装kfree_skb();<br>调用时只是简单的递减skb-&gt;users的值，直到减完为0才真的释放内存；<br>具体见skbuff.h/skbuff.c</p>
<h4 id="数据预留和对齐"><a href="#数据预留和对齐" class="headerlink" title="数据预留和对齐"></a>数据预留和对齐</h4><p>主要是通过skb_reserve(),skb_put,skb_push,skb_pull,等函数，对数据缓存区相关指针进行更新来做预留空间的操作；<br>具体怎么移动，要看是接收方向还是发送方向：<br>1) skb_reserve()<br>skb_reserve()通常用来在数据缓存区头部预留一定的空间，比如插入协议首部或者在某个边界上对齐，而预留操作主要是移动data和tail指针；<br>注意只能用于空的skb，所以通常在分配后就会调用该函数；此时tail和data一同指向数据区的起始位置；<br>例如：某个以太网设备驱动接收函数在分配skb后，在向skb缓存区填充数据前，会通过skb_reserve(skb,2)来预留两个字节，因为以太网首部是14B,加了后正好16B对齐；此时是data指针往下移动两个字节；<br>当数据从上往下传递时，则每层将skb-&gt;data指针往上移动，然后复制本层首部，更新len;<br>2) skb_push()<br>在数据缓存区前头增加一块数据。也是只移动data和tail指针，和reserve类似<br>3) skb_put()<br>修改指向末尾的tail指针，使之向下移动len字节，然后更新len<br>4) skb_pull()<br>data指针向下移动；从而在数据区首部忽略len字节长度，用于收到包后往上传递忽略首部；</p>
<h4 id="克隆和复制SKB"><a href="#克隆和复制SKB" class="headerlink" title="克隆和复制SKB"></a>克隆和复制SKB</h4><p>1) skb_clone() 用来克隆skb，克隆时只复制skb描述符，而对数据缓存区则，引用计数+1；<br>2) pskb_copy() 当一个函数不仅要修改skb描述符，还要修改数据缓存区的时候，就需要同时复制数据缓存区；如果要修改的数据在head-end之间，就可以用这个函数，<br>不然若还要修改聚合分散IO中的数据，则用skb_copy()做完全的拷贝；</p>
<h4 id="SKB链表的管理函数"><a href="#SKB链表的管理函数" class="headerlink" title="SKB链表的管理函数"></a>SKB链表的管理函数</h4><p>在skb链表操作中，为了防止被中断，则必须先获得自旋锁；然后才能访问队列中的元素；<br>skb_queue_head_init() :初始化skb链表头结点，创建一个空的skb链表；<br>skb_queue_head()/skb_queue_tail(),加入队列头/尾部，<br>skb_dequeue和skb_dequeue_tail，从首部和尾部取下一个skb;<br>skb_queue_purge() ,清空skb链表；<br>skb_queue_walk() 循环遍历skb链表中每个元素的宏；</p>
<h4 id="添加和删除尾部数据"><a href="#添加和删除尾部数据" class="headerlink" title="添加和删除尾部数据"></a>添加和删除尾部数据</h4><p>注意这里指的尾部数据，是data指向数据的结尾，而tail指向的是结尾的空间部分，一般是空的；<br>skb_add_data() tail指针下移，data尾部增加用户空间传递的数据，len加加；<br>skb_trim()和上面相反；<br>pskb_trim() 也处理到聚合分散iO;</p>
<h4 id="拆分数据"><a href="#拆分数据" class="headerlink" title="拆分数据"></a>拆分数据</h4><p>就是把一个skb拆成两个skb:<br>skb_split();分两种情况，一种是拆分的len小于线性缓存区长(即不包含聚合分散IO的)，另一种是大于，即分拆点在聚合分散IO中的某个位置；</p>
<h4 id="重新分配SKB的线性数据区；"><a href="#重新分配SKB的线性数据区；" class="headerlink" title="重新分配SKB的线性数据区；"></a>重新分配SKB的线性数据区；</h4><p>pskb_expand_head(),可以理解为realloc,就是扩展空间，将原数据复制过去；</p>
<h4 id="其他函数；"><a href="#其他函数；" class="headerlink" title="其他函数；"></a>其他函数；</h4><p>pskb_may_pull: 检测skb中的数据是否有指定长度<br>skb_queue_empty:检测skb队列是否为空<br>skb_realloc_headroom: 根据指定的skb得到一个新的skb,并确保新的skb存在指定的headroom空间；<br>skb_get() :引用并返回一个skb;<br>skb_shared() :检测指定的skb是否被多次引用；<br>skb_share_check():检测并返回skb,当被检测的skb被引用多次时，则克隆此skb,并返回克隆得到的skb;<br>skb_unshare():检测并返回skb,当被检查的skb被克隆时，则复制此skb,并返回复制得到的skb;<br>skb_orphan(): 使得此skb不属于任何传输控制块；<br>skb_cow(): 确保skb存在指定的head空间，若不足，则会重新分配<br>skb_pagelen(): 获得skb中线性数据区和SG类型聚合分散io分片中的数据的长度；</p>
<h4 id="关于虚拟设备和物理设备："><a href="#关于虚拟设备和物理设备：" class="headerlink" title="关于虚拟设备和物理设备："></a>关于虚拟设备和物理设备：</h4><p>linux支持多种形式的虚拟网络设备，并通过一个虚拟网络设备驱动管理。当这个虚拟设备被使用时，dev指针指向该虚拟设备的net_device结构。<br>在输出时，虚拟设备驱动会在一组设备中选择其中的某个合适的设备，并将dev指针修改为指向这个设备的net_device结构；<br>在输入时，当原始网络设备收到报文后，根据某种算法选择某个合适的虚拟网络设备，并将dev指针修改为指向这个虚拟设备的net_device结构。<br>因此，在某些情况下，指向传输设备的指针会在包处理过程中改变；</p>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_code</tag>
      </tags>
  </entry>
  <entry>
    <title>cprogram_generate</title>
    <url>/2021/02/20/cprogram-generate/</url>
    <content><![CDATA[<h3 id="关于编译链接执行，编译器和cpu相关"><a href="#关于编译链接执行，编译器和cpu相关" class="headerlink" title="关于编译链接执行，编译器和cpu相关"></a>关于编译链接执行，编译器和cpu相关</h3><p>目标： 学完这个部分的知识和调试方法后，一方面可以在写程序时，减少编译错误等，在遇到编译和运行时错误，可以更快的解决或者知道怎么解决，用什么工具可以<br>更快的解决，另一方面，在处理cpu高载，dump问题时，能知道怎么处理和更好的处理； <a id="more"></a></p>
<h3 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h3><p>说明linux下程序的预处理，编译，链接，运行的整个过程；<br>三个文件如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">main.cpp                               |func.cpp                               |func.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;                      |#include "func.h"                      |int funcc(int a1);</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;                     |int g_m = 3;                           |</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;                     |extern int g_n ;                       |~                                      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"func.h"</span>                      |int funcc(int a1)                      |~                                      </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_m;                        |&#123;                                      |~                                      </span><br><span class="line"><span class="keyword">int</span> g_n = <span class="number">3</span>;                           |    <span class="keyword">int</span> res = a1+<span class="number">3</span>+g_n;                |~                                      </span><br><span class="line">int main()                             |    return res;                        |~                                      </span><br><span class="line">&#123;                                      |&#125;                                      |~                                      </span><br><span class="line">    <span class="keyword">int</span> g_x = <span class="number">3</span>;                       |                                       |~                                      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello"</span>);                   |~                                      |~                                      </span><br><span class="line">    setuid(<span class="number">234323</span>);                    |~                                      |~                                      </span><br><span class="line">    <span class="keyword">int</span> c = funcc(g_x+<span class="number">2</span>);              |~                                      |~                                      </span><br><span class="line">    <span class="keyword">int</span> *i = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) *|~                                      |~                                      </span><br><span class="line"><span class="number">2</span>);                                    |~                                      |~                                      </span><br><span class="line">    *i = <span class="number">2</span>;                            |~                                      |~                                      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %lx\n"</span>,*i,i);          |~                                      |~                                      </span><br><span class="line">    <span class="built_in">free</span>(i);                           |~                                      |~                                      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                          |~                                      |~                                      </span><br><span class="line">&#125;                                      |~                                      |~</span><br></pre></td></tr></table></figure></p>
<h4 id="各自预处理后："><a href="#各自预处理后：" class="headerlink" title="各自预处理后："></a>各自预处理后：</h4><p>gcc -E test.c -o test.i 或 gcc -E test.c<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">func.i:</span><br><span class="line"># <span class="number">1</span> <span class="string">"func.cpp"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"func.cpp"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"func.h"</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcc</span><span class="params">(<span class="keyword">int</span> a1)</span></span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">"func.cpp"</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">int</span> g_m = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_n ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcc</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = a1+<span class="number">3</span>+g_n;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.i:</span><br><span class="line">前面展开太多，不贴了：</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">swab</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *__restrict __from, <span class="keyword">void</span> *__restrict __to,</span></span></span><br><span class="line">    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));</span><br><span class="line"># <span class="number">1151</span> <span class="string">"/usr/include/unistd.h"</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"># <span class="number">3</span> <span class="string">"main.cpp"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"func.h"</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcc</span><span class="params">(<span class="keyword">int</span> a1)</span></span>;</span><br><span class="line"># <span class="number">4</span> <span class="string">"main.cpp"</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_m;</span><br><span class="line"><span class="keyword">int</span> g_n = <span class="number">3</span>;                           </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                             </span></span><br><span class="line"><span class="function"></span>&#123;                                      </span><br><span class="line">    <span class="keyword">int</span> g_x = <span class="number">3</span>;                       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello"</span>);                   </span><br><span class="line">    setuid(<span class="number">234323</span>);                    </span><br><span class="line">    <span class="keyword">int</span> c = funcc(g_x+<span class="number">2</span>);              </span><br><span class="line">    <span class="keyword">int</span> *i = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) *<span class="number">2</span>);                                    </span><br><span class="line">    *i = <span class="number">2</span>;                            </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %lx\n"</span>,*i,i);          </span><br><span class="line">    <span class="built_in">free</span>(i);                           </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="接着编译为汇编文件："><a href="#接着编译为汇编文件：" class="headerlink" title="接着编译为汇编文件："></a>接着编译为汇编文件：</h4><p>gcc -S main.cpp<br>gcc -S func.cpp<br>从下面可以看到，已经对程序进行基本分段了，有数据段，代码段等，对全局变量，有专门的段来存取，对未确定的符号，用类型和等标识；<br>汇编语言和特定的cpu有关；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        .file   <span class="string">"main.cpp"</span>                                                |        .file   <span class="string">"func.cpp"</span></span><br><span class="line">        .globl  g_n                                                       |        .globl  g_m</span><br><span class="line">        .data                                                             |        .data</span><br><span class="line">        .align <span class="number">4</span>                                                          |        .align <span class="number">4</span></span><br><span class="line">        .type   g_n, @object                                              |        .type   g_m, @object</span><br><span class="line">        .size   g_n, <span class="number">4</span>                                                    |        .size   g_m, <span class="number">4</span></span><br><span class="line">g_n:                                                                      |g_m:</span><br><span class="line">        .<span class="keyword">long</span>   <span class="number">3</span>                                                         |        .<span class="keyword">long</span>   <span class="number">3</span></span><br><span class="line">        .section        .rodata                                           |        .text</span><br><span class="line">.LC0:                                                                     |        .globl  _Z5funcci</span><br><span class="line">        .<span class="built_in">string</span> <span class="string">"hello"</span>                                                   |        .type   _Z5funcci, @function</span><br><span class="line">.LC1:                                                                     |_Z5funcci:</span><br><span class="line">        .<span class="built_in">string</span> <span class="string">"%d  %lx\n"</span>                                               |.LFB0:</span><br><span class="line">        .text                                                             |        .cfi_startproc</span><br><span class="line">        .globl  main                                                      |        pushq   %rbp</span><br><span class="line">        .type   main, @function                                           |        .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">main:                                                                     |        .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">.LFB2:                                                                    |        movq    %rsp, %rbp</span><br><span class="line">        .cfi_startproc                                                    |        .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">        pushq   %rbp                                                      |        movl    %edi, <span class="number">-20</span>(%rbp)</span><br><span class="line">        .cfi_def_cfa_offset <span class="number">16</span>                                            |        movl    <span class="number">-20</span>(%rbp), %eax</span><br><span class="line">        .cfi_offset <span class="number">6</span>, <span class="number">-16</span>                                                |        leal    <span class="number">3</span>(%rax), %edx</span><br><span class="line">        movq    %rsp, %rbp                                                |        movl    g_n(%rip), %eax</span><br><span class="line">        .cfi_def_cfa_register <span class="number">6</span>                                           |        addl    %edx, %eax</span><br><span class="line">        subq    $<span class="number">16</span>, %rsp                                                 |        movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">        movl    $<span class="number">3</span>, <span class="number">-16</span>(%rbp)                                             |        movl    <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">        movl    $.LC0, %edi                                               |        popq    %rbp</span><br><span class="line">        movl    $<span class="number">0</span>, %eax                                                  |        .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">        call    <span class="built_in">printf</span>                                                    |        ret</span><br><span class="line">        movl    $<span class="number">234323</span>, %edi                                             |        .cfi_endproc</span><br><span class="line">        call    setuid                                                    |.LFE0:</span><br><span class="line">        movl    <span class="number">-16</span>(%rbp), %eax                                           |        .size   _Z5funcci, .-_Z5funcci</span><br><span class="line">        addl    $<span class="number">2</span>, %eax                                                  |        .ident  <span class="string">"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4"</span></span><br><span class="line">        movl    %eax, %edi                                                |        .section        .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br><span class="line">        call    _Z5funcci                                                  </span><br><span class="line">        movl    %eax, <span class="number">-12</span>(%rbp)                                           </span><br><span class="line">        movl    $<span class="number">8</span>, %eax</span><br><span class="line">        movq    %rax, %rdi                                                </span><br><span class="line">        call    <span class="built_in">malloc</span></span><br><span class="line">        movq    %rax, <span class="number">-8</span>(%rbp)                                            </span><br><span class="line">        movq    <span class="number">-8</span>(%rbp), %rax                                            </span><br><span class="line">        movl    $<span class="number">2</span>, (%rax)</span><br><span class="line">        movq    <span class="number">-8</span>(%rbp), %rax                                            </span><br><span class="line">        movl    (%rax), %eax</span><br><span class="line">        movq    <span class="number">-8</span>(%rbp), %rdx                                            </span><br><span class="line">        movl    %eax, %esi</span><br><span class="line">        movl    $.LC1, %edi                                               </span><br><span class="line">        movl    $<span class="number">0</span>, %eax                                                  </span><br><span class="line">        call    <span class="built_in">printf</span></span><br><span class="line">        movq    <span class="number">-8</span>(%rbp), %rax                                            </span><br><span class="line">        movq    %rax, %rdi                                                </span><br><span class="line">        call    <span class="built_in">free</span></span><br><span class="line">        movl    $<span class="number">0</span>, %eax                                                  </span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span>                                                 </span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc                                                      </span><br><span class="line">.LFE2:  </span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  <span class="string">"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4"</span>              </span><br><span class="line">        .section        .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure></p>
<h4 id="编译为目标文件："><a href="#编译为目标文件：" class="headerlink" title="编译为目标文件："></a>编译为目标文件：</h4><p>gcc -c main.cpp<br>gcc -c func.cpp<br>objdump -x func.o<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> file func.o</span><br><span class="line">func.o: ELF <span class="number">64</span>-bit LSB  relocatable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), <span class="keyword">not</span> stripped</span><br><span class="line">为relocatable可重定向文件</span><br><span class="line">objdump  -x func.o</span><br><span class="line"></span><br><span class="line">func.o:     file format elf64-x86<span class="number">-64</span> 文件格式</span><br><span class="line">func.o</span><br><span class="line">architecture: i386:x86<span class="number">-64</span>, flags <span class="number">0x00000011</span>: 系统架构</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address <span class="number">0x0000000000000000</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">0000001</span>d  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000060</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000064</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000064</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">4</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000090</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000090</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">SYMBOL TABLE:符号表，每个编译后的目标文件都有</span><br><span class="line"><span class="number">0000000000000000</span> l    df *ABS*	<span class="number">0000000000000000</span> func.cpp</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .text	<span class="number">0000000000000000</span> .text</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .data	<span class="number">0000000000000000</span> .data</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .bss	<span class="number">0000000000000000</span> .bss</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .note.GNU-<span class="built_in">stack</span>	<span class="number">0000000000000000</span> .note.GNU-<span class="built_in">stack</span></span><br><span class="line"><span class="number">0000000000000000</span> l    d  .eh_frame	<span class="number">0000000000000000</span> .eh_frame</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .comment	<span class="number">0000000000000000</span> .comment</span><br><span class="line"><span class="number">0000000000000000</span> g     O .data	<span class="number">0000000000000004</span> g_m</span><br><span class="line"><span class="number">0000000000000000</span> g     F .text	<span class="number">000000000000001</span>d _Z5funcci</span><br><span class="line"><span class="number">0000000000000000</span>         *UND*	<span class="number">0000000000000000</span> g_n  <span class="comment">//依赖的外部，未定义的符号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">000000000000000f</span> R_X86_64_PC32     g_n<span class="number">-0x0000000000000004</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000000020</span> R_X86_64_PC32     .text</span><br><span class="line"></span><br><span class="line">  file main.o</span><br><span class="line">main.o: ELF <span class="number">64</span>-bit LSB  relocatable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), <span class="keyword">not</span> stripped</span><br><span class="line"> objdump  -x main.o</span><br><span class="line"></span><br><span class="line">main.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line">main.o</span><br><span class="line">architecture: i386:x86<span class="number">-64</span>, flags <span class="number">0x00000011</span>:</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address <span class="number">0x0000000000000000</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00000081</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c4  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c8  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .rodata       <span class="number">0000000f</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c8  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">4</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>d7  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000103</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">6</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000108</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">SYMBOL TABLE: 这个是符号表，即这个文件导出或者依赖的符号，用于模块间调用使用；</span><br><span class="line"><span class="number">0000000000000000</span> l    df *ABS*	<span class="number">0000000000000000</span> main.cpp</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .text	<span class="number">0000000000000000</span> .text</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .data	<span class="number">0000000000000000</span> .data</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .bss	<span class="number">0000000000000000</span> .bss</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .rodata	<span class="number">0000000000000000</span> .rodata</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .note.GNU-<span class="built_in">stack</span>	<span class="number">0000000000000000</span> .note.GNU-<span class="built_in">stack</span></span><br><span class="line"><span class="number">0000000000000000</span> l    d  .eh_frame	<span class="number">0000000000000000</span> .eh_frame</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .comment	<span class="number">0000000000000000</span> .comment</span><br><span class="line"><span class="number">0000000000000000</span> g     O .data	<span class="number">0000000000000004</span> g_n</span><br><span class="line"><span class="number">0000000000000000</span> g     F .text	<span class="number">0000000000000081</span> main <span class="comment">//下面为依赖的外部符号，有点多，可以看到，因为这里没有使用g_m，所以不依赖；</span></span><br><span class="line"><span class="number">0000000000000000</span>         *UND*	<span class="number">0000000000000000</span> <span class="built_in">printf</span></span><br><span class="line"><span class="number">0000000000000000</span>         *UND*	<span class="number">0000000000000000</span> setuid</span><br><span class="line"><span class="number">0000000000000000</span>         *UND*	<span class="number">0000000000000000</span> _Z5funcci</span><br><span class="line"><span class="number">0000000000000000</span>         *UND*	<span class="number">0000000000000000</span> <span class="built_in">malloc</span></span><br><span class="line"><span class="number">0000000000000000</span>         *UND*	<span class="number">0000000000000000</span> <span class="built_in">free</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000000010</span> R_X86_64_32       .rodata</span><br><span class="line"><span class="number">000000000000001</span>a R_X86_64_PC32     <span class="built_in">printf</span><span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000024</span> R_X86_64_PC32     setuid<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000031</span> R_X86_64_PC32     _Z5funcci<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000041</span> R_X86_64_PC32     <span class="built_in">malloc</span><span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000060</span> R_X86_64_32       .rodata+<span class="number">0x0000000000000006</span></span><br><span class="line"><span class="number">000000000000006</span>a R_X86_64_PC32     <span class="built_in">printf</span><span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000076</span> R_X86_64_PC32     <span class="built_in">free</span><span class="number">-0x0000000000000004</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000000020</span> R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure></p>
<h4 id="接下来链接："><a href="#接下来链接：" class="headerlink" title="接下来链接："></a>接下来链接：</h4><p>gcc -o main main.cpp  func.cpp<br>也可以用ld命令链接，但是需要指定更多依赖；而gcc会自己去寻找一些默认的库等；</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"> file main</span><br><span class="line">main: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=2110927a3d6ecf4dd0f70085d18bc49c3b61ba41, not stripped</span><br></pre></td></tr></table></figure>
<p>可以看到这个文件为可执行文件类型；<br>通过elf工具看整个可执行程序的结构：上面的main.o func.o也是elf文件类型之一<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> readelf -a main</span><br><span class="line"> elf文件头：各个字段</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              <span class="number">2'</span>s complement, little endian</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       <span class="number">0</span></span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  Version:                           <span class="number">0x1</span></span><br><span class="line">  Entry point address:               <span class="number">0x400520</span></span><br><span class="line">  Start of program headers:          <span class="number">64</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">4544</span> (bytes into file)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  Size of <span class="keyword">this</span> header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">56</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">9</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">30</span></span><br><span class="line">  Section header <span class="built_in">string</span> table index: <span class="number">27</span></span><br><span class="line"></span><br><span class="line">各个sections</span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .interp           PROGBITS         <span class="number">0000000000400238</span>  <span class="number">00000238</span></span><br><span class="line">       <span class="number">000000000000001</span>c  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .note.ABI-tag     NOTE             <span class="number">0000000000400254</span>  <span class="number">00000254</span></span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">3</span>] .note.gnu.build-i NOTE             <span class="number">0000000000400274</span>  <span class="number">00000274</span></span><br><span class="line">       <span class="number">0000000000000024</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .gnu.hash         GNU_HASH         <span class="number">0000000000400298</span>  <span class="number">00000298</span></span><br><span class="line">       <span class="number">000000000000001</span>c  <span class="number">0000000000000000</span>   A       <span class="number">5</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">5</span>] .dynsym           DYNSYM           <span class="number">00000000004002b</span>8  <span class="number">000002b</span>8</span><br><span class="line">       <span class="number">00000000000000</span>a8  <span class="number">0000000000000018</span>   A       <span class="number">6</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">6</span>] .dynstr           STRTAB           <span class="number">0000000000400360</span>  <span class="number">00000360</span></span><br><span class="line">       <span class="number">0000000000000052</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .gnu.version      VERSYM           <span class="number">00000000004003b</span>2  <span class="number">000003b</span>2</span><br><span class="line">       <span class="number">000000000000000</span>e  <span class="number">0000000000000002</span>   A       <span class="number">5</span>     <span class="number">0</span>     <span class="number">2</span></span><br><span class="line">  [ <span class="number">8</span>] .gnu.version_r    VERNEED          <span class="number">00000000004003</span>c0  <span class="number">000003</span>c0</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">6</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">9</span>] .rela.dyn         RELA             <span class="number">00000000004003e0</span>  <span class="number">000003e0</span></span><br><span class="line">       <span class="number">0000000000000018</span>  <span class="number">0000000000000018</span>   A       <span class="number">5</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .rela.plt         RELA             <span class="number">00000000004003f</span>8  <span class="number">000003f</span>8</span><br><span class="line">       <span class="number">0000000000000090</span>  <span class="number">0000000000000018</span>   A       <span class="number">5</span>    <span class="number">12</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .init             PROGBITS         <span class="number">0000000000400488</span>  <span class="number">00000488</span></span><br><span class="line">       <span class="number">000000000000001</span>a  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">12</span>] .plt              PROGBITS         <span class="number">00000000004004b</span>0  <span class="number">000004b</span>0</span><br><span class="line">       <span class="number">0000000000000070</span>  <span class="number">0000000000000010</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">13</span>] .text             PROGBITS         <span class="number">0000000000400520</span>  <span class="number">00000520</span></span><br><span class="line">       <span class="number">0000000000000202</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">14</span>] .fini             PROGBITS         <span class="number">0000000000400724</span>  <span class="number">00000724</span></span><br><span class="line">       <span class="number">0000000000000009</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">15</span>] .rodata           PROGBITS         <span class="number">0000000000400730</span>  <span class="number">00000730</span></span><br><span class="line">       <span class="number">0000000000000013</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">16</span>] .eh_frame_hdr     PROGBITS         <span class="number">0000000000400744</span>  <span class="number">00000744</span></span><br><span class="line">       <span class="number">000000000000003</span>c  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">17</span>] .eh_frame         PROGBITS         <span class="number">0000000000400780</span>  <span class="number">00000780</span></span><br><span class="line">       <span class="number">0000000000000114</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">18</span>] .init_array       INIT_ARRAY       <span class="number">0000000000600e10</span>  <span class="number">00000e10</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">19</span>] .fini_array       FINI_ARRAY       <span class="number">0000000000600e18</span>  <span class="number">00000e18</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">20</span>] .jcr              PROGBITS         <span class="number">0000000000600e20</span>  <span class="number">00000e20</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">21</span>] .dynamic          DYNAMIC          <span class="number">0000000000600e28</span>  <span class="number">00000e28</span></span><br><span class="line">       <span class="number">00000000000001</span>d0  <span class="number">0000000000000010</span>  WA       <span class="number">6</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">22</span>] .got              PROGBITS         <span class="number">0000000000600f</span>f8  <span class="number">00000f</span>f8</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">23</span>] .got.plt          PROGBITS         <span class="number">0000000000601000</span>  <span class="number">00001000</span></span><br><span class="line">       <span class="number">0000000000000048</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">24</span>] .data             PROGBITS         <span class="number">0000000000601048</span>  <span class="number">00001048</span></span><br><span class="line">       <span class="number">0000000000000018</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">25</span>] .bss              NOBITS           <span class="number">0000000000601060</span>  <span class="number">00001060</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">26</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00001060</span></span><br><span class="line">       <span class="number">0000000000000056</span>  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">27</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">000010b</span>6</span><br><span class="line">       <span class="number">0000000000000108</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">28</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00001940</span></span><br><span class="line">       <span class="number">00000000000006</span>c0  <span class="number">0000000000000018</span>          <span class="number">29</span>    <span class="number">46</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">29</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">00002000</span></span><br><span class="line">       <span class="number">000000000000028f</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br><span class="line"></span><br><span class="line">There are no section groups in <span class="keyword">this</span> file.</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           <span class="number">0x0000000000000040</span> <span class="number">0x0000000000400040</span> <span class="number">0x0000000000400040</span></span><br><span class="line">                 <span class="number">0x00000000000001f8</span> <span class="number">0x00000000000001f8</span>  R E    <span class="number">8</span></span><br><span class="line">  INTERP         <span class="number">0x0000000000000238</span> <span class="number">0x0000000000400238</span> <span class="number">0x0000000000400238</span></span><br><span class="line">                 <span class="number">0x000000000000001c</span> <span class="number">0x000000000000001c</span>  R      <span class="number">1</span></span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>]</span><br><span class="line">  LOAD           <span class="number">0x0000000000000000</span> <span class="number">0x0000000000400000</span> <span class="number">0x0000000000400000</span></span><br><span class="line">                 <span class="number">0x0000000000000894</span> <span class="number">0x0000000000000894</span>  R E    <span class="number">200000</span></span><br><span class="line">  LOAD           <span class="number">0x0000000000000e10</span> <span class="number">0x0000000000600e10</span> <span class="number">0x0000000000600e10</span></span><br><span class="line">                 <span class="number">0x0000000000000250</span> <span class="number">0x0000000000000258</span>  RW     <span class="number">200000</span></span><br><span class="line">  DYNAMIC        <span class="number">0x0000000000000e28</span> <span class="number">0x0000000000600e28</span> <span class="number">0x0000000000600e28</span></span><br><span class="line">                 <span class="number">0x00000000000001d0</span> <span class="number">0x00000000000001d0</span>  RW     <span class="number">8</span></span><br><span class="line">  NOTE           <span class="number">0x0000000000000254</span> <span class="number">0x0000000000400254</span> <span class="number">0x0000000000400254</span></span><br><span class="line">                 <span class="number">0x0000000000000044</span> <span class="number">0x0000000000000044</span>  R      <span class="number">4</span></span><br><span class="line">  GNU_EH_FRAME   <span class="number">0x0000000000000744</span> <span class="number">0x0000000000400744</span> <span class="number">0x0000000000400744</span></span><br><span class="line">                 <span class="number">0x000000000000003c</span> <span class="number">0x000000000000003c</span>  R      <span class="number">4</span></span><br><span class="line">  GNU_STACK      <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span></span><br><span class="line">                 <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span>  RW     <span class="number">10</span></span><br><span class="line">  GNU_RELRO      <span class="number">0x0000000000000e10</span> <span class="number">0x0000000000600e10</span> <span class="number">0x0000000000600e10</span></span><br><span class="line">                 <span class="number">0x00000000000001f0</span> <span class="number">0x00000000000001f0</span>  R      <span class="number">1</span></span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   <span class="number">00</span>     </span><br><span class="line">   <span class="number">01</span>     .interp </span><br><span class="line">   <span class="number">02</span>     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   <span class="number">03</span>     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss </span><br><span class="line">   <span class="number">04</span>     .dynamic </span><br><span class="line">   <span class="number">05</span>     .note.ABI-tag .note.gnu.build-id </span><br><span class="line">   <span class="number">06</span>     .eh_frame_hdr </span><br><span class="line">   <span class="number">07</span>     </span><br><span class="line">   <span class="number">08</span>     .init_array .fini_array .jcr .dynamic .got </span><br><span class="line"></span><br><span class="line">Dynamic section at offset <span class="number">0xe28</span> contains <span class="number">24</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x0000000000000001</span> (NEEDED)             Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x000000000000000c</span> (INIT)               <span class="number">0x400488</span></span><br><span class="line"> <span class="number">0x000000000000000d</span> (FINI)               <span class="number">0x400724</span></span><br><span class="line"> <span class="number">0x0000000000000019</span> (INIT_ARRAY)         <span class="number">0x600e10</span></span><br><span class="line"> <span class="number">0x000000000000001b</span> (INIT_ARRAYSZ)       <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000001a</span> (FINI_ARRAY)         <span class="number">0x600e18</span></span><br><span class="line"> <span class="number">0x000000000000001c</span> (FINI_ARRAYSZ)       <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x000000006ffffef5</span> (GNU_HASH)           <span class="number">0x400298</span></span><br><span class="line"> <span class="number">0x0000000000000005</span> (STRTAB)             <span class="number">0x400360</span></span><br><span class="line"> <span class="number">0x0000000000000006</span> (SYMTAB)             <span class="number">0x4002b8</span></span><br><span class="line"> <span class="number">0x000000000000000a</span> (STRSZ)              <span class="number">82</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000000b</span> (SYMENT)             <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000015</span> (DEBUG)              <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x0000000000000003</span> (PLTGOT)             <span class="number">0x601000</span></span><br><span class="line"> <span class="number">0x0000000000000002</span> (PLTRELSZ)           <span class="number">144</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000014</span> (PLTREL)             RELA</span><br><span class="line"> <span class="number">0x0000000000000017</span> (JMPREL)             <span class="number">0x4003f8</span></span><br><span class="line"> <span class="number">0x0000000000000007</span> (RELA)               <span class="number">0x4003e0</span></span><br><span class="line"> <span class="number">0x0000000000000008</span> (RELASZ)             <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000009</span> (RELAENT)            <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x000000006ffffffe</span> (VERNEED)            <span class="number">0x4003c0</span></span><br><span class="line"> <span class="number">0x000000006fffffff</span> (VERNEEDNUM)         <span class="number">1</span></span><br><span class="line"> <span class="number">0x000000006ffffff0</span> (VERSYM)             <span class="number">0x4003b2</span></span><br><span class="line"> <span class="number">0x0000000000000000</span> (<span class="literal">NULL</span>)               <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">Relocation section '.rela.dyn' at offset 0x3e0 contains 1 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line"><span class="number">000000600f</span>f8  <span class="number">000400000006</span> R_X86_64_GLOB_DAT <span class="number">0000000000000000</span> __gmon_start__ + <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Relocation section '.rela.plt' at offset 0x3f8 contains 6 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line"><span class="number">000000601018</span>  <span class="number">000100000007</span> R_X86_64_JUMP_SLO <span class="number">0000000000000000</span> <span class="built_in">free</span> + <span class="number">0</span></span><br><span class="line"><span class="number">000000601020</span>  <span class="number">000200000007</span> R_X86_64_JUMP_SLO <span class="number">0000000000000000</span> <span class="built_in">printf</span> + <span class="number">0</span></span><br><span class="line"><span class="number">000000601028</span>  <span class="number">000300000007</span> R_X86_64_JUMP_SLO <span class="number">0000000000000000</span> __libc_start_main + <span class="number">0</span></span><br><span class="line"><span class="number">000000601030</span>  <span class="number">000400000007</span> R_X86_64_JUMP_SLO <span class="number">0000000000000000</span> __gmon_start__ + <span class="number">0</span></span><br><span class="line"><span class="number">000000601038</span>  <span class="number">000500000007</span> R_X86_64_JUMP_SLO <span class="number">0000000000000000</span> <span class="built_in">malloc</span> + <span class="number">0</span></span><br><span class="line"><span class="number">000000601040</span>  <span class="number">000600000007</span> R_X86_64_JUMP_SLO <span class="number">0000000000000000</span> setuid + <span class="number">0</span></span><br><span class="line"></span><br><span class="line">The decoding of unwind sections <span class="keyword">for</span> machine type Advanced Micro Devices X86<span class="number">-64</span> is <span class="keyword">not</span> currently supported.</span><br><span class="line"></span><br><span class="line">Symbol table '.dynsym' contains 7 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND <span class="built_in">free</span>@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND <span class="built_in">printf</span>@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND <span class="built_in">malloc</span>@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND setuid@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Symbol table '.symtab' contains 72 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000400238</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> </span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000400254</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">2</span> </span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000400274</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">3</span> </span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000400298</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">4</span> </span><br><span class="line">     <span class="number">5</span>: <span class="number">00000000004002b</span>8     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span> </span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000400360</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">6</span> </span><br><span class="line">     <span class="number">7</span>: <span class="number">00000000004003b</span>2     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">7</span> </span><br><span class="line">     <span class="number">8</span>: <span class="number">00000000004003</span>c0     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">8</span> </span><br><span class="line">     <span class="number">9</span>: <span class="number">00000000004003e0</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">9</span> </span><br><span class="line">    <span class="number">10</span>: <span class="number">00000000004003f</span>8     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">10</span> </span><br><span class="line">    <span class="number">11</span>: <span class="number">0000000000400488</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">11</span> </span><br><span class="line">    <span class="number">12</span>: <span class="number">00000000004004b</span>0     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">12</span> </span><br><span class="line">    <span class="number">13</span>: <span class="number">0000000000400520</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">13</span> </span><br><span class="line">    <span class="number">14</span>: <span class="number">0000000000400724</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">14</span> </span><br><span class="line">    <span class="number">15</span>: <span class="number">0000000000400730</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">15</span> </span><br><span class="line">    <span class="number">16</span>: <span class="number">0000000000400744</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">16</span> </span><br><span class="line">    <span class="number">17</span>: <span class="number">0000000000400780</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">17</span> </span><br><span class="line">    <span class="number">18</span>: <span class="number">0000000000600e10</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">18</span> </span><br><span class="line">    <span class="number">19</span>: <span class="number">0000000000600e18</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">19</span> </span><br><span class="line">    <span class="number">20</span>: <span class="number">0000000000600e20</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">20</span> </span><br><span class="line">    <span class="number">21</span>: <span class="number">0000000000600e28</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">21</span> </span><br><span class="line">    <span class="number">22</span>: <span class="number">0000000000600f</span>f8     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">22</span> </span><br><span class="line">    <span class="number">23</span>: <span class="number">0000000000601000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">23</span> </span><br><span class="line">    <span class="number">24</span>: <span class="number">0000000000601048</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">24</span> </span><br><span class="line">    <span class="number">25</span>: <span class="number">0000000000601060</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">25</span> </span><br><span class="line">    <span class="number">26</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">26</span> </span><br><span class="line">    <span class="number">27</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    <span class="number">28</span>: <span class="number">0000000000600e20</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">20</span> __JCR_LIST__</span><br><span class="line">    <span class="number">29</span>: <span class="number">0000000000400550</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">13</span> deregister_tm_clones</span><br><span class="line">    <span class="number">30</span>: <span class="number">0000000000400580</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">13</span> register_tm_clones</span><br><span class="line">    <span class="number">31</span>: <span class="number">00000000004005</span>c0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">13</span> __do_global_dtors_aux</span><br><span class="line">    <span class="number">32</span>: <span class="number">0000000000601060</span>     <span class="number">1</span> OBJECT  LOCAL  DEFAULT   <span class="number">25</span> completed<span class="number">.6982</span></span><br><span class="line">    <span class="number">33</span>: <span class="number">0000000000600e18</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">19</span> __do_global_dtors_aux_fin</span><br><span class="line">    <span class="number">34</span>: <span class="number">00000000004005e0</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">13</span> frame_dummy</span><br><span class="line">    <span class="number">35</span>: <span class="number">0000000000600e10</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">18</span> __frame_dummy_init_array_</span><br><span class="line">    <span class="number">36</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS main.cpp</span><br><span class="line">    <span class="number">37</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS func.cpp</span><br><span class="line">    <span class="number">38</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    <span class="number">39</span>: <span class="number">0000000000400890</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">17</span> __FRAME_END__</span><br><span class="line">    <span class="number">40</span>: <span class="number">0000000000600e20</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">20</span> __JCR_END__</span><br><span class="line">    <span class="number">41</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS </span><br><span class="line">    <span class="number">42</span>: <span class="number">0000000000600e18</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT   <span class="number">18</span> __init_array_end</span><br><span class="line">    <span class="number">43</span>: <span class="number">0000000000600e28</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">21</span> _DYNAMIC</span><br><span class="line">    <span class="number">44</span>: <span class="number">0000000000600e10</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT   <span class="number">18</span> __init_array_start</span><br><span class="line">    <span class="number">45</span>: <span class="number">0000000000601000</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">23</span> _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    <span class="number">46</span>: <span class="number">0000000000400720</span>     <span class="number">2</span> FUNC    GLOBAL DEFAULT   <span class="number">13</span> __libc_csu_fini</span><br><span class="line">    <span class="number">47</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND <span class="built_in">free</span>@@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">    <span class="number">48</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab</span><br><span class="line">    <span class="number">49</span>: <span class="number">0000000000601048</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT   <span class="number">24</span> data_start</span><br><span class="line">    <span class="number">50</span>: <span class="number">000000000040068</span>e    <span class="number">29</span> FUNC    GLOBAL DEFAULT   <span class="number">13</span> _Z5funcci</span><br><span class="line">    <span class="number">51</span>: <span class="number">0000000000601060</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">24</span> _edata</span><br><span class="line">    <span class="number">52</span>: <span class="number">0000000000400724</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT   <span class="number">14</span> _fini</span><br><span class="line">    <span class="number">53</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND <span class="built_in">printf</span>@@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">    <span class="number">54</span>: <span class="number">0000000000601058</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">24</span> g_n</span><br><span class="line">    <span class="number">55</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_</span><br><span class="line">    <span class="number">56</span>: <span class="number">0000000000601048</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">24</span> __data_start</span><br><span class="line">    <span class="number">57</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">    <span class="number">58</span>: <span class="number">0000000000601050</span>     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">24</span> __dso_handle</span><br><span class="line">    <span class="number">59</span>: <span class="number">0000000000400730</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">15</span> _IO_stdin_used</span><br><span class="line">    <span class="number">60</span>: <span class="number">00000000004006b</span>0   <span class="number">101</span> FUNC    GLOBAL DEFAULT   <span class="number">13</span> __libc_csu_init</span><br><span class="line">    <span class="number">61</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND <span class="built_in">malloc</span>@@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">    <span class="number">62</span>: <span class="number">0000000000601068</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">25</span> _end</span><br><span class="line">    <span class="number">63</span>: <span class="number">0000000000400520</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT   <span class="number">13</span> _start</span><br><span class="line">    <span class="number">64</span>: <span class="number">0000000000601060</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">25</span> __bss_start</span><br><span class="line">    <span class="number">65</span>: <span class="number">000000000040060</span>d   <span class="number">129</span> FUNC    GLOBAL DEFAULT   <span class="number">13</span> main</span><br><span class="line">    <span class="number">66</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses</span><br><span class="line">    <span class="number">67</span>: <span class="number">000000000060105</span>c     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">24</span> g_m</span><br><span class="line">    <span class="number">68</span>: <span class="number">0000000000601060</span>     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">24</span> __TMC_END__</span><br><span class="line">    <span class="number">69</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable</span><br><span class="line">    <span class="number">70</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND setuid@@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">    <span class="number">71</span>: <span class="number">0000000000400488</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT   <span class="number">11</span> _init</span><br><span class="line"></span><br><span class="line">Version symbols section '.gnu.version' contains 7 entries:</span><br><span class="line"> Addr: <span class="number">00000000004003b</span>2  Offset: <span class="number">0x0003b2</span>  Link: <span class="number">5</span> (.dynsym)</span><br><span class="line">  <span class="number">000</span>:   <span class="number">0</span> (*local*)       <span class="number">2</span> (GLIBC_2<span class="number">.2</span><span class="number">.5</span>)   <span class="number">2</span> (GLIBC_2<span class="number">.2</span><span class="number">.5</span>)   <span class="number">2</span> (GLIBC_2<span class="number">.2</span><span class="number">.5</span>)</span><br><span class="line">  <span class="number">004</span>:   <span class="number">0</span> (*local*)       <span class="number">2</span> (GLIBC_2<span class="number">.2</span><span class="number">.5</span>)   <span class="number">2</span> (GLIBC_2<span class="number">.2</span><span class="number">.5</span>)</span><br><span class="line"></span><br><span class="line">Version needs section '.gnu.version_r' contains 1 entries:</span><br><span class="line"> Addr: <span class="number">0x00000000004003c0</span>  Offset: <span class="number">0x0003c0</span>  Link: <span class="number">6</span> (.dynstr)</span><br><span class="line">  <span class="number">000000</span>: Version: <span class="number">1</span>  File: libc.so<span class="number">.6</span>  Cnt: <span class="number">1</span></span><br><span class="line">  <span class="number">0x0010</span>:   Name: GLIBC_2<span class="number">.2</span><span class="number">.5</span>  Flags: none  Version: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Displaying notes found at file offset <span class="number">0x00000254</span> with length <span class="number">0x00000020</span>:</span><br><span class="line">  Owner                 Data size	Description</span><br><span class="line">  GNU                  <span class="number">0x00000010</span>	NT_GNU_ABI_TAG (ABI version tag)</span><br><span class="line">    OS: Linux, ABI: <span class="number">2.6</span><span class="number">.24</span></span><br><span class="line"></span><br><span class="line">Displaying notes found at file offset <span class="number">0x00000274</span> with length <span class="number">0x00000024</span>:</span><br><span class="line">  Owner                 Data size	Description</span><br><span class="line">  GNU                  <span class="number">0x00000014</span>	NT_GNU_BUILD_ID (unique build ID bitstring)</span><br><span class="line">    Build ID: <span class="number">2110927</span>a3d6ecf4dd0f70085d18bc49c3b61ba41</span><br></pre></td></tr></table></figure></p>
<h4 id="接着来追踪下程序的运行："><a href="#接着来追踪下程序的运行：" class="headerlink" title="接着来追踪下程序的运行："></a>接着来追踪下程序的运行：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> ./main </span><br><span class="line">hello2  a61010</span><br><span class="line">think@think-VirtualBox:~/c++/testld$ strace ./main </span><br><span class="line">execve(<span class="string">"./main"</span>, [<span class="string">"./main"</span>], [<span class="comment">/* 74 vars */</span>]) = <span class="number">0</span></span><br><span class="line">brk(<span class="number">0</span>)                                  = <span class="number">0x9ba000</span></span><br><span class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = <span class="number">-1</span> ENOENT (No such file <span class="keyword">or</span> directory)</span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fc78575f000</span></span><br><span class="line">access(<span class="string">"/etc/ld.so.preload"</span>, R_OK)      = <span class="number">-1</span> ENOENT (No such file <span class="keyword">or</span> directory)</span><br><span class="line">open(<span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">86757</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">86757</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x7fc785749000</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = <span class="number">-1</span> ENOENT (No such file <span class="keyword">or</span> directory)</span><br><span class="line">open(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">"\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P \2\0\0\0\0\0"</span>..., <span class="number">832</span>) = <span class="number">832</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">1840928</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">3949248</span>, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x7fc78517a000</span></span><br><span class="line">mprotect(<span class="number">0x7fc785334000</span>, <span class="number">2097152</span>, PROT_NONE) = <span class="number">0</span></span><br><span class="line">mmap(<span class="number">0x7fc785534000</span>, <span class="number">24576</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0x1ba000</span>) = <span class="number">0x7fc785534000</span></span><br><span class="line">mmap(<span class="number">0x7fc78553a000</span>, <span class="number">17088</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fc78553a000</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fc785748000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fc785746000</span></span><br><span class="line">arch_prctl(ARCH_SET_FS, <span class="number">0x7fc785746740</span>) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x7fc785534000</span>, <span class="number">16384</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x600000</span>, <span class="number">4096</span>, PROT_READ)     = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x7fc785761000</span>, <span class="number">4096</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x7fc785749000</span>, <span class="number">86757</span>)           = <span class="number">0</span></span><br><span class="line">fstat(<span class="number">1</span>, &#123;st_mode=S_IFCHR|<span class="number">0620</span>, st_rdev=makedev(<span class="number">136</span>, <span class="number">4</span>), ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fc78575e000</span></span><br><span class="line">setuid(<span class="number">234323</span>)                          = <span class="number">-1</span> EPERM (Operation <span class="keyword">not</span> permitted)</span><br><span class="line">brk(<span class="number">0</span>)                                  = <span class="number">0x9ba000</span></span><br><span class="line">brk(<span class="number">0x9db000</span>)                           = <span class="number">0x9db000</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">"hello2  9ba010\n"</span>, <span class="number">15</span>hello2  <span class="number">9b</span>a010</span><br><span class="line">)        = <span class="number">15</span></span><br><span class="line">exit_group(<span class="number">0</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br></pre></td></tr></table></figure>
<p>其实这里比较好的方式是gdb,单步调试，这个有兴趣再做吧；<br>运行的时候，是执行execve系列函数，将可执行文件加载后，转换为进程运行，这个时候，做的事情很多，需要创建新进程，需要将可执行文件映射到进程对应的内存区，并建立各个vma区域，对依赖的符号做库加载和映射，然后进程实例结构建立好后，根据进程需要的资源和当前运行状态，加入对应的进程相关队列，等待执行；</p>
<ul>
<li>至此，一个程序，从源文件，到可执行文件，到链接，转换为进程，运行结束，一个周期完结；</li>
</ul>
<h3 id="具体解释：预处理"><a href="#具体解释：预处理" class="headerlink" title="具体解释：预处理"></a>具体解释：预处理</h3><p>1) 预处理阶段<br>c/c++是编译类型的语言，即c/c++源文件，是比较符合人类语言的文本文件，需要将这个文件翻译为机器能直接执行的可执行文件，这个翻译成可执行文件的过程，就是编译的过程；<br>程序在编译的过程中，需要经过几个阶段，第一个阶段是预处理阶段：<br>在正式的编译阶段之前进行。预处理阶段将根据已放置在文件中的预处理指令来修改源文件的内容。<br>如#include指令就是一个预处理指令，它把头文件的内容添加到.cpp文件中。<br>预处理指令，不是真正的程序语句，而是给预处理器的命令；<br>2) 预处理的指令：<br>预处理指令不止于#include,还有：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span></span></span><br><span class="line"><span class="meta">#end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span></span></span><br><span class="line">一些已定义好的宏：</span><br><span class="line">__LINE__	整数值，表示当前正在编译的行在源文件中的行数。</span><br><span class="line">__FILE__	字符串，表示被编译的源文件的文件名。</span><br><span class="line">__DATE__	一个格式为 <span class="string">"Mmm dd yyyy"</span> 的字符串，存储编译开始的日期。</span><br><span class="line">__TIME__	一个格式为 <span class="string">"hh:mm:ss"</span> 的字符串，存储编译开始的时间。</span><br><span class="line">__cplusplus	整数值，所有C++编译器都定义了这个常量为某个值。如果这个编译器是完全遵守C++标准的，它的值应该等于或大于<span class="number">199711L</span>，具体值取决于它遵守的是哪个版本的标准。</span><br><span class="line">ref: 见手册；</span><br></pre></td></tr></table></figure></p>
<p>预处理阶段，是预处理器对预处理指令的解析，并将解析后的内容输出出来或者到下个阶段的输入；<br>实践：<br>3) 例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">gcc -E test.c -o test.i 或 gcc -E test.c  或用cpp</span><br><span class="line">将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件：</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">"simplest.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"simplest.c"</span></span><br><span class="line">stdio.h的内容在这里铺开;</span><br><span class="line">包含了各种函数的声明；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他c/cpp文件也是一样，但是一个程序(进程)只能有一个main函数<br>PS:关于g++和gcc的不同： g++ 比gcc 多了一些库的链接功能，当使用了c++的标准库的时候，必须用g++;</p>
<p>4) 说明：<br>预处理中的#include指令，在编译器处理后，会将对应的头文件展开，这样，其中的函数声明就能展开在引用头文件的源码文件中，当之后编译程序时，用到的符号，<br>声明就能被找到；</p>
<h3 id="具体解释：编译"><a href="#具体解释：编译" class="headerlink" title="具体解释：编译"></a>具体解释：编译</h3><h4 id="编译阶段概述："><a href="#编译阶段概述：" class="headerlink" title="编译阶段概述："></a>编译阶段概述：</h4><p>这个阶段，编译器会把每个实现文件，结合头文件编译成中间文件(其实编译过程是不需要头文件的，原因是一些文件中会引用头文件中的函数等符号，所以需要，而也可以引用.c文件，但是会出现重复定义，而声明是可以重复)，一般是一个二进制.o文件，并进行相关的编译器优化，即将一些语句顺序进行调节等；<br>先把源文件翻译成汇编文件，再通过汇编器将汇编文件翻译为二进制文件；</p>
<h4 id="一个例子："><a href="#一个例子：" class="headerlink" title="一个例子："></a>一个例子：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gcc -S hh.cpp<br>生成hh.s:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	.file	<span class="string">"hh.cpp"</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	_Z1mv</span><br><span class="line">	.type	_Z1mv, @function</span><br><span class="line">_Z1mv:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">	movl	$<span class="number">3</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">	movl	<span class="number">-4</span>(%rbp), %eax</span><br><span class="line">	popq	%rbp</span><br><span class="line">	.cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	_Z1mv, .-_Z1mv</span><br><span class="line">	.ident	<span class="string">"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4"</span></span><br><span class="line">	.section	.note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure>
<p>暂时不解析</p>
<h4 id="编译时不需要依赖的调用的实现"><a href="#编译时不需要依赖的调用的实现" class="headerlink" title="编译时不需要依赖的调用的实现"></a>编译时不需要依赖的调用的实现</h4><p>编译期间，都是用的-c生成各种.o文件，进而是静态库或动态库，或者单纯的有main函数的中间文件；<br>这个时候不需要在编译时提供依赖的实现文件，比如依赖的函数实现文件，只需要头文件即可生成；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">dep.h:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">def</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">hello.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dep.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    def();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello.h</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br>gcc -c hello.cpp</p>
<p>gcc -c main.cpp</p>
<p>生成可执行时才需要链接：这个时候需要所有的实现接口对应点的实现文件：或以库的形式，或以动态库的形式，或者实现文件.o/.cpp<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">keshixing@ubuntu:~/testld$ g++ -o main main.cpp hello.o</span><br><span class="line">/usr/bin/ld: hello.o: in function `hello()<span class="string">':</span></span><br><span class="line">hello.cpp:(.text+0x9): undefined reference to `def()'</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure></p>
<p>这里没有实现def()所以报错了；</p>
<p>编译过程中汇编器将汇编文件翻译为.o中间文件，这里汇编器其实已经包含到gcc中了，也可以自己下载一个特定平台的比如：NASM<br>输出可执行程序时，必须实现入口函数，比如main;<br>gcc -o main main.s</p>
<h4 id="编译过程总结："><a href="#编译过程总结：" class="headerlink" title="编译过程总结："></a>编译过程总结：</h4><p>关于编译过程涉及如何将源程序转换为汇编程序，主要是编译器的部分工作，具体是词法分析，语法分析等，有著名的lex,yacc工具，也有<br>对应的状态机等逻辑，内容很多，有兴趣可以看编译原理 龙书；</p>
<p>这里，记录下：对编译后的程序单元，得到的是什么：是一种elf格式的文件，对linux来说；<br>elf文件，有以下几种类型：<br>可重定位文件： relocatable file .o文件<br>可执行文件：executable file<br>共享目标文件：shared object file ，通常是so动态库<br>dump文件： core-dump file </p>
<p>所以编译的结果，是生成第一种elf目标文件；<br>而主要的内容：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> elf格式头</span><br><span class="line"><span class="number">2</span> elf格式的各个段</span><br><span class="line"><span class="number">3</span> elf各个段的内容，比如代码段，里面包括了编译后的代码等；</span><br><span class="line"><span class="number">4</span> 符号表；</span><br><span class="line"><span class="number">5</span> 。。。</span><br><span class="line"></span><br><span class="line">其中最重要的，就是代码段和数据段，符号表等；</span><br><span class="line">代码段，展示了这个目标文件的功能了流程，数据段，表示了存放的全局数据等，符号表，展示了这个目标文件提供了哪些可以被外部使用的符号，以及</span><br><span class="line">依赖的哪些符号；以便链接使用</span><br></pre></td></tr></table></figure></p>
<h3 id="具体解释：链接"><a href="#具体解释：链接" class="headerlink" title="具体解释：链接"></a>具体解释：链接</h3><h4 id="基本概述："><a href="#基本概述：" class="headerlink" title="基本概述："></a>基本概述：</h4><ul>
<li>链接的来源：<br>写一个程序，需要定义各种函数，当只有一个源文件，编译为一个可执行程序时，这个时候，调用函数的地方直接填上函数的地址，看起来没什么问题；<br>但是当调整函数的定义时，不考虑其他因素，则函数的基地址在代码段中的位置，又会发生变化，这个时候，调用的位置有需要修改，这个是一个繁琐的工作；</li>
</ul>
<p>于是这里提供了符号的方式，调用函数的地方，转换为符号，根据符号寻找对应的地址，这样，即使修改函数，也不用改调用的地方；</p>
<p>当程序越来越大，拆分为多个目标文件模块，这个时候，对外部符号的链接 ，有两种形式：<br>一种是在产生可执行程序，链接时，将外部符号对应的定义模块，结合<br>到调用的文件中，程序通过符号表和重定位等，转换为正确的地址；程序包含符号对应函数的定义，执行时可以直接运行，不依赖外部库；<br>这种形式是静态链接</p>
<p>另一种形式，在链接时，并不是将实现的代码结合进去，只是带符号，而在运行时，依赖对应的系统上的动态库；执行时再根据调用的符号，到对应<br>的系统上寻找动态库，加载到内存中，来执行；</p>
<ul>
<li>链接的进一步解释和相关命令：<br>关于编译时的链接：<br>我们在编译一个完整的程序时，除了指定含有main函数的程序文件外，这个文件还可能依赖定义在其他源程序中的函数，这个时候，编译时需要指定如：<br>gcc -o main main.cpp func.cpp …<br>有时候这些源文件以编译好的.o的形式呈现，也可以进行：gcc -o main main.cpp func.o<br>而当许多.o需要指定比较麻烦，所以库出现了，用来将.o文件汇总，分为两种形式，一种是静态库，一种是动态库；<br>静态库，就是在编译时将文件的执行代码都聚合到可执行文件中，包括调用的功能函数等，执行时不需要额外的库支持；编译出来的可执行文件会比较大；<br>动态库，即在编译时只是将调用的函数符号指定到符号表中，在执行时才去系统默认库路径(头文件指定的)寻找库,并链接该函数执行；</li>
</ul>
<p>静态链接：在编译时，要指定链接的静态库，包括位置等；<br>eg:<br>gcc -o main main.cpp func.a /home/zhangsan/lib/funall.a local/local.a<br>动态链接：编译时，需要指定链接的动态库，包括位置等；默认会找默认位置的动态库<br>gcc -o main main.cpp -L./xxx   -lcurl -lpthread<br>-L./xx 为指定了目录下有动态链接库，也可以链接成功；<br>注意形式为：libxxx.so 链接为 -lxxx<br>在运行的时候：<br>ldd a.out这种可以得到可执行文件希望在哪里找到库；而一般要设置export LD_LIBRARY_PATH=/home/think/c++/ 或者放在<br>系统默认搜索路径下，或者修改系统文件/etc/ld.so.conf，添加路径，运行ldconfig命令<br>默认搜索路径：<br>/lib<br>/usr/lib<br>/usr/local/lib </p>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>静态链接用到的技术：</p>
<ul>
<li><p>如何将模块.o文件合并到输出的可执行文件：地址和空间分配<br>需要考虑字节对齐等，每个模块文件的格式都是类似，有各个对应的段，这样可以将相似的段进行合并；<br>比如.text -&gt;.text</p>
</li>
<li><p>符号解析和重定位：<br>在将段合并后，各个符号对应的函数等(相对位置)已经确定了，这样可以进行符号解析，调整代码中的地址等；<br>1) 可以通过objdump -h xx.o 和可执行文件的对比，看到text段等段的相对偏移位置已经确定了；<br>2) 可以通过objdump -d xx.o 和objdump -d xxmain来对比链接前后，对外部符号如全局变量和函数的汇编语句中的地址数值，是不是<br>从0-&gt;真正的位置；<br>在elf文件中，有个 结构叫重定位表（relocation table),具体见elf格式解析，专门存放和重定位相关的信息；<br>.rel.xxx<br>3) 链接器会在链接时，去重定位表中找到对应符号的地址，然后进行符号解析，将符号改为正在的相对地址；</p>
</li>
<li><p>相关命令：<br>1）链接的符号查看： nm xxx.o可以看到提供的符号和依赖的符号；<br>2） ld main.o func.o -e main -o abc -lc<br>3) ar -t libc.a 查看a文件中有哪些o文件；<br>4） gcc -static  –verbose -fno-builtin xx.c 输出详细信息，编译时；</p>
</li>
<li><p>链接过程控制–链接脚本：<br>链接器提供了多种控制整个链接过程的方法：<br>1) 提供命令行来给链接器指定参数；<br>2) 将链接指令存放在目标文件中；比如vc中经常使用<br>3) 使用链接脚本：在使用ld时，使用ld -T xxx.script</p>
</li>
</ul>
<p>一个例子说明链接脚本是做什么的：<br><a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html" target="_blank" rel="noopener">https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html</a></p>
<h3 id="具体解释：装载和动态链接"><a href="#具体解释：装载和动态链接" class="headerlink" title="具体解释：装载和动态链接"></a>具体解释：装载和动态链接</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>进程和程序有什么不同？</p>
<h4 id="进程的虚拟地址空间"><a href="#进程的虚拟地址空间" class="headerlink" title="进程的虚拟地址空间"></a>进程的虚拟地址空间</h4><h4 id="程序装载是什么，装载有什么方式？"><a href="#程序装载是什么，装载有什么方式？" class="headerlink" title="程序装载是什么，装载有什么方式？"></a>程序装载是什么，装载有什么方式？</h4><p>装载其实，就是将磁盘中的程序文件，按一定的格式，载入到内存中；这其中会用到页映射等操作系统对文件和内存管理的部分功能；<br>装载，只是程序转换为进程的其中一个步骤，一个程序，如何转换为一个进程？<br>1) 通过execvl系列函数，建立进程；创建一个独立的虚拟地址空间；<br>2) 读取可执行文件，将可执行文件映射到进程虚拟地址空间中，并建立各个段-vma 区域，一个vma由多个段组成；<br>3) 当调度器调度到此进程，将cpu指令寄存器设置为进程中可执行段的入口，启动运行<br>这之后，其实可执行程序并未全部都载入到内存中，在执行过程中，会出现缺页错误，然后操作系统进行处理，但是用户无感知；</p>
<h4 id="动态链接："><a href="#动态链接：" class="headerlink" title="动态链接："></a>动态链接：</h4><ul>
<li>为什么要动态链接：<br>如果用静态链接，可执行程序过大，副本多，占用磁盘大，不好传输，模块更新困难等等；<br>动态链接，是在执行程序的过程中发生的：具体来讲，发生在装载的时候；</li>
<li>动态链接如何实现？<br>在linux中，elf动态链接文件叫共享对象 dynamic shared obj<br>动态链接的程序，在程序被装载时，系统的动态链接器会将程序需要的所有动态链接库装载到进程的地址空间，并将所有未决议的符号<br>绑定到相应的动态链接库中，并进行重定位； 注意动态链接器和静态链接器不同；</li>
</ul>
<p>动态链接，会将链接和重定位的工作放到了运行时，这样会导致程序性能下降，但动态链接器也做了一些优化，比如延迟绑定等；</p>
<ul>
<li><p>如何生成动态库：<br>gcc -fPIC -shared -o xx.so xx.c</p>
</li>
<li><p>运行时查看进程的各个段映射：<br>cat /proc/pid/maps</p>
</li>
</ul>
<ul>
<li>动态链接库中的代码可以被多个程序共享，由此带来重定位的问题：<br>1) 原因：<br>动态库被装载时，共享对象，如何确定它在进程虚拟地址空间中的位置？ 装载时重定位，即类似静态链接，在模块装载地址确定时，系统对<br>程序中所有的绝对地址引用进行重定位。但是这个对不同进程来说，会产生不同的地址；所以同一份指令在被多个进程共享时会出现问题。无法做到共享省内存<br>的目的；这种方法其实就是-shared;</li>
</ul>
<p>2) 进阶：使用-fPIC: 地址无关代码： position-independent-code<br>可以解决以上办法，但是只能有部分可以达到目的：部分指令在多个进程间是无法共享的，所以需要将这部分抽离处理和数据段放在一起；<br>对数据，函数引用来说有以下四种，只有两种可以：<br>(1) 模块内部的函数调用，跳转  相对位置固定，不需要重定位<br>(2) 模块内部的数据访问，比如模块中定义的全局变量，静态变量 相对位置固定，不需要重定位<br>(3) 模块外部函数的调用，跳转   依赖外部符号，需要将其放到数据段，使用全局偏移表 GOT<br>(4) 模块外的数据访问，比如用到了其他模块中定义的全局变量；需要用GOT表<br>使用-fPIC就是用来产生地址无关代码的</p>
<ul>
<li>延迟绑定</li>
</ul>
<ul>
<li>动态链接相关结构：<br>1）.interp段<br>2) .dynamic段<br>3) 动态链接符号表等；<br>4）动态链接重定位表</li>
</ul>
<h3 id="关于编译，链接形成的目标文件；"><a href="#关于编译，链接形成的目标文件；" class="headerlink" title="关于编译，链接形成的目标文件；"></a>关于编译，链接形成的目标文件；</h3><h4 id="关于目标文件："><a href="#关于目标文件：" class="headerlink" title="关于目标文件："></a>关于目标文件：</h4><p>在编译时除了可以生成可执行文件，还可以生产静态库，动态库，中间文件，汇编文件等，这里看静态库和动态库的生成规则<br>生成静态库文件：<br>ar rvs libfunc.a func.o func2.o<br>man ar 查看更多<br>生成动态库文件:<br>gcc func.cpp  -fPIC -shared -o libfunc.so<br>-shared 该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接<br>Produce a shared object which can then be linked with other objects to form an executable.  Not all systems support this option.  For predictable results, you must also specify the same</p>
<p>-fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。<br>更多见man gcc<br>5) 总：<br>一个完整的gcc/g++编译命令，除了指定上面的内容，还需要指定头文件的位置，默认目录有哪些？，优化选项，-c/-o/-S/-E其他选项等，这里把这些汇总下，并给上参考地址方便查阅；man gcc<br>-c:  -c  Compile or assemble the source files, but do not link.  The linking stage simply is not done.  The ultimate output is in the form of an object file for each source file.<br>-I: 指定头文件的路径<br>gcc -I. -I /home/include/ ..<br>指定了头文件路径后，在#include时可以省略路径；</p>
<h4 id="elf格式"><a href="#elf格式" class="headerlink" title="elf格式"></a>elf格式</h4><p>/usr/include/elf.h中包含了elf文件结构的各个字段格式；<br><a href="https://refspecs.linuxfoundation.org/elf/elf.pdf" target="_blank" rel="noopener">https://refspecs.linuxfoundation.org/elf/elf.pdf</a><br>或者书籍： 程序员的自我修养等可以查阅到具体信息；</p>
<h3 id="关于入口函数和运行时库CRT："><a href="#关于入口函数和运行时库CRT：" class="headerlink" title="关于入口函数和运行时库CRT："></a>关于入口函数和运行时库CRT：</h3><p>入口函数不一定是main，在main调用之前，为了程序能顺利运行，需要初始化程序的执行环节，如堆分配初始化等，以及c++中的<br>全局对象构造函数，都在main之前执行，而全局对象的析构函数在main之后被执行；<br>这个依赖于elf中的两种特殊的段： .init .finit<br>所以在链接后，程序最开始运行的，不是main，而是.init中指定的入口函数，它可能包括各种初始化，如运行时库的入口函数，c++全局对象的构造函数，等等；</p>
<ul>
<li>运行时库：<br>一个c运行时库大概包括如下功能：<br>1) 启动和退出，包括入口函数及其依赖<br>2) 标准库函数集合<br>3) IO的封装<br>4) 堆的分配等封装<br>5) 语言中一些特殊功能实现<br>6) 调试功能；</li>
</ul>
<p>另外，链接脚本或参数也可以指定不是main作为主函数，而是用别的名字，如ld -e nomain</p>
<h3 id="关键词："><a href="#关键词：" class="headerlink" title="关键词："></a>关键词：</h3><p>ABI： 指的是不同的cpu架构，操作系统，编译器类型甚至版本带来的目标文件差异；<br>BFD库： 为了解决多种cpu，大小端下，可执行程序兼容性问题，提供了统一的格式；</p>
<h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><h5 id="c-c-的反汇编，二进制查看，可执行文件格式等；"><a href="#c-c-的反汇编，二进制查看，可执行文件格式等；" class="headerlink" title="c/c++的反汇编，二进制查看，可执行文件格式等；"></a>c/c++的反汇编，二进制查看，可执行文件格式等；</h5><p>1) 可执行文件的结构：<br>think@think-VirtualBox:~/c++$ size hh.o<br>   text       data        bss        dec        hex    filename<br>     72          0          0         72         48    hh.o<br>代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量;还有就是代码本身的0101机器码<br>数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）<br>bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null</p>
<p>2）如何反汇编；<br>objdump 工具，除了可以反汇编，还可以查看二进制文件等：<br>objdump -s hh.o : 查看十六进制<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~/c++$ objdump -s  hh.o</span><br><span class="line"></span><br><span class="line">hh.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> <span class="number">0000</span> <span class="number">554889e5</span> c745fc03 <span class="number">0000008b</span> <span class="number">45f</span>c5dc3  UH...E......E.].</span><br><span class="line">Contents of section .comment:</span><br><span class="line"> <span class="number">0000</span> <span class="number">00474343</span> <span class="number">3</span>a202855 <span class="number">62756e74</span> <span class="number">7520342</span>e  .GCC: (Ubuntu <span class="number">4.</span></span><br><span class="line"> <span class="number">0010</span> <span class="number">382e342</span>d <span class="number">32756275</span> <span class="number">6e747531</span> <span class="number">7e31342</span>e  <span class="number">8.4</span><span class="number">-2u</span>buntu1~<span class="number">14.</span></span><br><span class="line"> <span class="number">0020</span> <span class="number">30342e34</span> <span class="number">2920342</span>e <span class="number">382e3400</span>           <span class="number">04.4</span>) <span class="number">4.8</span><span class="number">.4</span>.    </span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> <span class="number">0000</span> <span class="number">14000000</span> <span class="number">00000000</span> <span class="number">017</span>a5200 <span class="number">01781001</span>  .........zR..x..</span><br><span class="line"> <span class="number">0010</span> <span class="number">1b</span>0c0708 <span class="number">90010000</span> <span class="number">1</span>c000000 <span class="number">1</span>c000000  ................</span><br><span class="line"> <span class="number">0020</span> <span class="number">00000000</span> <span class="number">10000000</span> <span class="number">00410e10</span> <span class="number">8602430</span>d  .........A....C.</span><br><span class="line"> <span class="number">0030</span> <span class="number">064b</span>0c07 <span class="number">08000000</span>                    .K......</span><br></pre></td></tr></table></figure></p>
<p> objdump -d hh.o: 反汇编：</p>
<h3 id="运行时："><a href="#运行时：" class="headerlink" title="运行时："></a>运行时：</h3><h5 id="c-c-文件如何执行，动态链接如何进行；"><a href="#c-c-文件如何执行，动态链接如何进行；" class="headerlink" title="c/c++文件如何执行，动态链接如何进行；"></a>c/c++文件如何执行，动态链接如何进行；</h5><p>c/c++可执行文件如何执行呢？<br>可执行文件分为完整的非动态链接的可执行文件和完整的静态链接的可执行文件<br>1）静态链接：在./a.out的时候，会通过触发起一个execl系列函数，起一个进程，并开始执行，执行过程即会创建进程空间，内核管理，内核分时间片运行；<br>即作为一个进程来运行，而进程有自己的生命周期：就绪，运行，阻塞等等，也有各种进程上下文，当前的资源等等；<br>总的来讲： 生命周期，进程管理的私有结构，进程的动态空间：堆，栈，虚拟地址空间，各种阻塞队列等等；<br>2）动态链接：动态链接的可执行文件，需要搜索路径下有依赖的动态库，否则无法运行，在运行时会通过链接的符号等去寻找对应的动态库函数实现，加载调用运行；<br>之后的运行和静态链接基本一致；</p>
<h5 id="gdb基础和gdb常用，手册等；"><a href="#gdb基础和gdb常用，手册等；" class="headerlink" title="gdb基础和gdb常用，手册等；"></a>gdb基础和gdb常用，手册等；</h5><p>当编译时带上-g后即带debug信息，运行时即可以进行gdb 运行；<br>gdb main<br>gdb attach 挂的是线程还是进程？<br>见gdb文章</p>
<h4 id="c-程序执行过程调试例子，注意执行语句先后，编译器优化前后不同"><a href="#c-程序执行过程调试例子，注意执行语句先后，编译器优化前后不同" class="headerlink" title="c++程序执行过程调试例子，注意执行语句先后，编译器优化前后不同"></a>c++程序执行过程调试例子，注意执行语句先后，编译器优化前后不同</h4><h4 id="堆栈空间表现例子"><a href="#堆栈空间表现例子" class="headerlink" title="堆栈空间表现例子"></a>堆栈空间表现例子</h4><p>堆栈空间如何增长呢？<br>跟cpu系统有关，暂时不深究；要知道new/malloc是在堆上分配空间，普通定义数组，变量是在栈上分配空间；<br>struct class这种的，定义一个非指针变量，是放栈还是堆？</p>
<h4 id="多线程相关调试例子；"><a href="#多线程相关调试例子；" class="headerlink" title="多线程相关调试例子；"></a>多线程相关调试例子；</h4><p>1）查看多线程pid: top -Hp pid<br>2) 多线程是系统层面的，多线程的实现可以是用系统的接口，比如posix的pthread,fork进程等，或者用语言的thread ,这种最后也是调用的pthread系列函数；<br>这里默认都是unix系统；<br>3）使用linux系统工具调试多线程程序；</p>
<h4 id="linux-core-dump机制和相关工具"><a href="#linux-core-dump机制和相关工具" class="headerlink" title="linux core-dump机制和相关工具"></a>linux core-dump机制和相关工具</h4><p>1) core-dump是什么？<br>2）core-dump如何触发？</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>compilelink</tag>
      </tags>
  </entry>
  <entry>
    <title>live_media_audioformat</title>
    <url>/2021/02/17/live-media-audioformat/</url>
    <content><![CDATA[<h3 id="音频编码：-aac-adts-wav-mp3-等编码的意义和基本概念"><a href="#音频编码：-aac-adts-wav-mp3-等编码的意义和基本概念" class="headerlink" title="音频编码： aac, adts, wav ,mp3 等编码的意义和基本概念"></a>音频编码： aac, adts, wav ,mp3 等编码的意义和基本概念</h3><ul>
<li>原始音频： 采集后得到的是音频的裸数据：在采集时需要指定采样率，量化位数(一般采样也会有几种协议，比如常见的PCM，里面会自带量化位数指定)，channle数，以及必要的大小端数据等<a id="more"></a></li>
<li><p>音频的裸数据有以下特点，在用Audacity导入原始数据播放时，需要填写相关参数(采样率，量化协议，channel数，数据的大小端情况等)：<br>由此可以知道，在播放裸数据(解释)裸音频数据时，至少需要上面的几个参数；</p>
</li>
<li><p>音频编码在音频裸数据的基础上做了什么？可以用来干嘛?<br>那么对于音频编码来说，主要是在裸数据上做了封装，带了以下几件事：<br>1）加上音频编码的头：主要内容是采样率，channel数，量化协议，大小端等，用来告诉解码器如何解释这个音频；<br>2)  加上其他的元数据：比如音频编码本身的协议标志，版本号，等等<br>3)  带上裸数据，长度size等，有的音频编码会对裸数据进行合理的压缩，去噪等等，减少文件大小等，如opus；</p>
</li>
<li><p>常见的音频编码：AAC,OPUS,FLAC,MP3,SBC,Vorbis等，更多可以看wiki:<br><a href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83</a></p>
</li>
<li><p>如何查看音频编码：最直接的就是用notepad++ ,vim等二进制方式打开，然后对着协议标志看等；<br>或者根据文件名使用工具查看；用播放软件查看文件信息看编码格式；但是只能看元信息；</p>
</li>
<li><p>查看AAC:<br>AAC Audio ES Viewer </p>
<h3 id="音频编码文件容器："><a href="#音频编码文件容器：" class="headerlink" title="音频编码文件容器："></a>音频编码文件容器：</h3></li>
<li>音频为什么需要容器：<br>如果说编码主要是压缩和携带解析的元数据，那容器的出现，除了增加更多元数据信息外，还加了时间戳dts等信息，封装为容器，一个重要的因素是为了和视频封装在一起，音视频<br>做同步解码播放；</li>
<li>音频编码和容器的关系<br> 音频容器是在音频编码的基础上增加了一些信息，和编码格式不同，比如opus编码的容器格式是oggs，是在opus封装为一页一页，并且加了页头；<br> 大部分容器其实可以封装视频和音频；比如Oggs也可以封装视频，只是现在不流行；所以你看到的Oggs基本都是音频的；而纯音频容器：如wav,mp3等</li>
<li>音视频容器常见: flv，avi,mov,mp4,3gp等<h3 id="音频编码流媒体-比如aac是怎么在直播系统中传输的；"><a href="#音频编码流媒体-比如aac是怎么在直播系统中传输的；" class="headerlink" title="音频编码流媒体: 比如aac是怎么在直播系统中传输的；"></a>音频编码流媒体: 比如aac是怎么在直播系统中传输的；</h3>流媒体是在网络传输中流式媒体数据，在网络中传输音视频数据时，也是主要是压缩的数据，比如音频，在网络上传输以opus的流格式，其实可以是oggs封装再加到其他传输协议中；<br>或者是Opus直接封装到完善的协议比如Rtp中；<br>而流媒体考虑到带宽利用率等，往往不会传输太多多余的东西，所以一些头带了的信息就不会重复封装头；<br>总的理解就是： 流媒体传输中，使用适合于音视频传输的(比如专门做了网络优化)的网络协议如Srt,Rtmp等，封装流媒体编码或容器进行传输；</li>
</ul>
]]></content>
      <categories>
        <category>audio</category>
      </categories>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>live_media_video</title>
    <url>/2021/02/17/live-media-video/</url>
    <content><![CDATA[<h3 id="图像科技发展史："><a href="#图像科技发展史：" class="headerlink" title="图像科技发展史："></a>图像科技发展史：</h3><h4 id="图像的本质："><a href="#图像的本质：" class="headerlink" title="图像的本质："></a>图像的本质：</h4><p>图像的本质可以说是反射光的集合，不同的物质分子组成等不同，那么光照射到物质上，有部分频率的光被吸收，剩下的反射出来，就形成不同的<a id="more"></a><br>颜色，反映了物质的基本特征；可以说每个像素点是一维值，就像声音的采样值；但图片还有大小位置，等信息；所以以一个方图为例，有图片的x轴<br>大小，y轴大小，甚至z轴空间信息，反映出来就是光影形成的三维效果；另外还有物体的位置；<br>而声音其实也有这些信息，声音的位置，不同物体的振动不同，在空气中振动的大小等；只是声音这些信息不能像图像一样能被人更好的利用；<br>或者说信息含量比较小；所以自然界中动物不止出现听觉还有视觉；<br>图像作为这种波动类型的物理信号的特点和表示：振幅，频率，相位，波长，共振等等，这些不赘述，有兴趣再翻阅资料；</p>
<h4 id="图像的记录发展史："><a href="#图像的记录发展史：" class="headerlink" title="图像的记录发展史："></a>图像的记录发展史：</h4><pre><code>图像最开始只能通过绘画记录下来，直到后来，人们发现了透镜成像原理和感光物质显像原理，即时记录图像的工具-相机才慢慢被开发出来；
</code></pre><ul>
<li>简单来说，图像的记录经历了一下的时代:<br>图像-<->湿版摄影法： 即通过成像后，一些感光的化学物质记录，形成图像<br>图像<--> 胶卷相机时代：即：图像反射光-&gt;小孔成像-&gt;感光物质曝光底片-&gt;冲洗照片<br>图像<-->数字信号和处理时代：即图像反射光–&gt;光敏电阻(单色)–&gt;电信号–&gt;模数转换–&gt;101010的数字信号–&gt;  像素值-&gt;计算机处理–&gt;屏幕呈现<br>PS:<a href="https://zhuanlan.zhihu.com/p/161200077" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/161200077</a></--></--></-></li>
</ul>
<h4 id="图像基本入门："><a href="#图像基本入门：" class="headerlink" title="图像基本入门："></a>图像基本入门：</h4><img src="/2021/02/17/live-media-video/basic.png" title="This is an example image">
<p>图像由像素点构成，简称像素(Pixel:picture Element）：像素是图像显示的基本单位，通常说一幅图片的大小，例如是1920<em>1080，即长度为1920个像素点，宽度为1080个像素点，乘积为2,073,600，即这个图片是两百万像素的，拍照中常说的也是这个；<br>PPI: 分辨率也是显示器的重要指标，而PPI是Pixels Per Inch，即每英寸像素；即手机或显示器屏幕上每英寸面积可以放多少个像素点；苹果的PPI值高达326<br><img src="/2021/02/17/live-media-video/pixel.png" title="This is an example image"><br>像素堆积成图片，所以像素本身需要颜色；如上那副图；每个像素点用一个数字来代表颜色，人眼的视锥细胞有三种分别过滤红蓝绿，其他颜色按照比例刺激；所以任何一种颜色可以通过R(红色), G(绿色),B(蓝色)按照一定的比例调配出来；这三种颜色被称为三原色；<br>而比例：是R,G,B的取值，分别从0-255，即8bit表示，所以一个像素点用3</em>8bit 即3个字节表示；而可以代表的颜色在256<em>256</em>256种；任何颜色，都可以用这三个值的组合表示；现在可以用画图试试；我们常说的RGB24就是3*8bit的形式；而一个颜色的16进制即是RGB的16进制即如：R:01,G:02,B:03–&gt; 010203</p>
<h4 id="原始图像和原始视频的文件表示和格式："><a href="#原始图像和原始视频的文件表示和格式：" class="headerlink" title="原始图像和原始视频的文件表示和格式："></a>原始图像和原始视频的文件表示和格式：</h4><ul>
<li>原始图像和原始视频：<br> 一个原始的图片是RGB或YUV格式的，即每个像素点都由8*3 24bit/yuv的数据格式，决定即：Red Green Blue<br>一个原始的视频也是没经过编码压缩的，每一帧都是完整的图像；</li>
<li>RGB YUV 表示和打开，修改等：<br><a href="https://blog.csdn.net/leixiaohua1020/article/details/50534150" target="_blank" rel="noopener">https://blog.csdn.net/leixiaohua1020/article/details/50534150</a><br>另外还有 ffmpeg对图片格式的转换，也能转换为rgb,yuv;<br>RGB和OpenCV,可以直接采集后用opencv调试；<br>RGB： 即每个像素由三个通道值组成R G B,都是8bit;<br>YUV:<br>人们常用RGB表示三基色，而且RGB也可以表示出所有颜色。但视觉心理学研究表明，人眼主要是对光的感知，人的视觉系统对光的感知程度用亮度（luminance）和色度（chrominance）两个属性表示，也就是我们常说的YUV。Y就是亮度感知，而色度感知分为两个属性：色相（hue）和色饱和度（saturation）。色相也就是U,是由光波的峰值定义的，描述的是光的颜色；色饱和度V是光波的谱宽定义的，描述的是光的纯度。 采用YUV色度空间比采用RGB颜色空间更利于视频的压缩，也能更有效的表示彩色视频图像<br><a href="https://www.jianshu.com/p/6a361e86ccd5" target="_blank" rel="noopener">https://www.jianshu.com/p/6a361e86ccd5</a><br>实践：<br>1） 先通过ffmpeg 将jpg或其他通用图片格式转换为 yuv或rgb ffmpeg -i 1.jpg -vcodec rawvideo -pix_fmt rgba raw1.rgb<br>2)   通过程序如<a href="https://blog.csdn.net/leixiaohua1020/article/details/50534150" target="_blank" rel="noopener">https://blog.csdn.net/leixiaohua1020/article/details/50534150</a> 或opencv来处理图像；<br>3） 用相关工具打开：<a href="https://github.com/leixiaohua1020/YUVplayer/blob/master/Release/yuvplayer.exe" target="_blank" rel="noopener">https://github.com/leixiaohua1020/YUVplayer/blob/master/Release/yuvplayer.exe</a><br>验证；</li>
<li>图像基本编码：<br>从RGB–&gt;YUV–&gt;JPEG/BMP/JPG/…</li>
<li>视频基本编码：<img src="/2021/02/17/live-media-video/video.png" title="This is an example image">
从yuv-&gt;h264</li>
<li>I,P,B帧和GOP的基本概念：其中I帧也叫关键帧，是一副完整的画面，而P帧则是记录I帧的变化（H.264中通过补偿算法根据I帧得到的差异文件），B帧类似。<br>I 帧：一个可以独立解码的帧，size大<br>P 帧：依赖前面的帧来解码，size小<br>B 帧：依赖前后的帧来解码，size小<br>GOP: 两个I帧之间的间隔，GOP = I(帧内编码帧) + B（双向预测帧） + P（前向预测帧）<br>其中I帧也叫关键帧，是一副完整的画面，而P帧则是记录I帧的变化（H.264中通过补偿算法根据I帧得到的差异文件），B帧类似。再简单点说，如果没有I帧，P帧和B帧也无法解码。这也很好理解，没有原始对比文件，只有差异文件是无法渲染画面的。<br>GOP结构一般两个数字，如M=1，N=2。M指定I帧和P帧之间的距离，N指定两个I帧之间的距离，其他都是B帧填充。如M=1，N=2这里的例子是IDR PB I排序。<br>有些地方会讲IDR帧，其实就是GOP的第一个I帧，这个帧很重要，因为关于首开优化基本上都在去尽可能减小IDR帧的大小</li>
<li>视频的几个参数和影响：<br>帧率：即每秒有多少帧，帧率越大，说明每秒帧数越多，即视频越流畅；若是假设一段10s的视频总帧数在200，则原本帧率为20fps,增大帧率<pre><code>到40fps会导致只需要5s就能放完，即加速了x2; 所以视频加速播放和慢速播放就是控制帧率的大小；
</code></pre>dts：DTS：Decode Time Stamp。DTS主要是标识读入内存中的bit流在什么时候开始送入解码器中进行解码。<br>DTS主要用于视频的解码,在解码阶段使用,每帧都有一个dts值，一般是个数值，一般视频帧之间差30，音频帧之间差20<br>pts:PTS主要用于视频的同步和输出.在display的时候使用.在没有B frame的情况下.DTS和PTS的输出顺序是一样的.<br>音视频同步的概念： 一般在看视频画面时，音频也要跟上嘴型和情节，所以音画同步需要借助dts/pts; 线性传递时，一般是一个音频帧一个视频帧；<pre><code>而音频帧和视频帧的dts也是有序的，如：a1:123 v1: 134 a2: 145 v2: 155
</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>video</category>
      </categories>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>live_media_audio</title>
    <url>/2021/02/17/live-media-audio/</url>
    <content><![CDATA[<h3 id="音频科技发展史："><a href="#音频科技发展史：" class="headerlink" title="音频科技发展史："></a>音频科技发展史：</h3><h4 id="声音的本质："><a href="#声音的本质：" class="headerlink" title="声音的本质："></a>声音的本质：</h4><p>声音的本质是一种振动，可以说是一种一维的物理信号；可以通过敲击，让物体振动产生，并且可以使空气产生振动，从而传播，不过会能量衰减，导致只能传播一定的距离，原始振动<br>能量越大，传输的距离就越大；<a id="more"></a><br>声音作为这种波动类型的物理信号的特点和表示：振幅，频率，相位，波长，共振等等，这些不赘述，有兴趣再翻阅资料；</p>
<h4 id="音频的录制发展史："><a href="#音频的录制发展史：" class="headerlink" title="音频的录制发展史："></a>音频的录制发展史：</h4><p><em>豆瓣有篇文章说的还可以：<a href="https://www.douban.com/group/topic/28212958/" target="_blank" rel="noopener">https://www.douban.com/group/topic/28212958/</a></em></p>
<ul>
<li>简单来说，声音的录制经历了一下的时代:<br>声音-<->动能(机械)的时代： 即通过声波振记器，比如：可以将声波变换成金属针的震动，然后将波形刻录在圆筒形腊管的锡箔上。当针再一次沿着刻录的轨迹行进时，便可以重新发出留下的声音。<br>声音<-->电信号的时代：即：声音–&gt;振动–麦克风振动膜放大–&gt;线圈磁铁–&gt;电信号磁信号： 由磁带记录，播放；<br>声音<-->数字信号和处理时代：即声音–&gt;麦克风–&gt;电信号–&gt;模拟信号处理AD/DA转换成数字信号：具体学习数字信号和模拟信号处理，了解示波器等器件；–&gt;101010的数字信号–&gt;<br>电脑接收和处理–&gt;数字信号转模拟信号AD/DA –&gt;转为声音信号–&gt;扬声器  增加了立体声；<br>PS:<a href="https://zhuanlan.zhihu.com/p/64050348" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/64050348</a><br>ADC=Analog Digital Change 模数转换<br>DAC= Digital Analog Change 数模转换<h4 id="现代声音录制采集处理的基本过程："><a href="#现代声音录制采集处理的基本过程：" class="headerlink" title="现代声音录制采集处理的基本过程："></a>现代声音录制采集处理的基本过程：</h4>即上述的第三个时代，这里稍微详细解释：现代为了提高声音的质量，在采集上也有各种细分： 环境的保证，声音无损传递，放大，麦克风的设计和材料，声音芯片的设计和材料(语音芯片有多种，涉及<br>声音从模拟信号到数字信号的过程：AD/DA转换), 采样也有相关定理：奈奎斯特采样定律；(模拟信号数字化必须经过三个过程，即抽样、量化和编码，以实现话音数字化的脉冲编码调制（PCM，Pulse Coding Modulation）技术。)，至此，完成声音的数字化过程，但是对声音的处理还远不止于此，采集到的声音可能有噪声，对噪声的处理，降噪技术等，采集到的声音的转换，混合，传输<br>识别，智能转文本等等。</--></--></-></li>
</ul>
<h3 id="音频的组成："><a href="#音频的组成：" class="headerlink" title="音频的组成："></a>音频的组成：</h3><h4 id="音频的表示和基本参数："><a href="#音频的表示和基本参数：" class="headerlink" title="音频的表示和基本参数："></a>音频的表示和基本参数：</h4><pre><code>+ 简单介绍PCM 声音如何从模拟信号转换为数字信号：  
</code></pre><img src="/2021/02/17/live-media-audio/pcmall.png" title="This is an example image">
<pre><code>      + 采样：采样是将模拟信号以其带宽两倍以上的频率提取样值，变为在时间轴上离散数据的过程：
         采样率：每秒从连续信号中提取出并组成离散信号的采样个数：用Hz表示；  
         如：
    如音频信号采样率为8000hz。
    可以理解上图采样对应图中 那段电压随时间变化的曲线 为1秒 那下面那个1 2 3 …10那就因该有1-8000个点，即将1秒均分为8000份，依次取出来那8000个点时间 对应的电压值。
      + 量化：
         可以看到，在时间轴上连续的值已经变为离散的了，但是在电压上(y轴)上的值还是可能有无限多个值的情况，所以这个时候需要将电压上的值进行量化,举个例子：
         采样位数： 即描述数字信号所用的位数：如t1时间的电压值V1用8bit的数值表示： 3： 00000011 ，8bit最大可以表示数值为256,16位类似；
         量化精度，即将一个范围的值转换为另一个范围的值，两个值之间的间隔： 比如：将0-3.3V的范围电压值存储在8位的数字里即： 3.3/256=0.0128
         量化： 即比如将0-3.3V的电压值放到8位数字中：即 电压值1.65V对应的值就是128，以此类推；
         量化的后果：量化后的抽样信号与量化前的抽样信号相比较，当然有所失真，且不再是模拟信号。这种量化失真在接收端还原模拟信号时表现为噪声，并称为量化噪声。量化噪声的大小取决于把样值分级“取整”的方式，分的级数越多，即          量化级差或间隔越小，量化噪声也越小。

      + 编码：将量化后得到的类似十进制数字码流经过一定的规则转换为二进制码流进入数字系统的过程；  
         常见的有PCM音频编码：
         PCM协议：  
PCM（PCM-clock、PCM-sync、PCM-in、PCM-out）脉冲编码调制，模拟语音信号经过采样量化以及一定数据排列就是PCM了。理论上可以传   输单声道，双声道立体声和多声道。是数字音频的raw data.
         PCM信号：PCM信号未经过任何编码和压缩处理(无损压缩)。与模拟信号比，它不易受传送系统的杂波及失真的影响。动态范围宽，可得到音质相当好的效果。编码上采用A律13折线编码。
        关于双声道的采样：  
</code></pre><img src="/2021/02/17/live-media-audio/channel.png" title="This is an example image">
<pre><code>  +  关于采样频率：
   人对频率的识别范围是 20HZ - 20000HZ, 如果每秒钟能对声音做 20000 个采样, 回放时就足可以满足人耳的需求.
      8000hz 为电话采样。
      22050 的采样频率是常用的。
      44100已是CD音质, 超过48000的采样对人耳已经没有意义
      对采样率为44.1kHz的AAC（Advanced Audio Coding）音频进行解码时，一帧的解码时间须控制在23.22毫秒内。通常是按1024个采样点一帧。
      而一个采样点，可以理解为就是一个8bit/16bit的音频值/hz
      PS： 音频其实没有帧的概念，音频是一连串的采样值，比如采样率为44.1kHZ，采样精度为16位的音频，你可以算出bitrate（比特率）是4410016kbps，每秒的音频数据是固定的4410016/8 字节。而一般是每次返回1024个采样值；
+ 什么样的采样和音频值位数叫无损呢？
</code></pre><h5 id="音频的采集和表示："><a href="#音频的采集和表示：" class="headerlink" title="音频的采集和表示："></a>音频的采集和表示：</h5><ul>
<li>pcm的格式的raw data数据；<pre><code>在linux下的采集
1）采集白噪音，播放并导入到/null  cat /dev/urandom | padsp tee /dev/audio &gt; /dev/null 
2）采集内存内容到播放audio,和/null cat /dev/mem | padsp tee /dev/audio &gt; /dev/null 
3)  采集白噪音并播放和保存：cat /dev/urandom | padsp tee /dev/audio &gt; /home/some.raw
注意这里是按默认的采样率，声道数，量化位数的；
更多接口：音频的linux下的编程接口；https://docs.google.com/viewerng/viewer?url=https://www.programmer-books.com/wp-content/uploads/2019/06/Linux-Sound-Programming.pdf
</code></pre></li>
<li>音频音量，pcm格式等表示；见上</li>
<li>音频编码情况：<br>WAV:pcm是无损wav文件中音频数据的一种编码方式，但wav还可以用其它方式编码<h5 id="音频的基本参数：采样率，音频值位数，比特率等；"><a href="#音频的基本参数：采样率，音频值位数，比特率等；" class="headerlink" title="音频的基本参数：采样率，音频值位数，比特率等；"></a>音频的基本参数：采样率，音频值位数，比特率等；</h5><h4 id="音频查看的相关工具：Audacity-可以导入原始格式进行播放和查看："><a href="#音频查看的相关工具：Audacity-可以导入原始格式进行播放和查看：" class="headerlink" title="音频查看的相关工具：Audacity 可以导入原始格式进行播放和查看："></a>音频查看的相关工具：Audacity 可以导入原始格式进行播放和查看：</h4>将wav或其他格式转换为pcm: eg:<br>ffmpeg -i file.wav -f s16be -ar 8000 -acodec pcm_s16be file.raw<br>PCM数据格式：即原始的音频采样数据：<br>比如：在得到file.raw后，用audacity播放，用文本编辑器打开，删除一半或一些数据，保存后再次用audacity播放，即可得到剩一半的数据；<br>WAV数据格式：PCM的基础上加上一些头，meta信息<br>其他工具：praat</li>
</ul>
<h4 id="认识音频原始数据"><a href="#认识音频原始数据" class="headerlink" title="认识音频原始数据"></a>认识音频原始数据</h4><h5 id="在windows-linux上采集pcm原始音频"><a href="#在windows-linux上采集pcm原始音频" class="headerlink" title="在windows/linux上采集pcm原始音频"></a>在windows/linux上采集pcm原始音频</h5><p>1） 列出设备：<br><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">ffmpeg -list_devices true -f dshow -i dummy  </span><br><span class="line">在DirectShow audio devices下  </span><br><span class="line">eg: "xxx"(Realtek Audio)" 中文时可能有乱码，这个时候可以选择可选的另一个名字：  </span><br><span class="line">eg: Alternative name "@device_cm_&#123;33D9A762<span class="string">-90</span>C8<span class="string">-11</span>D0-BD43<span class="string">-00</span>A0C911CE86&#125;\wave_&#123;E41DED46<span class="string">-6012</span><span class="string">-4493</span><span class="string">-8</span>D55<span class="string">-7</span>D9322A433B6&#125;"</span><br></pre></td></tr></table></figure></p>
<p>2）通过展示出来的设备进行录制音频：<br><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">ffmpeg.exe -f dshow -t 20 -i audio="@device_cm_&#123;33D9A762<span class="string">-90</span>C8<span class="string">-11</span>D0-BD43<span class="string">-00</span>A0C911CE86&#125;\wave_&#123;E41DED46<span class="string">-6012</span><span class="string">-4493</span><span class="string">-8</span>D55<span class="string">-7</span>D9322A433B6&#125;"  -f s16le -y D:\sijiruni3.pcm</span><br></pre></td></tr></table></figure></p>
<p>3) 按格式播放采集的音频：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ffplay<span class="selector-class">.exe</span> -channels <span class="number">2</span> -f s16le -<span class="selector-tag">i</span> D:\sijiruni.pcm</span><br><span class="line">将pcm转为wav:ffmpeg<span class="selector-class">.exe</span> -f s16le -ar <span class="number">44100</span> -ac <span class="number">2</span> -<span class="selector-tag">i</span> D:\audiotest\output_halfleft<span class="selector-class">.pcm</span> out_halfleft.wav</span><br></pre></td></tr></table></figure></p>
<p>注意：若播放失败，尝试用大端/小端都尝试下；</p>
<h5 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h5><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">-f  s16le  : </span><br><span class="line">   f: format </span><br><span class="line">   s16  ： <span class="keyword">signed</span> <span class="number">16</span><span class="built_in">bit</span></span><br><span class="line">   u16: <span class="keyword">unsigned</span> <span class="number">16</span><span class="built_in">bit</span> </span><br><span class="line">   le : little <span class="built_in">end</span>  小端</span><br><span class="line">   be: big <span class="built_in">end</span> 大端</span><br></pre></td></tr></table></figure>
<p>更多格式：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -formats | grep PCM</span><br><span class="line"> DE alaw            PCM A-law</span><br><span class="line"> DE f32be           PCM <span class="number">32</span>-<span class="built_in">bit</span> floating-<span class="built_in">point</span> big-endian</span><br><span class="line"> DE f32le           PCM <span class="number">32</span>-<span class="built_in">bit</span> floating-<span class="built_in">point</span> little-endian</span><br><span class="line"> DE f64be           PCM <span class="number">64</span>-<span class="built_in">bit</span> floating-<span class="built_in">point</span> big-endian</span><br><span class="line"> DE f64le           PCM <span class="number">64</span>-<span class="built_in">bit</span> floating-<span class="built_in">point</span> little-endian</span><br><span class="line"> DE mulaw           PCM mu-law</span><br><span class="line"> DE s16be           PCM <span class="keyword">signed</span> <span class="number">16</span>-<span class="built_in">bit</span> big-endian</span><br><span class="line"> DE s16le           PCM <span class="keyword">signed</span> <span class="number">16</span>-<span class="built_in">bit</span> little-endian</span><br><span class="line"> DE s24be           PCM <span class="keyword">signed</span> <span class="number">24</span>-<span class="built_in">bit</span> big-endian</span><br><span class="line"> DE s24le           PCM <span class="keyword">signed</span> <span class="number">24</span>-<span class="built_in">bit</span> little-endian</span><br><span class="line"> DE s32be           PCM <span class="keyword">signed</span> <span class="number">32</span>-<span class="built_in">bit</span> big-endian</span><br><span class="line"> DE s32le           PCM <span class="keyword">signed</span> <span class="number">32</span>-<span class="built_in">bit</span> little-endian</span><br><span class="line"> DE s8              PCM <span class="keyword">signed</span> <span class="number">8</span>-<span class="built_in">bit</span></span><br><span class="line"> DE u16be           PCM <span class="keyword">unsigned</span> <span class="number">16</span>-<span class="built_in">bit</span> big-endian</span><br><span class="line"> DE u16le           PCM <span class="keyword">unsigned</span> <span class="number">16</span>-<span class="built_in">bit</span> little-endian</span><br><span class="line"> DE u24be           PCM <span class="keyword">unsigned</span> <span class="number">24</span>-<span class="built_in">bit</span> big-endian</span><br><span class="line"> DE u24le           PCM <span class="keyword">unsigned</span> <span class="number">24</span>-<span class="built_in">bit</span> little-endian</span><br><span class="line"> DE u32be           PCM <span class="keyword">unsigned</span> <span class="number">32</span>-<span class="built_in">bit</span> big-endian</span><br><span class="line"> DE u32le           PCM <span class="keyword">unsigned</span> <span class="number">32</span>-<span class="built_in">bit</span> little-endian</span><br><span class="line"> DE u8              PCM <span class="keyword">unsigned</span> <span class="number">8</span>-<span class="built_in">bit</span></span><br><span class="line"> https:<span class="comment">//trac.ffmpeg.org/wiki/audio%20types</span></span><br></pre></td></tr></table></figure></p>
<h5 id="音频采集常见参数解释："><a href="#音频采集常见参数解释：" class="headerlink" title="音频采集常见参数解释："></a>音频采集常见参数解释：</h5><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"> channel: 通道数，可以有多个通道支持，常见有，单声道和立体声(两个通道)</span><br><span class="line">rate： 采样率： 即每秒采样的点数，比如<span class="number">44100</span>hz,则每秒采集<span class="number">44100</span>个值，这个值大小代表振幅大小，即音频音量值</span><br><span class="line">位深： 即一个采样点用多大类型的值表示： 常见有<span class="number">8</span><span class="built_in">bit</span>,<span class="number">16</span><span class="built_in">bit</span>等，见上；</span><br><span class="line">frame: 在单声道：一个帧表示一个通道下的一个采样，而双通道，则一个帧包含两个采样点；所以帧率和sample rate采样率一样；</span><br><span class="line">           比如：单声道： <span class="number">44100</span>hz,则表示 ，每秒<span class="number">44100</span>个采样点，帧率为<span class="number">44100</span>/s,而 双通道下，<span class="number">44100</span>hz,由于一帧两个采样，所以帧率也是<span class="number">44100</span>；</span><br><span class="line">           注意这里的帧率和传输上的帧率不同；</span><br><span class="line">period <span class="built_in">time</span>: 毫秒单位，两个硬件中断的时间间隔，这个中断用来刷新缓存；</span><br><span class="line">period size: 硬件中断之间的帧数量；和以下相关：</span><br><span class="line">          period <span class="built_in">time</span> = period size * <span class="built_in">time</span>/frame  : 帧数*每帧占用的时间长度；</span><br><span class="line">                             = period size * number <span class="keyword">of</span> channels * <span class="built_in">time</span>/sample : 帧数* 每个采样占用的时长</span><br><span class="line">                            = period size * number <span class="keyword">of</span> channels / samplate rate : 帧数/采样率(帧率)</span><br><span class="line">            eg:  <span class="number">48000</span>hz 双通道，periodsize = <span class="number">8192</span>frames,则 period <span class="built_in">time</span> = <span class="number">8192</span>/<span class="number">48000</span>=<span class="number">170.5</span>ms</span><br><span class="line">periods: 每个<span class="keyword">buffer</span>的periods数量</span><br><span class="line"><span class="keyword">buffer</span> <span class="built_in">time</span>: 一个<span class="keyword">buffer</span>的时长</span><br><span class="line"><span class="keyword">buffer</span> size: 一个<span class="keyword">buffer</span>的帧数；</span><br><span class="line">    一个<span class="keyword">buffer</span>的时长= <span class="keyword">buffer</span> size * <span class="built_in">time</span>/frame ： 一个<span class="keyword">buffer</span>的帧数* 一个帧的时长</span><br><span class="line">                              = <span class="keyword">buffer</span> size * number <span class="keyword">of</span> channels * <span class="built_in">time</span>/sample : 一个<span class="keyword">buffer</span>帧数 * channel数* 一个采样点的时长</span><br><span class="line">                              = <span class="keyword">buffer</span> size * number <span class="keyword">of</span> channels / sample rate</span><br><span class="line"></span><br><span class="line">注意一个<span class="keyword">buffer</span>可能是多个periods;</span><br><span class="line">https://www.alsa-project.org/wiki/FramesPeriods  更多更详细解释</span><br></pre></td></tr></table></figure>
<h5 id="音频数据组织方式和解释："><a href="#音频数据组织方式和解释：" class="headerlink" title="音频数据组织方式和解释："></a>音频数据组织方式和解释：</h5><p>音频中的数据如何排放：<br>对单声道： 每个采样点一个数据，以16bit，44100hz为例，XXOO  OOXX …. ,1s有44100个值<br>对双声道： 每个采样点一个数据，PCM16LE双声道数据中左声道和右声道的采样值是间隔存储的.<br>注意： 对单声道来讲，也是两个耳机都能播放的，关键在于左右声道平衡的设置，如audacity<br>而当双声道下，一个声道的数据为0时，则会出现左/右 只有一个有声音的情况；默认播放时 ；<br>所以我们可以将音频数据左右交替清除来达到空间的效果；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">只有右耳能听到；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplest_pcm16le_halfvolumeleft</span><span class="params">(<span class="keyword">char</span> *url)</span></span>&#123;</span><br><span class="line">	FILE *fp=fopen(url,<span class="string">"rb+"</span>);</span><br><span class="line">	FILE *fp1=fopen(<span class="string">"output_halfleft.pcm"</span>,<span class="string">"wb+"</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *sample=(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span>(!feof(fp))&#123;</span><br><span class="line">		<span class="keyword">short</span> *samplenum=<span class="literal">NULL</span>;</span><br><span class="line">		fread(sample,<span class="number">1</span>,<span class="number">4</span>,fp);</span><br><span class="line"> </span><br><span class="line">		samplenum=(<span class="keyword">short</span> *)sample;</span><br><span class="line">		*samplenum=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//L</span></span><br><span class="line">		fwrite(sample,<span class="number">1</span>,<span class="number">2</span>,fp1);</span><br><span class="line">		<span class="comment">//R</span></span><br><span class="line">		fwrite(sample+<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,fp1);</span><br><span class="line"> </span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Sample Cnt:%d\n"</span>,cnt);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">free</span>(sample);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	fclose(fp1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//blog.csdn.net/leixiaohua1020/article/details/50534316</span></span><br></pre></td></tr></table></figure></p>
<h5 id="音频技术："><a href="#音频技术：" class="headerlink" title="音频技术："></a>音频技术：</h5><ul>
<li>混音  TODO</li>
<li>重采样 TODO</li>
</ul>
<h5 id="音频压缩："><a href="#音频压缩：" class="headerlink" title="音频压缩："></a>音频压缩：</h5><p>TODO</p>
<h5 id="alsa音频编程："><a href="#alsa音频编程：" class="headerlink" title="alsa音频编程："></a>alsa音频编程：</h5><p>ref linux-sound-programming.pdf<br>mark:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">对alsa编程编译运行成功，但是貌似录制不到声音，用了arecord也不行；</span><br><span class="line">sudo arecord -D <span class="string">"hw:0,0"</span> -f S16_LE -r <span class="number">16000</span> -c <span class="number">2</span> -d <span class="number">20</span> -t wav test2.wav</span><br><span class="line">./test hw:<span class="number">0.0</span> file.pcm</span><br><span class="line">也都不行，但是其实命令和设备都是对的；</span><br><span class="line">先不搞了，本来还想依赖它搞硬件的混音，这里不了，直接录制后，从pcm或其他级别来搞混音；</span><br></pre></td></tr></table></figure></p>
<h4 id="next"><a href="#next" class="headerlink" title="next:"></a>next:</h4><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）学习audacity和理解各个音频功能： 混音，音频重采样等</span><br><span class="line"><span class="number">2</span>）学习音频相关协议： aac,wav,ogg,flac等；</span><br><span class="line"><span class="number">3</span>)  学习如何编程处理，裸，或者用ffmpeg库；</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>audio</category>
      </categories>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>live_media_overiew</title>
    <url>/2021/02/17/live-media-overiew/</url>
    <content><![CDATA[<h3 id="音视频基础知识：理论-实践"><a href="#音视频基础知识：理论-实践" class="headerlink" title="音视频基础知识：理论+实践"></a>音视频基础知识：理论+实践</h3><h4 id="音频的基本原理和组成"><a href="#音频的基本原理和组成" class="headerlink" title="音频的基本原理和组成"></a>音频的基本原理和组成</h4><ul>
<li>音频的表示和基本参数： Hz, 音量，pcm等以及基本编码；</li>
<li>音频查看的相关工具； <a id="more"></a></li>
</ul>
<h4 id="视频的基本原理和组成"><a href="#视频的基本原理和组成" class="headerlink" title="视频的基本原理和组成"></a>视频的基本原理和组成</h4><ul>
<li>图像基础知识：RGB,YUV </li>
<li>图像和视频：</li>
<li>关键帧和参考帧的概念：I,P,B</li>
<li>GOP的概念和应用；</li>
</ul>
<h4 id="音频文件和直播中的音频流"><a href="#音频文件和直播中的音频流" class="headerlink" title="音频文件和直播中的音频流"></a>音频文件和直播中的音频流</h4><ul>
<li>音频文件和直播中的音频流的基本区别和原理</li>
<li>音频编码格式和容器封装，以及相关格式和特点  </li>
</ul>
<h4 id="视频文件和直播中的视频流"><a href="#视频文件和直播中的视频流" class="headerlink" title="视频文件和直播中的视频流"></a>视频文件和直播中的视频流</h4><ul>
<li>视频文件和直播中的视频的基本区别和原理</li>
<li>视频编码格式和容器封装，以及相关格式和特点；  </li>
</ul>
<h3 id="音视频高级知识：-理论-实践"><a href="#音视频高级知识：-理论-实践" class="headerlink" title="音视频高级知识： 理论+实践"></a>音视频高级知识： 理论+实践</h3><h4 id="音频的编码技术："><a href="#音频的编码技术：" class="headerlink" title="音频的编码技术："></a>音频的编码技术：</h4><ul>
<li>AAC和ADTS</li>
<li>OPUS和OGG</li>
<li>其他  </li>
</ul>
<h4 id="视频的编码技术："><a href="#视频的编码技术：" class="headerlink" title="视频的编码技术："></a>视频的编码技术：</h4><ul>
<li>H.264/H.265和MPEG系列</li>
<li>VP8/VP9 google</li>
<li>其他，MS的VC-1  </li>
</ul>
<h4 id="实践：ffmpeg"><a href="#实践：ffmpeg" class="headerlink" title="实践：ffmpeg:"></a>实践：ffmpeg:</h4><ul>
<li>专注在ffmpeg的接口如何使用，并构建类似播放器这种例子；在遇到问题时查阅接口的源代码，这种学习方式；<br>在这种路子，可以学习各种ffmpeg支持的常用协议  </li>
</ul>
<h3 id="直播技术栈全貌"><a href="#直播技术栈全貌" class="headerlink" title="直播技术栈全貌"></a>直播技术栈全貌</h3><h4 id="直播技术架构：客户端，服务端，网络CDN等等；"><a href="#直播技术架构：客户端，服务端，网络CDN等等；" class="headerlink" title="直播技术架构：客户端，服务端，网络CDN等等；"></a>直播技术架构：客户端，服务端，网络CDN等等；</h4><h3 id="服务器后台直播技术栈：构建基本的直播后台架构；"><a href="#服务器后台直播技术栈：构建基本的直播后台架构；" class="headerlink" title="服务器后台直播技术栈：构建基本的直播后台架构；"></a>服务器后台直播技术栈：构建基本的直播后台架构；</h3><h4 id="分布式系统的技术栈"><a href="#分布式系统的技术栈" class="headerlink" title="分布式系统的技术栈"></a>分布式系统的技术栈</h4><h4 id="所在公司的直播网系统；"><a href="#所在公司的直播网系统；" class="headerlink" title="所在公司的直播网系统；"></a>所在公司的直播网系统；</h4><h4 id="所在公司的分发网系统"><a href="#所在公司的分发网系统" class="headerlink" title="所在公司的分发网系统"></a>所在公司的分发网系统</h4><h4 id="所在公司的直播网，分发网，p2p和cdn的融合；"><a href="#所在公司的直播网，分发网，p2p和cdn的融合；" class="headerlink" title="所在公司的直播网，分发网，p2p和cdn的融合；"></a>所在公司的直播网，分发网，p2p和cdn的融合；</h4><h3 id="服务器后台直播技术栈高级：-优化"><a href="#服务器后台直播技术栈高级：-优化" class="headerlink" title="服务器后台直播技术栈高级： 优化"></a>服务器后台直播技术栈高级： 优化</h3><h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><h4 id="网络本身：路由等等；延迟和卡顿-jitterbuffer-重传和fec"><a href="#网络本身：路由等等；延迟和卡顿-jitterbuffer-重传和fec" class="headerlink" title="网络本身：路由等等；延迟和卡顿(jitterbuffer,重传和fec)"></a>网络本身：路由等等；延迟和卡顿(jitterbuffer,重传和fec)</h4><h4 id="直播后台性能：缓存，资源调度和流量管理"><a href="#直播后台性能：缓存，资源调度和流量管理" class="headerlink" title="直播后台性能：缓存，资源调度和流量管理"></a>直播后台性能：缓存，资源调度和流量管理</h4><h3 id="音视频编码技术："><a href="#音视频编码技术：" class="headerlink" title="音视频编码技术："></a>音视频编码技术：</h3><h4 id="基本编码原理"><a href="#基本编码原理" class="headerlink" title="基本编码原理"></a>基本编码原理</h4><h4 id="opencv等视觉"><a href="#opencv等视觉" class="headerlink" title="opencv等视觉"></a>opencv等视觉</h4><h4 id="ai"><a href="#ai" class="headerlink" title="ai"></a>ai</h4><h3 id="更多：TODO"><a href="#更多：TODO" class="headerlink" title="更多：TODO:"></a>更多：TODO:</h3>]]></content>
      <categories>
        <category>live_media</category>
      </categories>
      <tags>
        <tag>overiew</tag>
      </tags>
  </entry>
  <entry>
    <title>my_funds_and_stocks</title>
    <url>/2021/02/09/my-funds-and-stocks/</url>
    <content><![CDATA[<h3 id="简介和写这篇文章的目的："><a href="#简介和写这篇文章的目的：" class="headerlink" title="简介和写这篇文章的目的："></a>简介和写这篇文章的目的：</h3><p>  其实在上大学，大三大四的时候就有财商的思考了，而触发这个思考一开始是大学期间看的穷爸爸和富爸爸那本书，和那个老鼠赛跑的游戏，再之后，财商这个词，<a id="more"></a>主要源于一个做生意的初中同学在某句话中出现了这个词，其实不用解释很多，仅仅是一个新概念，就足以引人深思；但是那会其实没有钱，也没啥概念，也单单只是停留在如何通过一些渠道更快更便捷的赚更多的钱；所以那个时候做一些兼职，也停留在简单的生意层面；  </p>
<p>  直到开始工作，因为繁忙，多加班，让我没有更多的精力去做斜杠青年，而老家的房子问题，让我第一份工作，即头两年左右的时间，都将工资，年终奖等，去掉生活费攒下的钱，都交给家里了；<br>没有时间消费，加上其他福利，少社交等，让我的生活基本只有工作；于是第一份工作，在完成家里的房子后，我也没剩下什么钱了；于是。累的我，跳槽了；  </p>
<p>  之后，才是我自己的生活，而这个时候已经毕业两年了；第二份工作时2019年11月底开始的，拿到工资的时候，钱也终于能自由支配；于是顺理成章的，我会去思考，如何理财，而无非，就是如何进行资产配置，如何记账，如何管理财富等等；<br>  于是我开始查理财的知识，直到加入一个线上低价的小白课入门，渐渐开始了解这个基金，股票的世界，而最让我感觉到希望的是，可以借此财富自由；毕竟，在这之前，我以为财富自由要赚很多很多钱，或者是要有类似书籍版权等类似的睡后收入；  </p>
<p>  于是我开始学习基金，股票知识，慢慢的，接触到螺丝钉和他的书，接着在2020年02月开始通过蛋卷基金买基金等；到现在2021年02月，整整一年，我的收益年化在15%左右；我了解的知识不多，只是跟着大螺买，了解基金的基本原理；<br>而后来我要自选一些基金，加上想在下一年进军美股港股等，所以，要接着继续学习；  </p>
<p>  于是这篇文章，想记录下我这2020年的资产配置和投资的总结；  </p>
<h3 id="关于资产的概念和资产配置："><a href="#关于资产的概念和资产配置：" class="headerlink" title="关于资产的概念和资产配置："></a>关于资产的概念和资产配置：</h3><ul>
<li>家庭日常消费规划一般：消费计划，投资计划，保险计划，教育金计划，养老金计划等；都是理财，凡是和钱有关的安排都是理财；</li>
<li>生钱资产，耗钱资产和其他资产，这三个重要概念：<ul>
<li>1)资产：房子，车子，手机，钱，桌子，椅子，基金，股票等等；</li>
<li>2)流动资产和非流动资产：流动资产：方便变现的如股票，基金等；非流动资产：不方便变现的如：房子，车子等；</li>
<li>3)资产的内涵：现金流</li>
<li>4)生钱资产：能给你持续带来净现金流入的东西，可以躺着赚钱，睡后收入；如基金，余额宝，债券等，变富有</li>
<li>5)耗钱资产：能给你持续带来净现金流出的东西，可以躺着付钱，睡后支出；如贷款的房子，车子；变穷</li>
<li>6)其他资产：净现金流为0 的资产，如黄金等；</li>
<li>7)注意耗钱资产在某个情况条件下也能变为生钱资产，若其生钱大于耗钱；且不用支出劳动力；</li>
</ul>
</li>
<li>财富自由<ul>
<li>收入低：分清楚必要开支和不必要开支；好支出和坏支出；<br>开源，提高工资收入；建议30岁前，多花时间在工作技能上；工资的增长比投资快多了；</li>
<li>工资收入和非工资收入要同步进行；</li>
<li>中产阶级的现金流和富人现金流的不同：中产：房贷等等；</li>
<li>财务自由的概念：你的非工资收入大于日常开支</li>
<li>财富自由度：年非工资收入(年投资收入)/年生活支出==1是最基本的自由度，数字越大，自由度越高；</li>
<li>富人的两个秘密：<ul>
<li>1）生钱资产占总资产的80%</li>
<li>2）好支出占总支出的80%；比如学习的，健康的；</li>
</ul>
</li>
</ul>
</li>
<li>从一万到100万的理财法则<ul>
<li>复利的强大力量：印度宰相米粒摆棋盘的故事；</li>
<li>复利的一些计算例子：</li>
<li>复利公式：最终收益=本金*（1+收益率）^时间—其实就是以前学政治的里面的公式；</li>
<li>复利曲线和单利曲线，单利就是比如本金10万，利率10%，那么第一年1万，第10年10万(除开本金),…而复利是把利息也投进去了；<br>从公式看y=x*z^t ,可见哪个因素影响大；从曲线来看，时间和z影响很大；所以越早投资越好；</li>
<li>复利计算器：<a href="http://www.yaocaiwuziyou.com/calculator.html" target="_blank" rel="noopener">www.yaocaiwuziyou.com/calculator.html</a>;</li>
</ul>
</li>
<li>财富配置举例：</li>
<li>3：家庭年收入的30%用来作为应急金（包括日常消费），以备不时之需，可以通过无风险工具管理处置，灵活存取</li>
<li>1: 家庭年收入的10%用来配置家庭保险，作为家庭资产的后盾</li>
<li>4：家庭年收入的40%用来养鹅，钱生钱</li>
<li>2：家庭年收入的20%用来投资自己，学习相关技巧，增加自己的工资和非工资收入<br>关于通货膨胀；~</li>
</ul>
<h3 id="本文主要写投资计划"><a href="#本文主要写投资计划" class="headerlink" title="本文主要写投资计划"></a>本文主要写投资计划</h3><h3 id="基金的相关知识"><a href="#基金的相关知识" class="headerlink" title="基金的相关知识"></a>基金的相关知识</h3><h4 id="股票，股权，股东，股份，原始股等概念："><a href="#股票，股权，股东，股份，原始股等概念：" class="headerlink" title="股票，股权，股东，股份，原始股等概念："></a>股票，股权，股东，股份，原始股等概念：</h4><ul>
<li><p>什么是股票?<br>股票（stock）是指股份公司发行的所有权凭证，是股份证书的简称，每家上市公司都会发行股票，是股份公司为筹集资金而发行给股东作为持股凭证并借以取得股息和红利的一种有价证券。<br>每股股票都代表股东对企业拥有一个基本单位的所有权。这种所有权是一种综合权利，如参加股东大会、投票表决、参与公司的重大决策、收取股息或分享红利等。同一类别的每一份股票所代表的公司所有权是相等的。每个股东所拥有的公司所有权份额的大小，取决于其持有的股票数量占公司总股本的比重。股票是股份公司资本的构成部分，可以转让、买卖或作价抵押，是资本市场的主要长期信用工具，但不能要求公司返还其出资。股东与公司之间的关系不是债权债务关系。股东是公司的所有者，以其出资份额为限对公司负有限责任，承担风险，分享收益。  –来自MBA智库  </p>
</li>
<li><p>为什么会有股票：<br>举个例子：<br>假设小明开了一家餐饮公司，名字就叫A公司吧。为了筹集更多资金扩大公司规模，小明准备把A公司上市，股价定为10元。<br>为了让大家购买股票，成为股东，小明承诺每年拿出A公司的部分利润分给股东。—这是投资股票的本质，也是价值投资最看重的，价值来自于公司盈利。<br>(除此之外，还可能承诺给与一定的权利，比如管理权，决策权等)<br>小红花了1000元，买了100股A公司股票，股价10元。<br>去年A公司利润算出来了，准备每股分红1元。分红前股价10元，分红后，小红得到现金1元，股价可能因此变成9元。小红总资产没有变化。—这个后面讨论为什么会可能变为9元  </p>
</li>
</ul>
<ul>
<li><p>股权，股份和股东：</p>
<ul>
<li>股权可以理解为对股票的一种权利，这种权利可以有多种，比如表决权，分红权等等，根据所拥有的股票种类和股票份数，权利也有对应的不同，份数越多，股权越大，越有话语权和管理权；  </li>
<li>股东可以理解为拥有股权的个人或机构；大股东是指拥有份数占比较大股票的个人或机构，这种对应的股权也会比较大；  </li>
<li>股份即拥有股票总数的占比等；  </li>
</ul>
</li>
<li><p>股票的分类：<br>股票有很多种类：  </p>
<ul>
<li><p>1) 按股东权利分类，股票可分为普通股、优先股和后配股。  </p>
<ul>
<li>普通股：在公司的经营管理和盈利及财产分配上有普通权利的股份，代表满足所有债权偿付要求及优先股东的收益权与求偿权要求后对企业盈利和剩余财产的索取权，它构成公司资本的基础，是股票的一种基本形式，也是发行量最大，最为重要的股票。目前在上海和深圳证券交易所上中交易的股票，都是普通股。</li>
<li>优先股：相对于普通股而言的。主要指在利润分红及剩余财产分配的权利方面，优先于普通股。</li>
<li>后配股：是与优先股相反的一种股票。它是指利润分配和剩余财产分配后于普通股的股票。正因为它在财产和股息上的权利顺序比普通股要落后，故称之为后配股。</li>
</ul>
</li>
<li><p>2) 根据上市地区可以分为，我国上市公司的股票有A股、B股、H股、N股和S股等的区分。这一区分主要依据股票的上市地点和所面对的投资者而定。</p>
</li>
<li><p>3) 根据业绩也分为：ST股、垃圾股、绩优股、蓝筹股 。</p>
</li>
<li>4) 其他分类： <ul>
<li>记名股票和无记名股票：是否记载股东姓名来划分股票</li>
<li>有票面值股票和无票面值股票：这主要是根据股票是否记明每股金额来划分的。有票面值股票，是在股票上记载每股的金额。无票面值股票，只是记明股票和公司资本总额，或每股占公司资本总额的比例。</li>
<li>单一股票和复数股票：这主要是根据股票上表示的份数来划分的。单一股票是指每张股票表示一股。复数股票是指每张股票表示数股。</li>
<li>普通股票和特别股票：普通股票的股息随公司利润大小而增减。特别股票一般按规定利率优先取得固定股息，但其股东的表决权有所限制。</li>
<li>表决权股票和无表决权股票：普通股票持有者都有表决权，而那些在某些方面享有特别利益的优先股票持有者在表决权上常受到限制。无表决权的股东，不能参与公司决策。</li>
<li>原始股： 公司申请上市之前发行的股票；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="股权和债权的区别："><a href="#股权和债权的区别：" class="headerlink" title="股权和债权的区别："></a>股权和债权的区别：</h4><ul>
<li>债权：对方借了你的钱，需要还你本金和利息，比如银行的定期存款，利息约定多少，到期还你多少，而活期，贷款等都是这种；  </li>
<li>股权：你花钱买了上市公司股票，成为公司股东，公司定期给你分红。不存在本金和利息。你只要还持有，就继续享受分红；公司不会还你本金和利息；而你要回本或者赚取利益，只能卖出股票或者继续持有通过分红等享受收益；  </li>
</ul>
<h4 id="分红，填权，除权和股票下跌上涨的关系"><a href="#分红，填权，除权和股票下跌上涨的关系" class="headerlink" title="分红，填权，除权和股票下跌上涨的关系"></a>分红，填权，除权和股票下跌上涨的关系</h4><ul>
<li><p>分红：  </p>
<ul>
<li><p>前提：其实股票是一种权利的凭证，股票本身的价值是一种非实体价值，在公司盈利的情况下，且扩张需求不大，无资金需求时，上不上市其实无关紧要，比如华为，OPPO就没上市，而是类似全员持股，或者管理者持股等等；<br>在这种情况下，一家企业的经营，盈利后抛去人力等成本，剩下的钱由老板和管理者，创始人拥有，并决定分配等；和股票和上市没有半毛钱关系；<br>当企业经营不善，或者寻求更进一步的扩张，需要资金支持或者仅仅是资本扩张等，会选择进行融资，上市，而上市前一般是融资，比如天使轮融资，A轮，B轮等直到上市；融资是寻求外部资金，那投资者为什么会给你投资呢？<br>你通过介绍产品等，承诺未来有希望做大，且给与一定的股权和分红等等，于是股票诞生，持有股票越多，股权越大，权利越大等等，至于后面的拆股以及一些手段，有兴趣的再查；  </p>
</li>
<li><p>所以分红，就是：给投资者利益，红利，钱等；有两种形式：向股东派发现金股利和股票股利，上市公司可根据情况选择其中一种形式进行分红，也可以两种形式同时用。  </p>
<ul>
<li>现金股利是指以现金形式向股东发放股利，称为派股息或派息；  </li>
<li>股票股利是指上市公司向股东分发股票，红利以股票的形式出现，又称为送红股或送股；  </li>
</ul>
</li>
</ul>
</li>
<li><p>分红派息，分红的意义？<br>分红即派息，是对投资者回报的一种方式，比如小红买了A公司股票后，股价每股10元，每年派息1元，则10年可以回本，之后还能继续派息；<br>但是投资回报还可以是利用股票的涨跌套利，这种可能是当前比较火的方式；时间也比较短；</p>
</li>
<li><p>那股票一定会分红吗？股票分红对套利的人来讲有意义吗？<br>股票是否分红是上市公司自己决定的，一般要赚钱了才会分红，且分红需要扣税，加上除权的影响，可能分红后持有的股票总资产可能反而有所下降；</p>
</li>
<li><p>PS:<br>对于投资者来说，很多人觉得分红没用其实是站在一个短期投资的角度来看的，如果是长期投资，每年的分红累计起来，过几年就可以收回成本。<br>分红的时候股价降低了，但是持股份额没有变，只要公司能够持续盈利，产生持续分红，那么基本上就是稳赚的。要知道公司只有赚了钱才能分红，能够持续分红的上市公司，一定是优质的投资公司。所以有的公司为了吸引投资者，还会进行强制分红，就是为了吸收更多的资金。<br>不过市场上真正的长期投资者并不是，大多都是短期投资者，所以分红的存在感就很弱，很多人都觉得股票分红没什么用。<br>对于上市公司来说，股票分红后，股价低了，就可以吸引更多的散户买入，同时也更容易获得投资者的信任，获得稳定的资金来源，稳定股价。这是一个良性循环。</p>
</li>
</ul>
<ul>
<li><p>除权，除息：<br>继续上面的例子：<br>去年A公司利润算出来了，准备每股分红1元。分红前股价10元，分红后，小红得到现金1元，股价可能因此变成9元。小红总资产没有变化。<br>因为股票在市场上一直在投资者之间进行转让买卖，当上市公司在一定时期向股东分派股利进行配股时，为使本公司的股东真正得到其应得的分红配股权利，就存在着一个这种权利应该分配给股票的买入者还是卖出者才合理的问题，由此产生了股票除息与除权交易。<br>比如上面的小红在分红日卖出股票，这个时候分红算给谁？ 或者说分红给小红，然后小红再以同样价格的股价卖出？是否合理？<br>此外，由于公司分红配股引起公司股本以及每股股票所代表的企业的实际价值（每股净资产）的变动，需要在发生该事实之后以股票市场价格中剔除这部分因素。<br>比如上面的，本来如果利润以净资产等方式保留下来，那股票价值应该是上涨的，但是因为分红导致少了，所以这个时候需要将每股价格进行下调，即除权：<br>而比如上面的，分红后，小红的总资产可能不变，不过这种情况比较少；毕竟股价和很多因素有关；<br>更多： 除息报价，股权登记日，送股率等等；</p>
</li>
<li><p>填权：<br>在除权（息）后的一段时间内，如果多数投资者对该股看好，使得该股股价上涨，其价格高于除权（息）报价，即股价比除（息）前有所上涨，这种行情称为填权。如果股价上涨到除权（息）前的价格水平，称为填满权。<br>相反，如果多数投资者不看好该股，使得该股价下跌，其价格低于除权（息）报价，即股价比除权（息）前有所下降，则为贴权。</p>
</li>
</ul>
<p>所以，除权和填权，是股票上涨和下跌的一个基础因素之一；<br>除此之外，供需关系，和投资者的看好，也会推高股价，比如这双鞋，我觉得价值高，我在市场上出价就高，即投资者推高股价；同样想买的人多，也会推高股价；  </p>
<h4 id="一级市场和二级市场"><a href="#一级市场和二级市场" class="headerlink" title="一级市场和二级市场"></a>一级市场和二级市场</h4><p>  这篇文章对一级市场和二级市场讲的比较清楚：<br><a href="https://www.zhihu.com/question/36594463" target="_blank" rel="noopener">https://www.zhihu.com/question/36594463</a><br>简单来讲：  </p>
<ul>
<li>一级市场：就是股票最先发行的市场，比如批发市场，而在股市中，一级市场是最开始发行的，对符合条件的机构投资者线下配售的和对个人的网上发行(打新股), 这个时候，往往是股价比较低的，可以理解为批发价，批发市场；</li>
<li>二级市场：就是在批发市场后，由投资机构和打新者，通过交易在零售市场上进行流通；这个时候会有很多散户等入场，于是将价格推高，就像平常的经销商将批发价进价的鞋提高到零售价发售的过程，而打新者因为拿到的是批发价，所以在交易时卖掉可以得到不错的收入；</li>
<li><p>关于破发：<br>如果股票定价1,000元，但二级市场上压根没有想要购买的交易者或者交易者非常少，如果想尽快出售股票就要承担一个比发行价更低市场价格，比如800块，这个过程就叫做股票破发（跌破发行价）。</p>
</li>
<li><p>一级市场的范围：<br>一级市场被称作发行市场其实是不严谨的，因为一级市场的范围其实更广，除了首次公开募股IPO的股票发行外，还包括了股票在公开发行和上市前的私募股权数轮融资过程，通常会以风投Venture Capital/私募股权Private Equity的形式来完成，对应着天使轮-A轮-B轮-C轮有些独角兽企业会一直进行到F轮直至上市退出。这些VC/PE，因为投资的都是一级市场未上市的股权，所以也被称为一级市场基金。</p>
</li>
<li><p>为什么要有一级二级市场：<br>就像鞋一样，如果一开始就投入零售市场，价格比较难确定，因为散户对这个鞋的价值认同不一样，需要经过较长时间的定价才能投入；</p>
</li>
</ul>
<h4 id="关于股票投资和股权投资："><a href="#关于股票投资和股权投资：" class="headerlink" title="关于股票投资和股权投资："></a>关于股票投资和股权投资：</h4><ul>
<li><p>股权投资：是一种价值投资，长期投资：<br>股权投资是投到实体经济、投到企业，投资人变成企业长期股东，投资人把自己的资源和隐性能力嫁接到这个公司，为公司的长期发展做出持续性贡献。所以，股权投资有两个非常鲜明的特点：一是增量资金进入公司；二是投资人作为股东会为这个公司做持续性的增值或服务。</p>
</li>
<li><p>股票投资：是一种零和游戏，是赚取波动的钱；<br>在投资者多空博弈中，股价会出现上涨和下跌，幅度有时候会远远超过业绩的变动幅度，意味着股价可能会涨太多偏离内在价值，之后又下跌进行修复，股民通过股价的涨跌波动赚取差价，就是赚波动的钱。那么这部分钱从哪里来，就是从对手的账户中来，有人赚必然就有人亏，你赚的钱就是别人亏的钱。</p>
</li>
<li><p>其他：央行印发钞票，这个时候大家都赚钱：央行印发钞票，为市场提供流动性，流动性充足甚至流动性泛滥，就会出现资产价格上涨，有时还会持续上涨，在由巨量流动性推升的行情中，所有人都赚到钱了，公司盈利没有明显增加，也没有对手博弈亏钱，这赚的就是央行的钱。</p>
</li>
<li><p>PS:<br>股票盈利靠价格波动，股权盈利靠价值增长。<br>A股（二级市场）遍布“铁公鸡”，有钱也不分红，投资人只能通过不断的交易，然后赢得差价。<br>而在一级市场中，较长的锁定期使得股权流动性大大降低，公司未来的估值提升才是盈利核心。<br>在中国，股票市场的绝大多数投资者是散户，而绝大多数上市公司的分红很少，具备持续成长能力的上市公司数量也少。<br>　　所以，中国的股票投资本质是我的钱进到别人兜里，我赚的钱是从别人口袋掏出来的，钱并没有进入公司，而是在不同股东之间高速流转，某种程度上是一种资金的空转。<br>　　股票投资是在交易市场里赚取交易的不对称性、不平衡性，某些人赚钱就意味着其他人一定亏钱，基本上是一个零和游戏。  </p>
</li>
<li><p>如何做股权投资？ TODO;  </p>
</li>
</ul>
<h4 id="基金是什么，基金分类"><a href="#基金是什么，基金分类" class="headerlink" title="基金是什么，基金分类"></a>基金是什么，基金分类</h4><p>股票和债券(债权)都是直接投资，而基金，是一种间接投资：  </p>
<ul>
<li>基金：代表一种委托关系，委托专业机构帮你理财，收益受专业机构的理财能力影响。一般来说，基金收益小于股票，大于债券，相对应，风险小于股票，大于债券。基金是一种间接投资，是委托专业的人员帮你理财，而专业人员往往会分散投资等等，基金公司将各种投资方案包装为一个个套餐供你选择；而专业人员如基金经理，可能会购买如股票，债券，银行存款等或者混合，来进行投资，并将收益转换为基金收益，返利给投资者等；而基金投资的东西不同，则有不同的基金分类，如股票基金，混合基金等；</li>
<li><p>因此：</p>
<ul>
<li>股票基金，收益大，风险高；</li>
<li>混合基金，收益中等，风险相对小；</li>
<li>债券基金，收益低，风险小；</li>
<li>还有一种指数基金：如果说普通的基金是由基金经理去主动挑选股票，债券等，那指数基金则是被动的跟踪某个指数来买入股票等组合；</li>
</ul>
</li>
<li><p>引用知乎上的一个解释：<br>指数就是一个选股规则。<br>指数基金它跟踪特定的指数，并按照这个指数成分股的比例买入同样的股票组合。<br>举个例子：学校选取校花有三个标准：身高1.68以上，腰围65cm以下，体重100斤以下。小A（身高1.71，腰围63cm，体重98斤）小B（身高1.70，腰围63cm，体重99斤）小C （身高1.69，腰围64cm，体重98斤）她们三个的身高，体重，腰围都符合选校花的三个标准，就被分到校花之列。<br>而有一天小B由于最近夜宵吃多了长胖了，体重达到了102，那么她就被踢出校花之列，而小D的身高，体重，腰围达标，她就被分到校花之列，只要选择校花的标准不变，就会有源源不断的符合校花条件的人列入其中。<br>计算纳入校花的人群各自美貌分，在加权平均一下，变成一个校花指数。<br>所以，金融市场上的指数的编制，就注定了会有源源不断的好公司被纳入指数中来。而且指数基金，不需要基金经理主动选股，直接买这些指数背后的成分股，构成对应的指数基金。  </p>
</li>
</ul>
<h4 id="为什么指数基金值得投资："><a href="#为什么指数基金值得投资：" class="headerlink" title="为什么指数基金值得投资："></a>为什么指数基金值得投资：</h4><p>1) 不依赖基金经理选股，而是依赖特定指数；<br>2）不依赖某家公司，公司倒闭了，也不受影响；<br>3）指数基金通过投资指数成分股来获得和市场持平的收益，所以长期看好就有收益；  </p>
<h4 id="基金中的名词概念："><a href="#基金中的名词概念：" class="headerlink" title="基金中的名词概念："></a>基金中的名词概念：</h4><ul>
<li>净值：基金单位净值即每份基金单位的净资产价值，等于基金的总资产减去总负债后的余额再除以基金全部发行的单位份额总数</li>
<li>申购和申购费率：认购费与申购费性质相似，都是向基金管理人购买基金单位时所支付的手续费<h4 id="基金的相关时间："><a href="#基金的相关时间：" class="headerlink" title="基金的相关时间："></a>基金的相关时间：</h4></li>
<li>基金交易时间：指开放式基金接受申购、转换、赎回或其它交易的时间段。<br>基金主要投资于股票和债券，所以交易时间和股票的开盘时间相同。一般为周一至周五上午9：30-下午3：00，国家法定假日除外，因此这和我们平时说的工作日并不完全相同。  </li>
<li>T日交易规则：<br>T日交易规则中的T日指的是不包括周末和节假日的交易日，一般以股市收市时间15:00为界。<br>一般来说，如果在交易日的15:00前申购，会按当天的净值计算，当天的净值一般在晚上8-10点更新后查看；如果在交易日3点之后购买，那么则按照下个交易日（T+1）当天的净值，具体以基金购买后被确认的信息为准。<br>在提交申购申请的T+1日，基金公司会确认份额，也就是交易确认日。在提交申购申请的T+2日可以查看基金的收益，也就是收益查看日。<br>这里要注意的是，我们在买入基金的时候其实并不知道买入的价格，因为具体的净值要等到当天收盘，基金公司根据收盘价计算后才会更新。  </li>
</ul>
<p>举例来说：<br>小明预计下周一市场上涨，因此在周五收盘后提交了订单，但是这和小红在周一下午3点前提交订单是一个效果，都是以周一收盘价计算，而周一的上涨和他都没有关系。因此，在当天下午2点左右操作是一个最佳时间点，因为越接近下午三点买入，就越接近收盘价格。  </p>
<ul>
<li>赎回时间：<br>一般的开放式基金赎回的流程为：T日卖出→ T+1确认→T+3到账。<br>赎回和购买时一样，如果在交易日下午3点前赎回，会按照当天收盘价格计算净值，如果在下午3点后申报赎回，赎回的基金净值则会按照下一个工作日的基金净值计算，资金一般在T+3日到账。<br>不过，具体的基金到账时间要根据实际情况为准，可以在每只基金的交易规则中查看。  </li>
</ul>
<h4 id="基金怎么算收益："><a href="#基金怎么算收益：" class="headerlink" title="基金怎么算收益："></a>基金怎么算收益：</h4><p>申购：<br>用1万元申购某基金，申购费率是1.5％，该基金当日净值是1.2000。<br>申购手续费＝10000.00×1.5％＝150.00(元)<br>申购份额＝(10000.00－150.00)÷1.2000＝8208.33(份)<br>赎回：<br>      1个月后赎回该基金，当日净值是1.4000，赎回费率是0.5％。<br>      赎回总额＝8208.33×1.4000＝11491.66(元)<br>      赎回手续费＝11491.66×0.5％＝57.46(元)<br>      赎回净额＝11491.66－57.46＝11434.20(元)<br>      净收益＝11434.20－10000.00＝1434.20(元)</p>
<h3 id="买基金需要看什么："><a href="#买基金需要看什么：" class="headerlink" title="买基金需要看什么："></a>买基金需要看什么：</h3><h4 id="持仓-规模，增长曲线，历史收益，净值估算，最大回撤，基金公告；"><a href="#持仓-规模，增长曲线，历史收益，净值估算，最大回撤，基金公告；" class="headerlink" title="持仓,规模，增长曲线，历史收益，净值估算，最大回撤，基金公告；"></a>持仓,规模，增长曲线，历史收益，净值估算，最大回撤，基金公告；</h4><ul>
<li>持仓：在蛋卷基金或其他基金软件，通过详情可以看到持仓，从而可以看到这个基金购买的公司股票或具体实体。以此判断公司和行业是否值得购买，是否是估值偏高等；</li>
<li>规模：通过详情可以看到规模，即这个基金有多少规模，投入多少money,一般越大越好，即基金净值乘以总数，净值受股价和供需的影响，一般购买规模大的比较稳定，比如100亿以上的；</li>
<li>增长曲线，通过净值年曲线，月曲线等，可以看到这个基金的总体收益等情况；</li>
<li>净值估算：比如支付宝可以看到实时的基金净值估算，从而判断改天的净值走势；</li>
<li>最大回撤： 即最大跌幅是多少；</li>
<li>基金公告：有些基金会进入封闭期等，此时可以通过公告来看什么时候开放等；</li>
</ul>
<h4 id="公司财报"><a href="#公司财报" class="headerlink" title="公司财报"></a>公司财报</h4><p>买股票和基金等，其实是在对公司的投资，所以需要对公司进行分析，只有公司，企业盈利，发展好等，才能有更大的上涨；而分析公司财报，可以看出这家公司的盈利情况等等；<br>公司财报没怎么看过，所以没啥记录的，只有一点宏观的：  </p>
<ul>
<li>A  衡量一个公司的还坏，营收能力，需要看以下几个点：<br>应付预收<ul>
<li>1)应付：【先用货，后给钱】，我大海天要产酱油了，我没有黄豆了，我先跟供货商说，你把豆子给我，然后我晚点结账。帅吧！不给钱就能空手套白狼</li>
<li>2)预收：【先收钱，后发货】，我跟经销商说，我酱油马上做好了，你先打钱，然后我再给你发货。快打钱，不打钱没货了啊，别人订走了。牛吧，先给钱后发货。</li>
</ul>
</li>
</ul>
<p>应收预付</p>
<ul>
<li>1)应收：【先发货，收不到钱】，我先发酱油给经销商，但是人家不给我钱，谁让他卖得好呢。哎不牛了。</li>
<li>2)预付：【先给钱，收不到货】，哎，我黄豆钱都打过去了，黄豆还没给我呢，谁让人既黄豆好呢。不帅。不牛。<ul>
<li>B:通过什么科目判断公司的安全性：？<br>资产负债率：=总负债/总资产；负债率大于70%的公司偿债风险比较大，而小于40%的几乎没有偿债风险；<br>股票可以参考A,B指标来购买；</li>
<li>C:如何下载上市公司的财报：<br><a href="http://www.cninfo.com.cn/new/index巨潮资讯网；" target="_blank" rel="noopener">http://www.cninfo.com.cn/new/index巨潮资讯网；</a><br>财报分析看结构，有23个步骤；</li>
<li>D:找工作跳槽等也是可以参考该上市公司的财务报表情况来看这家公司是不是一家好公司；<br>要选择好的行业；</li>
</ul>
</li>
</ul>
<h4 id="公司的ROE等参数"><a href="#公司的ROE等参数" class="headerlink" title="公司的ROE等参数"></a>公司的ROE等参数</h4><ul>
<li><p>市盈率：<br>公司市值/公司盈利 (即PE=P/E),P为公司市值，E表示公司盈利；(市值是指一家上市公司的发行股份按市场价格计算出来的股票总价值，其计算方法为每股股票的市场价格乘以发行总股数）<br>反映了我们愿意为获取1元的净利润付出多少代价：比如一个公司的市盈率是10，则代表我们愿意为这个公司的1元盈利付出10元；<br>适用范围：流通性好，盈利稳定的品种；周期行业也不适用市盈率；</p>
</li>
<li><p>盈利收益率<br>市盈率的倒数：公司盈利除以公司市值 E/P，即收益率</p>
</li>
<li><p>市净率<br>每股股价与每股净资产的比率：账面价值；PB=P/B P：公司市值，B：公司净资产；(资产-负债)  —越小越好</p>
</li>
<li><p>ROE: 净资产收益率  净利润/净资产   ： ROE越高，则资产运作效率越高</p>
</li>
<li><p>股息率<br>股息：是公司现金分红除以公司的市值，得到的就是股息率了；–越高越好</p>
</li>
</ul>
<h4 id="什么时候开始定投？"><a href="#什么时候开始定投？" class="headerlink" title="什么时候开始定投？"></a>什么时候开始定投？</h4><p>盈利收益率大于10%时，开始定投，6.4%到10%时，坚持持有<br>盈利收益率低于6.4%时，分批卖出基金  </p>
<h3 id="基金的投资指南–参考《指数基金投资指南》"><a href="#基金的投资指南–参考《指数基金投资指南》" class="headerlink" title="基金的投资指南–参考《指数基金投资指南》"></a>基金的投资指南–参考《指数基金投资指南》</h3><p>这本书主要讲述，指数基金的投资：<br>包括指数基金的解释，<br>指数基金的分类和特点，涵盖宽基，行业指数等等，<br>基金的投资理念：价值投资，估值等方法；<br>如何定投和如何制定属于自己的投资计划；<br>家庭资产配置和如何做长期投资的心理建设，不被短期涨跌影响；<br>更多具体可以查，当工具书等；  </p>
<h3 id="我目前买的组合和持仓："><a href="#我目前买的组合和持仓：" class="headerlink" title="我目前买的组合和持仓："></a>我目前买的组合和持仓：</h3><p>目前主要关注螺丝钉和螺丝钉相关组合，通过蛋卷基金投资，另外一些自选主要有易方达系列，汇添系列，兴全系列，银华富裕主题混合，招行中证白酒指数，华夏上证50AH优选指数(LOF)A,沪深300大盘，钉钉宝365组合等等；  </p>
<h3 id="一些基金软件等："><a href="#一些基金软件等：" class="headerlink" title="一些基金软件等："></a>一些基金软件等：</h3><p>天天基金，蛋卷基金，易方达基金<br>东方财富，雪球</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>打算玩点美股，港股打新，正在学习和搞账号，下一篇记录下美股和美股的一些知识，比如做空等等是什么意思；</p>
]]></content>
      <categories>
        <category>Financial_management</category>
      </categories>
      <tags>
        <tag>Funds_and_stocks</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_template_class</title>
    <url>/2021/01/09/cpp-template-class/</url>
    <content><![CDATA[<h3 id="类模板的基本概念"><a href="#类模板的基本概念" class="headerlink" title="类模板的基本概念"></a>类模板的基本概念</h3><h3 id="类模板的引入："><a href="#类模板的引入：" class="headerlink" title="类模板的引入："></a>类模板的引入：<a id="more"></a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">一个例子：</span><br><span class="line">用类封装一个包含多操作的IntArray:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INTARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt; // for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;</span><br><span class="line">    <span class="keyword">int</span> *m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    IntArray()</span><br><span class="line">    &#123;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    IntArray(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(length &gt; <span class="number">0</span>);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~IntArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">用类封装一个包含多操作的DoubleArray:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOUBLEARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOUBLEARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt; // for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;</span><br><span class="line">    <span class="keyword">double</span> *m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DoubleArray()</span><br><span class="line">    &#123;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    DoubleArray(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(length &gt; <span class="number">0</span>);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">double</span>[length];</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~DoubleArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">以上两个定义内容只有里面的类型不同，那么为什么不忽略类型的差异，定义通用的容器？于是类模板出现：</span><br><span class="line">类模板的定义和使用：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt; // for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">This</span> <span class="title">is</span> <span class="title">a</span> <span class="title">template</span> <span class="title">class</span>, <span class="title">the</span> <span class="title">user</span> <span class="title">will</span> <span class="title">provide</span> <span class="title">the</span> <span class="title">data</span> <span class="title">type</span> <span class="title">for</span> <span class="title">T</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;<span class="comment">//注意这里可以指定具体类型；</span></span><br><span class="line">    T *m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array()</span><br><span class="line">    &#123;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Array(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> T[length];</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Array()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The length of the array is always an integer</span></span><br><span class="line">    <span class="comment">// It does not depend on the data type of the array</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>; <span class="comment">// templated getLength() function defined below</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// member functions defined outside the class need their own template declaration</span></span><br><span class="line"><span class="keyword">int</span> Array&lt;T&gt;::getLength() &#123; <span class="keyword">return</span> m_length; &#125; <span class="comment">// note class name is Array&lt;T&gt;, not Array</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">使用：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Array&lt;<span class="keyword">int</span>&gt; intArray(<span class="number">12</span>);</span><br><span class="line">	Array&lt;<span class="keyword">double</span>&gt; doubleArray(<span class="number">12</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; intArray.getLength(); ++count)</span><br><span class="line">	&#123;</span><br><span class="line">		intArray[count] = count;</span><br><span class="line">		doubleArray[count] = count + <span class="number">0.5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = intArray.getLength()<span class="number">-1</span>; count &gt;= <span class="number">0</span>; --count)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intArray[count] &lt;&lt; <span class="string">"\t"</span> &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类模板和标准库："><a href="#类模板和标准库：" class="headerlink" title="类模板和标准库："></a>类模板和标准库：</h3><p>从上面的例子可以看到，类模板定义的Array和Vector容器很类似，而类似vector的容器就是类模板实现的；</p>
<h3 id="模板类无法进行定义和函数实现的分离："><a href="#模板类无法进行定义和函数实现的分离：" class="headerlink" title="模板类无法进行定义和函数实现的分离："></a>模板类无法进行定义和函数实现的分离：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">如下例子，在链接时会出现问题：</span><br><span class="line">Array.h:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt; // for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;</span><br><span class="line">    T *m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array()</span><br><span class="line">    &#123;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Array(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> T[length];</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Array()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The length of the array is always an integer</span></span><br><span class="line">    <span class="comment">// It does not depend on the data type of the array</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">Array.cpp:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Array&lt;T&gt;::getLength() &#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">使用时：链接时出错</span><br><span class="line">main.cpp:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Array&lt;<span class="keyword">int</span>&gt; intArray(<span class="number">12</span>);</span><br><span class="line">	Array&lt;<span class="keyword">double</span>&gt; doubleArray(<span class="number">12</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; intArray.getLength(); ++count)</span><br><span class="line">	&#123;</span><br><span class="line">		intArray[count] = count;</span><br><span class="line">		doubleArray[count] = count + <span class="number">0.5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = intArray.getLength()<span class="number">-1</span>; count &gt;= <span class="number">0</span>; --count)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intArray[count] &lt;&lt; <span class="string">"\t"</span> &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```cpp</span><br><span class="line"></span><br><span class="line">为什么呢：？</span><br><span class="line">实例化模板的必要条件：</span><br><span class="line">   为了让编译器去使用一个模板，它必须看到包括模板定义(而不是只有一个声明),和用于实例化模板的模板类型如<span class="keyword">int</span>等；</span><br><span class="line">上述例子为什么不成功？</span><br><span class="line">   且记住C++是单独编译文件的；当Array.h头文件被包含到main时，模板类定义被拷贝到main.cpp,当编译器看到我们需</span><br><span class="line">要两个模板实例，Array&lt;<span class="keyword">int</span>&gt;和Array&lt;<span class="keyword">double</span>&gt;,它将实例化他们，且编译他们作为main.cpp中的一部分；</span><br><span class="line">然而，当他单独的获取和编译Array.cpp时，他已经忘记我们需要一个Array&lt;<span class="keyword">int</span>&gt;和Array&lt;<span class="keyword">double</span>&gt;（单独编译，看不到main),所以Array.cpp中的模板函数不会被实例化；因此会因为找不到函数getLength()的定义而得到链接错误；</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">   针对上述问题，有几种处理方式：</span><br><span class="line">     <span class="number">1</span>)把定义全放在.h头文件</span><br><span class="line">  <span class="number">2</span>)把 rename Array.cpp to Array.inl (.inl stands <span class="keyword">for</span> <span class="keyword">inline</span>), <span class="keyword">and</span> then include Array.inl from the bottom of the Array.h header. That yields the same result as putting all the code in the header, but helps keep things a little cleaner.</span><br><span class="line"> <span class="number">3</span>）在main中include所有：</span><br><span class="line"><span class="comment">// Ensure the full Array template definition can be seen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.cpp"</span> <span class="comment">// we're breaking best practices here, but only in this one place</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// #include other .h and .cpp template definitions you need here</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;int&gt;;</span> <span class="comment">// Explicitly instantiate template Array&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;double&gt;;</span> <span class="comment">// Explicitly instantiate template Array&lt;double&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// instantiate other templates here</span></span><br></pre></td></tr></table></figure>
<h3 id="模板类类参数多样性"><a href="#模板类类参数多样性" class="headerlink" title="模板类类参数多样性"></a>模板类类参数多样性</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">模板类参数可以是无类型，即某种特定的类型：</span><br><span class="line">A value that has an integral type <span class="keyword">or</span> enumeration</span><br><span class="line">A pointer <span class="keyword">or</span> reference to a <span class="class"><span class="keyword">class</span> <span class="title">object</span></span></span><br><span class="line"><span class="class"><span class="title">A</span> <span class="title">pointer</span> <span class="title">or</span> <span class="title">reference</span> <span class="title">to</span> <span class="title">a</span> <span class="title">function</span></span></span><br><span class="line"><span class="class"><span class="title">A</span> <span class="title">pointer</span> <span class="title">or</span> <span class="title">reference</span> <span class="title">to</span> <span class="title">a</span> <span class="title">class</span> <span class="title">member</span> <span class="title">function</span></span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="keyword">nullptr_t</span></span><br><span class="line">例子：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; // <span class="title">size</span> <span class="title">is</span> <span class="title">the</span> <span class="title">non</span>-<span class="title">type</span> <span class="title">parameter</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// The non-type parameter controls the size of the array</span></span><br><span class="line">    T m_array[size];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">getArray</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Showing how a function for a class with a non-type parameter is defined outside of the class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">StaticArray</span>&lt;T, size&gt;:</span>:getArray()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_array;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// declare an integer array with room for 12 integers</span></span><br><span class="line">    StaticArray&lt;<span class="keyword">int</span>, <span class="number">12</span>&gt; intArray;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Fill it up in order, then print it backwards</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">12</span>; ++count)</span><br><span class="line">        intArray[count] = count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">11</span>; count &gt;= <span class="number">0</span>; --count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intArray[count] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// declare a double buffer with room for 4 doubles</span></span><br><span class="line">    StaticArray&lt;<span class="keyword">double</span>, <span class="number">4</span>&gt; doubleArray;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">4</span>; ++count)</span><br><span class="line">        doubleArray[count] = <span class="number">4.4</span> + <span class="number">0.1</span>*count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">4</span>; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类模板的特化"><a href="#类模板的特化" class="headerlink" title="类模板的特化"></a>类模板的特化</h3><p>什么是类模板的特化，为什么需要，什么时候使用？<br>类模板的特化和函数模板特化类似，当我们定义了一个类模板后，这个类模板可以实例成int ,bool,char等等类型，都是同样的处理逻辑；<br>当我们想针对bool特殊化，比如bool本身用一个bit就可以实现，节省空间，时，可以用类模板的特化，来为实例成bool时定义一个类模板的特化，这样，bool就和其他int等不同了；</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage8</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_array[<span class="number">8</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_array[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">特化<span class="keyword">bool</span>:</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// the following is a template class with no templated parameters</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage8</span>&lt;bool&gt; // <span class="title">we</span>'<span class="title">re</span> <span class="title">specializing</span> <span class="title">Storage8</span> <span class="title">for</span> <span class="title">bool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// What follows is just standard class implementation details</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Storage8() : m_data(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">bool</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Figure out which bit we're setting/unsetting</span></span><br><span class="line">        <span class="comment">// This will put a 1 in the bit we're interested in turning on/off</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> mask = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (value)  <span class="comment">// If we're setting a bit</span></span><br><span class="line">            m_data |= mask;  <span class="comment">// Use bitwise-or to turn that bit on</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// if we're turning a bit off</span></span><br><span class="line">            m_data &amp;= ~mask;  <span class="comment">// bitwise-and the inverse mask to turn that bit off</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Figure out which bit we're getting</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> mask = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">        <span class="comment">// bitwise-and to get the value of the bit we're interested in</span></span><br><span class="line">        <span class="comment">// Then implicit cast to boolean</span></span><br><span class="line">        <span class="keyword">return</span> (m_data &amp; mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Define a Storage8 for integers (instantiates Storage8&lt;T&gt;, where T = int)</span></span><br><span class="line">    Storage8&lt;<span class="keyword">int</span>&gt; intStorage;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count&lt;<span class="number">8</span>; ++count)</span><br><span class="line">        intStorage.<span class="built_in">set</span>(count, count);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count&lt;<span class="number">8</span>; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intStorage.get(count) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Define a Storage8 for bool  (instantiates Storage8&lt;bool&gt; specialization)</span></span><br><span class="line">    Storage8&lt;<span class="keyword">bool</span>&gt; boolStorage;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count&lt;<span class="number">8</span>; ++count)</span><br><span class="line">        boolStorage.<span class="built_in">set</span>(count, count &amp; <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count&lt;<span class="number">8</span>; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (boolStorage.get(count) ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板的偏特化"><a href="#模板的偏特化" class="headerlink" title="模板的偏特化"></a>模板的偏特化</h3><p>区别于前文说的特化，偏特化指的是部分的特化，比如两个模板类型，将其中一个特化了，或者是<br>特化为指针等等；见下面例子：</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 两个类型特化了其中一个</span><br><span class="line">泛化：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">特化：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&lt;bool,Alloc&gt;//在类型化时，若传入的第一个参数为<span class="title">bool</span>，则用以下版<span class="title">zf</span>本；</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="偏特化为指针"><a href="#偏特化为指针" class="headerlink" title="偏特化为指针"></a>偏特化为指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">泛化：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="keyword">int</span> ittt;</span><br><span class="line">&#125;;</span><br><span class="line">偏特化：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>*&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="keyword">double</span> ittt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_template</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_template_func</title>
    <url>/2021/01/09/cpp-template-func/</url>
    <content><![CDATA[<h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>为什么需要函数模板：类型限制了函数的通用性，参数换一种类型，即得重新再定义一个处理流程相同的函数；<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>,ints等等，甚至实现了&gt;运算符函数的类也是如此；</span><br></pre></td></tr></table></figure></p>
<h3 id="什么是函数模板："><a href="#什么是函数模板：" class="headerlink" title="什么是函数模板："></a>什么是函数模板：</h3><p>In C++, function templates are functions that serve as a pattern for creating other similar functions.<br>在c++中，函数模板即是能作为一个模式来创建其他相似函数的一组函数；<br>在c++函数模板中，我们使用占位符来替代部分或全部的函数中具体类型的变量；<br>返回值，形参，以及函数内定义的局部变量等都能使用；<br>typename和class 的区别：<a href="http://www.cplusplus.com/forum/general/8027/" target="_blank" rel="noopener">http://www.cplusplus.com/forum/general/8027/</a></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;                                                             </span></span></span><br><span class="line"><span class="comment">//using namespace std;导入这个为什么会出错？这里也定义了min函数，那么会冲突？                            </span></span><br><span class="line"><span class="keyword">using</span>  <span class="built_in">std</span>::<span class="built_in">cout</span>;                                                              </span><br><span class="line"><span class="keyword">using</span>  <span class="built_in">std</span>::<span class="built_in">endl</span>;                                                              </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                          </span><br><span class="line">   <span class="comment">/* T min( T x, T y)&#123; </span></span><br><span class="line"><span class="comment">            T t=x;                                          </span></span><br><span class="line"><span class="comment">        return (x+t&gt;y)?y:x;                                                      </span></span><br><span class="line"><span class="comment">&#125;   */</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">( T x, T y)</span></span>&#123;                                       </span><br><span class="line">        <span class="keyword">return</span> (x&gt;y)?y:x;                                                      </span><br><span class="line">&#125;                                                                               </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>                                                                    </span></span><br><span class="line"><span class="function"></span>&#123;                                                                              </span><br><span class="line">    <span class="keyword">int</span> i = min(<span class="number">3</span>,<span class="number">4</span>);                                                          </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;                                                             </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="keyword">double</span> d=min(<span class="number">6.38</span>,<span class="number">12.32</span>);                                                  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;                                                             </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="keyword">char</span> ch=min(<span class="string">'a'</span>,<span class="string">'6'</span>);                                                      </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;                                                            </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">建议，这里的模板定义加上<span class="keyword">const</span>和使用引用会更好，使用引用的原因是传入的参数有可能是类类型(这样参数类型和返回值应为引用更通用），使用<span class="keyword">const</span>是为了避免对传入参数的原变量造成影响；如下：</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">const</span> T&amp; min(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)&#123;</span><br><span class="line">        <span class="keyword">return</span> (x&gt;y)?y:x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="更多使用例子"><a href="#更多使用例子" class="headerlink" title="更多使用例子"></a>更多使用例子</h4><p>用于类类型:注意类需要实现对应的运算符函数等；<br>模板类型和实际类型混合<br>指针类型：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">average</span>(<span class="title">T</span> *<span class="title">array</span>, <span class="title">int</span> <span class="title">length</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; length; ++count)</span><br><span class="line">        sum += <span class="built_in">array</span>[count];</span><br><span class="line"> </span><br><span class="line">    sum /= length;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多个模板类型</p>
<h3 id="假设这里我传入了int-会怎么样？"><a href="#假设这里我传入了int-会怎么样？" class="headerlink" title="假设这里我传入了int* 会怎么样？"></a>假设这里我传入了int* 会怎么样？</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">来看一个例子：指针的话会优先匹配指针</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;导入这个为什么会出错？这里也定义了min函数，那么会冲突？                            </span></span><br><span class="line"><span class="keyword">using</span>  <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span>  <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">   <span class="comment">/* T min( T x, T y)&#123; </span></span><br><span class="line"><span class="comment">            T t=x;                                          </span></span><br><span class="line"><span class="comment">        return (x+t&gt;y)?y:x;                                                      </span></span><br><span class="line"><span class="comment">&#125;   */</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">( T* x, T* y)</span></span>&#123;<span class="comment">//这样的话，这里的x实际上是指针类型，比如传入int* ==&gt; T* ，要返回int的话，得对x做*，如*x</span></span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"real"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> (*x&gt;*y)?*y:*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*template&lt;typename T&gt; 模板只能匹配参数，不能匹配返回值，所以这里和上面的是重复的；编译会报错；</span></span><br><span class="line"><span class="comment">T* min(T* x,T* y)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">     return (x&gt;y)?y:x;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T x,T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = min(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> d=min(<span class="number">6.38</span>,<span class="number">12.32</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch=min(<span class="string">'a'</span>,<span class="string">'6'</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//以上匹配的是非指针的版本+</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"now pointer"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> m =<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> jj=min(&amp;m,&amp;n); <span class="comment">//这里匹配的是指针的</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m:"</span>&lt;&lt;&amp;m&lt;&lt;<span class="string">"n:"</span>&lt;&lt;&amp;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(&amp;m,&amp;n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;jj&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">~</span><br></pre></td></tr></table></figure>
<h3 id="函数模板的特化-什么时候需要"><a href="#函数模板的特化-什么时候需要" class="headerlink" title="函数模板的特化 什么时候需要"></a>函数模板的特化 什么时候需要</h3><p>引入：有时候，针对具体的类型，我们想定义具体的函数，而不是用模板中对所有类型通用的函数时，可以定义一个函数模板的特化函数；<br>语法：<br>eg</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Storage(T value)</span><br><span class="line">    &#123;</span><br><span class="line">         m_value = value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Storage()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Define some storage units</span></span><br><span class="line">    Storage&lt;<span class="keyword">int</span>&gt; nValue(<span class="number">5</span>);</span><br><span class="line">    Storage&lt;<span class="keyword">double</span>&gt; dValue(<span class="number">6.7</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print out some values</span></span><br><span class="line">    nValue.print();</span><br><span class="line">    dValue.print();</span><br><span class="line">&#125;</span><br><span class="line">那么当我们想针对<span class="keyword">double</span>有个特殊专属的print函数时，应该怎么做？</span><br><span class="line">答案是针对其写一个函数：特化：</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Storage&lt;<span class="keyword">double</span>&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::scientific &lt;&lt; m_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">这样，当编译器实例化模板时，<span class="keyword">double</span>时，就会使用这个特化的print;</span><br><span class="line">The template &lt;&gt; tells the compiler that this is a template function, but that there are no template parameters (since in this case, we’re explicitly specifying all of the types). Some compilers may allow you to omit this, but it’s proper to include it.</span><br></pre></td></tr></table></figure>
<h3 id="类相关例子："><a href="#类相关例子：" class="headerlink" title="类相关例子："></a>类相关例子：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类模板的构造函数也可以这样处理：</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span>*&gt;::Storage(<span class="keyword">char</span>* value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Figure out how long the string in value is</span></span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (value[length] != <span class="string">'\0'</span>)</span><br><span class="line">        ++length;</span><br><span class="line">    ++length; <span class="comment">// +1 to account for null terminator</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Allocate memory to hold the value string</span></span><br><span class="line">    m_value = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Copy the actual value string into the m_value memory we just allocated</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; length; ++count)</span><br><span class="line">        m_value[count] = value[count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_template</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_template_deepin</title>
    <url>/2021/01/09/cpp-template-deepin/</url>
    <content><![CDATA[<h3 id="模板是什么，为什么要引入模板："><a href="#模板是什么，为什么要引入模板：" class="headerlink" title="模板是什么，为什么要引入模板："></a>模板是什么，为什么要引入模板：</h3><p>模板是用来生成代码的，通过模板可以定义一组类型的共同行为；<br>为什么要引入模板：<br>继承和组合是实现重用代码的方法，而容器也是，为了实现能承载不同类型的容器，java等其他语言用所有类都继承于根类型等方式，<a id="more"></a><br>而c++这里为了减少不必要的开支，和冗余，采用预定义等方式，在预处理和编译时，将T替换为实际类型参数，并生成对应的类型；<br>来从而实现了容器；<br>所以说：模板的引入，是为了实现容器的需求；</p>
<p>那么容器呢？为什么容器被需要？<br>栈的内存管理依赖于函数本身，或者说操作系统，在函数的调用结束后，会回收相关的存于栈的结构，所以不用我们去考虑清理的事情；<br>但是当我们在堆上使用时，malloc/new后，往往需要free/delete,在传统的c中，malloc后会需要进行free，否则程序运行时会出现内存泄漏；<br>容器的真正需求，是在这种情景下，减轻程序员的负担，担负起自动new和清理的工作；</p>
<p>c++是怎么做的？ c++标准容器，用new创建需要的对象，将其指针放入容器中，实际使用时取出并处理，这种方法创建的只是对象，<br>清理时依赖析构函数时进行合理的free；不过需要注意，当存储的对象是指针时，此时的指针需要程序员自己去new和释放；<br>同时为了支持承载多种类型的对象，所以模板就被创建出来；</p>
<h3 id="模板的基本原理："><a href="#模板的基本原理：" class="headerlink" title="模板的基本原理："></a>模板的基本原理：</h3><p>为了解决多类型：有几个方法，模板采用的是第三个：<br>1) c方法复制粘贴代码<br>2) 继承来实现代码重用，但是需要学习基础类库<br>3) 实现类似宏替换的逻辑，并放到编译器中，编译器识别到类似声明，就进行替换，从而重新生成类定义等，也取消类型的指定；而容器的实现则是<br>    以堆来存放一组特定类型对象。类似对象数组等；</p>
<h3 id="模板是怎么工作的，工程上，内部结构等，编译器的作用；"><a href="#模板是怎么工作的，工程上，内部结构等，编译器的作用；" class="headerlink" title="模板是怎么工作的，工程上，内部结构等，编译器的作用；"></a>模板是怎么工作的，工程上，内部结构等，编译器的作用；</h3><h4 id="1）工程文件上，如何预编译，编译，链接等；"><a href="#1）工程文件上，如何预编译，编译，链接等；" class="headerlink" title="1）工程文件上，如何预编译，编译，链接等；"></a>1）工程文件上，如何预编译，编译，链接等；</h4><p> 模板中分为函数模板和类模板：<br>类模板：定义和成员函数实现都是写在头文件中<br>函数模板：定义声明等都是写在头文件中；<br>模板编译模型：<br>模板的完整定义都是放在每个编译单元中；例如完全放在单个文件程序中，或者放在文件程序的头文件中；和传统的编程方式背道而驰；</p>
<h5 id="1-传统的为什么要这么做？—分离模型："><a href="#1-传统的为什么要这么做？—分离模型：" class="headerlink" title="(1) 传统的为什么要这么做？—分离模型："></a>(1) 传统的为什么要这么做？—分离模型：</h5><p>不要放置分配存储空间的任何东西(这条规定是为了防止在链接期间的多重定义错误)，编译期间是单个文件的，此时不会出现，但是链接的时候是多个实现文件，若是头文件里也定义了，就会导致链接的时候多重定义，而编译器对此并没有去重；</p>
<p>头文件中的非内联函数体会导致多函数的定义，从而导致链接错误；<br>隐藏来自客户有益函数实现，减少了编译时链接；<br>隐藏代码，代码所有权；<br>头文件越小，编译时间越短；</p>
<h5 id="2-模板时包含模型，那这样客户代码想隐藏怎么办？"><a href="#2-模板时包含模型，那这样客户代码想隐藏怎么办？" class="headerlink" title="(2) 模板时包含模型，那这样客户代码想隐藏怎么办？"></a>(2) 模板时包含模型，那这样客户代码想隐藏怎么办？</h5><p>在template&lt;..&gt;后的任何东西都意味着编译器在当时不为它分配存储空间，而是一直处于等待状态直到一个模板示例告知，而此时是编译器在碰到模板示例时，往往是编译期间，然后生成对应的类，然后在运行时，才分配对象的空间；在编译器和连接器中有机制能去掉同一模板的多重定义；所以为了使用方便，几乎总是在头文件中放置全部的模板声明和定义；</p>
<p>模板代码本质上只是产生代码的指令，不是真正的代码，只有实例化了才是，一个编译器在编译期间看到模板的完整定义后，在同一个翻译单元中碰到模板实例化点时，也会在其他翻译单元碰到同样的实例化点，这样就会重复生成实例化代码；而编译器和连接器需要解决这个重复定义；<br>这种有两个缺点：<br>a  编译时间增加  b 无法隐藏实现代码；<br>如何处理？ 如何实现分离？<br>一种是显示实例化，一种是导出模板：<br>显示实例化：<br>    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	eg:</span><br><span class="line">ourMin.h :</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OURMIN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OURMIN_H</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">ourMin.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ourMin.h"</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (a&lt;b)?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UseMin1.cpp:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"outMin.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usemin1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;min(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UseMin2.cpp:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">#Include <span class="string">"outMin.h"</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usemin2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;min(<span class="number">3.2</span> ,<span class="number">4.3</span>) &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.cpp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usemin1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usemin2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    usemin1();</span><br><span class="line">    usemin2();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>建立这个程序式，连接器报告有未解析的min<int>() 和min<double>()的外部引用； 因为编译器在min的特化时，只有min的声明可见，定义不可见，编译器认为它可能来自于其他单元，所以即没有实例化，问题留给了连接器，连接器无法找到；<br>所以可用加一个显示实例化来进行，即显示特化：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Minstances.cpp:</span><br><span class="line">#Include <span class="string">"ourMin.cpp"</span><span class="comment">//因为编译器需要模板定义来实例化；</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">const</span> <span class="keyword">int</span>&amp; min&lt;min&gt;(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;);</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">const</span> <span class="keyword">double</span>&amp; min&lt;<span class="keyword">double</span>&gt; (<span class="keyword">const</span> <span class="keyword">double</span> &amp;,<span class="keyword">const</span> <span class="keyword">double</span>&amp;);</span><br></pre></td></tr></table></figure></double></int></p>
<p>导出模板：<br>export关键字： </p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-模板定义的几种方式："><a href="#2-模板定义的几种方式：" class="headerlink" title="2)模板定义的几种方式："></a>2)模板定义的几种方式：</h4><p>声明和内联函数的形式<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span> :</span><br><span class="line">       AA ()&#123;&#125;;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;...&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">声明和非内联函数的形式；</span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="title">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">          <span class="keyword">enum</span> &#123; size = <span class="number">1000</span>&#125;;</span><br><span class="line">          T A[size];</span><br><span class="line">          <span class="keyword">public</span>:</span><br><span class="line">               T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">    &#125;;</span><br><span class="line">       <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="title">T</span>&amp; <span class="title">Array</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line">               .....</span><br><span class="line">              <span class="keyword">return</span> A[index];</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>声明在头文件，定义在cpp的显示实例化，注意需要cpp加显示实例声明，见上面2</p>
<h4 id="3）模板的一些使用技巧：-在stl源码解析中："><a href="#3）模板的一些使用技巧：-在stl源码解析中：" class="headerlink" title="3）模板的一些使用技巧： 在stl源码解析中："></a>3）模板的一些使用技巧： 在stl源码解析中：</h4><pre><code>涉及以下几种： 类型萃取，迭代器，智能指针(引用释放等) ,泛型算法等等；
</code></pre><h3 id="模板的使用细节："><a href="#模板的使用细节：" class="headerlink" title="模板的使用细节："></a>模板的使用细节：</h3><h4 id="1-模板参数：-类型-基础或用户自定义-编译时常数值-整数，指针或某些静态实体的引用，通常作为无类型模板参数，支持默认参数-其他模板；"><a href="#1-模板参数：-类型-基础或用户自定义-编译时常数值-整数，指针或某些静态实体的引用，通常作为无类型模板参数，支持默认参数-其他模板；" class="headerlink" title="1) 模板参数： 类型(基础或用户自定义), 编译时常数值(整数，指针或某些静态实体的引用，通常作为无类型模板参数，支持默认参数),其他模板；"></a>1) 模板参数： 类型(基础或用户自定义), 编译时常数值(整数，指针或某些静态实体的引用，通常作为无类型模板参数，支持默认参数),其他模板；</h4><p>模板类型参数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line">     ....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">template</span>&lt;class&gt; <span class="title">class</span> <span class="title">Seq</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Container</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Seq&lt;T&gt; seq;<span class="comment">//通知编译器，Seq是一个模板；本例子中Seq代表Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">使用：Container&lt;<span class="keyword">int</span>,Array&gt; container;</span><br><span class="line">还可以支持标准库中的容器：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">template</span>&lt;class U,class = allocator&lt;U&gt;&gt;  <span class="title">class</span> <span class="title">Seq</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Container</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Seq&lt;T&gt; seq;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用： Container<int ,vector=""> xxx;实际上容器适配器就是用类似的方法实现的，如stack<br>typename关键字用法；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">当在模板中用T::id这种类型时，编译器会默认解析为T类中的静态成员id,而不会认为这个是一个内部类，所以，当用法为：</span><br><span class="line">T::id i ;这种定义变量的方式时，会出错，此时需要向编译器说明这个是一个嵌套类；</span><br><span class="line">所以<span class="keyword">typename</span>在这里的作用： <span class="number">1</span>) 声明是一个类型，<span class="number">2</span>）可以替换<span class="class"><span class="keyword">class</span> <span class="title">template</span>&lt; typename T&gt; <span class="title">class</span> <span class="title">X</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">typename</span>并不能起到定义新类型的作用，可以用<span class="keyword">typedef</span> <span class="keyword">typename</span> Seq&lt;it&gt;::iterator It;类似的</span><br></pre></td></tr></table></figure></int></p>
<p>template关键字的作用：<br>1）声明模板<br>2）模板中遇到&gt; &lt;等和模板的&gt; &lt;混合时，用template声明；</p>
<h4 id="2-成员模板；"><a href="#2-成员模板；" class="headerlink" title="2)成员模板；"></a>2)成员模板；</h4><p>就是在类模板中定义一个新的内部类模板：<br>eg:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Outer</span>&#123;</span></span><br><span class="line">     <span class="keyword">public</span> :</span><br><span class="line">         <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>&gt; <span class="title">class</span> <span class="title">inter</span>&#123;</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                 <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">template</span>&lt;class R&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Outer</span>&lt;T&gt;:</span>:inter&lt;R&gt;::g() &#123;</span><br><span class="line">      ..</span><br><span class="line">&#125;</span><br><span class="line">使用：</span><br><span class="line"> Outer&lt;<span class="keyword">int</span>&gt;::inter&lt;<span class="keyword">bool</span>&gt; interr;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-有关函数模板的内容"><a href="#3-有关函数模板的内容" class="headerlink" title="3) 有关函数模板的内容"></a>3) 有关函数模板的内容</h4><p>1) 函数模板定义了一簇函数； —函数模板参数的类型如何推断：涉及一些参数可以省略的问题<br>2) 函数模板重载：其实是直接定义了普通函数，这样若是符合普通函数的类型则调用的是定义的普通函数，否则是模板生成；<br>3）以一个已生成的函数模板地址作为参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T*)</span> </span>&#123;&#125;</span><br><span class="line">void h(void (*pf)(int*)) &#123;&#125;</span><br><span class="line">template&lt;typename T&gt;void g(void (*pf)(T*)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">    h(&amp;f&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">    h(&amp;f);</span><br><span class="line">    g&lt;<span class="keyword">int</span>&gt;(&amp;f&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">    g&lt;<span class="keyword">int</span>&gt;(&amp;f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4)将函数用到stl序列容器中：TODO<br>5）函数模板的半有序： 即T, T<em>,const T</em>的区分，优先匹配特化程度最高的那个模板；他们的特化程度逐渐递增；</p>
<h4 id="4-模板特化相关"><a href="#4-模板特化相关" class="headerlink" title="4)模板特化相关"></a>4)模板特化相关</h4><p>显示特化：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>&amp; min&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(.....)</span><br></pre></td></tr></table></figure></p>
<p>半特化：<br>比如有两个参数，只限定了其中一个类型；<br>防止代码膨胀– TODO</p>
<h4 id="5-模板中的名称查找问题"><a href="#5-模板中的名称查找问题" class="headerlink" title="5)模板中的名称查找问题"></a>5)模板中的名称查找问题</h4><p>编译器解析模板定义，并寻找明显的语法错误，还要对其所能解析的所有名称进行解析；对于不依赖模板参数的名称，编译器使用普通名称查找解析他们，不能解析的就是关联名称，只有等到实例化才知道；<br>模板和友元：  –TODO</p>
<h4 id="6-模板编程中的习语"><a href="#6-模板编程中的习语" class="headerlink" title="6)模板编程中的习语:"></a>6)模板编程中的习语:</h4><p>1) 特征：将与某种类型相关联的所有声明绑定在一起的实现方式；<br>2）策略： 其实就是类似萃取类型；<br>3）神奇的递归模板，在编译期间就算出来值了；运行时只需要读取即可</p>
<h4 id="7-模板元编程："><a href="#7-模板元编程：" class="headerlink" title="7)模板元编程："></a>7)模板元编程：</h4><p>1） 编译时编程 :模板中编译时循环，循环分解，编译时选择，编译时断言—即利用模板，在编译时就算出值，减少运行开销哈<br>2)  表达式模板：</p>
<h4 id="8-模板与继承：-模板实例也可以作为被继承方；"><a href="#8-模板与继承：-模板实例也可以作为被继承方；" class="headerlink" title="8)模板与继承： 模板实例也可以作为被继承方；"></a>8)模板与继承： 模板实例也可以作为被继承方；</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xx</span>:</span> <span class="keyword">public</span> tes&lt;A&gt; &#123;&#125;;</span><br><span class="line">模板其他资料；见书：c++ templates,the complete guide</span><br></pre></td></tr></table></figure>
<h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><p>懒惰初始化，使用时才分配空间，读写时分配<br>存放指针对象时，为了避免多重释放，可以实现所有权函数，拥有所有权的才有释放的权利 owns函数</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref:"></a>ref:</h3><p>c++编程思想；</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_template</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb基础</title>
    <url>/2020/07/11/gdb%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>1、总体<br>GDB可以做四种主要的事情（以及支持这些事情的其他事情）来帮助您捕获行为中的错误：<br><a id="more"></a><br>1）启动程序，并指定可能影响其行为的所有内容。<br>2）使程序在指定条件下停止。<br>3）检查程序停止时发生的情况。<br>4）更改程序中的内容，以便您可以尝试纠正一个错误的影响，然后继续学习另一个错误。<br>2、一个例子：<br>gdb 调试运行一个程序：<br>$ gdb m4  –运行<br>(gdb) set width 70 –设置显示最大字符数，类似more<br>(gdb) break m4_changequote   –设置断点，断点可以是某个函数，如main<br>Breakpoint 1 at 0x62f4: file builtin.c, line 879.<br>(gdb) run<br>Starting program: /work/Editorial/gdb/gnu/m4/m4  –开始运行<br>(gdb) n   –next 不进入函数运行，运行下一行；<br>(gdb) s  –step 运行下一行，遇到函数会进入</p>
<p>(gdb) bt –backtrace 打印调用栈<br>(gdb) p lquote  –打印变量lquote,这个是变量名<br>(gdb) p 表达式，这个表达式可以是符合语法的表达式，比如赋值语句和函数调用等，是生效的；<br>eg (gdb) p ++a</p>
<p>$1 = 0x35d40 “<quote>“<br>(gdb) l    —list，显示源代码<br>533             xfree(rquote);<br>(gdb) Ctrl-d –退出程序<br>(gdb)quit  /q –退出gdb<br>3、经常使用分类<br>3.1 如何开始：<br> 1）gdb programname<br>        2）gdb programname corefile<br>        3)  gdb  programname pid   / gdb -p pid  (关联上一个-g编译过的正在运行的进程)<br>        4)  gdb –args programname arg1 2 3….<br>        eg:gdb –args gcc -O2 -c foo.c<br>        5) gdb xx     –silent/–quit /-q 不用输出信息<br>3.2 在gdb中也可以使用shell指令：<br>(gdb) !ifconfig</quote></p>
<p>3.3 设置log文件<br>使用技巧：<br>1）回车表示重复上一个命令，除了run等；<br>2）step 数字，可以表示步进多少<br>3.4 设置打印方式：<br>1)要更改要打印的数组元素的限制<br>(gdb)set print elements 10<br>2)是否打印数组：<br>       (GDB) set print array on<br>       (GDB) print some_array<br>       (GDB) set print array off<br>3.5 gdb的自动补全，按tab即可，甚至可以补全函数名；<br>3.6 gdb 命令有option ,tab键可以召唤出来；<br>3.7 gdb和线程；<br>3.8 gdb的栈概念<br>4  常见命令<br>gdb栈查看命令<br>backtrace [option]… [qualifier]… [count]<br>bt [option]… [qualifier]… [count]<br>(gdb) frame 3<br>(gdb) frame level 3<br>(gdb) info frame<br>Stack level 1, frame at 0x7fffffffda30:<br>向上或向下跳帧；<br>up n<br>down n </p>
<p>(gdb) frame apply all p j</p>
<p>#0  some_function (i=5) at fun.c:4<br>No symbol “j” in current context.<br>(gdb) frame apply all -c p j</p>
<p>#0  some_function (i=5) at fun.c:4<br>No symbol “j” in current context.<br>打印变量：p<br>显示源码 l</p>
<p>5 参考资料</p>
<p><a href="https://scc.ustc.edu.cn/zlsc/sugon/intel/debugger/cl/index.htm#commandref/gdb_mode/cmd_set_width.htm" target="_blank" rel="noopener">https://scc.ustc.edu.cn/zlsc/sugon/intel/debugger/cl/index.htm#commandref/gdb_mode/cmd_set_width.htm</a><br>more:<br><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a><br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">https://sourceware.org/gdb/current/onlinedocs/gdb/</a></p>
<p>使用例子：</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>我理解的心理模型</title>
    <url>/2020/04/03/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E5%BF%83%E7%90%86%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>以下内容均为本人构想理解提出，如有雷同纯属巧合，仅为本人粗略观点，不期赞同；</p>
<h3 id="一、模型概念"><a href="#一、模型概念" class="headerlink" title="一、模型概念"></a>一、模型概念</h3><h4 id="1）模型的广义解释"><a href="#1）模型的广义解释" class="headerlink" title="1）模型的广义解释"></a>1）模型的广义解释</h4><p>模型用于抽象化一类事物的特点和规律，甚至是发展周期；模型常见有数学模型，物理模型，工业模型等等；<a id="more"></a><br>如数学模型，是用来处理一类问题，通过输入，模型处理，得到想要的预测输出，模型常用来预测和计算问题的结果和答案；逼近结果甚至计算出结果本身；最简单如: 1天卖10斤菜，预测10天卖多少斤这种简单问题，则模型就是10*天数；输入就是天数，输出就是卖了多少斤；复杂一点可以加上条件，阴天卖多少斤，晴天卖多少斤，阴天有几天，或者甚至让你预测天气等等；</p>
<h4 id="2）复杂的模型"><a href="#2）复杂的模型" class="headerlink" title="2）复杂的模型"></a>2）复杂的模型</h4><p>用于解释数学的模型，还可以用来解释更多内容，并归结升级到当下流行的人工智能中的机器学习模型和深度学习等等；这些大部分也是通过输入和模型获得输出；而模型的建立将是一个很复杂繁琐的过程；模型的正确性也是个重要因素；</p>
<h3 id="二、心理模型"><a href="#二、心理模型" class="headerlink" title="二、心理模型"></a>二、心理模型</h3><h4 id="1）起源"><a href="#1）起源" class="headerlink" title="1）起源"></a>1）起源</h4><p>PS: 博主其实从初中就开始关注心理学，不过没有深入了解；最初想探寻人的心理模型，是在博主遇到19年创伤事件后，不明白心理为什么会出现如此变化；且还没有去借助外在心理学知识来解释，尝试自己去理解时，总结出来的；</p>
<h5 id="（1）动物行为基本分析："><a href="#（1）动物行为基本分析：" class="headerlink" title="（1）动物行为基本分析："></a>（1）动物行为基本分析：</h5><p>​       动物通过感知周围的环境刺激如食物，猎食者等，和自身的内在刺激如饥饿等，输入，进入到自己的简单模型，处理后进行反应即输出，比如见到猎食者，输入刺激，模型处理的结果是要逃跑，于是反应为逃跑等等；而动物的几乎一切的行为活动，贯穿一生，都是这样度过的；所以动物的本质，是个输入输出模型；从这个角度理解的话。</p>
<h5 id="（2）人类"><a href="#（2）人类" class="headerlink" title="（2）人类"></a>（2）人类</h5><p>​       人类其实也是动物，只是因为人类有高级的模型，所以能使得有控制输入输出，以及控制模型的能力；但因为基因和自身的认知等影响，导致不同的人对这些控制能力不同，就算是最强的人，对这些控制也不是100%的；</p>
<p>​        人的模型很复杂，人需要适应多变的环境，并安稳的生存下来，需要得到更多的信息，来应对种种危险等等；所以人类进化出了各种感官器，处理器如最强的大脑；内在神经感受器等等；</p>
<h4 id="2）模型基本框架"><a href="#2）模型基本框架" class="headerlink" title="2）模型基本框架"></a>2）模型基本框架</h4><p>人的心理模型在：</p>
<p>外界的输入–&gt;人对应的感受器–&gt;进入处理器模型–&gt;决策后输出；</p>
<p>以下是处理器模型，优先从第一层传递到第五层；</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">第五层<span class="symbol">:---------</span>自我意识：理性思考(一般有多个)------------</span><br><span class="line">第四层<span class="symbol">:-------</span>受限的自我意识：感受----------------------</span><br><span class="line">第三层：------受约束的自我意识：道德，法律-----------------</span><br><span class="line">第二层：------潜意识，习惯-----------------------------</span><br><span class="line">第一层：------身体，物理感受和直接处理------------------</span><br></pre></td></tr></table></figure>
<p>身体：比如膝跳反应等；</p>
<p>潜意识习惯：比如交流中的口头禅等；</p>
<p>其他类似；总是先经过第一层，第一层处理不了或者不需要则往上传递；严格来说也不是层级关系，是一种分类的处理；</p>
<p>输入输出方式：</p>
<p>可以分为两种：</p>
<p>1、接收输入，处理(处理包括思维层面，感受等等)，表现出来输出(可能是行为或者单纯的感受并会存储记忆，内反馈形成下次处理同类型问题的经验或者进步)；</p>
<p>2、进行输出(可能之前得到输入或单纯想输出)，得到输入，处理，感受；</p>
<h4 id="3）人心理模型的基本组成分析"><a href="#3）人心理模型的基本组成分析" class="headerlink" title="3）人心理模型的基本组成分析"></a>3）人心理模型的基本组成分析</h4><h5 id="（1）-组成：输入源，感受器，处理器，输出器"><a href="#（1）-组成：输入源，感受器，处理器，输出器" class="headerlink" title="（1） 组成：输入源，感受器，处理器，输出器"></a>（1） 组成：输入源，感受器，处理器，输出器</h5><h5 id="（2）各个组成分析："><a href="#（2）各个组成分析：" class="headerlink" title="（2）各个组成分析："></a>（2）各个组成分析：</h5><h6 id="A-输入源："><a href="#A-输入源：" class="headerlink" title="A 输入源："></a>A 输入源：</h6><p>​    一个是外部输入源，对应于第一种方式：输入-&gt;处理-&gt;输出的方式：很多，几乎是无限的，而感受器却只有有限种类型，而为了缔结输入源，感受器和输出等的联系，所建立的缔结关系，也是无限的；即体现为知识，能力等等；输入源举例：不同的食物，不同的感受刺激如漂亮的花朵等等；深层的如赞美的话，得到礼物等等，其他人也是一种输入源；</p>
<p>​     一个是内部的输入源：对应于第二种方式：输出-&gt;输入-&gt;处理的方式：很多，推理，瞎想，想象，创作等等；甚至简单如思考后的说话等等；</p>
<h6 id="B-感受器："><a href="#B-感受器：" class="headerlink" title="B 感受器："></a>B 感受器：</h6><p>   感受器目前我了解到的有：</p>
<p>外在实体：触觉，嗅觉，味觉，听觉，视觉，痛觉，温觉；</p>
<h6 id="C-处理器："><a href="#C-处理器：" class="headerlink" title="C 处理器："></a>C 处理器：</h6><p> 见上图；最低层次为身体，这个和动物也类似，即本能，人会本能的躲避危险，碰到烫的东西会自动收回；这些是不经过大脑的；</p>
<p>接着是潜意识和习惯等，大部分没有被大脑意识到；这个层面反应很快；类似口头禅，可以理解为一个map,针对某个输入，有确定的输出；所以往往直接表现出来；</p>
<p>接着是感受和道德层面：某个事物让自己感受到开心或伤心，可能还来不及去考虑，就直接反应，而道德法律也是，即自己的底线；这种一般不用思考；这个其实也是意识层面，只是是较浅的意识；当然有些人是感受强势些，有些人是理性意识强势些；</p>
<p>意识层面：即在感受和道德无法做决定时，则到了意识层面，经过处理后得到反应；而这个层面的思考，取决于人的认知，学识，智慧，即智商，情商等等；更多的是：涉及计算，规律，预测，分析问题本质，多因素考虑等等；</p>
<h6 id="D-输出器"><a href="#D-输出器" class="headerlink" title="D 输出器"></a>D 输出器</h6><p>​    内在感受：快乐感受器，悲伤感受器，愤怒感受器，害怕感受器等自尊感受器，安全感受器，归属感，等等；基本感受表现器，这个和输入其实息息相关；只有很少的处理过程；比如快乐往往很简单；不用经过太多的思考；偏向于对应于输入输出方式</p>
<p>输出方式也有：行为，选择决策，语言等等；</p>
<h4 id="4）人类模型的复杂度分析"><a href="#4）人类模型的复杂度分析" class="headerlink" title="4）人类模型的复杂度分析"></a>4）人类模型的复杂度分析</h4><p>(1)  人的感受器丰富，不仅有外在感受器如：视觉，听觉，触觉，嗅觉，味觉，还有如痛觉等内在感受器，甚至高级的自尊感，安全感，归属感等等一些进化的非显性但是实际存在的感觉器；（这些感受器大多是因为社交体系，和他人的情感体系环境下产生的，和等级等观念也相关）</p>
<p>(2)  人的感受器特性：感受器有个特点，对初次刺激记忆最深，敏感度最高，对之后的相同刺激习惯了，就显得表现的不是很强烈，可能是因为进化的原因，第一次不知道是不是危险，所以显得最警惕，之后熟悉了便失去了焦点；所以才会有腻了，味觉疲劳等现象；而对于隔了很久的没有的刺激，再次刺激也会有比较大的反应，这个也是很容易理解的；也就是边际递减效应；</p>
<p>(3)  外界输入类型的多样性，有些输入是人类自身创造的；而这个太多了；比如游戏；</p>
<p>(4)  人的处理器复杂度高：正常处理：输入到达身体层面能处理则不会传递上去：如人碰到烫的东西自动收回等等；若能传递，则到潜意识，接着到意识进行逻辑等处理，而意识层面的处理是最复杂的；</p>
<p>(5)  人的感受器对应的是输入，而人的一部分感受器可以作为输出，而输出同样也是复杂，不同类型的人不同环境下等等输出的效果可能类似，但是输出方式不同；</p>
<h3 id="三、详解输入源等"><a href="#三、详解输入源等" class="headerlink" title="三、详解输入源等"></a>三、详解输入源等</h3><p>输入源分为外部输入源和内部输入源：当你的输入源能量大，形成一个能量场，别人也会被你吸引，到你的能量场，于是你可能成为别人眼中的有趣的人；而最好这些不要太过依赖外部能量的提供；生活的品质和热爱表现于此；</p>
<p>1） 外部输入源：</p>
<p>划分方式1：根据特性划分</p>
<p>人或其他活物：亲人朋友爱人，崇拜对象，宠物等等，这种可以提供长期的源，和刺激；</p>
<p>一次性物：食物，视频等等</p>
<p>游戏/竞技/运动：同时刺激多个感官，而且高反馈即时反馈的特性让人享受其中；</p>
<p>…</p>
<p>划分方式2：根据归属划分：</p>
<p>现实物理世界日常活动：</p>
<p>吃-食物和怎样获取食物：自己下厨，外卖刷剧，堂食探索，各种体验不同；</p>
<p>穿-衣服化妆护肤等颜值相关，保暖舒适好看漂亮气质吸引别人等等；</p>
<p>住-居家环境宜家家居：居住环境构成和特点：干净整洁安全安静床舒适度气味等等；</p>
<p>行-交通工具：汽车高铁公交飞机走路自行车跑步平衡车轮滑等不同体验；空间方位认路等体验；”</p>
<p>健康-健身等；喝茶泡脚吃等等，</p>
<p>纯玩：打球游戏等等；</p>
<p>工作-知识技能解决问题需求，</p>
<p>社交-人</p>
<p>网络世界：游戏，视频媒体，文字信息，虚拟化，创作编程等，社交购物等和现实挂钩的，统称信息；而媒介可以是手机，平板，电脑，手表，智能硬件等等；</p>
<p>2） 内部输入源：</p>
<p>内心世界：</p>
<p>关系情感：友情爱情亲情等；</p>
<p>欲望：性，贪，懒</p>
<p>自尊自信等需求；</p>
<h3 id="四、心理模型的影响因素和发展周期"><a href="#四、心理模型的影响因素和发展周期" class="headerlink" title="四、心理模型的影响因素和发展周期"></a>四、心理模型的影响因素和发展周期</h3><p>1)   模型的影响因素：基因，家庭环境，学校环境，社会环境；环境包括人；</p>
<p>2)   模型的变化特性：人格，气质，性格，等是不容易变化的，可以理解为硬编码，强缔结；而意识层面涉及情商，智商等认知是容易改变的，而道德，感受涉及三观等等，也是能改变的，不过比意识层面更难；</p>
<p>3)   模型的发展周期：</p>
<p>人诞生时，是婴儿时期，此时还未被环境影响，各个感受器处于初始状态；模型原始由基因决定；婴儿期性本善，性本偏外向</p>
<p>孩童时期：在接受家庭环境影响，父母等影响后，感受器特质发生改变，此时比如接收到的某种刺激较少，比如爱，则缺爱，则长大后，第一次感受到爱后，会比别人表现更强烈；内向或者外向：一开始是外向的，通过输出能量，但是得到的反馈，输入进来的时候被判断为不好的感受，即负能量，则长此以往，则不愿意再去输出，形成内向的性格，即只喜欢输出到内部环境；</p>
<p> 青少年：开始受到身体激素影响，并开始更理性的关注周围的事物，受到学校影响较大；</p>
<p> 成年期：模型基本稳定，会轻微调整，不过受到创伤等大事会重新建立等；</p>
<p>PS:模型的影响，包括模型的感受器，处理器和表现(输出);感受器的特质:敏感度等是能被随着发展周期改变的；</p>
<p>学校环境：更多的是改变道德，感受和意识层面，少量的改变潜意识和习惯；</p>
<h3 id="五、用此心理模型来解释一些心理现象"><a href="#五、用此心理模型来解释一些心理现象" class="headerlink" title="五、用此心理模型来解释一些心理现象"></a>五、用此心理模型来解释一些心理现象</h3><p>1） 人格：人格指一个人在一定情况下所作行为反应的特质，即人们在生活、工作中独特的行为表现，包括思考方式、决策方式等；包括了内向外向，感觉直觉，思考情感，判断知觉；</p>
<p>内向外向：内向的人偏向于第一种方式：即输入-&gt;处理-&gt;输出；而外向的人偏向于输出-&gt;处理-&gt;输入的方式；和小时候的经历等有关；</p>
<p>感觉直觉：获取信息的方式：是感官获取听到看到还是自己推理瞎想；模型解释：感官感觉针对第一种输入输出方式:即输入-&gt;处理-&gt;输出，而直觉：第二种：输出-&gt;输入-&gt;处理，而输入往往作为一种验证的方式；</p>
<p>思考情感：决策方式：对应于模型中的处理器中的意识层面中哪个占主导，是感受还是理性；而这其中其实还有道德在作用；</p>
<p>判断还是知觉：喜欢做计划还是灵活处理适应环境？做计划其实是由内而外，因为计划是偏向于自己做的，且更容易控制，而适应环境则是针对环境的输入，来做对应的输出，针对的是第一种输入输出方式，所以和内向外向有关；可能还涉及到安全感等；</p>
<p>2） 气质：其实是一个人的输出，表现，这个多是自我的主动输出，少部分是针对输入做的输出；气质，这个词太虚：</p>
<p>来看普世解释：气质是人的个性心理特征之一，它是指在人的认识、情感、言语、行动中，心理活动发生时力量的强弱、变化的快慢和均衡程度等稳定的动力特征。主要表现在情绪体验的快慢、强弱、表现的隐显以及动作的灵敏或迟钝方面，因而它为人的全部心理活动表现染上了一层浓厚的色彩。</p>
<p>可以理解为感受器，表现器的特质吧；</p>
<h3 id="六、马斯洛需求解释"><a href="#六、马斯洛需求解释" class="headerlink" title="六、马斯洛需求解释"></a>六、马斯洛需求解释</h3><p>最高层面的即价值，自我实现，创造等等，即对应了模型类别中的输出类模型，即模型本身偏向于输出源，能源源不断的给其他人(模型)提供输入，所以其他模型在感兴趣的情况下，被吸引，建立缔结，从而记得记住这个人；所以这个人的价值被体现出来；</p>
<p>尊重需要：更深层次的内在感受器，凌驾于开心等之上，表现为舒适，满足，安全，信心等等；</p>
<p>社会需要：亲情，爱情，友情：实际上是和某个输入源(包括方式1和2)，缔结了强烈的关系，这个源能提供源源不断的输入，好的或不好的，但是缔结的联系深深的印在脑子里了；所以一旦这个源不存在了，就体现为难受，其实这是一种上瘾；所以这种情况可以是建立一个相似的输入源不同的缔结；或者等自己适应了这种缔结的消失，而不再需要这种缔结；类似的还有和动物的情感，特殊物品的情感等等；</p>
<p>安全需要：安全感：财产人身等安全，工作等：这个是属于内在高级的感受器：但是它可能依赖的东西并不高级，因人而异，比如在一间新房子还是旧房子里；</p>
<p>生理需求：吃喝拉撒睡性穿住行；身体需求层面，本能，低级感受器；</p>
<p>没有了身体，就没有大脑，所以身体的感受是最强烈的但是短暂，而越靠近上层，感觉越不强烈但是可能长远；除非，和身体的感受形成了缔结；</p>
<p>预测行为；了解自己行动原因，深层原因，从而改变自己，完善自己，善待自己；</p>
<h3 id="七、模型和现代互联网AI"><a href="#七、模型和现代互联网AI" class="headerlink" title="七、模型和现代互联网AI"></a>七、模型和现代互联网AI</h3><p>模型编程和如何塑造一个你，TODO</p>
]]></content>
      <categories>
        <category>心理</category>
      </categories>
  </entry>
  <entry>
    <title>cpp_runtime_semantis</title>
    <url>/2018/07/29/cpp-runtime-semantis/</url>
    <content><![CDATA[<h3 id="c-执行期语意学"><a href="#c-执行期语意学" class="headerlink" title="c++ 执行期语意学"></a>c++ 执行期语意学</h3><h4 id="执行期和编译期的理解"><a href="#执行期和编译期的理解" class="headerlink" title="执行期和编译期的理解"></a>执行期和编译期的理解</h4><ul>
<li>执行期：此时是对已经编译等生成的可执行文件装载到内存并调用cpu将其作为一个进程执行的过程，对c.c++来说程序的入口为main,即第一条指令是执行main函数开始的，而c++可能会加入一些额外的代码，所以实际写的第一条语句和执行的第一条语句可能有偏差；　　　<a id="more"></a></li>
<li>在执行的过程，是程序代码运行的过程，可以想象为工厂开始生产，此时需要空间来运行，需要生产线，产品，工人，工人们走来走去搬运物品等；对程序的运行而言，此时主要的活动空间为栈和堆，即在栈和堆分配空间，而流程制式就是代码段，静态变量的数据区可以比喻为整个工厂共有的数据等；　这个过程中栈会被不断生成消失，堆也是，承载他们的是内存对应的区域；执行完后就从内存消失；</li>
<li>　编译期，就像生孩子之前的扫描，检查，看看语法对不对，添加额外的内容(c++).生成对应的汇编代码和二进制代码，而程序员需要尽力　编译出高效，整洁，可读等特性的代码，就像这个过程中通过调理，吃合适的东西等；尽可能避开一些坑和耗时的行为le.</li>
<li>　这部分的内容并不涉及太多执行期的，而更多的是编译器在编译代码时做了什么手脚<h4 id="c-中的运算符函数和运算符语法糖"><a href="#c-中的运算符函数和运算符语法糖" class="headerlink" title="c++中的运算符函数和运算符语法糖"></a>c++中的运算符函数和运算符语法糖</h4></li>
<li><p>运算符被编译器转换为运算符函数<br>操作符函数例子–&gt;到临时对象的产生和销毁带来的效率问题<br>–&gt;如何在程序中尽量避免产生临时变量和调用析构函数<br>例子：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X xx;</span><br><span class="line">Y yy;</span><br><span class="line"><span class="keyword">if</span>(yy==xx.getvalue()) ``` </span><br><span class="line">其中涉及到yy的==运算符函数和xx的getvalue函数，前者为：  </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Y&amp;) <span class="keyword">const</span>后者为X getvalue()  　　</span><br><span class="line">yy==xx.getvalue()被转换为yy.<span class="keyword">operator</span>==(xx.getvalue),显然类型不相符；  </span><br><span class="line">而此时若X有函数<span class="keyword">operator</span> Y()<span class="keyword">const</span>;<span class="comment">//conversion运算符，则进一步转换为：  </span></span><br><span class="line">     yy.<span class="keyword">operator</span>==(xx.getvalue.<span class="keyword">operator</span> Y())  </span><br><span class="line"> 这行代码看上去是这样简单，但是实际上需要产生中间变量，转为伪代码:  </span><br><span class="line">   X　tmp1=xx.getvalue;<span class="comment">//放返回值  </span></span><br><span class="line">   Y tmp2=tmp1.<span class="keyword">operator</span> Y()<span class="comment">//同上  </span></span><br><span class="line">   <span class="keyword">int</span> tmp3=yy.<span class="keyword">operator</span>==(tmp2);<span class="comment">//放置返回值  </span></span><br><span class="line">   总共产生三个临时变量，而且还得析构，麻烦效率低  </span><br><span class="line">   (注意，上述的为什么不能直接连锁调用?因为返回的是值而不是指针，思考<span class="keyword">this</span>指针的连锁操作，<span class="built_in">cout</span>的连锁操作，个人思考，应该是因为返回的是指针，上述返回的是值，所以无法用值调用下面的函数）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 对象的构造和解构</span><br><span class="line">+ 构造函数在哪里被安插:  </span><br><span class="line">构造函数在编译时，由编译器在合适的地方安插，一般情况下，正如我们想像的一样：在定义对象时会执行构造函数,解构在对象销毁时;</span><br><span class="line"><span class="comment">//c++伪代码  </span></span><br><span class="line">```cpp</span><br><span class="line">&#123;</span><br><span class="line">   Point point ;</span><br><span class="line">   <span class="comment">//point.Point::Point() 一般而言会被安插在这里</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//point.Point::~Point() 一般而言会被安插在这里</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解构函数在哪里被安插:<br>1、解构函数的安插需要考虑程序的退出时间（或者某个代码块的退出时间，在可能退出的地方都要加解构函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Point point;</span><br><span class="line">  <span class="comment">//constructor here</span></span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">int</span> (point.x()) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">    <span class="comment">//mumble;</span></span><br><span class="line">    <span class="comment">//destructor here</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="comment">//mumble;</span></span><br><span class="line">    <span class="comment">//destructor here</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">      <span class="comment">//mumble</span></span><br><span class="line">      <span class="comment">//destructor here</span></span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">    destructor here</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>解构代码应该在任何可能退出代码块的地方，return等，switch,if，goto等都会使加上解构函数的调用以避免出现退出但是还没有执行析构函数的尴尬；</li>
<li><p>而在如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(cache)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   Point xx;</span><br><span class="line">   <span class="keyword">if</span>(xx.get()==<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   和</span><br><span class="line">   &#123;</span><br><span class="line">     Point xx;</span><br><span class="line">     <span class="keyword">if</span>(cache）</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 前者不需要在if(cache）的return 前加解构和　构造函数，而后者需要，显然后者综合效率更差些；<br> 所以设计c++代码时候需要考虑，尽量在使用它的附近定义它</p>
</li>
<li><p>对特殊情况的考虑–全局对象的构造函数和解构函数的安插，有特殊的处理<br>“前面看到的是正常的局部情况，现在考虑的是全局对象，定义在main外面，它的构造函数被安插在哪里，什么时候执行?”<br>考虑以下例子：  </p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Matrix</span> identity;</span><br><span class="line"> main ()</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">//identity 必须在这里被初始化</span></span><br><span class="line">    <span class="keyword">Matrix</span> m1=identity;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 很明显，c++ 必须保证第一次用到identity把他构造出来而在main结束前销毁它；对全局对象而言，有构造函数和析构函数时，称为静态的初始化和内存释放操作；<br> 全局对象和全局变量一样被放在数据段(data segment),在c中，可以在编译期间给定全局变量常量值，而c++中的全局对象需要程序激活后才能执行构造函数给初值；相当于给全局对象做静态初始化；</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如,cfront在执行前，加入_main来初始化各种全局对象；</span></span><br><span class="line"><span class="comment">//sti_xxx---static initialization</span></span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="variable">_main</span>();---(<span class="variable">_sti_xxx</span>(); <span class="variable">_sti_xxx</span>();,,,)</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable">_exit</span>()---(<span class="variable">_std_xxx</span>()....)</span><br><span class="line">    <span class="comment">//而在结束时调用他们的析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    但是需要收集程序中各个对象文件的<span class="variable">_sti</span>函数和<span class="variable">_std</span>函数，此时可以用nm命令，即它会倾倒出符号表项目，nm会施加到.o文件上；搜寻<span class="variable">_sti</span> <span class="variable">_std</span>开头的函数；最后总结整理出来；</span><br></pre></td></tr></table></figure>
</li>
<li><p>对特殊情况的考虑–局部静态对象<br>考虑局部静态对象只会构造一次和销毁一次，却是可能调用多次包含定义局部静态对象的函数，如何保证只会构造一次和销毁一次呢?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> Matrix&amp;</span><br><span class="line"> identify() &#123;</span><br><span class="line">    <span class="keyword">static</span> Matrix mat_identify;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> mat_identify;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//1\首先要保证在调用该函数才初始化局部静态变量，</span></span><br><span class="line"><span class="comment">//2、其次，保证多次调用该函数不会重复初始化对象；</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>简单的说，解决方案就是用一个标志变量，当已经初始化一次局部静态变量就置为真；</p>
<ul>
<li>对象数组什么时候构造和解构?<br>考虑一下定义了一个对象数组，之后未做任何改动，要取其中的值，会在定义数组的时候也初始化数组中每一个对象（即调用构造函数)吗？<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">int</span> a;</span><br><span class="line">      Point ()&#123;a=<span class="number">3</span>;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">Point knot[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;knot[<span class="number">3</span>].a;<span class="comment">//会打印3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当这种对象数组没有默认构造函数和析构函数，则定义时和内置类型相同，只需配置足够的内存保存即可；<br>而当对象有构造函数和析构函数时，编译器提供了vec_new() vec_delete()之类的函数来统一做构造和析构</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *vec_new(<span class="keyword">void</span> *<span class="keyword">array</span>,<span class="comment">//数组起始地址</span></span><br><span class="line">      size_t elem_size,<span class="keyword">int</span> elem_count,<span class="comment">//对象大小和数组对象个数</span></span><br><span class="line">      <span class="keyword">void</span> (*constructor)(*<span class="keyword">void</span>)</span><br><span class="line">      <span class="keyword">void</span>(*destructor)(*<span class="keyword">void</span>)</span><br><span class="line">      而实际上调用时：</span><br><span class="line">      Point knots[<span class="number">10</span>]</span><br><span class="line">      <span class="comment">//可能是这样调用，delete类似</span></span><br><span class="line">      vec_new(&amp;knnots,<span class="keyword">sizeof</span>(Point),<span class="number">10</span>,&amp;Point::Point,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>而如果程序员额外调用了其中一些元素的构造函数，则：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>]=&#123;Point(),Point(<span class="number">1.8</span>,<span class="number">2.1</span>,<span class="number">0.2</span>),<span class="number">-1.9</span>&#125;;</span><br><span class="line">类似这样，则可能会明确的初始化前三个元素，后面的其他则用vec_new</span><br></pre></td></tr></table></figure></p>
<ul>
<li>默认构造函数和数组</li>
</ul>
<h4 id="new和delete运算符"><a href="#new和delete运算符" class="headerlink" title="new和delete运算符"></a>new和delete运算符</h4><p>上述是针对对象的，new和delete是针对指针的；</p>
<ul>
<li>本质上调用malloc函数和free函数,编译器解析new，delete会安插构造函数和解构函数<br>new 的实际过程：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">对内建类型</span><br><span class="line"><span class="keyword">int</span> *pi=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//1 调用函数库的new:_new </span></span><br><span class="line"><span class="comment">//int *pi=_new(sizeof(int));</span></span><br><span class="line"><span class="comment">//2 设置初值：*pi=5;</span></span><br><span class="line"><span class="comment">//或加条件：</span></span><br><span class="line">(<span class="keyword">int</span>  *pi ; <span class="keyword">if</span>(pi=_new(...))*pi=<span class="number">5</span>)</span><br><span class="line"><span class="comment">//delete类似；</span></span><br><span class="line">对对象：</span><br><span class="line">Point3d *origin =<span class="keyword">new</span> Point3d;</span><br><span class="line">转换为：</span><br><span class="line">Point3d *origin;</span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">if</span>(origin =_new(<span class="keyword">sizeof</span>(Point3d))</span><br><span class="line">origin=Pointed::Point3d(origin)<span class="comment">//注意这里会调用构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> origin;</span><br><span class="line">转换为：</span><br><span class="line"><span class="keyword">if</span> (!origin !=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">Point3d::~Point3d(origin);</span><br><span class="line">_delete(origin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">而<span class="keyword">new</span> 一般由<span class="built_in">malloc</span>实现，<span class="keyword">delete</span>由<span class="built_in">free</span>实现；</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">size_t</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (size =<span class="number">0</span>)</span><br><span class="line">    size=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">void</span> *last_alloc</span><br><span class="line">  <span class="keyword">while</span>(!(last_alloc=<span class="built_in">malloc</span>(size)))</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(_new_handle)</span><br><span class="line">   (*_new_handle)();</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="keyword">return</span> last_alloc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>针对数组的new和delete<br>实际上的new数组，若不存在构造函数，则只会做new的运算符函数：int <em>parray=(</em>int)_new(5*sizeof(int));<br>待续，略复杂。。。</li>
<li>placement operator new的语意-——new的重载；</li>
</ul>
<h4 id="影响c-效率因素之一—临时性对象"><a href="#影响c-效率因素之一—临时性对象" class="headerlink" title="影响c++效率因素之一—临时性对象"></a>影响c++效率因素之一—临时性对象</h4><ul>
<li><p>为什么需要临时性对象<br>临时性对象是影响程序效率和引入bug的来源之一；</p>
<ul>
<li><p>隐式的类型转换需要临时性对象：<br>当用内建类型写下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">....</span><br><span class="line">a=b+c;<span class="comment">//内建类型将算出的值赋给a</span></span><br><span class="line"><span class="comment">//想象一下如果此时a,b,c都是对象，b+c返回一个对象呢？</span></span><br><span class="line">在c++中操作符运算本质上也是函数，则这里单纯靠b+c返回</span><br><span class="line">一个对象的值赋值给a已经不现实了，对象是一个结构性的</span><br><span class="line">变量；所以在这种情况下就需要构建一个临时性对象，并将</span><br><span class="line">此临时性对象（函数的结果）利用赋值函数拷贝给a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单纯传入对象作为函数参数时，即使不返回对象，也会产生临时性对象，为什么? 随意写了个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">     <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="number">2</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="number">3</span>         <span class="keyword">public</span>:</span><br><span class="line">    <span class="number">4</span>                 <span class="keyword">int</span> a;</span><br><span class="line">    <span class="number">5</span>                 Point()&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"constructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; a=<span class="number">4</span>;&#125;</span><br><span class="line">    <span class="number">6</span>                 <span class="function"><span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="number">32</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="number">7</span>                 ~Point()&#123;</span><br><span class="line">    <span class="number">8</span>                         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"~destrucot"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">&gt;&gt;  <span class="number">9</span>                Point(<span class="keyword">const</span> Point&amp; p)</span><br><span class="line">   <span class="number">10</span>                &#123;</span><br><span class="line">   <span class="number">11</span>                                 <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy Constructor"</span> &lt;&lt; <span class="built_in">std</span>::en      dl;</span><br><span class="line">   <span class="number">12</span>                &#125;</span><br><span class="line">   <span class="number">13</span> </span><br><span class="line">&gt;&gt; <span class="number">14</span>               Point&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp; p)</span><br><span class="line">   <span class="number">15</span>               &#123;</span><br><span class="line">   <span class="number">16</span>                  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Assign"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="number">17</span>                  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   <span class="number">18</span>               &#125;</span><br><span class="line">   <span class="number">19</span> </span><br><span class="line">   <span class="number">20</span> &#125;;</span><br><span class="line">   <span class="number">21</span> <span class="function"><span class="keyword">void</span> <span class="title">getv</span><span class="params">(<span class="keyword">const</span> Point pp)</span></span></span><br><span class="line"><span class="function">   22 </span>&#123;</span><br><span class="line">   <span class="number">23</span>     <span class="comment">//= pp.a=6;</span></span><br><span class="line">   <span class="number">24</span>         pp.printa();</span><br><span class="line">   <span class="number">25</span>         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;pp.a&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="number">26</span> &#125;</span><br><span class="line">   <span class="number">27</span> </span><br><span class="line">   <span class="number">28</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   29 </span>&#123;</span><br><span class="line">   <span class="number">30</span>         Point pplist;</span><br><span class="line">   <span class="number">31</span>         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;pplist.a&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="number">32</span>         getv(pplist);<span class="comment">//这里产生临时对象是调用拷贝构造函数</span></span><br><span class="line">   <span class="number">33</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">34</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>按照内建类型来看，传入函数参数，其实传入的是值，<br>而对于对象来说，若传入的是引用或指针则不需要产生临时性对象，但是传入的若是值，则c++编译器需要产生一个临时性对象，在函数的栈中，供函数中对该对象调用函数和值等操作；</p>
<ul>
<li><p>函数返回对象；</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">另一个例子：</span><br><span class="line">   如何做X xxx=bar();如何拷贝的？双阶段初始化：</span><br><span class="line"> a 增加一个额外的引用参数给函数，如void bar(X＆　_result)</span><br><span class="line"> b 在return 前插入一个<span class="keyword">copy</span> <span class="function"><span class="keyword">constructor</span> </span></span><br><span class="line"><span class="function">     <span class="title">void</span> <span class="title">bar</span><span class="params">(X &amp;__result)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">               X xx;</span></span></span><br><span class="line"><span class="function"><span class="comment">               xx.X::X();</span></span></span><br><span class="line"><span class="function"><span class="comment">               __result.X::XX(xx);</span></span></span><br><span class="line"><span class="function"><span class="comment">               return ;</span></span></span><br><span class="line"><span class="function"><span class="comment">       &#125;</span></span></span><br><span class="line"><span class="function">   <span class="title">X</span> <span class="title">xxx</span>=<span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   //-&gt;<span class="title">bar</span><span class="params">(X &amp;__result)</span>;</span></span><br><span class="line">       xxx=_result;</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动调用构造函数：此时也会生成临时性对象；</p>
</li>
<li>其他如通过构造函数调用成员函数的：单纯一个表达式 a+b这种的</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tmpclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    tmpclass(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmpclass()</span><br><span class="line">    &#123;</span><br><span class="line">        tmpclass(<span class="number">0</span>);<span class="comment">//手动调用构造函数会产生临时对象，临时对象的a=0,故最后结果show还是无初值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tmpclass c;</span><br><span class="line">    c.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">其他：</span><br><span class="line"> tmpclass c1 = tmpclass(<span class="number">6</span>);<span class="comment">//赋值构造+构造函数</span></span><br><span class="line"> tmpclass(<span class="number">6</span>).show()<span class="comment">//产生临时性对象；</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如何避免产生临时性对象<br>尽量不用上述的手法编程</li>
<li>临时性对象的效率（迷思，测试)<br>临时性对象会造成效率低下，在不当的代码下容易产生很多临时性对象；不当的使用也会造成非预期的结果；</li>
<li>临时性对象的生命周期：<br>可能是这个表达式的生命周期，具体可以通过构造类函数和析构函数调试；</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_pingtraceroute</title>
    <url>/2018/06/24/tcpip-pingtraceroute/</url>
    <content><![CDATA[<h3 id="ping-and-traceroute"><a href="#ping-and-traceroute" class="headerlink" title="ping and traceroute"></a>ping and traceroute</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>ping是ICMP中的回显报文类型：</p>
<ul>
<li>ping 对应的icmp，type字段为0/8,code字段为0</li>
<li>ICMP回显请求和应答报文格式：<a id="more"></a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类型(<span class="number">0</span>/<span class="number">8</span>）       code(<span class="number">0</span>)       检验和 -<span class="number">-4B</span></span><br><span class="line">标示符（unix系统中为进程pid)   序号   -<span class="number">-4B</span></span><br><span class="line">           选项数据</span><br></pre></td></tr></table></figure>
<ul>
<li>最常见，回显时间，得到往返时间：<br>通过在icmp数据报文中存放发送请求的时间值来计算往返时间，当应答返回时，用当前时间减去存放在ICMP报文中的时间值，即是往返时间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类型(<span class="number">0</span>/<span class="number">8</span>）       code(<span class="number">0</span>)       检验和 -<span class="number">-4B</span></span><br><span class="line">标示符（unix系统中为进程pid)   序号   -<span class="number">-4B</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span>         -<span class="number">-8B</span></span><br></pre></td></tr></table></figure>
<p>共16Byte,除开ip头</p>
<ul>
<li>放抓包的图片，ping回显示时间</li>
<li>ping程序代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addr_conv</span><span class="params">(<span class="keyword">char</span> *address,struct in_addr *inaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">he</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(inet_aton(address,inaddr)==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">	he=gethostbyname(address);</span><br><span class="line">	<span class="keyword">if</span>(he!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*inaddr=*((struct in_addr *)he-&gt;h_addr_list[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_icmp</span><span class="params">(<span class="keyword">int</span> sockfd,sockaddr_in send_addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recv_icmp</span><span class="params">(<span class="keyword">int</span> sockfd,sockaddr_in send_addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">	sockfd=socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);</span><br><span class="line">    <span class="keyword">if</span>(sockfd&lt;<span class="number">0</span>)</span><br><span class="line"> 	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"creat socket error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sockaddr_in send_addr;</span><br><span class="line">	bzero(&amp;send_addr,<span class="keyword">sizeof</span>(send_addr));</span><br><span class="line">	send_addr.sin_family=AF_INET;</span><br><span class="line">	addr_conv(argv[<span class="number">1</span>],&amp;send_addr.sin_addr);</span><br><span class="line"><span class="comment">//send_addr.sin_addr.s_addr=inet_addr("192.168.0.110");</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line"> 	&#123;</span><br><span class="line">		send_icmp(sockfd,send_addr);</span><br><span class="line">		recv_icmp(sockfd,send_addr);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">checksum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> *addr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nleft=len;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> *w=addr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> answer=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(nleft&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=*w++;</span><br><span class="line">		nleft-=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(nleft==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)(&amp;answer)=*(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)w;</span><br><span class="line">		sum+=answer;</span><br><span class="line">	&#125;</span><br><span class="line">	sum=(sum&gt;&gt;<span class="number">16</span>)+(sum&amp;<span class="number">0xffff</span>);</span><br><span class="line">	sum+=(sum&gt;&gt;<span class="number">16</span>);</span><br><span class="line">	answer=~sum;</span><br><span class="line">	<span class="comment">//answer=(unsigned short)sum&amp;0xffff;</span></span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_icmp</span><span class="params">(<span class="keyword">int</span> sockfd,sockaddr_in send_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">short</span> <span class="keyword">int</span> seq=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">char</span>  buf[<span class="number">8</span>+<span class="number">8</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icmphdr</span> *<span class="title">icmp</span>=(<span class="title">struct</span> <span class="title">icmphdr</span> *)<span class="title">buf</span>;</span></span><br><span class="line">	<span class="comment">//填充icmp首部</span></span><br><span class="line">	icmp-&gt;type=ICMP_ECHO;<span class="comment">//类型</span></span><br><span class="line">	icmp-&gt;code=<span class="number">0</span>;<span class="comment">//和编码共同决定是回显报文</span></span><br><span class="line">	icmp-&gt;checksum=<span class="number">0</span>;<span class="comment">//头部包含校验和</span></span><br><span class="line">	icmp-&gt;un.echo.id=getpid();<span class="comment">//标识符，唯一性，一般填充pid，这样即使几个程序发送ping也能识别，写成其他时接收失败</span></span><br><span class="line">	icmp-&gt;un.echo.sequence=seq++;<span class="comment">//顺序号，回显时，显示，一般无规定，但是会在此基础上加１，接着加１，，</span></span><br><span class="line">	<span class="comment">//填充icmp数据(时间)//这里报文数据只有时间戳</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	<span class="comment">//tv=(struct timeval*)icmp-&gt;icmp_data;</span></span><br><span class="line">	gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(buf+<span class="number">8</span>,&amp;tv,<span class="keyword">sizeof</span>(tv));</span><br><span class="line">	<span class="keyword">int</span> buflen=<span class="keyword">sizeof</span>(struct icmphdr)+<span class="keyword">sizeof</span>(struct timeval);</span><br><span class="line">	<span class="comment">//计算校验和</span></span><br><span class="line">	icmp-&gt;checksum=checksum((<span class="keyword">unsigned</span> <span class="keyword">short</span> *)buf,buflen);</span><br><span class="line">	<span class="comment">//发送icmp数据包</span></span><br><span class="line">	<span class="keyword">int</span> len=sendto(sockfd,buf,buflen,<span class="number">0</span>,(struct sockaddr *)&amp;send_addr,<span class="keyword">sizeof</span>(send_addr));</span><br><span class="line">	<span class="keyword">if</span>(len&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"send icmp error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"senmd ok"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recv_icmp</span><span class="params">(<span class="keyword">int</span> sockfd,sockaddr_in send_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icmphdr</span> *<span class="title">icmp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">ip</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ipheadlen;</span><br><span class="line">	<span class="keyword">int</span> icmplen;</span><br><span class="line">	<span class="comment">//接收icmp响应</span></span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n=recvfrom(sockfd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"recv error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ip=(struct ip *)buf;	</span><br><span class="line">		ipheadlen=ip-&gt;ip_hl&lt;&lt;<span class="number">2</span>;</span><br><span class="line">		icmplen=n-ipheadlen;</span><br><span class="line">		<span class="keyword">if</span>(icmplen&lt;<span class="number">16</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		icmp=(struct icmphdr *)(buf+ipheadlen);</span><br><span class="line">		<span class="keyword">if</span>(icmp-&gt;type==ICMP_ECHOREPLY&amp;&amp;icmp-&gt;un.echo.id==getpid())</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算时间差</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">recv_tv</span>;</span></span><br><span class="line">	gettimeofday(&amp;recv_tv,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">send_tv</span>;</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;send_tv,icmp+<span class="number">1</span>,<span class="keyword">sizeof</span>(send_tv));</span><br><span class="line">	recv_tv.tv_sec-=send_tv.tv_sec;</span><br><span class="line">	recv_tv.tv_usec+=recv_tv.tv_sec*<span class="number">1000000L</span>;</span><br><span class="line">	<span class="keyword">long</span> interval=recv_tv.tv_usec-send_tv.tv_usec;</span><br><span class="line">	<span class="comment">//输出信息</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;icmplen&lt;&lt; <span class="string">" bytes fromfdfd "</span>&lt;&lt;inet_ntoa(send_addr.sin_addr);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">" icmp_seq="</span>&lt;&lt;icmp-&gt;un.echo.sequence&lt;&lt;<span class="string">" bytes="</span>&lt;&lt;icmplen&lt;&lt;<span class="string">" ttl="</span>&lt;&lt;(<span class="keyword">int</span>)ip-&gt;ip_ttl;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">" time="</span>&lt;&lt;(<span class="keyword">float</span>)interval/<span class="number">1000.0</span>&lt;&lt;<span class="string">"ms"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ip 记录路由选项：<br>利用ip头，ip头长度字段为4bit,最长的ip首部为15x32bit=60字节，所以除去头20字节，选项字段最大40字节，除去3字节的code,len.ptr三个字节，剩下37个字节，可以容纳9个ip地址<br>windows下可以通过ping -r ip来尝试</li>
<li>ip时间戳选项</li>
</ul>
<h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><h5 id="traceroute主要两点"><a href="#traceroute主要两点" class="headerlink" title="traceroute主要两点"></a>traceroute主要两点</h5><ul>
<li>利用ttl,ttl是一个有限值，每经过一个路由器减1，这样放置循环发包。</li>
<li>利用icmp报文，当路由器接收到ttl为0或1时，不转发，而是丢弃，并给信源回复一个icmp超时信息，且包含该路由器的ip</li>
<li>具体流程：<br>traceroute发送一份ttl字段为1的ip数据报给目的主机，处理这个数据报的第一个路由器将ttl值减去1，丢弃该数据报，并发送一份超时icmp报文，这样就得到了该路径的第一个路由器的地址；<br>以此类推，发送ttl为2的数据报，则得到第二个路由器的地址；直到到达目的地址；<br>怎么知道到达了目的地?<br>traceroute发送了一份udp数据包给目的主机，但它选择了一个不可能的值作为udp端口号（大于30000)，使目的主机的任何一个应用程序都不可能使用该端口号，则当包到达目的主机时，目的主机的udp模块会产生一个端口不可达的错误icmp报文。traceroute要做的是区分icmp是超时还是端口不可达，以判断什么时候结束</li>
</ul>
<h5 id="traceroute命令"><a href="#traceroute命令" class="headerlink" title="traceroute命令"></a>traceroute命令</h5><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">traceroute www.baidu.com</span><br><span class="line">traceroute to www.baidu.com (<span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span>), <span class="number">30</span> hops max, <span class="number">60</span> byte packets<span class="comment">//ttl字段为30跳，每个数据包为60字节（20ip头等）</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> (<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>)  <span class="number">2.762</span> ms  <span class="number">3.485</span> ms  <span class="number">3.477</span> ms/发到网关<span class="number">1</span>,针对每个ttl值发送三份包，分别在<span class="number">2.762</span>,<span class="number">3.485</span>,<span class="number">3.477</span>收到</span><br><span class="line"> <span class="number">2</span>  <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> (<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>)  <span class="number">3.466</span> ms  <span class="number">3.453</span> ms  <span class="number">3.443</span> ms</span><br><span class="line"> <span class="number">3</span>  <span class="number">101.232</span><span class="number">.192</span><span class="number">.1</span> (<span class="number">101.232</span><span class="number">.192</span><span class="number">.1</span>)  <span class="number">6.807</span> ms  <span class="number">6.813</span> ms  <span class="number">7.412</span> ms</span><br><span class="line"> <span class="number">4</span>  <span class="number">10.144</span><span class="number">.11</span><span class="number">.37</span> (<span class="number">10.144</span><span class="number">.11</span><span class="number">.37</span>)  <span class="number">7.405</span> ms  <span class="number">7.393</span> ms  <span class="number">7.381</span> ms</span><br><span class="line"> <span class="number">5</span>  <span class="number">10.144</span><span class="number">.14</span><span class="number">.138</span> (<span class="number">10.144</span><span class="number">.14</span><span class="number">.138</span>)  <span class="number">7.369</span> ms  <span class="number">7.362</span> ms  <span class="number">7.340</span> ms</span><br><span class="line"> <span class="number">6</span>  * * <span class="number">14.197</span><span class="number">.242</span><span class="number">.145</span> (<span class="number">14.197</span><span class="number">.242</span><span class="number">.145</span>)  <span class="number">10.329</span> ms</span><br><span class="line"> <span class="number">7</span>  <span class="number">14.197</span><span class="number">.218</span><span class="number">.173</span> (<span class="number">14.197</span><span class="number">.218</span><span class="number">.173</span>)  <span class="number">7.240</span> ms <span class="number">14.197</span><span class="number">.248</span><span class="number">.253</span> (<span class="number">14.197</span><span class="number">.248</span><span class="number">.253</span>)  <span class="number">6.855</span> ms  <span class="number">7.212</span> ms</span><br><span class="line"> <span class="number">8</span>  <span class="number">14.197</span><span class="number">.240</span><span class="number">.249</span> (<span class="number">14.197</span><span class="number">.240</span><span class="number">.249</span>)  <span class="number">44.799</span> ms <span class="number">14.197</span><span class="number">.252</span><span class="number">.189</span> (<span class="number">14.197</span><span class="number">.252</span><span class="number">.189</span>)  <span class="number">42.107</span> ms <span class="number">14.197</span><span class="number">.253</span><span class="number">.145</span> (<span class="number">14.197</span><span class="number">.253</span><span class="number">.145</span>)  <span class="number">50.051</span> ms</span><br><span class="line"> <span class="number">9</span>  <span class="number">14.197</span><span class="number">.252</span><span class="number">.54</span> (<span class="number">14.197</span><span class="number">.252</span><span class="number">.54</span>)  <span class="number">49.394</span> ms  <span class="number">49.414</span> ms <span class="number">14.197</span><span class="number">.248</span><span class="number">.94</span> (<span class="number">14.197</span><span class="number">.248</span><span class="number">.94</span>)  <span class="number">49.406</span> ms</span><br><span class="line"><span class="number">10</span>  <span class="number">14.197</span><span class="number">.149</span><span class="number">.178</span> (<span class="number">14.197</span><span class="number">.149</span><span class="number">.178</span>)  <span class="number">49.406</span> ms  <span class="number">49.383</span> ms <span class="number">14.197</span><span class="number">.178</span><span class="number">.102</span> (<span class="number">14.197</span><span class="number">.178</span><span class="number">.102</span>)  <span class="number">49.382</span> ms</span><br><span class="line"><span class="number">11</span>  <span class="number">182.61</span><span class="number">.253</span><span class="number">.119</span> (<span class="number">182.61</span><span class="number">.253</span><span class="number">.119</span>)  <span class="number">49.912</span> ms <span class="number">182.61</span><span class="number">.253</span><span class="number">.117</span> (<span class="number">182.61</span><span class="number">.253</span><span class="number">.117</span>)  <span class="number">50.916</span> ms <span class="number">182.61</span><span class="number">.253</span><span class="number">.119</span> (<span class="number">182.61</span><span class="number">.253</span><span class="number">.119</span>)  <span class="number">50.554</span> ms</span><br><span class="line"><span class="number">12</span>  <span class="number">182.61</span><span class="number">.253</span><span class="number">.126</span> (<span class="number">182.61</span><span class="number">.253</span><span class="number">.126</span>)  <span class="number">47.975</span> ms *  <span class="number">50.625</span> ms<span class="comment">//5s未收到时打印一个*号并发送下一份数据包</span></span><br><span class="line"><span class="number">13</span>  * * *</span><br><span class="line"><span class="number">14</span>  * * *</span><br><span class="line"><span class="number">15</span>  * * *</span><br><span class="line"><span class="number">16</span>  * * *</span><br><span class="line"><span class="number">17</span>  * * *</span><br><span class="line"><span class="number">18</span>  * * *</span><br><span class="line"><span class="number">19</span>  * * *</span><br><span class="line"><span class="number">20</span>  * * *</span><br><span class="line"><span class="number">21</span>  * * *</span><br><span class="line"><span class="number">22</span>  * * *</span><br><span class="line"><span class="number">23</span>  * * *</span><br><span class="line"><span class="number">24</span>  * * *</span><br><span class="line"><span class="number">25</span>  * * *</span><br><span class="line"><span class="number">26</span>  * * *</span><br><span class="line"><span class="number">27</span>  * * *</span><br><span class="line"><span class="number">28</span>  * * *</span><br><span class="line"><span class="number">29</span>  * * *</span><br><span class="line"><span class="number">30</span>  * * *</span><br></pre></td></tr></table></figure>
<p>tcpdump输出：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">traceroute www.baidu.com(<span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span>)</span><br><span class="line"><span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.39650</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33434</span>: [udp sum ok] UDP, length <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009075</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">1</span>, id <span class="number">5354</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)//ttl=<span class="number">1</span></span><br><span class="line"><span class="number">192.168</span><span class="meta">.0</span><span class="meta">.1</span> &gt; <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span>: ICMP time exceeded <span class="keyword">in</span>-transit, length <span class="number">68</span>//网关回复icmp超时</span><br><span class="line">	<span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">1</span>, id <span class="number">941</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.48912</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33435</span>: [udp sum ok] UDP, length <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009114</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">1</span>, id <span class="number">5355</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.43061</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33436</span>: [udp sum ok] UDP, length <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009148</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">2</span>, id <span class="number">5356</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)//ttl=<span class="number">2</span></span><br><span class="line"> <span class="number">192.168</span><span class="meta">.1</span><span class="meta">.1</span> &gt; <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span>: ICMP time exceeded <span class="keyword">in</span>-transit, length <span class="number">68</span></span><br><span class="line">	<span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">1</span>, id <span class="number">942</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)</span><br><span class="line">//第<span class="number">2</span>个路由器回复超时</span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.52554</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33437</span>: [udp sum ok] UDP, length <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009189</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">2</span>, id <span class="number">5357</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.51967</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33438</span>: [udp sum ok] UDP, length <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009243</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">2</span>, id <span class="number">5358</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.45922</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33439</span>: [udp sum ok] UDP, length <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009281</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">3</span>, id <span class="number">5359</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)//ttl==<span class="number">3</span></span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.34392</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33440</span>: [udp sum ok] UDP, length <span class="number">32</span>  </span><br><span class="line">    <span class="number">101.232</span><span class="meta">.192</span><span class="meta">.1</span> &gt; <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span>: ICMP time exceeded <span class="keyword">in</span>-transit, length <span class="number">60</span></span><br><span class="line">	<span class="built_in">IP</span> (tos <span class="number">0x0</span>, id <span class="number">945</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.57724</span> &gt; <span class="number">119.75</span><span class="meta">.216</span><span class="meta">.20</span><span class="meta">.33440</span>: UDP, length <span class="number">32</span></span><br><span class="line">//第三个路由器回复icmpc超时</span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">59.304604</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">59</span>, id <span class="number">0</span>, offset <span class="number">0</span>, flags [DF], proto UDP (<span class="number">17</span>), length <span class="number">161</span>)</span><br></pre></td></tr></table></figure>
<p>从上面包的情况可以看到:</p>
<ul>
<li>设备首先发送ucp包。若用更详细的打印看到端口号为源55050 目的端口:33443别的设备可能不同，但是都很大，这样到达时会发出端口不可达；ttl字段从1递增，源地址目的地址不变</li>
<li>路由器根据ttl的值，回复icmp超时包，回复给设备，从源地址可以看到，经过的路由器；</li>
<li>该icmp的包格式：<br>类型11  code 0/1  校验和<br>ip首部（包括选项)+原始ip数据报中数据的前8个字节</li>
<li>注意：每一次的路由都可能不一样</li>
</ul>
<h5 id="关于ip源站选路选项"><a href="#关于ip源站选路选项" class="headerlink" title="关于ip源站选路选项"></a>关于ip源站选路选项</h5><ul>
<li>ip通常都是动态的，即每个路由都要判断数据报下面该转发到哪个路由器，一般不对此进行控制；这里提供的思想是：</li>
<li>由源站发送者指定路由，即经过哪些ip</li>
<li>分为严格的源路由选择和宽松的源站选路</li>
<li>前者必须采用确切的路由，若发现失败则路由器返回源站选路失败的icmp报文；</li>
<li>后者致命一个数据包经过的ip清单，但是数据包在清单上指明的任意两个地址之间可以通过其他路由器；</li>
<li>ip源站路由选项的格式：<br>包含在ip头部的选项中，因长度有限只能包含9个ip:<br>code(1) len(1) ptr(1) ip1(4) ip2(4)….</li>
<li>eg: traceroute -g 192.168.23.1 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></li>
</ul>
<h5 id="traceroute实现"><a href="#traceroute实现" class="headerlink" title="traceroute实现"></a>traceroute实现</h5><ul>
<li>参考linux traceroute源码实现；</li>
<li>主要就是发送一多个dp包设置ttl递增，并将接收到的icmp报文打印出来；直到收到端口不可达报文时退出；</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_string</title>
    <url>/2018/06/24/leetcode-string/</url>
    <content><![CDATA[<h3 id="leetcode-string"><a href="#leetcode-string" class="headerlink" title="leetcode_string"></a>leetcode_string</h3><h4 id="传统字符串匹配："><a href="#传统字符串匹配：" class="headerlink" title="传统字符串匹配："></a>传统字符串匹配：</h4><ul>
<li>简单写写,变量命名等就先不纠结了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">char</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'\0'</span>||p[<span class="number">0</span>]==<span class="string">'\0'</span>)</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"p or s is null"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> k=<span class="number">0</span>,j=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;s[i]!=<span class="string">'\0'</span>&amp;&amp;s[k]!=<span class="string">'\0'</span>;)</span><br><span class="line">		&#123;</span><br><span class="line">		     <span class="keyword">if</span>(p[j]==<span class="string">'\0'</span>)</span><br><span class="line">				   <span class="keyword">break</span>;	 </span><br><span class="line">			 <span class="keyword">if</span>(s[k]==p[j])</span><br><span class="line">			 &#123;</span><br><span class="line">					 k++;</span><br><span class="line">					 j++;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">else</span> <span class="comment">//不匹配时重新来过</span></span><br><span class="line">			 &#123;</span><br><span class="line">					 i++;</span><br><span class="line">					 k=i;</span><br><span class="line">					 j=<span class="number">0</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span>(p[j]==<span class="string">'\0'</span>)</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kmp匹配算法"><a href="#kmp匹配算法" class="headerlink" title="kmp匹配算法"></a>kmp匹配算法</h4><p>kmp算法：基本过程见另一篇文章数据结构之字符串<a id="more"></a>，这里贴写代码(未经大数据检验，谨慎观看)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextfunc</span><span class="params">(<span class="keyword">char</span> p[],<span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">   next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(p[j]!=<span class="string">'\0'</span>)</span><br><span class="line">   &#123;</span><br><span class="line">		   <span class="keyword">if</span>(k==<span class="number">0</span>||p[j]==p[k])</span><br><span class="line">		   &#123;</span><br><span class="line">				   ++j;</span><br><span class="line">				   ++k;</span><br><span class="line">				   next[j]=k;</span><br><span class="line">		   &#125;</span><br><span class="line">		   <span class="keyword">else</span></span><br><span class="line">				   k=next[k];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">char</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> next[<span class="number">100</span>];</span><br><span class="line">   nextfunc(p,next);</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>;s[i]!=<span class="string">'\0'</span>&amp;&amp;p[j]!=<span class="string">'\0'</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">		   <span class="comment">//if(j==-1)j=0;</span></span><br><span class="line">		   <span class="keyword">if</span>(s[i]==p[j])</span><br><span class="line">		   &#123;</span><br><span class="line">		     j++;</span><br><span class="line">			 <span class="keyword">continue</span>;</span><br><span class="line">		   &#125;</span><br><span class="line">		   <span class="keyword">while</span>(s[i]!=p[j]&amp;&amp;j&gt;=<span class="number">0</span>)j=next[j];</span><br><span class="line">		   j++;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">if</span>(p[j]==<span class="string">'\0'</span>)</span><br><span class="line">		 <span class="keyword">return</span> i-j;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">		 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单测试<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">char</span> a[<span class="number">19</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'s'</span>,<span class="string">'s'</span>,<span class="string">'f'</span>,<span class="string">'r'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>&#125;;</span><br><span class="line">		<span class="keyword">char</span> b[<span class="number">10</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'s'</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> pos=strStr(a,b);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;pos&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> pos2=kmp(a,b);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;pos2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="其他字符串算法题目："><a href="#其他字符串算法题目：" class="headerlink" title="其他字符串算法题目："></a>其他字符串算法题目：</h4><h5 id="判读字符串是否为回文串"><a href="#判读字符串是否为回文串" class="headerlink" title="判读字符串是否为回文串"></a>判读字符串是否为回文串</h5><ul>
<li>所谓回文串即正者读反着读都一样：</li>
<li>解决方案：<ul>
<li>1.设置两个索引，一个从字符串开始位置往后走，一个从字符串最后的位置往前走，比较这两个索引指向的字符是否相等，直到遍历完整个字符串；注意这里其实并不需要遍历整个字符串，一个索引只需要走一半就可以，回文串两边对称的。</li>
<li>2.利用栈，思路类似</li>
</ul>
</li>
</ul>
<h5 id="字符串转整数-atoi"><a href="#字符串转整数-atoi" class="headerlink" title="字符串转整数(atoi)"></a>字符串转整数(atoi)</h5><ul>
<li>分析：这个题目需要注意的是各种不规则的输入和其他边缘条件如int整数的范围等</li>
<li>解决方案:<ul>
<li>若是严格的检查，则判断字符ASCII码是否在0-9之间，注意整数的首位不能为0）；整数的正负；数据是否溢出；是否数据的表现形式如33x8fe；等等。</li>
<li>非严格的检查，如遇到非法的字符跳过即可；首位为0时跳过或者当成八进制等等</li>
</ul>
</li>
</ul>
<h5 id="对两个二进制字符串求和"><a href="#对两个二进制字符串求和" class="headerlink" title="对两个二进制字符串求和"></a>对两个二进制字符串求和</h5><ul>
<li>如”111”+”101”=”1100”</li>
<li>解决方案：<ul>
<li><ol>
<li>像十进制那样直接求和，进位，从最右边的字符开始，若相加大于1则进位，注意两个字符串可能一个很长一个很短，而进位可能一直需要延续</li>
</ol>
</li>
<li>2.将两个字符串分别转换为十进制再做运算，结果再转为二进制</li>
</ul>
</li>
</ul>
<h5 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h5><ul>
<li>暴力方法：将所有子串列出来先判断哪些是回文串，再取长度最长的；<h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5></li>
<li>我对正则表达式的处理方案一直很倾向于用状态机，这种方法可以用图表示出来，方案的完备性好判断，别人也好理解；</li>
<li>递归方案<h5 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h5></li>
<li>找出字符串数组中的最长公共前缀：给定一个字符串数组，找出他们的最长公共前缀</li>
<li>分析：这道题目需求不明确，是需要 所有的字符串=都有的公共前缀还是若只有部分字符串有公共前缀也可以？也可能我理解有误~</li>
</ul>
<h5 id="实现strtod-函数"><a href="#实现strtod-函数" class="headerlink" title="实现strtod()函数"></a>实现strtod()函数</h5><ul>
<li>即判断一个字符串是否表示一个数字如:”1.0”</li>
<li>分析：可以用状态机实现</li>
</ul>
<h5 id="整数和罗马数字的相互转换"><a href="#整数和罗马数字的相互转换" class="headerlink" title="整数和罗马数字的相互转换"></a>整数和罗马数字的相互转换</h5><ul>
<li>这道题有些无聊<h5 id="count-and-say"><a href="#count-and-say" class="headerlink" title="count and say"></a>count and say</h5></li>
<li>一个数列如下：<br>1 11 21 1211 111221,…<br>意思是1,第二个表示第一个的情况，即1个1故为11,第三个数表示第二个数的情况，即两个1,21，以此类推  </li>
<li>求数列中的第n个数</li>
<li>解决方案，直接模拟，一个一个算出来</li>
</ul>
<h5 id="Anagrams"><a href="#Anagrams" class="headerlink" title="Anagrams:"></a>Anagrams:</h5><ul>
<li>字符串中的打乱字母顺序从而得到新的单词如eat打乱后得到tea等</li>
</ul>
<h5 id="给定绝对路径简化它"><a href="#给定绝对路径简化它" class="headerlink" title="给定绝对路径简化它"></a>给定绝对路径简化它</h5><h5 id="在一个英文句子中找到最后一个单词的长度"><a href="#在一个英文句子中找到最后一个单词的长度" class="headerlink" title="在一个英文句子中找到最后一个单词的长度"></a>在一个英文句子中找到最后一个单词的长度</h5>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_string</tag>
      </tags>
  </entry>
  <entry>
    <title>DS_string</title>
    <url>/2018/06/24/DS-string/</url>
    <content><![CDATA[<h3 id="数据结构之串"><a href="#数据结构之串" class="headerlink" title="数据结构之串"></a>数据结构之串</h3><p>欢迎来到简单而又复杂的串世界,博主许久没有去研究串，还停留在以前学习和使用串的水平，再来一波学习和归纳，发现串的基本用法其实简单，也好理解，但是衍生出来的和应用相关，而且复杂，下面道来；<a id="more"></a></p>
<h4 id="串的基本"><a href="#串的基本" class="headerlink" title="串的基本"></a>串的基本</h4><h5 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h5><ul>
<li>“a1a2…..an”,其中包含字母，广义上可以是任意字符</li>
<li>在c/c++中结尾带’\0’，python则不带，长度均不包含’\0’</li>
<li>串长度-不同编码不同，根据具体需要如字节，实际字符等</li>
<li>空串和空白串，空白又可能是tab,回车，空格等等“</li>
<li>串的子串:子串个数：n(n+1)/2–等差数列，<h5 id="串常用的数据结构"><a href="#串常用的数据结构" class="headerlink" title="串常用的数据结构"></a>串常用的数据结构</h5></li>
<li><p>串常量–存在从汇编去看－数据段(data)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    .file	<span class="string">"test.c"</span></span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">"kesance"</span></span><br><span class="line">.LC1:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">"%d\n"</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br></pre></td></tr></table></figure>
</li>
<li><p>串数组:<br>将字符串存在顺序数组中</p>
</li>
<li>堆分配存在链表中<h5 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h5></li>
<li>子串个数：</li>
<li>串赋值</li>
<li>串比较</li>
<li>求串长</li>
<li>串拼接</li>
<li>求子串</li>
<li>替换子串</li>
<li>定位子串的位置<h4 id="字符编码和字符串匹配"><a href="#字符编码和字符串匹配" class="headerlink" title="字符编码和字符串匹配"></a>字符编码和字符串匹配</h4><h5 id="字符串的编码"><a href="#字符串的编码" class="headerlink" title="字符串的编码"></a>字符串的编码</h5></li>
<li>所谓字符编码，就是将字符用二进制唯一表示。在计算机的世界里不是1就是0，无论什么字符最后存入的还是二进制数，只是从内存中读出来时解析不同而已，即如让计算机将读出来的00111000解析成数字8,如文本显示程序，当设定为某种编码时，将字节流解析成对应的字符～现在看到的许多字体库也是这样的，将一串二进制串和某个字体对应起来，解析程序负责处理匹配和显示等</li>
<li><a href="https://en.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Unicode</a>　unicode编码了解一下</li>
</ul>
<h5 id="传统模式匹配算法"><a href="#传统模式匹配算法" class="headerlink" title="传统模式匹配算法"></a>传统模式匹配算法</h5><p>模式匹配，就是在字符串里面匹配另一个串相似或者相同的子串，传统的想法也和一般人想到的一样，扫描并一个一个字符对比，若第二串失配，则第二串重新匹配第一串的第二个，接着往下。。</p>
<h5 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h5><p>kmp作为完全匹配算法中的高效算法，基本原理如下：ps:大学学这个算法只学了它是什么原理，还没去想为什么这么做等）</p>
<ul>
<li><p><strong>基本思想</strong>：从上面看传统的匹配算法：  </p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> e f g </span><br><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> d <span class="selector-tag">a</span> e f</span><br></pre></td></tr></table></figure>
<p> 像上面的字符串匹配，第一次失配的地方是在c,则按照传统的方式，则应该重新：</p>
 <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> e f g</span><br><span class="line">  <span class="selector-tag">a</span> <span class="selector-tag">b</span> d <span class="selector-tag">a</span> e f</span><br></pre></td></tr></table></figure>
<p>但是其实如果是我们人去做匹配时，则会直接从：  </p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> e f g</span><br><span class="line">      <span class="selector-tag">a</span> <span class="selector-tag">b</span> d <span class="selector-tag">a</span> e f</span><br></pre></td></tr></table></figure>
<p>开始匹配，而kmp的基本思想也是这样；<br>例子：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c d <span class="selector-tag">a</span> <span class="selector-tag">b</span> c f g e </span><br><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c e <span class="selector-tag">a</span> <span class="selector-tag">b</span> c t</span><br><span class="line">第一次失配在d,那下一次应该在  </span><br><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c d <span class="selector-tag">a</span> <span class="selector-tag">b</span> c f g e </span><br><span class="line">        <span class="selector-tag">a</span> <span class="selector-tag">b</span> c e <span class="selector-tag">a</span> <span class="selector-tag">b</span> c t</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>所以它分为两部分，１是模式串在移动时候遵循的基本原理，２是当失配时，模式串的哪个位置的字符和源串的当前位置进行重新匹配；</li>
<li>1基本原理，重复：当模式串中存在大量的重复时，效果尤为明显<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c d <span class="selector-tag">a</span> <span class="selector-tag">b</span> c e f g </span><br><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c d <span class="selector-tag">a</span> <span class="selector-tag">b</span> c t</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述例子一样，可以看到 以d 为中点，前后有相同的串，abc,则显然next函数也能隐士检测到这个，所以当显然因为模式串的前后abc相等，而后abc又和源串的后abc相等，所以源串的后abc和模式串的前abc想等，自然失配时候就可以从模式串的d开始匹配起</p>
<ul>
<li><p><strong>2重点在next的计算，它决定当发生失配时，模式串如何移动</strong>：  </p>
<ul>
<li>假设模式串为P,j是当前模式串正在匹配的位置，源串为S,i是源串的当前位置，k是当P[j]!=S[i]时，P应该和S[i]比较的位置，以next[j]=k表示，故关键是求出next数组，显然k&lt;j</li>
<li>next如何计算得到:其实要利用前面的基本原理，<br>P[0-k-1]==P[j-k~j-1]==S[i-k到i-1] (即next[j]=k)<br>所以要求next[j+1]=?<br>-若P[k]==P[j]<br>P[0-k-1]+P[k]==P[j-k~j-1]+P[j]<br>即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1<br>-若P[k]!=P[j]<br>我们已经知道（0，k-1）串和（j-k,j-1）串是相等的，所以可以把（0，k-1）串当做一个新的模式串，发现在新模式串中<br>（0，next[k]-1）串与（k-next[k],k-1）串相等，所以（j-k,j-1）中存在与（0，next[k]-1）相等的串，所以可以把j移动到next[k],继续比较和移动。</li>
</ul>
</li>
<li><p>具体程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显然，next[0]=-1,此时无法向左边移动了源串模式串都要移动</span></span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>,此时只能向左移动到<span class="number">0.</span></span><br><span class="line"><span class="keyword">int</span> getnext(<span class="keyword">char</span> *P,<span class="keyword">int</span> next[])&#123;</span><br><span class="line">    j=<span class="number">1</span>,next[j]=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;<span class="keyword">sizeof</span>(P)&#123;</span><br><span class="line">      <span class="keyword">if</span>(k==<span class="number">0</span>||P[j++]==P[k++])</span><br><span class="line">            next[j]==k;<span class="comment">//next[j]=next[j]+1</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">           k=next[k];</span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="串和哈夫曼编码"><a href="#串和哈夫曼编码" class="headerlink" title="串和哈夫曼编码"></a>串和哈夫曼编码</h5><ul>
<li>霍夫曼编码是和编码相关的一个算法，是将一个串编码为二进制整数，如类似AABXBDHADFBFJD编码为1010011100011101001,而霍夫曼编码则作为转换算法，Huffman编码使得每一个字符的编码都与另一个字符编码的前一部分不同，不会出现像’A’：00，  ’B’：001，这样的情况，解码也不会出现冲突。</li>
</ul>
<h4 id="论文查重对比的几个算法-文本相似度）"><a href="#论文查重对比的几个算法-文本相似度）" class="headerlink" title="论文查重对比的几个算法(文本相似度）"></a>论文查重对比的几个算法(文本相似度）</h4><ul>
<li>杰卡德（Jaccard）相似系数<br>这种相似度计算方式相对简单，原理也易于理解，就是计算单词集合之间的交集和并集大小的比例，该值越大，表示两个文本越相似。在涉及到大规模并行计算时，该方法效率上有一定的优势。</li>
<li>余弦（Cosine）相似度<br>余弦相似度是利用计算两个向量之间的夹角，夹角越小相似度越高，其公式为：<br>假定A和B是两个n维向量，A是[A1,A2,…,An],B是[B1,B2,B3,…,Bn],则A与B的夹角余弦等于</li>
<li>等等,用时再看：<br><a href="https://www.cnblogs.com/huilixieqi/p/6493089.html" target="_blank" rel="noopener">https://www.cnblogs.com/huilixieqi/p/6493089.html</a></li>
<li>linux下的diff命令<br>还有win上的beyondcompare软件，这两个是用于比较文本的差异的，在代码移植时经常用到</li>
</ul>
<h4 id="串匹配－正则表达式"><a href="#串匹配－正则表达式" class="headerlink" title="串匹配－正则表达式"></a>串匹配－正则表达式</h4><ul>
<li>正则表达式用于匹配文本字符串，但是并不一定是完全匹配，且是匹配的串出现有随意性</li>
</ul>
<h5 id="正则表达式的理论基础"><a href="#正则表达式的理论基础" class="headerlink" title="正则表达式的理论基础"></a>正则表达式的理论基础</h5><ul>
<li>最早接触到正则表达式，是在大三学习编译原理的时候，解析词法语法的时候会用到正则表达式，用来过滤关键词，像c语言的很多关键词，以及判断它是不是合法的表达式，等等，常用的是lex和yacc,最原始的是自己的实现对词法和语法的解析，而不借助的lex；</li>
<li>正则表达，语法树，常用有限状态机来来实现，功能强大的如图灵机；</li>
</ul>
<h5 id="正则表达式和编译原理"><a href="#正则表达式和编译原理" class="headerlink" title="正则表达式和编译原理"></a>正则表达式和编译原理</h5><h5 id="正则表达式的基本实现"><a href="#正则表达式的基本实现" class="headerlink" title="正则表达式的基本实现"></a>正则表达式的基本实现</h5><ul>
<li>用c实现正则表达实现词法分析：</li>
<li><h5 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h5></li>
<li>语言支持</li>
<li>脚本语言支持情况</li>
<li>sed,awk</li>
</ul>
<h4 id="串和流"><a href="#串和流" class="headerlink" title="串和流"></a>串和流</h4><ul>
<li>流，所有的文本流</li>
<li>流分为二进制流和文本流</li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_routeicmp</title>
    <url>/2018/06/10/tcpip-routeicmp/</url>
    <content><![CDATA[<h3 id="IP选路和ICMP协议"><a href="#IP选路和ICMP协议" class="headerlink" title="IP选路和ICMP协议"></a>IP选路和ICMP协议</h3><h4 id="IP如何选路概述："><a href="#IP如何选路概述：" class="headerlink" title="IP如何选路概述："></a>IP如何选路概述：</h4><ul>
<li>ip选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组，区别于选路策略，后者是一组决定把哪些路由放入路由表的规则；ip执行选路机制，而路由守护程序则一般提供选路策略如rip,ospf</li>
<li>点对点时，直接送到  </li>
<li>非点对点时，经过路由器送到  </li>
<li>Ip层可以是配置为路由或者主机前者非则转发，后者非则丢弃</li>
<li>路由表项：每一项为<a id="more"></a><ul>
<li>目的ip地址（网络地址指定网络中所有主机或主机地址);</li>
<li>下一站路由器的ip地址，可能充当中继转发的，下一站非终点；</li>
<li>标志：指明目的地址是网络还是主机，下一站是路由器还是直连的接口</li>
<li>数据传输的网络接口如wlan0,eth0</li>
</ul>
</li>
<li>ip选路是逐跳进行的，</li>
<li>例子：<br>没连接热点前：<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">ernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line"><span class="number">10.42</span><span class="number">.0</span><span class="number">.0</span>       *               <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>   U     <span class="number">600</span>    <span class="number">0</span>        <span class="number">0</span> wlp2s0</span><br><span class="line">link-local      *               <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>     U     <span class="number">1000</span>   <span class="number">0</span>        <span class="number">0</span> wlp2s0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>连接热点后：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line"><span class="section">default</span>         <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         UG    <span class="number">600</span>    <span class="number">0</span>        <span class="number">0</span> wlp2s0</span><br><span class="line">link-local      *               <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>     U     <span class="number">1000</span>   <span class="number">0</span>        <span class="number">0</span> wlp2s0</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>     *               <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>   U     <span class="number">600</span>    <span class="number">0</span>        <span class="number">0</span> wlp2s0</span><br></pre></td></tr></table></figure></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Destination 	目标网段或者主机</span><br><span class="line">Gateway 	网关地址，”*” 表示目标是本主机所属的网络，不需要路由</span><br><span class="line">Genmask 	网络掩码</span><br><span class="line">Flags 	标记。一些可能的标记如下：</span><br><span class="line">  	U — 路由是活动的</span><br><span class="line">  	H — 目标是一个主机</span><br><span class="line">  	G — 路由指向网关</span><br><span class="line">  	R — 恢复动态路由产生的表项</span><br><span class="line">  	D — 由路由的后台程序动态地安装,(由重定向报文创建）</span><br><span class="line">  	M — 由路由的后台程序修改(已被重定向报文修改）</span><br><span class="line">  	! — 拒绝路由</span><br><span class="line">Metric 	路由距离，到达指定网络所需的中转数（linux 内核中没有使用）</span><br><span class="line">Ref 	路由项引用次数（linux 内核中没有使用）</span><br><span class="line"><span class="keyword">Use</span> 	此路由项被路由软件查找的次数</span><br><span class="line">Iface 	该路由表项对应的输出接口</span><br></pre></td></tr></table></figure>
<h5 id="如何搜索路由表"><a href="#如何搜索路由表" class="headerlink" title="如何搜索路由表"></a>如何搜索路由表</h5><ul>
<li>搜索路由表，目的ip地址匹配条母时，送到该条目的下一站，否则下一步：</li>
<li>搜索路由表，寻找与目的网络相匹配的条目，找到则送到下一站，如本地局域网；否则下一步：</li>
<li>搜索路由表，寻找标为默认的条目，有则使用它</li>
<li>若走完最后一步都没有，则数据包无法被传送，会向生成数据包的程序返回主机不可达或者网络不可达的错误</li>
<li>详细例子见卷１，这里较清楚了</li>
</ul>
<h5 id="子网寻址rfc950"><a href="#子网寻址rfc950" class="headerlink" title="子网寻址rfc950"></a>子网寻址rfc950</h5><ul>
<li>主机号再分为子网号和主机号，子网掩码也跟着变化；这样可以缩小路由表规模，想象一个包含30个子网的B类地址和30个C类地址相比</li>
<li>此时，外网–&gt;网关–&gt;局域网１–&gt;局域网１中的子网（局域网）10–&gt;子网11。。。</li>
<li>所以此时网关并非就是其直接路由器，若主机在子网11,10中，路由器需要知道发往哪个子网，通过子网掩码</li>
<li>给定ip地址和子网掩码后能知道什么：<br>知道该主机所在的子网；路由器可以知道是本子网的主机还是本网络中其他子网的主机还是其他网络的主机。。。路由进行的比较不需要比较到主机，如先比较类别网络地址如A,B,C:<br>如我们主机为140.252.1.1,子掩码为255.255.255.0,则与目的ip地址比较：140.252.4.5,可以知道B类网络地址相同但是子网不同(1,4),就不用再比较主机了，</li>
</ul>
<h5 id="特殊的网络地址"><a href="#特殊的网络地址" class="headerlink" title="特殊的网络地址"></a>特殊的网络地址</h5><h5 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h5><ul>
<li>ifconfig -a<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">wlp2s0</span>    <span class="selector-tag">Link</span> <span class="selector-tag">encap</span><span class="selector-pseudo">:Ethernet</span>  <span class="selector-tag">HWaddr</span> <span class="selector-tag">48</span><span class="selector-pseudo">:5a</span><span class="selector-pseudo">:b6</span><span class="selector-pseudo">:6e</span><span class="selector-pseudo">:c9</span><span class="selector-pseudo">:5f</span>  </span><br><span class="line">          <span class="selector-tag">inet</span> <span class="selector-tag">addr</span><span class="selector-pseudo">:192.168.0.110</span>  <span class="selector-tag">Bcast</span><span class="selector-pseudo">:192.168.0.255</span>  <span class="selector-tag">Mask</span><span class="selector-pseudo">:255.255.255.0</span></span><br><span class="line">          <span class="selector-tag">inet6</span> <span class="selector-tag">addr</span>: <span class="selector-tag">fe80</span><span class="selector-pseudo">::d713</span><span class="selector-pseudo">:7c0f</span><span class="selector-pseudo">:b40c</span><span class="selector-pseudo">:c085</span>/<span class="selector-tag">64</span> <span class="selector-tag">Scope</span><span class="selector-pseudo">:Link</span></span><br><span class="line">          <span class="selector-tag">UP</span> <span class="selector-tag">BROADCAST</span> <span class="selector-tag">RUNNING</span> <span class="selector-tag">MULTICAST</span>  <span class="selector-tag">MTU</span><span class="selector-pseudo">:1500</span>  <span class="selector-tag">Metric</span><span class="selector-pseudo">:1</span></span><br><span class="line">          <span class="selector-tag">RX</span> <span class="selector-tag">packets</span><span class="selector-pseudo">:7032</span> <span class="selector-tag">errors</span><span class="selector-pseudo">:0</span> <span class="selector-tag">dropped</span><span class="selector-pseudo">:0</span> <span class="selector-tag">overruns</span><span class="selector-pseudo">:0</span> <span class="selector-tag">frame</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">TX</span> <span class="selector-tag">packets</span><span class="selector-pseudo">:4297</span> <span class="selector-tag">errors</span><span class="selector-pseudo">:0</span> <span class="selector-tag">dropped</span><span class="selector-pseudo">:0</span> <span class="selector-tag">overruns</span><span class="selector-pseudo">:0</span> <span class="selector-tag">carrier</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">collisions</span><span class="selector-pseudo">:0</span> <span class="selector-tag">txqueuelen</span><span class="selector-pseudo">:1000</span> </span><br><span class="line">          <span class="selector-tag">RX</span> <span class="selector-tag">bytes</span><span class="selector-pseudo">:3668623</span> (<span class="number">3.6</span> MB)  <span class="selector-tag">TX</span> <span class="selector-tag">bytes</span><span class="selector-pseudo">:703812</span> (<span class="number">703.8</span> KB)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h5><ul>
<li>其实这个命令的功能很强，可以相互开服务端客户端通信和反向shell</li>
<li>netstat -in<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Kernel Interface table</span><br><span class="line">Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">enp1s0     <span class="number">1500</span> <span class="number">0</span>         <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> <span class="number">0</span>             <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> BMU</span><br><span class="line">lo        <span class="number">65536</span> <span class="number">0</span>      <span class="number">1404</span>      <span class="number">0</span>      <span class="number">0</span> <span class="number">0</span>          <span class="number">1404</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> LRU</span><br><span class="line">wlp2s0     <span class="number">1500</span> <span class="number">0</span>      <span class="number">7257</span>      <span class="number">0</span>      <span class="number">0</span> <span class="number">0</span>          <span class="number">4311</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> BMRU</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">netstat -rn</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line"><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         UG        <span class="number">0</span> <span class="number">0</span>          <span class="number">0</span> wlp2s0</span><br><span class="line"><span class="number">169.254</span><span class="number">.0</span><span class="number">.0</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>     U         <span class="number">0</span> <span class="number">0</span>          <span class="number">0</span> wlp2s0</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>   U         <span class="number">0</span> <span class="number">0</span>          <span class="number">0</span> wlp2s0</span><br></pre></td></tr></table></figure>
<h5 id="初始化路由表"><a href="#初始化路由表" class="headerlink" title="初始化路由表"></a>初始化路由表</h5><ul>
<li>ifconfig设置接口地址，并用route　命令添加或删除路由表项<h5 id="主机可以选择转发或者不转发报文"><a href="#主机可以选择转发或者不转发报文" class="headerlink" title="主机可以选择转发或者不转发报文"></a>主机可以选择转发或者不转发报文</h5></li>
<li>在配置文件中配置ipfordwarding:</li>
<li>echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot<h4 id="ICMP协议rfc792"><a href="#ICMP协议rfc792" class="headerlink" title="ICMP协议rfc792"></a>ICMP协议rfc792</h4><h5 id="Icmp报文："><a href="#Icmp报文：" class="headerlink" title="Icmp报文："></a>Icmp报文：</h5></li>
<li>ICMP：IP头(20字节）+ICMP报文</li>
<li>IP头：<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code"> 0                   1                   2                   3</span></span><br><span class="line"><span class="code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中options和padding不一定有</p>
<ul>
<li><p>ICMP报文：type+code共同决定ICMP类型，如回显or差错，，，</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |     Code      |          Checksum             |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       different type and code has different content           |</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
</li>
<li><p>被封装于ip报文中，ip头加icmp,所有报文前四个字节都相同<br>(8位类型，8位代码，16位校验和）</p>
</li>
<li>类型+代码决定ICMP的报文类型，种类很多，见协议卷表</li>
<li>下列几种不会导致icmp差错报文：<ul>
<li>icmp差错报文；</li>
<li>目的地址为广播地址</li>
<li>作为链路层的广播地址</li>
<li>不是ip分片第一片</li>
<li>源地址不能为零地址，环回地址，广播地址或多播地址</li>
<li>上述是为了防止过去允许icmp差错报文对广播分组带来的广播风暴</li>
</ul>
</li>
<li><h5 id="ICMP协议总结几种类型："><a href="#ICMP协议总结几种类型：" class="headerlink" title="ICMP协议总结几种类型："></a>ICMP协议总结几种类型：</h5><ul>
<li>主机不可达</li>
<li>重定向错误</li>
<li>路由发现报文</li>
<li>icmp地址掩码请求和应答</li>
<li>icmp时间戳请求和应答</li>
<li>icmp端口不可达</li>
<li>ping 回显请求：</li>
<li>等等见表</li>
<li>且类型不同发送的报文格式不同</li>
</ul>
</li>
<li>主机不可达：当路由器收到一份ip数据报但是在路由表中搜索后找不到，不能转发时，会发送一份icmp主机不可达的差错报文</li>
<li>还有可能是已经经过了几个路由器后出现主机或网络不可达的情况，所以若是测试局域网，则先让路由器断开网络，ping路由器则确保问题不是在本地，而是在网络上；</li>
<li>icmp重定向错误：<br>举个例子，主机在路由表中搜索后将数据包发给默认路由，R1路由器，接着R1路由器搜索后发送给R2路由器，并同时发现它正在发送的接口(R2)和数据报到达的接口相同，即主机和两个路由器所在lan，即在同一个lan中）此时主机可以直接发送给R2,所以R1就发送一份ICMP重定向报文给主机，这样主机下次就可以直接发给R2了</li>
<li>如何更新路由表?通过ICMP的路由器发现报文：<br>以及利用路由器的定期广播多播它们的路由器通告报文rfc1256,而它一般是由用户守护进程来创建和处理</li>
<li>icmp地址掩码请求和应答，发送对某个ip地址请求地址掩码，并接收到子网掩码。路由器回复或者主机回复</li>
<li>icmp时间戳请求和应答，通过向某个IP主机发送这个，从而得到时间信息，telnet也可以进行，如NTP协议（网络时间协议）</li>
<li>icmp端口不可达：udp报文发送给主机后，若端口不匹配，对方主机会发送端口不可达的差错报文</li>
<li>ping回显，后面有文章记录ping程序编写<h4 id="动态选路"><a href="#动态选路" class="headerlink" title="动态选路"></a>动态选路</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5>上述讲的是静态路由表的情况：适合于1网络较小，2且与其他网络只有单个连接点，3且没有多余的路由时（如主路由失败，可以选择备用路由）；</li>
<li>总结：一种更新路由表的动态协议，从而达到最短路径  </li>
<li>上述三个条件不满足时，通常使用动态选路协议</li>
<li>当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时出现动态选路，路由器之间必须采用选路协议进行通信；路由器上有一个称为路由守护程序的进程，它运行选路协议，并与相邻的路由器通信，根据收到的信息，更新路由表</li>
</ul>
<h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><p>RIP ,OSPF(开放最短路径优先）,BGP</p>
<h5 id="宏观上看"><a href="#宏观上看" class="headerlink" title="宏观上看"></a>宏观上看</h5><p>在internet上，存在大量的主机，路由器等；并以一组自治系统(AS)的方式组织的，每个自治系统通常由单个实体管理，比如大学校园，公司，常常被定义为一个自治系统，NSFNET的internet骨干网形成一个自治系统；</p>
<ul>
<li>自治系统中使用的选路协议，称为内部网关协议IGP或者称为域内选路协议，这些协议有RIP,OSPF</li>
<li>用于不同自治系统之间的路由器，称为外部网关协议EGP,常见有BGP</li>
<li>unix选路守护程序：routed,gated等</li>
</ul>
<h5 id="RIP：rfc1058"><a href="#RIP：rfc1058" class="headerlink" title="RIP：rfc1058"></a>RIP：rfc1058</h5><ul>
<li>rip采用udp报文，端口号位520，为一种采用距离向量的协议,易受攻击</li>
<li>流程：<ul>
<li>初始化：启动一个路由守护进程时，先判断启动了哪些接口，接着在每个接口上发送请求报文，要求其他路由器发送完整的路由表，广播或点对点</li>
<li>接收请求：接收到上述请求后，会回复完整的路由表，否则处理请求报文每一个表项，若有链接到指明地址路由，则度量设置为我们的值，否则设置为16表示无穷大。返回响应</li>
<li>接收到响应后，更新路由表，如增加或修改或删除,采用Dijkstra算法得到最短路径树</li>
<li>定期选路更新，30s一次，进行广播发送完整路由表给相邻的路由器</li>
<li>触发更新：即每当度量发生变化，则对它进行更新，只需要发送度量变化的表项</li>
<li>定时器：3min内无更新路由，则度量设置为无穷大，标注为删除，再过60s删除并传波</li>
</ul>
</li>
<li>注:度量就是跳数，相邻路由度量为１</li>
<li>rip问题：无子网概念；路由器或链路故障要很久才能稳定下来，即收敛慢；易发生环回路由；跳数限制了网络大小15</li>
</ul>
<h5 id="OSPF开放最短路径优先：rfc1247"><a href="#OSPF开放最短路径优先：rfc1247" class="headerlink" title="OSPF开放最短路径优先：rfc1247"></a>OSPF开放最短路径优先：rfc1247</h5><ul>
<li>是一个链路状态协议；</li>
<li>使用ip协议而不是udp.tcp,</li>
<li>不与邻站交换距离信息而是主动测试与其他邻站相连链路状态，并将这些信息发送给它的其他邻站，邻站接着广播出去，每个路由器接收到后更新路由表</li>
<li>收敛快</li>
<li>可以对每个ip服务类型计算各自的路由集，意味着对任何目的，可以有多个路由表表项，每个表项对应一个ip服务类型；</li>
<li>给每个接口指派一个费用，通过吞吐率，往返时间，可靠性等，可以给每个ip服务类型指派一个费用</li>
<li><strong>同一个目的地址存在多个相同费用的路由时，在这些路由上平均分配流量，即流量平衡</strong></li>
<li><strong>支持子网</strong></li>
<li>路由器之间的点对点链路不需要每端都有一个ip地址，－无编号网络，节省ip</li>
<li>多播而非广播</li>
</ul>
<h5 id="BGP边界网关协议rfc1268"><a href="#BGP边界网关协议rfc1268" class="headerlink" title="BGP边界网关协议rfc1268"></a>BGP边界网关协议rfc1268</h5><ul>
<li>自治系统分类：<ul>
<li>残桩自治系统，他和其他自治系统只有单个连接，只有本地流量</li>
<li>多接口自治系统，和其他多个自治系统有多个链接，但是拒绝传送流量</li>
<li>转送自治系统，多链接且在一些策略准则下，它可以传送本地流量和通过流量</li>
</ul>
</li>
<li>是距离向量协议，用于自治系统之间，定期发送keepalive报文，30s<h5 id="CIDR无类型域间选路：rfc1518-1519"><a href="#CIDR无类型域间选路：rfc1518-1519" class="headerlink" title="CIDR无类型域间选路：rfc1518,1519"></a>CIDR无类型域间选路：rfc1518,1519</h5>待探索</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_conanddest_semantics</title>
    <url>/2018/06/09/cpp-conanddest-semantics/</url>
    <content><![CDATA[<h3 id="构造和析构函数语义学"><a href="#构造和析构函数语义学" class="headerlink" title="构造和析构函数语义学"></a>构造和析构函数语义学</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>即使是abstract base class也可能需要手动写constructor,de…,关键是看它有没有non satic data member  <a id="more"></a><br>例如:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_class</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="keyword">virtual</span> ~Abstract_base() = <span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span></span>=<span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> _mumble;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">       <span class="keyword">char</span> *_mumble;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>  上述例子，该抽象类本身不能被实例化，但是可以被继承，被继承时在构造时必须初始化 “mumble”,此时就需要用它的默认构造函数，所以必须为这个抽象类写一个构造函数；   </p>
<h4 id="2-纯虚函数的存在："><a href="#2-纯虚函数的存在：" class="headerlink" title="2. 纯虚函数的存在："></a>2. 纯虚函数的存在：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstra_class</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">	   <span class="comment">// virtual ~Abstra_class() =0;</span></span><br><span class="line">		<span class="keyword">virtual</span> ~Abstra_class() &#123; <span class="keyword">delete</span> _mumble;<span class="built_in">cout</span>&lt;&lt;<span class="string">"use ~abstra_class"</span>;&#125;</span><br><span class="line">		<span class="comment">//virtual void interface() const=0;</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"use interface Abstra_class:"</span>;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> _mumble;</span><br><span class="line">		&#125;</span><br><span class="line">		Abstra_class()&#123;_mumble=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];<span class="built_in">cout</span>&lt;&lt;<span class="string">"construct:Abs.."</span>;&#125;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="keyword">char</span>* _mumble;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dev</span> :</span> <span class="keyword">public</span> Abstra_class &#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				~dev() &#123;dd=<span class="number">0</span>;&#125;</span><br><span class="line">				dev()&#123;dd=<span class="number">3</span>;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">void</span> <span class="title">useA</span> <span class="params">()</span></span>&#123;</span><br><span class="line">               Abstra_class::interface();<span class="comment">//即使可以这样，但是链接失败，即因该函数的定义=0,重新加上定义使之不为pure就ok了</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">if</span>(dd==<span class="number">4</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"re"</span>;&#125;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="keyword">int</span> dd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  dev ddd;</span><br><span class="line">		ddd.useA();</span><br><span class="line">		ddd.interface();</span><br><span class="line">	  <span class="comment">//  Abstra_class::interface();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：construct:Abs..use interface Abstra_class:use ~Abstra_class: </p>
<p>　“可以定义和调用pure virtual func ,但是只能被静态的调用，而不能通过虚拟机制 “这个在g++上实验了下，发现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstra_class</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">	   <span class="comment">// virtual ~Abstra_class() =0;</span></span><br><span class="line">		<span class="keyword">virtual</span> ~Abstra_class() &#123; <span class="keyword">delete</span> _mumble;<span class="built_in">cout</span>&lt;&lt;<span class="string">"use ~Abstra_class:"</span>;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span></span>=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//virtual void interface() const &#123; cout&lt;&lt;"use interface Abstra_class:";&#125;</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> _mumble;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">ii</span><span class="params">()</span> <span class="keyword">const</span></span>=<span class="number">0</span>;<span class="comment">//ensure is a abstra class</span></span><br><span class="line">		Abstra_class()&#123;_mumble=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];<span class="built_in">cout</span>&lt;&lt;<span class="string">"construct:Abs.."</span>;&#125;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="keyword">char</span>* _mumble;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Abstra_class::interface() <span class="keyword">const</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dev</span> :</span> <span class="keyword">public</span> Abstra_class &#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				~dev() &#123;dd=<span class="number">0</span>;&#125;</span><br><span class="line">				dev()&#123;dd=<span class="number">3</span>;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">void</span> <span class="title">useA</span> <span class="params">()</span></span>&#123;</span><br><span class="line">                Abstra_class::interface();<span class="comment">//即使可以这样，但是链接失败，即因该函数的引用为0</span></span><br><span class="line">		           dd=<span class="number">4</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">						<span class="keyword">if</span>(dd==<span class="number">4</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"\nre\n"</span>;</span><br><span class="line">						<span class="comment">//Abstra_class::interface();</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ii</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"is implenment"</span>;&#125;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="keyword">int</span> dd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  dev ddd;</span><br><span class="line">		ddd.useA();</span><br><span class="line">		ddd.interface();</span><br><span class="line">	Abstra_class *pt=&amp;ddd;</span><br><span class="line">	pt-&gt;interface();</span><br><span class="line">	  <span class="comment">//  Abstra_class::interface();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  输出了两次re,说明可以通过虚拟机制调用它；interface在这里被内联的定义了空的函数，它不算pure了，所以上述说法感觉存在问题。。。<br>　注意，因为在每一个derived class　destructor会被扩展，以静态方式调用每一个virtual base class 和上一层的desturctor,<br>     所以只要缺少任何一个 base destructor定义则链接失败　，所以需要定义pure virtual destructor<br>      一个比较好的替代方式就是不要把vitual dect~定义为pure<br>      考虑到成本，不要把所有的函数都定以为virtual</p>
<p>3)虚拟规格的存在：<br>　　　　在virtual func要不要为const ,主要看要不要对date member做修改<br>所以不要随便定义为pure,virtual const,毕竟效率</p>
<h4 id="考虑几种情况下的构造情况："><a href="#考虑几种情况下的构造情况：" class="headerlink" title="考虑几种情况下的构造情况："></a>考虑几种情况下的构造情况：</h4><h5 id="一、无继承情况下对象构造几种方式："><a href="#一、无继承情况下对象构造几种方式：" class="headerlink" title="一、无继承情况下对象构造几种方式："></a>一、无继承情况下对象构造几种方式：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point global;　<span class="comment">//周期：程序的生命周期，exit前</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Point local;　<span class="comment">//此函数的周期，调用默认构造函数但是不会初始化成员</span></span><br><span class="line">   Point *heap=<span class="keyword">new</span> Point;<span class="comment">//delete 前，调用默认构造函数，但不会初始化成员</span></span><br><span class="line">   *heap=local;<span class="comment">//local若未调用用户初始化的构造函数，则warning,调用拷贝赋值函数，maybe 位搬移</span></span><br><span class="line">   <span class="keyword">delete</span> heap;<span class="comment">//默认析构函数</span></span><br><span class="line">   <span class="keyword">return</span> local;<span class="comment">//maybe拷贝构造或者位搬移</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>考虑这几个对象的声明周期</li>
<li>在c中，global会被放入bss中，未初始化，但是c++中所有的全局对象被当做“初始化过的数据”，会调用constructor函数　可以测试一下</li>
<li>一般情况下，c++默认为类生成：default constructor,destructor,copy constructor,copy assignment operator<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">			Point ()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"in constructor "</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">			~Point() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"in destructor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point glo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>显然在定义Point glo的时候构造函数是会调用的</p>
<p>１、抽象数据类型：<br>　　根据需要决定是否写constructor destructor或者默认的就足够了<br>　　　global类型的对象直到程序激活才调用构造函数<br>　　　显性的初始化列表比将构造函数扩展为inline效率更高，后者需要赋值等，看下面例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0.0</span>, <span class="keyword">double</span> y = <span class="number">0.0</span>, <span class="keyword">double</span> z = <span class="number">0.0</span>) :_x(x), _y(y), _z(z)&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; _x &lt;&lt; <span class="built_in">endl</span> &lt;&lt; _y &lt;&lt; <span class="built_in">endl</span> &lt;&lt; _z &lt;&lt; <span class="built_in">endl</span>; &#125;;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">double</span> _x, _y, _z;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    Point local1 = &#123; <span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span> &#125;;<span class="comment">//用g++ --std=c++11可以，若为double a=1.5; ..=&#123;a,...&#125;变量形式则不行（c++11可以） </span></span><br><span class="line">    local1.print();  </span><br><span class="line">  </span><br><span class="line">    system(<span class="string">"pause"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; ``` </span><br><span class="line">而在显性初始化列表（<span class="keyword">explicit</span> initialization <span class="built_in">list</span>)-&gt;xxx=&#123;yyy&#125;;使用时较快是如下原因：  </span><br><span class="line">函数的activation record 被放进程序的堆栈时，initializatioin <span class="built_in">list</span> 中的常量就可以被放进local1的内存中了;  </span><br><span class="line">但是<span class="keyword">explicit</span> initialization <span class="built_in">list</span>带来三个缺点：</span><br><span class="line">+ 只有当<span class="class"><span class="keyword">class</span> <span class="title">member</span> 都是<span class="title">public</span>时才生效，这点实验<span class="title">private</span>时也可以  </span></span><br><span class="line"><span class="class">+ 只能在&#123;</span> &#125;中指定常量，因为在编译期间进行评估求值</span><br><span class="line">+ 由于编译器为自动施行，所以失败的可能性更高  </span><br><span class="line">看一下汇编代码：</span><br><span class="line">```cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span>  y = <span class="number">0</span>, <span class="keyword">int</span> z = <span class="number">0</span>) :_x(x), _y(y), _z(z)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
 <figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x400938</span> push   <span class="symbol">%rbp</span></span><br><span class="line"><span class="number">0x400939</span> mov    <span class="symbol">%rsp</span>,<span class="symbol">%rbp</span></span><br><span class="line"><span class="number">0x40093c</span> mov    <span class="symbol">%rdi</span>,<span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="symbol">%rbp</span>)</span><br><span class="line"><span class="number">0x400940</span> mov    <span class="symbol">%esi</span>,<span class="number">-0</span>xc(<span class="symbol">%rbp</span>)</span><br><span class="line"><span class="number">0x400943</span> mov    <span class="symbol">%edx</span>,<span class="number">-0</span><span class="keyword">x</span><span class="number">10</span>(<span class="symbol">%rbp</span>)</span><br><span class="line"><span class="number">0x400946</span> mov    <span class="symbol">%ecx</span>,<span class="number">-0</span><span class="keyword">x</span><span class="number">14</span>(<span class="symbol">%rbp</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; _x &lt;&lt; <span class="built_in">endl</span> &lt;&lt; _y &lt;&lt; <span class="built_in">endl</span> &lt;&lt; _z &lt;&lt; <span class="built_in">endl</span>; &#125;;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">int</span> _x, _y, _z;  </span><br><span class="line">&#125;;   </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="keyword">int</span>  a=<span class="number">1</span>;	</span><br><span class="line">    Point local1 = &#123; a, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x4008a4</span> <span class="keyword">mov</span>    -<span class="number">0x24</span>(%rbp),%esi</span><br><span class="line"><span class="number">0x4008a7</span> <span class="keyword">lea</span>    -<span class="number">0x20</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x4008ab</span> <span class="keyword">mov</span>    <span class="number">$0</span>x5,%ecx</span><br><span class="line"><span class="number">0x4008b0</span> <span class="keyword">mov</span>    <span class="number">$0</span>x4,%edx</span><br><span class="line"><span class="number">0x4008b5</span> <span class="keyword">mov</span>    %rax,%rdi</span><br><span class="line"><span class="number">0x4008b8</span> callq  <span class="number">0x400938</span> &lt;Point::Point(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>上述讲的activation record是：  </p>
<ul>
<li>Locals to the callee</li>
<li>Return address to the caller</li>
<li><p>Parameters of the callee<br>从上述的汇编代码可以看到，在做显示初始化列表时将常量值赋给ecx等两个寄存器，接着调用构造函数，构造函数将寄存器的内容赋给成员，而其实采用Point local2;这种直接调用构造函数的发式也是如此，且和在构造函数中赋值给成员时转换的汇编相同，所以不是很理解这块的区别，在g++ c++11是如此表现的    </p>
<h5 id="２、为继承做准备："><a href="#２、为继承做准备：" class="headerlink" title="２、为继承做准备："></a>２、为继承做准备：</h5><p>继承可能用到多态，此时需要使用virtual ,那就会带来constructor等函数中加入对vptr的初始化（copy constructor等）<br>c++标准会要求编译器尽量延迟对nontrivial members的实际合成 操作，直到真正遇到其使用场合：这里trivial意思是无意义，这个trivial和non-trivial是对类的四种函数来说的：</p>
<p>  构造函数(ctor)<br>  复制构造函数(copy)<br>  赋值函数(assignment)<br>  析构函数(dtor)  </p>
</li>
</ul>
<p>如果至少满足下面3条里的一条：</p>
<pre><code>显式(explict)定义了这四种函数。
类里有非静态非POD的数据成员。
有基类。
</code></pre><p>那么上面的四种函数是non-trivial函数，比如叫non-trivial ctor、non-trivial copy…，也就是说有意义的函数，里面有一下必要的操作，比如类成员的初始化，释放内存等。   </p>
<h5 id="二、继承体系下的对象构造："><a href="#二、继承体系下的对象构造：" class="headerlink" title="二、继承体系下的对象构造："></a>二、继承体系下的对象构造：</h5><p>constructor函数中的隐藏代码，  </p>
<ol>
<li>初始化列表  </li>
<li>member的默认构造函数,若该member未出现在初始化列表中</li>
<li>vptr，在1,2之前，指向vtable   </li>
<li>base class constructor  1,2,3之前，以声明顺序为顺序，若在member initialization list中，则应传递参数，否则在1,2,3前加入其默认构造函数。多继承时可能this指针调</li>
<li>virtual base class constructor，从左到右，从最深到最浅 ，同4，若在list中有则用，否则。。  </li>
</ol>
<p>例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   Point (<span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>);  </span><br><span class="line">   Point(<span class="keyword">const</span> Point&amp;);</span><br><span class="line">   Point&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp;);</span><br><span class="line">   <span class="keyword">virtual</span> ~Point();</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0.0</span>;&#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">float</span> _x,_y;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">line</span> &#123;</span></span><br><span class="line">   Point _begin,_end;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     Line(....);</span><br><span class="line">     Line(...);</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure></p>
<p>line的默认析构函数会被合成，但是无意义，当然它的member的默认析构函数会被加入。。。其他类似</p>
<h5 id="三、虚拟继承："><a href="#三、虚拟继承：" class="headerlink" title="三、虚拟继承："></a>三、虚拟继承：</h5><ul>
<li><p>考虑下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       Point3d(<span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>,<span class="keyword">float</span> z=<span class="number">0.0</span>):Point(x,y),_z(z)&#123;&#125;</span><br><span class="line">       Point3d(<span class="keyword">const</span> Point3d&amp; rhs):point(rhs),_z(rhs._z)&#123;&#125;</span><br><span class="line">       ~Point3d();</span><br><span class="line">       Point3d&amp; <span class="keyword">operator</span>=...</span><br><span class="line">       <span class="comment">//..</span></span><br><span class="line">      proteced:</span><br><span class="line">      <span class="keyword">float</span> _z;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>传统的如上面的扩充构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;Point(:Point(x,y);</span><br><span class="line"><span class="keyword">this</span>-&gt;_vptr_Point3d = vtbl_Point3d;</span><br><span class="line"><span class="keyword">this</span>-&gt;_vptr_point3d_point=_vtbl_point3d_point;</span><br><span class="line"><span class="keyword">this</span>-&gt;_z=rhs_z;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span></span><br></pre></td></tr></table></figure>
<p>但是在这里，虚拟继承这显然不够准确：　　<br>考虑当出现菱形继承：　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Point;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Point3d,<span class="keyword">public</span> Vertex&#123;;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pvertex</span>:</span><span class="keyword">public</span> Vertex3d&#123;;&#125;;'</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  那作为被共享的Point subobject应该由最底层的如Vertex3d来初始化：<br>  而最底层显然也会初始化Point3d和vertex,并调用他们的构造函数；如果他们的构造函数不加限制，就会又调用Point的构造，导致错误；　　<br>  所以应该做限制，如下：<br>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vertex3d::Vertex3d(Vertex3d *<span class="keyword">this</span>,<span class="keyword">bool</span> __most_derived,<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z)&#123;</span><br><span class="line"><span class="keyword">if</span>(__most_derived!=<span class="literal">false</span>)<span class="comment">//判断是否为最底层</span></span><br><span class="line">   <span class="keyword">this</span>-&gt;Point::Point(x,y);<span class="comment">//是则构造最上层的</span></span><br><span class="line">   <span class="comment">//调用上一层的base classes</span></span><br><span class="line">   <span class="comment">//设定__most_derived为false</span></span><br><span class="line"><span class="keyword">this</span>-&gt;Point3d::Ponint3d(..);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>而在<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point3d::Point3d(Point3d* <span class="keyword">this</span>,...)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(___most_derived!=<span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">this</span>-&gt;Point::Point(x,y);</span><br><span class="line">      ....</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>所以最底层的构造函数等会限制中间层对最上层的构造</p>
<ul>
<li>思考：</li>
<li>当obj只是某个完整的obj的子obj时，则不用调用virtual base class constructor:,如上，那就产生了一种提高效率的方式：</li>
<li>将构造函数分割为obj和subobj,，前者为完整版本的obj，自然要调用所有，包括基类的构造，后者不用，这种分裂可以提高效率</li>
</ul>
<h4 id="vptr初始化语意"><a href="#vptr初始化语意" class="headerlink" title="vptr初始化语意"></a>vptr初始化语意</h4><ul>
<li>题外，这本书总喜欢讨论特殊的情况，哭笑，下面也是，在构造函数中调用虚函数222</li>
<li>主要讨论vptr什么时候初始化合适，以及为什么</li>
<li><p>constructor调用顺序：考虑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Point;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Point3d,<span class="keyword">public</span> Vertex&#123;;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pvertex</span>:</span><span class="keyword">public</span> Vertex3d&#123;;&#125;;'</span><br></pre></td></tr></table></figure>
<p>当一个PVertex对象被构造时，构造函数顺序为：　　<br>Point<br>Point3d<br>Vertex<br>Vertex3d<br>Pvertex  </p>
</li>
<li>假设这个继承体系中的每一个类都定义了一个virtual func size()，该函数负责传回class的大小；如果我们写：<br>Pvertex pv;<br>Point3d p3d;<br>Point  *pt=&pv;<br>那么这个调用pt-&gt;size()传回PVertex的大小，而<br>pt=&p3d; pt-&gt;size()则传回p3d的大小；</li>
<li><p>更进一步，特殊情况：<br>当在构造函数中调用这个操作时，如在point3d构造函数中调用时，是选择哪个class的size,毕竟现在正在构造point3d,答案是point3d的</p>
<ul>
<li>考虑如何使得上述生效?</li>
<li>静态调用Point3d::size()或者bnalalla</li>
<li>最后，利用vptr虚拟机制，即要在调用size之前初始化好其class对应的vptr</li>
<li>总结：在这种情况下，vptr在base class constructor 调用之后，在程序员代码之前（如size),或是初始化列表所列的member初始化操作前</li>
<li>更好的，分割constructor为完整obj和subobj</li>
</ul>
<h3 id="对象复制语意学"><a href="#对象复制语意学" class="headerlink" title="对象复制语意学"></a>对象复制语意学</h3><h4 id="复制函数什么时候会被合成和使用"><a href="#复制函数什么时候会被合成和使用" class="headerlink" title="复制函数什么时候会被合成和使用"></a>复制函数什么时候会被合成和使用</h4></li>
<li>前言，当你设计一个类，并以一个对象复制给另一个对象时，有三种选择：  <ul>
<li>什么也不做，实行默认行为  </li>
<li>提供一个显性拷贝函数</li>
<li>拒绝，只需要把复制函数声明为private就可以 </li>
</ul>
</li>
<li>考虑默认的行为：<ul>
<li>bitwise copy行为，当不出现一下情况时，甚至不会调用复制函数，而是做bitwise copy</li>
<li>而当出现以下行为时，调用默认的copy assignment operator函数，并合成相关操作：　　<ol>
<li>当class中有mem obj，这个obj有一个copy ass operaator</li>
<li>当类的基类有copy assi opera..</li>
<li>类带virtual func</li>
<li>继承自一个virtual base class  </li>
</ol>
</li>
</ul>
</li>
<li>写一个显性的复制函数：  <ul>
<li>在发生上述情况时，编译器也会像合成构造函数一样在显性的复制函数中加东西</li>
<li>而继上面的，Point共享基类，编译器如何能在Point3d和Vertex的copy assignment operator中压抑point的copy assignment operator呢?</li>
<li>书中的后面有些难以理解，等后面再探索吧，哎时间有限。。<h3 id="对象的功能"><a href="#对象的功能" class="headerlink" title="对象的功能"></a>对象的功能</h3>测试对象构造和拷贝的成本，在从简单形式，单一继承，到多重继承，虚拟继承等情况下的时间复杂度<h3 id="解构语意学"><a href="#解构语意学" class="headerlink" title="解构语意学"></a>解构语意学</h3></li>
</ul>
</li>
<li>析构函数并不会总是被合成出来，更别提调用；</li>
<li>只有在类内带的member object或者自己的base class带有destructor，编译器才会合成一个析构函数，否则被视为不需要或者不用合成调用</li>
<li>析构函数没必要和构造函数对称</li>
<li>析构函数一般有以下顺序：<ul>
<li>先调用最底层子类析构函数，接着往上，直到基类</li>
<li>析构函数本身在被执行时，vprt会在程序员代码前被执行</li>
<li>若class拥有member class object ,而后者拥有destructor,则他们会以其声明顺序相反顺序被调用</li>
<li>如果object内带一个vptr,则首先重设相关的virtual table</li>
<li>若有任何直接的非虚基类拥有析构函数，则同上</li>
<li>若有虚基类，则按照构造顺序相反顺序调用</li>
</ul>
</li>
<li>类似于构造函数，可以分裂</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_funcmember_memory</title>
    <url>/2018/06/09/cpp-funcmember-memory/</url>
    <content><![CDATA[<h3 id="c-function语意学"><a href="#c-function语意学" class="headerlink" title="c++ function语意学"></a>c++ function语意学</h3><p>something:<br>恩，这部分记录自己对c++中的函数特殊性的理解，本想深入函数本质，之前接触过，记得在linux内核剖析那本书讲的很好。<br> 可以参考；<a id="more"></a></p>
<ul>
<li>实现类的成员函数和类之间的关联，即通过对象能调用成员函数。这种实现，可以是以下几种方式：<br>1）struct+函数指针：结构体中，一个成员函数对应一个指针，增加空间 如何操作成员？<br>2）函数+this指针，普通函数，this指针一个，不添加额外多的空间，this 操作成员<br>。。。</li>
</ul>
<ul>
<li>c++的类主要是将成员和函数封装起来。那么成员的封装就像struct一样，而函数呢？成员函数如何和类，对象联系起来？–this指针</li>
</ul>
<ul>
<li>c++中的成员函数和普通函数一样，只是多了个this指针，这个指针指向当前调用这个函数的对象，并以形参传入，这样，成员函数就可以使用对象成员了，通过<br>this指针；</li>
</ul>
<ul>
<li><p>这里也是根据深入探索c++模型中第四章，function语义学总结的：</p>
<h4 id="引入这个问题："><a href="#引入这个问题：" class="headerlink" title="引入这个问题："></a>引入这个问题：</h4><p>通过对象和对象指针来调用成员函数的不同：<br>Point3d obj;<br>Point3d *p=&obj;<br>两者效率有何不同？</p>
<p>通过上面分析：当这个成员函数为普通的成员函数时，则直接调用函数，传入this指针，所以基本没有大的区别  </p>
<h4 id="以下分为几种函数讨论："><a href="#以下分为几种函数讨论：" class="headerlink" title="以下分为几种函数讨论："></a>以下分为几种函数讨论：</h4><h5 id="非静态成员函数："><a href="#非静态成员函数：" class="headerlink" title="非静态成员函数："></a>非静态成员函数：</h5><p>为了支持this指针等构成成员函数，c++做了如下步骤：  </p>
<ul>
<li>a;改写函数原型：安插了一个this参数</li>
<li>b；对对象成员的操作，通过this</li>
<li>c;对成员函数写成外部函数，并将其名称进行mangling处理，成独一无二～类似：函数名___类名参数名 等等</li>
<li>如何命名：成员函数和成员都会被名称特殊化处理：一般加上base class &amp;derived class名<br> 对重载函数而言如何区分：加上参数链表；<br> 当extern C时，会压抑这种特殊命名化<br> 具体编译器实现不同，可以通过汇编等。gdb等看</li>
</ul>
</li>
</ul>
<ul>
<li><p>鉴于此：看一个例子：<br>当你需要构造一个（拷贝构造函数）或者改变一个类的成员： 伪代码：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize__Point</span><span class="params">(<span class="keyword">register</span> <span class="keyword">const</span> Point3d *<span class="keyword">const</span> <span class="keyword">this</span>,Point3d &amp;_result)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    _reuslt.Point3d::Point3d() <span class="comment">//默认构造函数：</span></span><br><span class="line">    _result._x=<span class="keyword">this</span>-&gt;__x/<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"> 那么，以下这种方式：更好：</span><br><span class="line"> Point3d Point3d::normmalize() <span class="keyword">const</span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  Point3d(_x/<span class="number">2</span> ...)直接构建会更快） </span><br><span class="line">  =》转换为<span class="keyword">return</span> Point3d(<span class="keyword">this</span>-&gt;_x/<span class="number">2</span>,...)</span><br></pre></td></tr></table></figure>
<h5 id="virtual-func"><a href="#virtual-func" class="headerlink" title="virtual func"></a>virtual func</h5><p>若normilaze是虚拟函数，则<br>ptr-&gt;normilaze()=》 （*ptr-&gt;vptr[1])(ptr);<br>可以看到效率较低，所以当确认不用多态机制的时候，最好抑制它，直接使用：Point3d::xxx  这种方式调用函数<br>而若被写成内连函数会更优–原因待探索：</p>
</li>
</ul>
<h5 id="静态成员函数："><a href="#静态成员函数：" class="headerlink" title="静态成员函数："></a>静态成员函数：</h5><p> 显然这种能被类直接调用的函数，没有this指针，从而也就无法用成员<br> 这种函数的出现，是因为一种需求：即不用每个成员函数都会使用成员，不一定需要this<br> 不用声明一个对象就可以调用函数，当非要对象不可，又不用成员时：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">((Point3d*)<span class="number">0</span>)-&gt;object_count() ;</span><br></pre></td></tr></table></figure></p>
<p> 有了static后，就不用上述方式了<br> 所以static的特性完全来源它的原理：  </p>
<ul>
<li>它不能直接存取non static 成员</li>
<li>它不能被声明为const volatile virtual</li>
<li><p>能直接被类调用<br>静态成员函数和普通函数更像，因为它没有this指针，也就不是这种类型：~ unsigned int(*) ();<br>所以更可以和类之外的元素沟通，比如回调函数</p>
<h5 id="虚拟成员函数"><a href="#虚拟成员函数" class="headerlink" title="虚拟成员函数"></a>虚拟成员函数</h5><ul>
<li>a 为了支持多态，需要在执行期间能判断到底调用哪个函数？即pz-&gt;z()这个函数，pz为基类指针，而能调用子类函数</li>
<li>b 基类指针或引用参考到的（指向的）子类，，子类中的重写父类的函数，在调用时并不知道传入哪个this,即表现为调用哪个函数</li>
<li>c　那么为了支持通过基类能调用它，通过子类也能调用该函数，则需要基类和子类共享某个东西，他能正确决议出要调用的函数</li>
</ul>
</li>
<li><p>带来：额外的空间，和c的兼容性</p>
<h5 id="积极多态的概念："><a href="#积极多态的概念：" class="headerlink" title="积极多态的概念："></a>积极多态的概念：</h5><p>（１）被指出的对象真正被使用；（２）dynamic_cast<br>那么哪些函数需要支持这样的特性－－－》由virtual标志来指出<br>如何在执行期间调用真正的函数？－－－》ptr所指的对象真实类型＋函数的位置　真实类型放在vtable[0]</p>
</li>
<li><p>编译期间做的：<br>在每个对象中加入：一个字符串或数字来表示class　类型＋一个指针，指向表格vtable,它带有程序的virtual func执行期地址<br>确定表格中的函数指针，执行期无法改变表格一个类对应一个表格，每个virtual func被指定一个固定的索引值</p>
</li>
<li>执行期间做的：<br>为vptr分配内存地址。它的值在编译期间确定，类似于x=3;  指向vtable<br>调用函数时激活　。编译器已经为其转换语义为xxx-&gt;vptr<a href="this">n</a>.. </li>
<li>注意，当一个子类继承基类时，vptr继承过来，当子类改写virtual函数时，则改变表中的指针指向子类的；当子类添加一个新的virtual func时，则在表中加一个slot</li>
<li>唯一在执行期间才知道的：slot(n)到底指向哪个函数实体<br>细想一下：  <pre><code>derived de; //编译期间，符号表确认要分配的对象类型,执行期间分配内存和调用构造函数等，构造函数中会初始化vptr,    
base *p=&amp;de;//编译期间，类似于int x=3;,执行期间分
配内存给x,并将３给x,确定p所指的真正对象，从而才能取得vptr,到调用到最终的函数
p-&gt;xx();//xx为virtual (*p-&gt;vptr[1])(p)
</code></pre></li>
</ul>
<h5 id="some-question"><a href="#some-question" class="headerlink" title="some question"></a>some question</h5><p> //关于执行期和编译期确定的东西，有些困惑，为啥编译器不能在p-&gt;xx()的时候指定调用子类的xx()?<br> //在编译器扫描代码的时候，知道定义了一个derived类型的变量，知道，定义了一个base指针，并指向的变量类型为derived,后面调用时也能<br> 确定函数名，为啥不能根据已存的这些信息。来得到哦。这时p指向的是derive类型的。所以调用derived的函数？<br> 不过也是，编译器从做词汇扫描，到语义扫描，出符号表，到语法检查，语义规则等</p>
<h5 id="多重继承下面的virtual-func"><a href="#多重继承下面的virtual-func" class="headerlink" title="多重继承下面的virtual func"></a>多重继承下面的virtual func</h5><p> 考虑以下例子：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span> :</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">　　　<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> base1* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base2</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> b;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> b;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> base2* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derive</span>:</span><span class="keyword">public</span> base1,<span class="keyword">public</span> base2</span><br><span class="line">   <span class="keyword">int</span> c;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">c</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> c;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> derive* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 对于和derived有相同起点的base1不用考虑太多，关键是base2,;有三个问题要解决：<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">　(<span class="number">1</span>)<span class="keyword">virtual</span> <span class="function"><span class="keyword">destructor</span> <span class="params">(记得之前是逐层调用）</span></span></span><br><span class="line"><span class="function"><span class="params"> 　（２）被继承下来的b()</span></span></span><br><span class="line"><span class="function">  <span class="params">(3）一组clone函数 </span></span></span><br><span class="line"><span class="function"><span class="params">（a)</span>   做<span class="title">base2</span> *<span class="title">pbase2</span>=<span class="title">new</span> <span class="title">derive</span>;</span></span><br><span class="line">　　　　＆＆＆编译期间确定：＆＆＆</span><br><span class="line"> =&gt;  derived *tmp=new derive;</span><br><span class="line"> 　　　base2 *pbase2=tmp?tmp+sizeof(base1):<span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p> 为了使pbase2能访问到　b 即pbase２-&gt;b, 多重继承下使用 base *p=de;时，注意此时需要调整，让p指向的是de中的base对应部分</p>
<ul>
<li>当通过delete pbase2时，此时需要删除完整的对象，所以pbase２指针需要调整到指出完整对象的起始点<br>他也要通过上述a类似的加法，以及调用virtual destructor函数  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> 如base2 *pbase2=<span class="keyword">new</span> derive;  </span><br><span class="line"><span class="keyword">delete</span> pbase2;<span class="comment">//invoke derive class's destructor (virtual )</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> 　首先这个调用要通过vptr,其次，传入的this指针需要调整<br>  ＆＆＆执行期间确定＆＆＆</p>
<ul>
<li><p>注意：然而，这种offset加法无法在编译期间直接设定。pbase2所指的真正对象只有在执行期间才能确定<br>//如何调整；早期的想法是：将vtable中的slot改为一个slot放置函数指针faddr和this的offset<br>//则：（<em>pbase2-&gt;vptr[1])(pbase2);<br>//改为　（</em>pbase2-&gt;vptr[1].faddr)(pbase2+pbase2-  &gt;vptr[1].offset);但是连带处罚了其他形式virtual func调用，</p>
<ul>
<li>那如何处理？  </li>
<li>[１]方法１：thunk<br>　　　～：this+=sizeof(base1)<pre><code>Derived::~Derived(this);//只有汇编才有效率
</code></pre>如何使能？在virtual table slot继续内含一个简单的指针，slot中的地址可以指向一个virtual func或者一个thunk(若需要调整this)<br>其实多重继承来讲，每个继承的基类，都需要一个virtual table;,这样派生类就会维护多个基类的vtable</li>
<li>1)经由derived或第一个base class)调用，不需要调整this</li>
<li><p>2)经由&gt;=2的base class 调用，同一种函数在virtual table中可能需要多笔对应的slot</p>
<pre><code>base1 *pbase1 =new derived;
base2 *pbase2=new derived;
delete pbase1//不需要调整this,virtual table slot放置正真的destructor地址

delete pbase2//需要调整this ,放置thunk
vptr和vtable命名也会被特殊化
参考图在书中，这里不放
</code></pre></li>
</ul>
</li>
<li><p>[２]方法２　：<br> 因为动态链接器的原因，使得符号链接变得缓慢<br> 为了调整执行期链接器的效率，sun编译器将多个vtable 连锁为一个，指向次要表格的指针可以由主要表格加offset<br>　  其他类似。<br>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　　　　　base2 *ptr =<span class="keyword">new</span> derived;</span><br><span class="line"><span class="keyword">delete</span> ptr;<span class="comment">//此时调用derived::~deirved,故ptr需要被调整，若为virtual，需要更多</span></span><br><span class="line"></span><br><span class="line">derived *pder=<span class="keyword">new</span> derived;</span><br><span class="line">pder-&gt;b();<span class="comment">//注意b没有被改写，所以需要调整pder指向base2 subobj</span></span><br><span class="line"></span><br><span class="line">base2 *pb1=<span class="keyword">new</span> derived;</span><br><span class="line">base2 *pb2=pb1-&gt;clone()<span class="comment">//注意是调用derived:clone,所以调用后返回值要改变器指向base2 subobj</span></span><br><span class="line"></span><br><span class="line">当函数被认为足够小　，sun编译器会采用某种算法优化，split。。，否则不会，具体待了解。</span><br><span class="line">所以<span class="keyword">virtual</span> func的通常大小为８行</span><br></pre></td></tr></table></figure>
</li>
<li><p>[３]IBM:<br>函数若支持多重进入点，将不必有许多thunk;将thunk操作放在virtual func中，里面判断是否需要调整this指针</p>
</li>
</ul>
<h5 id="虚拟继承下的virtual-func"><a href="#虚拟继承下的virtual-func" class="headerlink" title="虚拟继承下的virtual func"></a>虚拟继承下的virtual func</h5><p>这种情况相当复杂了。需要探索上述的这些问题：point2d.point3d的对象不再相符，即使只继承一个，即单一虚拟继承，也需要调整this指针<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point2d</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  point2d()</span><br><span class="line">  <span class="keyword">virtual</span> ~point2d()</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mumble</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  virutal  <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span></span><br><span class="line">  protected:</span><br><span class="line">  <span class="keyword">float</span> _x,_y;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">point3d</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> point2d&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    point3d()</span><br><span class="line">    ~point3d</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>可以尝试下写出例子比较point2d和point3d指针看指向是否相同
当virtual base class中包含virtual func和nonstatic member时，各个厂商实现不同，复杂，作者不建议这么做

－－－－－－－－－－－－－－－－－－－
</code></pre><h4 id="函数的效能："><a href="#函数的效能：" class="headerlink" title="函数的效能："></a>函数的效能：</h4><p>  这部分可以通过函数的调用方式感性的了解，或者根据不同的编译器。测试对比几种调用的时间，以及是否已经开启优化等<br>  （如编译器将被视为不变的表达式提到循环之外）<br>  （通过消除局部对象的使用可以消除对constructor的调用）</p>
<h4 id="指向memeber-func的指针："><a href="#指向memeber-func的指针：" class="headerlink" title="指向memeber　func的指针："></a>指向memeber　func的指针：</h4><p>  取一个nonstatic member func的地址，若为nonvirtual 则为其在内存中的真正地址。<br>  但需要this参数。　<br>  指向member func的指针：double (Point::<em>pmf)();类似<br>  定义：double (point::</em>coord)() =&amp;point::x;<br>       赋值:coord=&amp;point::y<br>       调用：（origin.<em>coord)()/(ptr-&gt;</em>coord)()<br>       转换为：(coord)(&amp;origin)/(coord)(ptr)</p>
<h5 id="指向virtual-memeber-func指针"><a href="#指向virtual-memeber-func指针" class="headerlink" title="指向virtual memeber func指针"></a>指向virtual memeber func指针</h5><p>  在g++中<br>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">getp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mp;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">void</span> <span class="title">setp</span><span class="params">(<span class="keyword">float</span> mmp)</span></span>&#123;mp=mmp;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">4</span>;&#125;</span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">				<span class="keyword">float</span> mp;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">		<span class="keyword">float</span> (Base1::*pmf)()=&amp;Base1::getp;</span><br><span class="line">		Base1 *ptr=<span class="keyword">new</span> Base1;</span><br><span class="line">		ptr-&gt;setp(<span class="number">3.2</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ptr-&gt;getp()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//3.2</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//3.2　　会被内部转换：（*ptr-&gt;vptr[(int)pmf])(ptr)</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::getp);<span class="comment">//1　索引值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::setp);<span class="comment">//40xxx真实地址</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::test);<span class="comment">// 9，为什么是９不清楚</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::test1);<span class="comment">//11</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　所以，对于虚拟函数也是可以通过函数指针来访问的，只不过得到的地址是索引值，但不影响访问<br>或者对以下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">getp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mp;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">void</span> <span class="title">setp</span><span class="params">(<span class="keyword">float</span> mmp)</span></span>&#123;mp=mmp;&#125;</span><br><span class="line">			        <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">4</span>;&#125;</span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">				<span class="keyword">float</span> mp;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">		<span class="keyword">float</span> (Base1::*pmf)()=&amp;Base1::getp;</span><br><span class="line">		Base1 *ptr=<span class="keyword">new</span> Base1;</span><br><span class="line">		ptr-&gt;setp(<span class="number">3.2</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ptr-&gt;getp()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::getp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::setp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::test);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::test1);</span><br><span class="line">                  </span><br><span class="line">                <span class="keyword">int</span> (Base1::*pmi)()=&amp;Base1::test1;<span class="comment">//or test　可以指向两种，编译器如何区分呢？cfront２　通过判断是索引（may &lt;127)还是函数地址来区分</span></span><br><span class="line">                Base1 *ptr2=<span class="keyword">new</span> Base1;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;(ptr2-&gt;*pmi)()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> ptr2;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="多重继承下指向member-func指针"><a href="#多重继承下指向member-func指针" class="headerlink" title="多重继承下指向member func指针"></a>多重继承下指向member func指针</h5><p>为了让mem func point能支持多重继承和虚拟继承：<br>噢这种情况很复杂了。你得知道它指向的是virtual 还是non virtual<br>书中并没有探讨太多，野比较复杂，这里举一个例子，探索细节可以看编译器，gdb等结果：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">getp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mp;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">void</span> <span class="title">setp</span><span class="params">(<span class="keyword">float</span> mmp)</span></span>&#123;mp=mmp;&#125;</span><br><span class="line">			        <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">4</span>;&#125;</span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">				<span class="keyword">float</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">get2p</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m2p;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set2p</span><span class="params">(<span class="keyword">float</span> m2pp)</span></span>&#123;m2p=m2pp;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">int</span> <span class="title">test22</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test21</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">6</span>;&#125;</span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">				<span class="keyword">float</span> m2p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Der</span>:</span><span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">get3p</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m3p;&#125;</span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">				<span class="keyword">float</span> m3p;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">		<span class="keyword">float</span> (Base1::*pmf)()=&amp;Base1::getp;<span class="comment">//这后面的调用就发挥想象把，想怎么尝试都行</span></span><br><span class="line">		Base1 *ptr=<span class="keyword">new</span> Der;</span><br><span class="line">		ptr-&gt;setp(<span class="number">3.2</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ptr-&gt;getp()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Der::getp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::setp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::test);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::test1);</span><br><span class="line">                  </span><br><span class="line">                <span class="keyword">int</span> (Base1::*pmi)()=&amp;Base1::test1;<span class="comment">//or test</span></span><br><span class="line">                Base1 *ptr2=<span class="keyword">new</span> Base1;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;(ptr2-&gt;*pmi)()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> ptr2;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="效能"><a href="#效能" class="headerlink" title="效能"></a>效能</h5><h5 id="inline-func"><a href="#inline-func" class="headerlink" title="inline func:"></a>inline func:</h5><p>首先得直到，内联函数实际上表现为什么？函数本质上被经过栈调用，而内联函数是直接　在主函数中铺开为表达式，所以调用内联函数　能提高效率，但是响应的<br>源代码会变大，而且有参数的限制<br>应用：在操作符函数中，指定set,get类函数，使得操作符函数能被写成普通的函数。　而set get 写成inline函数，会减少效率降低<br>inline关键词只是请求，并不会所有都inline展开，编译器会做判断权衡<br>具体看书，不是很细<br>内联函数两个注意点：<br>形式参数：inline扩展时，每一个形式参数会被对应的实际参数代替：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　　　　　　<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> i&lt;j?i:j;</span><br><span class="line">          &#125;</span><br><span class="line">三个调用：</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> minval;</span><br><span class="line">   <span class="keyword">int</span> val1=<span class="number">1024</span>;</span><br><span class="line">   <span class="keyword">int</span> val2=<span class="number">2048</span>;</span><br><span class="line">   minval=min(val1,val2); 参数直接替换val1&lt;val2?val1:val2;</span><br><span class="line">   minval=min(<span class="number">1024</span>,<span class="number">2048</span>);替换后直接使用常量：<span class="number">1024</span></span><br><span class="line">   minval=min(fool(),bar()+<span class="number">1</span>) 引发参数副作用，需要导入一个临时对象，以避免重复求值：</span><br><span class="line">   　　　　     <span class="keyword">int</span> t1,t2; minval=(t1=foo()),(t2=bar()+<span class="number">1</span>),t1&lt;t2?...)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> minval&#125;</span><br></pre></td></tr></table></figure></p>
<p> 局部变量:在内联函数中加入局部变量，会导致因为维护局部变量带来的成本；<br> 内联函数在替代c宏，是比较安全的；但是若宏中参数有副作用的话，如上，会导致大的扩展码以维护局部变量或者生成临时的变量</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_datamember_memory</title>
    <url>/2018/06/08/cpp-datamember-memory/</url>
    <content><![CDATA[<h3 id="c-class-datamemory"><a href="#c-class-datamemory" class="headerlink" title="c++ class  datamemory"></a>c++ class  datamemory</h3><p>详细介绍c++的成员布局，类本身的布局和在各种情况下的布局</p>
<h4 id="“类”本身的大小："><a href="#“类”本身的大小：" class="headerlink" title="“类”本身的大小："></a>“类”本身的大小：</h4><ul>
<li>the simplest 引入</li>
<li>1.2 多少内存能表现一个class?<br>最小是１　  size<a id="more"></a></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span> &#125;;   --<span class="number">-1</span> 一个<span class="keyword">char</span> 表示这个类型</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;　　--指针大小，指针指向T  <span class="keyword">virtual</span> base <span class="class"><span class="keyword">class</span> <span class="title">subobject</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Y</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;  --指针大小</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> X,<span class="keyword">public</span> Y &#123;&#125;;　--两个指针大小　```  </span><br><span class="line">－－从深入那本书中说有两种方式，体现<span class="class"><span class="keyword">class</span>的大小，这里是优化的特殊的类型，这些好理解，但是需要类的空间的真正原因是什么？这<span class="title">T</span>的一个<span class="title">char</span>存储了什么？  </span></span><br><span class="line"><span class="class">用来干嘛？那在<span class="title">X</span>中指向<span class="title">T</span>的又是为什么需要？  </span></span><br><span class="line"><span class="class">最小１<span class="title">char</span>?  </span></span><br><span class="line"><span class="class">我们知道，当一个类中仅包含一个<span class="title">nonstatic</span> <span class="title">member</span>时，如<span class="title">int</span> ,则对象为<span class="title">int</span>大小，但是当类为空时，对象如何去分配内存？</span></span><br><span class="line"><span class="class">如果同时定义了两个对象，那如何去区分这两个对象？让他们地址不相同？－－－所以这里需要一个<span class="title">char</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">+ 注意，类本身也是一个类型，像<span class="title">int</span>，<span class="title">struct</span>一样，它的大小为４，<span class="title">struct</span>成员和对齐，则类也一样，<span class="title">sizeof</span>是在编译期间（确定<span class="title">c89</span>中）  </span></span><br><span class="line"><span class="class">一个例子：</span></span><br><span class="line"><span class="class">```<span class="title">cpp</span></span></span><br><span class="line"><span class="class">#<span class="title">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="class">#<span class="title">define</span> _<span class="title">sizeof</span>(<span class="title">T</span>) ((<span class="title">size_t</span>)((<span class="title">T</span>*)0+1))</span></span><br><span class="line"><span class="class">#<span class="title">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">namespace</span> <span class="title">std</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span><span class="keyword">public</span> X,<span class="keyword">public</span> Y&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TT</span>&#123;</span><span class="keyword">public</span>:<span class="keyword">int</span> q;<span class="keyword">int</span> x;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		T t1,t2;</span><br><span class="line">		<span class="keyword">int</span> xx;</span><br><span class="line">		<span class="keyword">if</span> (&amp;t1==&amp;t2)</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"same"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%x\n"</span>,&amp;t1);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%x\n"</span>,&amp;t2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,&amp;xx);</span><br><span class="line">	<span class="comment">//	int sie=(Y*)0+1;</span></span><br><span class="line">	<span class="comment">//	printf("%x\n",X&#123;&#125;);</span></span><br><span class="line">	    <span class="keyword">int</span> s= _sizeof(TT);　８　编译期间确定，直接把８赋给内存</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;_sizeof(T)&lt;&lt;<span class="built_in">endl</span>;　１</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(TT)&lt;&lt;<span class="built_in">endl</span>;　　８</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(T)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(X)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自然t1,t2地址不同，相邻</p>
<h4 id="那么一个类大的方面需要这些："><a href="#那么一个类大的方面需要这些：" class="headerlink" title="那么一个类大的方面需要这些："></a>那么一个类大的方面需要这些：</h4><p>１）类中定义的普通成员<br>２）语言本身所造成的额外负担如virtual机制，virtual table ,virtual base class subobject<br>３）Aligmnment带来的<br>（编译器的优化会带来内存布局的影响）</p>
<p>上述例子：当编译器不做优化时，为１，8+1+3,8+1+3 ,1(X)+8+8+3(ali)</p>
<h4 id="总结datamember的布局"><a href="#总结datamember的布局" class="headerlink" title="总结datamember的布局"></a>总结datamember的布局</h4><ul>
<li>对象只存非静态的成员变量，而无论中间放置了几个静态变量都不会影响他们之间的排布。<br>　　　大部分的编译器将先定义的非静态成员变量放在低地址，而后的放在高地址。最好用时先用kdbg或测试程序等看下</li>
<li>静态成员的存取不通过对象，他们放在数据段中</li>
<li>vptr一般会放在哪里？　<br>　　对象的头或者尾巴</li>
<li>align:C++标准要求，在同一个access section(private,public,protect等区段），member的排列只需要符和较晚出现放在较高的地址“即可，<br>　　access sections的多少并不会带来额外的负担</li>
<li>我在g++上做了测试:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TT</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line">   <span class="keyword">sizeof</span>&#123;TT);   <span class="number">8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TT</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line"> protect:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">   <span class="keyword">sizeof</span>(TT)=<span class="number">16</span></span><br><span class="line">class TT&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line"> protect:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">char</span> f;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">sizeof</span>(TT)=<span class="number">24</span> </span><br><span class="line">class TT&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">char</span> f;</span><br><span class="line"> protect:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">sizeof</span>(TT)=<span class="number">24</span></span><br><span class="line">class TT&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">char</span> f;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line"> protect:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">sizeof</span>(TT)=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>  由此看来这个编译器是按着c的struct对齐来的啊， </p>
<h4 id="data-member的存取："><a href="#data-member的存取：" class="headerlink" title="data member的存取："></a>data member的存取：</h4><ul>
<li><p>成本<br>比较：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">        TT tt1;</span><br><span class="line">		TT *tt2=&amp;tt1;</span><br><span class="line"><span class="number">0x400b87</span> lea    <span class="number">-0x20</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400b8b</span> mov    %rax,<span class="number">-0x48</span>(%rbp)</span><br><span class="line">		<span class="keyword">int</span> d=tt1.d;</span><br><span class="line"><span class="number">0x400b8f</span> mov    <span class="number">-0x1c</span>(%rbp),%eax</span><br><span class="line"><span class="number">0x400b92</span> mov    %eax,<span class="number">-0x68</span>(%rbp)</span><br><span class="line">		<span class="keyword">int</span> f=tt2-&gt;d;</span><br><span class="line"><span class="number">0x400b95</span> mov    <span class="number">-0x48</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400b99</span> mov    <span class="number">0x4</span>(%rax),%eax</span><br><span class="line"><span class="number">0x400b9c</span> mov    %eax,<span class="number">-0x64</span>(%rbp)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对static成员啊而言，实际是在数据段中，所以不管什么形式的访问都是相同的<br>待测试</p>
</li>
<li>通过成员函数<br>需要通过this 指针，则同上例子中的指针访问</li>
</ul>
<h3 id="总结几种情况下的的布局"><a href="#总结几种情况下的的布局" class="headerlink" title="总结几种情况下的的布局"></a>总结几种情况下的的布局</h3><h4 id="单一继承不含多态"><a href="#单一继承不含多态" class="headerlink" title="单一继承不含多态"></a>单一继承不含多态</h4><h5 id="一个典型的例子如下"><a href="#一个典型的例子如下" class="headerlink" title="一个典型的例子如下"></a>一个典型的例子如下</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    Point2d( <span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>):_x(x),_y(y)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123; _x=newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123; _y=newY;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+= (<span class="keyword">const</span> Point2d&amp;  rhs) &#123;</span><br><span class="line">        _x+=rhs.x();</span><br><span class="line">        _y+=rhs.y();</span><br><span class="line">        &#125;</span><br><span class="line">    ...more member;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Point3d</span>:</span> <span class="keyword">public</span> Point2d&#123;</span><br><span class="line">     <span class="keyword">public</span>: </span><br><span class="line">        Point3d(<span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>,<span class="keyword">float</span> z=<span class="number">0.0</span>):Point2d(x,y),_z(z)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">z</span><span class="params">(<span class="keyword">float</span> newZ)</span></span>&#123;_z=newZ;&#125; </span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Point3d&amp; rhs) &#123;</span><br><span class="line">           Point2d::<span class="keyword">operator</span>+=(rhs);</span><br><span class="line">           _z+=rhs.z();</span><br><span class="line">           &#125;</span><br><span class="line">          ...more member               </span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h5><p>则　基类的成员被子类包含，放在较低的地址；相比之下，多了对齐的空间；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     <span class="keyword">char</span> c1;</span><br><span class="line">     <span class="keyword">char</span> c2;</span><br><span class="line">     <span class="keyword">char</span> c3;</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure></p>
<p>则需要占用８bytes;</p>
<p>而当被继承实现时：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete1</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     <span class="keyword">char</span> bit1;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete2</span>：<span class="title">public</span> <span class="title">Concrete1</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">char</span> bit2;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="class"><span class="keyword">class</span>  <span class="title">Concrete3</span>:</span><span class="keyword">public</span> Concrete2&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> bit3;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>  由此带来成本 8+4+4=16</p>
<ul>
<li>那为什么要这么做的？继承的时候不能挤在一起吗？<br>（在深入c++对象模型中有图容易理解。这里仅说明：<br>　　　若：　Concrete2  *pc2;<pre><code>Concrete1 *pc1_1,*pc1_2;
*pc1_2=*pc1_1; -默认复制构造
pc1_1 = pc2; //pc1_1指向pc2;
*pc1_2=*pc1_1;//覆盖掉了，如果继承是成员挤在一起，而不是对齐来的
</code></pre></li>
</ul>
<h5 id="单一继承含多态："><a href="#单一继承含多态：" class="headerlink" title="单一继承含多态："></a>单一继承含多态：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    Point2d( <span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>):_x(x),_y(y)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">0.0</span>;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z</span><span class="params">(<span class="keyword">float</span>)</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123; _x=newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123; _y=newY;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="keyword">operator</span>+= (<span class="keyword">const</span> Point2d&amp;  rhs) &#123;</span><br><span class="line">        _x+=rhs.x();</span><br><span class="line">        _y+=rhs.y();</span><br><span class="line">        &#125;</span><br><span class="line">    ...more member;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Point3d</span>:</span> <span class="keyword">public</span> Point2d&#123;</span><br><span class="line">     <span class="keyword">public</span>: </span><br><span class="line">        Point3d(<span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>,<span class="keyword">float</span> z=<span class="number">0.0</span>):Point2d(x,y),_z(z)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z</span><span class="params">(<span class="keyword">float</span> newZ)</span></span>&#123;_z=newZ;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Point3d&amp; rhs) &#123;</span><br><span class="line">           Point2d::<span class="keyword">operator</span>+=(rhs);</span><br><span class="line">           _z+=rhs.z();</span><br><span class="line">           &#125;</span><br><span class="line">          ...more member     </span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由此可以满足<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　<span class="function"><span class="keyword">void</span> <span class="title">fool</span><span class="params">(Point2d &amp;p1,Point2d &amp;p2)</span></span>&#123;</span><br><span class="line">p1+=p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以是Point2d和Point3d 这种弹性，牺牲了时间和空间<br>加入了什么呢？  </p>
<pre><code>virtual table
vptr
add constructor vptr setting
add destructor vptr virtual table dele
</code></pre><p>所以需要视情况而定，如若只是涉及到2d&amp;3d之间，则可以是<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Point２d&amp; rhs) &#123;</span><br><span class="line">           Point2d::<span class="keyword">operator</span>+=(rhs);</span><br><span class="line">           _z+=rhs.z();<span class="comment">//此时＋０</span></span><br><span class="line">           &#125;</span><br><span class="line"><span class="function">Point2d <span class="title">p2d</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">Point3d <span class="title">p3d</span><span class="params">(,,,,)</span></span>;</span><br><span class="line">p3d+=p2d</span><br></pre></td></tr></table></figure></p>
<p>另外：对vptr的摆放位置，若放在最后面，则兼容c<br>但是损失了对继承的更好支持，所以现在放在最前面</p>
<h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>多重继承考虑的问题较多？但从设计角度看，你可能会问？<br>对比单一继承，子类成员起始地址和基类相同，那多重继承，和哪个基类一样？其他基类怎么办，在向上转型如何处理，指针呢？</p>
<p>另外，在单一继承中，vptr放在最开始的地方，如果base class没有virtual func而derived　class有呢？则此时单一继承的自然多态被打破，<br>若此时把一个derived class 转换为base class则　需要编译器介入，在多重继承+虚拟继承下就更有必要了</p>
<p>考虑这个例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　<span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span> 带<span class="keyword">virtual</span> 接口</span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">float</span> _x _y;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> Point2d&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   protectd:</span><br><span class="line">      <span class="keyword">float</span> _z;</span><br><span class="line">      &#125;'</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> &#123;</span>带<span class="keyword">virtual</span>接口</span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">        Vertex *next;</span><br><span class="line">   &#125;;    </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Point3d,<span class="keyword">public</span> Vertex &#123;</span><br><span class="line">   protexted:</span><br><span class="line">     <span class="keyword">float</span> mumble;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>对多重继承派生对象，若将其地址　指定给最左端的base class则情况同单一继承一样，因为二者指向相同的地址。但是对第二个及以上时<br>需要将地址修改，加上或减去　介于中间的base class subobject<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  eg:  Vertex3d v3d;</span><br><span class="line">        Vertex *pv;</span><br><span class="line">        Point２d *p2d</span><br><span class="line">        POint3d  *p3d;  </span><br><span class="line">        pv=&amp;v3d</span><br><span class="line">     则内部为：pv=(Vertex*)(((<span class="keyword">char</span>*)&amp;v3d)+<span class="keyword">sizeof</span>(Point3d));     </span><br><span class="line">     而对p2d=&amp;v3d;</span><br><span class="line">         p3d=&amp;v3d则只需要简单的拷贝</span><br><span class="line">```              </span><br><span class="line">      若为Vertex3d　*v3d;  pv=v3d;则内部还要进行判断空。因为*v3d可能为空，</span><br><span class="line">      而引用不用，因为引用不可能参考到无</span><br><span class="line">对存取其第二个基类成员，也是做类似的offset操作</span><br><span class="line">##### 虚拟继承</span><br><span class="line">在多重继承加虚拟继承时，如ios istream ostream</span><br><span class="line">前面的内容会好理解一些，这部分的内容不好理解，也有些繁琐，于是，我回到之前学习的方法，即为什么，出现的原因，如果是自己实现又如何，等思考：</span><br><span class="line">+ 为什么需要虚拟继承？  </span><br><span class="line">虚拟继承出现，是因为当基类<span class="number">2</span>和<span class="number">3</span>都继承了基类<span class="number">1</span>，而基类<span class="number">4</span>继承了<span class="number">2</span>和<span class="number">3</span>，则基类<span class="number">4</span>会同时拥有两份基类<span class="number">1</span>，而虚拟继承就是为了让基类<span class="number">4</span>只包含一份基类<span class="number">1</span>，形成菱形继承结构</span><br><span class="line">```cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ios</span>&#123;</span>..&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> ios&#123;..&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> ios&#123;..&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iostream</span>:</span></span><br><span class="line"><span class="keyword">public</span> istream, <span class="keyword">public</span> ostream &#123;..&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，虚拟继承是如何做，使得类4能只包含1份基类1，而不影响其他功能呢：</p>
<ul>
<li><p>梳理下：<br>上述例子：挑战在于，将istream 和ostream 各自维护的一个ios subobj ，折叠为一个由iostream维护的单一ios subobj ，<br>并且还可以保存base class 和derived class的指针（以及reference)之间的多态操作<br>一般的实现方式如下： class 如果内含一个或者多个virtual base class obj,像istream那样，将被分割为两部分，一个不变的局部和一个共享局部<br>不变的局部中的数据，不管后继如何演化，都总是拥有固定的offset(从obj头算起），这部分数据可以直接存取，共享局部，则是virtual base class subject，这部分数据位置会因为每次派生发生变化，所以他们只能被间接存取  </p>
<p>所以就是：istream 中有自己的和ios相关的部分，这部分为共享部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> _<span class="title">x</span> _<span class="title">y</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point2d  _z</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point2d</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Point3d <span class="keyword">public</span> Vertex</span><br></pre></td></tr></table></figure>
<p>那 istream 如何存取这部分共享的数据？和iostream共享？感觉有点像单例模式</p>
</li>
<li><p>cfront是这样实现的：（这语言没见过）： 会在每个derived class obj中安插一些指针，每个指针 指向一个virtual base class 存取继承得来的virtual base<br>class member;所以在存取时通过这个指针存取<br>在多层继承时间接存取次数多；每个对象需要为每个virtual base class 背负一个指针）</p>
<pre><code> void Point3d::operator+=(const Point3d &amp;rhs) {
  _x+=rhs._x;
  _y+=rhs._y;
  _z+=rhs._z;
  }
 则在这里：被转为：伪代码：_vbcPoint2d-&gt;_x+=rhs.__vbcPoint2d-&gt;_x;//vbc==virtual base class
 ....

而Point2d *2d=3d;
Point2d *2d=3d? 3d-&gt;__vbcPoint2d:0;
</code></pre></li>
</ul>
<ul>
<li><p>microsoft ：引入类似于vbtable的方法，引入virtual base class table 。而在对象中放一个指针指向该表，表则放置那些指向virtual base class 指针<br>Bjarne: g++等（现在可能变了，但是类似）：</p>
<pre><code>在虚函数表中放置virtual base class 的offset而不是地址。
在这里，上面的例子：（this+__vbtr__point3d[-1])-&gt;_x+= (&amp;rhs+rhs.__vptr__point3d[-1])-&gt;_x;
...
Point2d *2d=3d?3d+3d-&gt;__vptr__point3d[-1]:0
</code></pre></li>
<li><p>注意：若是基类1含有virtual func则会拥有一个vptr指向自己的vtable. 而虚拟继承它的基类2,3，基类2,3本身含有virtual func则不会通过继承基类1的方式<br>继承它的vptr,所以可以看到在书中的图中point3d有两个指针vptr,以下例子通过kdbg调试可以看到这个两个vptr</p>
</li>
</ul>
<ul>
<li>两个问题：</li>
<li>基类1在继承连增加时位置如何变化？</li>
<li>在基类自己有virtual func时为什么要自己独用一个vptr?<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> &#123;</span></span><br><span class="line">                <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">printx</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point2d&#123;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				Vertex *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point2d&#123;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Vertex,<span class="keyword">public</span> Point3d&#123;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="keyword">float</span> mumble;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PO</span>&#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">		    <span class="comment">// virtual ~PO();</span></span><br><span class="line">			 <span class="keyword">static</span> <span class="keyword">int</span> origin;</span><br><span class="line">			 <span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> PO::origin =<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		Point2d d2d;</span><br><span class="line">		Point3d d3d;</span><br><span class="line">		Vertex vx;</span><br><span class="line">		Vertex3d v3x;</span><br><span class="line">		PO po;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,&amp; PO::z);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,&amp;po);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,&amp;po.x);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,&amp;po.y);</span><br><span class="line"><span class="comment">//		printf("%d\n",&amp;po.origin);</span></span><br><span class="line">		<span class="keyword">float</span> PO::*p1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">float</span> PO::*p2=&amp;PO::x;</span><br><span class="line">		<span class="keyword">if</span>(p1==p2)</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"sma"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="使用gdb调试："><a href="#使用gdb调试：" class="headerlink" title="使用gdb调试："></a>使用gdb调试：</h5><p>写完程序后：<br>编译时加-g<br>gdb 科执行程序名</p>
<ul>
<li>设置断点：break 行号<br>s向下执行<br>set p obj &lt;on/off&gt;: 在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。 使用show print object查看对象选项的设置。<br>set p pertty &lt;on/off&gt;: 按照层次打印结构体。可以从设置前后看到这个区别。on的确更容易阅读。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> p obj on</span><br><span class="line"><span class="built_in">set</span> p pertty on</span><br><span class="line">p 对象名</span><br><span class="line">p /a ((<span class="keyword">void</span> ***)d3d)[<span class="number">0</span>]@<span class="number">18</span> <span class="comment">//看到更详细的内存 @18为打印的成员数，[0]指从第0个开始打印--感觉不太对</span></span><br><span class="line">p /a ((<span class="keyword">void</span> **)vx)[<span class="number">0</span>]@<span class="number">16</span><span class="comment">//同上</span></span><br><span class="line">(gdb) p b</span><br><span class="line">$<span class="number">1</span> = &#123;_vptr.Base = <span class="number">0x400a60</span> &lt;vtable <span class="keyword">for</span> Base+<span class="number">16</span>&gt;&#125;</span><br><span class="line">(gdb) x/<span class="number">16</span>x <span class="number">0x400a60</span></span><br><span class="line"><span class="number">0x400a60</span> &lt;_ZTV4Base+<span class="number">16</span>&gt;:    <span class="number">0x0040094c</span>  <span class="number">0x00000000</span>  <span class="number">0x72654437</span>  <span class="number">0x64657669</span></span><br><span class="line">(gdb) x/<span class="number">16</span>x <span class="number">0x0040094c</span></span><br><span class="line"><span class="number">0x40094c</span> &lt;Base::f()&gt;:   <span class="number">0xe5894855</span>  <span class="number">0x10ec8348</span>  <span class="number">0xf87d8948</span>  <span class="number">0x400a15be</span></span><br><span class="line"><span class="number">0x40095c</span> &lt;Base::f()+<span class="number">16</span>&gt;:    <span class="number">0x10c0bf00</span>  <span class="number">0xf9e80060</span>  <span class="number">0xc9fffffd</span>  <span class="number">0x485590c3</span></span><br><span class="line"><span class="number">0x40096c</span> &lt;Derived::f()+<span class="number">2</span>&gt;:  <span class="number">0x8348e589</span>  <span class="number">0x894810ec</span>  <span class="number">0x1bbef87d</span>  <span class="number">0xbf00400a</span></span><br><span class="line"><span class="number">0x40097c</span> &lt;Derived::f()+<span class="number">18</span>&gt;: <span class="number">0x006010c0</span>  <span class="number">0xfffddbe8</span>  <span class="number">0x66c3c9ff</span>  <span class="number">0x00841f0f</span></span><br><span class="line">  (gdb) <span class="built_in">set</span> $i = <span class="number">0</span></span><br><span class="line">  (gdb) <span class="keyword">while</span> $i &lt; <span class="number">10</span></span><br><span class="line">     &gt;print $i</span><br><span class="line">     &gt;p /a (*(<span class="keyword">void</span> ***)obj)[$i]</span><br><span class="line">     &gt;<span class="built_in">set</span> $i = $i + <span class="number">1</span></span><br><span class="line">     &gt;end</span><br><span class="line">Where <span class="string">"obj"</span> is the object whose vtable you'd like to print, <span class="keyword">and</span> <span class="number">10</span> is the number of methods.</span><br><span class="line">p /a (*(<span class="keyword">void</span> ***)obj)[<span class="number">0</span>]@<span class="number">10</span></span><br><span class="line">info address _ZTV3Bar</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="对象成员的效率"><a href="#对象成员的效率" class="headerlink" title="对象成员的效率"></a>对象成员的效率</h4><h4 id="指向对象成员变量的指针"><a href="#指向对象成员变量的指针" class="headerlink" title="指向对象成员变量的指针"></a>指向对象成员变量的指针</h4><p>可以用于测试底层布局，如vptr放在哪，access section 次序。等<br>例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　<span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> &#123;</span></span><br><span class="line">     <span class="keyword">public</span> :</span><br><span class="line">        <span class="keyword">virtual</span> ~Point3d();</span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">static</span> Point3d origin；</span><br><span class="line">        <span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1)&amp;Point3d::z  –得到z在class obj中的偏移量<br>需用printf</p>
<p>书中说的为了使得指向对象和对象成员的指针区分，而+1,在g++中没有怎么体现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//			virtual ~Point3d()&#123;;&#125;</span></span><br><span class="line">				<span class="keyword">static</span> Point3d origin;</span><br><span class="line">				<span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line">Point3d Point3d::origin;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Point3d p3d;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&amp;Point3d=%p\n"</span>,&amp;p3d);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&amp;Point3d=%p\n"</span>,&amp;p3d.x);<span class="comment">//这两个地址相同</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&amp;Point3d=%p\n"</span>,&amp;p3d.y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&amp;Point3d::x=%p\n"</span>,&amp;Point3d::x);<span class="comment">//nil,若Point3d带virtual func,则为8</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&amp;Point3d::y=%p\n"</span>,&amp;Point3d::y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&amp;Point3d::z=%p\n"</span>,&amp;Point3d::z);</span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">float</span>*)&amp;p3d==(<span class="keyword">float</span>*)&amp;p3d.x)<span class="built_in">cout</span>&lt;&lt;<span class="string">"yes"</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出yes</span></span><br><span class="line">		<span class="keyword">float</span> Point3d::*p1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">float</span> Point3d::*p2=&amp;Point3d::x;</span><br><span class="line">		<span class="keyword">float</span> Point3d::*p3=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span>(p1==p2)<span class="comment">//未输出</span></span><br><span class="line">		&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"p1==p2"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//no output in g++</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span>(p2==p3)</span><br><span class="line">		&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"p2==p3"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//no output in g++</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里若是加了virtual func则，x为8，说明是vptr是放在前面的<br>通过指针取得对象成员:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> *p=origin.z  </span><br><span class="line">struct  Base1&#123;<span class="keyword">int</span> val1;&#125;</span><br><span class="line"><span class="function">struct <span class="title">Base2</span> <span class="params">(<span class="keyword">int</span> val2;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">struct Derved:Base1,Base2&#123;..&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> func1(<span class="keyword">int</span> Derved::*bmp,Derved *pd)</span><span class="comment">//传入offset等，多继承时易出错</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pd-&gt;*dmp;.....</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_polymorphism</title>
    <url>/2018/06/08/cpp-polymorphism/</url>
    <content><![CDATA[<h3 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h3><h4 id="为什么需要多态？"><a href="#为什么需要多态？" class="headerlink" title="为什么需要多态？"></a>为什么需要多态？</h4><p>引入几个点：<br>　　继承的机制中，基类的指针和引用能指向派生类，（派生类对象中的基类成员是在内存前面的，即指向派生类对象的指针指向的是第一个基类的第一个成员）  </p>
<ul>
<li>指针的值本质上是内存地址，也就是说指向不同变量(int char.)，对象的指针本身的值都是地址的value)</li>
<li>指针的类型限定了指针的操作内存范围和取值的方式，如通过int指针取值的时候，取到４byte,通过char指针取值时取得1byte;）<a id="more"></a></li>
<li>因此，基类指针限定了，即使它指向派生类，它也只能操作基类自身的成员和方法；就像char形指针指向int形，取得的只是一部分）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="number">4</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 5 </span>&#123;</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">int</span> in=<span class="number">2</span>;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">char</span> *pc=(<span class="keyword">char</span>*)&amp;in;</span><br><span class="line"> <span class="number">8</span>     <span class="built_in">cout</span>&lt;&lt;*pc&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//乱码</span></span><br><span class="line"> <span class="number">9</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure>
<p>所以基类指针可以指向子类，但是只能调用基类的函数，即使子类复写了父类的函数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;rBase = derived;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>This example prints the result:</p>
<p>rBase is a Base</p>
<p>/＝》简化：如何让下面的例子得到想要的结果？<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Animal *animals[] = &#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iii=<span class="number">0</span>; iii &lt; <span class="number">6</span>; iii++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animals[iii]-&gt;getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; animals[iii]-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如何让父类指针指向子类对象，可以调用子类函数呢？<pre><code>－－－多态
</code></pre></li>
<li>调用的子类函数要满足:<br>A derived function is considered a match if it has the same signature (name, parameter types, and whether it is const) and return type as the base version of the function. Such functions are called overrides.</li>
</ul>
<h4 id="如何使用－－－例子"><a href="#如何使用－－－例子" class="headerlink" title="如何使用－－－例子"></a>如何使用－－－例子</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125; <span class="comment">// note addition of virtual keyword</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;rBase = derived;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This example prints the result:</p>
<p>rBase is a Derived<br>－－－－－－－－－－－－－－－－－－－－－－－<br>再盗一个例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We're making this constructor protected because</span></span><br><span class="line">    <span class="comment">// we don't want people creating Animal objects directly,</span></span><br><span class="line">    <span class="comment">// but we still want derived classes to be able to use it.</span></span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"???"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Meow"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Woof"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(Animal &amp;animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; animal.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cat <span class="title">cat</span><span class="params">(<span class="string">"Fred"</span>)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">dog</span><span class="params">(<span class="string">"Garbo"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    report(cat);</span><br><span class="line">    report(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="注意多态的方式："><a href="#注意多态的方式：" class="headerlink" title="注意多态的方式："></a>注意多态的方式：</h4><p>调用基类指针指向子类，函数时，会调用到继承琏最底端，且该最低端的子类有该virtual函数的，否则只调用到最下且复写了该函数的。如下例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="number">3</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"> 4 &#123;</span></span><br><span class="line"> <span class="number">5</span>         <span class="keyword">public</span>:</span><br><span class="line"> <span class="number">6</span>                     <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line"> <span class="number">7</span> &#125;;</span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line"><span class="number">10</span> &#123;</span><br><span class="line"><span class="number">11</span>         <span class="keyword">public</span>:</span><br><span class="line"><span class="number">12</span>                     <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line"><span class="number">13</span> &#125;;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line"><span class="number">16</span> &#123;</span><br><span class="line"><span class="number">17</span>         <span class="keyword">public</span>:</span><br><span class="line"><span class="number">18</span>                     <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">                       <span class="comment">//or const char * getName()&#123;..&#125; and default virtual</span></span><br><span class="line"><span class="number">19</span> &#125;;</span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">21</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line"><span class="number">22</span> &#123;</span><br><span class="line"><span class="number">23</span>         <span class="keyword">public</span>:</span><br><span class="line"><span class="number">24</span>                    <span class="comment">// virtual const char* getName() &#123; return "D"; &#125;</span></span><br><span class="line"><span class="number">25</span> &#125;;</span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">28 </span>&#123;</span><br><span class="line"><span class="number">29</span>             D d;</span><br><span class="line"><span class="number">30</span>             A &amp;rBase = d;</span><br><span class="line"><span class="number">31</span>             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="number">32</span> </span><br><span class="line"><span class="number">33</span>             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">34</span> &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>输出c
</code></pre><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><ul>
<li>virtual关键字是否都需要写？：<br>Only the most base class function needs to be tagged as virtual for all of the derived<br>functions to work virtually. However, having the keyword virtual on the derived functions<br>does not hurt, and it serves as a useful reminder that the function is a virtual function<br>rather than a normal one.</li>
</ul>
<ul>
<li><p>不能在构造函数和西沟函数中调用它，因为此时子类对象还没有被构造</p>
</li>
<li><p>c++11引入override和final来防止避免不匹配的复写和阻止继承：<br>１）override:<br>出现错误的例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// note: parameter is a short int</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// note: function is const</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	A &amp;rBase = b;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName1(<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName2(<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> 由于参数返回值不匹配，所以编译器认为不是复写，结果：<br> A<br>A<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">加入override:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> x)</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// compile error, function is not an override</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// compile error, function is not an override</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName3</span><span class="params">(<span class="keyword">int</span> x)</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// okay, function is an override of A::getName3(int) </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">Rule: Apply the override specifier to every intended override function you write.</span><br></pre></td></tr></table></figure></p>
<ul>
<li>final:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> 加了final的函数无法被复写：</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// note use of final specifier on following line -- that makes this function no longer overridable</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> override final </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// okay, overrides A::getName()</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125; <span class="comment">// compile error: overrides B::getName(), which is final</span></span><br><span class="line">&#125;;</span><br><span class="line"> 加了final的类不能被继承：</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">final</span> :</span> <span class="keyword">public</span> A <span class="comment">// note use of final specifier here</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B <span class="comment">// compile error: cannot inherit from final class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> `</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>对匹配返回值的一个“例外”：covariant return types:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// This version of getThis() returns a pointer to a Base class</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Normally override functions have to return objects of the same type as the base function</span></span><br><span class="line">    <span class="comment">// However, because Derived is derived from Base, it's okay to return Derived* instead of Base*</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意当base=&derive;<br>     base.getThis()—-取得的任然是base</p>
<h4 id="当想基类指针指向派生类，虚函数但仍然想用基类虚函数时："><a href="#当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：" class="headerlink" title="当想基类指针指向派生类，虚函数但仍然想用基类虚函数时："></a>当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;base = derived;</span><br><span class="line">    <span class="comment">// Calls Base::GetName() instead of the virtualized Derived::GetName()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; base.Base::getName() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="虚析构函数-："><a href="#虚析构函数-：" class="headerlink" title="虚析构函数　："></a>虚析构函数　：</h3><h4 id="为什么需要虚析构函数："><a href="#为什么需要虚析构函数：" class="headerlink" title="为什么需要虚析构函数："></a>为什么需要虚析构函数：</h4><p> 当基类指针指向派生类时，当析构后，只会调用基类的析构函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Base() <span class="comment">// note: not virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Base()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_array;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">    ~Derived() <span class="comment">// note: not virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Derived()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *derived = <span class="keyword">new</span> Derived(<span class="number">5</span>);</span><br><span class="line">    Base *base = derived ;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 只输出Calling ~Base()</p>
<ul>
<li>所以为了调用派生类的析构函数，需要定义为虚析构函数：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() <span class="comment">// note: virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Base()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_array;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Derived() <span class="comment">// note: virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Derived()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *derived = <span class="keyword">new</span> Derived(<span class="number">5</span>);</span><br><span class="line">    Base *base = derived;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Now <span class="keyword">this</span> program produces the following result:</span><br><span class="line">Calling ~Derived()</span><br><span class="line">Calling ~Base()</span><br><span class="line">Rule: Whenever you are dealing with inheritance, you should make any <span class="keyword">explicit</span> destructors <span class="keyword">virtual</span>.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="虚表："><a href="#虚表：" class="headerlink" title="虚表："></a>虚表：</h3><h4 id="Early-binding（静态绑定）-and-late-binding（动态绑定）"><a href="#Early-binding（静态绑定）-and-late-binding（动态绑定）" class="headerlink" title="Early binding（静态绑定） and late binding（动态绑定）"></a>Early binding（静态绑定） and late binding（动态绑定）</h4><p> 前者指的是直接在代码里调用函数，通过函数名，即编译期间就可以直到函数的地址的（偏移，非真实的内存地址）<br>“” Early binding (also called static binding) means the compiler (or linker) is able to directly associate the identifier name (such as a function or variable name) with a machine address.<br> Remember that all functions have a unique address. So when the compiler (or linker) encounters a function call,<br>  it replaces the function call with a machine language instruction that tells the CPU to jump to the address of the function.””<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter another number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an operation (0=add, 1=subtract, 2=multiply): "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">    &#125; <span class="keyword">while</span> (op &lt; <span class="number">0</span> || op &gt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// call the target function directly using early binding</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: result = add(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: result = subtract(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: result = multiply(x, y); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 后者指的是通过函数指针等方式，即在编译期间无法确定调用什么函数，需要通过指针来访问函数（函数指针），效率比前者低<br> in some programs, it is not possible to know which function will be called until runtime (when the program is run).<br> This is known as late binding (or dynamic binding). In C++, one way to get late binding is to use function pointers.<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a function pointer and make it point to the Add function</span></span><br><span class="line">    <span class="keyword">int</span> (*pFcn)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pFcn(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// add 5 + 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h4><p> 为什么虚函数能成立－－基类指针指向派生类能调用派生类的函数：<br> 实际上，在定义了虚函数的基类中维护了一个虚指针：它指向一张表，表中包含各个虚函数指针；在这个继承琏中的每一个类有自己的一张虚表，这张表由编译器在编译期间生成, 虚指针在包含虚函数的类的对象被创建时自动创建<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;; </span><br><span class="line"> 实际上为：</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FunctionPointer *__vptr;<span class="comment">//虚指针</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> base</span><br><span class="line">    *__vptr;--------------------------&gt;base vtable</span><br><span class="line">   virtual function1()&lt;----------------function1()</span><br><span class="line">|-&gt;virtual function2()&lt;----------------function2()</span><br><span class="line">-----------------------------------------------------|</span><br><span class="line">   D1:<span class="keyword">public</span> base                                    |</span><br><span class="line">   *__vptr,(inherited) ----------------D1 vtable     |</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="title">function1</span><span class="params">()</span></span>; &lt;--------------function1()   |</span><br><span class="line">                                       function2()----</span><br><span class="line"> D2类似D1</span><br></pre></td></tr></table></figure></p>
<h3 id="纯虚函数和纯虚类："><a href="#纯虚函数和纯虚类：" class="headerlink" title="纯虚函数和纯虚类："></a>纯虚函数和纯虚类：</h3><h4 id="什么是纯虚函数和纯虚类："><a href="#什么是纯虚函数和纯虚类：" class="headerlink" title="什么是纯虚函数和纯虚类："></a>什么是纯虚函数和纯虚类：</h4><ul>
<li>没有定义函数体的虚成员函数成为纯虚函数：<br>virtual int getValue() = 0; // a pure virtual function<br>包含一个或多个纯虚函数的类成为纯虚类<br>虚基类是不能被对象化的，当对象化后调用纯虚函数，就会出现错误  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base; <span class="comment">// We can't instantiate an abstract base class, but for the sake of example, pretend this was allowed</span></span><br><span class="line">    base.getValue(); <span class="comment">// what would this do?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="为什么需要纯虚函数和纯虚类？"><a href="#为什么需要纯虚函数和纯虚类？" class="headerlink" title="为什么需要纯虚函数和纯虚类？"></a>为什么需要纯虚函数和纯虚类？</h4><p>当子类继承了基类后，对虚函数来讲，需要复写基类的虚函数，而当忘记去写时，默认就会调用基类的虚函数；<br>而如果将基类的虚函数定义为纯虚函数。就会通过编译报错来提醒我们要复写子类的虚函数：<br> 例子：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> // <span class="title">This</span> <span class="title">Animal</span> <span class="title">is</span> <span class="title">an</span> <span class="title">abstract</span> <span class="title">base</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// note that speak is now a pure virtual function</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cow(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We forgot to redefine speak</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">cow</span><span class="params">(<span class="string">"Betsy"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cow.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cow(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Moo"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">cow</span><span class="params">(<span class="string">"Betsy"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cow.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当想要使用虚基类的实现时，又同时想让虚基类不能对象化且子类能提示需要实现纯虚函数时，应该怎么做？<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> // <span class="title">This</span> <span class="title">Animal</span> <span class="title">is</span> <span class="title">an</span> <span class="title">abstract</span> <span class="title">base</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// note that speak is a pure virtual function</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* Animal::speak()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"buzz"</span>; <span class="comment">// some default implementation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dragonfly</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dragonfly(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> <span class="comment">// this class is no longer abstract because we defined this function</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Animal::speak(); <span class="comment">// use Animal's default implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Dragonfly <span class="title">dfly</span><span class="params">(<span class="string">"Sally"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dfly.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; dfly.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">The above code prints:</span><br><span class="line">Sally says buzz</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="接口类："><a href="#接口类：" class="headerlink" title="接口类："></a>接口类：</h4><p>接口类的类中没有成员变量。全部由纯虚函数构成；常命名为I开头的:如IErrorLog,类似于java中的接口<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IErrorLog</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">openLog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">closeLog</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">writeError</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *errorMessage)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~IErrorLog() &#123;&#125;; <span class="comment">// make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="virtual-base-class"><a href="#virtual-base-class" class="headerlink" title="virtual base class"></a>virtual base class</h4><p>当普通的继承，即一个子类继承自两个不同的父类，这两个父类继承自同一个基类时。就容易出现问题：<br>如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PoweredDevice(<span class="keyword">int</span> power)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"PoweredDevice: "</span> &lt;&lt; power &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Scanner(<span class="keyword">int</span> scanner, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Scanner: "</span> &lt;&lt; scanner &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Printer(<span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Printer: "</span> &lt;&lt; printer &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Copier(<span class="keyword">int</span> scanner, <span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : Scanner(scanner, power), Printer(printer, power)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Copier <span class="title">copier</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">PoweredDevice: <span class="number">3</span></span><br><span class="line">Scanner: <span class="number">1</span></span><br><span class="line">PoweredDevice: <span class="number">3</span></span><br><span class="line">Printer: <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>从输出看，基类被构造了两次<br>如何防止构造两个基类呢？使用virtual base class<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PoweredDevice(<span class="keyword">int</span> power)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PoweredDevice: "</span> &lt;&lt; power &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice <span class="comment">// note: PoweredDevice is now a virtual base class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Scanner(<span class="keyword">int</span> scanner, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power) <span class="comment">// this line is required to create Scanner objects, but ignored in this case</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Scanner: "</span> &lt;&lt; scanner &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice <span class="comment">// note: PoweredDevice is now a virtual base class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Printer(<span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power) <span class="comment">// this line is required to create Printer objects, but ignored in this case</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Printer: "</span> &lt;&lt; printer &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Copier(<span class="keyword">int</span> scanner, <span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : Scanner(scanner, power), Printer(printer, power),</span><br><span class="line">        PoweredDevice(power) <span class="comment">// PoweredDevice is constructed here</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">This time, our previous example:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Copier <span class="title">copier</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">produces the result:</span><br><span class="line">PoweredDevice: <span class="number">3</span></span><br><span class="line">Scanner: <span class="number">1</span></span><br><span class="line">Printer: <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>这样的话，基类的构造交给了继承琏最底层的类</p>
<ul>
<li>注意：</li>
<li>virtual base class在子类对象之前就创建了</li>
<li>if Copier was singly inherited from Printer, and Printer was virtually inherited from PoweredDevice, Copier is still responsible for creating PoweredDevice</li>
<li>Fourth, a virtual base class is always considered a direct base of its most derived class<br>(which is why the most derived class is responsible for its construction).</li>
<li>But classes inheriting the virtual base still need access to it. So in order to facilitate this, the compiler creates a virtual table for each class directly inheriting the virtual class (Printer and Scanner). These virtual tables point to the functions in the most derived class. Because the derived classes have a virtual table,  that also means they are now larger by a pointer (to the virtual table).</li>
</ul>
<h4 id="对象分割："><a href="#对象分割：" class="headerlink" title="对象分割："></a>对象分割：</h4><p>当子类对象赋值给基类会发生什么？<br>子类对象的基类部分会给基类对象<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    Base base = derived; <span class="comment">// what happens here?</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base is a "</span> &lt;&lt; base.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; base.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">传值给基类</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">(<span class="keyword">const</span> Base base)</span> <span class="comment">// note: base passed by value, not reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; base.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">This is a pretty simple function with a <span class="keyword">const</span> base object parameter that is passed by value. If we call <span class="keyword">this</span> function like such:	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    printName(d); <span class="comment">// oops, didn't realize this was pass by value on the calling end </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>vector<base>和vector&lt;&amp;base&gt;和vector&lt;base*&gt;<br>第一种可以但是只能调用基类的部分<br>第二种不行：std::vector&lt;Base&amp;&gt; v;<br>Unfortunately, this won’t compile. The elements of std::vector must be assignable, whereas references can’t be reassigned (only initialized).<br>第三种可以但是要做delete<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Base*&gt; v;</span><br><span class="line">	v.push_back(<span class="keyword">new</span> Base(<span class="number">5</span>)); <span class="comment">// add a Base object to our vector</span></span><br><span class="line">	v.push_back(<span class="keyword">new</span> Derived(<span class="number">6</span>)); <span class="comment">// add a Derived object to our vector</span></span><br><span class="line">        <span class="comment">// Print out all of the elements in our vector</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; v.size(); ++count)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; v[count]-&gt;getName() &lt;&lt; <span class="string">" with value "</span> &lt;&lt; v[count]-&gt;getValue() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; v.size(); ++count)</span><br><span class="line">		<span class="keyword">delete</span> v[count];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">用智能指针可以避免：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; // for std::reference_wrapper</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::reference_wrapper&lt;Base&gt; &gt; v; <span class="comment">// our vector is a vector of std::reference_wrapper wrapped Base (not Base&amp;)</span></span><br><span class="line">	<span class="function">Base <span class="title">b</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// b and d can't be anonymous objects</span></span><br><span class="line">	<span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">	v.push_back(b); <span class="comment">// add a Base object to our vector</span></span><br><span class="line">	v.push_back(d); <span class="comment">// add a Derived object to our vector</span></span><br><span class="line">	<span class="comment">// Print out all of the elements in our vector</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; v.size(); ++count)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; v[count].get().getName() &lt;&lt; <span class="string">" with value "</span> &lt;&lt; v[count].get().getValue() &lt;&lt; <span class="string">"\n"</span>; <span class="comment">// we use .get() to get our element from the wrapper</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一种极端情况：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Derived <span class="title">d2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    Base &amp;b = d2;<span class="comment">//b为d2的引用</span></span><br><span class="line">    b = d1; <span class="comment">// this line is problematic　导致b的基类部分为d1,子类部分为d2,因为b是d2的引用，导致现在d2的基类部分是d1而子类部分是d2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="总结多态的方式＋dynamic-cast"><a href="#总结多态的方式＋dynamic-cast" class="headerlink" title="总结多态的方式＋dynamic_cast:"></a>总结多态的方式＋dynamic_cast:</h4><ul>
<li><p>　shape <em>ps=new circle();<br>  经由virtual func:  ps-&gt;rotate()    //virtual func<br>  经由dynamic_cast:和type运算符：<br>  if(circle </em>pc=dynamic_cast&lt;circle*&gt;(ps))</p>
<p>  (理解了指针类型的本质就可以理解它和理解分割的内容了:指针的类型会教导编译器如何解释某个特定地址的内容和大小:<br>  所以一个void*的指针无法去确定涵盖多大的地址空间，所以它只能含有一个地址但是不能操作它指向的Ｏｂｊｅｃｔ<br>  所以转型只是一种编译器指令，不改变真正的地址，而是改变解读指针的方式让它指出其内存的大小和内容）<br>  更多见内存布局第一章图就能理解）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_inheritance</title>
    <url>/2018/06/08/cpp-inheritance/</url>
    <content><![CDATA[<h3 id="c-继承："><a href="#c-继承：" class="headerlink" title="c++ 继承："></a>c++ 继承：</h3><h4 id="继承是什么能做什么"><a href="#继承是什么能做什么" class="headerlink" title="继承是什么能做什么"></a>继承是什么能做什么</h4><p>继承是创建复杂类的另一种方式，它展现出来俩个obj 的is-a的概念（前一种方式是加入复杂的函数和成员等has-a　概念）<br>继承体现的是两个对象（类）之间的联系，子类继承父类的成员和方法，然后特殊化于扩展自己的成员和方法，正如苹果和梨都是水果，它们拥有水果的一般特性，等边三角形是特殊的等腰三角形<a id="more"></a><br>几个概念引英文词： the class being inherited from is called the parent class, base class, or superclass, and the class doing the inheriting is called the child class, derived class, or subclass.</p>
<h4 id="继承怎么使用，分为什么"><a href="#继承怎么使用，分为什么" class="headerlink" title="继承怎么使用，分为什么"></a>继承怎么使用，分为什么</h4><p>继承的使用通过例子来学习，分为单继承和多继承等<br>多继承的问题：<br>１）两个基类中存在相同的方法，子类调用该方法－－－》解决，可以调用的方法前加上类限定符base::<br>2)俩个类继承自同一个类，接着另一个类继承这两个类<br>懒得自己写，从learncpp拷贝<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure></p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"> </span><br><span class="line">    Person(<span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">""</span>, <span class="keyword">int</span> age = <span class="number">0</span>)</span><br><span class="line">        : m_name(name), m_age(age)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_age; &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// BaseballPlayer publicly inheriting Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseballPlayer</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_battingAverage;</span><br><span class="line">    <span class="keyword">int</span> m_homeRuns;</span><br><span class="line"> </span><br><span class="line">    BaseballPlayer(<span class="keyword">double</span> battingAverage = <span class="number">0.0</span>, <span class="keyword">int</span> homeRuns = <span class="number">0</span>)</span><br><span class="line">       : m_battingAverage(battingAverage), m_homeRuns(homeRuns)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a new BaseballPlayer object</span></span><br><span class="line">    BaseballPlayer joe;</span><br><span class="line">    <span class="comment">// Assign it a name (we can do this directly because m_name is public)</span></span><br><span class="line">    joe.m_name = <span class="string">"Joe"</span>;</span><br><span class="line">    <span class="comment">// Print out the name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; joe.getName() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// use the getName() function we've acquired from the Person base class</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承的方式，访问控制"><a href="#继承的方式，访问控制" class="headerlink" title="继承的方式，访问控制"></a>继承的方式，访问控制</h4><p>A child class inherits both behaviors (member functions) and properties (member variables) from the parent 但是受继承方式的限制<br>继承的方式有public等，受限制，这种可以通俗的理解为，你和你妈，你姨妈，你表舅等的亲密度和能访问的内容是有等级差别的</p>
<table>
<thead>
<tr>
<th style="text-align:left">Access specifier in base class</th>
<th style="text-align:left">when inherited publicly</th>
<th style="text-align:left">when　inherited privately</th>
<th style="text-align:left">when inherited protectedly</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Public</td>
<td style="text-align:left">Public</td>
<td style="text-align:left">Private</td>
<td style="text-align:left">Protected</td>
</tr>
<tr>
<td style="text-align:left">Private</td>
<td style="text-align:left">Inaccessible</td>
<td style="text-align:left">Inaccessible</td>
<td style="text-align:left">Inaccessible</td>
</tr>
<tr>
<td style="text-align:left">Protected</td>
<td style="text-align:left">Protected</td>
<td style="text-align:left">Private</td>
<td style="text-align:left">Protected</td>
</tr>
</tbody>
</table>
<h4 id="继承的内存"><a href="#继承的内存" class="headerlink" title="继承的内存"></a>继承的内存</h4><ul>
<li>对单纯的类对象来说，没有继承时，其对象内存是成员变量，存储在栈中<br>，当继承了基类后，基类的成员变量（即使是private不能访问的）会添加到子类的对象内存中，而且一般是放在低地址（前面）<br>对访问控制是在编译期间去做限制的</li>
</ul>
<h4 id="编译器对继承做了什么？"><a href="#编译器对继承做了什么？" class="headerlink" title="编译器对继承做了什么？"></a>编译器对继承做了什么？</h4><ul>
<li>构造函数  </li>
<li>首先，构造函数顺序：Because Derived inherits functions and variables from Base,<br>you may assume that the members of Base are copied into Derived.<br>However, this is not true. Instead, we can consider Derived as a two part class:<br>one part Derived, and one part Base.<br>，从构造函数可以看出，继承的类，对象先调用继承连最上层的类构造函数，最后调用它自己的构造函数</li>
<li>其次，基类构造函数被子类调用：//弥补了子类不能　初始化父类成员的缺陷－－－为什么子类不能在初始化队列中初始化父类成员？若为const就出错了，初始化两次</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// our member is now private</span></span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>, <span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : Base(id), <span class="comment">// Call Base(int) constructor with value id!</span></span><br><span class="line">            m_cost(cost)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>析构函数：调用顺序和构造函数相反</li>
<li><p>子类加入自己的函数和ovrridewirte父类函数  </p>
<ul>
<li><p>策略：<br>When a member function is called with a derived class object,<br>the compiler first looks to see if that member exists in the derived class.<br>If not, it begins walking up the inheritance chain and checking whether the member<br>has been defined in any of the parent classes. It uses the first one it finds.</p>
</li>
<li><p>在父类中被声明为private 的函数经过子类重写后可能会变成public:  </p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derived derived;</span><br><span class="line">	derived.print(); <span class="comment">// calls derived::print(), which is public</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>保留父类函数的方法:</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> value)</span><br><span class="line">        : m_value(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identify</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a Base\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base::identify(); <span class="comment">// call Base::identify() first</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a Derived\n"</span>; <span class="comment">// then identify ourselves</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>c++11新：<br>将base类中的保护函数，在子类中声明为public:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> value)</span><br><span class="line">        : m_value(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Base::printValue was inherited as protected, so the public has no access</span></span><br><span class="line">    <span class="comment">// But we're changing it to public via a using declaration</span></span><br><span class="line">    <span class="keyword">using</span> Base::printValue; <span class="comment">// note: no parenthesis here  //c++11</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// printValue is public in Derived, so this is okay</span></span><br><span class="line">    derived.printValue(); <span class="comment">// prints 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类中将父类的方法隐藏：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Base(<span class="keyword">int</span> value)</span><br><span class="line">		: m_value(value)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Derived(<span class="keyword">int</span> value)</span><br><span class="line">		: Base(value)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>= <span class="keyword">delete</span>; <span class="comment">// mark this function as inaccessible</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// The following won't work because getValue() has been deleted!</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; derived.getValue();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_conandde</title>
    <url>/2018/06/08/cpp-conandde/</url>
    <content><![CDATA[<h2 id="c-class-constructor-and-destructor"><a href="#c-class-constructor-and-destructor" class="headerlink" title="c++ class constructor and destructor"></a>c++ class constructor and destructor</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="构造函数表现"><a href="#构造函数表现" class="headerlink" title="构造函数表现"></a>构造函数表现</h4><h5 id="构造函数的作用："><a href="#构造函数的作用：" class="headerlink" title="构造函数的作用："></a>构造函数的作用：</h5><p>构造函数主要是用来初始化对象的－－－一般是成员，函数不用<br>–所以它需要在构建对象时就执行<a id="more"></a></p>
<h5 id="构造函数如何写："><a href="#构造函数如何写：" class="headerlink" title="构造函数如何写："></a>构造函数如何写：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:　classname(arg...):member(arg),mem2(arg),..&#123;xxx&#125;</span><br><span class="line">    classname(..)&#123;..&#125;</span><br><span class="line">```        </span><br><span class="line">##### 默认构造函数的生成规则（深入对象模型）</span><br><span class="line">+ 下面四个情况下会生成默认构造函数（编译器控制）(nontrivial <span class="keyword">default</span> constructor)  </span><br><span class="line"> + 带有<span class="keyword">default</span> constructor的member <span class="class"><span class="keyword">class</span> <span class="title">object</span>  </span></span><br><span class="line"><span class="class"> 即在类中带有对象成员，该对象成员所属的类有构造函数</span></span><br><span class="line"><span class="class">如：　</span></span><br><span class="line"><span class="class">```<span class="title">cpp</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Foo</span> &#123;</span><span class="keyword">public</span> :Foo(),Foo(<span class="keyword">int</span>)...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span><span class="keyword">public</span>:Foo foo;<span class="keyword">char</span> *str&#125;;</span><br><span class="line">                          <span class="function"><span class="keyword">void</span> <span class="title">funv</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                          </span>&#123;   Bar bar;....</span><br><span class="line">                          &#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下若程序员没有实现构造函数，则编译器会自己生成构造函数，来调用Foo的构造函数<br>但是不初始化str,这个得由程序员来做。<br>如类似于：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Bar::Bar()&#123;</span><br><span class="line">   foo.Foo::Foo();</span><br><span class="line"> ```                  </span><br><span class="line"> 若程序员自己写了构造函数但是不包括初始化foo则，编译器会在程序眼写的构造函数中加入上述，另外若有多个对象</span><br><span class="line">则按照声明顺序进行调用他们的构造函数；</span><br><span class="line"> + 带有Default constructor 的base <span class="class"><span class="keyword">class</span>  </span></span><br><span class="line"><span class="class"> 同理，当继承的基类带有构造函数时就会加入，若程序员的构造函数没有初始化他们时就会扩展  </span></span><br><span class="line"><span class="class">//以上见例子<span class="title">class_constructor</span>.<span class="title">cpp</span>，</span></span><br><span class="line"><span class="class"> + 和<span class="title">vcirtual</span>相关<span class="title">need</span> <span class="title">to</span> <span class="title">create</span> <span class="title">vptr</span>  </span></span><br><span class="line"><span class="class">    带有一个<span class="title">virtual</span>　<span class="title">func</span>的<span class="title">class</span>  </span></span><br><span class="line"><span class="class">     1)<span class="title">class</span>　声明或继承一个<span class="title">virtua</span> <span class="title">func</span>  </span></span><br><span class="line"><span class="class">     2)<span class="title">class</span>派生自一个继承琏，其中有<span class="title">virtual</span> <span class="title">base</span> <span class="title">classes</span>       这个比较容易理解</span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class"> + 和<span class="title">virtual</span>相关 <span class="title">need</span> <span class="title">to</span> <span class="title">init</span> <span class="title">vptr</span></span></span><br><span class="line"><span class="class">   带有一个<span class="title">virtual</span>　<span class="title">base</span> <span class="title">class</span> 的<span class="title">class</span>  </span></span><br><span class="line"><span class="class">   如：</span></span><br><span class="line"><span class="class">   ```<span class="title">cpp</span></span></span><br><span class="line"><span class="class">       <span class="title">class</span> <span class="title">X</span>&#123;</span>  <span class="keyword">public</span> <span class="keyword">int</span> i;&#125;  </span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="comment">///</span></span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A,<span class="keyword">public</span> B</span><br></pre></td></tr></table></figure></p>
<h5 id="构造函数何时被执行"><a href="#构造函数何时被执行" class="headerlink" title="构造函数何时被执行"></a>构造函数何时被执行</h5><p>-在对象定义时若有构造函数，则会执行</p>
<h5 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h5><p>1:5构造函数的使用：重载，初始化式</p>
<h4 id="构造函数表现的原理"><a href="#构造函数表现的原理" class="headerlink" title="构造函数表现的原理"></a>构造函数表现的原理</h4><h5 id="构造函数在静态代码块中的位置和符号体现"><a href="#构造函数在静态代码块中的位置和符号体现" class="headerlink" title="构造函数在静态代码块中的位置和符号体现"></a>构造函数在静态代码块中的位置和符号体现</h5><p>如果有定义构造函数，它本身也是一个函数，放在代码段中，可以通过kdbg查看<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">origin(<span class="keyword">int</span> ax=<span class="number">3</span>,<span class="keyword">int</span> bx=<span class="number">4</span>):a(ax),b(bx)&#123;&#125;</span><br><span class="line"><span class="number">0x400bae</span> push   %rbp</span><br><span class="line"><span class="number">0x400baf</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x400bb2</span> mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line"><span class="number">0x400bb6</span> mov    %esi,<span class="number">-0xc</span>(%rbp)</span><br><span class="line"><span class="number">0x400bb9</span> mov    %edx,<span class="number">-0x10</span>(%rbp)</span><br></pre></td></tr></table></figure></p>
<h5 id="构造函数在动态执行时，放在哪个内存段中，如何被引用，使用"><a href="#构造函数在动态执行时，放在哪个内存段中，如何被引用，使用" class="headerlink" title="构造函数在动态执行时，放在哪个内存段中，如何被引用，使用"></a>构造函数在动态执行时，放在哪个内存段中，如何被引用，使用</h5><ul>
<li>动态执行时，在代码段中，通过this引用</li>
<li>构造函数总结：任何c++ class只有在以上四中情况下才会产生默认构造函数，且产生的默认构造函数不会去初始化成员的值<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><h4 id="拷贝的动作发生了什么"><a href="#拷贝的动作发生了什么" class="headerlink" title="拷贝的动作发生了什么"></a>拷贝的动作发生了什么</h4>拷贝的本质，为什么需要拷贝构造函数？</li>
<li>首先对基本的类型而言，拷贝是把值赋给另一个同类型的变量，而数租不能做=赋值拷贝</li>
<li>对对象而言，也是把值赋给同类型的对象，而不是共享一个指针，所以这个过程需要将对象中的成员也复制过去（复制的是当前对象在此时时成员的值　）</li>
<li>c++中的拷贝构造函数针对三种行为：＝　，f(T t)和　f(){T t;return t}返回对象－－这三种情况都针对左值的　　　</li>
<li>=:注意这个是在定义时做的，如origin or1=or2;此时会调用”拷贝构造函数”（　同or1(or2))<br>　or2=or3;此时不会调用拷贝构造函数<br>（当程序员自己写了拷贝构造函数时，默认调用该构造函数，而不会区做成员复制，所以若在其中没有做复制，可能得到不想要的值，见例子)</li>
</ul>
<h4 id="拷贝构造函数的作用和使用"><a href="#拷贝构造函数的作用和使用" class="headerlink" title="拷贝构造函数的作用和使用"></a>拷贝构造函数的作用和使用</h4><h5 id="什么情况下会生成默认的拷贝构造函数？"><a href="#什么情况下会生成默认的拷贝构造函数？" class="headerlink" title="什么情况下会生成默认的拷贝构造函数？"></a>什么情况下会生成默认的拷贝构造函数？</h5><p>类似于构造函数，在以下情形会生成默认的拷贝构造函数－</p>
<ul>
<li>当需要调用别的拷贝构造函数时，如：当类内含有一个member object而后者的class声明有一个copy　constructor时；</li>
<li>当类继承自一个base class而后者有拷贝构造函数</li>
<li>当类声明了一个或多个virtual functions时</li>
<li>当class 派生自一个继承　串琏，而其中有一个或多个virtual base classes 时</li>
</ul>
<h4 id="拷贝构造函数和编译器－－－汇编，转换："><a href="#拷贝构造函数和编译器－－－汇编，转换：" class="headerlink" title="拷贝构造函数和编译器－－－汇编，转换："></a>拷贝构造函数和编译器－－－汇编，转换：</h4><p>分三种情况讨论：</p>
<ul>
<li><p>初始化拷贝构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;</span><br><span class="line">X x2=x0;</span><br><span class="line">X x3=X(x0);</span><br></pre></td></tr></table></figure>
<p> 上述三种都是定义一个类，即定义的本质会在内存中开辟空间<br>上述三个都会执行拷贝构造函数，如何执行？<br>会被转换为：伪代码</p>
<pre><code>X x1;
x1.X::X(x0);
会调用X::X(const X&amp; xx) 
x2,x3也是这样，将拷贝方作为函数参数传入
这样就可以解释为什么拷贝构造函数的定义是      
classname (const classname &amp;obj)
</code></pre></li>
<li>参数的初始化<br>即传入一个参数给函数：<pre><code>foo(X x)
</code></pre>如：<pre><code>X xx;
//,..
foo(xx);
则会产生一个临时的对象：
</code></pre>伪代码<pre><code>X __temp0;
_temp0.X::X(xx);//use copy construtor
 foo(__temp0)
</code></pre>这里因为它是临时的，所以则定义的时候需要用引用foo(X &amp;x)//这里不是很清楚为什么用引用～！，是否后面的操作直接面向该对象，需要做实际的修改，所以。。<br>所以，为了对付临时的对象，在执行完函数后，需要调用该对象的析构函数</li>
<li>返回值的初始化：<br>如<pre><code>X bar(){
               X xx;
                //...
                return xx;
     }
  如何做X xxx=bar();如何拷贝的？双阶段初始化：
  a 增加一个额外的引用参数给函数，如void bar(X＆　_result)
  b 在return 前插入一个copy constructor 
      void bar(X &amp;__result){
                X xx;
                xx.X::X();
                __result.X::XX(xx);
                return ;
        }
 所以上述会被转化为：
 Ｘ　xx=bar()  ---&gt;  X xx ;//注意这里不会执行默认构造函数　　bar(xx);
     ex:bar().memfunc()---&gt;X __temp0;(bar(__temp0),__temp0).memfunc();
     X (*pf)();pf=bar;---&gt;void (*pf)(X&amp;);pf=bar;
</code></pre></li>
</ul>
<h5 id="关于上述三种情况的优化："><a href="#关于上述三种情况的优化：" class="headerlink" title="关于上述三种情况的优化："></a>关于上述三种情况的优化：</h5><p>１)在使用者层面上优化；２）在编译器层面的优化（ＮＲＶ）具体见深入模型（书）</p>
<h5 id="关于该不该编写copy-constructor"><a href="#关于该不该编写copy-constructor" class="headerlink" title="关于该不该编写copy  constructor:"></a>关于该不该编写copy  constructor:</h5><p>除非需要大量的memberwise 初始化操作，如传值给object以便做NRV优化，否则不需要<br>//上述情况的检验可以通过代码，或者去看编译器的生成代码～    </p>
<h5 id="拷贝构造函数的内存"><a href="#拷贝构造函数的内存" class="headerlink" title="拷贝构造函数的内存"></a>拷贝构造函数的内存</h5><p>放在代码段，</p>
<h3 id="初始化队列"><a href="#初始化队列" class="headerlink" title="初始化队列"></a>初始化队列</h3><p>即构造函数的一种形式如：X(int f):a(ax),b(bx)..{….}</p>
<ul>
<li><p>问题：什么时候用初始化列表？它和初始化赋值有什么不同？</p>
<pre><code>有以下四种情况需要使用初始化列表：
１）当初始化一个reference member时
２）当初始化一个const member时
３）当调用一个base class的constructor,当它拥有一组参数时
４）当调用一个member　class 的consructor，而它有一组参数时；
</code></pre><p>如<br><code></code>cpp<br> class world {</p>
<pre><code>String _nhame;
int cnt;
public :world(){_nhame=0;cnt=0;}}<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时，对_nhame这个成员，需要做较多的事，如产生临时对像，调用operator=....</span></span><br><span class="line">   －－－－所以想到用初始化列表：</span><br><span class="line">```cpp </span><br><span class="line">          world::world:nhame(<span class="number">0</span>)&#123;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            这样只会调用nhame的构造函数</span><br><span class="line">            会被转换为：world::world&#123; <span class="comment">//伪代码</span></span><br><span class="line">             _nhame.String::String(<span class="number">0</span>);</span><br><span class="line">              cnt=<span class="number">0</span>;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
<li><p>更具体的，初始化列表如何进行：顺序如何：如前，初始化列表最终会被转换为初始化表达式到构造函数体中，那是什么顺序呢？<br>注意这里的初始化顺序是根据成员在类中的定义（声明）顺序来的，而不是初始化列表中的顺序<br>看这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">             <span class="keyword">int</span> i; </span><br><span class="line">             <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">              X(<span class="keyword">int</span> cal):i(j)&#123;&#125;</span><br><span class="line">              ...</span><br><span class="line">              此时，因为i先初始化,再j,出错，i需要j</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  —-&gt;可以改善为：X::X(int cal):j(cal){i=j;}<br>   —-为什么这样可以？<br>   因为初始化列表的内容会放到初始化体中的表达式前面，这样j就会先定义<br>        －－－－》另一个可能出错的例子：<br>        　　　X::X(int cal):i(xfoo(cal)),j(cal){}<br>        –&gt;转换为：X::X(/<em>this pointer</em>/ int cal){<br>                      i=this-&gt;xfoo(cal);<br>                      j=cal;<br>                      }<br>            这个情况在这里是对的，但是当X 继承自某个类，在xfoo是基类的函数，，则会出错this-&gt;xfoo</p>
<h4 id="几个问题："><a href="#几个问题：" class="headerlink" title="几个问题："></a>几个问题：</h4><ul>
<li>较为简单的例子见文件中的例子</li>
<li>当程序员定义了拷贝构造函数时，还会执行memberwise initialization吗　－－会执行拷贝构造函数<br>参考：深入c++对象模型和<a href="http://en.cppreference.com/w/cpp/language/copy_constructor" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/language/copy_constructor</a></li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_class_memory</title>
    <url>/2018/06/08/cpp-class-memory/</url>
    <content><![CDATA[<h3 id="c-类内存布局："><a href="#c-类内存布局：" class="headerlink" title="c++类内存布局："></a>c++类内存布局：</h3><h4 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h4><p>下编译后的“内存布局”，此时还未分配内存，不能算是内存，只能说是文件布局<a id="more"></a></p>
<ul>
<li>two question:<br>多少内存能表现一个ob:?<br>多少内存能表现一个class?–编译期，如　int 大小为４ </li>
<li>静态下，编译后同C一样分为代码段等；而类的特性有些类似于struct,定义类的文件中包含了成员变量，成员函数。</li>
<li>类：<pre><code>非静态成员变量：存于对象中
vptr指针：存于对象中
vt表:vptr指向这个表，这个表在构造函数中默认隐士初始化，将对应的虚拟函数地址赋给表中的各个值（表本身with&quot;类&quot;）
obj:         class:
_vptr ---&gt;   table: ptr1 --&gt;virtual func1
                    ptr2 --&gt;virtual func2
静态变量: 存入数据段中
成员函数:代码段,通过this和成员变量建立联系
静态函数：　存于代码段中
全局函数
main函数
全局变量和静态变量
局部变量：栈
something extra depend on compiler~
</code></pre></li>
<li>some rules<ul>
<li>每个类产生一堆指向virtual func的指针，放在表格中，表称为：vtbl;   </li>
<li>每个obj被添加了一个指针，指向相关的tirtual table ,为vptr;</li>
<li>vptr的设定和重置由constructor，destructor,copy assignment运算服自动完成）　</li>
<li>注意每一个class所关联的type info object(用于支持runtime type identification  )也经由virtual table指出，放在vptr[0]处）</li>
<li>虚函数有可能被转换为：(*px-&gt;vtbl[1])(px)<pre><code>具体见深入c++模型书
</code></pre></li>
</ul>
</li>
</ul>
<h4 id="多少内存能表现一个ob"><a href="#多少内存能表现一个ob" class="headerlink" title="多少内存能表现一个ob:?"></a>多少内存能表现一个ob:?</h4><ul>
<li>non static data members</li>
<li>padding</li>
<li>virtual—vptr<h4 id="多少内存能表现一个class"><a href="#多少内存能表现一个class" class="headerlink" title="多少内存能表现一个class?"></a>多少内存能表现一个class?</h4>见datamember_memory  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">最小是１　  size  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span> &#125;;   --<span class="number">-1</span> 一个<span class="keyword">char</span> 表示这个类型  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;　　--指针大小，指针指向T    <span class="keyword">virtual</span> base <span class="class"><span class="keyword">class</span> <span class="title">subobject</span>  </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Y</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;  --指针大小</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> X,<span class="keyword">public</span> Y &#123;&#125;;　--两个指针大小</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>more seee datamember_memory</p>
<h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4><p>的内存布局，即作为进程运行时，其内存是如何的；</p>
<ul>
<li>运行时，涉及类的对象模型，对象的内存部分只包含非静态成员变量和虚拟函数指针表；</li>
<li>可以通过gdb 或kgdb进行查看类对象的地址或者类函数的地址：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	Circle c12;</span><br><span class="line">		<span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">1.2</span>,<span class="string">"red"</span>)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"getRadius:%x\n"</span>,&amp;Circle::getRadius);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x, %x\n"</span>,&amp;c12,c12);</span><br><span class="line"> <span class="keyword">void</span> *cc;</span><br><span class="line">        cc=(Circle*)(&amp;c12);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;*((<span class="keyword">double</span>*)cc)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">```		</span><br><span class="line">    		</span><br><span class="line">所以c++的对象带来的开销在于操作多态时的vptr等效率低）		</span><br><span class="line"></span><br><span class="line">一个例子</span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">					<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">					<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">					<span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">6</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"D"</span>; &#125;</span><br><span class="line"><span class="number">0x400ae8</span> push   %rbp</span><br><span class="line"><span class="number">0x400ae9</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x400aec</span> mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">					<span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">8</span>;&#125;</span><br><span class="line"><span class="number">0x400af8</span> push   %rbp</span><br><span class="line"><span class="number">0x400af9</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x400afc</span> mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">		    A aa;</span><br><span class="line">			aa.getName();</span><br><span class="line">		    D d;</span><br><span class="line">			d.getName();</span><br><span class="line">			A &amp;rBase = d;</span><br><span class="line">			rBase.getName();</span><br><span class="line"><span class="number">0x400986</span> mov    <span class="number">-0x28</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x40098a</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x40098d</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x400990</span> mov    <span class="number">-0x28</span>(%rbp),%rdx</span><br><span class="line"><span class="number">0x400994</span> mov    %rdx,%rdi</span><br><span class="line"><span class="number">0x400997</span> callq  *%rax</span><br><span class="line">            rBase.getage();</span><br><span class="line"><span class="number">0x400999</span> mov    <span class="number">-0x28</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x40099d</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x4009a0</span> add    $<span class="number">0x8</span>,%rax</span><br><span class="line"><span class="number">0x4009a4</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x4009a7</span> mov    <span class="number">-0x28</span>(%rbp),%rdx</span><br><span class="line"><span class="number">0x4009ab</span> mov    %rdx,%rdi</span><br><span class="line"><span class="number">0x4009ae</span> callq  *%rax</span><br><span class="line">		    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">					 </span><br><span class="line">			D d2;</span><br><span class="line">            A &amp;rBase2 =d2;</span><br><span class="line"><span class="number">0x4009f9</span> lea    <span class="number">-0x30</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x4009fd</span> mov    %rax,<span class="number">-0x20</span>(%rbp)</span><br><span class="line">		   rBase2.getName();	</span><br><span class="line"><span class="number">0x400a01</span> mov    <span class="number">-0x20</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a05</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x400a08</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x400a0b</span> mov    <span class="number">-0x20</span>(%rbp),%rdx</span><br><span class="line"><span class="number">0x400a0f</span> mov    %rdx,%rdi</span><br><span class="line"><span class="number">0x400a12</span> callq  *%rax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>something else:  </p>
<ul>
<li>成员函数也是只有一份被存于代码区中，而对象并没有指向成员函数的指针，对象只存成员和虚拟表　；那在对象.成员函数使用时，</li>
<li>是如何确定该函数中使用的成员是该对象的成员?<br>这里是this指针的作用<br>从汇编看，是否是成员函数在取的成员变量时，会做一些动作，这时的成员变量是在栈区；；<br>或者从调用成员函数时，是否有传入或控制函数的一些动作，让它知道从哪里取得对应的成员返回；</li>
<li>成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_this</title>
    <url>/2018/06/08/cpp-this/</url>
    <content><![CDATA[<h3 id="c-关键字之this"><a href="#c-关键字之this" class="headerlink" title="c++关键字之this"></a>c++关键字之this</h3><h4 id="this指针是什么"><a href="#this指针是什么" class="headerlink" title="this指针是什么"></a>this指针是什么</h4><p>this是一个指向当前正在使用的对象的指针，它是一个指针；<br>成员函数通过它来使用对象的值，通过它知道要对哪个对象的成员操作<br>如：<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Simple(<span class="keyword">int</span> id)</span><br><span class="line">    &#123;</span><br><span class="line">        setID(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; m_id = id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Simple <span class="title">simple</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    simple.setID(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; simple.getID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">simple.setID(<span class="number">2</span>);---&gt;</span><br><span class="line">setID(&amp;simple, <span class="number">2</span>); <span class="comment">// note that simple has been changed from an object prefix to a function argument!</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; m_id = id; &#125;---&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(Simple* <span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">int</span> id)</span> </span>&#123; <span class="keyword">this</span>-&gt;m_id = id; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="this指针用法"><a href="#this指针用法" class="headerlink" title="this指针用法"></a>this指针用法</h4><p>关键词 this 是一个纯右值表达式，其值是在调用成员函数时的对象地址。它能出现于下列语境：</p>
<ul>
<li>在任何非静态成员函数体内，含成员初始化列表</li>
<li>在非静态成员函数的声明内任何(可选) cv 限定符序列后处，包含动态异常规定(弃用)、 noexcept 规定(C++11)及尾随返回类型(C++11 起)</li>
<li>在默认成员初始化中 (C++11 起)</li>
<li>在一个对象的构造期间，若通过不直接或间接从构造函数的 this 指针获得的泛左值，访问对象的值或任何其子对象，则如此获得的对象或子对象的值是未指定的。换言之，构造函数中 this 指针不能别名使用：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">D</span> <span class="title">d</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line">D(<span class="keyword">int</span> a) : a(a), b(d.a) &#123;&#125; <span class="comment">// a(a)will change to this-&gt;a(a),but b(d.a)--&gt;this-&gt;b(d.a),and will get random value,but b(a) 或 b(this-&gt;a) 是正确的</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line">D d = D(<span class="number">1</span>);   <span class="comment">// 因为 b(d.a) 不通过 this 访问， d.b 现在是未指定的,i try in g++.find it d.b==1</span></span><br></pre></td></tr></table></figure>
<h4 id="this指针于内存哪里？"><a href="#this指针于内存哪里？" class="headerlink" title="this指针于内存哪里？"></a>this指针于内存哪里？</h4><p>this 指针是不占类的内存的，它是传入成员函数的参数，所以它在栈中  </p>
<h4 id="this-指针总是指向正在操作的对象："><a href="#this-指针总是指向正在操作的对象：" class="headerlink" title="this 指针总是指向正在操作的对象："></a>this 指针总是指向正在操作的对象：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Simple <span class="title">A</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// *this = &amp;A inside the Simple constructor</span></span><br><span class="line">    <span class="function">Simple <span class="title">B</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// *this = &amp;B inside the Simple constructor</span></span><br><span class="line">    A.setID(<span class="number">3</span>); <span class="comment">// *this = &amp;A inside member function setID</span></span><br><span class="line">    B.setID(<span class="number">4</span>); <span class="comment">// *this = &amp;B inside member function setID</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line">+ <span class="keyword">this</span>指针的连锁使用：  </span><br><span class="line">由<span class="keyword">this</span>指针理解<span class="built_in">cout</span>&lt;&lt;xxx&lt;&lt;&lt;xxx&lt;&lt;&lt;xxxxx....</span><br><span class="line">对上述的表达式，<span class="built_in">cout</span>是一个类，&lt;&lt;是该类的操作符函数，则&lt;&lt;函数返回<span class="keyword">this</span>，若返回空，则无法进行：  </span><br><span class="line">```cpp</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; userName;</span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span>) &lt;&lt; userName;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">void</span>) &lt;&lt; userName;　错误</span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span>) &lt;&lt; userName;正确</span><br><span class="line">如何写？</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Calc() &#123; m_value = <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Calc&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value += value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">sub</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value -= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">mult</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value *= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calc calc;</span><br><span class="line">    calc.add(<span class="number">5</span>).sub(<span class="number">3</span>).mult(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; calc.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意Calc&amp; 和return *this</p>
<h4 id="this指针到对象名代表的是什么"><a href="#this指针到对象名代表的是什么" class="headerlink" title="this指针到对象名代表的是什么"></a>this指针到对象名代表的是什么</h4><p>由above和以下例子：来看对象的地址等<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">set</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">set</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_i += i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">getval</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span> s;</span><br><span class="line">    s.add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.getval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//结果是２　因为函数返回的*this是一个值，它是set对象的值：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span></span></span><br><span class="line"><span class="class">    5 &#123;</span>   </span><br><span class="line">    <span class="number">6</span>     <span class="keyword">int</span> m_e;</span><br><span class="line">    <span class="number">7</span>     <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="number">8</span>  <span class="keyword">public</span>:</span><br><span class="line">    <span class="number">9</span>     <span class="built_in">set</span>()</span><br><span class="line">   <span class="number">10</span>     &#123;</span><br><span class="line">   <span class="number">11</span>         m_e=<span class="number">0</span>;</span><br><span class="line">   <span class="number">12</span>         m_i=<span class="number">0</span>;</span><br><span class="line">   <span class="number">13</span>     &#125;</span><br><span class="line">   <span class="number">14</span>     <span class="function"><span class="built_in">set</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">   <span class="number">15</span>             m_i+=i;</span><br><span class="line">   <span class="number">16</span>             <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   <span class="number">17</span>     &#125;</span><br><span class="line">   <span class="number">18</span>     <span class="function"><span class="keyword">int</span> <span class="title">getval</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   <span class="number">19</span>             <span class="keyword">return</span> m_i;</span><br><span class="line">   <span class="number">20</span>     &#125;</span><br><span class="line">   <span class="number">21</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   33 </span>&#123;</span><br><span class="line">   <span class="number">34</span>         <span class="built_in">set</span> s;</span><br><span class="line">   <span class="number">35</span>         <span class="built_in">set</span> s2;</span><br><span class="line">&gt;&gt; <span class="number">36</span>         <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,s.add(<span class="number">2</span>));--输出<span class="number">0</span>,返回的是*<span class="keyword">this</span>，为s的值，m_e是其第一个成员</span><br><span class="line">&gt;&gt; <span class="number">37</span>         <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,s);－－输出<span class="number">0</span></span><br><span class="line">   <span class="number">38</span>         s2=s.add(<span class="number">2</span>);--s2被赋值了s，s此时的m_i=<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">   <span class="number">39</span>         s2.add(<span class="number">2</span>);--s2的m_i=<span class="number">6</span></span><br><span class="line">&gt;&gt; <span class="number">40</span>         <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s2);<span class="comment">//输出的是０－－－ m_e=0</span></span><br><span class="line">   <span class="number">41</span>         <span class="built_in">cout</span>&lt;&lt;s2.getval()&lt;&lt;<span class="built_in">endl</span>;-输出<span class="number">6</span>，因为</span><br><span class="line">   <span class="number">42</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">43</span> &#125;</span><br><span class="line"> 由此可以看出<span class="keyword">this</span>-&gt;object  <span class="keyword">this</span>-&gt;s</span><br><span class="line">            *<span class="keyword">this</span>==s</span><br><span class="line">            *<span class="keyword">this</span>==s的内容</span><br><span class="line">　　　　　　取对象的地址　&amp;s</span><br></pre></td></tr></table></figure></p>
<p>ref:<br><a href="http://zh.cppreference.com/w/cpp/language/this" target="_blank" rel="noopener">http://zh.cppreference.com/w/cpp/language/this</a><br><a href="http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/" target="_blank" rel="noopener">http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/</a></p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_static</title>
    <url>/2018/06/08/cpp-static/</url>
    <content><![CDATA[<h3 id="c-关键词之static"><a href="#c-关键词之static" class="headerlink" title="c++关键词之static"></a>c++关键词之static</h3><h5 id="something-share"><a href="#something-share" class="headerlink" title="something share:"></a>something share:</h5><p>其实，一开始学习c++的时候，并没有想去了解它的语法原理。虽然学c的时候，附带学了汇编，也学到了内存段，和学编译原理的时候顺带了解了它的相关词法语法处理。　　<br>现在开始从原因，历史，内存，汇编等角度去看cpp，觉得清晰了一些。虽然没有去学习g++或者其他编译器<a id="more"></a><br>如何处理c++的语法词法。这个想着以后如果有时间再研究吧。应该也是有工具去看，毕竟，g++是开源的，可以直接看源码如何处理C++</p>
<h4 id="static-overiew"><a href="#static-overiew" class="headerlink" title="static overiew"></a>static overiew</h4><ul>
<li>static在c的时候就有，因存储的地方不同于局部变量(in static mem ,not in stack)，使得在函数代码块结束后不会被销毁。从而能持续整个程序.</li>
<li>静态存储区(data)：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</li>
</ul>
<h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><p>１、static概念和用法<br>２、static内存存储和汇编<br>３、static和类相关内容与原理  </p>
<h4 id="static概念："><a href="#static概念：" class="headerlink" title="static概念："></a>static概念：</h4><p>　static为静态修饰符。编译器遇到这个修饰符时将对应的变量存储在静态存储区(data)  　</p>
<ul>
<li>根据类型：static可以修饰变量和函数，修饰对象和成员函数  </li>
<li>根据位置：静态局部变量和全局静态变量 -存于静态数据区(data)</li>
</ul>
<h5 id="c中的static"><a href="#c中的static" class="headerlink" title="c中的static:"></a>c中的static:</h5><ul>
<li>修饰变量：作用域是本程序文件，局部变量默认为auto,静态变量不管局部或者全局都存储于静态数据区，使得不会因为函数调用而销毁</li>
<li>修饰函数：只能用于本程序文件，普通函数默认为extern ,能被其他文件引用，static则不行</li>
</ul>
<p>“ 举个例子：<br>在stat.h中声明static int getstats()函数.<br>并在stat.c中实现它，static int getstats(){return xxx;}<br>在main中或者其他文件中使用这个函数<br>编译时报错未能找到该函数（未定义该函数)<br>c++中的static当和类无关时同c” </p>
<h4 id="static使用和内存与汇编："><a href="#static使用和内存与汇编：" class="headerlink" title="static使用和内存与汇编："></a>static使用和内存与汇编：</h4><h5 id="static全局变量"><a href="#static全局变量" class="headerlink" title="static全局变量"></a>static全局变量</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> global1=<span class="number">4</span>;</span><br><span class="line">   <span class="number">12</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   13 </span>&#123;</span><br><span class="line">&gt;&gt; <span class="number">14</span>         <span class="keyword">int</span> loc1=global1;</span><br><span class="line"></span><br><span class="line">_ZL7global1:</span><br><span class="line">	.<span class="keyword">long</span>	<span class="number">4</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line"></span><br><span class="line">	movl	_ZL7global1(%rip), %eax</span><br><span class="line">	movl	%eax, <span class="number">-4</span>(%rbp)</span><br><span class="line"><span class="comment">//且可以通过kdbg看到在执行期，</span></span><br><span class="line"><span class="keyword">static</span>变量的内存位置约为：</span><br><span class="line">(<span class="keyword">int</span> *) <span class="number">0x601048</span> &lt;global1&gt;　数据段地址</span><br><span class="line">局部变量的位置约为：</span><br><span class="line">(<span class="keyword">char</span> **) <span class="number">0x7ffff7a54530</span> &lt;loc1&gt;　栈地址</span><br></pre></td></tr></table></figure>
<h5 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   13 </span>&#123;</span><br><span class="line">   <span class="number">14</span>         <span class="keyword">static</span> <span class="keyword">int</span> locstatic1=<span class="number">5</span>;</span><br><span class="line">&gt;&gt; <span class="number">15</span>         <span class="keyword">int</span> loc1=global1;</span><br><span class="line">&gt;&gt; <span class="number">16</span>         <span class="keyword">int</span> loc2=locstatic1;</span><br><span class="line"></span><br><span class="line">	movl	_ZZ4mainE10locstatic1(%rip), %eax</span><br><span class="line">	movl	%eax, <span class="number">-4</span>(%rbp)</span><br><span class="line"></span><br><span class="line">_ZZ4mainE10locstatic1:</span><br><span class="line">	.<span class="keyword">long</span>	<span class="number">5</span></span><br><span class="line">执行期：</span><br><span class="line">　　loca1 　(<span class="keyword">int</span> *) <span class="number">0x7fffffffd8a8</span></span><br><span class="line">　　loca2 (<span class="keyword">int</span> *) <span class="number">0x7fffffffd8ac</span></span><br><span class="line"></span><br><span class="line">  global1 (<span class="keyword">int</span> *) <span class="number">0x601048</span> &lt;global1&gt;</span><br><span class="line">  locstatic:(<span class="keyword">int</span> *) <span class="number">0x60104c</span> &lt;main::locstatic1&gt;</span><br></pre></td></tr></table></figure>
<h5 id="static定义的变量和函数只能在本程序文件中使用"><a href="#static定义的变量和函数只能在本程序文件中使用" class="headerlink" title="static定义的变量和函数只能在本程序文件中使用"></a>static定义的变量和函数只能在本程序文件中使用</h5><p>要知道这个的原因可能有些复杂，一时半会也说不清，得先直到函数为什么能被外部引用：存在“符号表”中，能被外部链接，静态函数不在符号表中所以不行，类似这样吧，<br>这块不太清楚，感觉是这个原因</p>
<h5 id="static函数："><a href="#static函数：" class="headerlink" title="static函数："></a>static函数：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">getv</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    4 </span>&#123;</span><br><span class="line">    <span class="number">5</span>         <span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="number">6</span>         a++;</span><br><span class="line">    <span class="number">7</span>         <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="number">8</span>         <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="number">9</span> &#125; </span><br><span class="line"></span><br><span class="line">	.type	_ZL4getvv, @function</span><br><span class="line">_ZL4getvv:</span><br><span class="line">.LFB1021:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">	subq	$<span class="number">16</span>, %rsp</span><br><span class="line">　　　。。。。</span><br></pre></td></tr></table></figure>
<p>　    call    _ZL4getvv<br>从汇编代码看貌似跟普通函数没什么差别<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">运行时</span><br><span class="line">　　<span class="function"><span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">getv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="number">0x400816</span> push   %rbp</span><br><span class="line"><span class="number">0x400817</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x40081a</span> sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">		<span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line">		a++;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> global1=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">int</span> locstatic1=<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">int</span> loc1=global1;</span><br><span class="line">		<span class="keyword">int</span> loc2=locstatic1;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;getv()&lt;&lt;endl;</span></span><br><span class="line">    	getv();</span><br><span class="line"><span class="number">0x400866</span> callq  <span class="number">0x400816</span> &lt;getv()&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="static和类相关"><a href="#static和类相关" class="headerlink" title="static和类相关"></a>static和类相关</h4><h5 id="static成员变量的使用"><a href="#static成员变量的使用" class="headerlink" title="static成员变量的使用"></a>static成员变量的使用</h5><p> static成员变量是类的所有对象共有的，但是只有一份，通过类也可以访问到<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value; <span class="comment">// declares the static member variable</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Something::s_value = <span class="number">1</span>; <span class="comment">// defines the static member variable (we'll discuss this section below)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// note: we're not instantiating any objects of type Something</span></span><br><span class="line"> </span><br><span class="line">    Something::s_value = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Something::s_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_ZN9Something7s_valueE:</span><br><span class="line">	.<span class="keyword">long</span>	<span class="number">1</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line"></span><br><span class="line">　　</span><br><span class="line">  Something::s_value=<span class="number">3</span>;</span><br><span class="line"><span class="number">0x40081a</span> movl   $<span class="number">0x3</span>,<span class="number">0x20083c</span>(%rip)        # <span class="number">0x601060</span> &lt;Something::s_value&gt;</span><br><span class="line">（	movl	_ZN9Something7s_valueE(%rip), %eax</span><br><span class="line">	movl	%eax, %esi</span><br><span class="line">）</span><br><span class="line">可见类似于上述的，存在内存的数据段中</span><br></pre></td></tr></table></figure>
<h5 id="类静态变量作用域"><a href="#类静态变量作用域" class="headerlink" title="类静态变量作用域"></a>类静态变量作用域</h5><p>静态成员在多个文件中:<br>类中的机制，可以让定义在文件中的静态成员变量能被其他文件访问；加了作用域的声明，所以可以这样用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">在stati.h</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Some</span>&#123;</span></span><br><span class="line">  <span class="number">2</span>         <span class="keyword">public</span>:</span><br><span class="line">  <span class="number">3</span>                 <span class="keyword">static</span> <span class="keyword">int</span> s_v;</span><br><span class="line">  <span class="number">4</span> &#125;;</span><br><span class="line">  <span class="number">5</span> <span class="comment">//static int s_vv;//error 错误</span></span><br><span class="line"></span><br><span class="line">在stati.cpp</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stati.h"</span></span></span><br><span class="line">  <span class="number">2</span> <span class="keyword">int</span> Some::s_v=<span class="number">4</span>;</span><br><span class="line">  <span class="number">3</span> <span class="comment">//static int s_vv=5;error</span></span><br><span class="line"></span><br><span class="line">在main</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stati.h"</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> gets= Some::s_v;</span><br><span class="line"></span><br><span class="line">other:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Whatever</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> s_value = <span class="number">4</span>; <span class="comment">// a static const int can be declared and initialized directly</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="静态成员函数的使用"><a href="#静态成员函数的使用" class="headerlink" title="静态成员函数的使用"></a>静态成员函数的使用</h5><ul>
<li>考虑一个问题，当静态成员被申明为private时，则无法使用它directly by class。<br>but you can用非静态成员函数操作或者用静态成员函数操作to use it  </li>
<li>静态成员函数也是可以用类直接调用，它没有this指针，所以不能修改和访问对象的成员； </li>
<li>（非静态成员func,它可以定义在类的内部或者外部，外部不用加static,这点和static成员不同，成员得在外部初始化－－因为public等定义成员时，非const不能赋值，而<br>static不能修饰构造函数（对象相关），所以只能在外部初始化)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDGenerator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_nextID; <span class="comment">// Here's the declaration for a static member</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextID</span><span class="params">()</span></span>; <span class="comment">// Here's the declaration for a static function</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Here's the definition of the static member outside the class.  Note we don't use the static keyword here.</span></span><br><span class="line"><span class="comment">// We'll start generating IDs at 1</span></span><br><span class="line"><span class="keyword">int</span> IDGenerator::s_nextID = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Here's the definition of the static function outside of the class.  Note we don't use the static keyword here.</span></span><br><span class="line"><span class="keyword">int</span> IDGenerator::getNextID() &#123; <span class="keyword">return</span> s_nextID++; &#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">5</span>; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The next ID is: "</span> &lt;&lt; IDGenerator::getNextID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_const</title>
    <url>/2018/06/08/cpp-const/</url>
    <content><![CDATA[<h3 id="c-关键词之const"><a href="#c-关键词之const" class="headerlink" title="c++关键词之const"></a>c++关键词之const</h3><h4 id="const介绍，用法，原理，注意点等"><a href="#const介绍，用法，原理，注意点等" class="headerlink" title="const介绍，用法，原理，注意点等"></a>const介绍，用法，原理，注意点等</h4><h5 id="const-介绍："><a href="#const-介绍：" class="headerlink" title="const 介绍："></a>const 介绍：</h5><p>const是用于标示不可修改的变量，对象或函数的。<br>在其前面添加const就无法在之后做修改  </p>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法 "></a>用法 <a id="more"></a></h5><p>const总结起来有以下用法：</p>
<ul>
<li>const 修饰基本类型的变量  <ul>
<li>const int xx=4; const double xd=3.3;   </li>
<li>const int array[3]={3,4,5};</li>
<li>const　修饰指针和引用</li>
</ul>
</li>
<li>const 指针： <ul>
<li>const int *p=&value;<br>//无法改变指针指向的值，但是可以改变指针,<br>value可以是int value;/const int value;</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">          <span class="keyword">int</span> va=<span class="number">4</span>;</span><br><span class="line">    <span class="number">6</span>         <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;va ;</span><br><span class="line">    <span class="number">7</span>         va=<span class="number">5</span>;</span><br><span class="line">&gt;&gt;  <span class="number">8</span>         *p=<span class="number">6</span>;<span class="comment">//error</span></span><br><span class="line">    <span class="number">9</span>         <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//5</span></span><br><span class="line">   <span class="number">10</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>int *const p=&value; //无法改变指针的值，但是可以改变指针指向的值</li>
<li>const int *const p=&value;//指针的值和指针指向的值　都不可以改变<ul>
<li>const 引用：</li>
<li>const int &amp;ref=value;</li>
</ul>
</li>
</ul>
<h5 id="const-c-amp-cpp差异"><a href="#const-c-amp-cpp差异" class="headerlink" title="const  c&amp;cpp差异"></a>const  c&amp;cpp差异</h5><ul>
<li>不同于CPP，c将const存入的内存中设为只读，还是在栈中，而取其值时需要从内存中获取，所以从这个点看其效率比cpp差<br>why?see follow <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    c code:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cc=<span class="number">8</span>;</span><br><span class="line"><span class="number">0x4004da</span> movl   $<span class="number">0x8</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">		<span class="keyword">int</span> ccc=cc;</span><br><span class="line"><span class="number">0x4004e1</span> mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line"><span class="number">0x4004e4</span> mov    %eax,<span class="number">-0x4</span>(%rbp)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="const和类"><a href="#const和类" class="headerlink" title="const和类"></a>const和类</h5><ul>
<li><p>const 对象 const对象不能调用非const成员函数，也不能改变成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">constobj</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> ax;</span><br><span class="line">     <span class="keyword">int</span> bx;</span><br><span class="line">     constonj(<span class="keyword">int</span> a,<span class="keyword">int</span> b):ax(a),bx(b)&#123;&#125;;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">getax</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> ax;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">getbx</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bx;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setax</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;ax=a;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     constobj cobj;</span><br><span class="line">     <span class="keyword">const</span> constobj ccobj;</span><br><span class="line">     ccobj.setax(<span class="number">3</span>);<span class="comment">//error</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>const 成员函数（只有成员函数能被声明为const )，它不能改变成员</p>
</li>
<li>不能在const成员函数中修改成员变量，但是可以修改其他变量。</li>
<li>非const对象可以调用const成员函数</li>
<li>一个灵活使用const成员函数的例子：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Something(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;value=<span class="string">""</span>) &#123; m_value= value; &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125; <span class="comment">// getValue() for const objects</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125; <span class="comment">// getValue() for non-const objects</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Something something;</span><br><span class="line">	something.getValue() = <span class="string">"Hi"</span>; <span class="comment">// calls non-const getValue();</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">const</span> Something something2;</span><br><span class="line">	something2.getValue(); <span class="comment">// calls const getValue();</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="c-11中的添加的新内容"><a href="#c-11中的添加的新内容" class="headerlink" title="c++11中的添加的新内容"></a>c++11中的添加的新内容</h5><ul>
<li>constexp，cv限定  <h5 id="c-const内存和原理"><a href="#c-const内存和原理" class="headerlink" title="c++ const内存和原理"></a>c++ const内存和原理</h5></li>
<li>基本变量<br>const变量是在栈中分配内存的，但是仅限于定义的时候，之后其他地方使用这个const变量都直接是使用该值<br>从汇编中可以看到</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">    const int  co1=<span class="number">3</span>;</span><br><span class="line"><span class="number">0x4008ed</span> movl   $<span class="number">0x3</span>,<span class="number">-0x14</span>(%rbp)</span><br><span class="line">		 int  nor=co1;</span><br><span class="line"><span class="number">0x4008f4</span> movl   $<span class="number">0x3</span>,<span class="number">-0x10</span>(%rbp)</span><br></pre></td></tr></table></figure>
<p>所以无法当进行co1=4;的赋值操作时会被编译器拦截，想想，编译后会变成3=4;是不对的； </p>
<ul>
<li>这也解释了为什么一开始就要给const的变量赋值 *</li>
</ul>
<ul>
<li>数组:save in stack</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">3</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="number">0x4008fb</span> movl   $<span class="number">0x2</span>,<span class="number">-0x20</span>(%rbp)</span><br><span class="line"><span class="number">0x400902</span> movl   $<span class="number">0x3</span>,<span class="number">-0x1c</span>(%rbp)</span><br><span class="line"><span class="number">0x400909</span> movl   $<span class="number">0x5</span>,<span class="number">-0x18</span>(%rbp)</span><br></pre></td></tr></table></figure>
<ul>
<li>指针：<br>const指针结合，其并不像基本类型那样贴出值，而是每次还是得去内存中取值，它的限定改变值，由编译器控制报错  </li>
</ul>
<p>指针并不是像前面那样，如<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;value;</span><br><span class="line">    <span class="keyword">int</span> xx=*p;<span class="comment">//被替换成值?不是的，而是去内存中先取出指针的值，再以此为地址去取值；</span></span><br><span class="line">     <span class="keyword">int</span> pv=<span class="number">4</span>;</span><br><span class="line"><span class="number">0x400a12</span> movl   $<span class="number">0x4</span>,<span class="number">-0x58</span>(%rbp)</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;pv;</span><br><span class="line"><span class="number">0x400a19</span> lea    <span class="number">-0x58</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a1d</span> mov    %rax,<span class="number">-0x40</span>(%rbp)</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">int</span> px=*p;</span><br><span class="line"><span class="number">0x400a69</span> mov    <span class="number">-0x40</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a6d</span> mov    (%rax),%eax</span><br><span class="line"><span class="number">0x400a6f</span> mov    %eax,<span class="number">-0x48</span>(%rbp)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">　　　   <span class="keyword">int</span> pv=<span class="number">4</span>;</span><br><span class="line"><span class="number">0x400a12</span> movl   $<span class="number">0x4</span>,<span class="number">-0x70</span>(%rbp)<span class="comment">//put 4 in mem(statck)</span></span><br><span class="line">		 <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;pv;</span><br><span class="line"><span class="number">0x400a19</span> lea    <span class="number">-0x70</span>(%rbp),%rax<span class="comment">//get its addr</span></span><br><span class="line"><span class="number">0x400a1d</span> mov    %rax,<span class="number">-0x58</span>(%rbp)<span class="comment">//addr to p</span></span><br><span class="line">         <span class="keyword">int</span> *<span class="keyword">const</span> pp=&amp;pv; </span><br><span class="line"><span class="number">0x400a21</span> lea    <span class="number">-0x70</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a25</span> mov    %rax,<span class="number">-0x50</span>(%rbp)<span class="comment">//adddr to pp</span></span><br><span class="line">         <span class="keyword">int</span>  *ppp=pp;</span><br><span class="line"><span class="number">0x400a29</span> mov    <span class="number">-0x50</span>(%rbp),%rax<span class="comment">//get pp num</span></span><br><span class="line"><span class="number">0x400a2d</span> mov    %rax,<span class="number">-0x48</span>(%rbp)<span class="comment">//to ppp</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>引用：<br>引用同指针，是会去内存中取值的,same to pointer</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">follow above</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref=pv;</span><br><span class="line"><span class="number">0x400aba</span> lea    <span class="number">-0x7c</span>(%rbp),%rax<span class="comment">//get pv</span></span><br><span class="line"><span class="number">0x400abe</span> mov    %rax,<span class="number">-0x38</span>(%rbp)<span class="comment">//to ref</span></span><br><span class="line">		 <span class="keyword">int</span> cs=ref;</span><br><span class="line"><span class="number">0x400ac2</span> mov    <span class="number">-0x38</span>(%rbp),%rax<span class="comment">//get ref</span></span><br><span class="line"><span class="number">0x400ac6</span> mov    (%rax),%eax<span class="comment">//get *ref</span></span><br><span class="line"><span class="number">0x400ac8</span> mov    %eax,<span class="number">-0x64</span>(%rbp)<span class="comment">//to cs</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>const类对象：  </p>
<ul>
<li>const对象为什么不能更改成员：<br>成员是存在对象中的，如int,char等成员，存在栈中<br>const对象的成员也是放在栈中的，它们之所以不能赋值，是在编译期间确定，更具体的细节未知；  　</li>
</ul>
</li>
<li>const对象为什么不能调用非const成员函数：<ul>
<li>一个成员函数如何被调用：   　　</li>
<li>其实成员函数也是全局函数，所以它能被调用，<br>　eg:    <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  obj.show();---&gt;实际上被转换为：</span><br><span class="line">  show(&amp;obj)  --传递给<span class="keyword">this</span>指针：</span><br><span class="line"> 所以当：<span class="function"><span class="keyword">const</span> OB <span class="title">obj</span><span class="params">()</span></span>;</span><br><span class="line">obj.show();时，翻译为　<span class="keyword">const</span> OB *<span class="keyword">this</span>;</span><br><span class="line">在传递给OB *<span class="keyword">this</span>时会出现不能将<span class="keyword">this</span>指针</span><br><span class="line">从<span class="keyword">const</span> OB转换为OB &amp;的错误</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>可以做个实验试试</p>
<ul>
<li><p>conclude:<br>if it can use non const func ,it will change member by non const this pointer;</p>
</li>
<li><p>为什么可以调用const函数：<br>const函数：void show() const转换为：show(const OB *this);所以匹配上了，就可以调用了</p>
</li>
</ul>
<p>注意：有最小权限原则，非const对象可以调用const成员函数，就像可以赋值一样。非const变量可以用const赋值</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_linklist3</title>
    <url>/2018/06/07/leetcode-linklist3/</url>
    <content><![CDATA[<h3 id="leetcode-linklist3"><a href="#leetcode-linklist3" class="headerlink" title="leetcode_linklist3"></a>leetcode_linklist3</h3><p>continue..</p>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.<br><a id="more"></a><br>Example 1:</p>
<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
<p>Example 2:</p>
<p>Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>Output: 2-&gt;0-&gt;1-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL<br>rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL<br>rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>/**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li>int val;</li>
<li>struct ListNode *next;</li>
<li>};<br>*/</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">rotateRight</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">headnode</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    headnode-&gt;next=head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">sumhead</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">//compute len of list</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sumhead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        sumhead=sumhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    sum++;</span><br><span class="line">    <span class="comment">//compare k and len,or just compute the rota num</span></span><br><span class="line">    <span class="keyword">int</span> num=k%sum;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dealheadf</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;sum-num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dealheadf=dealheadf-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sumhead-&gt;next=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=dealheadf-&gt;next;</span><br><span class="line">    dealheadf-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">    head=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headnode);</span><br><span class="line">    <span class="keyword">return</span>  head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移除倒数第n个元素"><a href="#移除倒数第n个元素" class="headerlink" title="移除倒数第n个元素"></a>移除倒数第n个元素</h4><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>
<p>Example:</p>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p>
<p>Note:</p>
<p>Given n will always be valid.</p>
<p>Follow up:</p>
<p>Could you do this in one pass?</p>
<p>/**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li>int val;</li>
<li>struct ListNode *next;</li>
<li>};<br>*/</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="comment">//这个几乎没道题都要注意</span></span><br><span class="line">         <span class="keyword">return</span> head;</span><br><span class="line">     <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>&amp;&amp;n&gt;=<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">sumhead</span>=<span class="title">head</span>;</span></span><br><span class="line">     <span class="keyword">while</span>(sumhead!=<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         sum++;</span><br><span class="line">         sumhead=sumhead-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> remove=sum-n;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">removenode</span>=<span class="title">head</span>;</span></span><br><span class="line">     <span class="keyword">while</span>(remove&gt;<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         removenode=removenode-&gt;next;</span><br><span class="line">         remove--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">rmnode</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(remove==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">rmnode</span>;</span></span><br><span class="line">     rmnode=removenode-&gt;next;</span><br><span class="line">     removenode-&gt;next=removenode-&gt;next-&gt;next;</span><br><span class="line">     rmnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">     <span class="built_in">free</span>(rmnode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//删除头</span></span><br><span class="line">    &#123;</span><br><span class="line">        rmnode=removenode;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">        rmnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(rmnode);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//一开始未考虑到删除头的情况，所以加了else 部分</p>
<h4 id="交换元素"><a href="#交换元素" class="headerlink" title="交换元素"></a>交换元素</h4><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>Example:</p>
<p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Note:</p>
<pre><code>Your algorithm should use only constant extra space.
You may not modify the values in the list&apos;s nodes, only nodes itself may be changed.
</code></pre><p>/**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li>int val;</li>
<li>struct ListNode *next;</li>
<li>};<br>*/</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">swapPairs</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">headNode</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">second</span>=<span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">first</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">curhead</span>=<span class="title">headNode</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="literal">NULL</span>)<span class="keyword">break</span>;</span><br><span class="line">        second=first-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(second!=<span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          first-&gt;next=second-&gt;next==<span class="literal">NULL</span>?<span class="literal">NULL</span>:second-&gt;next;</span><br><span class="line">          second-&gt;next=first;</span><br><span class="line">          curhead-&gt;next=second;</span><br><span class="line">          curhead=first;</span><br><span class="line">          first=first-&gt;next==<span class="literal">NULL</span>?<span class="literal">NULL</span>:first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head=headNode-&gt;next;</span><br><span class="line">    headNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headNode);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="k组反转"><a href="#k组反转" class="headerlink" title="k组反转"></a>k组反转</h4><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>Example:</p>
<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>Note:</p>
<pre><code>Only constant extra memory is allowed.
You may not alter the values in the list&apos;s nodes, only nodes itself may be changed.
</code></pre><p>/**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li>int val;</li>
<li>struct ListNode *next;</li>
<li>};<br><em>/<br>/</em><br>这道题目原想在遍历一次就解决，可是还是想不出好的方法，得遍历两次，一次计算长度，一次正真的处理；<br>在处理的过程使用头插法。注意边界条件，但因为有数量控制好些*/<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseKGroup</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">headnode</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    headnode-&gt;next=head;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">lenhead</span>=<span class="title">head</span>,*<span class="title">curhead</span>=<span class="title">headnode</span>,*<span class="title">cur</span>=<span class="title">head</span>,*<span class="title">tmp</span>=<span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(lenhead!=<span class="literal">NULL</span>)<span class="comment">//计算长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        lenhead=lenhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numofreverse=len/k;<span class="comment">//要reverse几次</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=numofreverse;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j=k;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">1</span>)<span class="comment">//每一次reverse k次，头插法</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp=curhead-&gt;next;</span><br><span class="line">            curhead-&gt;next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            curhead-&gt;next-&gt;next=tmp;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        curhead=cur;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    head=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headnode);</span><br><span class="line">    <span class="keyword">return</span> head;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>后面还有几道题，不贴了，这里简述下：  </p>
<ul>
<li>检查是否链表中存在循环</li>
<li>检查链表中是否存在循环并找到循环的起点</li>
<li>深度复制链表，链表中的每个节点存在一个指向任意节点的指针</li>
<li>设计一个LRU cache,即（最近使用的）</li>
<li><p>。。。。。</p>
</li>
<li><p>链表的套路：</p>
<ul>
<li>常使用头插法进行反转操作</li>
<li>使用两个指针解决循环问题，指针相遇测试是否存在循环，指针遍历减少时间</li>
<li>使用哈希，以空间换时间</li>
<li>加头节点，简化逻辑</li>
</ul>
</li>
<li>使用链表注意<ul>
<li>检查空和是否只有一个节点</li>
<li>释放空间，和放置取空指针，可以通过次数控制和判空</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_linklist2</title>
    <url>/2018/06/03/leetcode-linklist2/</url>
    <content><![CDATA[<h3 id="leetcode——单链表2"><a href="#leetcode——单链表2" class="headerlink" title="leetcode——单链表2"></a>leetcode——单链表2</h3><h4 id="partition-list"><a href="#partition-list" class="headerlink" title="partition list"></a>partition list</h4><p>这个是快速排序中一个很重要的步骤，即比该数大于等于的放其前小的放后。在链表中，基本思路:扫描链表，比给定数字小的不处理，比给定数字大的取下并插入到末尾 <a id="more"></a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">You should preserve the original relative order of the nodes in each of the two partitions.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">partition</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next ==<span class="literal">NULL</span>)</span><br><span class="line">              <span class="keyword">return</span> head;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span>  <span class="title">ListNode</span>));</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;next=head;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">head1</span>=<span class="title">list</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">cur</span> = <span class="title">head1</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">tail</span>=<span class="title">head1</span>;</span></span><br><span class="line">		<span class="keyword">int</span> lenoflist1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(tail-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">				tail=tail-&gt;next;</span><br><span class="line">				lenoflist1++;</span><br><span class="line">		&#125;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tmp</span>=<span class="title">tail</span>;</span></span><br><span class="line">		<span class="keyword">while</span>(lenoflist1&gt;=<span class="number">1</span>)</span><br><span class="line">		&#123; </span><br><span class="line">            lenoflist1--;</span><br><span class="line">            <span class="keyword">if</span>(tail==cur)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span>(cur-&gt;val&gt;=x)</span><br><span class="line">		  &#123;</span><br><span class="line">				  head1-&gt;next=cur-&gt;next;</span><br><span class="line">				  cur-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		          tail-&gt;next=cur;</span><br><span class="line">				  tail=tail-&gt;next;<span class="comment">//not consid at first</span></span><br><span class="line">				  cur=head1-&gt;next;</span><br><span class="line"></span><br><span class="line">		  &#125; </span><br><span class="line">		  <span class="keyword">else</span>&#123;</span><br><span class="line">				  head1=head1-&gt;next;</span><br><span class="line">				  cur=cur-&gt;next;</span><br><span class="line">		  &#125;</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">//  printf("%d : ",cur-&gt;num);</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//if(head1-&gt;next==NULL)head1-&gt;next=tmp;</span></span><br><span class="line">         head=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">   <span class="built_in">list</span>-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//此题目最终被accepted<br>//应该在函数中添加头节点而不是依靠传入的链表带头节点,一开始没有考虑到传入的链表不带链表头。。，没有考虑到一个元素的情况，这个方案最终accept</p>
<h4 id="链表中的子链表反转，考察头插法"><a href="#链表中的子链表反转，考察头插法" class="headerlink" title="链表中的子链表反转，考察头插法"></a>链表中的子链表反转，考察头插法</h4><ul>
<li>头插法在链表的反转，倒序，常被用到  </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* reverse a linklist from m to n</span></span><br><span class="line"><span class="comment"> * 1-&gt;2-&gt;4-&gt;5-&gt;null and m,n(ex:2,4)</span></span><br><span class="line"><span class="comment"> * return 1-&gt;5-&gt;4-&gt;2-&gt;null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span>  *<span class="title">next</span>;</span></span><br><span class="line">&#125;Linklist;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverselinklist</span><span class="params">(Linklist *list1,<span class="keyword">int</span> m,<span class="keyword">int</span> n,Linklist **result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(list1==<span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		Linklist *head1,*head2,*cur,*tmp,*pre;</span><br><span class="line">		cur=list1;</span><br><span class="line">		head1=cur;</span><br><span class="line">		pre=head1;</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">				cur=cur-&gt;next;</span><br><span class="line">				<span class="keyword">for</span>(i=m;i&lt;n;i++)</span><br><span class="line">				&#123;</span><br><span class="line">				  pre-&gt;next=cur-&gt;next;</span><br><span class="line">				  cur-&gt;next=head1;</span><br><span class="line">				  head1=cur;</span><br><span class="line">				  cur=pre-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			    *result=head1;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)<span class="comment">//node1-&gt;node2-&gt;node3---1-&gt;2-&gt;3--ex:m=2,list1-&gt;1</span></span><br><span class="line">		&#123;</span><br><span class="line">		  head1=cur;</span><br><span class="line">          cur=cur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		head2=cur;</span><br><span class="line">		cur=cur-&gt;next;</span><br><span class="line">		pre=head2;</span><br><span class="line">		<span class="keyword">for</span>(i=m;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">		   pre-&gt;next=cur-&gt;next;</span><br><span class="line">		   cur-&gt;next=head1-&gt;next;</span><br><span class="line">		   head1-&gt;next=cur;</span><br><span class="line">		   cur=pre-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		Linklist *list1=(Linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">		Linklist *result11=list1;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		list1-&gt;num=<span class="number">4</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"4 "</span>);</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">9</span>;i++)</span><br><span class="line">	  &#123;</span><br><span class="line">						     </span><br><span class="line">			list1-&gt;next = (Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">			list1 = list1-&gt;next;</span><br><span class="line">		    list1-&gt;num = i*<span class="number">2</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,i*<span class="number">2</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	   Linklist *rr=(Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">	   Linklist **resull=&amp;rr;</span><br><span class="line">	   <span class="keyword">int</span> rere=reverselinklist(result11,<span class="number">1</span>,<span class="number">9</span>,resull);</span><br><span class="line">	   <span class="keyword">if</span>(rere==<span class="number">3</span>) &#123;</span><br><span class="line">	    <span class="keyword">for</span>(i=<span class="number">0</span>;result11!=<span class="literal">NULL</span> ;i++,result11=result11-&gt;next)</span><br><span class="line">				       <span class="built_in">printf</span>(<span class="string">"%d "</span>,result11-&gt;num); </span><br><span class="line">	  	<span class="built_in">free</span>(list1);</span><br><span class="line">	   &#125;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	  &#123; </span><br><span class="line">	    <span class="keyword">for</span>(i=<span class="number">0</span>;*resull!=<span class="literal">NULL</span> ;i++,*resull= (*resull)-&gt;next)</span><br><span class="line">				       <span class="built_in">printf</span>(<span class="string">"%d "</span>,(*resull)-&gt;num); </span><br><span class="line">	  	<span class="built_in">free</span>(*resull);</span><br><span class="line">	  &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//此解法未经过leetcode检验，不过应该问题不大</p>
<h4 id="有序链表移除重复元素"><a href="#有序链表移除重复元素" class="headerlink" title="有序链表移除重复元素"></a>有序链表移除重复元素</h4><ul>
<li>考察的是遍历链表删除链表中的元素，注意边缘条件控制如头部和尾部</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Given a sorted linked list, delete all duplicates such that each element appear only once.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1-&gt;1-&gt;2</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">first</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">second</span>=<span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span>=<span class="title">second</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(second!=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        tmp=second;</span><br><span class="line">        <span class="keyword">if</span>(first-&gt;val==second-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            first-&gt;next=second;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(first-&gt;val==tmp-&gt;val)</span><br><span class="line">        first-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//此方案最后被accepted</p>
<h4 id="删除有序链表中的有重复的node"><a href="#删除有序链表中的有重复的node" class="headerlink" title="删除有序链表中的有重复的node"></a>删除有序链表中的有重复的node</h4><ul>
<li>和上一道题目类似:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Given a sorted linked list, delete all duplicates such that each element appear only once.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1-&gt;1-&gt;2</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">headnode</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    headnode-&gt;next=head;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">first</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">second</span>=<span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> numsame=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmphead</span>=<span class="title">headnode</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(second!=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(first-&gt;val==second-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">               numsame++;</span><br><span class="line">               first=first-&gt;next;</span><br><span class="line">               second=second-&gt;next;</span><br><span class="line">               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(first-&gt;val !=second-&gt;val &amp;&amp; numsame==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmphead-&gt;next=first;</span><br><span class="line">            tmphead=tmphead-&gt;next;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">            numsame=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numsame==<span class="number">0</span>)tmphead-&gt;next=first;</span><br><span class="line">    <span class="keyword">else</span> tmphead-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">    head=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headnode);   </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list1</span>=(<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span>=<span class="title">list1</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">freelist1</span>=<span class="title">list1</span>;</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">		 list1-&gt;val=<span class="number">20</span>-i;</span><br><span class="line">		 list1-&gt;next=(struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">		 list1=list1-&gt;next;</span><br><span class="line">		 <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="number">20</span>-i);</span><br><span class="line">   &#125;</span><br><span class="line">   list1-&gt;val=<span class="number">12</span>;</span><br><span class="line">   tmp=deleteDuplicates(tmp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;tmp!=<span class="literal">NULL</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">		   <span class="built_in">printf</span>(<span class="string">"%d  "</span>,tmp-&gt;val);</span><br><span class="line">		   tmp=tmp-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">free</span>(freelist1);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这道题做的比较顺利，一次提交就=通过了</span><br><span class="line">注意：加头节点，由于解题的思路是两个指针的遍历，在第二个指针为空时停止，就会有尾巴为几种情况时的处理：如当尾巴为：<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span> 这两种情况时，去掉尾巴，否则<span class="number">4</span>,<span class="number">5</span>,<span class="number">6.4</span>,<span class="number">4</span>,<span class="number">5</span>时尾巴保留；见代码</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_linklist1</title>
    <url>/2018/06/03/leetcode-linklist1/</url>
    <content><![CDATA[<h3 id="leetcode——单链表"><a href="#leetcode——单链表" class="headerlink" title="leetcode——单链表"></a>leetcode——单链表</h3><h4 id="两数相加："><a href="#两数相加：" class="headerlink" title="两数相加："></a>两数相加：</h4><ul>
<li>这道题是经一年多没刷题目之后，重新开始的第一道题，本来想着只是本地刷刷，后面开始就到leetcode提交了，毕竟写的程序还是得经过检验</li>
<li>所以这道题就纯粹的解答，未经检验，只是本地跑通，并且加上了自己的一些看法，比如对该题目该思路可能可以应用在哪些地方，这样算法才有了真正的意义，个人十分不赞同一些在公司呆久了的人说数据结构算法没什么用的人2333</li>
<li>废话不多说：  好久没写，第一道就别吐槽了，慢慢来</li>
<li>题目描述：  <a id="more"></a><br>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>Example<br>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.<br>注意两个数字位数可能不同，所以需要一些特殊情况要处理<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">		<span class="keyword">int</span> num;</span><br><span class="line">&#125; *linklist,listnode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是自己加的扩展，把输入的两个大数字符串转换为链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">changtolist</span><span class="params">(struct ListNode *list1,<span class="keyword">char</span> num1[],struct ListNode *list2,<span class="keyword">char</span>  num2[])</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//应该在接口内计算长度好些</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> lennum1=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(num1[lennum1]!=<span class="string">'\0'</span>)&#123;lennum1++;&#125;</span><br><span class="line">   <span class="keyword">int</span> lennum2=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(num2[lennum2]!=<span class="string">'\0'</span>)&#123;lennum2++;&#125;</span><br><span class="line"><span class="comment">//分配空间加字母转数字，无头节点</span></span><br><span class="line">   list1-&gt;num=num1[lennum1<span class="number">-1</span>]<span class="number">-48</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=lennum1<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">   &#123;</span><br><span class="line">		list1-&gt;next=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">		list1=list1-&gt;next;</span><br><span class="line">        list1-&gt;num=num1[i]<span class="number">-48</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   list1-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   list2-&gt;num=num2[lennum2<span class="number">-1</span>]<span class="number">-48</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=lennum2<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">   &#123;</span><br><span class="line">		list2-&gt;next=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">		list2=list2-&gt;next;</span><br><span class="line">		list2-&gt;num=num2[i]<span class="number">-48</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   list2-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个大数相加，不用头节点的方式，麻烦一些</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add_two_num</span><span class="params">(struct ListNode *list1,struct ListNode *list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">int</span> adding = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(list1 == <span class="literal">NULL</span> || list2 == <span class="literal">NULL</span>)</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/*	 while(list1!=NULL &amp;&amp; list2!=NULL)</span></span><br><span class="line"><span class="comment">	 &#123;</span></span><br><span class="line"><span class="comment">			 list1-&gt;num = (list1-&gt;num+list2-&gt;num+adding)%10;</span></span><br><span class="line"><span class="comment">             adding = (list1-&gt;num + list2-&gt;num+adding)/10;</span></span><br><span class="line"><span class="comment">			 list1 = list1-&gt;next;</span></span><br><span class="line"><span class="comment">			 list2 = list2-&gt;next;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	 if(list1==NULL &amp;&amp; list2!=NULL)</span></span><br><span class="line"><span class="comment">	*/</span>		 </span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">xx</span>=<span class="title">list1</span>;</span></span><br><span class="line">      <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	  sum = list1-&gt;num+list2-&gt;num+adding;</span><br><span class="line">	  list1-&gt;num = sum%<span class="number">10</span>;</span><br><span class="line">      adding = sum/<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;<span class="comment">//常规情况，两个同长度部分</span></span><br><span class="line">			 list1 = list1-&gt;next;</span><br><span class="line">			 list2 = list2-&gt;next;</span><br><span class="line">			 sum= list1-&gt;num+list2-&gt;num+adding;</span><br><span class="line">			 list1-&gt;num = sum %<span class="number">10</span>;</span><br><span class="line">			<span class="comment">// printf("%d ",list1-&gt;num);</span></span><br><span class="line">             adding = sum/<span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(list1-&gt;next!=<span class="literal">NULL</span> &amp;&amp; list2-&gt;next!=<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(list1-&gt;next ==<span class="literal">NULL</span>&amp;&amp; list2-&gt;next==<span class="literal">NULL</span> &amp;&amp;adding!=<span class="number">0</span>)<span class="comment">//串1短于串2</span></span><br><span class="line">	&#123;</span><br><span class="line">			list1-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">			list1-&gt;next-&gt;num= adding;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"show:%d\n"</span>,adding);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(list1-&gt;next==<span class="literal">NULL</span> &amp;&amp; list2-&gt;next !=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">			list1-&gt;next = list2-&gt;next;</span><br><span class="line">			<span class="keyword">while</span>(list2-&gt;next!=<span class="literal">NULL</span>&amp;&amp;adding !=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">              list2=list2-&gt;next;</span><br><span class="line">			  sum= list2-&gt;num+adding;</span><br><span class="line">              list2-&gt;num=sum%<span class="number">10</span>;</span><br><span class="line">			  adding = sum/<span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(adding&gt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">					list2-&gt;next=(struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">		            list2-&gt;next-&gt;num=adding;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">    ...<span class="comment">//串1长于 串2</span></span><br><span class="line">    .....</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要思考，当进位到最后时，可能1,2都结束了，但是产生高位，此时要new　listnode 完成</span></span><br><span class="line"><span class="comment">//或者剩下２，和进位，则考虑２加进位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list1</span>,*<span class="title">list2</span>;</span></span><br><span class="line">  list1 = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">  list2 = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">  list1-&gt;num=<span class="number">3</span>;</span><br><span class="line">  list2-&gt;num=<span class="number">5</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmplist1</span>=<span class="title">list1</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmplist2</span>=<span class="title">list2</span>;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">9</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">	list1-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">	list2-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">	list1 = list1-&gt;next;</span><br><span class="line">	list2 = list2-&gt;next;</span><br><span class="line">    list1-&gt;num = <span class="number">2</span>;</span><br><span class="line">	list2-&gt;num= <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  list2-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">  list2-&gt;next-&gt;num=<span class="number">9</span>; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">result</span>=<span class="title">tmplist1</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">freelist1</span> = <span class="title">tmplist1</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">freelist2</span> = <span class="title">tmplist2</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++,tmplist1=tmplist1-&gt;next)</span><br><span class="line">		  <span class="built_in">printf</span>(<span class="string">"%d "</span>,tmplist1-&gt;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++,tmplist2=tmplist2-&gt;next)</span><br><span class="line">		  <span class="built_in">printf</span>(<span class="string">"%d "</span>,tmplist2-&gt;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  Add_two_num(freelist1,freelist2);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;result!=<span class="literal">NULL</span> ;i++,result=result-&gt;next)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d "</span>,result-&gt;num); </span><br><span class="line">  <span class="built_in">free</span>(freelist1);</span><br><span class="line">  <span class="built_in">free</span>(freelist2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list11</span>,*<span class="title">list22</span>;</span></span><br><span class="line">  list11 = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">  list22 = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> num1[<span class="number">100</span>],num2[<span class="number">100</span>];</span><br><span class="line">  gets(num1);</span><br><span class="line">  gets(num2);</span><br><span class="line">  changtolist(list11,num1,list22,num2);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">result11</span> = <span class="title">list11</span>;</span></span><br><span class="line">  Add_two_num(list11,list22);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;result11!=<span class="literal">NULL</span> ;i++,result11=result11-&gt;next)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d "</span>,result11-&gt;num); </span><br><span class="line">  <span class="built_in">free</span>(list11);</span><br><span class="line">  <span class="built_in">free</span>(list22);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//思考，扩大这道题的应用，在大数相加的时候，增加用户输入接口:”<br>//5263565656554+5656537677834546<br>//由char读入，int/char相加，<br>——-极其丑的程序，以后不能这么搞，留个纪念<br>想贴下两年多前（大三吧，那会刷这道题通过的程序–看来最喜欢的还是c）<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	 <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">		 ListNode *sum, *l4;</span><br><span class="line">		 sum = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//新节点</span></span><br><span class="line">		 l4 = sum;</span><br><span class="line">		 <span class="keyword">int</span> sum_single, en = <span class="number">0</span>;<span class="comment">//en表示进位的标志</span></span><br><span class="line">		 <span class="keyword">while</span> (l1 != <span class="literal">NULL</span>&amp;&amp;l2 != <span class="literal">NULL</span>)</span><br><span class="line">		 &#123;</span><br><span class="line">			 </span><br><span class="line">				 sum-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//这里有个问题变为sum=NULL就行</span></span><br><span class="line">				 sum = sum-&gt;next;</span><br><span class="line">			<span class="comment">// signal = 0;</span></span><br><span class="line">			 sum_single = l1-&gt;val + l2-&gt;val + en;</span><br><span class="line">			 <span class="keyword">if</span> (sum_single&lt;<span class="number">10</span>)</span><br><span class="line">			 &#123;</span><br><span class="line">				 sum-&gt;val = sum_single;</span><br><span class="line">				 en = <span class="number">0</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">else</span> <span class="keyword">if</span> (sum_single &gt;= <span class="number">10</span>)</span><br><span class="line">			 &#123;</span><br><span class="line">				 sum-&gt;val = sum_single - <span class="number">10</span>;</span><br><span class="line">				 en = <span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 l1 = l1-&gt;next;</span><br><span class="line">			 l2 = l2-&gt;next;</span><br><span class="line">		</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">while</span> (l1 != <span class="literal">NULL</span>&amp;&amp;l2 == <span class="literal">NULL</span>)</span><br><span class="line">		 &#123; </span><br><span class="line">			 sum-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">			 sum = sum-&gt;next;</span><br><span class="line">			 sum_single = en + l1-&gt;val;</span><br><span class="line">			 <span class="keyword">if</span> (sum_single &gt;= <span class="number">10</span>)</span><br><span class="line">			 &#123;</span><br><span class="line">				 sum-&gt;val = sum_single - <span class="number">10</span>;</span><br><span class="line">				 en = <span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">else</span></span><br><span class="line">			 &#123;</span><br><span class="line">				 sum-&gt;val = sum_single;</span><br><span class="line">				 en = <span class="number">0</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 l1 = l1-&gt;next;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">while</span> (l2 != <span class="literal">NULL</span>&amp;&amp;l1 == <span class="literal">NULL</span>)</span><br><span class="line">		 &#123; </span><br><span class="line">			 sum-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">			 sum = sum-&gt;next;</span><br><span class="line">			 sum_single = en + l2-&gt;val;</span><br><span class="line">			 <span class="keyword">if</span> (sum_single &gt;= <span class="number">10</span>)</span><br><span class="line">			 &#123;</span><br><span class="line">				 sum-&gt;val = sum_single - <span class="number">10</span>;</span><br><span class="line">				 en = <span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">else</span></span><br><span class="line">			 &#123;</span><br><span class="line">				 sum-&gt;val = sum_single;</span><br><span class="line">				 en = <span class="number">0</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 l2 = l2-&gt;next;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>&amp;&amp;l2 == <span class="literal">NULL</span>&amp;&amp;en == <span class="number">1</span>)</span><br><span class="line">			 sum-&gt;next = <span class="keyword">new</span> ListNode(en);</span><br><span class="line">		<span class="comment">//if(l1==NULL&amp;&amp;l2==NULL&amp;&amp;en==0)sum = NULL;</span></span><br><span class="line">	<span class="comment">/*	 while (l3)</span></span><br><span class="line"><span class="comment">		 &#123;</span></span><br><span class="line"><span class="comment">			 cout &lt;&lt; l3-&gt;val;</span></span><br><span class="line"><span class="comment">			 l3 = l3-&gt;next;</span></span><br><span class="line"><span class="comment">		 &#125;*/</span></span><br><span class="line">		 <span class="keyword">return</span> l4-&gt;next;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Solution sou;</span></span><br><span class="line"><span class="comment">    ListNode *l1,*l2,*l3;</span></span><br><span class="line"><span class="comment">    l1=new ListNode(3);</span></span><br><span class="line"><span class="comment">    l1-&gt;next=new ListNode(7);</span></span><br><span class="line"><span class="comment">    l1-&gt;next-&gt;next=new ListNode(5);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     l2=new ListNode(7);</span></span><br><span class="line"><span class="comment">    l2-&gt;next=new ListNode(7);</span></span><br><span class="line"><span class="comment">    l2-&gt;next-&gt;next=new ListNode(5);</span></span><br><span class="line"><span class="comment">    l3=sou.addTwoNumbers(l1,l2);</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;l3-&gt;val&lt;&lt;l3-&gt;next-&gt;val&lt;&lt;l3-&gt;next-&gt;next-&gt;val;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_IP</title>
    <url>/2018/06/03/tcpip-IP/</url>
    <content><![CDATA[<h3 id="IP-协议和路由"><a href="#IP-协议和路由" class="headerlink" title="IP 协议和路由"></a>IP 协议和路由</h3><h4 id="IP的作用–路由"><a href="#IP的作用–路由" class="headerlink" title="IP的作用–路由"></a>IP的作用–路由</h4><h5 id="路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作"><a href="#路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作" class="headerlink" title="路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?"></a>路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?</h5><ol>
<li><p>从广义上讲，路由是路线图，就像百度地图上源地址到目的地址的路线，路线有很多，故路由也很多；  <a id="more"></a><br>从网络层面讲，路由是一个数据包从源地址到目的地的传输路径，它如何被决定怎么走，即中间经过哪些路由器，选择哪一条路线等等。</p>
</li>
<li><p>一个数据包在网络上传输实例：<br>A,B连上AP进行上网，AP和外网连接，AP的下一站是D;<br>A 在构造了数据包后选择发送，要查询路由表，若该数据包发送给B,则通过路由表中的直连路由，找到B的ip,发送时不知道B的mac地址，故先做arp,得到后将数据包发给B:<br>数据包：源ip：A,源mac A ，目的IP:B,目的mac:B<br>若A在构造了数据包后，查询路由，该数据包是发送给外网，目的地址是百度ip,则无此条目，向默认路由；即发给路由器，此时若不知道mac地址会做arp;<br>数据包：源ip:A,源mac：A  ,目的ip:百度，目的mac：路由器(arp代理）<br>数据包到路由器后，将做下一步转发：<br>在路由发送的数据包：源ip:路由外网地址，源mac:路由，目的ip:百度ip.目的mac,D<br>(注意，在源ip改为路由外网地址后，此时ip唯一，源地址在传输过程中不会再改变）  </p>
</li>
<li><p>内网的路由器会将源地址改为路由器的外网地址<br>—想想像192.168.0.4这样的源地址是内网地址，如果在包的传输过程中不做处理，到达目的地如QQ的服务器，那QQ处理完要发给你，这时得到包是从192.168.0.4来的，它作为内网地址，全世界很多个，怎么决定—–所以ip首部中的源地址和目的地址必须是全球唯一的ip地址，即外网地址；</p>
</li>
<li>路由器会对ttl做减1,然后再重新做校验和–即直接加1</li>
<li>路由器会将数据包的mac首部，源地址改为路由的mac地址，目的地址改为默认路由（或其他导向路由）ip对应的mac地址</li>
</ol>
<h4 id="网络地址和子网"><a href="#网络地址和子网" class="headerlink" title="网络地址和子网"></a>网络地址和子网</h4><p>这里不记录太多的ip地址相关的内容，毕竟比较基础，且协议卷或者网上很多介绍</p>
<h5 id="网络地址简介"><a href="#网络地址简介" class="headerlink" title="网络地址简介"></a>网络地址简介</h5><p>网络地址用来在网络上代表一台设备，就像家庭地址一样，当然现在的设备，如手机可以同时拥有几个ip地址（数据网，wifi，等等，可以理解为家有多个门）<br>而现在的网络地址从32位点分十进制地址，  </p>
<ul>
<li>决定了它的数量–&gt;一个网络中的设备数量决定了它如何划分网络   </li>
<li>网络中的设备数量动态性，可能很少，ip地址不够用–&gt;子网出现（CIDR)  </li>
<li>网络地址不够用了–&gt;NAT出现，内网  </li>
</ul>
<h5 id="网段，网络范围内，由谁主导生效进行实际的网络隔离和连接"><a href="#网段，网络范围内，由谁主导生效进行实际的网络隔离和连接" class="headerlink" title="网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?"></a>网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?</h5><p>—其实本质上，设备间可以通过知道mac地址相互通信，即没有网络的隔离（只要介质支持如wifi,或者有线网下设备能被连在一起)在二层上考虑的    </p>
<ul>
<li>到了三层，ip层，设备与设备之间的通信，取决于网络的大小，在同一个局域网中，设备间可以直接通信，但是不同局域网，就必须借助路由器，网络，为什么?<br>首先，考虑他们的距离，若很远，则单纯直连很难，则需要转发，转发单知道mac地址（好吧，假设一开始知道对方的mac地址），很难像现在用ip地址的方式去找到它emm感觉考虑到协议设计了。。。<br>其次，考虑相邻的不同网络，对应不同的网段，路由表规定了只能和该网络地址范围的主机直接连接，否则就要用默认路由了</li>
<li>考虑这样一个例子：A 在子网192.168.0.0中，地址为192.168.0.3,B在子网10.170.3.0,地址为10.170.3.2,使用wifi,他们之间相邻，此时，A向B发送ARP请求，广播帧，所以B可以接收到，接着B给A回复了响应帧，单波能收到，因为在二层传递，能接收到，不被内核过滤，此时arp表中应该多了条目；接着为了能在三层通信，在路由表中增加一条路由指示不同网段的一个地址，表示他们可以直连，接着测试看看能不能相互发送ip包，ping通，当然可能因为防火墙等；就理论而言，应该是能通的，没试过~–&gt;问题总结：IP地址网段不同的两个设备，一定不能直接通信码?<ul>
<li>网关地址必须是.1结尾码?<br>恩当然可以是别的地址</li>
<li>路由表和路由规则决定了这些<br>路由表如何决定了网络的方向，下一跳，和限制了网络范围？</li>
</ul>
</li>
</ul>
<h5 id="IP封包简介"><a href="#IP封包简介" class="headerlink" title="IP封包简介"></a>IP封包简介</h5><ul>
<li>ip封包网上能找到详情，这里记录几个注意点：</li>
<li>网络字节序的概念，是大端字节序，传输的次序是先0-7bit—最后到24-31这样，所以小端的设备需要线转换为网络字节序再传输</li>
<li>首部长度字段是指占32bit的数量，有4bit，最大1111*4bytes=60bytes,即ip首部最长为60字节，普通ip同不带选项时是20字节</li>
<li>服务类型现在已经不怎么用，主要是指在不同服务下拥有不同的最小时延，最大吞吐，最高可靠性的情况，具体见协议卷１图3-2</li>
<li>总长度，指整个ip数据包的长度，包含首部和数据报，16位，即最大2^16=65535个字节，（考虑超级通道的mtu=65535并非是真正的mtu,而是最长ip数据报），数据报分片时会随着变化</li>
<li>标示和分片偏移等后面补充</li>
<li>校验和为ip首部校验和:首先校验和设置为0，接着每个16bit进行反码求和。rfc1071</li>
</ul>
<h4 id="网络的拓扑结构"><a href="#网络的拓扑结构" class="headerlink" title="网络的拓扑结构:"></a>网络的拓扑结构:</h4><p>理论上，网络中的每台设备都能相互通信，即使是点对点通信p2p.但是这要求设备能在网络上被唯一标示，如外网ip地址；</p>
<ul>
<li>所以常见的设备A和B的通信借助服务器如：<br>主机A<-->路由器(给主机唯一标识)<-->服务器<-->路由器<-->主机B<br>(现有的大部分通信软件等都是这样的)</--></--></--></--></li>
<li>而主机A可以直接和主机B通信不通过服务器吗?<br>答案是可以，我们使用的迅雷，bt,这些下载资源就是利用的各个主机的资源，其结构如何：<br>主机A<-->路由器(做NAPT等)<-->路由器<-->主机B<br>那和主机A和B如何在网络上被唯一标示，且被B知道该地址呢?路由器在其中充当什么角色，会做什么限制呢？<br>见下NAT和NAT穿透<h4 id="路由深入–NAT和NAT穿透"><a href="#路由深入–NAT和NAT穿透" class="headerlink" title="路由深入–NAT和NAT穿透"></a>路由深入–NAT和NAT穿透</h4>感谢这两篇文章把我带进门：<br><a href="https://blog.csdn.net/u012908515/article/details/53518062" target="_blank" rel="noopener">https://blog.csdn.net/u012908515/article/details/53518062</a><br><a href="https://blog.csdn.net/ustcgy/article/details/5655050" target="_blank" rel="noopener">https://blog.csdn.net/ustcgy/article/details/5655050</a><br>rfc ：nat<br><a href="https://tools.ietf.org/html/rfc1631" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1631</a><br><a href="https://tools.ietf.org/html/rfc2663" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2663</a><br>rfc：p2p<br><a href="https://tools.ietf.org/html/rfc5694" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc5694</a><h5 id="NAT的由来"><a href="#NAT的由来" class="headerlink" title="NAT的由来"></a>NAT的由来</h5></--></--></--></li>
<li>NAT的出现是因为ipv4的地址不够用，所以大量主机在内网使用内网地址，这样在互联网上通信的时候不能被寻找到，此时路由器将内网的设备发送的包中的ip转换为外网的ip,并记录映射在路由器中，这样就能实现主机在互联网上的正常通信，即发包和收包都能找到；</li>
<li>而这种方式阻碍了不同内网的主机之间的通信，即p2p;<h4 id="NAT的分类（路由器决定）"><a href="#NAT的分类（路由器决定）" class="headerlink" title="NAT的分类（路由器决定）"></a>NAT的分类（路由器决定）</h4></li>
<li>静态NAT:即内网的一个IP对应外网的一个IP，且一一对应，即每次分配的时候都是相同的，永久的</li>
<li>动态NAT：即内网的一个IP对应外网的一个IP,但是每次分配的外网IP可能不同，映射不同</li>
<li>NAPT:即为了使同一个外网IP能被多个内网的主机使用而出现；<br>如何区分各个主机？即路由器发包时和收包时，如收包时，如何确定该包是发给主机A还是B?即用NAPT,IP加端口号的形式来区分  </li>
<li>NAPT分为以下两大类：cone锥形NAT和symmetric 对称NAT</li>
</ul>
<ol>
<li>cone NAT的特点是对内网的主机A，和外网所有的服务器通信，都使用相同的端口号；<br>如：内网：192.168.4.5:4323–&gt;server:222.33.22.334:80<br>则经过路由器：外网ip:122.332.43.32:1234–&gt;server:22…路由器把源地址改为122.332.43.32:1234后发送<br>进过服务器2也是类似的，使用同一个端口1234<br>//这里有个疑问，即内网下相同的ip地址，不同的端口时，经过路由器转换后是否为不同端口<br>考虑在接收服务器回复的内容时:<br>222.33.22.334:80–&gt;122.332.43.32：1234此时路由器根据映射，即端口122.332.43.32：1234对应的是192.168.4.5把目的地址和端口更改为它后发送。所以为了能让包在主机内找到对应端口的程序，路由器的设置应为内网同ip不同端口，映射外网的ip+不同端口（待验证）</li>
</ol>
<ul>
<li>锥形NAT类型：完全锥形full cone和受限锥形( restricted cone) 以及端口受限锥形（port restricted cone)  <ul>
<li>完全锥形：任何知道主机B银蛇在NAT上的外部地址和端口的主机都可以通过它发包给内部主机B,即使A在内网(在内网时通过映射的外网地址）</li>
<li>受限锥形：只有内部主机B向其发送过包的主机A才能对这个内部主机B发包（通过主机B映射在外部的地址端口）</li>
<li>端口受限：在受限锥形的基础上加了端口限制</li>
</ul>
</li>
</ul>
<ol start="2">
<li>对称NAT(symmetric nat):<br>会为新的session分配新的端口，即和服务器1通信时使用端口1234，接着发起新的服务器2访问时，使用端口1235等<br>如何检测类型？<a href="https://blog.csdn.net/u012908515/article/details/53518062" target="_blank" rel="noopener">https://blog.csdn.net/u012908515/article/details/53518062</a></li>
</ol>
<h5 id="ipv6不需要NAT"><a href="#ipv6不需要NAT" class="headerlink" title="ipv6不需要NAT"></a>ipv6不需要NAT</h5><p>ipv6地址很多，有人形容世界上的每个沙子都能被定址，所以地址够用，也就不用内网，所以用来做p2p更适用，自然也就不用什么nat转换</p>
<h5 id="p2p网络架构和内网穿透"><a href="#p2p网络架构和内网穿透" class="headerlink" title="p2p网络架构和内网穿透"></a>p2p网络架构和内网穿透</h5><p>基于上面的napt类型介绍，可以知道内网的主机如何和外网的服务器通信，那内网的主机1如何和另一个内网的主机2直接通信?（不借助服务器）<br>答案:基于上面的限制，有几种方案：  </p>
<ul>
<li>针对full cone类型的，内网主机2只要知道内网主机1映射到外部的ip地址和端口，就可以直接发送数据包给1，且能接收；</li>
<li>针对受限的cone类型，内网机2像上面的方式是不行的：得满足两个条件：1是知道主机1映射到外部的ip和端口，2是主机1曾向主机2发送过请求，相当于开了个口，显然这个条件下2为服务器或者有公网ip的设备；所以针对此受限的类型，有一下场景+方案：<ul>
<li>场景1：主机1在nat后，打开了和服务器A通信，主机2想和1通信，主机2不在nat后；显然直接向主机1发起请求是不行的，上述条件2不满足，主机1不曾向2发起请求；  </li>
<li>解决方案是，借助服务器A请求主机1做一个反向连接，即向2发起请求，从而打开通道，进而2就可以跟1通信了</li>
<li>场景2：主机1在nat后，主机2在nat后，主机1，2均打开了和服务器A通信，主机1想直接和2通过双方映射到外网的地址端口进行通信 </li>
<li>解决方案：UDP打洞：假如1开始发送一个UDP信息到2的公网地址上,与此同时,他又通过A中转发送了一个邀请信息给2,请求2也给1发送一个UDP信息到1的公网地址上.这时1向2的公网IP发送的信息导致 NAT 1 打开一个处于1的私有地址和2的公网地址之间的新的通信会话,与此同时NAT 2也打开了一个处于2的私有地址和1的公网地址之间的新的通信会话.一旦这个新的UDP会话各自向对方打开了,1和2之间就可以直接通信,而无需A来牵线搭桥了.这就是所谓的打洞技术.一旦这种处于NAT之后的端对端的直连建立之后,连接的双方可以轮流担任对方的”媒人”,把对方介绍给其他的客户端,这样就极大的降低了服务器A的工作量.</li>
<li>场景3：主机1和2处于同一个NAT下，他们却不知道：</li>
<li>解决方案：综合相同内网下主机可以直接相互通信原理：在主机1发送给A的包中携带其内网地址和端口，A从而知道了1的外网端口地址和内网端口地址，相互都发给1,2，若接着1发起请求给2能收到回复说明在同一个内网，否则采用场景2的解决方案</li>
<li>场景4：主机1处于多层NAT下</li>
<li>问题：udp空闲状态下超时断开的问题：使用心跳包</li>
<li>扩展：tcp的打洞，同时开放tcp连接，原理类似，较复杂</li>
</ul>
</li>
<li>针对对称性的cone,不定因素多，不建议写</li>
<li>所以p2p网络即是多个内网主机1,2,3,4等之间的相互直接通信，即他们之间的下载数据可以相互共享，也就是平常说的挂种子，bt下载，也是为什么能达到那么快速的原因;当然可想这个过程和普通的cs架构区别：</li>
<li>p2p架构，bt模型（猜测)：首先客户端负责下载和挂种的基本功能。下载:需要向服务器取得可以获取资源的主机的nat外网地址和ip,接着服务器为其打洞，将正在挂种的客户ip等提供给该客户端，从而能下载；挂种：给服务器声明自己能提供资源，并通过心跳维持一个持续的洞；BT服务器做什么?综合客户端资源和打洞，即让下载方能方访问挂种放 。   这个过程需要考虑：下载方面对多个挂种方，如何下载文件块和组装，最多同时和几个挂种方下载等等；</li>
<li>回忆：之前学校的rs bt站就是这样，只是开放在学校的内网，可以说是相同nat下的不同主机???好像也不能这么说。。然后采用的原理就是上述的，记得一开始速度不是很快，但是后面15年吧，下载速度能达到10+m/s,很快的，我想可能是优化了下载多个挂种方的方案，增加了最多的下载源，或者学校的网络变优～<h5 id="Cbitterrot源码分析（待"><a href="#Cbitterrot源码分析（待" class="headerlink" title="Cbitterrot源码分析（待~)"></a>Cbitterrot源码分析（待~)</h5><a href="https://linux.cn/thread-5529-1-1.html" target="_blank" rel="noopener">https://linux.cn/thread-5529-1-1.html</a><br>对于p2p架构的软件设计，其实跟平常的cs架构很象，都需要用到socket等</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_MAC</title>
    <url>/2018/06/02/tcpip-MAC/</url>
    <content><![CDATA[<h3 id="mac数据链路层的理解"><a href="#mac数据链路层的理解" class="headerlink" title="mac数据链路层的理解"></a>mac数据链路层的理解</h3><h4 id="mac层的功能介绍"><a href="#mac层的功能介绍" class="headerlink" title="mac层的功能介绍"></a>mac层的功能介绍</h4><p>mac层在理论上赋予了较全的功能，但是其实，实际上在使用的时候，由于无噪声通道，或者一些功能交给了上层的协议，所以实际的mac功能没有理论那么全面。mac层的实现包括在驱动和固件中，所以实际的功能得看芯片和固件的支持，比如是否支持监听模式；  <a id="more"></a><br>理论上：建议书籍《数据通信与网络》<br>寻址：实际的端到端通信，都是需要先知到对方的mac地址(通过arp),才能进行实际传输的；<br>帧构建：这一层结束后就是完成了包封装，下一步传送给物理层编码发送了；<br>数据差错检查；传送控制，流量控制，差错控制，编码，校验和等等；，编码是指在原始数据mac封包后，在实际传输时进行编码（按照某个80x协议等，这个属于偏物理层的事情了）<br>实际上：数据差错检查，流量控制，差错控制等都没做，或者要看具体的厂商实现如高通，mtk等</p>
<h4 id="mac层的传输限制"><a href="#mac层的传输限制" class="headerlink" title="mac层的传输限制"></a>mac层的传输限制</h4><p> 考虑一个包从电脑发出去，最后一次封包根据接口不同(有线，无线),协议不同，采用的mac头也不同，如ppp协议要加其他信息；<br> –&gt;简述:接着可能发给无线路由器或者交换机，路由器会判断是wifi的mac头，接着要向以太网传输时，或者无线传输时，需要去掉mac头，并加上自己的mac头，改变mac源地址为自己，目的地址为(路由表对应)arp寻找的下一跳mac地址;若为以太网，还要转换为以太网的头类型等<br> …<br> 整个过程，从物理层角度看，是可以顺利进行的，但是实际为了效率，不接受无用的包，不发送无效的包和安全等，在驱动和固件都会有做相应的过滤处理，从而使发包收包，转发包等受到了限制，见下实验等；</p>
<h4 id="mac层的封包-mtu-msdu-mpdu"><a href="#mac层的封包-mtu-msdu-mpdu" class="headerlink" title="mac层的封包,mtu,msdu,mpdu"></a>mac层的封包,mtu,msdu,mpdu</h4><p>在包的封装上，有线网和无线网不同，更确切的是协议不同，其mac层封包也不同–对相同的ip包(ip头+上层数据/arp/…）带有不同的mac头：<br>例如对以太网（有线）：常见有一下四种mac头封装的帧：</p>
<ul>
<li>EthernetII:  dest addr+src addr+type+data+fcs</li>
<li>Ethernet 802.2:dest addr+srcaddr+len+ llc+data+fcs</li>
<li>Ethernet 802.3:dest addr+src addr+len+data+fcs </li>
<li>Ethernet SNAP:dest addr+src addr+len+llc+snap+data+fcs<br>参考：<a href="https://blog.csdn.net/xiao628945/article/details/8006022" target="_blank" rel="noopener">https://blog.csdn.net/xiao628945/article/details/8006022</a><br>针对无线网络：802.11n等，更复杂些：</li>
<li>802.11头+msdu(数据部分)+fcs(crc)<br>而802.11wifi无线帧分为控制帧，管理帧和数据帧，因为在无线网络中的安全性等考虑，需要扫描，关联，认证四次握手等步骤,在802.11头就包含了subtype，即数据部分是什么类型（控制，。。）<a href="https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末" target="_blank" rel="noopener">https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末</a><br><a href="https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了" target="_blank" rel="noopener">https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了</a><br>这么多的封包类型，除却ip层只有一种，那在传递的过程中如何处理?即有线到无线，怎么识别?答案是在路由器，主机中进行去头和加头<br>不同厂商实现不同，在无线中，非数据帧部分：底层的实现分为full mac driver（Full Mac的Driver，一般Auth和Assoc的包直接在芯片里边处理了，Driver通过command形式告诉Firmware要连接AP的信息，Firmware处理了Assoc Response之后，report给Driver一个Event，说明连接的情况（result和AID）以及assoc相关的IE，Driver会直接调用cfg80211的接口报告给supplicant，然后处理EAPOL的握手过程，因为之后的EAPOL Data的处理会用到Assoc Response里边的IE）  而用soft mac则软件可以控制较多的事情(Soft Mac模块开源代码mac80211的WiFi芯片，会将这两种包送到Mac80211处理，mac80211处理完后调用cfg80211的接口通过nl80211(netlink)通知wpa_supplicant准备认证以及四次握手的状态机，等待处理EAPOL包，EAPOL是二层的Data包，会在Supplicant里边处理，连接加密的路由情况就是这样处理的，如果不加密，那就直接DHCP了)；扯远了。。<br>在pc等设备中，在封装到数据链路层时，封装时用的是ethernetII，到底层驱动时就被替换为对应的802.11的头了，进而发送出去，而在接收数据包的时候，底层上报上来又会把802.11格式的转换为ehternetII的形式，所以我在实验wifi的时候，用的PF_PACKET来操作数据包，加的是ethernetII的头，接收到打印出来后还是ethernetII的头<br>晒张空中包的和本地tcpdump抓到的包对比：<br>//to do</li>
</ul>
<p>当然除却mac头的不同，mtu的概念还是存在:<br>mac层在传输时一次传输一帧，这一帧即是封装了mac头的数据包，它常为[46-1500]+mac头,而mtu即是最大的传输单元，是去掉mac头的负载部分最大值，如1500<br>而在实际传输的空中包，情况又可能不同，这里看msdu 和mpdu:<br><a href="https://blog.csdn.net/zhengnice/article/details/51923132" target="_blank" rel="noopener">https://blog.csdn.net/zhengnice/article/details/51923132</a><br>这篇文章讲的很好，在理解了上述的内容后，看这篇文章里面的msdu和mpdu就能很好的理解了，spec的416页也有相关的内容</p>
<h5 id="mac头格式：不同协议可能不同："><a href="#mac头格式：不同协议可能不同：" class="headerlink" title="mac头格式：不同协议可能不同："></a>mac头格式：不同协议可能不同：</h5><p>常见：dest addr,src addr ,proto type; 14byte<br>见上文</p>
<h4 id="mac层的发包和收包限制"><a href="#mac层的发包和收包限制" class="headerlink" title="mac层的发包和收包限制"></a>mac层的发包和收包限制</h4><p>考虑一个问题，即在不考虑网络网段的情况下，两台设备在开启wifi或者连接网线的情况下，能相互直接通信吗？<br>从理论上是可以的，首先是发送，无问题，接收，可以接收；其次，接收之后解码，需要双方使用相同的编码协议等；<br>其次：实际上，需要几个条件，且有线和无线的方式不同：</p>
<ul>
<li>有线：需要双方相同的编码，直连的情况下，可以直接通信；</li>
<li>无线: (分为数据部分和管理部分，需要双方相同的编码)，但是仅开启wifi，只能接收小量信息的beacon帧；即wifi为了安全性，效率等(wifi本身可以接收所有数据），做了连接前的扫描，关联认证，四次握手等过程，并且对mac地址进行过滤，使不同网段的两个相邻设备不能通过直接发送接收mac层数据来交互；具体见厂商的实现，可以参考实验部分；  </li>
<li>所以关键看厂商怎么实现，底层的东西，他们提供接口给你，你就能操作了balalal<h5 id="普通模式，混杂模式和监听模式"><a href="#普通模式，混杂模式和监听模式" class="headerlink" title="普通模式，混杂模式和监听模式"></a>普通模式，混杂模式和监听模式</h5><h4 id="mac层的几个实验"><a href="#mac层的几个实验" class="headerlink" title="mac层的几个实验"></a>mac层的几个实验</h4>普通模式下，wifi实验，以station架构进行：<br>设备A，B,路由器C，D;  </li>
<li>A,B连接同一个路由器C,A,B通过PF_PACKET发送和接收mac头加任意数据，成功发送接收，即使arp表无对方的条目  </li>
<li>A,B都不连接wifi,只是打开wifi，此时无法发送和接收数据，厂商默认的只会发送主动扫苗和接收beacon帧，扫描的具体过程待文章写,在没有连接上时，只会发送小数据</li>
<li>A,B间任意设备连上路由器，同上</li>
<li><em>A连接路由C,B连接路由D,相互发送和接收mac头加任意数据，目的地址为对方mac，源地址为自己的mac—失败，其实一开始是怀着疑问的，从理论分析是可以的，但是还是不行，若只是在二层的话，对方怎么知道这个源mac地址是在不同网段并做过滤?难道发之前，底层进行了隐式arp？但是我发的包里面没有带ip信息啊，同时进行了广播帧的发送接收，还是失败了；应该都是出在接收的环节；也有可能是两个ap使用的协议不同导致编码方式不同从而接收失败</em></li>
<li>考虑到可能是两个路由器编码和使用的协议如一个是802.11n,一个是ac，等，可能导致接收不到，所以可以再尝试使用两个相同的型号的路由器；//待测试</li>
<li>发送方普通模式，接收方监听模式，接收方可以收到所有包，所以可以接收到</li>
</ul>
<h4 id="openwrt开源路由系统，驱动，固件"><a href="#openwrt开源路由系统，驱动，固件" class="headerlink" title="openwrt开源路由系统，驱动，固件"></a>openwrt开源路由系统，驱动，固件</h4><p>了解一下。。。<br>spec:Wireless LAN Medium Access Control<br>(MAC)<br>and Physical Layer (PHY) Specifications</p>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_ARP</title>
    <url>/2018/05/27/tcpip-ARP/</url>
    <content><![CDATA[<h3 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h3><h4 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h4><ul>
<li>ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信；</li>
<li>在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：<br>端设备手机pc等–&gt;(交换机)路由器—&gt;下一个路由器—&gt;下一个终端设备  <a id="more"></a><br>端设备默认路由到网关–&gt;网关收到包后，将源地址改为网关的外网地址—&gt;下一个路由–&gt;….-&gt;设备地址为目的地址时，接收而不转发</li>
<li>考虑一个问题：在上述的网络上发送时，如pc发给路由器时，只知道它的ip地址，怎么发给它：<br>即端到端的发送：是借助设备唯一的mac地址来发送的<br>在有线网中。利用了交换机的端口和mac地址关系，转发<br>在wifi中，能接收到所有的包，但是会在驱动中将mac目的地址非本地的包丢弃，除非开启了混杂监听模式</li>
<li>但是路由器怎么知道设备如手机的mac地址呢？<br>通过arp协议来获取，arp是依赖mac和ip的”映射”</li>
<li>tcpip卷1中4.2举了一个完整的例子，可以去看<h4 id="ARP协议的交互过程"><a href="#ARP协议的交互过程" class="headerlink" title="ARP协议的交互过程"></a>ARP协议的交互过程</h4></li>
<li>基本的交互方式：<br>例如ping网关：<br>station  —ARP request—-&gt;   AP  ARP请求，广播帧<br>station  &lt;—ARP response —  AP  ARP应答 ,单播帧<br>通过上述的方式，station得到了AP的mac地址，之后将AP的MAC地址存在缓存中，在下次数据包等包的时候就可以将该mac地址填在mac头中，即知道了AP的地址后，包就可以顺利的被AP接收了</li>
<li>AP(路由器)也会主动的向station发送arp request，当它不知道station的mac地址（或缓存过期），例如，AP收到一个外网的包，要转发给对应192.168.0.4的staton,但是没有他的mac地址，或者过期了或者其他情况，则向该station发出arp请求。从而得打station的mac地址</li>
<li>什么时候会触发arp请求？<br>1.在ping的时候<br>2.在发送tcp，ip包的时候<br>3.在缓存过期时主动发出，这个由arp状态机中实现<h4 id="ARP代理和免费ARP"><a href="#ARP代理和免费ARP" class="headerlink" title="ARP代理和免费ARP"></a>ARP代理和免费ARP</h4></li>
<li>当我们通过ping百度，或者想访问百度的时候，怎么在mac头中填写目的mac地址呢？即怎么找到百度?（另一个网络)</li>
<li>是通过在mac头目的mac地址填写网关的mac地址实现的，借助w网关的来帮我们寻找，这个叫做ARP代理,其实欺骗了主机</li>
<li>tcpip卷对此有较详细解说4.6</li>
<li>免费ARP是用于检测是否周围有使用相同的ip地址的设备，即通过ping自己，寻找有自己的ip的主机<h4 id="ARP协议的包封装格式和抓包分析"><a href="#ARP协议的包封装格式和抓包分析" class="headerlink" title="ARP协议的包封装格式和抓包分析"></a>ARP协议的包封装格式和抓包分析</h4></li>
<li>分组格式：  ()为字节数<br>mac头：以太网目的地址(6) mac源地址(6) 帧类型(2)(0x0806)<br>28byte arp帧：硬件类型(2)|协议类型(2)|硬件地址长度(1)|协议地址长度(1)|op(请求或应答或rarp 2)|发送端mac地址(6)|发送端ip(4)|接收端mac地址(6)|接收端ip(4)  </li>
<li>请求广播帧：目的mac地址为全1，电缆上所有的以太网接口都要接收广播帧,硬件类型为1表示以太网地址，协议类型为要映射的协议地址类型0x0800,表示为ip地址，op（arp请求为1，答应为2，rarp请求为3，rarp答应为4）</li>
<li>arp填充：以太网帧最小值为60，mac头14，所以=46，要填充：46-28=18个字节</li>
<li>arp抓包，可以用wireshark,Omnipeek - Savvius,tcpdump,或者自己写一个程序来抓～<br>tcpdump : sudo tcpdump -vv arp  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> tcpdump: listening on wlp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">21.134575</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span> <span class="comment">//ap ask me</span></span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">21.135404</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span></span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">21.135413</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Reply <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> is-at <span class="number">48</span>:<span class="number">5</span>a:b6:<span class="number">6</span>e:c9:<span class="number">5f</span> (oui Unknown), length <span class="number">28</span><span class="comment">// i reply ap</span></span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">32.081916</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.106</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span> <span class="comment">//ask other</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">01</span>:<span class="number">27.149947</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.107</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span></span><br><span class="line">	<span class="number">0x0000</span>:  <span class="number">0001</span> <span class="number">0800</span> <span class="number">0604</span> <span class="number">0001</span> <span class="number">206b</span> e70f <span class="number">1b</span>42 c0a8  .........k...B..</span><br><span class="line">	<span class="number">0x0010</span>:  <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> c0a8 <span class="number">006b</span>            ...........k</span><br><span class="line">    </span><br><span class="line">    <span class="number">22</span>:<span class="number">04</span>:<span class="number">17.114593</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Reply <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> is-at <span class="number">48</span>:<span class="number">5</span>a:b6:<span class="number">6</span>e:c9:<span class="number">5f</span> (oui Unknown), length <span class="number">28</span></span><br><span class="line">	<span class="number">0x0000</span>:  <span class="number">0001</span> <span class="number">0800</span> <span class="number">0604</span> <span class="number">0002</span> <span class="number">485</span>a b66e c95f c0a8  ........HZ.n._..</span><br><span class="line">	<span class="number">0x0010</span>:  <span class="number">006</span>e <span class="number">206b</span> e70f <span class="number">1b</span>42 c0a8 <span class="number">0001</span>            .n.k...B....</span><br></pre></td></tr></table></figure>
<h4 id="ARP协议的常用命令和调试分析"><a href="#ARP协议的常用命令和调试分析" class="headerlink" title="ARP协议的常用命令和调试分析"></a>ARP协议的常用命令和调试分析</h4><ul>
<li>查看ARP缓存：即现在保存的arp映射表:  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">arp</span> <span class="selector-tag">-a</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.101</span>) <span class="selector-tag">at</span> 4<span class="selector-tag">c</span><span class="selector-pseudo">:32</span><span class="selector-pseudo">:75</span><span class="selector-pseudo">:3a</span><span class="selector-pseudo">:09</span><span class="selector-pseudo">:b3</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.1</span>) <span class="selector-tag">at</span> 20<span class="selector-pseudo">:6b</span><span class="selector-pseudo">:e7</span><span class="selector-pseudo">:0f</span><span class="selector-pseudo">:1b</span><span class="selector-pseudo">:42</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.108</span>) <span class="selector-tag">at</span> 94<span class="selector-pseudo">:d0</span><span class="selector-pseudo">:29</span><span class="selector-pseudo">:9d</span><span class="selector-pseudo">:74</span><span class="selector-pseudo">:dd</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.107</span>) <span class="selector-tag">at</span> 94<span class="selector-pseudo">:65</span><span class="selector-pseudo">:2d</span><span class="selector-pseudo">:ab</span><span class="selector-pseudo">:88</span><span class="selector-pseudo">:8b</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">arp</span> </span><br><span class="line"><span class="selector-tag">Address</span>                  <span class="selector-tag">HWtype</span>  <span class="selector-tag">HWaddress</span>           <span class="selector-tag">Flags</span> <span class="selector-tag">Mask</span>            <span class="selector-tag">Iface</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.101</span>            <span class="selector-tag">ether</span>   4<span class="selector-tag">c</span><span class="selector-pseudo">:32</span><span class="selector-pseudo">:75</span><span class="selector-pseudo">:3a</span><span class="selector-pseudo">:09</span><span class="selector-pseudo">:b3</span>   <span class="selector-tag">C</span>                     <span class="selector-tag">wlp2s0</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.1</span>              <span class="selector-tag">ether</span>   20<span class="selector-pseudo">:6b</span><span class="selector-pseudo">:e7</span><span class="selector-pseudo">:0f</span><span class="selector-pseudo">:1b</span><span class="selector-pseudo">:42</span>   <span class="selector-tag">C</span>                     <span class="selector-tag">wlp2s0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ip neigh</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span> dev wlp2s0 lladdr <span class="number">4</span>c:<span class="number">32</span>:<span class="number">75</span>:<span class="number">3</span>a:<span class="number">09</span>:b3 STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> dev wlp2s0 lladdr <span class="number">20</span>:<span class="number">6b</span>:e7:<span class="number">0f</span>:<span class="number">1b</span>:<span class="number">42</span> STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.108</span> dev wlp2s0 lladdr <span class="number">94</span>:d0:<span class="number">29</span>:<span class="number">9</span>d:<span class="number">74</span>:dd STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.107</span> dev wlp2s0 lladdr <span class="number">94</span>:<span class="number">65</span>:<span class="number">2</span>d:ab:<span class="number">88</span>:<span class="number">8b</span> STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.104</span> dev wlp2s0 lladdr e4:<span class="number">9</span>a:dc:b0:a5:<span class="number">36</span> STALE</span><br></pre></td></tr></table></figure>
<ul>
<li>arping命令：<br><a href="http://man.linuxde.net/arping" target="_blank" rel="noopener">http://man.linuxde.net/arping</a></li>
<li>arp 命令<br>man arp 包括删除arp表项等，有问题，找男人~<h4 id="ARP协议内核状态机"><a href="#ARP协议内核状态机" class="headerlink" title="ARP协议内核状态机"></a>ARP协议内核状态机</h4></li>
<li>对不存在的主机，arp请求的超时机制  </li>
<li>arp缓存和老化时间：<br><a href="http://www.jb51.net/LINUXjishu/65693.html：" target="_blank" rel="noopener">http://www.jb51.net/LINUXjishu/65693.html：</a><br>改变老化时间：在Linux上如果你想设置你的ARP缓存老化时间，那么执行sysctl -w net.ipv4.neigh.ethX=Y即<h4 id="ARP协议的编程"><a href="#ARP协议的编程" class="headerlink" title="ARP协议的编程"></a>ARP协议的编程</h4></li>
<li>在PF_PACKET中发出ARP包</li>
<li>直接贴例子，具体可以看博客的PF_PACKET文章：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取硬件网卡的相应信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="keyword">char</span> *name , <span class="keyword">char</span> *MAC_addr , struct in_addr * IP_addr)</span></span>;</span><br><span class="line"><span class="comment">//arp包的结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ARP_PACKET</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="comment">//以太网首部</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> dest_mac[<span class="number">6</span>]; <span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> sorce_mac[<span class="number">6</span>];<span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> type;       <span class="comment">//2字节</span></span><br><span class="line">  <span class="comment">//arp——内容</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> hw_type;   <span class="comment">//2字节：硬件地址类型     0x0001 表示mac地址</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> pro_type;  <span class="comment">//2字节：软件地址类型    0x0806 表示IPV4地址</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> hw_len;     <span class="comment">//1字节：硬件地址长度  </span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> pro_len;    <span class="comment">//1字节：软件地址长度</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> op;        <span class="comment">//2字节：操作类型           0x0001表示ARP请求；0x0002表示ARP应答</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> from_mac[<span class="number">6</span>];<span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> from_ip[<span class="number">4</span>]; <span class="comment">//4字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> to_mac[<span class="number">6</span>];  <span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> to_ip[<span class="number">4</span>];   <span class="comment">//4字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> padding[<span class="number">18</span>];<span class="comment">//18字节：填充字节，因为以太网数据最少要46字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> MAC_ADDR[<span class="number">6</span>];</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">IP_ADDR</span>;</span><span class="comment">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ARP_PACKET</span> <span class="title">arp_pk</span>=&#123;</span><span class="number">0</span>&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">eth_info</span>;</span><span class="comment">//结构体的定义//在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class="line"> <span class="comment">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class="line"> GetEthInfor(<span class="string">"wlp2s0"</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class="line">   <span class="comment">/*printf("The MAC_addr is:");</span></span><br><span class="line"><span class="comment"> for(i =0 ;i&lt;6;i++)</span></span><br><span class="line"><span class="comment">    printf("%4X",MAC_ADDR[i]); </span></span><br><span class="line"><span class="comment"> printf("\n");</span></span><br><span class="line"><span class="comment">    printf("the IP is:%s\n",inet_ntoa(IP_ADDR));*/</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//第二步：填充ARP数据包的内容</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充以太网首部的目的mac地址</span></span><br><span class="line"> &#123;</span><br><span class="line">  arp_pk.dest_mac[i]=<span class="number">0XFF</span>;      </span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充以太网首部的源mac地址</span></span><br><span class="line"> &#123;</span><br><span class="line">  arp_pk.sorce_mac[i]=MAC_ADDR[i];</span><br><span class="line"> &#125;</span><br><span class="line">   arp_pk.type = htons(<span class="number">0x0806</span>);    <span class="comment">//填充以太网首部的侦类型</span></span><br><span class="line">   arp_pk.hw_type = htons(<span class="number">0x0001</span>); <span class="comment">//填充硬件地址类型：0x0001表示的是MAC地址</span></span><br><span class="line">   arp_pk.pro_type = htons(<span class="number">0x0800</span>);<span class="comment">//填充协议地址类型：0x0800表示的是IP地址</span></span><br><span class="line">   arp_pk.hw_len = <span class="number">6</span>;              <span class="comment">//填充硬件地址长度</span></span><br><span class="line">   arp_pk.pro_len = <span class="number">4</span>;             <span class="comment">//填充协议地址长度</span></span><br><span class="line">   arp_pk.op = htons(<span class="number">0x0001</span>);      <span class="comment">//填充操作类型：0x0001表示ARP请求</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充源mac地址</span></span><br><span class="line">   &#123;</span><br><span class="line">  arp_pk.from_mac[i]=MAC_ADDR[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">in_addr_t</span> ipaddr=inet_network(inet_ntoa(IP_ADDR));</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)                 <span class="comment">//填充源IP地址</span></span><br><span class="line">   &#123;</span><br><span class="line">  arp_pk.from_ip[i]=(<span class="keyword">unsigned</span> <span class="keyword">char</span>)ipaddr&amp;<span class="number">0xFF</span>;</span><br><span class="line">   ipaddr=ipaddr&gt;&gt;<span class="number">8</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"-%d-"</span>,arp_pk.from_ip[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">/* arp_pk.from_ip[0]=192;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[1]=168;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[2]=199;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[3]=145;*/</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充欲获取的目的mac地址</span></span><br><span class="line">   &#123;</span><br><span class="line">    arp_pk.to_mac[i]=<span class="number">0X00</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   arp_pk.to_ip[<span class="number">0</span>]=<span class="number">0X0B</span>;        <span class="comment">//填充想要装换为MAC地址的IP地址。可以使用命令行参数来做</span></span><br><span class="line">   arp_pk.to_ip[<span class="number">1</span>]=<span class="number">0X40</span>;</span><br><span class="line">   arp_pk.to_ip[<span class="number">2</span>]=<span class="number">0X39</span>;</span><br><span class="line">   arp_pk.to_ip[<span class="number">3</span>]=<span class="number">0X0A</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第三步：填充sockaddr_ll eth_info结构</span></span><br><span class="line">    eth_info.sll_family = PF_PACKET;</span><br><span class="line"> eth_info.sll_ifindex = if_nametoindex(<span class="string">"wlp2s0"</span>);<span class="comment">//返回输入的接口名称的索引值</span></span><br><span class="line"> <span class="comment">//printf("number is:%d\n",eth_info.sll_family);</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第四步：创建原始套接字</span></span><br><span class="line"> fd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));  <span class="comment">//</span></span><br><span class="line"> <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"socket SOCK_RAW failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="comment">//第五步：发送ARP数据包</span></span><br><span class="line"> num = sendto(fd , &amp;arp_pk , <span class="keyword">sizeof</span>(struct ARP_PACKET) , <span class="number">0</span> ,(struct sockaddr*)(&amp;eth_info),<span class="keyword">sizeof</span>(eth_info));</span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sendto failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">        <span class="comment">//第六步：接受ARP应答</span></span><br><span class="line"> num = recvfrom(fd , &amp;arp_pk , <span class="keyword">sizeof</span>(struct ARP_PACKET) ,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"rcvfrom failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"I receive %d bytes!\n"</span>,num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the mac  is:"</span>);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%4X "</span>,arp_pk.from_mac[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"op:%d\n"</span>,arp_pk.op);</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d. "</span>,arp_pk.to_ip[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="keyword">char</span> *name ,  <span class="keyword">char</span> *MAC_addr , struct in_addr * IP_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span>  <span class="title">eth</span>;</span>  <span class="comment">//够结构用于存放最初多获取的接口信息</span></span><br><span class="line"><span class="comment">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class="line">   <span class="keyword">int</span> fd;             <span class="comment">//用于创建套接字</span></span><br><span class="line"> <span class="keyword">int</span> temp=<span class="number">0</span>;         <span class="comment">//用于验证接口调用</span></span><br><span class="line"> <span class="keyword">int</span> i=<span class="number">0</span>;            <span class="comment">//用于循环</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">strncpy</span>(eth.ifr_name,name,<span class="keyword">sizeof</span>(struct ifreq)<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class="line"> <span class="comment">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class="line">    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"socket failed!\n"</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class="line">   temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class="line"> <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="built_in">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class="number">6</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"The MAC_addr is:"</span>);</span><br><span class="line"> <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%4X"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class="line">   temp = ioctl(fd,SIOCGIFADDR,&amp;eth);</span><br><span class="line"> <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="built_in">memcpy</span>(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class="number">4</span>);</span><br><span class="line"> <span class="comment">//关闭套接口</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"got ipaddr:%s\n"</span>,inet_ntoa(*IP_addr));</span><br><span class="line"><span class="comment">/*i=0;</span></span><br><span class="line"><span class="comment">printf("get the MAC_ADDR:\n");</span></span><br><span class="line"><span class="comment">for(i;i&lt;6;i++)</span></span><br><span class="line"><span class="comment">  printf("%.2X:",MAC_addr[i]&amp;0xFF);*/</span></span><br><span class="line">   close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步填充arp数据包的时候，填充的数据和类型根据需要进行。</span></span><br><span class="line"><span class="comment">//这里的arp数据包结构体是自己定义的，也可以是利用linux的相关结构：</span></span><br><span class="line"><span class="comment">/*eg:</span></span><br><span class="line"><span class="comment">typedef struct _tagARP_PACKET&#123;    </span></span><br><span class="line"><span class="comment">    struct ether_header  eh;    ///net/ethernet.h</span></span><br><span class="line"><span class="comment">    struct ether_arp arp;    </span></span><br><span class="line"><span class="comment">&#125;ARP_PACKET_OBJ, *ARP_PACKET_HANDLE; /netinet/if_ether.h;/net/if_arp.h</span></span><br><span class="line"><span class="comment">各个字段的填充见头文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三步：填充sockaddr_ll eth_info结构,关键是填充网络接口索引值，最直接的方法是上面的函数，</span></span><br><span class="line"><span class="comment">还有另外的方法:利用ioctl函数获取struct ifreq结构的信息，该结构放置了很多网络接口的相关信息*/</span></span><br><span class="line"><span class="comment">/*  struct sockaddr_ll&#123;</span></span><br><span class="line"><span class="comment">    unsigned short sll_family; //总是 AF_PACKET </span></span><br><span class="line"><span class="comment">    unsigned short sll_protocol; // 物理层的协议 </span></span><br><span class="line"><span class="comment">    int sll_ifindex; //接口号 </span></span><br><span class="line"><span class="comment">    unsigned short sll_hatype; // 报头类型 </span></span><br><span class="line"><span class="comment">    unsigned char sll_pkttype; // 分组类型 </span></span><br><span class="line"><span class="comment">    unsigned char sll_halen; // 地址长度 </span></span><br><span class="line"><span class="comment">    unsigned char sll_addr[8]; // 物理层地址 </span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">eg:</span></span><br><span class="line"><span class="comment">*     struct sockaddr_ll peer_addr;  </span></span><br><span class="line"><span class="comment">*    memset(&amp;peer_addr, 0, sizeof(peer_addr));    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_family = AF_PACKET;    </span></span><br><span class="line"><span class="comment">        struct ifreq req;  </span></span><br><span class="line"><span class="comment">    bzero(&amp;req, sizeof(struct ifreq));  </span></span><br><span class="line"><span class="comment">        strcpy(req.ifr_name, "eth0");    </span></span><br><span class="line"><span class="comment">        if(ioctl(sockfd, SIOCGIFINDEX, &amp;req) != 0)  </span></span><br><span class="line"><span class="comment">        perror("ioctl()");    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_ifindex = req.ifr_ifindex;    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_protocol = htons(ETH_P_ARP);  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*第四步，创建套结字的时候，有以下的组合：更多见：man packet</span></span><br><span class="line"><span class="comment"> * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</span></span><br><span class="line"><span class="comment"> * 第二个参数： 2）套接字类型：</span></span><br><span class="line"><span class="comment">          SOCK_DGRAM----以太网头已经构造好了</span></span><br><span class="line"><span class="comment">          SOCK_RAW------自己构造以太头 </span></span><br><span class="line"><span class="comment">          * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字</span></span><br><span class="line"><span class="comment">          * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），</span></span><br><span class="line"><span class="comment">          * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，</span></span><br><span class="line"><span class="comment">          * 而发送时也无须用户添加头部字段。</span></span><br><span class="line"><span class="comment">   第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP</span></span><br><span class="line"><span class="comment">   * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：</span></span><br><span class="line"><span class="comment">   1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)</span></span><br><span class="line"><span class="comment">  和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)</span></span><br><span class="line"><span class="comment">    2)IEEE维护的注册以太网类型列表</span></span><br><span class="line"><span class="comment">     3）半官方的列表由IANA维护</span></span><br><span class="line"><span class="comment">      ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。</span></span><br><span class="line"><span class="comment">      0x88b5和0x88b6是保留以太网类型，供实验或私人使用。 </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">   <span class="comment">/*第五步发送和接收套接字的函数可以是read write操作套结字，也可以是上文的UDP无连接用的函数*/</span></span><br></pre></td></tr></table></figure>
<p>处理的时候可能需要获取网关的ip地址：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*proc方法获取网关地址*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetGateWayIP</span><span class="params">(uint8 *ip_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> inf[<span class="number">100</span>];</span><br><span class="line">      FILE *file_fd;</span><br><span class="line">      uint8 high=<span class="number">0</span>,low=<span class="number">0</span>,value;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      file_fd = fopen(<span class="string">"/proc/net/route"</span>,<span class="string">"r"</span>);</span><br><span class="line">      <span class="keyword">if</span>(file_fd==<span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"can not open /proc/net/route\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">             <span class="keyword">while</span>(!feof(file_fd))</span><br><span class="line">             &#123;</span><br><span class="line">                     <span class="built_in">memset</span>(inf,<span class="number">0</span>,<span class="keyword">sizeof</span>(inf));</span><br><span class="line">                     fgets(inf,<span class="number">100</span>,file_fd);</span><br><span class="line">                     <span class="keyword">if</span>(inf[<span class="number">5</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">6</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">7</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">8</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">9</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">10</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">11</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">12</span>]==<span class="string">'0'</span>)</span><br><span class="line">                     &#123;</span><br><span class="line">                              <span class="keyword">for</span>(i=<span class="number">20</span>;i&gt;=<span class="number">14</span>;i-=<span class="number">2</span>)</span><br><span class="line">                              &#123;</span><br><span class="line">                                         <span class="keyword">if</span>(inf[i]&gt;=<span class="number">65</span>)</span><br><span class="line">                                                 high = inf[i]<span class="number">-55</span>;</span><br><span class="line">                                         <span class="keyword">else</span></span><br><span class="line">                                                 high = inf[i]<span class="number">-48</span>;</span><br><span class="line">                                         <span class="keyword">if</span>(inf[i+<span class="number">1</span>]&gt;=<span class="number">65</span>)</span><br><span class="line">                                                 low = inf[i+<span class="number">1</span>]<span class="number">-55</span>;</span><br><span class="line">                                         <span class="keyword">else</span></span><br><span class="line">                                                 low = inf[i+<span class="number">1</span>]<span class="number">-48</span>;</span><br><span class="line">                                        value = high*<span class="number">16</span>+low;</span><br><span class="line">                                       ip_addr[<span class="number">10</span>-i/<span class="number">2</span>] = value;</span><br><span class="line">                              &#125;</span><br><span class="line">                              <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h4><ul>
<li>ARP包可以直接发送给对端不经过路由器，有趣<br>在一个局域网中，客户端的几乎所有的包都是发往路由器的，这归结于默认路由设置，而在无线网，网卡其实可以接收所有数据，毕竟空气介质，所以，局域网中的设备可以直接通信<br>实验：在文件全能王中开启wifi文件传输，和它在同一个局域网的sta能访问该地址，抓包，发现目的地址和源地址都为同一个局域网的不同ip,且不为路由器网关ip，证明其两个设备是可以直接通信的</li>
<li>再来做一个实验：通过pf_packet<br>1、在电脑A上写一个程序，mac目的地址为B,源地址为A,协议类型随机，数据随意，发送给B<br> 同时在B端进行接收，过滤掉其他mac地址，看是否可以接收到，在连接ap和不连接ap的条件下<br>2、在A和B设置静态ip地址，且不同网段，都不连接AP ,让A向B 发送ARP请求包，B接收到后回复arp响应包，接着做ping或其他操作，看是否能互相通信</li>
<li>编程可以参考上述程序，改一下地址什么的就可以，或者参考其他：<br><a href="http://www.freebuf.com/articles/system/5157.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/system/5157.html</a><br>这篇文章讲的很具体，个人也喜欢这个网站，emm,实验过了，还可以，can also make your own program,具体程序不贴了  </li>
<li>arp欺骗的基本原理：<br>在局域网中，设备A,B连接同一个路由器，他们之间可以直接相互通信，因此可以直接向对方发送arp包；<br>设备A ,B都会定期和AP交互arp请求和回复，相互知道对方的mac地址，这样，就能给ap发送请求，ap也能知道回复给谁；<br>arp欺骗的基本原理在于，如B是攻击方，则B向A发送ARP回复自己是AP ,即在ARP回复包中带上自己的mac地址，ap的ip地址；<br>同时向AP回复自己是A，即带上A的ip地址，自己的mac地址；<br>这样A就会以为B是AP，就会把请求发给B ,同时AP以为B是A，会把回复传给B,但是同时得配置B的转发功能，<br>echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot<br>该博文中有一处错误，见评论</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_PF_PACKET</title>
    <url>/2018/05/27/tcpip-PF-PACKET/</url>
    <content><![CDATA[<img src="/2018/05/27/tcpip-PF-PACKET/pf_packet.jpg" title="it just picture">
<h3 id="PF-PACKET的使用："><a href="#PF-PACKET的使用：" class="headerlink" title="PF_PACKET的使用："></a>PF_PACKET的使用：</h3><h3 id="PF-PACKET简介："><a href="#PF-PACKET简介：" class="headerlink" title="PF_PACKET简介："></a>PF_PACKET简介：</h3><p>是linux下的用于发送和接收二层(mac层)的套接字：<br><a id="more"></a></p>
<h3 id="PF-PACKET基本使用："><a href="#PF-PACKET基本使用：" class="headerlink" title="PF_PACKET基本使用："></a>PF_PACKET基本使用：</h3><ul>
<li>基本的几个操作：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取硬件网卡的相应信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="keyword">char</span> *name ,  <span class="keyword">char</span> *MAC_addr , struct in_addr * IP_addr)</span><span class="comment">//传入接口名，取回mac和ip</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span>  <span class="title">eth</span>;</span>  <span class="comment">//结构用于存放最初获取的接口信息</span></span><br><span class="line">   <span class="comment">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class="line">   <span class="keyword">int</span> fd;             <span class="comment">//用于创建套接字</span></span><br><span class="line">   <span class="keyword">int</span> temp=<span class="number">0</span>;         <span class="comment">//用于验证接口调用</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;            <span class="comment">//用于循环</span></span><br><span class="line">   <span class="built_in">strncpy</span>(eth.ifr_name,name,<span class="keyword">sizeof</span>(struct ifreq)<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class="line">  <span class="comment">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class="line">    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"socket failed!\n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class="line">     temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class="line">     <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="built_in">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class="number">6</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"The MAC_addr is:"</span>);</span><br><span class="line">      <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%4X"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class="line">      temp = ioctl(fd,SIOCGIFADDR,&amp;eth);</span><br><span class="line">      <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class="number">4</span>);</span><br><span class="line">      <span class="comment">//关闭套接口</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"got ipaddr:%s\n"</span>,inet_ntoa(*IP_addr)); </span><br><span class="line">      close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取得网络接口的索引：int值,传入fd和接口名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_IfaceIndex</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* interfaceName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"><span class="keyword">if</span> (interfaceName == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line"><span class="built_in">strcpy</span>(ifr.ifr_name, interfaceName);</span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, SIOCGIFINDEX, &amp;ifr) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"RED ioctl error\n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ifr.ifr_ifindex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_Iface_promisc</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> dev_id)</span><span class="comment">//传入fd和index</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_mreq</span> <span class="title">mr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;mr,<span class="number">0</span>,<span class="keyword">sizeof</span>(mr));</span><br><span class="line">mr.mr_ifindex = dev_id;</span><br><span class="line">mr.mr_type = PACKET_MR_PROMISC;</span><br><span class="line"><span class="keyword">if</span>(setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&amp;mr,<span class="keyword">sizeof</span>(mr))==<span class="number">-1</span>)<span class="comment">//退出混杂模式使用这个：PACKET_DROP_MEMBERSHIP</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"GREEN set promisc failed! \n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">unsigned</span> <span class="keyword">char</span> MAC_ADDR[<span class="number">6</span>];</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">IP_ADDR</span>;</span><span class="comment">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class="line">	 <span class="comment">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class="line">    GetEthInfor(<span class="string">"wlp2s0"</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">     fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP));</span><br><span class="line">    <span class="keyword">int</span> index=Get_IfaceIndex(fd,<span class="string">"enp1s0"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"index:%d\n"</span>,index);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="PF-PACKET的接收："><a href="#PF-PACKET的接收：" class="headerlink" title="PF_PACKET的接收："></a>PF_PACKET的接收：</h3><p>简单说明：<br>创建套结字的时候，有以下的组合：更多见：man packet</p>
<ul>
<li>利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</li>
<li>第二个参数： 套接字类型：<pre><code>SOCK_DGRAM----以太网头已经构造好了
SOCK_RAW------自己构造以太头 
* 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字
* 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），
* 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，
* 而发送时也无须用户添加头部字段。
</code></pre></li>
</ul>
<ul>
<li>第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP<ul>
<li>以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：<br>1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)<br>和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)<br>2)  IEEE维护的注册以太网类型列表<br>3）半官方的列表由IANA维护<br> ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。<br> 0x88b5和0x88b6是保留以太网类型，供实验或私人使用。<br>(若指定socket_type为SOCK_RAW则意味着原始数据包包含了链路层头部，若指定为SOCK_DGRAM则将做一些处理以剥掉链路层头部。链路层头部信息的通用格式是一个sockaddr_ll结构。protocol填入网络字节序的IEEE 802.3协议号。参见&lt;linux/if_ether.h&gt;头文件了解允许的协议。如果protocol被设置为htons(ETH_P_ALL)，则意味着接受所有协议。所有接入的协议类型为protocol的数据包将在传递给内核之前传递到PACKET套接字。)</li>
</ul>
<ul>
<li>收包可以使用的接口：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readnum = recvfrom(rawsock, buffer,<span class="number">2048</span>,<span class="number">0</span>, (struct sockaddr*)(&amp;eth_info),&amp;leneth_info);</span><br><span class="line"><span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);</span><br><span class="line"><span class="keyword">int</span> readnum = recvfrom(rawsock, buffer,<span class="number">2048</span>,<span class="number">0</span>, <span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>一个简单的接收包的例子：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_MAX 2048</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: create raw socket!!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf("recv buffer:%s\n",buffer);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>指定从某个接口接收数据：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">eth_info</span>;</span><span class="comment">//结构体的定义在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class="line">  eth_info.sll_family = PF_PACKET;  <span class="comment">//PF_PACKET定义在sys/types.h中</span></span><br><span class="line">  eth_info.sll_ifindex = if_nametoindex(<span class="string">"lo"</span>);<span class="comment">//返回输入的接口名称的索引值　　//次函数定义在net/if.h中</span></span><br><span class="line"> <span class="keyword">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: create raw socket!!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">if</span>(bind(rawsock,(struct sockaddr *)(&amp;eth_info),<span class="keyword">sizeof</span>(eth_info))==<span class="number">-1</span>)<span class="comment">//绑定接口，从而只接收那个接口上的数据</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"error: bind!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf("recv buffer:%s\n",buffer);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>接收后的包如何读取：以包括mac头的形式来看：粗暴的形式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rawsock;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_MAX];</span><br><span class="line">    <span class="keyword">char</span> *ethhead;</span><br><span class="line">    <span class="keyword">char</span> *iphead;</span><br><span class="line">    <span class="keyword">char</span> *tcphead;</span><br><span class="line">    <span class="keyword">char</span> *udphead;</span><br><span class="line">    <span class="keyword">char</span> *icmphead;</span><br><span class="line">    <span class="keyword">char</span> *pHead;</span><br><span class="line"> <span class="keyword">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: create raw socket!!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf("recv buffer:%s\n",buffer);</span></span><br><span class="line">         <span class="keyword">if</span>(readnum &lt; <span class="number">42</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error: Header is incomplete!!!\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//  for(j;j&lt;readnum;j++)</span></span><br><span class="line">      <span class="comment">//     printf("%.2X:",buffer[j]&amp;0xFF);</span></span><br><span class="line">        ethhead = (<span class="keyword">char</span> *)buffer;</span><br><span class="line">        pHead = ethhead;</span><br><span class="line">        <span class="keyword">int</span> ethernetmask = <span class="number">0XFF</span>;</span><br><span class="line">        framecount++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"------------------Analysis   Packet [%d]---------------------\n"</span>,framecount);</span><br><span class="line">       <span class="comment">// printf("all:-----%s\n",ethhead);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"MAC:"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;=<span class="number">11</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2X:"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;=<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2X:"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"proto: %.2x:"</span>,pHead[<span class="number">12</span>]&amp;ethernetmask);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"proto2: %.2x:\n"</span>,pHead[<span class="number">13</span>]&amp;ethernetmask);        </span><br><span class="line">        iphead = ethhead + <span class="number">14</span>;</span><br><span class="line">        pHead = iphead + <span class="number">14</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"IP:"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;=<span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">10</span>; i &lt;=<span class="number">13</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">13</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> prototype = (iphead + <span class="number">9</span>)[<span class="number">0</span>];</span><br><span class="line">     <span class="comment">//   printf("Protocol: %.2X:",prototype);</span></span><br><span class="line">        <span class="comment">//int prototype = (iphead + 9)[0];</span></span><br><span class="line">        pHead = iphead + <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Protocol: "</span>);</span><br><span class="line">        <span class="keyword">switch</span>(prototype)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_ICMP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ICMP\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_IGMP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"IGMP\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_IPIP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"IP\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_TCP :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"TCP | source port: %u | "</span>,(pHead[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">1</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"dest port: %u\n"</span>, (pHead[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">3</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_UDP :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"UDP | source port: %u | "</span>,(pHead[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">1</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"dest port: %u\n"</span>, (pHead[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">3</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_RAW :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"RAW\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Unkown\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-------------------------end-----------------------\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>收包处理的方式，也可以把指针赋给内核的结构：struct iphdr<br>如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> <span class="title">ip</span>;</span></span><br><span class="line">ip = (struct iphdr *)(buffer + <span class="keyword">sizeof</span>(struct ethhdr));</span><br></pre></td></tr></table></figure></p>
<p>内核提供了很多的包结构，在发包或者收包的时候可以直接使用这些结构解析或者粗暴的用字符串解析</p>
<h3 id="PF-PACKET发送包："><a href="#PF-PACKET发送包：" class="headerlink" title="PF_PACKET发送包："></a>PF_PACKET发送包：</h3><ul>
<li>发包和接收包类似：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">num = sendto(rawsock, buffer,<span class="number">2048</span> , <span class="number">0</span> ,(struct sockaddr*)(&amp;eth_info),<span class="keyword">sizeof</span>(eth_info));</span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sendto failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"success:%d\n"</span>,num);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>PF_PACKET</tag>
      </tags>
  </entry>
  <entry>
    <title>DS_linklist</title>
    <url>/2018/05/26/DS-linklist/</url>
    <content><![CDATA[<h2 id="数据结构之线性表："><a href="#数据结构之线性表：" class="headerlink" title="数据结构之线性表："></a>数据结构之线性表：</h2><h3 id="有序表：数组："><a href="#有序表：数组：" class="headerlink" title="有序表：数组："></a>有序表：数组：</h3><h3 id="单链表："><a href="#单链表：" class="headerlink" title="单链表："></a>单链表：</h3><p>链表定义  <a id="more"></a><br>{  </p>
<ul>
<li>数据成员:常见的基本类型或者对象类型均可  </li>
<li>数据关系:在链表中的块的成员在连续的内存中，块与块之间内存位置不连续  </li>
<li>指向块的指针：单链表只有一个next,双链表加上pre  </li>
</ul>
<p>}<br>基本运算：<br>{</p>
<ul>
<li>InitList(&amp;L);:初始化链表，在c/c++中需要做分配内存，初始化链表头和其值的操作；  </li>
<li>DestroyList(&amp;L); 在销毁时需要free内存  </li>
<li>Length(L);链表的长度是块的个数</li>
<li>GetElem(L,i,&amp;e); 在链表中取元素需要一个一个遍历直到下标值，若为双链表会快些。所以这里取索引值对应的值和取链表的值，效率几乎一样；  </li>
<li>LocateElem(L,e,compare()); 和链表中的元素做对比</li>
<li>InsertElem(&amp;L,i,e); 在链表中插入元素，复杂度O(1),在提供位置的时候，若不提供位置，还需要加搜索的时间</li>
<li>DeleteElem(&amp;L,i,&amp;e); 在链表中删除元素，复杂度O(1)<br>……  </li>
</ul>
<p>}<br>eg:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span> </span><br><span class="line">       ElemType data；<span class="comment">//数据域</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>  *<span class="title">next</span>； //指针域</span></span><br><span class="line"><span class="class">&#125; <span class="title">LNode</span>,  *<span class="title">LinkList</span>;</span></span><br><span class="line">LNode  *L;</span><br><span class="line">LinkList  L;</span><br><span class="line">L =  (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">或 L = <span class="keyword">new</span> LNode;</span><br><span class="line">L-&gt;data;</span><br><span class="line">LNode  L;</span><br><span class="line">L.date</span><br></pre></td></tr></table></figure></p>
<img src="/2018/05/26/DS-linklist/linklist.png" title="链表示意图">    
<h3 id="链表的两种头部："><a href="#链表的两种头部：" class="headerlink" title="链表的两种头部："></a>链表的两种头部：</h3><ol>
<li>没有头的链表：第一个块就开始存储数据  </li>
<li>任何时候都有头的链表：  第一个块不存储数据，作为头节点，第二个块开始存数据  </li>
<li>应用：在leetcode中的ReverseLinklist中，当反转的是从1开始的时候，若使用的是没有头的，则需要额外判断处理，否则可以统一处理；  </li>
</ol>
<img src="/2018/05/26/DS-linklist/headnode.png" title="头节点示意图">  
<h3 id="链表的几个常见操作："><a href="#链表的几个常见操作：" class="headerlink" title="链表的几个常见操作：　"></a>链表的几个常见操作：　</h3><ul>
<li><p>取第i个元素：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//查找操作</span></span><br><span class="line">    p = L-&gt;next;  </span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; j &lt; i)&#123;</span><br><span class="line">          p = p-&gt;next; </span><br><span class="line">          ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j&gt;i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入元素：在第i个位置上插入    </p>
<img src="/2018/05/26/DS-linklist/insert.png" title="插入示意图">    
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p = L; j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (p &amp;&amp; j &lt; i<span class="number">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class="line">     <span class="keyword">if</span> (!p || j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line">  s =  (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     s-&gt;data = e;  </span><br><span class="line">  s-&gt;next = p-&gt;next;  </span><br><span class="line">  p-&gt;next = s;  </span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素:删除第i个元素:  </p>
<img src="/2018/05/26/DS-linklist/delete.png" title="删除示意图">  
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> p = L; j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i<span class="number">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class="line">     <span class="keyword">if</span> (!(p-&gt;next) || j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line"> q = p-&gt;next;</span><br><span class="line">     e = q-&gt;data;  </span><br><span class="line"> p-&gt;next = p-&gt;next-&gt;next;  <span class="comment">//(p-&gt;next = q-&gt;next;)</span></span><br><span class="line"> <span class="built_in">free</span>(q);  </span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="链表的建立："><a href="#链表的建立：" class="headerlink" title="链表的建立："></a>链表的建立：</h3><ul>
<li><p>头插法：  </p>
<img src="/2018/05/26/DS-linklist/headbuild.png" title="头插法示意图">  
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CreateList_L(LinkList &amp;L, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">     L = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span>( i=n; i&gt;<span class="number">0</span>; --i)&#123;</span><br><span class="line">         s = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">         <span class="built_in">scanf</span>( &amp;s-&gt;data);</span><br><span class="line">         s-&gt;next = L-&gt;next; ①</span><br><span class="line">         L-&gt;next = s; ②</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾插法：  </p>
<img src="/2018/05/26/DS-linklist/tailbuile.png" title="尾插法示意图">  
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CreateList_L(LinkList &amp;L, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">     tail = L = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span>( i=n; i&gt;<span class="number">0</span>; --i)&#123;</span><br><span class="line">         s = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">         <span class="built_in">scanf</span>( &amp;s-&gt;data);</span><br><span class="line">         tail-&gt;next = s; ①</span><br><span class="line">         tail = s; ②</span><br><span class="line">     &#125;      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="链表的常见复杂操作："><a href="#链表的常见复杂操作：" class="headerlink" title="链表的常见复杂操作："></a>链表的常见复杂操作：</h3><ul>
<li>两个有序链表的合并：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa = La-&gt;next; pb = Lb-&gt;next;</span><br><span class="line">    Lc = pc = La;</span><br><span class="line">    <span class="keyword">while</span>( pa &amp;&amp; pb )&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class="line">             pc-&gt;next = pa; pc = pa; pa = pa-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">             pc-&gt;next = pb; pc = pb; pb= pb-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = pa ? pa : pb;</span><br><span class="line">    <span class="built_in">free</span>( Lb );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="一些特殊的链表："><a href="#一些特殊的链表：" class="headerlink" title="一些特殊的链表："></a>一些特殊的链表：</h3><ul>
<li>单向循环链表：</li>
<li>图示：  <img src="/2018/05/26/DS-linklist/sigrecyclelink.png" title="单向循环链表">
<img src="/2018/05/26/DS-linklist/mergerecycle.png" title="合并"></li>
<li>多重循环链表：</li>
<li>双向链表：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">     ElemType               data;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>    *<span class="title">prior</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>    *<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode,  *DuLinkList;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>双向循环链表：</p>
<h3 id="探讨："><a href="#探讨：" class="headerlink" title="探讨："></a>探讨：</h3><ul>
<li>链表作为最基础的数据结构，是对其他数据结构：如栈，树等的支撑，其他这些大部分是在链表的基础上建立的；  </li>
<li>从较底层的层面：即深入到内存，链表实现了对零散内存的有效使用，内存在为链表分配空间的时候不用大段的连续空间；</li>
<li>从较高层，即抽象的层面看，链表仅仅是一批数据的拓扑结构之一，就常见的栈，队列，树，图等等，你还可以想出其他可能有用没用的，如，立体的结构，方块，金字塔形(emm这个像堆），还有随意的，感觉想到了矩阵里面的压缩。   </li>
</ul>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul>
<li>链表的应用：如</li>
<li>在文件中，对大文件的存储，采用类似链表的结构，</li>
<li>大数相加，像两个100位的整数相加，使用链表，每个块为一位，就可以解决这个问题，数组也行</li>
<li>倒排索引结构，在操作系统中用到，我的github上放着一个本科毕业设计做的简单搜索引擎，几乎全是自己搞的（解析网页那块自己c写了状态机，觉得效果不如beatifulsoup好，后面用它了),不过想想那会还不会很有意识的去想如果让它运行在大量用户下，各种使用条件（如输入条件下，会怎么样，年轻啊~)</li>
<li>其他，当然是其他数据结构基于链表做的，多了去了</li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>code_efficandreadable</title>
    <url>/2018/05/25/code-efficandreadable/</url>
    <content><![CDATA[<h2 id="论代码的效率和可读性的权衡"><a href="#论代码的效率和可读性的权衡" class="headerlink" title="论代码的效率和可读性的权衡"></a>论代码的效率和可读性的权衡</h2><h4 id="高效代码可读性差："><a href="#高效代码可读性差：" class="headerlink" title="高效代码可读性差："></a>高效代码可读性差：</h4><p>有一些代码，占用额外内存小，即run in place，且执行的速度快，即复杂度O()低，但是可读性差，即使注释了，修改起来也容易出错，如：<br>对链表的操作：举一个leetcode的例子：(这个例子不是很典型，能说明问题即可）<br>    reverse a linklist from m to n;<br>    1-&gt;3-&gt;4-&gt;5-&gt;null and m,n(ex:2,4);<br>    return 1-&gt;5-&gt;4-&gt;2-&gt;null;<br>   上面例子一开始可以想到，头插法，或者将范围内的那一段用新的处理过的链表替换掉，即只需要处理该片段的头和尾部，当然可能还有其他方法，这里先不考虑；<br>   于是，头插法不是很复杂，但是在这里不用额外的内存时，需要频繁的改变next指针和对pre元素做临时保存，使得代码可读性差，所以可以考虑以下方案：<br>   在替换的内存小时，可以采用后者，让代码可读性高些，方便维护和（被替代~更容易被炒鱿鱼的风险哈哈)<br>   在内存小时，采用前者，爱怎么指怎么指，看不懂不管哈哈哈</p>
]]></content>
      <categories>
        <category>代码整洁</category>
      </categories>
      <tags>
        <tag>代码可读性</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_mtu</title>
    <url>/2018/05/20/tcpip-mtu/</url>
    <content><![CDATA[<h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍：</p>
<h3 id="理论部分："><a href="#理论部分：" class="headerlink" title="理论部分："></a>理论部分：</h3><h4 id="１、MTU-Maximum-Transmission-Unit-如何定义"><a href="#１、MTU-Maximum-Transmission-Unit-如何定义" class="headerlink" title="１、MTU(Maximum Transmission Unit)如何定义:"></a>１、MTU(Maximum Transmission Unit)如何定义:</h4><ul>
<li>指的是通信协议中的某一层上面所能通过的最大数据包大小</li>
<li>这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？  <a id="more"></a><br>　答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B&gt;1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:<br>分片：ip净载荷：MTU-IP头：1500-20=1480;<br> 3008B 需要分为3片，3008=1480,1480,48<br>总结：MTU就是MAC承载的载荷的最大值  </li>
</ul>
<h4 id="2、MTU会影响什么"><a href="#2、MTU会影响什么" class="headerlink" title="2、MTU会影响什么:"></a>2、MTU会影响什么:</h4><ul>
<li>数据包太大-&gt;分片重组-&gt;网络性能变差  </li>
<li>数据包太小-&gt;一次能传输的数据小-&gt;网速差  </li>
<li>路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191)　　</li>
</ul>
<h4 id="3、如何知道这个值呢？"><a href="#3、如何知道这个值呢？" class="headerlink" title="3、如何知道这个值呢？"></a>3、如何知道这个值呢？</h4><p>路径最大传输单元发现方法(RFC1191)　　</p>
<ul>
<li>越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。  </li>
<li>MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：<br>ping -c 3 -s 1474 -M do 192.168.0.1<br>PING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.<br>ping: local error: Message too long, mtu=1500<br>提示错误即消息太大且未设置分片</li>
</ul>
<h4 id="4-MTU大小的来源"><a href="#4-MTU大小的来源" class="headerlink" title="4 MTU大小的来源:"></a>4 MTU大小的来源:</h4><p>ref <a href="https://www.zhihu.com/question/31460305/answer/183766816" target="_blank" rel="noopener">https://www.zhihu.com/question/31460305/answer/183766816</a><br>以太网传输帧的最小值：    </p>
<ul>
<li>最早的以太网工作方式：载波多路复用/冲突检测（CSMA/D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。</li>
<li>假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。  </li>
</ul>
<p>为什么标准以太网帧长度上限为1518字节?  </p>
<ul>
<li>IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。</li>
<li>由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 byte那有效传输效率= 160 / 218 = 73%而如果以太网长度为1518，那有效传输效率= 1460 / 1518 = 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题.</li>
<li>于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。</li>
</ul>
<p>其他疑问：  </p>
<ul>
<li>最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？</li>
<li>这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到&gt; 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。</li>
<li>有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度&gt;接口MTU，怎么办？<br>丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。</li>
<li>所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？</li>
<li>我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU = MRU，但比如9000侧的数据到达1500，由于9000 &gt; MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样<h3 id="实践部分："><a href="#实践部分：" class="headerlink" title="实践部分："></a>实践部分：</h3>如何设置MTU：<br>ifconfig eth0 mtu 1460<br>如何查看mtu:<br>netstat -i</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_debug_layout_static</title>
    <url>/2018/05/20/cpp-debug-layout-static/</url>
    <content><![CDATA[<h3 id="c-compile-time-memory-layout"><a href="#c-compile-time-memory-layout" class="headerlink" title="c compile time memory layout"></a>c compile time memory layout</h3><p>　　标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法：</p>
<p>　　概述：首先介绍几个概念：<a id="more"></a><br>　　程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候；<br>　　当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程；<br>      注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码　。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句；</p>
<p>　　本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c</p>
<p>前言：<br>一个源代码通过编译后生成一个目标文件.o它是一个elf　relocatable文件,以下.o文件指此类，elf文件为executable文件<br>.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到</p>
<pre><code>other data  ...
.comment    offset 0x000000c6.
.rodata      ...　　　//const &amp; str 常量
.data
.text
.elf header
</code></pre><p>一个elf文件的结构是这样的：可以通过readelf来看：<br>    　　　　　　　　elfheader　　　　　　　　文件头包含了平台信息：/usr/include/elf.h<br>            .text　　　　　　　　　　　　段表　各个段：应用程序也可以自己定义段，和指定变量在哪个段<br>            .data<br>            .bss<br>            ..<br>            other sections<br>            section header table　　　　<br>            string tables　　　　　　　　重定位表和字符串表<br>            symbol tables　　　　　　　　 符号表是链接的接口<br> 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂<br> 可以通过readelf -s　xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突<br>  强符号和弱符号（强引用和若引用），调试信息　－g<br> 扩展：<br> １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀；<br> 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B  i386 image.jpg image.o<br>   objdump -ht image.o<br>   可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们<br>   具体看文档<br>２）自定义段：<strong>attribute</strong>((section(“FOO”))) int global=24;<br>           <strong>attribute</strong>((section(“BAR”))) void  foo(){}  既可以把变量或函数放入该段中　段名：BAR FOO</p>
<p>正文：</p>
<h4 id="0、先从几个命令："><a href="#0、先从几个命令：" class="headerlink" title="0、先从几个命令："></a>0、先从几个命令：</h4><p>1)size filename:查看elf或.o文件中各个段大小：<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o<br>　　代码段　　　数据段　　<br>代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址<br>数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）<br>bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null</p>
<p>2)其他工具：<br> readelf -a simplest.o<br> 可以看到更清楚的段信息<br> objdump -t simplest<br> objdump -h simplest.o   替代size可以看到更多信息</p>
<p>此时显示出来的一些地址并不是装载后的地址</p>
<p>objdump -s -d xx.o:　　-s 16进制，-d反汇编　　－－－查看代码段<br>objdump -s -x -d xx.o:   –查看数据段和rodata</p>
<p>3)查看目标文件文件属性如relocatable –.o/executable –elf/share object –.so..<br> file xxx</p>
<h4 id="１、从最简单的程序开始：simplest-c"><a href="#１、从最简单的程序开始：simplest-c" class="headerlink" title="１、从最简单的程序开始：simplest.c"></a>１、从最简单的程序开始：simplest.c</h4><pre><code>int main()
{
   return 0;
}
</code></pre><p>将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件：</p>
<pre><code># 1 &quot;simplest.c&quot;
# 1 &quot;&lt;built-in&gt;&quot;
# 1 &quot;&lt;command-line&gt;&quot;
# 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4
# 1 &quot;&lt;command-line&gt;&quot; 2
# 1 &quot;simplest.c&quot;
int main()
 {
  return 0;
 }
</code></pre><p>将它进行汇编：gcc -S simplest.c<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>
<p>生成.o文件：gcc -c simplest.c<br>并通过file xx.o查看类型<br>simplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</p>
<p>通过size 查看各个段：<br>size simplest.o:  可以看到只有代码段，数据为空，bss为空，是比较纯净的</p>
<p>text       data        bss        dec        hex    filename<br>     67          0          0         67         43    simplest.o</p>
<p>接着编译成elf:gcc -o simplest simplest.c<br>file simplest<br>simplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,<br>interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=<br>56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped<br>可以看到连接器等信息</p>
<p>size simplest<br>  text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest<br>注意这里的和.o的文件大小和分段不同，</p>
<h4 id="２、加入头文件和局部变量"><a href="#２、加入头文件和局部变量" class="headerlink" title="２、加入头文件和局部变量"></a>２、加入头文件和局部变量</h4><pre><code>#include&lt;stdio.h&gt;
int main()
{
  int locala;
  int localb=3;
  return 0;
  }
</code></pre><p>进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数<br>汇编，可以看到分配３到内存中<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>
<p>　　生成.o文件：可以看到未改变data和bss,但是代码段变大<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o</p>
<p>生成elf:数据区和bss未改变，代码段也未改变？<br> text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest</p>
<h4 id="３、加入已经初始化的局部静态变量："><a href="#３、加入已经初始化的局部静态变量：" class="headerlink" title="３、加入已经初始化的局部静态变量："></a>３、加入已经初始化的局部静态变量：</h4><pre><code>int main()
{
 static int statica=3;
..
}
</code></pre><p>看生成的汇编：<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2285, @object　//新加的段<br>        .size    statica.2285, 4<br>    statica.2285:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>
<p>.o大小：在静态数据区增加了，４　１个int的长度<br> text       data        bss        dec        hex    filename<br>     74          4          0         78         4e    simplest.o</p>
<p>elf:有点费解，。。<br> text       data        bss        dec        hex    filename<br>   1099        548          4       1651        673    simplest</p>
<h4 id="４、加入已经初始化的全局变量和全局静态变量"><a href="#４、加入已经初始化的全局变量和全局静态变量" class="headerlink" title="４、加入已经初始化的全局变量和全局静态变量"></a>４、加入已经初始化的全局变量和全局静态变量</h4><pre><code>int golbala=6;
    　static long gs=12;
</code></pre><p>生成的汇编<br>        .file    “simplest.c”<br>        .globl    golbala<br>        .data<br>        .align 4<br>        .type    golbala, @object<br>        .size    golbala, 4<br>    golbala://变量名<br>        .long    6<br>        .align 8<br>        .type    gs, @object<br>        .size    gs, 8<br>    gs://变量名<br>        .quad    12<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2287, @object<br>        .size    statica.2287, 4<br>    statica.2287:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>
<p>size : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4=20<br>      text       data        bss        dec        hex    filename<br>       74         20          0         94         5e    simplest.o</p>
<p>elf size:548–&gt;564  16<br>  text       data        bss        dec        hex    filename<br>   1099        564          4       1667        683    simplest</p>
<h4 id="5-将-int-golbala-6"><a href="#5-将-int-golbala-6" class="headerlink" title="5 将 　　int golbala=6;"></a>5 将 　　int golbala=6;</h4><pre><code>　static long gs=12;　　倒换位置！！！！！！！！！
</code></pre><p> 则对齐成：size x.o为：１６比原来小，可以用于节省内存：<br>   text       data        bss        dec        hex    filename<br>     74         16          0         90         5a    simplest.o<br>　　汇编：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2287, @object<br>    .size    statica.2287, 4<br>statica.2287:<br>    .long    3<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits<br>elf文件的也变小：但bss变大，费解。。<br> text       data        bss        dec        hex    filename<br>   1099        560          8       1667        683    simplest</p>
<h4 id="6、加入未初始化的全局变量和全局与局部静态变量"><a href="#6、加入未初始化的全局变量和全局与局部静态变量" class="headerlink" title="6、加入未初始化的全局变量和全局与局部静态变量"></a>6、加入未初始化的全局变量和全局与局部静态变量</h4><pre><code>  1 #include&lt;stdio.h&gt;
    2 static long gs=12;
    3 int golbala=6;
    4      
    5     
    6 static long gsl;
    7 int gi;
    8 int main()
    9 {   
   10      static int staticn;
11      static int statica=3;
   12      int locala;
   13      int localb=3;
   14      return 0;
   15 }
</code></pre><p>汇编没有看到什么变化：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .local    gsl<br>    .comm    gsl,8,8<br>    .comm    gi,4,4<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2290, @object<br>    .size    statica.2290, 4<br>statica.2290:<br>    .long    3<br>    .local    staticn.2289<br>    .comm    staticn.2289,4,4<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits</p>
<p>.o文件：+12 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>     74         16         12        102         66    simplest.o</p>
<p>elf:+16 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>   1099        560         24       1683        693    simplest</p>
<p>至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同</p>
<p>参考：程序员的自我修养</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_debug_layout_dynamic</title>
    <url>/2018/05/20/cpp-debug-layout-dynamic/</url>
    <content><![CDATA[<h3 id="c执行期内存布局和调试："><a href="#c执行期内存布局和调试：" class="headerlink" title="c执行期内存布局和调试："></a>c执行期内存布局和调试：</h3><p>在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等<br>１、将目标文件装入: <a id="more"></a><br><em>１）重定位－－－　放在内存哪里<br> 2)  等待调度执行</em><br>这里可以使用gdb进行调试查看</p>
<p>一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).<br>一个进程主要包括：<br>   在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等</p>
<blockquote>
<p>栈区　　高地址到低地址<br>堆区　　低地址到高地址<br>bss<br>数据<br>代码</p>
</blockquote>
<p> 以下将从两个维度进行对一个程序被执行成进程时，内存的情况：<br> １、各种段区的内存分布<br> ２、gdb 调试程序执行时的过程。－－可能涉及到汇编<br> －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<h4 id="1、gdb-常用的命令和用法："><a href="#1、gdb-常用的命令和用法：" class="headerlink" title="1、gdb　常用的命令和用法："></a>1、gdb　常用的命令和用法：</h4><p>1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令<br> 2)设置断点：　<br>b 行号<br>b 函数名<br>b 行号　if 条件<br>eg:<br>break main  /  b main<br>  删除断点:delete 行号</p>
<p>3)列出代码<br>l /list</p>
<p>4)运行，start<br>  跳转到断点:c/continue   r/run<br>  until  行号　　　运行直到该行<br>5)观察变量b和地址<br>watch b  若变量值发生变化，则程序停止</p>
<p>　p/print  b  看变量值<br>　p/print &amp;b　看变量地址<br> i  locals</p>
<p> info registers 显示所有寄存器的值<br> 查看特定内存位置的值如：<br> print/x $eax   显示为16进制<br> print/t  2进制，　<br> print/d 十进制,<br>x/nyz  : n表示字段数，y为输出格式，z是字段长度</p>
<p>６）单步调试<br> n/next   /   s/step　</p>
<p> 7) 保存断点：<br> info b  查看断点信息<br> save breakpoint fig.dp 保存断点<br> 读取断点文件：　gdb hello -x fig.dp</p>
<p> 退出quit</p>
<p> <a href="http://bbs.chinaunix.net/thread-150524-1-1.html" target="_blank" rel="noopener">http://bbs.chinaunix.net/thread-150524-1-1.html</a></p>
<h4 id="2-使用kdbg"><a href="#2-使用kdbg" class="headerlink" title="2 使用kdbg"></a>2 使用kdbg</h4><p> 界面版本gdb  在gcc … -g后，用kdbg打开即可、<br> 查看程序运行时各个地址：<br>    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHW_ADR(ID,I) printf(<span class="meta-string">"the id %s \t is at adr:%8X\n"</span>,ID,&amp;I);</span></span><br><span class="line"><span class="keyword">extern</span> etext,edata,end;</span><br><span class="line"><span class="keyword">char</span> *cptr=<span class="string">"Hello World\n"</span>;</span><br><span class="line"><span class="keyword">char</span> buffer1[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showit</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">"Adr etext:%8x\tAdr edata:%8x \t Adr end :%8x \n\n"</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class="line">	SHW_ADR(<span class="string">"main"</span>,main);</span><br><span class="line">	SHW_ADR(<span class="string">"showit"</span>,showit);</span><br><span class="line">	SHW_ADR(<span class="string">"cptr"</span>,cptr);</span><br><span class="line">	SHW_ADR(<span class="string">"buffer1"</span>,buffer1);</span><br><span class="line">	SHW_ADR(<span class="string">"i"</span>,i);</span><br><span class="line">	<span class="built_in">strcpy</span>(buffer1,<span class="string">"A demonstration\n"</span>);</span><br><span class="line">	write(<span class="number">1</span>,buffer1,<span class="built_in">strlen</span>(buffer1)+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;<span class="number">1</span>;++i)</span><br><span class="line">		showit(cptr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showit</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *buffer2;</span><br><span class="line">	SHW_ADR(<span class="string">"buffer2"</span>,buffer2);</span><br><span class="line">	<span class="keyword">if</span>((buffer2=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>((<span class="keyword">unsigned</span>)(<span class="built_in">strlen</span>(p)+<span class="number">1</span>)))!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(buffer2,p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s"</span>,buffer2);</span><br><span class="line">		<span class="built_in">free</span>(buffer2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Allocation error.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;alloca.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">afunc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> etext,edata,end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bss_var;				<span class="comment">//no init globel data must be in bss</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data_var=<span class="number">42</span>;			<span class="comment">//init globel data must be in data</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHW_ADR(ID,I) printf(<span class="meta-string">"the %8s\t is at adr:%8x\n"</span>,ID,&amp;I);		<span class="comment">//the macro to printf the addr</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p,*b,*nb;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Adr etext:%8x\t Adr edata %8x\t Adr end %8x\t\n"</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\ntext Location:\n"</span>);</span><br><span class="line">	SHW_ADR(<span class="string">"main"</span>,main);			<span class="comment">//text section function</span></span><br><span class="line">	SHW_ADR(<span class="string">"afunc"</span>,afunc);			<span class="comment">//text section function</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nbss Location:\n"</span>);</span><br><span class="line">	SHW_ADR(<span class="string">"bss_var"</span>,bss_var);		<span class="comment">//bss section var</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\ndata location:\n"</span>);</span><br><span class="line">	SHW_ADR(<span class="string">"data_var"</span>,data_var);	<span class="comment">//data section var</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nStack Locations:\n"</span>);</span><br><span class="line">	afunc();</span><br><span class="line">	</span><br><span class="line">	p=(<span class="keyword">char</span> *)alloca(<span class="number">32</span>);			<span class="comment">//alloc memory from statck</span></span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		SHW_ADR(<span class="string">"start"</span>,p);</span><br><span class="line">		SHW_ADR(<span class="string">"end"</span>,p+<span class="number">31</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	b=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">32</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));	<span class="comment">//malloc memory from heap</span></span><br><span class="line">	nb=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">16</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nHeap Locations:\n"</span>);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the Heap start: %p\n"</span>,b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the Heap end:%p\n"</span>,(nb+<span class="number">16</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>)));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nb and nb in Stack\n"</span>);</span><br><span class="line">	SHW_ADR(<span class="string">"b"</span>,b);</span><br><span class="line">	SHW_ADR(<span class="string">"nb"</span>,nb);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">free</span>(nb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afunc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">long</span> level=<span class="number">0</span>;	<span class="comment">//data section static var</span></span><br><span class="line">	<span class="keyword">int</span>	 stack_var;				<span class="comment">//temp var ,in stack section</span></span><br><span class="line">	<span class="keyword">if</span>(++level==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SHW_ADR(<span class="string">"stack_var in stack section"</span>,stack_var);</span><br><span class="line">	SHW_ADR(<span class="string">"Level in data section"</span>,level);</span><br><span class="line">	afunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title>android_jni</title>
    <url>/2018/05/20/android-jni/</url>
    <content><![CDATA[<h3 id="a-example-of-JNI-static-way"><a href="#a-example-of-JNI-static-way" class="headerlink" title="a example of JNI static way:"></a>a example of JNI static way:</h3><h4 id="first-step-write-a-middle-java-file"><a href="#first-step-write-a-middle-java-file" class="headerlink" title="first step: write a middle java file:"></a>first step: write a middle java file:</h4><p>mkdir jni<br>cd jni/<a id="more"></a><br>vim TestJni.java</p>
<pre><code>import java.util.*;
public class TestJni
{
    public native void xprint(String content);
    static
    {
        System.loadLibrary(&quot;TestJni&quot;);
    }
}
</code></pre><p>  javac TestJni.java  and make a class</p>
<p>then<br>  javah -jni TestJni  to make a .h file:</p>
<pre><code>  /* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class TestJni */

#ifndef _Included_TestJni
#define _Included_TestJni
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     TestJni
 * Method:    xprint
 * Signature: (Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_TestJni_xprint
  (JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif
</code></pre><h4 id="step-two-write-jni-file-c"><a href="#step-two-write-jni-file-c" class="headerlink" title="step two write jni file.c:"></a>step two write jni file.c:</h4><p>TestJni.c:</p>
<pre><code>#include&lt;jni.h&gt;
#include&lt;stdio.h&gt;
#include &quot;TestJni.h&quot;

JNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content)
{
    const jbyte *str=(const jbyte*)(*env)-&gt;GetStringUTFChars(env,content,JNI_FALSE);
    printf(&quot;hello--wo%s \n&quot;,str);
    (*env)-&gt;ReleaseStringUTFChars(env,content,(const char*)str);
    return;
}
</code></pre><h4 id="three-build-so-lib"><a href="#three-build-so-lib" class="headerlink" title="three build .so lib"></a>three build .so lib</h4><pre><code>cc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c
</code></pre><h4 id="four-write-a-test-hellow-java"><a href="#four-write-a-test-hellow-java" class="headerlink" title="four write a test:hellow.java"></a>four write a test:hellow.java</h4><pre><code>import java.util.*;
public class hellow
{
    public static void main(String argc[])
    { 
        new hellow();
    }
    public hellow()
    { 
       new TestJni().xprint(&quot;hi my name is keee&quot;);
    }
}
</code></pre><h4 id="question"><a href="#question" class="headerlink" title="question:"></a>question:</h4><p>如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径：</p>
<p>java -Djava.library.path=’.’ HelloWorld<br>或者输入命令：<br>export LD_LIBRARY_PATH=“HelloWorld路径”:$LD_LIBRARY_PATH   设置环境变量</p>
<p>然后再 java HelloWorld 一样OK</p>
<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html" target="_blank" rel="noopener">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br><a href="http://www.cnblogs.com/wzben/p/5733571.html" target="_blank" rel="noopener">http://www.cnblogs.com/wzben/p/5733571.html</a></p>
<h3 id="a-example-of-JNI-dynamic-way"><a href="#a-example-of-JNI-dynamic-way" class="headerlink" title="a example of JNI dynamic way:"></a>a example of JNI dynamic way:</h3><h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1:"></a>step 1:</h4><p>write a TestJni.java</p>
<pre><code>public class SimpleJni{
    static {
        System.out.println(&quot;[java] static code block,start load shared library...&quot;);
        System.loadLibrary(&quot;SimpleJni&quot;);
        System.out.println(&quot;[java]load library end...&quot;);
    }
    static native int add(int a,int b);
    public static void main(String args[])
    {
        System.out.println(&quot;[java] in main...&quot;);
        System.out.println(&quot;[java] 3+4=&quot;+SimpleJni.add(3,4));
        System.out.println(&quot;end...&quot;);
    }
}
</code></pre><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2:"></a>step 2:</h4><p>write a Jni file:</p>
<pre><code>#include &lt;jni.h&gt;
#include&lt;stdio.h&gt;
const char *classPathName=&quot;com/bt/jni/SimpleJni&quot;;

jint myadd(JNIEnv *env,jobject thiz,jint a,jint b)
{
    return a+b;
}
static JNINativeMethod methods[]={
    {&quot;add&quot;,&quot;(II)I&quot;,(void*)myadd},};
int registerNatives(JNIEnv *env)
{
    jclass clazz;

    clazz=(*env)-&gt;FindClass(env,classPathName);
    if(NULL==clazz){
       printf(&quot;[C] FindClass fail\n&quot;);
       goto failed;
    }
     if (0&gt;(*env)-&gt;RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0]))){
         printf(&quot;RegisterNatives fail.\n&quot;);
         goto failed;
     }
     return JNI_TRUE;
failed:
     return JNI_FALSE;
}


jint JNI_OnLoad(JavaVM *vm,void *reserved)
{
    JNIEnv *env=NULL;
    jint result=-1;
    void **env_p=NULL;

    printf(&quot;start register native func\n&quot;);
    env_p=(void**)&amp;env;

    if(JNI_OK!=(*vm)-&gt;GetEnv(vm,env_p,0x00010006)){
        printf(&quot;get env failed..\n&quot;);
        goto err;
    }
    if(JNI_TRUE!=registerNatives(env)){
        printf(&quot;register fail...exit....\n&quot;);
        goto err;
    }
    result=0x00010006;
err:
    return result;
}
</code></pre><h4 id="step-use"><a href="#step-use" class="headerlink" title="step use:"></a>step use:</h4><p>1.首先编写SimpleJni.java和simpel_jni.c<br>    2.编译java和c文件<br>$ java -d .  SimpleJni.java<br>$gcc -fPIC -I$JAVA_HOME/include/ -I$JAVA_HOME/include/linux/ -o libsimpleJni.so simple_jni.c</p>
<pre><code>3.执行
$java -Djava.library.path=. com.bt.jni.SimpleJni
</code></pre><h4 id="other-example"><a href="#other-example" class="headerlink" title="other example:"></a>other example:</h4><p>java file:<br>    import java.util.*;<br>    public class TestJni<br>    {<br>        public native void xprint(String content);<br>        static<br>        {<br>            System.loadLibrary(“TestJni”);<br>        }<br>        public native static String native_hello();<br>    }</p>
<p>JNI file:</p>
<pre><code>#include&lt;jni.h&gt;
#include&lt;stdio.h&gt;
//#include &quot;TestJni.h&quot;
#include&lt;iostream&gt;
using namespace std;
 void xprint(JNIEnv *env,jobject obj,jstring content)
{  
//    const jbyte *str=(const jbyte*)(env-&gt;GetStringUTFChars(env,content,JNI_FALSE));
    //printf(&quot;hello--wo%s \n&quot;,str);
//    env-&gt;ReleaseStringUTFChars(env,content,(const char*)str);
        cout&lt;&lt;&quot;here:&quot;&lt;&lt;content&lt;&lt;endl;
    return;
}
static jstring  native_hello(JNIEnv *env,jobject object)
{ 


    return (env)-&gt;NewStringUTF(&quot;keshixi&quot;);
}

static JNINativeMethod method_table[]={
    { &quot;xprint&quot;,&quot;(Ljava/lang/String;)V&quot;,(void*)xprint},
    {&quot;native_hello&quot;,&quot;()Ljava/lang/String;&quot;,(void*)native_hello}
//    {,,(void*)xprint},{,,(void*)native_hello}
};

 jint JNI_OnLoad(JavaVM *jvm,void *reserved){
    JNIEnv *env;
    if(jvm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6)!=JNI_OK){
        return -1;
    }
    jclass clz=env-&gt;FindClass(&quot;TestJni&quot;);
    if(clz==NULL)
    {
        return JNI_FALSE;
    }
    if(env-&gt;RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK){
        return JNI_VERSION_1_6;
    }
  }
</code></pre><p>####reference:<br>jni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行</p>
<p>动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子</p>
<p>另外可以作为ndk在android中使用及在android　stdio也可以直接生成so</p>
<p>一些链接：android_jni_ndk:<a href="http://www.cnblogs.com/wzben/p/5733571.html" target="_blank" rel="noopener">http://www.cnblogs.com/wzben/p/5733571.html</a><br>动态注册无运行实例：<a href="http://www.linuxidc.com/Linux/2017-02/140130.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2017-02/140130.htm</a><br>静态注册：<a href="http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html" target="_blank" rel="noopener">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br>动态注册：有实例<a href="http://www.linuxidc.com/Linux/2017-02/140129.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2017-02/140129.htm</a></p>
<p><a href="http://www.fer.unizg.hr/_download/repository/jni.pdf文档" target="_blank" rel="noopener">www.fer.unizg.hr/_download/repository/jni.pdf文档</a>    </p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title>android_adb</title>
    <url>/2018/05/20/android-adb/</url>
    <content><![CDATA[<h4 id="android-adb-command"><a href="#android-adb-command" class="headerlink" title="android adb command"></a>android adb command</h4><p>从android群英传中学习到额外的几个adb指令，是之前没接触到的：<br>adb list targets<br>adb install -r　xx.apk -r为覆盖<br>adb shell df<br><a id="more"></a><br>adb shell pm list packages -f<br>adb shell input keyevent 3　　－－模拟按键输入，这里为点击home建<br>adb shell touchscreen ..模拟滑动<br>adb shell dumpsys 监听Activity运行状态<br>adb shell screenrecord /sdcard/demo.mp4  录制　屏幕<br>adb shell am start -n 包名/包名＋类名</p>
<p>更多，见google　develop中android studio的部分<br>另在源码目录中/system/core/toolbox  和/frameworks/base/cmds为所有ADB命令和shell命令来源</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title>android_AndroidManifest</title>
    <url>/2018/05/20/android-AndroidManifest/</url>
    <content><![CDATA[<h4 id="一个典型的androidmanifest文件："><a href="#一个典型的androidmanifest文件：" class="headerlink" title="一个典型的androidmanifest文件："></a>一个典型的androidmanifest文件：</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.example.ksx.helloworld&quot;&gt;
&lt;!-- more --&gt;
    &lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;hallo&quot;//app的名字和显示在bar上的文字
        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/AppTheme&quot;&gt;
        &lt;activity android:name=&quot;.MainActivity&quot;&gt;//活动的注册
        &lt;android:label=&quot;this is hallo&quot;&gt;//会覆盖上面的
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;//声明为主活动

                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title>android_makefirst_app</title>
    <url>/2018/05/20/android-makefirst-app/</url>
    <content><![CDATA[<h3 id="install-and-make-first-app"><a href="#install-and-make-first-app" class="headerlink" title="install and make first app"></a>install and make first app</h3><p>20170608<br>今天主要是安装了android-studio环境并成功开发第一个helloworld   app 在模拟器和手机上运行，下面是整个教程：在ubuntu下</p>
<h4 id="1-安装java-jdk"><a href="#1-安装java-jdk" class="headerlink" title="1 安装java-jdk:"></a>1 安装java-jdk:<a id="more"></a></h4><p>a  先下载java-jdk:Java SE Development Kit 8 Downloads<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>下载对应系统的版本</p>
<p>b  下载到某个目录，解压到要安装的目录：如：/usr/jdk-8/</p>
<p>c   设置全局环境变量：如上述的安装目录，则将<br>export JAVA_HOME=/usr/jdk-8<br>export JRE_HOME=$JAVA_HOME/jre<br>export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib<br>export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin<br>添加到/etc/profile文件中，在末尾另起一行添加</p>
<p>d 使用source /etc/profile命令使刚才配置的信息生效</p>
<p>e 测试是否成功：java -version<br>测试,编写java文件：<br>public class test{<br>    public static void main(String[] args){<br>        System.out.println(“hello world”);<br>    }<br>}<br>保存为test.java，<br>生成字节码：javac test.java<br>运行:java test</p>
<h3 id="2-安装android-studio"><a href="#2-安装android-studio" class="headerlink" title="2 安装android-studio:"></a>2 安装android-studio:</h3><p>a 下载：在官网或者其他网站下载后<br>b 按照installion说明进行：一般是先选择要安装的目录：如/usr/android-studio<br>c　直接在终端,进入bin目录后:./studio.sh<br>d 还有其他配置．比如在任意目录都能打开软件．<br>e 其他见说明文件等</p>
<p>3 第一个app helloworld<br>在模拟器上运行<br>打开软件－－&gt;选择新建一个工程，适当选择之后-&gt;选择build-&gt;make project-&gt;点击run–<br>–&gt;会提示选择安装下载模拟器–&gt;选择合适的，最好不要是带锁的<br>－－－&gt;之后会提示成功．再选择建立一个模拟器，之后就可以了</p>
<p>注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm<br>如果不能运行x86的，可能需要安装kvm:<br>也可以使用genymotion模拟器</p>
<h4 id="4-安装kvm可选"><a href="#4-安装kvm可选" class="headerlink" title="4 安装kvm可选"></a>4 安装kvm可选</h4><p>要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？<br>那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。<br>首先要确定你的cpu满足要求，下面有几个命令可以参考：</p>
<p>$ egrep -c ‘(vmx|svm)’ /proc/cpuinfo<br>4</p>
<p>打印的值不为0即可。</p>
<p>下面安装kvm：</p>
<p>$ sudo apt-get install qemu-kvm<br>$ sudo adduser linc kvm<br>$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils<br>$ sudo adduser linc libvirtd</p>
<p>(linc为用户名，适当改）<br>检验安装是否成功：</p>
<p>$ sudo virsh -c qemu:///system list</p>
<h2 id="Id-Name-State"><a href="#Id-Name-State" class="headerlink" title=" Id    Name                           State"></a> Id    Name                           State</h2><p>运行，在有模拟器的目录中：<br>如/home/ksx/Android/Sdk/emulator/emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm</p>
<p>使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。</p>
<p>如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。</p>
<h4 id="5在手机上运行app"><a href="#5在手机上运行app" class="headerlink" title="5在手机上运行app"></a>5在手机上运行app</h4><p>首先连接手机，打开usb调试<br>还是一样，但是选择app那里不是app,而是选择Edit Configurations<br>之后选择usb　device，ok，就可以了，接着运行</p>
<h4 id="关于项目结构模式："><a href="#关于项目结构模式：" class="headerlink" title="关于项目结构模式："></a>关于项目结构模式：</h4><p>默认为android<br>设置为project可以看到整个完整的目录结构：<br>　　　　　.gradle和.idea 为自动生成<br>　　　　　app<br>　　　　　build   编译时自动生成的文件，不用太关心<br>　　　　　gradle   包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle<br>     .gitignore<br>     build.gradle<br>     gradle.properties  全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本<br>     gradlew　和gradlew.bat在命令行中执行gradle命令<br>     local.properties　　指定本机android sdk路径<br>     setting.gradle指定项目中引入的模块</p>
<pre><code>app目录下
build　　为自动生成，同上
lib   项目使用的第三方库
test 测试用例
proguard-rules.pro  代码混淆规则
</code></pre><h4 id="build-gradle-intruduce"><a href="#build-gradle-intruduce" class="headerlink" title="build gradle intruduce"></a>build gradle intruduce</h4><p>gradle  Groovy 领域语言　　DSL    摒弃了Ant 和Maven </p>
<p>在app 外有一个 build.gradle。在app中有一个build.gradle</p>
<p>在外面的　gradle 也可以构建c++等项目，<br>buildscript {<br>    repositories {<br>        jcenter()　　　//代码托管仓库　利用它可以轻松引用jcenter开源项目</p>
<pre><code>}
dependencies {
    classpath &apos;com.android.tools.build:gradle:2.3.2&apos;　　//声明构建的是android

    // NOTE: Do not place your application dependencies here; they belong
    // in the individual module build.gradle files
}
</code></pre><p>}</p>
<p>allprojects {<br>    repositories {<br>        jcenter()<br>    }<br>}</p>
<p>task clean(type: Delete) {<br>    delete rootProject.buildDir<br>}</p>
<p>app中<br>apply plugin: ‘com.android.application’　//表明为android 应用程序模块，为com.android.library表示库模块</p>
<p>android {　　　//安卓闭包<br>    compileSdkVersion 25　　　　//项目的编译版本，25为API 25,对应android 7.1<br>    buildToolsVersion “25.0.3”   //项目构建工具版本<br>    defaultConfig {<br>        applicationId “org.example.myactivity1”　　　项目包名<br>        minSdkVersion 25　　　　　//项目最低兼容的android系统版本<br>        targetSdkVersion 25　　//表明如22表示只在22测试充分，如不启动运行时权限，android６　的运行时权限就不会加，表明只在5上做充分测试<br>        versionCode 1　　　项目版本编号<br>        versionName “1.0”　　　项目版本名<br>        testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner”<br>    }<br>    buildTypes {//分debug和release版本<br>        release {<br>            minifyEnabled false　//是否混淆代码<br>            proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’//混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件<br>        }<br>    }<br>}</p>
<p>dependencies {//分本地依赖，库依赖和远程依赖<br>    compile fileTree(dir: ‘libs’, include: [‘*.jar’])　　//本地依赖声明<br>    androidTestCompile(‘com.android.support.test.espresso:espresso-core:2.2.2’, {<br>        exclude group: ‘com.android.support’, module: ‘support-annotations’<br>    })<br>    compile ‘com.android.support:appcompat-v7:25.3.1’　　//　依赖库<br>    compile ‘com.android.support.constraint:constraint-layout:1.0.2’<br>    testCompile ‘junit:junit:4.12’　　//测试用例库<br>}</p>
<p>其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title>android_howto_makeapk_cmd</title>
    <url>/2018/05/20/android-howto-makeapk-cmd/</url>
    <content><![CDATA[<h3 id="how-to-make-a-android-by-cmd"><a href="#how-to-make-a-android-by-cmd" class="headerlink" title="how to make a android by cmd :"></a>how to make a android by cmd :</h3><pre><code>在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni
</code></pre><a id="more"></a>
<h3 id="way-1-方法１"><a href="#way-1-方法１" class="headerlink" title="way 1:方法１"></a>way 1:方法１</h3><h4 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h4><pre><code>android studio 创建了一个工程，然后手动在命令行打包，进入工程里的.  或者direct use andrid create project创建
</code></pre><p>cd ~/Desktop/FirstTest/app/src/main<br>mkdir gen<br>mkdir build<br>mkdir out</p>
<p>在android工程目录下建立Makefile文件，添加如下代码：<br>    SDK=~/Android/Sdk　　　　<br>    BUILD_TOOLS=$(SDK)/build-tools/25.0.3<br>    PLATFORMS=$(SDK)/platforms/android-25<br>    aapt=$(BUILD_TOOLS)/aapt<br>    dx=$(BUILD_TOOLS)/dx<br>    aidl=$(BUILD_TOOLS)/aidl<br>    apkbuilder=$(SDK)/tools/apkbuilder2 //后面不支持apkbuilder所以<br>    adb=$(SDK)/platform-tools/adb</p>
<h4 id="资源编译，生成-R-java"><a href="#资源编译，生成-R-java" class="headerlink" title="资源编译，生成 R.java"></a>资源编译，生成 R.java</h4><pre><code>aapt_task:
    $(aapt) package \
    -f \ #如果编译出来的文件已经存在，强制覆盖
    -M  AndroidManifest.xml  \ # Mainifest.xml 的路径
    -I  $(PLATFORMS)/android.jar \ # 某个版本平台的 android.jar 的路径　#依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...
    -S  res/ \ # res 文件夹路径
    -J gen/ \ # 生成 R.java 的输出目录
    -m  #使得生成的包的目录放在 -J 参数指定的目录
</code></pre><h4 id="代码编译，生成-class"><a href="#代码编译，生成-class" class="headerlink" title="代码编译，生成 .class"></a>代码编译，生成 .class</h4><pre><code>javac_task:
    javac -source 1.7 -target 1.7 \ # 使用 jdk1.8 编译 1.7 的 .class 文件
    -encoding UTF-8 \ 
    -bootclasspath  $(PLATFORMS)/android.jar \ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...
    -d build/ \ #指定放置生成的类文件的位置
    java/thereisnospon/dextest/*.java \
    gen/thereisnospon/dextest/*.java \
</code></pre><h4 id="生成-dex"><a href="#生成-dex" class="headerlink" title="生成 .dex"></a>生成 .dex</h4><pre><code>dx_task:
    $(dx) --dex --output=build/classes.dex \
    build  
</code></pre><h4 id="资源文件初始包"><a href="#资源文件初始包" class="headerlink" title="资源文件初始包"></a>资源文件初始包</h4><pre><code>resapk_task:
    $(aapt) package -f \
    -M  AndroidManifest.xml  \
    -I  $(PLATFORMS)/android.jar \
    -S  res/ \
    -F  out/resources
</code></pre><h4 id="将-dex-文件加入到资源文件初始包中"><a href="#将-dex-文件加入到资源文件初始包中" class="headerlink" title="将.dex 文件加入到资源文件初始包中"></a>将.dex 文件加入到资源文件初始包中</h4><p>　　<br>注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行</p>
<pre><code>apk_task:    
    java -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \
      com.android.sdklib.build.ApkBuilderMain \
      Demo.apk -v -u -z src/main/out/resources\
      -f src/main/build/classes.dex -rf src
</code></pre><h4 id="签名，使用debug的签名"><a href="#签名，使用debug的签名" class="headerlink" title="签名，使用debug的签名"></a>签名，使用debug的签名</h4><pre><code>signer:
    jarsigner -verbose \
    -keystore ~/.android/debug.keystore \
    -storepass android \
    -keypass android \
    Demo.apk  androiddebugkey
</code></pre><h4 id="一次性打包"><a href="#一次性打包" class="headerlink" title="一次性打包"></a>一次性打包</h4><pre><code>pkg: 
    make apk_task
    make signer 
</code></pre><h4 id="卸载apk"><a href="#卸载apk" class="headerlink" title="卸载apk"></a>卸载apk</h4><pre><code>uninstall:
    $(adb) uninstall  thereisnospon.dextest
</code></pre><h4 id="安装apk"><a href="#安装apk" class="headerlink" title="安装apk"></a>安装apk</h4><pre><code>install: 
    $(adb) install out/app.apk
</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>run:<br>    make pkg<br>    make uninstall<br>    make install</p>
<pre><code>$(adb) shell am start -n thereisnospon.dextest/        thereisnospon.dextest.MainActivity  
</code></pre><h3 id="方法２，用gradle"><a href="#方法２，用gradle" class="headerlink" title="方法２，用gradle,"></a>方法２，用gradle,</h3><p>首先用AS 建立工程，之后在工程文件下，之星执行，gradle clean<br>gradle build<br>即生成apk文件</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title>android_will_write</title>
    <url>/2018/05/20/android-will-write/</url>
    <content><![CDATA[<p>#test categories<br>this is the android categories to test </p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_activity</tag>
      </tags>
  </entry>
  <entry>
    <title>test_article_picture</title>
    <url>/2018/05/20/test-article-picture/</url>
    <content><![CDATA[<p>##this is a test of picture with test again in 2019<br><img src="/2018/05/20/test-article-picture/example.jpg" title="This is an example image"><br>end</p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
