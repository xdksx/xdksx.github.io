<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DS_linklist</title>
    <url>/2018/05/26/DS-linklist/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数据结构之线性表："><a href="#数据结构之线性表：" class="headerlink" title="数据结构之线性表："></a>数据结构之线性表：</h2><h3 id="有序表：数组："><a href="#有序表：数组：" class="headerlink" title="有序表：数组："></a>有序表：数组：</h3><h3 id="单链表："><a href="#单链表：" class="headerlink" title="单链表："></a>单链表：</h3><p>链表定义  <span id="more"></span><br>{  </p>
<ul>
<li>数据成员:常见的基本类型或者对象类型均可  </li>
<li>数据关系:在链表中的块的成员在连续的内存中，块与块之间内存位置不连续  </li>
<li>指向块的指针：单链表只有一个next,双链表加上pre</li>
</ul>
<p>}<br>基本运算：<br>{</p>
<ul>
<li>InitList(&amp;L);:初始化链表，在c&#x2F;c++中需要做分配内存，初始化链表头和其值的操作；  </li>
<li>DestroyList(&amp;L); 在销毁时需要free内存  </li>
<li>Length(L);链表的长度是块的个数</li>
<li>GetElem(L,i,&amp;e); 在链表中取元素需要一个一个遍历直到下标值，若为双链表会快些。所以这里取索引值对应的值和取链表的值，效率几乎一样；  </li>
<li>LocateElem(L,e,compare()); 和链表中的元素做对比</li>
<li>InsertElem(&amp;L,i,e); 在链表中插入元素，复杂度O(1),在提供位置的时候，若不提供位置，还需要加搜索的时间</li>
<li>DeleteElem(&amp;L,i,&amp;e); 在链表中删除元素，复杂度O(1)<br>……</li>
</ul>
<p>}<br>eg:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span> </span><br><span class="line">       ElemType data；<span class="comment">//数据域</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>  *<span class="title">next</span>； //指针域</span></span><br><span class="line"><span class="class">&#125; <span class="title">LNode</span>,  *<span class="title">LinkList</span>;</span></span><br><span class="line">LNode  *L;</span><br><span class="line">LinkList  L;</span><br><span class="line">L =  (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">或 L = new LNode;</span><br><span class="line">L-&gt;data;</span><br><span class="line">LNode  L;</span><br><span class="line">L.date</span><br></pre></td></tr></table></figure>
<img src="/2018/05/26/DS-linklist/linklist.png" class="" title="链表示意图">    
<h3 id="链表的两种头部："><a href="#链表的两种头部：" class="headerlink" title="链表的两种头部："></a>链表的两种头部：</h3><ol>
<li>没有头的链表：第一个块就开始存储数据  </li>
<li>任何时候都有头的链表：  第一个块不存储数据，作为头节点，第二个块开始存数据  </li>
<li>应用：在leetcode中的ReverseLinklist中，当反转的是从1开始的时候，若使用的是没有头的，则需要额外判断处理，否则可以统一处理；</li>
</ol>
<img src="/2018/05/26/DS-linklist/headnode.png" class="" title="头节点示意图">  

<h3 id="链表的几个常见操作："><a href="#链表的几个常见操作：" class="headerlink" title="链表的几个常见操作："></a>链表的几个常见操作：</h3><ul>
<li>取第i个元素：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">GetElem_L</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType &amp;e)</span></span><br><span class="line">&#123;<span class="comment">//查找操作</span></span><br><span class="line">    p = L-&gt;next;  </span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; j &lt; i)&#123;</span><br><span class="line">          p = p-&gt;next; </span><br><span class="line">          ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j&gt;i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>插入元素：在第i个位置上插入    <img src="/2018/05/26/DS-linklist/insert.png" class="" title="插入示意图">    
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">  p = L; j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (p &amp;&amp; j &lt; i<span class="number">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class="line">     <span class="keyword">if</span> (!p || j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line">  s =  (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     s-&gt;data = e;  </span><br><span class="line">  s-&gt;next = p-&gt;next;  </span><br><span class="line">  p-&gt;next = s;  </span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
<li>删除元素:删除第i个元素:  <img src="/2018/05/26/DS-linklist/delete.png" class="" title="删除示意图">  
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> Status <span class="title function_">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line"> p = L; j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i<span class="number">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class="line">     <span class="keyword">if</span> (!(p-&gt;next) || j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line"> q = p-&gt;next;</span><br><span class="line">     e = q-&gt;data;  </span><br><span class="line"> p-&gt;next = p-&gt;next-&gt;next;  <span class="comment">//(p-&gt;next = q-&gt;next;)</span></span><br><span class="line"> <span class="built_in">free</span>(q);  </span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="链表的建立："><a href="#链表的建立：" class="headerlink" title="链表的建立："></a>链表的建立：</h3><ul>
<li>头插法：  <img src="/2018/05/26/DS-linklist/headbuild.png" class="" title="头插法示意图">  
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CreateList_L(LinkList &amp;L, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">     L = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span>( i=n; i&gt;<span class="number">0</span>; --i)&#123;</span><br><span class="line">         s = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">         <span class="built_in">scanf</span>( &amp;s-&gt;data);</span><br><span class="line">         s-&gt;next = L-&gt;next; ①</span><br><span class="line">         L-&gt;next = s; ②</span><br><span class="line">     &#125;</span><br><span class="line">&#125;```</span><br><span class="line">+ 尾插法：  </span><br><span class="line">&#123;% asset_img tailbuile.png 尾插法示意图 %&#125;  </span><br><span class="line">```c</span><br><span class="line"><span class="title function_">CreateList_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     tail = L = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span>( i=n; i&gt;<span class="number">0</span>; --i)&#123;</span><br><span class="line">         s = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">         <span class="built_in">scanf</span>( &amp;s-&gt;data);</span><br><span class="line">         tail-&gt;next = s; ①</span><br><span class="line">         tail = s; ②</span><br><span class="line">     &#125;      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="链表的常见复杂操作："><a href="#链表的常见复杂操作：" class="headerlink" title="链表的常见复杂操作："></a>链表的常见复杂操作：</h3><ul>
<li>两个有序链表的合并：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeList_L</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span><br><span class="line">&#123;</span><br><span class="line">    pa = La-&gt;next; pb = Lb-&gt;next;</span><br><span class="line">    Lc = pc = La;</span><br><span class="line">    <span class="keyword">while</span>( pa &amp;&amp; pb )&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class="line">             pc-&gt;next = pa; pc = pa; pa = pa-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">             pc-&gt;next = pb; pc = pb; pb= pb-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = pa ? pa : pb;</span><br><span class="line">    <span class="built_in">free</span>( Lb );</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="一些特殊的链表："><a href="#一些特殊的链表：" class="headerlink" title="一些特殊的链表："></a>一些特殊的链表：</h3><ul>
<li>单向循环链表：</li>
<li>图示：  <img src="/2018/05/26/DS-linklist/sigrecyclelink.png" class="" title="单向循环链表">
<img src="/2018/05/26/DS-linklist/mergerecycle.png" class="" title="合并"></li>
<li>多重循环链表：</li>
<li>双向链表：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">     ElemType               data;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>    *<span class="title">prior</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>    *<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode,  *DuLinkList;</span><br></pre></td></tr></table></figure>
双向循环链表：</li>
</ul>
<h3 id="探讨："><a href="#探讨：" class="headerlink" title="探讨："></a>探讨：</h3><ul>
<li>链表作为最基础的数据结构，是对其他数据结构：如栈，树等的支撑，其他这些大部分是在链表的基础上建立的；  </li>
<li>从较底层的层面：即深入到内存，链表实现了对零散内存的有效使用，内存在为链表分配空间的时候不用大段的连续空间；</li>
<li>从较高层，即抽象的层面看，链表仅仅是一批数据的拓扑结构之一，就常见的栈，队列，树，图等等，你还可以想出其他可能有用没用的，如，立体的结构，方块，金字塔形(emm这个像堆），还有随意的，感觉想到了矩阵里面的压缩。</li>
</ul>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul>
<li>链表的应用：如</li>
<li>在文件中，对大文件的存储，采用类似链表的结构，</li>
<li>大数相加，像两个100位的整数相加，使用链表，每个块为一位，就可以解决这个问题，数组也行</li>
<li>倒排索引结构，在操作系统中用到，我的github上放着一个本科毕业设计做的简单搜索引擎，几乎全是自己搞的（解析网页那块自己c写了状态机，觉得效果不如beatifulsoup好，后面用它了),不过想想那会还不会很有意识的去想如果让它运行在大量用户下，各种使用条件（如输入条件下，会怎么样，年轻啊~)</li>
<li>其他，当然是其他数据结构基于链表做的，多了去了</li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>DS_string</title>
    <url>/2018/06/24/DS-string/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数据结构之串"><a href="#数据结构之串" class="headerlink" title="数据结构之串"></a>数据结构之串</h3><p>欢迎来到简单而又复杂的串世界,博主许久没有去研究串，还停留在以前学习和使用串的水平，再来一波学习和归纳，发现串的基本用法其实简单，也好理解，但是衍生出来的和应用相关，而且复杂，下面道来；<span id="more"></span></p>
<h4 id="串的基本"><a href="#串的基本" class="headerlink" title="串的基本"></a>串的基本</h4><h5 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h5><ul>
<li>“a1a2…..an”,其中包含字母，广义上可以是任意字符</li>
<li>在c&#x2F;c++中结尾带’\0’，python则不带，长度均不包含’\0’</li>
<li>串长度-不同编码不同，根据具体需要如字节，实际字符等</li>
<li>空串和空白串，空白又可能是tab,回车，空格等等“</li>
<li>串的子串:子串个数：n(n+1)&#x2F;2–等差数列，<h5 id="串常用的数据结构"><a href="#串常用的数据结构" class="headerlink" title="串常用的数据结构"></a>串常用的数据结构</h5></li>
<li>串常量–存在从汇编去看－数据段(data)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    .file	<span class="string">&quot;test.c&quot;</span></span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">&quot;kesance&quot;</span></span><br><span class="line">.LC1:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">&quot;%d\n&quot;</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br></pre></td></tr></table></figure></li>
<li>串数组:<br>将字符串存在顺序数组中</li>
<li>堆分配存在链表中<h5 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h5></li>
<li>子串个数：</li>
<li>串赋值</li>
<li>串比较</li>
<li>求串长</li>
<li>串拼接</li>
<li>求子串</li>
<li>替换子串</li>
<li>定位子串的位置<h4 id="字符编码和字符串匹配"><a href="#字符编码和字符串匹配" class="headerlink" title="字符编码和字符串匹配"></a>字符编码和字符串匹配</h4><h5 id="字符串的编码"><a href="#字符串的编码" class="headerlink" title="字符串的编码"></a>字符串的编码</h5></li>
<li>所谓字符编码，就是将字符用二进制唯一表示。在计算机的世界里不是1就是0，无论什么字符最后存入的还是二进制数，只是从内存中读出来时解析不同而已，即如让计算机将读出来的00111000解析成数字8,如文本显示程序，当设定为某种编码时，将字节流解析成对应的字符～现在看到的许多字体库也是这样的，将一串二进制串和某个字体对应起来，解析程序负责处理匹配和显示等</li>
<li><a href="https://en.wikipedia.org/wiki/Unicode">https://en.wikipedia.org/wiki/Unicode</a>　unicode编码了解一下</li>
</ul>
<h5 id="传统模式匹配算法"><a href="#传统模式匹配算法" class="headerlink" title="传统模式匹配算法"></a>传统模式匹配算法</h5><p>模式匹配，就是在字符串里面匹配另一个串相似或者相同的子串，传统的想法也和一般人想到的一样，扫描并一个一个字符对比，若第二串失配，则第二串重新匹配第一串的第二个，接着往下。。</p>
<h5 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h5><p>kmp作为完全匹配算法中的高效算法，基本原理如下：ps:大学学这个算法只学了它是什么原理，还没去想为什么这么做等）</p>
<ul>
<li><p><strong>基本思想</strong>：从上面看传统的匹配算法：  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> e f g </span><br><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> d <span class="selector-tag">a</span> e f```</span><br><span class="line">像上面的字符串匹配，第一次失配的地方是在c,则按照传统的方式，则应该重新：</span><br></pre></td></tr></table></figure>
<p> a b c a e f g<br>   a b d a e f &#96;&#96;&#96;<br>但是其实如果是我们人去做匹配时，则会直接从：  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">    <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> e f g</span><br><span class="line">          <span class="selector-tag">a</span> <span class="selector-tag">b</span> d <span class="selector-tag">a</span> e f ```</span><br><span class="line"> 开始匹配，而kmp的基本思想也是这样；</span><br><span class="line">例子：</span><br></pre></td></tr></table></figure>
<p> a b c d a b c f g e<br> a b c e a b c t<br> 第一次失配在d,那下一次应该在<br> a b c d a b c f g e<br>   a b c e a b c t&#96;&#96;&#96;</p>
</li>
<li><p>所以它分为两部分，１是模式串在移动时候遵循的基本原理，２是当失配时，模式串的哪个位置的字符和源串的当前位置进行重新匹配；</p>
</li>
<li><p>1基本原理，重复：当模式串中存在大量的重复时，效果尤为明显<br><code>a b c d a b c e f g  a b c d a b c t</code><br>上述例子一样，可以看到 以d 为中点，前后有相同的串，abc,则显然next函数也能隐士检测到这个，所以当显然因为模式串的前后abc相等，而后abc又和源串的后abc相等，所以源串的后abc和模式串的前abc想等，自然失配时候就可以从模式串的d开始匹配起</p>
</li>
<li><p><strong>2重点在next的计算，它决定当发生失配时，模式串如何移动</strong>：  </p>
<ul>
<li>假设模式串为P,j是当前模式串正在匹配的位置，源串为S,i是源串的当前位置，k是当P[j]!&#x3D;S[i]时，P应该和S[i]比较的位置，以next[j]&#x3D;k表示，故关键是求出next数组，显然k&lt;j</li>
<li>next如何计算得到:其实要利用前面的基本原理，<br> P[0-k-1]&#x3D;&#x3D;P[j-k~j-1]&#x3D;&#x3D;S[i-k到i-1] (即next[j]&#x3D;k)<br> 所以要求next[j+1]&#x3D;?</li>
</ul>
<p> -若P[k]&#x3D;&#x3D;P[j]<br> P[0-k-1]+P[k]&#x3D;&#x3D;P[j-k~j-1]+P[j]<br> 即：P[0 ~ k] &#x3D;&#x3D; P[j-k ~ j]，即next[j+1] &#x3D;&#x3D; k + 1 &#x3D;&#x3D; next[j] + 1<br> -若P[k]!&#x3D;P[j]<br>我们已经知道（0，k-1）串和（j-k,j-1）串是相等的，所以可以把（0，k-1）串当做一个新的模式串，发现在新模式串中<br>（0，next[k]-1）串与（k-next[k],k-1）串相等，所以（j-k,j-1）中存在与（0，next[k]-1）相等的串，所以可以把j移动到next[k],继续比较和移动。</p>
</li>
<li><p>具体程序：<br><code>c //显然，next[0]=-1,此时无法向左边移动了源串模式串都要移动 next[1]=0,此时只能向左移动到0. int getnext(char *P,int next[])&#123;   j=1,next[j]=0,k=0;   while(j&lt;sizeof(P)&#123; if(k==0||P[j++]==P[k++])       next[j]==k;//next[j]=next[j]+1 else      k=next[k];      &#125;      &#125;</code></p>
</li>
</ul>
<h5 id="串和哈夫曼编码"><a href="#串和哈夫曼编码" class="headerlink" title="串和哈夫曼编码"></a>串和哈夫曼编码</h5><ul>
<li>霍夫曼编码是和编码相关的一个算法，是将一个串编码为二进制整数，如类似AABXBDHADFBFJD编码为1010011100011101001,而霍夫曼编码则作为转换算法，Huffman编码使得每一个字符的编码都与另一个字符编码的前一部分不同，不会出现像’A’：00，  ’B’：001，这样的情况，解码也不会出现冲突。</li>
</ul>
<h4 id="论文查重对比的几个算法-文本相似度）"><a href="#论文查重对比的几个算法-文本相似度）" class="headerlink" title="论文查重对比的几个算法(文本相似度）"></a>论文查重对比的几个算法(文本相似度）</h4><ul>
<li>杰卡德（Jaccard）相似系数<br>这种相似度计算方式相对简单，原理也易于理解，就是计算单词集合之间的交集和并集大小的比例，该值越大，表示两个文本越相似。在涉及到大规模并行计算时，该方法效率上有一定的优势。</li>
<li>余弦（Cosine）相似度<br>余弦相似度是利用计算两个向量之间的夹角，夹角越小相似度越高，其公式为：<br>假定A和B是两个n维向量，A是[A1,A2,…,An],B是[B1,B2,B3,…,Bn],则A与B的夹角余弦等于</li>
<li>等等,用时再看：<br> <a href="https://www.cnblogs.com/huilixieqi/p/6493089.html">https://www.cnblogs.com/huilixieqi/p/6493089.html</a></li>
<li>linux下的diff命令<br>还有win上的beyondcompare软件，这两个是用于比较文本的差异的，在代码移植时经常用到</li>
</ul>
<h4 id="串匹配－正则表达式"><a href="#串匹配－正则表达式" class="headerlink" title="串匹配－正则表达式"></a>串匹配－正则表达式</h4><ul>
<li>正则表达式用于匹配文本字符串，但是并不一定是完全匹配，且是匹配的串出现有随意性</li>
</ul>
<h5 id="正则表达式的理论基础"><a href="#正则表达式的理论基础" class="headerlink" title="正则表达式的理论基础"></a>正则表达式的理论基础</h5><ul>
<li>最早接触到正则表达式，是在大三学习编译原理的时候，解析词法语法的时候会用到正则表达式，用来过滤关键词，像c语言的很多关键词，以及判断它是不是合法的表达式，等等，常用的是lex和yacc,最原始的是自己的实现对词法和语法的解析，而不借助的lex；</li>
<li>正则表达，语法树，常用有限状态机来来实现，功能强大的如图灵机；</li>
</ul>
<h5 id="正则表达式和编译原理"><a href="#正则表达式和编译原理" class="headerlink" title="正则表达式和编译原理"></a>正则表达式和编译原理</h5><h5 id="正则表达式的基本实现"><a href="#正则表达式的基本实现" class="headerlink" title="正则表达式的基本实现"></a>正则表达式的基本实现</h5><ul>
<li>用c实现正则表达实现词法分析：</li>
<li><h5 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h5></li>
<li>语言支持</li>
<li>脚本语言支持情况</li>
<li>sed,awk</li>
</ul>
<h4 id="串和流"><a href="#串和流" class="headerlink" title="串和流"></a>串和流</h4><ul>
<li>流，所有的文本流</li>
<li>流分为二进制流和文本流</li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>android_AndroidManifest</title>
    <url>/2018/05/20/android-AndroidManifest/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="一个典型的androidmanifest文件："><a href="#一个典型的androidmanifest文件：" class="headerlink" title="一个典型的androidmanifest文件："></a>一个典型的androidmanifest文件：</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.example.ksx.helloworld&quot;&gt;
&lt;!-- more --&gt;
    &lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;hallo&quot;//app的名字和显示在bar上的文字
        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/AppTheme&quot;&gt;
        &lt;activity android:name=&quot;.MainActivity&quot;&gt;//活动的注册
        &lt;android:label=&quot;this is hallo&quot;&gt;//会覆盖上面的
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;//声明为主活动

                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title>android_adb</title>
    <url>/2018/05/20/android-adb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="android-adb-command"><a href="#android-adb-command" class="headerlink" title="android adb command"></a>android adb command</h4><p>从android群英传中学习到额外的几个adb指令，是之前没接触到的：<br>adb list targets<br>adb install -r　xx.apk -r为覆盖<br>adb shell df</p>
<span id="more"></span>
<p>adb shell pm list packages -f<br>adb shell input keyevent 3　　－－模拟按键输入，这里为点击home建<br>adb shell touchscreen ..模拟滑动<br>adb shell dumpsys 监听Activity运行状态<br>adb shell screenrecord &#x2F;sdcard&#x2F;demo.mp4  录制　屏幕<br>adb shell am start -n 包名&#x2F;包名＋类名</p>
<p>更多，见google　develop中android studio的部分<br>另在源码目录中&#x2F;system&#x2F;core&#x2F;toolbox  和&#x2F;frameworks&#x2F;base&#x2F;cmds为所有ADB命令和shell命令来源</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title>android_howto_makeapk_cmd</title>
    <url>/2018/05/20/android-howto-makeapk-cmd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="how-to-make-a-android-by-cmd"><a href="#how-to-make-a-android-by-cmd" class="headerlink" title="how to make a android by cmd :"></a>how to make a android by cmd :</h3><pre><code> 在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni
</code></pre>
<span id="more"></span>

<h3 id="way-1-方法１"><a href="#way-1-方法１" class="headerlink" title="way 1:方法１"></a>way 1:方法１</h3><h4 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h4><pre><code> android studio 创建了一个工程，然后手动在命令行打包，进入工程里的.  或者direct use andrid create project创建
</code></pre>
<p>cd ~&#x2F;Desktop&#x2F;FirstTest&#x2F;app&#x2F;src&#x2F;main<br>mkdir gen<br>mkdir build<br>mkdir out</p>
<p>在android工程目录下建立Makefile文件，添加如下代码：<br>    SDK&#x3D;~&#x2F;Android&#x2F;Sdk　　　　<br>    BUILD_TOOLS&#x3D;$(SDK)&#x2F;build-tools&#x2F;25.0.3<br>    PLATFORMS&#x3D;$(SDK)&#x2F;platforms&#x2F;android-25<br>    aapt&#x3D;$(BUILD_TOOLS)&#x2F;aapt<br>    dx&#x3D;$(BUILD_TOOLS)&#x2F;dx<br>    aidl&#x3D;$(BUILD_TOOLS)&#x2F;aidl<br>    apkbuilder&#x3D;$(SDK)&#x2F;tools&#x2F;apkbuilder2 &#x2F;&#x2F;后面不支持apkbuilder所以<br>    adb&#x3D;$(SDK)&#x2F;platform-tools&#x2F;adb</p>
<h4 id="资源编译，生成-R-java"><a href="#资源编译，生成-R-java" class="headerlink" title="资源编译，生成 R.java"></a>资源编译，生成 R.java</h4><pre><code>aapt_task:
    $(aapt) package \
    -f \ #如果编译出来的文件已经存在，强制覆盖
    -M  AndroidManifest.xml  \ # Mainifest.xml 的路径
    -I  $(PLATFORMS)/android.jar \ # 某个版本平台的 android.jar 的路径　#依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...
    -S  res/ \ # res 文件夹路径
    -J gen/ \ # 生成 R.java 的输出目录
    -m  #使得生成的包的目录放在 -J 参数指定的目录
</code></pre>
<h4 id="代码编译，生成-class"><a href="#代码编译，生成-class" class="headerlink" title="代码编译，生成 .class"></a>代码编译，生成 .class</h4><pre><code>javac_task:
    javac -source 1.7 -target 1.7 \ # 使用 jdk1.8 编译 1.7 的 .class 文件
    -encoding UTF-8 \ 
    -bootclasspath  $(PLATFORMS)/android.jar \ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...
    -d build/ \ #指定放置生成的类文件的位置
    java/thereisnospon/dextest/*.java \
    gen/thereisnospon/dextest/*.java \
</code></pre>
<h4 id="生成-dex"><a href="#生成-dex" class="headerlink" title="生成 .dex"></a>生成 .dex</h4><pre><code>dx_task:
    $(dx) --dex --output=build/classes.dex \
    build  
</code></pre>
<h4 id="资源文件初始包"><a href="#资源文件初始包" class="headerlink" title="资源文件初始包"></a>资源文件初始包</h4><pre><code>resapk_task:
    $(aapt) package -f \
    -M  AndroidManifest.xml  \
    -I  $(PLATFORMS)/android.jar \
    -S  res/ \
    -F  out/resources
</code></pre>
<h4 id="将-dex-文件加入到资源文件初始包中"><a href="#将-dex-文件加入到资源文件初始包中" class="headerlink" title="将.dex 文件加入到资源文件初始包中"></a>将.dex 文件加入到资源文件初始包中</h4><p>　　<br>注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行</p>
<pre><code>apk_task:    
    java -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \
      com.android.sdklib.build.ApkBuilderMain \
      Demo.apk -v -u -z src/main/out/resources\
      -f src/main/build/classes.dex -rf src
</code></pre>
<h4 id="签名，使用debug的签名"><a href="#签名，使用debug的签名" class="headerlink" title="签名，使用debug的签名"></a>签名，使用debug的签名</h4><pre><code>signer:
    jarsigner -verbose \
    -keystore ~/.android/debug.keystore \
    -storepass android \
    -keypass android \
    Demo.apk  androiddebugkey
</code></pre>
<h4 id="一次性打包"><a href="#一次性打包" class="headerlink" title="一次性打包"></a>一次性打包</h4><pre><code>pkg: 
    make apk_task
    make signer 
</code></pre>
<h4 id="卸载apk"><a href="#卸载apk" class="headerlink" title="卸载apk"></a>卸载apk</h4><pre><code>uninstall:
    $(adb) uninstall  thereisnospon.dextest
</code></pre>
<h4 id="安装apk"><a href="#安装apk" class="headerlink" title="安装apk"></a>安装apk</h4><pre><code>install: 
    $(adb) install out/app.apk
</code></pre>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>run:<br>    make pkg<br>    make uninstall<br>    make install</p>
<pre><code>    $(adb) shell am start -n thereisnospon.dextest/        thereisnospon.dextest.MainActivity  
</code></pre>
<h3 id="方法２，用gradle"><a href="#方法２，用gradle" class="headerlink" title="方法２，用gradle,"></a>方法２，用gradle,</h3><p>首先用AS 建立工程，之后在工程文件下，之星执行，gradle clean<br>gradle build<br>即生成apk文件</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title>android_jni</title>
    <url>/2018/05/20/android-jni/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="a-example-of-JNI-static-way"><a href="#a-example-of-JNI-static-way" class="headerlink" title="a example of JNI static way:"></a>a example of JNI static way:</h3><h4 id="first-step-write-a-middle-java-file"><a href="#first-step-write-a-middle-java-file" class="headerlink" title="first step: write a middle java file:"></a>first step: write a middle java file:</h4><p>mkdir jni<br>cd jni&#x2F;<span id="more"></span><br>vim TestJni.java</p>
<pre><code>import java.util.*;
public class TestJni
&#123;
    public native void xprint(String content);
    static
    &#123;
        System.loadLibrary(&quot;TestJni&quot;);
    &#125;
&#125;
</code></pre>
<p>  javac TestJni.java  and make a class</p>
<p>then<br>  javah -jni TestJni  to make a .h file:</p>
<pre><code>  /* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class TestJni */

#ifndef _Included_TestJni
#define _Included_TestJni
#ifdef __cplusplus
extern &quot;C&quot; &#123;
#endif
/*
 * Class:     TestJni
 * Method:    xprint
 * Signature: (Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_TestJni_xprint
  (JNIEnv *, jobject, jstring);

#ifdef __cplusplus
&#125;
#endif
#endif
</code></pre>
<h4 id="step-two-write-jni-file-c"><a href="#step-two-write-jni-file-c" class="headerlink" title="step two write jni file.c:"></a>step two write jni file.c:</h4><p>TestJni.c:</p>
<pre><code>#include&lt;jni.h&gt;
#include&lt;stdio.h&gt;
#include &quot;TestJni.h&quot;

JNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content)
&#123;
    const jbyte *str=(const jbyte*)(*env)-&gt;GetStringUTFChars(env,content,JNI_FALSE);
    printf(&quot;hello--wo%s \n&quot;,str);
    (*env)-&gt;ReleaseStringUTFChars(env,content,(const char*)str);
    return;
&#125;
</code></pre>
<h4 id="three-build-so-lib"><a href="#three-build-so-lib" class="headerlink" title="three build .so lib"></a>three build .so lib</h4><pre><code>cc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c
</code></pre>
<h4 id="four-write-a-test-hellow-java"><a href="#four-write-a-test-hellow-java" class="headerlink" title="four write a test:hellow.java"></a>four write a test:hellow.java</h4><pre><code>import java.util.*;
public class hellow
&#123;
    public static void main(String argc[])
    &#123; 
        new hellow();
    &#125;
    public hellow()
    &#123; 
       new TestJni().xprint(&quot;hi my name is keee&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="question"><a href="#question" class="headerlink" title="question:"></a>question:</h4><p>如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径：</p>
<p>java -Djava.library.path&#x3D;’.’ HelloWorld<br>或者输入命令：<br>export LD_LIBRARY_PATH&#x3D;“HelloWorld路径”:$LD_LIBRARY_PATH   设置环境变量</p>
<p>然后再 java HelloWorld 一样OK</p>
<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br><a href="http://www.cnblogs.com/wzben/p/5733571.html">http://www.cnblogs.com/wzben/p/5733571.html</a></p>
<h3 id="a-example-of-JNI-dynamic-way"><a href="#a-example-of-JNI-dynamic-way" class="headerlink" title="a example of JNI dynamic way:"></a>a example of JNI dynamic way:</h3><h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1:"></a>step 1:</h4><p>write a TestJni.java</p>
<pre><code>public class SimpleJni&#123;
    static &#123;
        System.out.println(&quot;[java] static code block,start load shared library...&quot;);
        System.loadLibrary(&quot;SimpleJni&quot;);
        System.out.println(&quot;[java]load library end...&quot;);
    &#125;
    static native int add(int a,int b);
    public static void main(String args[])
    &#123;
        System.out.println(&quot;[java] in main...&quot;);
        System.out.println(&quot;[java] 3+4=&quot;+SimpleJni.add(3,4));
        System.out.println(&quot;end...&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2:"></a>step 2:</h4><p>write a Jni file:<br>    #include &lt;jni.h&gt;<br>    #include&lt;stdio.h&gt;<br>    const char *classPathName&#x3D;”com&#x2F;bt&#x2F;jni&#x2F;SimpleJni”;</p>
<pre><code>jint myadd(JNIEnv *env,jobject thiz,jint a,jint b)
&#123;
    return a+b;
&#125;
static JNINativeMethod methods[]=&#123;
    &#123;&quot;add&quot;,&quot;(II)I&quot;,(void*)myadd&#125;,&#125;;
int registerNatives(JNIEnv *env)
&#123;
    jclass clazz;

    clazz=(*env)-&gt;FindClass(env,classPathName);
    if(NULL==clazz)&#123;
       printf(&quot;[C] FindClass fail\n&quot;);
       goto failed;
    &#125;
     if (0&gt;(*env)-&gt;RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0])))&#123;
         printf(&quot;RegisterNatives fail.\n&quot;);
         goto failed;
     &#125;
     return JNI_TRUE;
failed:
     return JNI_FALSE;
&#125;


jint JNI_OnLoad(JavaVM *vm,void *reserved)
&#123;
    JNIEnv *env=NULL;
    jint result=-1;
    void **env_p=NULL;

    printf(&quot;start register native func\n&quot;);
    env_p=(void**)&amp;env;

    if(JNI_OK!=(*vm)-&gt;GetEnv(vm,env_p,0x00010006))&#123;
        printf(&quot;get env failed..\n&quot;);
        goto err;
    &#125;
    if(JNI_TRUE!=registerNatives(env))&#123;
        printf(&quot;register fail...exit....\n&quot;);
        goto err;
    &#125;
    result=0x00010006;
err:
    return result;
&#125;
</code></pre>
<h4 id="step-use"><a href="#step-use" class="headerlink" title="step use:"></a>step use:</h4><p>1.首先编写SimpleJni.java和simpel_jni.c<br>    2.编译java和c文件<br>$ java -d .  SimpleJni.java<br>$gcc -fPIC -I$JAVA_HOME&#x2F;include&#x2F; -I$JAVA_HOME&#x2F;include&#x2F;linux&#x2F; -o libsimpleJni.so simple_jni.c</p>
<pre><code>3.执行
$java -Djava.library.path=. com.bt.jni.SimpleJni
</code></pre>
<h4 id="other-example"><a href="#other-example" class="headerlink" title="other example:"></a>other example:</h4><p>java file:<br>    import java.util.*;<br>    public class TestJni<br>    {<br>        public native void xprint(String content);<br>        static<br>        {<br>            System.loadLibrary(“TestJni”);<br>        }<br>        public native static String native_hello();<br>    }</p>
<p>JNI file:</p>
<pre><code>#include&lt;jni.h&gt;
#include&lt;stdio.h&gt;
//#include &quot;TestJni.h&quot;
#include&lt;iostream&gt;
using namespace std;
 void xprint(JNIEnv *env,jobject obj,jstring content)
&#123;  
//    const jbyte *str=(const jbyte*)(env-&gt;GetStringUTFChars(env,content,JNI_FALSE));
    //printf(&quot;hello--wo%s \n&quot;,str);
//    env-&gt;ReleaseStringUTFChars(env,content,(const char*)str);
        cout&lt;&lt;&quot;here:&quot;&lt;&lt;content&lt;&lt;endl;
    return;
&#125;
static jstring  native_hello(JNIEnv *env,jobject object)
&#123; 

    
    return (env)-&gt;NewStringUTF(&quot;keshixi&quot;);
&#125;

static JNINativeMethod method_table[]=&#123;
    &#123; &quot;xprint&quot;,&quot;(Ljava/lang/String;)V&quot;,(void*)xprint&#125;,
    &#123;&quot;native_hello&quot;,&quot;()Ljava/lang/String;&quot;,(void*)native_hello&#125;
//    &#123;,,(void*)xprint&#125;,&#123;,,(void*)native_hello&#125;
&#125;;

 jint JNI_OnLoad(JavaVM *jvm,void *reserved)&#123;
    JNIEnv *env;
    if(jvm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6)!=JNI_OK)&#123;
        return -1;
    &#125;
    jclass clz=env-&gt;FindClass(&quot;TestJni&quot;);
    if(clz==NULL)
    &#123;
        return JNI_FALSE;
    &#125;
    if(env-&gt;RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK)&#123;
        return JNI_VERSION_1_6;
    &#125;
  &#125;
</code></pre>
<p>####reference:<br>jni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行</p>
<p>动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子</p>
<p>另外可以作为ndk在android中使用及在android　stdio也可以直接生成so</p>
<p>一些链接：android_jni_ndk:<a href="http://www.cnblogs.com/wzben/p/5733571.html">http://www.cnblogs.com/wzben/p/5733571.html</a><br>动态注册无运行实例：<a href="http://www.linuxidc.com/Linux/2017-02/140130.htm">http://www.linuxidc.com/Linux/2017-02/140130.htm</a><br>静态注册：<a href="http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br>动态注册：有实例<a href="http://www.linuxidc.com/Linux/2017-02/140129.htm">http://www.linuxidc.com/Linux/2017-02/140129.htm</a></p>
<p><a href="http://www.fer.unizg.hr/_download/repository/jni.pdf%E6%96%87%E6%A1%A3">www.fer.unizg.hr/_download/repository/jni.pdf文档</a>    </p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title>android_will_write</title>
    <url>/2018/05/20/android-will-write/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#test categories<br>this is the android categories to test </p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_activity</tag>
      </tags>
  </entry>
  <entry>
    <title>android_makefirst_app</title>
    <url>/2018/05/20/android-makefirst-app/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="install-and-make-first-app"><a href="#install-and-make-first-app" class="headerlink" title="install and make first app"></a>install and make first app</h3><p>20170608<br>今天主要是安装了android-studio环境并成功开发第一个helloworld   app 在模拟器和手机上运行，下面是整个教程：在ubuntu下</p>
<h4 id="1-安装java-jdk"><a href="#1-安装java-jdk" class="headerlink" title="1 安装java-jdk:"></a>1 安装java-jdk:<span id="more"></span></h4><p>a  先下载java-jdk:Java SE Development Kit 8 Downloads<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>下载对应系统的版本</p>
<p>b  下载到某个目录，解压到要安装的目录：如：&#x2F;usr&#x2F;jdk-8&#x2F;</p>
<p>c   设置全局环境变量：如上述的安装目录，则将<br>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;jdk-8<br>export JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre<br>export CLASSPATH&#x3D;.:$CLASSPATH:$JAVA_HOME&#x2F;lib:$JRE_HOME&#x2F;lib<br>export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin<br>添加到&#x2F;etc&#x2F;profile文件中，在末尾另起一行添加</p>
<p>d 使用source &#x2F;etc&#x2F;profile命令使刚才配置的信息生效</p>
<p>e 测试是否成功：java -version<br>测试,编写java文件：<br>public class test{<br>    public static void main(String[] args){<br>        System.out.println(“hello world”);<br>    }<br>}<br>保存为test.java，<br>生成字节码：javac test.java<br>运行:java test</p>
<h3 id="2-安装android-studio"><a href="#2-安装android-studio" class="headerlink" title="2 安装android-studio:"></a>2 安装android-studio:</h3><p>a 下载：在官网或者其他网站下载后<br>b 按照installion说明进行：一般是先选择要安装的目录：如&#x2F;usr&#x2F;android-studio<br>c　直接在终端,进入bin目录后:.&#x2F;studio.sh<br>d 还有其他配置．比如在任意目录都能打开软件．<br>e 其他见说明文件等</p>
<p>3 第一个app helloworld<br>在模拟器上运行<br>打开软件－－&gt;选择新建一个工程，适当选择之后-&gt;选择build-&gt;make project-&gt;点击run–<br>–&gt;会提示选择安装下载模拟器–&gt;选择合适的，最好不要是带锁的<br>－－－&gt;之后会提示成功．再选择建立一个模拟器，之后就可以了</p>
<p>注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm<br>如果不能运行x86的，可能需要安装kvm:<br>也可以使用genymotion模拟器</p>
<h4 id="4-安装kvm可选"><a href="#4-安装kvm可选" class="headerlink" title="4 安装kvm可选"></a>4 安装kvm可选</h4><p>要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？<br>那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。<br>首先要确定你的cpu满足要求，下面有几个命令可以参考：</p>
<p>$ egrep -c ‘(vmx|svm)’ &#x2F;proc&#x2F;cpuinfo<br>4</p>
<p>打印的值不为0即可。</p>
<p>下面安装kvm：</p>
<p>$ sudo apt-get install qemu-kvm<br>$ sudo adduser linc kvm<br>$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils<br>$ sudo adduser linc libvirtd</p>
<p>(linc为用户名，适当改）<br>检验安装是否成功：</p>
<p>$ sudo virsh -c qemu:&#x2F;&#x2F;&#x2F;system list<br> Id    Name                           State</p>
<hr>
<p>运行，在有模拟器的目录中：<br>如&#x2F;home&#x2F;ksx&#x2F;Android&#x2F;Sdk&#x2F;emulator&#x2F;emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm</p>
<p>使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。</p>
<p>如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。</p>
<h4 id="5在手机上运行app"><a href="#5在手机上运行app" class="headerlink" title="5在手机上运行app"></a>5在手机上运行app</h4><p>首先连接手机，打开usb调试<br>还是一样，但是选择app那里不是app,而是选择Edit Configurations<br>之后选择usb　device，ok，就可以了，接着运行</p>
<h4 id="关于项目结构模式："><a href="#关于项目结构模式：" class="headerlink" title="关于项目结构模式："></a>关于项目结构模式：</h4><p>默认为android<br>设置为project可以看到整个完整的目录结构：<br>　　　　　.gradle和.idea 为自动生成<br>　　　　　app<br>　　　　　build   编译时自动生成的文件，不用太关心<br>　　　　　gradle   包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle<br>     .gitignore<br>     build.gradle<br>     gradle.properties  全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本<br>     gradlew　和gradlew.bat在命令行中执行gradle命令<br>     local.properties　　指定本机android sdk路径<br>     setting.gradle指定项目中引入的模块</p>
<pre><code> app目录下
 build　　为自动生成，同上
 lib   项目使用的第三方库
 test 测试用例
 proguard-rules.pro  代码混淆规则
</code></pre>
<h4 id="build-gradle-intruduce"><a href="#build-gradle-intruduce" class="headerlink" title="build gradle intruduce"></a>build gradle intruduce</h4><p>gradle  Groovy 领域语言　　DSL    摒弃了Ant 和Maven </p>
<p>在app 外有一个 build.gradle。在app中有一个build.gradle</p>
<p>在外面的　gradle 也可以构建c++等项目，<br>buildscript {<br>    repositories {<br>        jcenter()　　　&#x2F;&#x2F;代码托管仓库　利用它可以轻松引用jcenter开源项目</p>
<pre><code>&#125;
dependencies &#123;
    classpath &#39;com.android.tools.build:gradle:2.3.2&#39;　　//声明构建的是android

    // NOTE: Do not place your application dependencies here; they belong
    // in the individual module build.gradle files
&#125;
</code></pre>
<p>}</p>
<p>allprojects {<br>    repositories {<br>        jcenter()<br>    }<br>}</p>
<p>task clean(type: Delete) {<br>    delete rootProject.buildDir<br>}</p>
<p>app中<br>apply plugin: ‘com.android.application’　&#x2F;&#x2F;表明为android 应用程序模块，为com.android.library表示库模块</p>
<p>android {　　　&#x2F;&#x2F;安卓闭包<br>    compileSdkVersion 25　　　　&#x2F;&#x2F;项目的编译版本，25为API 25,对应android 7.1<br>    buildToolsVersion “25.0.3”   &#x2F;&#x2F;项目构建工具版本<br>    defaultConfig {<br>        applicationId “org.example.myactivity1”　　　项目包名<br>        minSdkVersion 25　　　　　&#x2F;&#x2F;项目最低兼容的android系统版本<br>        targetSdkVersion 25　　&#x2F;&#x2F;表明如22表示只在22测试充分，如不启动运行时权限，android６　的运行时权限就不会加，表明只在5上做充分测试<br>        versionCode 1　　　项目版本编号<br>        versionName “1.0”　　　项目版本名<br>        testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner”<br>    }<br>    buildTypes {&#x2F;&#x2F;分debug和release版本<br>        release {<br>            minifyEnabled false　&#x2F;&#x2F;是否混淆代码<br>            proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’&#x2F;&#x2F;混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件<br>        }<br>    }<br>}</p>
<p>dependencies {&#x2F;&#x2F;分本地依赖，库依赖和远程依赖<br>    compile fileTree(dir: ‘libs’, include: [‘*.jar’])　　&#x2F;&#x2F;本地依赖声明<br>    androidTestCompile(‘com.android.support.test.espresso:espresso-core:2.2.2’, {<br>        exclude group: ‘com.android.support’, module: ‘support-annotations’<br>    })<br>    compile ‘com.android.support:appcompat-v7:25.3.1’　　&#x2F;&#x2F;　依赖库<br>    compile ‘com.android.support.constraint:constraint-layout:1.0.2’<br>    testCompile ‘junit:junit:4.12’　　&#x2F;&#x2F;测试用例库<br>}</p>
<p>其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title>audio_aac_adts</title>
    <url>/2022/03/27/audio-aac-adts/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="AAC简介："><a href="#AAC简介：" class="headerlink" title="AAC简介："></a>AAC简介：</h4><h5 id="MPEG家族："><a href="#MPEG家族：" class="headerlink" title="MPEG家族："></a>MPEG家族：</h5><p>AAC是MPEG家族中的音频算法之一；其实AAC分了很多种：&#x2F;&#x2F;关于MPEG家族，可以看视频编码和容器流媒体概念；<span id="more"></span></p>
<ul>
<li><p>1991 MPEG-1 or MPEG-2 Audio Layer III,由位于德国埃尔朗根的研究组织弗劳恩霍夫协会的一组工程师发明和标准化的，它被设计来大幅降低音频数据量，通过舍弃PCM音频资料中对人类听觉不重要的部分   –MP3</p>
</li>
<li><p>1997 基于MPEG-2的有损数字音频压缩的专利音频编码标准；由Fraunhofer IIS、杜比实验室、AT&amp;T、Sony、Nokia等公司共同开发  –MPEG-2 AAC</p>
</li>
<li><p>2000  MPEG-4标准在原本的基础上加上了PNS（Perceptual Noise Substitution）等技术，并提供了多种扩展工具。 –MPEG-4 AAC</p>
</li>
<li><p>2003  HE-AAC  v1 (aac+)  </p>
</li>
<li><p>2006  HE-AAC v2 (eaac+)<br>于是总共有：<!--more--></p>
</li>
<li><p>MPEG-2 AAC LC低复杂度规格（Low Complexity）</p>
</li>
<li><p>MPEG-2 AAC Main主规格</p>
</li>
<li><p>MPEG-2 AAC SSR可变采样率规格（Scaleable Sample Rate）</p>
</li>
<li><p>MPEG-4 AAC LC低复杂度规格（Low Complexity），现在的手机比较常见的MP4文件中的音频部分就包括了该规格音频档案</p>
</li>
<li><p>MPEG-4 AAC Main主规格</p>
</li>
<li><p>MPEG-4 AAC SSR可变采样率规格（Scaleable Sample Rate）</p>
</li>
<li><p>MPEG-4 AAC LTP长时期预测规格（Long Term Predicition）</p>
</li>
<li><p>MPEG-4 AAC LD低延迟规格（Low Delay）</p>
</li>
<li><p>MPEG-4 AAC HE高效率规格（High Efficiency）<br>常见：MPEG-4 AAC LC（Low Complexity）是最常用的规格，我们叫“低复杂度规格”，我们简称“LC-AAC”，</p>
<h5 id="AAC-编码器："><a href="#AAC-编码器：" class="headerlink" title="AAC 编码器："></a>AAC 编码器：</h5></li>
<li><p>FhG：Fraunhofer IIS研发的权威编码器。</p>
</li>
<li><p>Nero AAC：同时支持LC-AAC &#x2F; HE-AAC规格，由Nero公司免费发布的Nero AAC编码器。</p>
</li>
<li><p>QuickTime &#x2F; iTunes：Apple公司的两款软件都提供了AAC编码功能，其编码技术来自”Dolby Laboratories”（简写为Dolby Labs，杜比实验室）。</p>
</li>
<li><p>FAAC（Freeware Advanced Audio Coder）：也是一种很好的命令行编码器，支持LC&#x2F;Main&#x2F;LTP规格，而这个软件是免费的。FAAC是属于自由软件。</p>
</li>
<li><p>DivX AAC：2009年DivX开发出来的新AAC编码器，支持LC&#x2F;HE&#x2F;HEv2规格。目前正在测试中。</p>
<h5 id="AAC常见的扩展名："><a href="#AAC常见的扩展名：" class="headerlink" title="AAC常见的扩展名："></a>AAC常见的扩展名：</h5><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="title">.aac</span></span><br><span class="line"><span class="title">.mp4</span></span><br><span class="line"><span class="title">.m4a</span></span><br></pre></td></tr></table></figure>
<p>更多历史介绍：<a href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E9%9F%B3%E8%A8%8A%E7%B7%A8%E7%A2%BC">https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E9%9F%B3%E8%A8%8A%E7%B7%A8%E7%A2%BC</a></p>
</li>
</ul>
<h4 id="ADTS和AAC"><a href="#ADTS和AAC" class="headerlink" title="ADTS和AAC:"></a>ADTS和AAC:</h4><p>经验中：ADTS是aac音频文件的封装，而纯aac则可以用于流媒体传输，比如放到flv中，当然流媒体也可以传输adts.</p>
<h5 id="AAC文件的封装："><a href="#AAC文件的封装：" class="headerlink" title="AAC文件的封装："></a>AAC文件的封装：</h5><p>通过AAC协议和文件查看 AAC Audio ES Viewer，可以看到，AAC文件是这样封装的：<br>ADTS header + AAC raw data      ADTS header+AAC raw data   ….这样；<br>ADTS header: adts_fixed_header() + adts_variable_header() 后者可变在于有没有包含atdt_error_check()16bit<br>         adts_fixed_header()为固定头，是28bit,  adts_variable_header() 为前面固定的28bit,加可能有的16bit   tatdt_error_check()<br>         所以ADTS header: 7(28bit+28bit)&#x2F;9 Bytes(28+28+16);</p>
<img src="/2022/03/27/audio-aac-adts/1.png" class="" title="tes">
<img src="/2022/03/27/audio-aac-adts/2.png" class="" title="tes">

<h5 id="ADTS头-的各个字段解释："><a href="#ADTS头-的各个字段解释：" class="headerlink" title="ADTS头 的各个字段解释："></a>ADTS头 的各个字段解释：</h5><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line">  <span class="attribute">Header</span> consists of <span class="number">7</span> or <span class="number">9</span> bytes (without or with CRC).</span><br><span class="line"></span><br><span class="line"><span class="attribute">Letter</span>	Length (bits)	Description</span><br><span class="line"><span class="attribute">A</span>	<span class="number">12</span>	syncword <span class="number">0</span>xFFF, <span class="literal">all</span> bits must be <span class="number">1</span> 同步号，用来找帧</span><br><span class="line"><span class="attribute">B</span>	<span class="number">1</span>	MPEG Version: <span class="number">0</span> for MPEG-<span class="number">4</span>, <span class="number">1</span> for MPEG-<span class="number">2</span> 版本号</span><br><span class="line"><span class="attribute">C</span>	<span class="number">2</span>	Layer: always <span class="number">0</span> 总是<span class="number">0</span></span><br><span class="line"><span class="attribute">D</span>	<span class="number">1</span>	protection absent, Warning, set to <span class="number">1</span> if there is no CRC and <span class="number">0</span> if there is CRC   决定是否有额外<span class="number">16</span>bit</span><br><span class="line"><span class="attribute">E</span>	<span class="number">2</span>	profile, the MPEG-<span class="number">4</span> Audio Object Type minus <span class="number">1</span></span><br><span class="line"><span class="attribute">F</span>	<span class="number">4</span>	MPEG-<span class="number">4</span> Sampling Frequency Index (<span class="number">15</span> is forbidden)  idx来表示采样，<span class="number">4</span>为<span class="number">44100</span></span><br><span class="line"><span class="attribute">G</span>	<span class="number">1</span>	private bit, guaranteed never to be used by MPEG, set to <span class="number">0</span> when encoding, ignore when decoding</span><br><span class="line"><span class="attribute">H</span>	<span class="number">3</span>	MPEG-<span class="number">4</span> Channel Configuration (in the case of <span class="number">0</span>, the channel configuration is sent via an inband PCE) channel数</span><br><span class="line"><span class="attribute">I</span>	<span class="number">1</span>	originality, set to <span class="number">0</span> when encoding, ignore when decoding</span><br><span class="line"><span class="attribute">J</span>	<span class="number">1</span>	home, set to <span class="number">0</span> when encoding, ignore when decoding 编码时设置为<span class="number">0</span>，解码数据时忽略</span><br><span class="line"><span class="attribute">K</span>	<span class="number">1</span>	copyrighted id bit, the next bit of a centrally registered copyright identifier, set to <span class="number">0</span> when encoding, ignore when decoding</span><br><span class="line"><span class="attribute">L</span>	<span class="number">1</span>	copyright id start, signals that this frame&#x27;s copyright id bit is the first bit of the copyright id, set to <span class="number">0</span> when encoding, ignore when decoding</span><br><span class="line"><span class="attribute">M</span>	<span class="number">13</span>	frame length, this value must include <span class="number">7</span> or <span class="number">9</span> bytes of header length: FrameLength = (ProtectionAbsent == <span class="number">1</span> ? <span class="number">7</span> : <span class="number">9</span>) + size(AACFrame)  --帧长</span><br><span class="line"><span class="attribute">O</span>	<span class="number">11</span>	Buffer fullness</span><br><span class="line"><span class="attribute">P</span>	<span class="number">2</span>	Number of AAC frames (RDBs) in ADTS frame minus <span class="number">1</span>, for maximum compatibility always use <span class="number">1</span> AAC frame per ADTS frame --一个adts帧中的aac原始数据块数量，一般为一个</span><br><span class="line"><span class="attribute">Q</span>	<span class="number">16</span>	CRC if protection absent is <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"> <span class="attribute">ADTS</span> packet must be a content of PES packet. Pack AAC data inside ADTS frame, than pack inside PES packet, then mux by TS packetizer.</span><br></pre></td></tr></table></figure>

<h5 id="aac-rowdatablock"><a href="#aac-rowdatablock" class="headerlink" title="aac rowdatablock:"></a>aac rowdatablock:</h5><p>一个典型的aac音频文件编码是这样一串：<br>Adts header aac rawdatablock  adts header aac rawdatablock<br>但是首帧，可能是某种类型的rawdatablock;<br>关于rawdatablock<br>Raw_data_block格式如下，id_syn_ele:3位标志位，指示后面所跟着的数据流的类型。  </p>
<p>在AAC中，原始数据块的组成可能有六种不同的元素：<br>     + SCE: Single Channel Element单通道元素。单通道元素基本上只由一个ICS组成。一个原始数据块最可能由16个SCE组成。<br>     + CPE: Channel Pair Element 双通道元素，由两个可能共享边信息的ICS和一些联合立体声编码信息组成。一个原始数据块最多可能由16个SCE组成。<br>     + CCE: Coupling Channel Element 藕合通道元素。代表一个块的多通道联合立体声信息或者多语种程序的对话信息。<br>     + LFE: Low Frequency Element 低频元素。包含了一个加强低采样频率的通道。<br>     + DSE: Data Stream Element 数据流元素，包含了一些并不属于音频的附加信息。<br>     + PCE: Program Config Element 程序配置元素。包含了声道的配置信息。它可能出现在 ADIF 头部信息中。<br>     + FIL: Fill Element 填充元素。包含了一些扩展信息。如SBR，动态范围控制信息等。<br>id_syn_ele    数据流</p>
<ul>
<li>ID_SCE(0x0) single_channel_element()</li>
<li>ID_CPE(0x1)channel_pair_element()</li>
<li>ID_CCE(0x2)coupling_channel_element()</li>
<li>ID_LFE(0x3)lfe_channel_element(</li>
<li>ID_DSE(0x4)data_stream_element()</li>
<li>ID_PCE(0x5)program_config_element()</li>
<li>ID_FIL(0x6)fill_element()</li>
</ul>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref:"></a>ref:</h5><p>more:<a href="https://www.cnblogs.com/fellow1988/p/7291939.html">https://www.cnblogs.com/fellow1988/p/7291939.html</a><br><a href="https://maxwellqi.github.io/ios-audio-format-decoder/">https://maxwellqi.github.io/ios-audio-format-decoder/</a><br><a href="http://www.telemidia.puc-rio.br/~rafaeldiniz/public_files/normas/ISO-13818/ISO_IEC_13818-7_2006(E).pdf">http://www.telemidia.puc-rio.br/~rafaeldiniz/public_files/normas/ISO-13818/ISO_IEC_13818-7_2006(E).pdf</a>   </p>
<p>关于buffer fullness:<a href="http://blog.olivierlanglois.net/index.php/2008/09/12/aac_adts_header_buffer_fullness_field">http://blog.olivierlanglois.net/index.php/2008/09/12/aac_adts_header_buffer_fullness_field</a>   </p>
<h5 id="FLV中AAC的封装："><a href="#FLV中AAC的封装：" class="headerlink" title="FLV中AAC的封装："></a>FLV中AAC的封装：</h5><p>FlV由tag构成，而音频的tag是：包含AAC头的tag+ 后面都是AAC 原始数据的tag<br>11B  tag header + 2B audio tag header + 一般是5B的AAC sequence header;<br>之后就都是数据：11B头+2B音频tag头+aac rawdata&#x3D;&#x3D;(adts中的aac rawdatablock)<br>通过flvAnalyser工具可以看到：</p>
<img src="/2022/03/27/audio-aac-adts/3.png" class="" title="tes">
<img src="/2022/03/27/audio-aac-adts/4.png" class="" title="tes">
<img src="/2022/03/27/audio-aac-adts/5.png" class="" title="tes">


<p> 更多见flv的封装；和<a href="https://wiki.multimedia.cx/index.php/MPEG-4_Audio">https://wiki.multimedia.cx/index.php/MPEG-4_Audio</a></p>
<h5 id="如何将flv-aac封装为流媒体：-举例："><a href="#如何将flv-aac封装为流媒体：-举例：" class="headerlink" title="如何将flv aac封装为流媒体： 举例："></a>如何将flv aac封装为流媒体： 举例：</h5><p> 一般来讲，流媒体传输需要使得最终接收方可以解码播放，所以需要传递解码信息，如音频必备的几个要素:channel,samplaterate,编码方式等等，而版权等根据需要放入metadata</p>
<ul>
<li><p>流媒体中AAC的一般封装： ADTS+aac raw data;</p>
</li>
<li><p>AAC 协议：查ADTS头： <a href="http://read.pudn.com/downloads98/doc/comm/401153/14496/ISO_IEC_14496-3%20Part%203%20Audio/C036083E_SUB1.PDF">http://read.pudn.com/downloads98/doc/comm/401153/14496/ISO_IEC_14496-3%20Part%203%20Audio/C036083E_SUB1.PDF</a>  page 61-67</p>
</li>
</ul>
<p><a href="http://www.telemidia.puc-rio.br/~rafaeldiniz/public_files/normas/ISO-13818/ISO_IEC_13818-7_2006%28E%29.pdf">http://www.telemidia.puc-rio.br/~rafaeldiniz/public_files/normas/ISO-13818/ISO_IEC_13818-7_2006%28E%29.pdf</a><br>ISO_IEC_13818-7_2006(E).pdf MPEG-2的AAC<br>ISO14496-3-2009.pdf  MPEG-4的AAC<br>HE-AAC: trev_305-moser.pdf</p>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><p>一个解析aac文件的简单程序：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3                                                                                                                                                                                     </span></span><br><span class="line">   <span class="number">2</span> <span class="keyword">import</span> sys</span><br><span class="line">   <span class="number">3</span> <span class="keyword">import</span> struct</span><br><span class="line">   <span class="number">4</span> </span><br><span class="line">   <span class="number">5</span> <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">   <span class="number">6</span>   <span class="built_in">print</span>(<span class="string">&quot;Usage: aac_parer.py &lt;target.aac&gt;&quot;</span>)</span><br><span class="line">   <span class="number">7</span>   exit()</span><br><span class="line">   <span class="number">8</span> </span><br><span class="line">   <span class="number">9</span> aacfile = <span class="built_in">open</span>(sys.argv[<span class="number">1</span>], <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">  <span class="number">10</span> frame_no = <span class="number">1</span></span><br><span class="line">  <span class="number">11</span> </span><br><span class="line">  <span class="number">12</span> <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="number">13</span>   data = aacfile.read(<span class="number">7</span>)</span><br><span class="line">  <span class="number">14</span>   <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">- <span class="number">15</span>     exit()</span><br><span class="line">  <span class="number">16</span>   hdr = struct.unpack(<span class="string">&quot;&gt;7B&quot;</span>, data)</span><br><span class="line">  <span class="number">17</span> </span><br><span class="line">  <span class="number">18</span>   <span class="comment"># parse adts_fixed_header()</span></span><br><span class="line">  <span class="number">19</span>   syncword = (hdr[<span class="number">0</span>] &lt;&lt; <span class="number">4</span>) | (hdr[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>)  <span class="comment"># bslbf(12)</span></span><br><span class="line">  <span class="number">20</span>   <span class="keyword">if</span> syncword != <span class="number">0b111111111111</span>:</span><br><span class="line">- <span class="number">21</span>     <span class="built_in">print</span>(<span class="string">&quot;Invalid `syncword` for &#123;&#125; frame&quot;</span>.<span class="built_in">format</span>(frame_no))</span><br><span class="line">| <span class="number">22</span>     exit()</span><br><span class="line">  <span class="number">23</span>   ID                 = (hdr[<span class="number">1</span>] &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0b1</span>    <span class="comment"># bslbf(1)</span></span><br><span class="line">  <span class="number">24</span>   layer              = (hdr[<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0b11</span>   <span class="comment"># uimsbf(2)</span></span><br><span class="line">  <span class="number">25</span>   protection_absent  = (hdr[<span class="number">1</span>]     ) &amp; <span class="number">0b1</span>    <span class="comment"># bslbf(1)</span></span><br><span class="line">  <span class="number">26</span>   profile            = (hdr[<span class="number">2</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0b11</span>   <span class="comment"># uimsbf(2)</span></span><br><span class="line">  <span class="number">27</span>   sampling_freq_idx  = (hdr[<span class="number">2</span>] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0b1111</span> <span class="comment"># uimsbf(4)</span></span><br><span class="line">  <span class="number">28</span>   private_bit        = (hdr[<span class="number">2</span>] &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0b1</span>    <span class="comment"># bslbf(1)</span></span><br><span class="line">  <span class="number">29</span>   channel_cfg        = ((hdr[<span class="number">2</span>] &amp; <span class="number">0b1</span>) &lt;&lt; <span class="number">2</span>) | (hdr[<span class="number">3</span>] &gt;&gt; <span class="number">6</span>)  <span class="comment"># uimsbf(3)</span></span><br><span class="line">  <span class="number">30</span>   original_copy      = (hdr[<span class="number">3</span>] &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0b1</span>    <span class="comment"># bslbf(1)</span></span><br><span class="line">  <span class="number">31</span>   home               = (hdr[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0b1</span>    <span class="comment"># bslbf(1)</span></span><br><span class="line">  <span class="number">32</span>   <span class="comment"># parse adts_variable_header()</span></span><br><span class="line">  <span class="number">33</span>   copyright_id_bit   = (hdr[<span class="number">3</span>] &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0b1</span>    <span class="comment"># bslbf(1)</span></span><br><span class="line">  <span class="number">34</span>   copyright_id_start = (hdr[<span class="number">3</span>] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0b1</span>    <span class="comment"># bslbf(1)</span></span><br><span class="line">  <span class="number">35</span>   frame_length       = ((hdr[<span class="number">3</span>] &amp; <span class="number">0b11</span>) &lt;&lt; <span class="number">11</span>) | (hdr[<span class="number">4</span>] &lt;&lt; <span class="number">3</span>) | (hdr[<span class="number">5</span>] &gt;&gt; <span class="number">5</span>)  <span class="comment"># bslbf(13)</span></span><br><span class="line">  <span class="number">36</span>   adts_buf_fullness  = ((hdr[<span class="number">5</span>] &amp; <span class="number">0b11111</span>) &lt;&lt; <span class="number">6</span>) | (hdr[<span class="number">6</span>] &gt;&gt; <span class="number">2</span>)  <span class="comment"># bslbf(11)</span></span><br><span class="line">  <span class="number">37</span>   num_rawdata_blocks = (hdr[<span class="number">6</span>]     ) &amp; <span class="number">0b11</span>   <span class="comment"># uimsbf(2)</span></span><br><span class="line">  <span class="number">38</span> </span><br><span class="line">  <span class="number">39</span>   crc_check = <span class="number">0</span></span><br><span class="line">  <span class="number">40</span>   size = frame_length - <span class="number">7</span></span><br><span class="line">  <span class="number">41</span>   <span class="keyword">if</span> num_rawdata_blocks == <span class="number">0</span>:</span><br><span class="line">  <span class="number">42</span>     <span class="comment"># adts_error_check()</span></span><br><span class="line">  <span class="number">43</span>     <span class="keyword">if</span> protection_absent == <span class="number">0</span>:</span><br><span class="line">| <span class="number">44</span>     ¦ crc_check = struct.unpack(<span class="string">&quot;&gt;H&quot;</span>, aacfile.read(<span class="number">2</span>))[<span class="number">0</span>]  <span class="comment"># rpchof(16)</span></span><br><span class="line">| <span class="number">45</span>     ¦ size -= <span class="number">2</span></span><br><span class="line">| <span class="number">46</span>     <span class="comment"># raw_data_block()</span></span><br><span class="line">| <span class="number">47</span>     aacfile.read(size)</span><br><span class="line">  <span class="number">48</span>   <span class="keyword">else</span>:</span><br><span class="line">  <span class="number">49</span>     <span class="comment"># adts_header_error_check()</span></span><br><span class="line">- <span class="number">50</span>     <span class="keyword">if</span> protection_absent == <span class="number">0</span>:</span><br><span class="line">| <span class="number">51</span>     ¦ crc_check = struct.unpack(<span class="string">&quot;&gt;H&quot;</span>, aacfile.read(<span class="number">2</span>))[<span class="number">0</span>]  <span class="comment"># rpchof(16)</span></span><br><span class="line">| <span class="number">52</span>     ¦ size -= (<span class="number">2</span> * num_rawdata_blocks) + <span class="number">2</span></span><br><span class="line">| <span class="number">53</span>     <span class="comment"># &#123;raw_data_block() + adts_raw_data_block_error_check()&#125; x N</span></span><br><span class="line">| <span class="number">54</span>     aacfile.read(size)</span><br><span class="line">  <span class="number">55</span>   <span class="built_in">print</span>(<span class="string">&quot;raw size:&quot;</span>)</span><br><span class="line">  <span class="number">56</span>   <span class="built_in">print</span>(size)</span><br><span class="line">  <span class="number">57</span>   <span class="keyword">if</span> frame_no &gt;= <span class="number">1</span>:</span><br><span class="line">  <span class="number">58</span>     <span class="comment"># dump adts_fixed_header()</span></span><br><span class="line">- <span class="number">59</span>     <span class="built_in">print</span>(<span class="string">&quot;adts_fixed_header():&quot;</span>)</span><br><span class="line">| <span class="number">60</span>     <span class="built_in">print</span>(<span class="string">&quot;ID=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(ID))</span><br><span class="line">| <span class="number">61</span>     <span class="built_in">print</span>(<span class="string">&quot;layer=&#123;:02b&#125;&quot;</span>.<span class="built_in">format</span>(layer))</span><br><span class="line">| <span class="number">62</span>     <span class="built_in">print</span>(<span class="string">&quot;protection_absent=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(protection_absent))</span><br><span class="line">| <span class="number">63</span>     <span class="built_in">print</span>(<span class="string">&quot;profile=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(profile))</span><br><span class="line">| <span class="number">64</span>     <span class="built_in">print</span>(<span class="string">&quot;sampling_frequency_index=0x&#123;:x&#125;&quot;</span>.<span class="built_in">format</span>(sampling_freq_idx))</span><br><span class="line">| <span class="number">65</span>     <span class="built_in">print</span>(<span class="string">&quot;private_bit=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(private_bit))</span><br><span class="line">| <span class="number">66</span>     <span class="built_in">print</span>(<span class="string">&quot;channel_configuration=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(channel_cfg))</span><br><span class="line">| <span class="number">67</span>     <span class="built_in">print</span>(<span class="string">&quot;original/copy=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(original_copy))</span><br><span class="line">| <span class="number">68</span>     <span class="built_in">print</span>(<span class="string">&quot;home=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(home))</span><br><span class="line">| <span class="number">69</span>     <span class="built_in">print</span>(<span class="string">&quot;adts_variable_header():&quot;</span>)</span><br><span class="line">| <span class="number">70</span>   <span class="comment"># dump adts_variable_header()</span></span><br><span class="line">| <span class="number">71</span>     <span class="built_in">print</span>(<span class="string">&quot;#&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,0x&#123;:04x&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">| <span class="number">72</span>     frame_no, copyright_id_bit, copyright_id_start, frame_length, adts_buf_fullness, num_rawdata_blocks, crc_check))</span><br><span class="line">  <span class="number">73</span>   frame_no += <span class="number">1</span>                                   </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>audio</category>
      </categories>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>audio_wav</title>
    <url>/2022/03/26/audio-wav/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="wav格式介绍："><a href="#wav格式介绍：" class="headerlink" title="wav格式介绍："></a>wav格式介绍：</h3><p>1 wave格式：<br>    文件描述：WAVE or RIFF WAVE sound<br>    文件扩展名：.wav&#x2F;.wave<br>    文件字节序：小端  <span id="more"></span><br>    参考文档：<a href="http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html">http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html</a><br>    wave有几个spec,和几种数据类型；  </p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">wave文件格式：</span><br><span class="line">1）wave头：wave文件有一个主要的RIFF chunk 包含了WAVE标识符，并紧跟着子chunks.数据是小端排序；</span><br><span class="line">    Field    Length    Contents</span><br><span class="line">    ckID   <span class="number"> 4 </span>   Chunk ID: RIFF</span><br><span class="line">    cksize   <span class="number"> 4 </span>   Chunk size: 4+n</span><br><span class="line">    WAVEID   <span class="number"> 4 </span>   WAVE ID: WAVE</span><br><span class="line">    WAVE chunks    n    Wave chunks containing format information and sampled data</span><br><span class="line"></span><br><span class="line">2）fmt chunk:fmt 具体化数据的格式，有三种不同的sampled data,它们的不同之处在于对基本fmt块的扩展</span><br><span class="line">Field    Length          Contents</span><br><span class="line">ckID     <span class="number"> 4 </span>             Chunk ID: fmt </span><br><span class="line">cksize     <span class="number"> 4 </span>             Chunk size: 16,<span class="number"> 18 </span>or 40</span><br><span class="line">wFormatTag   <span class="number"> 2 </span>         Format code</span><br><span class="line">nChannels   <span class="number"> 2 </span>         Number of interleaved channels</span><br><span class="line">nSamplesPerSec   <span class="number"> 4 </span>     Sampling rate (blocks per second)</span><br><span class="line">nAvgBytesPerSec   <span class="number"> 4 </span>     Data rate</span><br><span class="line">nBlockAlign   <span class="number"> 2 </span>         Data block size (bytes)</span><br><span class="line">wBitsPerSample   <span class="number"> 2 </span>     Bits per sample</span><br><span class="line">以下四个字段在音频采样数据非PCM,且为扩展的WAVE_FORMAT_EXTENSIBLE才会用到，24B/48B</span><br><span class="line">cbSize   <span class="number"> 2 </span>             Size of the extension (0 or 22) </span><br><span class="line">wValidBitsPerSample   <span class="number"> 2 </span>Number of valid bits</span><br><span class="line">dwChannelMask   <span class="number"> 4 </span>     Speaker position mask</span><br><span class="line">SubFormat   <span class="number"> 16 </span>         GUID, including the data format code 这里分类型：</span><br><span class="line"></span><br><span class="line">wavform数据的标准编码格式有以下几种；上面的参考文献提供了更多的压缩数据格式代码，其中很大一部分现在已经过时了</span><br><span class="line">    Format Code    PreProcessor Symbol    Data</span><br><span class="line">    0x0001    WAVE_FORMAT_PCM    PCM</span><br><span class="line">    0x0003    WAVE_FORMAT_IEEE_FLOAT    IEEE float</span><br><span class="line">    0x0006    WAVE_FORMAT_ALAW    8-bit ITU-T G.711 A-law</span><br><span class="line">    0x0007    WAVE_FORMAT_MULAW    8-bit ITU-T G.711 µ-law</span><br><span class="line">    0xFFFE    WAVE_FORMAT_EXTENSIBLE    Determined by SubFormat</span><br><span class="line">    以上几种，若是non-PCM，则需要带一个fact chunk </span><br><span class="line">    </span><br><span class="line">3) fact chunk non-PCM才需要</span><br><span class="line">4）data chunk 音频数据部分：包含了采样数据：</span><br><span class="line"></span><br><span class="line">Field    Length        Contents</span><br><span class="line">ckID   <span class="number"> 4 </span>           Chunk ID: data</span><br><span class="line">cksize   <span class="number"> 4 </span>           Chunk size: n</span><br><span class="line">sampled data    n    Samples</span><br><span class="line">pad byte   <span class="number"> 0 </span>or<span class="number"> 1 </span>   Padding byte if n is odd</span><br><span class="line"></span><br><span class="line">标准给了一个例子：</span><br><span class="line">Examples</span><br><span class="line">Consider sampled data with the following parameters,</span><br><span class="line">    Nc channels</span><br><span class="line">    The total number of blocks is Ns. Each block consists of Nc samples.</span><br><span class="line">    Sampling rate F (blocks per second)</span><br><span class="line">    Each sample is M bytes long</span><br><span class="line"></span><br><span class="line">PCM Data：</span><br><span class="line">Field    Length    Contents</span><br><span class="line">ckID   <span class="number"> 4 </span>   Chunk ID: RIFF</span><br><span class="line">cksize   <span class="number"> 4 </span>   Chunk size:<span class="number"> 4 </span>+<span class="number"> 24 </span>+ (8 + M*Nc*Ns + (0 or 1)</span><br><span class="line">WAVEID   <span class="number"> 4 </span>   WAVE ID: WAVE</span><br><span class="line">ckID   <span class="number"> 4 </span>   Chunk ID: fmt </span><br><span class="line">cksize   <span class="number"> 4 </span>   Chunk size: 16</span><br><span class="line">wFormatTag   <span class="number"> 2 </span>   WAVE_FORMAT_PCM</span><br><span class="line">nChannels   <span class="number"> 2 </span>   Nc</span><br><span class="line">nSamplesPerSec   <span class="number"> 4 </span>   F</span><br><span class="line">nAvgBytesPerSec   <span class="number"> 4 </span>   F*M*Nc</span><br><span class="line">nBlockAlign   <span class="number"> 2 </span>   M*Nc</span><br><span class="line">wBitsPerSample   <span class="number"> 2 </span>   rounds up to 8*M</span><br><span class="line">ckID   <span class="number"> 4 </span>   Chunk ID: data</span><br><span class="line">cksize   <span class="number"> 4 </span>   Chunk size: M*Nc*Ns</span><br><span class="line">sampled data    M*Nc*Ns    Nc*Ns channel-interleaved M-byte samples</span><br><span class="line">pad byte   <span class="number"> 0 </span>or<span class="number"> 1 </span>   Padding byte if M*Nc*Ns is odd</span><br><span class="line"></span><br><span class="line">更多例子见文档；</span><br></pre></td></tr></table></figure>

<p>二、wav播放器3：</p>
<audio id="mmedia-JqdfxiJtfNlcMwzO" audi="audio" Thi="This" i="is" a="an" exampl="example" src="/2022/03/26/audio-wav/wind.mp3" ></audio>   


]]></content>
      <categories>
        <category>audio</category>
      </categories>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>c++_valuetype</title>
    <url>/2021/05/23/c-valuetype/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="彻底理解c-中的五种值，临时对象，移动语意，引用指针，const等的概念和关联"><a href="#彻底理解c-中的五种值，临时对象，移动语意，引用指针，const等的概念和关联" class="headerlink" title="彻底理解c++中的五种值，临时对象，移动语意，引用指针，const等的概念和关联"></a>彻底理解c++中的五种值，临时对象，移动语意，引用指针，const等的概念和关联</h3><h4 id="c-的引用和指针"><a href="#c-的引用和指针" class="headerlink" title="c++的引用和指针"></a>c++的引用和指针</h4><h5 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h5><p>引用，是变量或对象的别名，这么解释其实还是有点抽象的；<br>如果是指针，则好理解，是对象的虚拟内存地址；所以在赋值拷贝等容易有实体理解；而引用，在这些常见下，又是什么样的实际操作？<br>考虑如下例子：<span id="more"></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">为了理解引用是什么，来看这个例子：</span><br><span class="line"></span><br><span class="line">leaq是只移动地址，或者说直接值，而movq是移动值作为地址的内存的存放的值，或者寄存器存放的值</span><br><span class="line"><span class="number">258</span>     xorl    %eax, %eax                                                    |<span class="number">14</span> <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"><span class="number">259</span>     <span class="comment">//为x1分配栈地址，将地址放到寄存器rax                                 |15 &#123;</span></span><br><span class="line"><span class="number">260</span>     leaq    <span class="number">-44</span>(%rbp), %rax                                               |<span class="number">16</span> <span class="keyword">public</span>:</span><br><span class="line"><span class="number">261</span>     <span class="comment">//将rax寄存器的值，即x1地址给到rdi(调用函数的参数0)                   |17    int a;</span></span><br><span class="line"><span class="number">262</span>     movq    %rax, %rdi                                                    |<span class="number">18</span>    <span class="built_in">A</span>() &#123; std::cout&lt;&lt; <span class="string">&quot;A con&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line"><span class="number">263</span> .LEHB3:                                                                   |<span class="number">19</span>    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other)</span><br><span class="line"><span class="number">264</span>     <span class="comment">//调用A构造函数                                                       |20    &#123;</span></span><br><span class="line"><span class="number">265</span>     call    _ZN1AC1Ev                                                     |<span class="number">21</span>     ¦  a = other.a;</span><br><span class="line"><span class="number">266</span> .LEHE3:                                                                   |<span class="number">22</span>     ¦  std::cout&lt;&lt; <span class="string">&quot;use operator =&quot;</span> &lt;&lt; std::endl;                                     </span><br><span class="line"><span class="number">267</span>     <span class="comment">//将34赋值给x1的内存地址                                              |23     ¦  return *this;</span></span><br><span class="line"><span class="number">268</span>     movl    $<span class="number">34</span>, <span class="number">-44</span>(%rbp)                                                |<span class="number">24</span>    &#125;</span><br><span class="line"><span class="number">269</span>     <span class="comment">//将x1地址给到rax寄存器                                               |25    A(const A&amp; aa) &#123; a=aa.a; std::cout&lt;&lt; &quot;copy con&quot; &lt;&lt; std::endl;&#125;</span></span><br><span class="line"><span class="number">270</span>     leaq    <span class="number">-44</span>(%rbp), %rax</span><br><span class="line">        <span class="comment">//将rax寄存器的值即x1的地址给到-32(%rbp)即x2                          |26    ~A() &#123; std::cout&lt;&lt; &quot;A dec&quot; &lt;&lt; std::endl;&#125;</span></span><br><span class="line"><span class="number">271</span>     movq    %rax, <span class="number">-32</span>(%rbp)                                               |<span class="number">27</span> &#125;;</span><br><span class="line"><span class="number">272</span>     <span class="comment">//将x1的a取值赋值给寄存器                                             |28 </span></span><br><span class="line"><span class="number">273</span>     movl    <span class="number">-44</span>(%rbp), %eax                                               |<span class="number">29</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">274     <span class="comment">//将值赋值给dds，dds的内存地址就是-36(%rbp)                           |30 &#123;</span></span></span><br><span class="line"><span class="function">275     movl    %eax, -36<span class="params">(%rbp)</span>                                               |31     A x1</span>;</span><br><span class="line"><span class="number">276</span>     leaq    <span class="number">-44</span>(%rbp), %rdx                                               |<span class="number">32</span>     x1.a = <span class="number">34</span>;</span><br><span class="line"><span class="number">277</span>     leaq    <span class="number">-40</span>(%rbp), %rax                                               |<span class="number">33</span>     A &amp;x2 = x1;</span><br><span class="line"><span class="number">278</span>     movq    %rdx, %rsi                                                    |<span class="number">34</span>     <span class="type">int</span> dds = x1.a;</span><br><span class="line"><span class="number">279</span>     movq    %rax, %rdi                                                    |<span class="number">35</span>     A x3 = x1;</span><br><span class="line"><span class="number">280</span> .LEHB4:                                                                   |<span class="number">36</span>     std::cout&lt;&lt; <span class="string">&quot;x1:&quot;</span> &lt;&lt; x1.a &lt;&lt; <span class="string">&quot; addr:&quot;</span>&lt;&lt; &amp;x1 &lt;&lt;std::endl;</span><br><span class="line"><span class="number">281</span>     call    _ZN1AC1ERKS_                                                  |<span class="number">37</span>     std::cout &lt;&lt; <span class="string">&quot;x2:&quot;</span> &lt;&lt;x2.a &lt;&lt; <span class="string">&quot; addr:&quot;</span> &lt;&lt; &amp;x2  &lt;&lt;std::endl;</span><br><span class="line"><span class="number">282</span> .LEHE4:                                                                   |<span class="number">38</span>     x2.a = <span class="number">321</span>;</span><br><span class="line"><span class="number">283</span>     leaq    .<span class="built_in">LC4</span>(%rip), %rsi                                              |<span class="number">39</span> </span><br><span class="line"><span class="number">284</span>     leaq    _ZSt4cout(%rip), %rdi                                         |<span class="number">40</span> </span><br><span class="line"><span class="number">285</span> .LEHB5:                                                                   |<span class="number">41</span> </span><br><span class="line"><span class="number">286</span>     call    _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@PLT   |<span class="number">42</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//前面知道x2就在-32(%rbp)的位置，所以这里是取这块内存的值放寄存器</span></span><br><span class="line"><span class="number">220</span>     movq    <span class="number">-32</span>(%rbp), %rax</span><br><span class="line"><span class="comment">//将321放到上面的值为地址的值，即x1的值被改了；</span></span><br><span class="line"><span class="number">221</span>     movl    $<span class="number">321</span>, (%rax)</span><br><span class="line"> <span class="comment">//这里 x1在-44(%rbp),这个地址存放它的值，而x2是在-32(%rbp)上存放x1的地址；</span></span><br><span class="line"><span class="comment">//所以通过x2能找到x1,且修改其值时，编译器会转换为修改其值指向的地址上值，</span></span><br><span class="line"><span class="comment">//这样x1也会发生变化</span></span><br><span class="line"><span class="comment">//所以其实引用就是在一个内存位置上放一个相同的地址值，指向所引用的对象；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以对于汇编来讲，引用和指针本质上是一样的，都是存放变量的地址，只是编译器对引用做了封装和限制，不允许像操作指针那样操作引用，而实际上<br>修改引用的值，是修改对应位置的值，所以会影响源对象，而将引用赋值给另一个变量，是将其值赋值过去，而不是将地址赋值过去；</p>
<h5 id="c-的左值引用和右值引用"><a href="#c-的左值引用和右值引用" class="headerlink" title="c++的左值引用和右值引用"></a>c++的左值引用和右值引用</h5><p>左值引用，和指针没啥太大本质差别，给程序员的权限比指针少了些，但是也是很多的；而右值引用，是编译器对临时对象的权限的释放，即允许程序员能有一定的控制临时对象的权利；<br>所以先来看临时对象；可能一切都是由临时对象惹得锅；</p>
<h4 id="c-临时对象"><a href="#c-临时对象" class="headerlink" title="c++临时对象"></a>c++临时对象</h4><p>我们知道，如果是c语言，是很少有临时对象这些说法的，因为c没有类和对象的概念，即使是struct，在赋值，构造的时候，也不需要调用构造函数，一般是映射过去；<br>而c++不一样，c++有了类和对象，和基础类型不同的是，对赋值传值等场景下，需要调用拷贝函数等，而且拷贝函数的参数等不能像基础变量那样，直接传递值到寄存器，往往涉及到<br>要用内存作为跳板，比如c&#x3D;a+b，当它们是基础类型如int时，a+b的值甚至可以存在寄存器中，再赋值到c对应的内存中；而如果是对象，那a+b时，要调用operator+ 函数，结果<br>要构造一个临时对象来赋值给c，这个时候要调用赋值函数；</p>
<p>而临时对象的出现，伴随着即时的构造和销毁，会带来相应的开支，效率降低；</p>
<p>在一些场景下，对临时对象的某个操作可以提高效率，减少开支；如在赋值时，不是去做将临时对象拷贝到新对象上，而是将临时对象的地址赋值到新对象上，称为移动；<br>这样会少一次拷贝，提升效率；此为移动语意；</p>
<p>伴随着这种提升的出现；面临着一个问题，就是哪些可以用来移动，哪些只是临时对象，完全由编译器去控制？ 编译器可能不够清楚，需要程序员去提示它需要移动，不能立刻销毁；<br>要延长寿命； 传统的左值右值无法精确区分，所以为了用户明确表示它要移动，编译器制定了规则，用来区分，于是就有了下面的五种值；</p>
<h4 id="c-的五种值：lvalue-xvalue-rvalue-gvalue-prvalue"><a href="#c-的五种值：lvalue-xvalue-rvalue-gvalue-prvalue" class="headerlink" title="c++的五种值：lvalue,xvalue,rvalue,gvalue,prvalue"></a>c++的五种值：lvalue,xvalue,rvalue,gvalue,prvalue</h4><pre><code>         expression
      /       \
glvalue       rvalue
   /      \      /      \
</code></pre>
<p>lvalue         xvalue        prvalue<br>所以实际上是三种值，只是又将三种值分为两类，为了简单，直接看这三种值：</p>
<p>主值类别对应于表达式的两个属性：<br>具有标识 ：可以通过比较对象的地址或它们标识的功能（直接或间接获得）来确定该表达式是否与另一个表达式引用相同的实体；<br>可以从以下位置移动：移动构造函数，移动赋值运算符，或实现移动语义的另一个函数重载可以绑定到表达式。</p>
<p>表示为：<br>具有身份并且不能被移走的被称为左值表达式 ; lvalue，即编译器不会自动帮你销毁它，除非到达了作用域结尾；<br>具有身份并可以移出的称为xvalue 表达式 ; xvalue,编译器以此知道它不能立刻被销毁，直到你移动了它；所以它叫expiring值，你移动了它，它就亡了<br>没有身份且可以移出的被称为prvalue 表达式 ; prvalue，完全由编译器去控制，用户几乎无感知它的生命周期；<br>没有身份并且无法从中移走的人不会被使用。</p>
<h4 id="c-右值引用和五种值的关系"><a href="#c-右值引用和五种值的关系" class="headerlink" title="c++右值引用和五种值的关系"></a>c++右值引用和五种值的关系</h4><p>右值引用，可以说是对应了xvalue了，左值引用是lvalue,因为修改它，就像修改左值一样；而临时对象prvalue,没有引用之说，你不能引用它，除非你用它构造一个右值引用或左值引用；<br>它就是一个单纯的值，只在内存存在很短的时间；</p>
<h4 id="c-临时对象，右值引用，和五种值的关系"><a href="#c-临时对象，右值引用，和五种值的关系" class="headerlink" title="c++临时对象，右值引用，和五种值的关系"></a>c++临时对象，右值引用，和五种值的关系</h4><p>到这里，我们可以知道临时对象，是五种值来源的关键，而右值引用，是对临时对象带来的问题的解救；</p>
<h4 id="const-amp-和-amp-的区别和使用"><a href="#const-amp-和-amp-的区别和使用" class="headerlink" title="const &amp;和&amp; 的区别和使用"></a>const &amp;和&amp; 的区别和使用</h4><p>看下面这个例子，你会发现对汇编来讲，其实是一样的，但是编译器会检查你的行为，直接在编译阶段过滤掉你尝试对const的改动；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">| <span class="number">28</span>     movl    $<span class="number">3</span>, <span class="number">-28</span>(%rbp)                                                              |    <span class="number">19</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">| 29     leaq    -28<span class="params">(%rbp)</span>, %rax                                                            |    20 </span>&#123;</span><br><span class="line">| <span class="number">30</span>     movq    %rax, <span class="number">-24</span>(%rbp)                                                            |-   <span class="number">21</span>     A x1;</span><br><span class="line">| <span class="number">31</span>     leaq    <span class="number">-28</span>(%rbp), %rax                                                            ||   <span class="number">22</span>     x1.a = <span class="number">3</span>;</span><br><span class="line">| <span class="number">32</span>     movq    %rax, <span class="number">-16</span>(%rbp)                                                            ||   <span class="number">23</span> </span><br><span class="line">| <span class="number">33</span>     leaq    .<span class="built_in">LC0</span>(%rip), %rsi                                                           ||-- <span class="number">24</span>     <span class="type">const</span> A &amp;x2 = x1;</span><br><span class="line">| <span class="number">34</span>     leaq    _ZSt4cout(%rip), %rdi                                                      ||-- <span class="number">25</span>     A &amp;x3 = x1;                                                                       </span><br><span class="line">| <span class="number">35</span>     call    _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@PLT                ||   <span class="number">26</span>     std::cout&lt;&lt; <span class="string">&quot;x1.a &quot;</span> &lt;&lt; x1.a &lt;&lt; std::endl;</span><br><span class="line">| <span class="number">36</span>     movq    %rax, %rdx                                                                 ||   <span class="number">27</span> </span><br><span class="line">| <span class="number">37</span>     movl    <span class="number">-28</span>(%rbp), %eax                                                            ||   <span class="number">28</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                                                        </span><br></pre></td></tr></table></figure>

<h4 id="move移动语意"><a href="#move移动语意" class="headerlink" title="move移动语意"></a>move移动语意</h4><p>看下面的例子就知道了，move只是对封装了下，和const &amp;的引用类似；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="number">49</span>     movl    $<span class="number">3</span>, <span class="number">-20</span>(%rbp)                                                              |     <span class="number">9</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">| 50     leaq    -20<span class="params">(%rbp)</span>, %rax                                                            |    10 </span>&#123; </span><br><span class="line">| <span class="number">51</span>     movq    %rax, %rdi                                                                 |-   <span class="number">11</span>     A x1;</span><br><span class="line">| <span class="number">52</span>     call    _ZSt4moveIR1AEONSt16remove_referenceIT_E4typeEOS3_                         ||   <span class="number">12</span>     x1.a = <span class="number">3</span>;</span><br><span class="line">| <span class="number">53</span>     movq    %rax, <span class="number">-16</span>(%rbp)                                                            ||   <span class="number">13</span>                                                                                       </span><br><span class="line">| <span class="number">54</span>     leaq    .<span class="built_in">LC0</span>(%rip), %rsi                                                           ||-- <span class="number">14</span>     A &amp;&amp;x2 = std::<span class="built_in">move</span>(x1);</span><br><span class="line">| <span class="number">55</span>     leaq    _ZSt4cout(%rip), %rdi                                                      ||   <span class="number">15</span>     std::cout&lt;&lt; <span class="string">&quot;x1.a &quot;</span> &lt;&lt; x1.a &lt;&lt; std::endl;</span><br><span class="line">| <span class="number">56</span>     call    _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@PLT                ||   <span class="number">16</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="一些例子和基础使用："><a href="#一些例子和基础使用：" class="headerlink" title="一些例子和基础使用："></a>一些例子和基础使用：</h4><ul>
<li>左值引用可以被修改： 很明显就像指针；</li>
<li>右值引用不能被修改？ 为什么?<br>我们来看一个例子：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">                                                                                            ||   <span class="number">22</span>     A x1;</span><br><span class="line">                                                                                            ||   <span class="number">23</span>     x1.a = <span class="number">3</span>;</span><br><span class="line">| <span class="number">24</span>     subq    $<span class="number">32</span>, %rsp                                                                  ||-- <span class="number">24</span>     A&amp;&amp; x2 = <span class="built_in">A</span>();                                                                     </span><br><span class="line">| <span class="number">25</span>     movq    %fs:<span class="number">40</span>, %rax                                                               ||   <span class="number">25</span>     <span class="comment">//A&amp;&amp; x2 = std::move(x1);</span></span><br><span class="line">| <span class="number">26</span>     movq    %rax, <span class="number">-8</span>(%rbp)                                                             ||   <span class="number">26</span> </span><br><span class="line">| <span class="number">27</span>     xorl    %eax, %eax                                                                 ||   <span class="number">27</span>     std::cout&lt;&lt; <span class="string">&quot;x1.a &quot;</span> &lt;&lt; x1.a &lt;&lt; std::endl;</span><br><span class="line">| <span class="number">28</span>     movl    $<span class="number">3</span>, <span class="number">-24</span>(%rbp)                                                              ||   <span class="number">28</span> </span><br><span class="line">| <span class="number">29</span>     movl    $<span class="number">0</span>, <span class="number">-20</span>(%rbp)                                                              ||   <span class="number">29</span>     <span class="comment">//A x3;</span></span><br><span class="line">| <span class="number">30</span>     leaq    <span class="number">-20</span>(%rbp), %rax                                                            ||   <span class="number">30</span>     <span class="comment">//x3 = x1;//会默认将x1弄为const &amp;传递进去</span></span><br><span class="line">| <span class="number">31</span>     movq    %rax, <span class="number">-16</span>(%rbp)                                                            ||   <span class="number">31</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">| <span class="number">32</span>     leaq    .<span class="built_in">LC0</span>(%rip), %rsi                                                           |    <span class="number">32</span> &#125;</span><br><span class="line"></span><br><span class="line">从上面汇编可以看到，<span class="number">3</span>被直接赋值到<span class="number">-24</span>(%rbp)  即是x1.a=<span class="number">3</span>,这里没有显示定义构造函数，所以没有调用，所以，如果可以，就不要声明构造函数了，这样减少开销；</span><br><span class="line">接着将<span class="number">0</span> 给到<span class="number">-20</span>(%rbp),相当于在构造临时对象<span class="built_in">A</span>(),接着将A的地址给到<span class="number">-16</span>(%rbp)，即就是延长了<span class="built_in">A</span>()临时对象的寿命，后面可以通过右值引用使用<span class="built_in">A</span>()(不可写)</span><br><span class="line">所以右值引用，是一个临时对象的地址；当我们将左值赋给右值引用时，会出现问题，显然编译器不允许这样操作；</span><br><span class="line"></span><br><span class="line">这里好像还是没有解释为什么右值引用不能被修改： 这里明显是编译器的行为了;实际上它也是内存中的一块，但是编译器不允许你写；当检测到有写的操作时，会报错；</span><br><span class="line">即使是间接的，比如试图把<span class="type">const</span>指针赋值给指针，企图拿<span class="built_in">A</span>()的地址等；</span><br></pre></td></tr></table></figure>

<ul>
<li>其他的理解：</li>
</ul>
<ol>
<li>对vector的emplace_back，有如下几种情况：<br>(1) emplace_back(A()) &#x2F;&#x2F;将A的内存地址直接move；A()会被清理<br>(2) emplace_back(x) &#x2F;&#x2F;x是基础变量，则x的地址被拷贝；<br>(3) emplace_back(3) &#x2F;&#x2F;和push_back(int{3})没有区别，都需要再开辟一个内存地址,注意参数的不同<br>所以emplace_back要比push_back快一倍几乎；</li>
</ol>
<ul>
<li>各种例子：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="type">int</span> n; &#125;;</span><br><span class="line"><span class="keyword">extern</span> X x;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>;                   <span class="comment">// prvalue: does not have an identity</span></span><br><span class="line">x;                   <span class="comment">// lvalue</span></span><br><span class="line">x.n;                 <span class="comment">// lvalue</span></span><br><span class="line">std::<span class="built_in">move</span>(x);        <span class="comment">// xvalue</span></span><br><span class="line">std::forward&lt;X&amp;&gt;(x); <span class="comment">// lvalue</span></span><br><span class="line">X&#123;<span class="number">4</span>&#125;;                <span class="comment">// prvalue: does not have an identity</span></span><br><span class="line">X&#123;<span class="number">4</span>&#125;.n;              <span class="comment">// xvalue: does have an identity and denotes resources</span></span><br><span class="line">                     <span class="comment">// that can be reused</span></span><br></pre></td></tr></table></figure>
其他例子：ref:<br><a href="https://www.geeksforgeeks.org/understanding-lvalues-prvalues-and-xvalues-in-ccwith-examples/">https://www.geeksforgeeks.org/understanding-lvalues-prvalues-and-xvalues-in-ccwith-examples/</a><br><a href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a></li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++_valuetype</tag>
      </tags>
  </entry>
  <entry>
    <title>code_efficandreadable</title>
    <url>/2018/05/26/code-efficandreadable/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="论代码的效率和可读性的权衡"><a href="#论代码的效率和可读性的权衡" class="headerlink" title="论代码的效率和可读性的权衡"></a>论代码的效率和可读性的权衡</h2><h4 id="高效代码可读性差："><a href="#高效代码可读性差：" class="headerlink" title="高效代码可读性差："></a>高效代码可读性差：</h4><p>有一些代码，占用额外内存小，即run in place，且执行的速度快，即复杂度O()低，但是可读性差，即使注释了，修改起来也容易出错，如：<br>对链表的操作：举一个leetcode的例子：(这个例子不是很典型，能说明问题即可）<br>    reverse a linklist from m to n;<br>    1-&gt;3-&gt;4-&gt;5-&gt;null and m,n(ex:2,4);<br>    return 1-&gt;5-&gt;4-&gt;2-&gt;null;<br>   上面例子一开始可以想到，头插法，或者将范围内的那一段用新的处理过的链表替换掉，即只需要处理该片段的头和尾部，当然可能还有其他方法，这里先不考虑；<br>   于是，头插法不是很复杂，但是在这里不用额外的内存时，需要频繁的改变next指针和对pre元素做临时保存，使得代码可读性差，所以可以考虑以下方案：<br>   在替换的内存小时，可以采用后者，让代码可读性高些，方便维护和（被替代~更容易被炒鱿鱼的风险哈哈)<br>   在内存小时，采用前者，爱怎么指怎么指，看不懂不管哈哈哈</p>
]]></content>
      <categories>
        <category>代码整洁</category>
      </categories>
      <tags>
        <tag>代码可读性</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_class_memory</title>
    <url>/2018/06/09/cpp-class-memory/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c-类内存布局："><a href="#c-类内存布局：" class="headerlink" title="c++类内存布局："></a>c++类内存布局：</h3><h4 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h4><p>下编译后的“内存布局”，此时还未分配内存，不能算是内存，只能说是文件布局<span id="more"></span></p>
<ul>
<li>two question:<br> 多少内存能表现一个ob:?<br> 多少内存能表现一个class?–编译期，如　int 大小为４ </li>
<li>静态下，编译后同C一样分为代码段等；而类的特性有些类似于struct,定义类的文件中包含了成员变量，成员函数。</li>
<li>类：<br>  非静态成员变量：存于对象中<br>  vptr指针：存于对象中<br>  vt表:vptr指向这个表，这个表在构造函数中默认隐士初始化，将对应的虚拟函数地址赋给表中的各个值（表本身with”类”）<br>  obj:         class:<br>  _vptr —&gt;   table: ptr1 –&gt;virtual func1<br>                      ptr2 –&gt;virtual func2<br>  静态变量: 存入数据段中<br>  成员函数:代码段,通过this和成员变量建立联系<br>  静态函数：　存于代码段中<br>  全局函数<br>  main函数<br>  全局变量和静态变量<br>  局部变量：栈<br>  something extra depend on compiler~</li>
<li>some rules<ul>
<li>每个类产生一堆指向virtual func的指针，放在表格中，表称为：vtbl;   </li>
<li>每个obj被添加了一个指针，指向相关的tirtual table ,为vptr;</li>
<li>vptr的设定和重置由constructor，destructor,copy assignment运算服自动完成）　</li>
<li>注意每一个class所关联的type info object(用于支持runtime type identification  )也经由virtual table指出，放在vptr[0]处）</li>
<li>虚函数有可能被转换为：(*px-&gt;vtbl[1])(px)<br>具体见深入c++模型书</li>
</ul>
</li>
</ul>
<h4 id="多少内存能表现一个ob"><a href="#多少内存能表现一个ob" class="headerlink" title="多少内存能表现一个ob:?"></a>多少内存能表现一个ob:?</h4><ul>
<li>non static data members</li>
<li>padding</li>
<li>virtual—vptr<h4 id="多少内存能表现一个class"><a href="#多少内存能表现一个class" class="headerlink" title="多少内存能表现一个class?"></a>多少内存能表现一个class?</h4>见datamember_memory  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">最小是１　  size  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123; &#125;;   --<span class="number">-1</span> 一个<span class="type">char</span> 表示这个类型  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> :<span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;　　--指针大小，指针指向T    <span class="keyword">virtual</span> base <span class="keyword">class</span> <span class="title class_">subobject</span>  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> :<span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;  --指针大小</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> X,<span class="keyword">public</span> Y &#123;&#125;;　--两个指针大小　　```</span><br><span class="line">more seee datamember_memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 运行时</span><br><span class="line">的内存布局，即作为进程运行时，其内存是如何的；</span><br><span class="line"></span><br><span class="line">+ 运行时，涉及类的对象模型，对象的内存部分只包含非静态成员变量和虚拟函数指针表；</span><br><span class="line">+ 可以通过gdb 或kgdb进行查看类对象的地址或者类函数的地址：</span><br><span class="line"> ```cpp</span><br><span class="line">	Circle c12;</span><br><span class="line">		<span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">1.2</span>,<span class="string">&quot;red&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;getRadius:%x\n&quot;</span>,&amp;Circle::getRadius);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x, %x\n&quot;</span>,&amp;c12,c12);</span><br><span class="line"> <span class="type">void</span> *cc;</span><br><span class="line">        cc=(Circle*)(&amp;c12);</span><br><span class="line">		cout&lt;&lt;*((<span class="type">double</span>*)cc)&lt;&lt;endl;</span><br><span class="line">```		</span><br><span class="line">    		</span><br><span class="line">所以c++的对象带来的开销在于操作多态时的vptr等效率低）		</span><br><span class="line"></span><br><span class="line">一个例子</span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">					<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">					<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">					<span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">6</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;D&quot;</span>; &#125;</span><br><span class="line"><span class="number">0x400ae8</span> push   %rbp</span><br><span class="line"><span class="number">0x400ae9</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x400aec</span> mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">					<span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">8</span>;&#125;</span><br><span class="line"><span class="number">0x400af8</span> push   %rbp</span><br><span class="line"><span class="number">0x400af9</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x400afc</span> mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">		    A aa;</span><br><span class="line">			aa.<span class="built_in">getName</span>();</span><br><span class="line">		    D d;</span><br><span class="line">			d.<span class="built_in">getName</span>();</span><br><span class="line">			A &amp;rBase = d;</span><br><span class="line">			rBase.<span class="built_in">getName</span>();</span><br><span class="line"><span class="number">0x400986</span> mov    <span class="number">-0x28</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x40098a</span> <span class="built_in">mov</span>    (%rax),%rax</span><br><span class="line"><span class="number">0x40098d</span> <span class="built_in">mov</span>    (%rax),%rax</span><br><span class="line"><span class="number">0x400990</span> mov    <span class="number">-0x28</span>(%rbp),%rdx</span><br><span class="line"><span class="number">0x400994</span> mov    %rdx,%rdi</span><br><span class="line"><span class="number">0x400997</span> callq  *%rax</span><br><span class="line">            rBase.<span class="built_in">getage</span>();</span><br><span class="line"><span class="number">0x400999</span> mov    <span class="number">-0x28</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x40099d</span> <span class="built_in">mov</span>    (%rax),%rax</span><br><span class="line"><span class="number">0x4009a0</span> add    $<span class="number">0x8</span>,%rax</span><br><span class="line"><span class="number">0x4009a4</span> <span class="built_in">mov</span>    (%rax),%rax</span><br><span class="line"><span class="number">0x4009a7</span> mov    <span class="number">-0x28</span>(%rbp),%rdx</span><br><span class="line"><span class="number">0x4009ab</span> mov    %rdx,%rdi</span><br><span class="line"><span class="number">0x4009ae</span> callq  *%rax</span><br><span class="line">		    std::cout &lt;&lt; <span class="string">&quot;rBase is a &quot;</span> &lt;&lt; rBase.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">					 </span><br><span class="line">			D d2;</span><br><span class="line">            A &amp;rBase2 =d2;</span><br><span class="line"><span class="number">0x4009f9</span> lea    <span class="number">-0x30</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x4009fd</span> mov    %rax,<span class="number">-0x20</span>(%rbp)</span><br><span class="line">		   rBase2.<span class="built_in">getName</span>();	</span><br><span class="line"><span class="number">0x400a01</span> mov    <span class="number">-0x20</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a05</span> <span class="built_in">mov</span>    (%rax),%rax</span><br><span class="line"><span class="number">0x400a08</span> <span class="built_in">mov</span>    (%rax),%rax</span><br><span class="line"><span class="number">0x400a0b</span> mov    <span class="number">-0x20</span>(%rbp),%rdx</span><br><span class="line"><span class="number">0x400a0f</span> mov    %rdx,%rdi</span><br><span class="line"><span class="number">0x400a12</span> callq  *%rax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure></li>
</ul>
<p>something else:  </p>
<ul>
<li>成员函数也是只有一份被存于代码区中，而对象并没有指向成员函数的指针，对象只存成员和虚拟表　；那在对象.成员函数使用时，</li>
<li>是如何确定该函数中使用的成员是该对象的成员?<br>这里是this指针的作用<br>从汇编看，是否是成员函数在取的成员变量时，会做一些动作，这时的成员变量是在栈区；；<br>或者从调用成员函数时，是否有传入或控制函数的一些动作，让它知道从哪里取得对应的成员返回；</li>
<li>成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_conandde</title>
    <url>/2018/06/09/cpp-conandde/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="c-class-constructor-and-destructor"><a href="#c-class-constructor-and-destructor" class="headerlink" title="c++ class constructor and destructor"></a>c++ class constructor and destructor</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="构造函数表现"><a href="#构造函数表现" class="headerlink" title="构造函数表现"></a>构造函数表现</h4><h5 id="构造函数的作用："><a href="#构造函数的作用：" class="headerlink" title="构造函数的作用："></a>构造函数的作用：</h5><p>构造函数主要是用来初始化对象的－－－一般是成员，函数不用<br>–所以它需要在构建对象时就执行<span id="more"></span></p>
<h5 id="构造函数如何写："><a href="#构造函数如何写：" class="headerlink" title="构造函数如何写："></a>构造函数如何写：</h5><pre><code class="cpp">public:　classname(arg...):member(arg),mem2(arg),..&#123;xxx&#125;
    classname(..)&#123;..&#125;
</code></pre>
<h5 id="默认构造函数的生成规则（深入对象模型）"><a href="#默认构造函数的生成规则（深入对象模型）" class="headerlink" title="默认构造函数的生成规则（深入对象模型）"></a>默认构造函数的生成规则（深入对象模型）</h5><ul>
<li><p>下面四个情况下会生成默认构造函数（编译器控制）(nontrivial default constructor)  </p>
</li>
<li><p>带有default constructor的member class object<br> 即在类中带有对象成员，该对象成员所属的类有构造函数<br>如：　</p>
<pre><code class="cpp">class Foo &#123;public :Foo(),Foo(int)...&#125;
class Bar&#123;public:Foo foo;char *str&#125;;
                       void funv()
                       &#123;   Bar bar;....
                       &#125;```
这种情况下若程序员没有实现构造函数，则编译器会自己生成构造函数，来调用Foo的构造函数
但是不初始化str,这个得由程序员来做。
如类似于：
```cpp
Bar::Bar()&#123;
foo.Foo::Foo();
</code></pre>
<p> 若程序员自己写了构造函数但是不包括初始化foo则，编译器会在程序眼写的构造函数中加入上述，另外若有多个对象<br>则按照声明顺序进行调用他们的构造函数；</p>
</li>
<li><p>带有Default constructor 的base class<br> 同理，当继承的基类带有构造函数时就会加入，若程序员的构造函数没有初始化他们时就会扩展<br>&#x2F;&#x2F;以上见例子class_constructor.cpp，</p>
</li>
<li><p>和vcirtual相关need to create vptr<br> 带有一个virtual　func的class<br>  1)class　声明或继承一个virtua func<br>  2)class派生自一个继承琏，其中有virtual base classes       这个比较容易理解</p>
</li>
<li><p>和virtual相关 need to init vptr<br>带有一个virtual　base class 的class<br>如：<br><code>cpp class X&#123;  public int i;&#125;   class A :public virtual X &#123;/// class B :public virtual X &#123; class C: public A,public B </code></p>
</li>
</ul>
<h5 id="构造函数何时被执行"><a href="#构造函数何时被执行" class="headerlink" title="构造函数何时被执行"></a>构造函数何时被执行</h5><p>-在对象定义时若有构造函数，则会执行</p>
<h5 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h5><p>1:5构造函数的使用：重载，初始化式</p>
<h4 id="构造函数表现的原理"><a href="#构造函数表现的原理" class="headerlink" title="构造函数表现的原理"></a>构造函数表现的原理</h4><h5 id="构造函数在静态代码块中的位置和符号体现"><a href="#构造函数在静态代码块中的位置和符号体现" class="headerlink" title="构造函数在静态代码块中的位置和符号体现"></a>构造函数在静态代码块中的位置和符号体现</h5><p>如果有定义构造函数，它本身也是一个函数，放在代码段中，可以通过kdbg查看</p>
<pre><code class="c">origin(int ax=3,int bx=4):a(ax),b(bx)&#123;&#125;
0x400bae push   %rbp
0x400baf mov    %rsp,%rbp
0x400bb2 mov    %rdi,-0x8(%rbp)
0x400bb6 mov    %esi,-0xc(%rbp)
0x400bb9 mov    %edx,-0x10(%rbp)```
##### 构造函数在动态执行时，放在哪个内存段中，如何被引用，使用
+ 动态执行时，在代码段中，通过this引用
+ 构造函数总结：任何c++ class只有在以上四中情况下才会产生默认构造函数，且产生的默认构造函数不会去初始化成员的值
### 拷贝构造函数
#### 拷贝的动作发生了什么
拷贝的本质，为什么需要拷贝构造函数？
+ 首先对基本的类型而言，拷贝是把值赋给另一个同类型的变量，而数租不能做=赋值拷贝
+ 对对象而言，也是把值赋给同类型的对象，而不是共享一个指针，所以这个过程需要将对象中的成员也复制过去（复制的是当前对象在此时时成员的值　）
+ c++中的拷贝构造函数针对三种行为：＝　，f(T t)和　f()&#123;T t;return t&#125;返回对象－－这三种情况都针对左值的　　　
+ =:注意这个是在定义时做的，如origin or1=or2;此时会调用&quot;拷贝构造函数&quot;（　同or1(or2))
　or2=or3;此时不会调用拷贝构造函数
（当程序员自己写了拷贝构造函数时，默认调用该构造函数，而不会区做成员复制，所以若在其中没有做复制，可能得到不想要的值，见例子)

#### 拷贝构造函数的作用和使用
##### 什么情况下会生成默认的拷贝构造函数？
类似于构造函数，在以下情形会生成默认的拷贝构造函数－
+ 当需要调用别的拷贝构造函数时，如：当类内含有一个member object而后者的class声明有一个copy　constructor时；
+ 当类继承自一个base class而后者有拷贝构造函数
+ 当类声明了一个或多个virtual functions时
+ 当class 派生自一个继承　串琏，而其中有一个或多个virtual base classes 时

#### 拷贝构造函数和编译器－－－汇编，转换：
分三种情况讨论：
+ 初始化拷贝构造：
```cpp
                   X x1(x0);
                   X x2=x0;
                   X x3=X(x0);```
   上述三种都是定义一个类，即定义的本质会在内存中开辟空间
上述三个都会执行拷贝构造函数，如何执行？  
会被转换为：伪代码
        X x1;
        x1.X::X(x0);
        会调用X::X(const X&amp; xx) 
        x2,x3也是这样，将拷贝方作为函数参数传入
        这样就可以解释为什么拷贝构造函数的定义是      
        classname (const classname &amp;obj)
+ 参数的初始化
即传入一个参数给函数：
       foo(X x)
如：
       X xx;
       //,..
       foo(xx);
       则会产生一个临时的对象：
 伪代码
        X __temp0;
        _temp0.X::X(xx);//use copy construtor
         foo(__temp0)
这里因为它是临时的，所以则定义的时候需要用引用foo(X &amp;x)//这里不是很清楚为什么用引用～！，是否后面的操作直接面向该对象，需要做实际的修改，所以。。
所以，为了对付临时的对象，在执行完函数后，需要调用该对象的析构函数
+ 返回值的初始化：  
如
       X bar()&#123;
                      X xx;
                       //...
                       return xx;
            &#125;
         如何做X xxx=bar();如何拷贝的？双阶段初始化：
         a 增加一个额外的引用参数给函数，如void bar(X＆　_result)
         b 在return 前插入一个copy constructor 
             void bar(X &amp;__result)&#123;
                       X xx;
                       xx.X::X();
                       __result.X::XX(xx);
                       return ;
               &#125;
        所以上述会被转化为：
        Ｘ　xx=bar()  ---&gt;  X xx ;//注意这里不会执行默认构造函数　　bar(xx);
            ex:bar().memfunc()---&gt;X __temp0;(bar(__temp0),__temp0).memfunc();
            X (*pf)();pf=bar;---&gt;void (*pf)(X&amp;);pf=bar;
            
##### 关于上述三种情况的优化：
１)在使用者层面上优化；２）在编译器层面的优化（ＮＲＶ）具体见深入模型（书）
##### 关于该不该编写copy  constructor: 
除非需要大量的memberwise 初始化操作，如传值给object以便做NRV优化，否则不需要
//上述情况的检验可以通过代码，或者去看编译器的生成代码～    
##### 拷贝构造函数的内存
放在代码段，
### 初始化队列
即构造函数的一种形式如：X(int f):a(ax),b(bx)..&#123;....&#125;
+ 问题：什么时候用初始化列表？它和初始化赋值有什么不同？
        有以下四种情况需要使用初始化列表：
        １）当初始化一个reference member时
        ２）当初始化一个const member时
        ３）当调用一个base class的constructor,当它拥有一组参数时
        ４）当调用一个member　class 的consructor，而它有一组参数时；
如
``cpp
   class world &#123;
          String _nhame;
          int cnt;
          public :world()&#123;_nhame=0;cnt=0;&#125;&#125;```
//此时，对_nhame这个成员，需要做较多的事，如产生临时对像，调用operator=....
   －－－－所以想到用初始化列表：
```cpp 
          world::world:nhame(0)&#123;
            cnt=0;
            &#125;
            这样只会调用nhame的构造函数
            会被转换为：world::world&#123; //伪代码
             _nhame.String::String(0);
              cnt=0;
              &#125;```
+ 更具体的，初始化列表如何进行：顺序如何：如前，初始化列表最终会被转换为初始化表达式到构造函数体中，那是什么顺序呢？  
注意这里的初始化顺序是根据成员在类中的定义（声明）顺序来的，而不是初始化列表中的顺序
看这个例子：
```cpp 
       class X&#123;
                    int i; 
                    int j;
                   public:
                     X(int cal):i(j)&#123;&#125;
                     ...
                     此时，因为i先初始化,再j,出错，i需要j```
                     
  ----&gt;可以改善为：X::X(int cal):j(cal)&#123;i=j;&#125;   
   ----为什么这样可以？  
   因为初始化列表的内容会放到初始化体中的表达式前面，这样j就会先定义
        －－－－》另一个可能出错的例子：
        　　　X::X(int cal):i(xfoo(cal)),j(cal)&#123;&#125;
        --&gt;转换为：X::X(/*this pointer*/ int cal)&#123;
                      i=this-&gt;xfoo(cal);
                      j=cal;
                      &#125;
            这个情况在这里是对的，但是当X 继承自某个类，在xfoo是基类的函数，，则会出错this-&gt;xfoo

#### 几个问题：
+ 较为简单的例子见文件中的例子
+ 当程序员定义了拷贝构造函数时，还会执行memberwise initialization吗　－－会执行拷贝构造函数
参考：深入c++对象模型和http://en.cppreference.com/w/cpp/language/copy_constructor
</code></pre>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_conanddest_semantics</title>
    <url>/2018/06/09/cpp-conanddest-semantics/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="构造和析构函数语义学"><a href="#构造和析构函数语义学" class="headerlink" title="构造和析构函数语义学"></a>构造和析构函数语义学</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>即使是abstract base class也可能需要手动写constructor,de…,关键是看它有没有non satic data member  <span id="more"></span><br>例如:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">Abstract_class</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">         <span class="keyword">virtual</span> ~<span class="built_in">Abstract_base</span>() = <span class="number">0</span>;</span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">interface</span><span class="params">()</span> <span class="type">const</span></span>=<span class="number">0</span>;</span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">mumble</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> _mumble;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">protected</span>:</span><br><span class="line">         <span class="type">char</span> *_mumble;</span><br><span class="line">    &#125;;```</span><br><span class="line">  上述例子，该抽象类本身不能被实例化，但是可以被继承，被继承时在构造时必须初始化 “mumble”,此时就需要用它的默认构造函数，所以必须为这个抽象类写一个构造函数；   </span><br><span class="line">  </span><br><span class="line">#### <span class="number">2.</span> 纯虚函数的存在： </span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstra_class</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">	   <span class="comment">// virtual ~Abstra_class() =0;</span></span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Abstra_class</span>() &#123; <span class="keyword">delete</span> _mumble;cout&lt;&lt;<span class="string">&quot;use ~abstra_class&quot;</span>;&#125;</span><br><span class="line">		<span class="comment">//virtual void interface() const=0;</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">interface</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;use interface Abstra_class:&quot;</span>;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> _mumble;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Abstra_class</span>()&#123;_mumble=<span class="keyword">new</span> <span class="type">char</span>[<span class="number">4</span>];cout&lt;&lt;<span class="string">&quot;construct:Abs..&quot;</span>;&#125;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="type">char</span>* _mumble;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dev</span> : <span class="keyword">public</span> Abstra_class &#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				~<span class="built_in">dev</span>() &#123;dd=<span class="number">0</span>;&#125;</span><br><span class="line">				<span class="built_in">dev</span>()&#123;dd=<span class="number">3</span>;&#125;</span><br><span class="line">				<span class="function"><span class="type">void</span> <span class="title">useA</span> <span class="params">()</span></span>&#123;</span><br><span class="line">               Abstra_class::<span class="built_in">interface</span>();<span class="comment">//即使可以这样，但是链接失败，即因该函数的定义=0,重新加上定义使之不为pure就ok了</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">interface</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">if</span>(dd==<span class="number">4</span>)cout&lt;&lt;<span class="string">&quot;re&quot;</span>;&#125;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="type">int</span> dd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  dev ddd;</span><br><span class="line">		ddd.<span class="built_in">useA</span>();</span><br><span class="line">		ddd.<span class="built_in">interface</span>();</span><br><span class="line">	  <span class="comment">//  Abstra_class::interface();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：construct:Abs..use interface Abstra_class:use ~Abstra_class: </p>
<p>　“可以定义和调用pure virtual func ,但是只能被静态的调用，而不能通过虚拟机制 “这个在g++上实验了下，发现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstra_class</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">	   <span class="comment">// virtual ~Abstra_class() =0;</span></span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Abstra_class</span>() &#123; <span class="keyword">delete</span> _mumble;cout&lt;&lt;<span class="string">&quot;use ~Abstra_class:&quot;</span>;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">interface</span><span class="params">()</span> <span class="type">const</span></span>=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//virtual void interface() const &#123; cout&lt;&lt;&quot;use interface Abstra_class:&quot;;&#125;</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> _mumble;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span>  <span class="title">ii</span><span class="params">()</span> <span class="type">const</span></span>=<span class="number">0</span>;<span class="comment">//ensure is a abstra class</span></span><br><span class="line">		<span class="built_in">Abstra_class</span>()&#123;_mumble=<span class="keyword">new</span> <span class="type">char</span>[<span class="number">4</span>];cout&lt;&lt;<span class="string">&quot;construct:Abs..&quot;</span>;&#125;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="type">char</span>* _mumble;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Abstra_class::interface</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dev</span> : <span class="keyword">public</span> Abstra_class &#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				~<span class="built_in">dev</span>() &#123;dd=<span class="number">0</span>;&#125;</span><br><span class="line">				<span class="built_in">dev</span>()&#123;dd=<span class="number">3</span>;&#125;</span><br><span class="line">				<span class="function"><span class="type">void</span> <span class="title">useA</span> <span class="params">()</span></span>&#123;</span><br><span class="line">                Abstra_class::<span class="built_in">interface</span>();<span class="comment">//即使可以这样，但是链接失败，即因该函数的引用为0</span></span><br><span class="line">		           dd=<span class="number">4</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">interface</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">						<span class="keyword">if</span>(dd==<span class="number">4</span>)cout&lt;&lt;<span class="string">&quot;\nre\n&quot;</span>;</span><br><span class="line">						<span class="comment">//Abstra_class::interface();</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ii</span><span class="params">()</span> <span class="type">const</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;is implenment&quot;</span>;&#125;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="type">int</span> dd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  dev ddd;</span><br><span class="line">		ddd.<span class="built_in">useA</span>();</span><br><span class="line">		ddd.<span class="built_in">interface</span>();</span><br><span class="line">	Abstra_class *pt=&amp;ddd;</span><br><span class="line">	pt-&gt;<span class="built_in">interface</span>();</span><br><span class="line">	  <span class="comment">//  Abstra_class::interface();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出了两次re,说明可以通过虚拟机制调用它；interface在这里被内联的定义了空的函数，它不算pure了，所以上述说法感觉存在问题。。。<br>　注意，因为在每一个derived class　destructor会被扩展，以静态方式调用每一个virtual base class 和上一层的desturctor,<br>     所以只要缺少任何一个 base destructor定义则链接失败　，所以需要定义pure virtual destructor<br>      一个比较好的替代方式就是不要把vitual dect~定义为pure<br>      考虑到成本，不要把所有的函数都定以为virtual</p>
<p>3)虚拟规格的存在：<br>　　　　在virtual func要不要为const ,主要看要不要对date member做修改<br>所以不要随便定义为pure,virtual const,毕竟效率</p>
<h4 id="考虑几种情况下的构造情况："><a href="#考虑几种情况下的构造情况：" class="headerlink" title="考虑几种情况下的构造情况："></a>考虑几种情况下的构造情况：</h4><h5 id="一、无继承情况下对象构造几种方式："><a href="#一、无继承情况下对象构造几种方式：" class="headerlink" title="一、无继承情况下对象构造几种方式："></a>一、无继承情况下对象构造几种方式：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point global;　<span class="comment">//周期：程序的生命周期，exit前</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Point local;　<span class="comment">//此函数的周期，调用默认构造函数但是不会初始化成员</span></span><br><span class="line">   Point *heap=<span class="keyword">new</span> Point;<span class="comment">//delete 前，调用默认构造函数，但不会初始化成员</span></span><br><span class="line">   *heap=local;<span class="comment">//local若未调用用户初始化的构造函数，则warning,调用拷贝赋值函数，maybe 位搬移</span></span><br><span class="line">   <span class="keyword">delete</span> heap;<span class="comment">//默认析构函数</span></span><br><span class="line">   <span class="keyword">return</span> local;<span class="comment">//maybe拷贝构造或者位搬移</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>考虑这几个对象的声明周期</li>
<li>在c中，global会被放入bss中，未初始化，但是c++中所有的全局对象被当做“初始化过的数据”，会调用constructor函数　可以测试一下</li>
<li>一般情况下，c++默认为类生成：default constructor,destructor,copy constructor,copy assignment operator<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">			<span class="built_in">Point</span> ()&#123;cout&lt;&lt;<span class="string">&quot;in constructor &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">			~<span class="built_in">Point</span>() &#123;cout&lt;&lt;<span class="string">&quot;in destructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point glo;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;```</span><br><span class="line">显然在定义Point glo的时候构造函数是会调用的</span><br><span class="line"></span><br><span class="line">１、抽象数据类型：</span><br><span class="line">　　根据需要决定是否写constructor destructor或者默认的就足够了</span><br><span class="line">　　　global类型的对象直到程序激活才调用构造函数</span><br><span class="line">　　　显性的初始化列表比将构造函数扩展为<span class="keyword">inline</span>效率更高，后者需要赋值等，看下面例子：</span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x = <span class="number">0.0</span>, <span class="type">double</span> y = <span class="number">0.0</span>, <span class="type">double</span> z = <span class="number">0.0</span>) :_x(x), _y(y), _z(z)&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; cout &lt;&lt; _x &lt;&lt; endl &lt;&lt; _y &lt;&lt; endl &lt;&lt; _z &lt;&lt; endl; &#125;;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">double</span> _x, _y, _z;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    Point local1 = &#123; <span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span> &#125;;<span class="comment">//用g++ --std=c++11可以，若为double a=1.5; ..=&#123;a,...&#125;变量形式则不行（c++11可以） </span></span><br><span class="line">    local1.<span class="built_in">print</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; ``` </span><br><span class="line">而在显性初始化列表（<span class="keyword">explicit</span> initialization list)-&gt;xxx=&#123;yyy&#125;;使用时较快是如下原因：  </span><br><span class="line">函数的activation record 被放进程序的堆栈时，initializatioin list 中的常量就可以被放进local1的内存中了;  </span><br><span class="line">但是<span class="keyword">explicit</span> initialization list带来三个缺点：</span><br><span class="line">+ 只有当<span class="keyword">class</span> <span class="title class_">member</span> 都是<span class="keyword">public</span>时才生效，这点实验<span class="keyword">private</span>时也可以  </span><br><span class="line">+ 只能在&#123; &#125;中指定常量，因为在编译期间进行评估求值</span><br><span class="line">+ 由于编译器为自动施行，所以失败的可能性更高  </span><br><span class="line">看一下汇编代码：</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span>  y = <span class="number">0</span>, <span class="type">int</span> z = <span class="number">0</span>) :_x(x), _y(y), _z(z)&#123;&#125;  </span><br></pre></td></tr></table></figure>
 <figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x400938</span> push   <span class="variable">%rbp</span></span><br><span class="line"><span class="number">0x400939</span> mov    <span class="variable">%rsp</span><span class="punctuation">,</span><span class="variable">%rbp</span></span><br><span class="line"><span class="number">0x40093c</span> mov    <span class="variable">%rdi</span><span class="punctuation">,</span><span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="variable">%rbp</span>)</span><br><span class="line"><span class="number">0x400940</span> mov    <span class="variable">%esi</span><span class="punctuation">,</span><span class="number">-0</span>xc(<span class="variable">%rbp</span>)</span><br><span class="line"><span class="number">0x400943</span> mov    <span class="variable">%edx</span><span class="punctuation">,</span><span class="number">-0</span><span class="keyword">x</span><span class="number">10</span>(<span class="variable">%rbp</span>)</span><br><span class="line"><span class="number">0x400946</span> mov    <span class="variable">%ecx</span><span class="punctuation">,</span><span class="number">-0</span><span class="keyword">x</span><span class="number">14</span>(<span class="variable">%rbp</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; cout &lt;&lt; _x &lt;&lt; endl &lt;&lt; _y &lt;&lt; endl &lt;&lt; _z &lt;&lt; endl; &#125;;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> _x, _y, _z;  </span><br><span class="line">&#125;;   </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="type">int</span>  a=<span class="number">1</span>;	</span><br><span class="line">    Point local1 = &#123; a, <span class="number">4</span>, <span class="number">5</span>&#125;;```</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>0x4008a4 mov    -0x24(%rbp),%esi<br>0x4008a7 lea    -0x20(%rbp),%rax<br>0x4008ab mov    $0x5,%ecx<br>0x4008b0 mov    $0x4,%edx<br>0x4008b5 mov    %rax,%rdi<br>0x4008b8 callq  0x400938 &lt;Point::Point(int, int, int)&gt;</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">上述讲的activation record是：  </span><br><span class="line">+ Locals <span class="keyword">to</span> the callee</span><br><span class="line">+ Return address <span class="keyword">to</span> the caller</span><br><span class="line">+ Parameters <span class="keyword">of</span> the callee  </span><br><span class="line">从上述的汇编代码可以看到，在做显示初始化列表时将常量值赋给ecx等两个寄存器，接着调用构造函数，构造函数将寄存器的内容赋给成员，而其实采用Point local2;这种直接调用构造函数的发式也是如此，且和在构造函数中赋值给成员时转换的汇编相同，所以不是很理解这块的区别，在g++ c++<span class="number">11</span>是如此表现的    </span><br><span class="line">##### ２、为继承做准备：  </span><br><span class="line">继承可能用到多态，此时需要使用<span class="keyword">virtual</span> ,那就会带来constructor等函数中加入对vptr的初始化（copy constructor等）</span><br><span class="line">c++标准会要求编译器尽量延迟对nontrivial members的实际合成 操作，直到真正遇到其使用场合：这里trivial意思是无意义，这个trivial和non-trivial是对类的四种函数来说的：</span><br><span class="line"></span><br><span class="line">    构造函数(ctor)  </span><br><span class="line">    复制构造函数(copy)  </span><br><span class="line">    赋值函数(assignment)  </span><br><span class="line">    析构函数(dtor)  </span><br><span class="line"></span><br><span class="line">如果至少满足下面<span class="number">3</span>条里的一条：</span><br><span class="line"></span><br><span class="line">    显式(explict)定义了这四种函数。</span><br><span class="line">    类里有非静态非POD的数据成员。</span><br><span class="line">    有基类。</span><br><span class="line"></span><br><span class="line">那么上面的四种函数是non-trivial函数，比如叫non-trivial ctor、non-trivial copy…，也就是说有意义的函数，里面有一下必要的操作，比如类成员的初始化，释放内存等。   </span><br><span class="line"></span><br><span class="line">##### 二、继承体系下的对象构造：  </span><br><span class="line">constructor函数中的隐藏代码，  </span><br><span class="line"><span class="number">1.</span> 初始化列表  </span><br><span class="line"><span class="number">2.</span> member的默认构造函数,若该member未出现在初始化列表中</span><br><span class="line"><span class="number">3.</span> vptr，在<span class="number">1</span>,<span class="number">2</span>之前，指向vtable   </span><br><span class="line"><span class="number">4.</span> base <span class="keyword">class</span> constructor  <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>之前，以声明顺序为顺序，若在member initialization <span class="built_in">list</span>中，则应传递参数，否则在<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>前加入其默认构造函数。多继承时可能this指针调</span><br><span class="line"><span class="number">5.</span> <span class="keyword">virtual</span> base <span class="keyword">class</span> constructor，从左到右，从最深到最浅 ，同<span class="number">4</span>，若在<span class="built_in">list</span>中有则用，否则。。  </span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">```cpp</span><br><span class="line"> <span class="keyword">class</span> Point&#123;</span><br><span class="line">   public:</span><br><span class="line">    Point (<span class="built_in">float</span> x=<span class="number">0.0</span>,<span class="built_in">float</span> y=<span class="number">0.0</span>);  </span><br><span class="line">    <span class="constructor">Point(<span class="params">const</span> Point&amp;)</span>;</span><br><span class="line">    Point&amp; operator=(const Point&amp;);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">Point()</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">float</span> z<span class="literal">()</span> &#123;return <span class="number">0.0</span>;&#125;</span><br><span class="line">   protected:</span><br><span class="line">   <span class="built_in">float</span> _x,_y;</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">class</span> line &#123;</span><br><span class="line">    Point _begin,_end;</span><br><span class="line">    public:</span><br><span class="line">      <span class="constructor">Line(<span class="operator">...</span>.)</span>;</span><br><span class="line">      <span class="constructor">Line(<span class="operator">...</span>)</span>;</span><br><span class="line">      &#125;;```</span><br><span class="line">line的默认析构函数会被合成，但是无意义，当然它的member的默认析构函数会被加入。。。其他类似</span><br><span class="line"></span><br><span class="line">##### 三、虚拟继承：</span><br><span class="line">+ 考虑下面的例子：</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> Point3d:public <span class="keyword">virtual</span> Point&#123;</span><br><span class="line">    public:</span><br><span class="line">       <span class="constructor">Point3d(<span class="params">float</span> <span class="params">x</span>=0.0,<span class="params">float</span> <span class="params">y</span>=0.0,<span class="params">float</span> <span class="params">z</span>=0.0)</span>:<span class="constructor">Point(<span class="params">x</span>,<span class="params">y</span>)</span>,<span class="constructor">_z(<span class="params">z</span>)</span>&#123;&#125;</span><br><span class="line">       <span class="constructor">Point3d(<span class="params">const</span> Point3d&amp; <span class="params">rhs</span>)</span>:point(rhs),<span class="constructor">_z(<span class="params">rhs</span>.<span class="params">_z</span>)</span>&#123;&#125;</span><br><span class="line">       ~<span class="constructor">Point3d()</span>;</span><br><span class="line">       Point3d&amp; operator=...</span><br><span class="line">       <span class="comment">//..</span></span><br><span class="line">      proteced:</span><br><span class="line">      <span class="built_in">float</span> _z;</span><br><span class="line">      &#125;```</span><br><span class="line">  传统的如上面的扩充构造函数：</span><br><span class="line">  ```cpp</span><br><span class="line">  this-&gt;<span class="constructor">Point(:Point(<span class="params">x</span>,<span class="params">y</span>)</span>;</span><br><span class="line">  this-&gt;_vptr_Point3d = vtbl_Point3d;</span><br><span class="line">  this-&gt;_vptr_point3d_point=_vtbl_point3d_point;</span><br><span class="line">  this-&gt;_z=rhs_z;</span><br><span class="line">  return this```</span><br><span class="line">  但是在这里，虚拟继承这显然不够准确：　　</span><br><span class="line">  考虑当出现菱形继承：　　</span><br><span class="line">  ```cpp</span><br><span class="line">  <span class="keyword">class</span> Vertex:<span class="keyword">virtual</span> public Point;</span><br><span class="line">  <span class="keyword">class</span> Vertex3d:public Point3d,public Vertex&#123;;&#125;;</span><br><span class="line">  <span class="keyword">class</span> Pvertex:public Vertex3d&#123;;&#125;;&#x27;```</span><br><span class="line">  </span><br><span class="line">  那作为被共享的Point subobject应该由最底层的如Vertex3d来初始化：</span><br><span class="line">  而最底层显然也会初始化Point3d和vertex,并调用他们的构造函数；如果他们的构造函数不加限制，就会又调用Point的构造，导致错误；　　</span><br><span class="line">  所以应该做限制，如下：  </span><br><span class="line">  ```cpp</span><br><span class="line">  Vertex3d::<span class="constructor">Vertex3d(Vertex3d <span class="operator">*</span><span class="params">this</span>,<span class="params">bool</span> <span class="params">__most_derived</span>,<span class="params">float</span> <span class="params">x</span>,<span class="params">float</span> <span class="params">y</span>,<span class="params">float</span> <span class="params">z</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(__most_derived!=<span class="literal">false</span>)<span class="comment">//判断是否为最底层</span></span><br><span class="line">     this-&gt;Point::<span class="constructor">Point(<span class="params">x</span>,<span class="params">y</span>)</span>;<span class="comment">//是则构造最上层的</span></span><br><span class="line">     <span class="comment">//调用上一层的base classes</span></span><br><span class="line">     <span class="comment">//设定__most_derived为false</span></span><br><span class="line">  this-&gt;Point3d::<span class="constructor">Ponint3d(..)</span>;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>而在   </p>
<p><code>cpp Point3d::Point3d(Point3d* this,...) &#123;    if(___most_derived!=false)       this-&gt;Point::Point(x,y);       ....       &#125;</code><br>所以最底层的构造函数等会限制中间层对最上层的构造</p>
<ul>
<li>思考：</li>
<li>当obj只是某个完整的obj的子obj时，则不用调用virtual base class constructor:,如上，那就产生了一种提高效率的方式：</li>
<li>将构造函数分割为obj和subobj,，前者为完整版本的obj，自然要调用所有，包括基类的构造，后者不用，这种分裂可以提高效率</li>
</ul>
<h4 id="vptr初始化语意"><a href="#vptr初始化语意" class="headerlink" title="vptr初始化语意"></a>vptr初始化语意</h4><ul>
<li>题外，这本书总喜欢讨论特殊的情况，哭笑，下面也是，在构造函数中调用虚函数222</li>
<li>主要讨论vptr什么时候初始化合适，以及为什么</li>
<li>constructor调用顺序：考虑：<br><code>cpp class Vertex:virtual public Point; class Vertex3d:public Point3d,public Vertex&#123;;&#125;; class Pvertex:public Vertex3d&#123;;&#125;;&#39;</code><br>当一个PVertex对象被构造时，构造函数顺序为：　　<br>Point<br>Point3d<br>Vertex<br>Vertex3d<br>Pvertex  </li>
<li>假设这个继承体系中的每一个类都定义了一个virtual func size()，该函数负责传回class的大小；如果我们写：<br>Pvertex pv;<br>Point3d p3d;<br>Point  *pt&#x3D;&amp;pv;<br>那么这个调用pt-&gt;size()传回PVertex的大小，而<br>pt&#x3D;&amp;p3d; pt-&gt;size()则传回p3d的大小；</li>
<li>更进一步，特殊情况：<br>当在构造函数中调用这个操作时，如在point3d构造函数中调用时，是选择哪个class的size,毕竟现在正在构造point3d,答案是point3d的</li>
<li>考虑如何使得上述生效?</li>
<li>静态调用Point3d::size()或者bnalalla</li>
<li>最后，利用vptr虚拟机制，即要在调用size之前初始化好其class对应的vptr</li>
<li>总结：在这种情况下，vptr在base class constructor 调用之后，在程序员代码之前（如size),或是初始化列表所列的member初始化操作前</li>
<li>更好的，分割constructor为完整obj和subobj</li>
</ul>
<h3 id="对象复制语意学"><a href="#对象复制语意学" class="headerlink" title="对象复制语意学"></a>对象复制语意学</h3><h4 id="复制函数什么时候会被合成和使用"><a href="#复制函数什么时候会被合成和使用" class="headerlink" title="复制函数什么时候会被合成和使用"></a>复制函数什么时候会被合成和使用</h4><ul>
<li>前言，当你设计一个类，并以一个对象复制给另一个对象时，有三种选择：  </li>
<li>什么也不做，实行默认行为  </li>
<li>提供一个显性拷贝函数</li>
<li>拒绝，只需要把复制函数声明为private就可以 </li>
<li>考虑默认的行为：</li>
<li>bitwise copy行为，当不出现一下情况时，甚至不会调用复制函数，而是做bitwise copy</li>
<li>而当出现以下行为时，调用默认的copy assignment operator函数，并合成相关操作：　　<ol>
<li>当class中有mem obj，这个obj有一个copy ass operaator</li>
<li>当类的基类有copy assi opera..</li>
<li>类带virtual func</li>
<li>继承自一个virtual base class</li>
</ol>
</li>
<li>写一个显性的复制函数：  <ul>
<li>在发生上述情况时，编译器也会像合成构造函数一样在显性的复制函数中加东西</li>
<li>而继上面的，Point共享基类，编译器如何能在Point3d和Vertex的copy assignment operator中压抑point的copy assignment operator呢?</li>
<li>书中的后面有些难以理解，等后面再探索吧，哎时间有限。。<h3 id="对象的功能"><a href="#对象的功能" class="headerlink" title="对象的功能"></a>对象的功能</h3>测试对象构造和拷贝的成本，在从简单形式，单一继承，到多重继承，虚拟继承等情况下的时间复杂度<h3 id="解构语意学"><a href="#解构语意学" class="headerlink" title="解构语意学"></a>解构语意学</h3></li>
</ul>
</li>
<li>析构函数并不会总是被合成出来，更别提调用；</li>
<li>只有在类内带的member object或者自己的base class带有destructor，编译器才会合成一个析构函数，否则被视为不需要或者不用合成调用</li>
<li>析构函数没必要和构造函数对称</li>
<li>析构函数一般有以下顺序：<ul>
<li>先调用最底层子类析构函数，接着往上，直到基类</li>
<li>析构函数本身在被执行时，vprt会在程序员代码前被执行</li>
<li>若class拥有member class object ,而后者拥有destructor,则他们会以其声明顺序相反顺序被调用</li>
<li>如果object内带一个vptr,则首先重设相关的virtual table</li>
<li>若有任何直接的非虚基类拥有析构函数，则同上</li>
<li>若有虚基类，则按照构造顺序相反顺序调用</li>
</ul>
</li>
<li>类似于构造函数，可以分裂</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_const</title>
    <url>/2018/06/08/cpp-const/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c-关键词之const"><a href="#c-关键词之const" class="headerlink" title="c++关键词之const"></a>c++关键词之const</h3><h4 id="const介绍，用法，原理，注意点等"><a href="#const介绍，用法，原理，注意点等" class="headerlink" title="const介绍，用法，原理，注意点等"></a>const介绍，用法，原理，注意点等</h4><h5 id="const-介绍："><a href="#const-介绍：" class="headerlink" title="const 介绍："></a>const 介绍：</h5><p>const是用于标示不可修改的变量，对象或函数的。<br>在其前面添加const就无法在之后做修改  </p>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法 "></a>用法 <span id="more"></span></h5><p>const总结起来有以下用法：</p>
<ul>
<li>const 修饰基本类型的变量  </li>
<li>const int xx&#x3D;4; const double xd&#x3D;3.3;   </li>
<li>const int array[3]&#x3D;{3,4,5};</li>
<li>const　修饰指针和引用</li>
<li>const 指针： </li>
<li>const int *p&#x3D;&amp;value;<br>  &#x2F;&#x2F;无法改变指针指向的值，但是可以改变指针,<br>  value可以是int value;&#x2F;const int value;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">          <span class="type">int</span> va=<span class="number">4</span>;</span><br><span class="line">    <span class="number">6</span>         <span class="type">const</span> <span class="type">int</span> *p=&amp;va ;</span><br><span class="line">    <span class="number">7</span>         va=<span class="number">5</span>;</span><br><span class="line">&gt;&gt;  <span class="number">8</span>         *p=<span class="number">6</span>;<span class="comment">//error</span></span><br><span class="line">    <span class="number">9</span>         cout&lt;&lt;*p&lt;&lt;endl;<span class="comment">//5</span></span><br><span class="line">   <span class="number">10</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>int *const p&#x3D;&amp;value; &#x2F;&#x2F;无法改变指针的值，但是可以改变指针指向的值</li>
<li>const int *const p&#x3D;&amp;value;&#x2F;&#x2F;指针的值和指针指向的值　都不可以改变</li>
<li>const 引用：</li>
<li>const int &amp;ref&#x3D;value;</li>
</ul>
<h5 id="const-c-amp-cpp差异"><a href="#const-c-amp-cpp差异" class="headerlink" title="const  c&amp;cpp差异"></a>const  c&amp;cpp差异</h5><ul>
<li>不同于CPP，c将const存入的内存中设为只读，还是在栈中，而取其值时需要从内存中获取，所以从这个点看其效率比cpp差<br>why?see follow <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    c code:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cc=<span class="number">8</span>;</span><br><span class="line"><span class="number">0x4004da</span> movl   $<span class="number">0x8</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">		<span class="type">int</span> ccc=cc;</span><br><span class="line"><span class="number">0x4004e1</span> mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line"><span class="number">0x4004e4</span> mov    %eax,<span class="number">-0x4</span>(%rbp)</span><br></pre></td></tr></table></figure>
<h5 id="const和类"><a href="#const和类" class="headerlink" title="const和类"></a>const和类</h5></li>
<li>const 对象 const对象不能调用非const成员函数，也不能改变成员<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">       <span class="keyword">class</span> <span class="title class_">constobj</span>&#123;</span><br><span class="line">          <span class="keyword">public</span>:</span><br><span class="line">            <span class="type">int</span> ax;</span><br><span class="line">            <span class="type">int</span> bx;</span><br><span class="line">            <span class="built_in">constonj</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">ax</span>(a),<span class="built_in">bx</span>(b)&#123;&#125;;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">getax</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> ax;&#125;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">getbx</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bx;&#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setax</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;ax=a;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            constobj cobj;</span><br><span class="line">            <span class="type">const</span> constobj ccobj;</span><br><span class="line">            ccobj.<span class="built_in">setax</span>(<span class="number">3</span>);<span class="comment">//error</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;```</span><br><span class="line">+ <span class="type">const</span> 成员函数（只有成员函数能被声明为<span class="type">const</span> )，它不能改变成员</span><br><span class="line">+ 不能在<span class="type">const</span>成员函数中修改成员变量，但是可以修改其他变量。</span><br><span class="line">+ 非<span class="type">const</span>对象可以调用<span class="type">const</span>成员函数</span><br><span class="line">+ 一个灵活使用<span class="type">const</span>成员函数的例子：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Something</span>(<span class="type">const</span> std::string &amp;value=<span class="string">&quot;&quot;</span>) &#123; m_value= value; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125; <span class="comment">// getValue() for const objects</span></span><br><span class="line">    <span class="function">std::string&amp; <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125; <span class="comment">// getValue() for non-const objects</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Something something;</span><br><span class="line">	something.<span class="built_in">getValue</span>() = <span class="string">&quot;Hi&quot;</span>; <span class="comment">// calls non-const getValue();</span></span><br><span class="line"> </span><br><span class="line">	<span class="type">const</span> Something something2;</span><br><span class="line">	something2.<span class="built_in">getValue</span>(); <span class="comment">// calls const getValue();</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="c-11中的添加的新内容"><a href="#c-11中的添加的新内容" class="headerlink" title="c++11中的添加的新内容"></a>c++11中的添加的新内容</h5><ul>
<li>constexp，cv限定  <h5 id="c-const内存和原理"><a href="#c-const内存和原理" class="headerlink" title="c++ const内存和原理"></a>c++ const内存和原理</h5></li>
<li>基本变量<br>const变量是在栈中分配内存的，但是仅限于定义的时候，之后其他地方使用这个const变量都直接是使用该值<br>从汇编中可以看到</li>
</ul>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">    const <span class="keyword">int</span>  co1=<span class="number">3</span>;</span><br><span class="line"><span class="number">0x4008ed</span> movl   $0x3,<span class="number">-0x14</span>(%rbp)</span><br><span class="line">		 <span class="keyword">int</span>  nor=co1;</span><br><span class="line"><span class="number">0x4008f4</span> movl   $0x3,<span class="number">-0x10</span>(%rbp)<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">所以无法当进行co1=4;的赋值操作时会被编译器拦截，想想，编译后会变成3=4;是不对的； </span></span><br><span class="line"><span class="string">* 这也解释了为什么一开始就要给const的变量赋值 *</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+ 数组:save in stack</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>c </span><br><span class="line">   const <span class="keyword">int</span> a[<span class="number">3</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="number">0x4008fb</span> movl   $0x2,<span class="number">-0x20</span>(%rbp)</span><br><span class="line"><span class="number">0x400902</span> movl   $0x3,<span class="number">-0x1c</span>(%rbp)</span><br><span class="line"><span class="number">0x400909</span> movl   $0x5,<span class="number">-0x18</span>(%rbp)<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+ 指针：  </span></span><br><span class="line"><span class="string">const指针结合，其并不像基本类型那样贴出值，而是每次还是得去内存中取值，它的限定改变值，由编译器控制报错  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">指针并不是像前面那样，如</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>c</span><br><span class="line">    const <span class="keyword">int</span> *p=&amp;value;</span><br><span class="line">    <span class="keyword">int</span> xx=*p;<span class="comment">//被替换成值?不是的，而是去内存中先取出指针的值，再以此为地址去取值；</span></span><br><span class="line">     <span class="keyword">int</span> pv=<span class="number">4</span>;</span><br><span class="line"><span class="number">0x400a12</span> movl   $0x4,<span class="number">-0x58</span>(%rbp)</span><br><span class="line">      const <span class="keyword">int</span> *p=&amp;pv;</span><br><span class="line"><span class="number">0x400a19</span> lea    <span class="number">-0x58</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a1d</span> mov    %rax,<span class="number">-0x40</span>(%rbp)</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">int</span> px=*p;</span><br><span class="line"><span class="number">0x400a69</span> mov    <span class="number">-0x40</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a6d</span> mov    (%rax),%eax</span><br><span class="line"><span class="number">0x400a6f</span> mov    %eax,<span class="number">-0x48</span>(%rbp)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">　　　   <span class="type">int</span> pv=<span class="number">4</span>;</span><br><span class="line"><span class="number">0x400a12</span> movl   $<span class="number">0x4</span>,<span class="number">-0x70</span>(%rbp)<span class="comment">//put 4 in mem(statck)</span></span><br><span class="line">		 <span class="type">const</span> <span class="type">int</span> *p=&amp;pv;</span><br><span class="line"><span class="number">0x400a19</span> lea    <span class="number">-0x70</span>(%rbp),%rax<span class="comment">//get its addr</span></span><br><span class="line"><span class="number">0x400a1d</span> mov    %rax,<span class="number">-0x58</span>(%rbp)<span class="comment">//addr to p</span></span><br><span class="line">         <span class="type">int</span> *<span class="type">const</span> pp=&amp;pv; </span><br><span class="line"><span class="number">0x400a21</span> lea    <span class="number">-0x70</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a25</span> mov    %rax,<span class="number">-0x50</span>(%rbp)<span class="comment">//adddr to pp</span></span><br><span class="line">         <span class="type">int</span>  *ppp=pp;</span><br><span class="line"><span class="number">0x400a29</span> mov    <span class="number">-0x50</span>(%rbp),%rax<span class="comment">//get pp num</span></span><br><span class="line"><span class="number">0x400a2d</span> mov    %rax,<span class="number">-0x48</span>(%rbp)<span class="comment">//to ppp</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>引用：<br>引用同指针，是会去内存中取值的,same to pointer</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">follow above</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref=pv;</span><br><span class="line"><span class="number">0x400aba</span> lea    <span class="number">-0x7c</span>(%rbp),%rax<span class="comment">//get pv</span></span><br><span class="line"><span class="number">0x400abe</span> mov    %rax,<span class="number">-0x38</span>(%rbp)<span class="comment">//to ref</span></span><br><span class="line">		 <span class="type">int</span> cs=ref;</span><br><span class="line"><span class="number">0x400ac2</span> mov    <span class="number">-0x38</span>(%rbp),%rax<span class="comment">//get ref</span></span><br><span class="line"><span class="number">0x400ac6</span> mov    (%rax),%eax<span class="comment">//get *ref</span></span><br><span class="line"><span class="number">0x400ac8</span> mov    %eax,<span class="number">-0x64</span>(%rbp)<span class="comment">//to cs</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>const类对象：  </p>
</li>
<li><p>const对象为什么不能更改成员：<br>成员是存在对象中的，如int,char等成员，存在栈中<br>const对象的成员也是放在栈中的，它们之所以不能赋值，是在编译期间确定，更具体的细节未知；  　</p>
</li>
<li><p>const对象为什么不能调用非const成员函数：</p>
</li>
<li><p>一个成员函数如何被调用：   　　</p>
</li>
<li><p>其实成员函数也是全局函数，所以它能被调用，<br>　eg:<br>  <code>c   obj.show();---&gt;实际上被转换为：   show(&amp;obj)  --传递给this指针：  所以当：const OB obj(); obj.show();时，翻译为　const OB *this; 在传递给OB *this时会出现不能将this指针 从const OB转换为OB &amp;的错误</code></p>
</li>
</ul>
<p>可以做个实验试试</p>
<ul>
<li><p>conclude:<br>if it can use non const func ,it will change member by non const this pointer;</p>
</li>
<li><p>为什么可以调用const函数：<br>const函数：void show() const转换为：show(const OB *this);所以匹配上了，就可以调用了</p>
</li>
</ul>
<p>注意：有最小权限原则，非const对象可以调用const成员函数，就像可以赋值一样。非const变量可以用const赋值</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_debug_layout_static</title>
    <url>/2018/05/20/cpp-debug-layout-static/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c-compile-time-memory-layout"><a href="#c-compile-time-memory-layout" class="headerlink" title="c compile time memory layout"></a>c compile time memory layout</h3><p>　　标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法：</p>
<p>　　概述：首先介绍几个概念：<span id="more"></span><br>　　程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候；<br>　　当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程；<br>      注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码　。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句；</p>
<p>　　本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c</p>
<p>前言：<br>一个源代码通过编译后生成一个目标文件.o它是一个elf　relocatable文件,以下.o文件指此类，elf文件为executable文件<br>.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到</p>
<pre><code>          other data  ...
          .comment    offset 0x000000c6.
          .rodata      ...　　　//const &amp; str 常量
          .data
          .text
          .elf header
</code></pre>
<p>一个elf文件的结构是这样的：可以通过readelf来看：<br>    　　　　　　　　elfheader　　　　　　　　文件头包含了平台信息：&#x2F;usr&#x2F;include&#x2F;elf.h<br>            .text　　　　　　　　　　　　段表　各个段：应用程序也可以自己定义段，和指定变量在哪个段<br>            .data<br>            .bss<br>            ..<br>            other sections<br>            section header table　　　　<br>            string tables　　　　　　　　重定位表和字符串表<br>            symbol tables　　　　　　　　 符号表是链接的接口<br> 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂<br> 可以通过readelf -s　xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突<br>  强符号和弱符号（强引用和若引用），调试信息　－g<br> 扩展：<br> １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀；<br> 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B  i386 image.jpg image.o<br>   objdump -ht image.o<br>   可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们<br>   具体看文档<br>２）自定义段：<strong>attribute</strong>((section(“FOO”))) int global&#x3D;24;<br>           <strong>attribute</strong>((section(“BAR”))) void  foo(){}  既可以把变量或函数放入该段中　段名：BAR FOO</p>
<p>正文：</p>
<h4 id="0、先从几个命令："><a href="#0、先从几个命令：" class="headerlink" title="0、先从几个命令："></a>0、先从几个命令：</h4><p>1)size filename:查看elf或.o文件中各个段大小：<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o<br>　　代码段　　　数据段　　<br>代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x&#x3D;3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址<br>数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）<br>bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null</p>
<p>2)其他工具：<br> readelf -a simplest.o<br> 可以看到更清楚的段信息<br> objdump -t simplest<br> objdump -h simplest.o   替代size可以看到更多信息</p>
<p>此时显示出来的一些地址并不是装载后的地址</p>
<p>objdump -s -d xx.o:　　-s 16进制，-d反汇编　　－－－查看代码段<br>objdump -s -x -d xx.o:   –查看数据段和rodata</p>
<p>3)查看目标文件文件属性如relocatable –.o&#x2F;executable –elf&#x2F;share object –.so..<br> file xxx</p>
<h4 id="１、从最简单的程序开始：simplest-c"><a href="#１、从最简单的程序开始：simplest-c" class="headerlink" title="１、从最简单的程序开始：simplest.c"></a>１、从最简单的程序开始：simplest.c</h4><pre><code>int main()
&#123;
   return 0;
&#125;
</code></pre>
<p>将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件：<br>    # 1 “simplest.c”<br>    # 1 “<built-in>“<br>    # 1 “<command-line>“<br>    # 1 “&#x2F;usr&#x2F;include&#x2F;stdc-predef.h” 1 3 4<br>    # 1 “<command-line>“ 2<br>    # 1 “simplest.c”<br>    int main()<br>     {<br>      return 0;<br>     }</p>
<p>将它进行汇编：gcc -S simplest.c<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>
<p>生成.o文件：gcc -c simplest.c<br>并通过file xx.o查看类型<br>simplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</p>
<p>通过size 查看各个段：<br>size simplest.o:  可以看到只有代码段，数据为空，bss为空，是比较纯净的</p>
<p>text       data        bss        dec        hex    filename<br>     67          0          0         67         43    simplest.o</p>
<p>接着编译成elf:gcc -o simplest simplest.c<br>file simplest<br>simplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,<br>interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 2.6.32, BuildID[sha1]&#x3D;<br>56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped<br>可以看到连接器等信息</p>
<p>size simplest<br>  text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest<br>注意这里的和.o的文件大小和分段不同，</p>
<h4 id="２、加入头文件和局部变量"><a href="#２、加入头文件和局部变量" class="headerlink" title="２、加入头文件和局部变量"></a>２、加入头文件和局部变量</h4><pre><code>#include&lt;stdio.h&gt;
int main()
&#123;
  int locala;
  int localb=3;
  return 0;
  &#125;
</code></pre>
<p>进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数<br>汇编，可以看到分配３到内存中<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>
<p>　　生成.o文件：可以看到未改变data和bss,但是代码段变大<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o</p>
<p>生成elf:数据区和bss未改变，代码段也未改变？<br> text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest</p>
<h4 id="３、加入已经初始化的局部静态变量："><a href="#３、加入已经初始化的局部静态变量：" class="headerlink" title="３、加入已经初始化的局部静态变量："></a>３、加入已经初始化的局部静态变量：</h4><pre><code>int main()
&#123;
 static int statica=3;
..
&#125;
</code></pre>
<p>看生成的汇编：<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2285, @object　&#x2F;&#x2F;新加的段<br>        .size    statica.2285, 4<br>    statica.2285:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>
<p>.o大小：在静态数据区增加了，４　１个int的长度<br> text       data        bss        dec        hex    filename<br>     74          4          0         78         4e    simplest.o</p>
<p>elf:有点费解，。。<br> text       data        bss        dec        hex    filename<br>   1099        548          4       1651        673    simplest</p>
<h4 id="４、加入已经初始化的全局变量和全局静态变量"><a href="#４、加入已经初始化的全局变量和全局静态变量" class="headerlink" title="４、加入已经初始化的全局变量和全局静态变量"></a>４、加入已经初始化的全局变量和全局静态变量</h4><pre><code>     int golbala=6;
    　static long gs=12;
</code></pre>
<p>生成的汇编<br>        .file    “simplest.c”<br>        .globl    golbala<br>        .data<br>        .align 4<br>        .type    golbala, @object<br>        .size    golbala, 4<br>    golbala:&#x2F;&#x2F;变量名<br>        .long    6<br>        .align 8<br>        .type    gs, @object<br>        .size    gs, 8<br>    gs:&#x2F;&#x2F;变量名<br>        .quad    12<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2287, @object<br>        .size    statica.2287, 4<br>    statica.2287:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>
<p>size : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4&#x3D;20<br>      text       data        bss        dec        hex    filename<br>       74         20          0         94         5e    simplest.o</p>
<p>elf size:548–&gt;564  16<br>  text       data        bss        dec        hex    filename<br>   1099        564          4       1667        683    simplest</p>
<h4 id="5-将-int-golbala-x3D-6"><a href="#5-将-int-golbala-x3D-6" class="headerlink" title="5 将 　　int golbala&#x3D;6;"></a>5 将 　　int golbala&#x3D;6;</h4><pre><code>　static long gs=12;　　倒换位置！！！！！！！！！
</code></pre>
<p> 则对齐成：size x.o为：１６比原来小，可以用于节省内存：<br>   text       data        bss        dec        hex    filename<br>     74         16          0         90         5a    simplest.o<br>　　汇编：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2287, @object<br>    .size    statica.2287, 4<br>statica.2287:<br>    .long    3<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits<br>elf文件的也变小：但bss变大，费解。。<br> text       data        bss        dec        hex    filename<br>   1099        560          8       1667        683    simplest</p>
<h4 id="6、加入未初始化的全局变量和全局与局部静态变量"><a href="#6、加入未初始化的全局变量和全局与局部静态变量" class="headerlink" title="6、加入未初始化的全局变量和全局与局部静态变量"></a>6、加入未初始化的全局变量和全局与局部静态变量</h4><pre><code>  1 #include&lt;stdio.h&gt;
    2 static long gs=12;
    3 int golbala=6;
    4      
    5     
    6 static long gsl;
    7 int gi;
    8 int main()
    9 &#123;   
   10      static int staticn;
11      static int statica=3;
   12      int locala;
   13      int localb=3;
   14      return 0;
   15 &#125;
</code></pre>
<p>汇编没有看到什么变化：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .local    gsl<br>    .comm    gsl,8,8<br>    .comm    gi,4,4<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2290, @object<br>    .size    statica.2290, 4<br>statica.2290:<br>    .long    3<br>    .local    staticn.2289<br>    .comm    staticn.2289,4,4<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits</p>
<p>.o文件：+12 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>     74         16         12        102         66    simplest.o</p>
<p>elf:+16 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>   1099        560         24       1683        693    simplest</p>
<p>至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同</p>
<p>参考：程序员的自我修养</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_debug_layout_dynamic</title>
    <url>/2018/05/20/cpp-debug-layout-dynamic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c执行期内存布局和调试："><a href="#c执行期内存布局和调试：" class="headerlink" title="c执行期内存布局和调试："></a>c执行期内存布局和调试：</h3><p>在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等<br>１、将目标文件装入: <span id="more"></span><br><em>１）重定位－－－　放在内存哪里<br> 2)  等待调度执行</em><br>这里可以使用gdb进行调试查看</p>
<p>一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).<br>一个进程主要包括：<br>   在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等</p>
<blockquote>
<p>栈区　　高地址到低地址<br>堆区　　低地址到高地址<br>bss<br>数据<br>代码</p>
</blockquote>
<p> 以下将从两个维度进行对一个程序被执行成进程时，内存的情况：<br> １、各种段区的内存分布<br> ２、gdb 调试程序执行时的过程。－－可能涉及到汇编<br> －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<h4 id="1、gdb-常用的命令和用法："><a href="#1、gdb-常用的命令和用法：" class="headerlink" title="1、gdb　常用的命令和用法："></a>1、gdb　常用的命令和用法：</h4><p>1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令<br> 2)设置断点：　<br>b 行号<br>b 函数名<br>b 行号　if 条件<br>eg:<br>break main  &#x2F;  b main<br>  删除断点:delete 行号</p>
<p>3)列出代码<br>l &#x2F;list</p>
<p>4)运行，start<br>  跳转到断点:c&#x2F;continue   r&#x2F;run<br>  until  行号　　　运行直到该行<br>5)观察变量b和地址<br>watch b  若变量值发生变化，则程序停止</p>
<p>　p&#x2F;print  b  看变量值<br>　p&#x2F;print &amp;b　看变量地址<br> i  locals</p>
<p> info registers 显示所有寄存器的值<br> 查看特定内存位置的值如：<br> print&#x2F;x $eax   显示为16进制<br> print&#x2F;t  2进制，　<br> print&#x2F;d 十进制,<br>x&#x2F;nyz  : n表示字段数，y为输出格式，z是字段长度</p>
<p>６）单步调试<br> n&#x2F;next   &#x2F;   s&#x2F;step　</p>
<ol start="7">
<li>保存断点：<br> info b  查看断点信息<br> save breakpoint fig.dp 保存断点<br> 读取断点文件：　gdb hello -x fig.dp</li>
</ol>
<p> 退出quit</p>
<p> <a href="http://bbs.chinaunix.net/thread-150524-1-1.html">http://bbs.chinaunix.net/thread-150524-1-1.html</a></p>
<h4 id="2-使用kdbg"><a href="#2-使用kdbg" class="headerlink" title="2 使用kdbg"></a>2 使用kdbg</h4><p> 界面版本gdb  在gcc … -g后，用kdbg打开即可、<br> 查看程序运行时各个地址：<br>    <figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHW_ADR(ID,I) printf(<span class="string">&quot;the id %s \t is at adr:%8X\n&quot;</span>,ID,&amp;I);</span></span><br><span class="line"><span class="keyword">extern</span> etext,edata,end;</span><br><span class="line"><span class="type">char</span> *cptr=<span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buffer1[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showit</span><span class="params">(<span class="type">char</span> *)</span></span>;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;Adr etext:%8x\tAdr edata:%8x \t Adr end :%8x \n\n&quot;</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;main&quot;</span>,main);</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;showit&quot;</span>,showit);</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;cptr&quot;</span>,cptr);</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;buffer1&quot;</span>,buffer1);</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;i&quot;</span>,i);</span><br><span class="line">	<span class="built_in">strcpy</span>(buffer1,<span class="string">&quot;A demonstration\n&quot;</span>);</span><br><span class="line">	<span class="built_in">write</span>(<span class="number">1</span>,buffer1,<span class="built_in">strlen</span>(buffer1)+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;<span class="number">1</span>;++i)</span><br><span class="line">		<span class="built_in">showit</span>(cptr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showit</span><span class="params">(<span class="type">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *buffer2;</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;buffer2&quot;</span>,buffer2);</span><br><span class="line">	<span class="keyword">if</span>((buffer2=(<span class="type">char</span> *)<span class="built_in">malloc</span>((<span class="type">unsigned</span>)(<span class="built_in">strlen</span>(p)+<span class="number">1</span>)))!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(buffer2,p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buffer2);</span><br><span class="line">		<span class="built_in">free</span>(buffer2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Allocation error.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;alloca.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">afunc</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> etext,edata,end;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bss_var;				<span class="comment">//no init globel data must be in bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> data_var=<span class="number">42</span>;			<span class="comment">//init globel data must be in data</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHW_ADR(ID,I) printf(<span class="string">&quot;the %8s\t is at adr:%8x\n&quot;</span>,ID,&amp;I);		<span class="comment">//the macro to printf the addr</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *p,*b,*nb;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Adr etext:%8x\t Adr edata %8x\t Adr end %8x\t\n&quot;</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\ntext Location:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;main&quot;</span>,main);			<span class="comment">//text section function</span></span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;afunc&quot;</span>,afunc);			<span class="comment">//text section function</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nbss Location:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;bss_var&quot;</span>,bss_var);		<span class="comment">//bss section var</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\ndata location:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;data_var&quot;</span>,data_var);	<span class="comment">//data section var</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nStack Locations:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">afunc</span>();</span><br><span class="line">	</span><br><span class="line">	p=(<span class="type">char</span> *)<span class="built_in">alloca</span>(<span class="number">32</span>);			<span class="comment">//alloc memory from statck</span></span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SHW_ADR</span>(<span class="string">&quot;start&quot;</span>,p);</span><br><span class="line">		<span class="built_in">SHW_ADR</span>(<span class="string">&quot;end&quot;</span>,p+<span class="number">31</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	b=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">32</span>*<span class="built_in">sizeof</span>(<span class="type">char</span>));	<span class="comment">//malloc memory from heap</span></span><br><span class="line">	nb=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">16</span>*<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nHeap Locations:\n&quot;</span>);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the Heap start: %p\n&quot;</span>,b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the Heap end:%p\n&quot;</span>,(nb+<span class="number">16</span>*<span class="built_in">sizeof</span>(<span class="type">char</span>)));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nb and nb in Stack\n&quot;</span>);</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;b&quot;</span>,b);</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;nb&quot;</span>,nb);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">free</span>(nb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">afunc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> <span class="type">long</span> level=<span class="number">0</span>;	<span class="comment">//data section static var</span></span><br><span class="line">	<span class="type">int</span>	 stack_var;				<span class="comment">//temp var ,in stack section</span></span><br><span class="line">	<span class="keyword">if</span>(++level==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;stack_var in stack section&quot;</span>,stack_var);</span><br><span class="line">	<span class="built_in">SHW_ADR</span>(<span class="string">&quot;Level in data section&quot;</span>,level);</span><br><span class="line">	<span class="built_in">afunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_inheritance</title>
    <url>/2018/06/09/cpp-inheritance/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c-继承："><a href="#c-继承：" class="headerlink" title="c++ 继承："></a>c++ 继承：</h3><h4 id="继承是什么能做什么"><a href="#继承是什么能做什么" class="headerlink" title="继承是什么能做什么"></a>继承是什么能做什么</h4><p>继承是创建复杂类的另一种方式，它展现出来俩个obj 的is-a的概念（前一种方式是加入复杂的函数和成员等has-a　概念）<br>继承体现的是两个对象（类）之间的联系，子类继承父类的成员和方法，然后特殊化于扩展自己的成员和方法，正如苹果和梨都是水果，它们拥有水果的一般特性，等边三角形是特殊的等腰三角形<span id="more"></span><br>几个概念引英文词： the class being inherited from is called the parent class, base class, or superclass, and the class doing the inheriting is called the child class, derived class, or subclass.</p>
<h4 id="继承怎么使用，分为什么"><a href="#继承怎么使用，分为什么" class="headerlink" title="继承怎么使用，分为什么"></a>继承怎么使用，分为什么</h4><p>继承的使用通过例子来学习，分为单继承和多继承等<br>多继承的问题：<br>１）两个基类中存在相同的方法，子类调用该方法－－－》解决，可以调用的方法前加上类限定符base::<br>2)俩个类继承自同一个类，接着另一个类继承这两个类<br>懒得自己写，从learncpp拷贝</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Person</span>(std::string name = <span class="string">&quot;&quot;</span>, <span class="type">int</span> age = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_age; &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// BaseballPlayer publicly inheriting Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseballPlayer</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> m_battingAverage;</span><br><span class="line">    <span class="type">int</span> m_homeRuns;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">BaseballPlayer</span>(<span class="type">double</span> battingAverage = <span class="number">0.0</span>, <span class="type">int</span> homeRuns = <span class="number">0</span>)</span><br><span class="line">       : <span class="built_in">m_battingAverage</span>(battingAverage), <span class="built_in">m_homeRuns</span>(homeRuns)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a new BaseballPlayer object</span></span><br><span class="line">    BaseballPlayer joe;</span><br><span class="line">    <span class="comment">// Assign it a name (we can do this directly because m_name is public)</span></span><br><span class="line">    joe.m_name = <span class="string">&quot;Joe&quot;</span>;</span><br><span class="line">    <span class="comment">// Print out the name</span></span><br><span class="line">    std::cout &lt;&lt; joe.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// use the getName() function we&#x27;ve acquired from the Person base class</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;```</span><br><span class="line">#### 继承的方式，访问控制</span><br><span class="line"><span class="function">A child <span class="keyword">class</span> inherits both <span class="title">behaviors</span> <span class="params">(member functions)</span> <span class="keyword">and</span> <span class="title">properties</span> <span class="params">(member variables)</span> from the parent 但是受继承方式的限制</span></span><br><span class="line"><span class="function">继承的方式有<span class="keyword">public</span>等，受限制，这种可以通俗的理解为，你和你妈，你姨妈，你表舅等的亲密度和能访问的内容是有等级差别的</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">|Access specifier in base <span class="keyword">class</span>|when inherited publicly|when　inherited privately|when inherited protectedly|</span></span><br><span class="line"><span class="function">|:-|:-|:-|:-|</span></span><br><span class="line"><span class="function">|Public|Public|Private|Protected|</span></span><br><span class="line"><span class="function">|Private|Inaccessible|Inaccessible|Inaccessible|</span></span><br><span class="line"><span class="function">|Protected|Protected|Private|Protected|</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#### 继承的内存</span></span><br><span class="line"><span class="function">+ 对单纯的类对象来说，没有继承时，其对象内存是成员变量，存储在栈中</span></span><br><span class="line"><span class="function">，当继承了基类后，基类的成员变量（即使是private不能访问的）会添加到子类的对象内存中，而且一般是放在低地址（前面）</span></span><br><span class="line"><span class="function">对访问控制是在编译期间去做限制的</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#### 编译器对继承做了什么？</span></span><br><span class="line"><span class="function">+ 构造函数  </span></span><br><span class="line"><span class="function">+ 首先，构造函数顺序：Because Derived inherits functions and variables from Base, </span></span><br><span class="line"><span class="function">you may assume that the members of Base are copied into Derived. </span></span><br><span class="line"><span class="function">However, this is not true. Instead, we can consider Derived as a two part class: </span></span><br><span class="line"><span class="function">one part Derived, and one part Base.</span></span><br><span class="line"><span class="function">，从构造函数可以看出，继承的类，对象先调用继承连最上层的类构造函数，最后调用它自己的构造函数</span></span><br><span class="line"><span class="function">+ 其次，基类构造函数被子类调用：//弥补了子类不能　初始化父类成员的缺陷－－－为什么子类不能在初始化队列中初始化父类成员？若为const就出错了，初始化两次</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">```cpp</span></span><br><span class="line"><span class="function">class Derived: public Base</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// our member is now private</span></span><br><span class="line">    <span class="type">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">double</span> cost=<span class="number">0.0</span>, <span class="type">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">Base</span>(id), <span class="comment">// Call Base(int) constructor with value id!</span></span><br><span class="line">            <span class="built_in">m_cost</span>(cost)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>析构函数：调用顺序和构造函数相反</p>
</li>
<li><p>子类加入自己的函数和ovrridewirte父类函数  </p>
</li>
<li><p>策略：<br>When a member function is called with a derived class object,<br>the compiler first looks to see if that member exists in the derived class.<br> If not, it begins walking up the inheritance chain and checking whether the member<br> has been defined in any of the parent classes. It uses the first one it finds.</p>
</li>
<li><p>在父类中被声明为private 的函数经过子类重写后可能会变成public:</p>
</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Derived &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derived derived;</span><br><span class="line">	derived.<span class="built_in">print</span>(); <span class="comment">// calls derived::print(), which is public</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>保留父类函数的方法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value)</span><br><span class="line">        : <span class="built_in">m_value</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">identify</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;I am a Base\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> value)</span><br><span class="line">        : <span class="built_in">Base</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">identify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base::<span class="built_in">identify</span>(); <span class="comment">// call Base::identify() first</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am a Derived\n&quot;</span>; <span class="comment">// then identify ourselves</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>c++11新：<br>将base类中的保护函数，在子类中声明为public:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value)</span><br><span class="line">        : <span class="built_in">m_value</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> value)</span><br><span class="line">        : <span class="built_in">Base</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Base::printValue was inherited as protected, so the public has no access</span></span><br><span class="line">    <span class="comment">// But we&#x27;re changing it to public via a using declaration</span></span><br><span class="line">    <span class="keyword">using</span> Base::printValue; <span class="comment">// note: no parenthesis here  //c++11</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// printValue is public in Derived, so this is okay</span></span><br><span class="line">    derived.<span class="built_in">printValue</span>(); <span class="comment">// prints 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类中将父类的方法隐藏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">int</span> value)</span><br><span class="line">		: <span class="built_in">m_value</span>(value)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>(<span class="type">int</span> value)</span><br><span class="line">		: <span class="built_in">Base</span>(value)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>= <span class="keyword">delete</span>; <span class="comment">// mark this function as inaccessible</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// The following won&#x27;t work because getValue() has been deleted!</span></span><br><span class="line">	std::cout &lt;&lt; derived.<span class="built_in">getValue</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_runtime_semantis</title>
    <url>/2018/07/29/cpp-runtime-semantis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c-执行期语意学"><a href="#c-执行期语意学" class="headerlink" title="c++ 执行期语意学"></a>c++ 执行期语意学</h3><h4 id="执行期和编译期的理解"><a href="#执行期和编译期的理解" class="headerlink" title="执行期和编译期的理解"></a>执行期和编译期的理解</h4><ul>
<li>执行期：此时是对已经编译等生成的可执行文件装载到内存并调用cpu将其作为一个进程执行的过程，对c.c++来说程序的入口为main,即第一条指令是执行main函数开始的，而c++可能会加入一些额外的代码，所以实际写的第一条语句和执行的第一条语句可能有偏差；　　　<span id="more"></span></li>
<li>在执行的过程，是程序代码运行的过程，可以想象为工厂开始生产，此时需要空间来运行，需要生产线，产品，工人，工人们走来走去搬运物品等；对程序的运行而言，此时主要的活动空间为栈和堆，即在栈和堆分配空间，而流程制式就是代码段，静态变量的数据区可以比喻为整个工厂共有的数据等；　这个过程中栈会被不断生成消失，堆也是，承载他们的是内存对应的区域；执行完后就从内存消失；</li>
<li>　编译期，就像生孩子之前的扫描，检查，看看语法对不对，添加额外的内容(c++).生成对应的汇编代码和二进制代码，而程序员需要尽力　编译出高效，整洁，可读等特性的代码，就像这个过程中通过调理，吃合适的东西等；尽可能避开一些坑和耗时的行为le.</li>
<li>　这部分的内容并不涉及太多执行期的，而更多的是编译器在编译代码时做了什么手脚<h4 id="c-中的运算符函数和运算符语法糖"><a href="#c-中的运算符函数和运算符语法糖" class="headerlink" title="c++中的运算符函数和运算符语法糖"></a>c++中的运算符函数和运算符语法糖</h4></li>
<li>运算符被编译器转换为运算符函数<br>操作符函数例子–&gt;到临时对象的产生和销毁带来的效率问题</li>
</ul>
<p>–&gt;如何在程序中尽量避免产生临时变量和调用析构函数<br>例子：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X xx;</span><br><span class="line">Y yy;</span><br><span class="line"><span class="keyword">if</span>(yy==xx.<span class="built_in">getvalue</span>()) ``` </span><br><span class="line">其中涉及到yy的==运算符函数和xx的getvalue函数，前者为：  </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Y&amp;) <span class="type">const</span>后者为X <span class="built_in">getvalue</span>()  　　</span><br><span class="line">yy==xx.<span class="built_in">getvalue</span>()被转换为yy.<span class="keyword">operator</span>==(xx.getvalue),显然类型不相符；  </span><br><span class="line">而此时若X有函数<span class="keyword">operator</span> <span class="built_in">Y</span>()<span class="type">const</span>;<span class="comment">//conversion运算符，则进一步转换为：  </span></span><br><span class="line">     yy.<span class="keyword">operator</span>==(xx.getvalue.<span class="keyword">operator</span> <span class="built_in">Y</span>())  </span><br><span class="line"> 这行代码看上去是这样简单，但是实际上需要产生中间变量，转为伪代码:  </span><br><span class="line">   X　tmp1=xx.getvalue;<span class="comment">//放返回值  </span></span><br><span class="line">   Y tmp2=tmp1.<span class="keyword">operator</span> <span class="built_in">Y</span>()<span class="comment">//同上  </span></span><br><span class="line">   <span class="type">int</span> tmp3=yy.<span class="keyword">operator</span>==(tmp2);<span class="comment">//放置返回值  </span></span><br><span class="line">   总共产生三个临时变量，而且还得析构，麻烦效率低  </span><br><span class="line">   (注意，上述的为什么不能直接连锁调用?因为返回的是值而不是指针，思考<span class="keyword">this</span>指针的连锁操作，cout的连锁操作，个人思考，应该是因为返回的是指针，上述返回的是值，所以无法用值调用下面的函数）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 对象的构造和解构</span><br><span class="line">+ 构造函数在哪里被安插:  </span><br><span class="line">构造函数在编译时，由编译器在合适的地方安插，一般情况下，正如我们想像的一样：在定义对象时会执行构造函数,解构在对象销毁时;</span><br><span class="line"><span class="comment">//c++伪代码  </span></span><br><span class="line">```cpp</span><br><span class="line">&#123;</span><br><span class="line">   Point point ;</span><br><span class="line">   <span class="comment">//point.Point::Point() 一般而言会被安插在这里</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//point.Point::~Point() 一般而言会被安插在这里</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>解构函数在哪里被安插:<br>1、解构函数的安插需要考虑程序的退出时间（或者某个代码块的退出时间，在可能退出的地方都要加解构函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Point point;</span><br><span class="line">  <span class="comment">//constructor here</span></span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">int</span> (point.<span class="built_in">x</span>()) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">    <span class="comment">//mumble;</span></span><br><span class="line">    <span class="comment">//destructor here</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="comment">//mumble;</span></span><br><span class="line">    <span class="comment">//destructor here</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">      <span class="comment">//mumble</span></span><br><span class="line">      <span class="comment">//destructor here</span></span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">    destructor here</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>解构代码应该在任何可能退出代码块的地方，return等，switch,if，goto等都会使加上解构函数的调用以避免出现退出但是还没有执行析构函数的尴尬；</p>
</li>
<li><p>而在如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(cache)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   Point xx;</span><br><span class="line">   <span class="keyword">if</span>(xx.<span class="built_in">get</span>()==<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   和</span><br><span class="line">   &#123;</span><br><span class="line">     Point xx;</span><br><span class="line">     <span class="keyword">if</span>(cache）</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 前者不需要在if(cache）的return 前加解构和　构造函数，而后者需要，显然后者综合效率更差些；<br> 所以设计c++代码时候需要考虑，尽量在使用它的附近定义它</p>
</li>
<li><p>对特殊情况的考虑–全局对象的构造函数和解构函数的安插，有特殊的处理<br>“前面看到的是正常的局部情况，现在考虑的是全局对象，定义在main外面，它的构造函数被安插在哪里，什么时候执行?”<br>考虑以下例子：  </p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Matrix identity<span class="comment">;</span></span><br><span class="line"> main ()</span><br><span class="line"> &#123;</span><br><span class="line">    //identity 必须在这里被初始化</span><br><span class="line">    Matrix m1<span class="operator">=</span>identity<span class="comment">;</span></span><br><span class="line">    ...</span><br><span class="line">    return <span class="number">0</span><span class="comment">;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 很明显，c++ 必须保证第一次用到identity把他构造出来而在main结束前销毁它；对全局对象而言，有构造函数和析构函数时，称为静态的初始化和内存释放操作；<br> 全局对象和全局变量一样被放在数据段(data segment),在c中，可以在编译期间给定全局变量常量值，而c++中的全局对象需要程序激活后才能执行构造函数给初值；相当于给全局对象做静态初始化；</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如,cfront在执行前，加入_main来初始化各种全局对象；</span></span><br><span class="line"><span class="comment">//sti_xxx---static initialization</span></span><br><span class="line"> int <span class="selector-tag">main</span>()</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="built_in">_main</span>();<span class="built_in">---</span>(_sti_xxx(); <span class="built_in">_sti_xxx</span>();,,,)</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">_exit</span>()<span class="built_in">---</span>(_std_xxx()....)</span><br><span class="line">    <span class="comment">//而在结束时调用他们的析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    但是需要收集程序中各个对象文件的_sti函数和_std函数，此时可以用nm命令，即它会倾倒出符号表项目，nm会施加到<span class="selector-class">.o</span>文件上；搜寻_sti _std开头的函数；最后总结整理出来；</span><br></pre></td></tr></table></figure>
</li>
<li><p>对特殊情况的考虑–局部静态对象<br>考虑局部静态对象只会构造一次和销毁一次，却是可能调用多次包含定义局部静态对象的函数，如何保证只会构造一次和销毁一次呢?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> <span class="title class_">Matrix</span>&amp;</span><br><span class="line"> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title class_">Matrix</span> mat_identify;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> mat_identify;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//1\首先要保证在调用该函数才初始化局部静态变量，</span></span><br><span class="line"><span class="comment">//2、其次，保证多次调用该函数不会重复初始化对象；</span></span><br></pre></td></tr></table></figure>
<p>简单的说，解决方案就是用一个标志变量，当已经初始化一次局部静态变量就置为真；</p>
</li>
<li><p>对象数组什么时候构造和解构?<br>考虑一下定义了一个对象数组，之后未做任何改动，要取其中的值，会在定义数组的时候也初始化数组中每一个对象（即调用构造函数)吗？</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Point</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">int</span> a;</span><br><span class="line">      Point ()&#123;a=<span class="number">3</span>;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">Point knot[<span class="number">10</span>];</span><br><span class="line">cout&lt;&lt;knot[<span class="number">3</span>].a;<span class="comment">//会打印3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当这种对象数组没有默认构造函数和析构函数，则定义时和内置类型相同，只需配置足够的内存保存即可；<br>而当对象有构造函数和析构函数时，编译器提供了vec_new() vec_delete()之类的函数来统一做构造和析构</p>
</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *vec_new(<span class="keyword">void</span> *<span class="built_in">array</span>,<span class="comment">//数组起始地址</span></span><br><span class="line">      size_t elem_size,int elem_count,<span class="comment">//对象大小和数组对象个数</span></span><br><span class="line">      <span class="keyword">void</span> (*constructor)(*<span class="keyword">void</span>)</span><br><span class="line">      <span class="keyword">void</span>(*destructor)(*<span class="keyword">void</span>)</span><br><span class="line">      而实际上调用时：</span><br><span class="line">      <span class="built_in">Point</span> knots[<span class="number">10</span>]</span><br><span class="line">      <span class="comment">//可能是这样调用，delete类似</span></span><br><span class="line">      vec_new(&amp;knnots,sizeof(<span class="built_in">Point</span>),<span class="number">10</span>,&amp;<span class="built_in">Point</span>::<span class="built_in">Point</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>而如果程序员额外调用了其中一些元素的构造函数，则：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Point</span> knots[<span class="number">10</span>]=&#123;<span class="built_in">Point</span>(),<span class="built_in">Point</span>(<span class="number">1.8</span>,<span class="number">2.1</span>,<span class="number">0.2</span>),<span class="number">-1.9</span>&#125;;</span><br><span class="line">类似这样，则可能会明确的初始化前三个元素，后面的其他则用vec_new</span><br></pre></td></tr></table></figure>


<ul>
<li>默认构造函数和数组</li>
</ul>
<h4 id="new和delete运算符"><a href="#new和delete运算符" class="headerlink" title="new和delete运算符"></a>new和delete运算符</h4><p>上述是针对对象的，new和delete是针对指针的；</p>
<ul>
<li>本质上调用malloc函数和free函数,编译器解析new，delete会安插构造函数和解构函数<br>new 的实际过程：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">对内建类型</span><br><span class="line"><span class="type">int</span> *pi=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//1 调用函数库的new:_new </span></span><br><span class="line"><span class="comment">//int *pi=_new(sizeof(int));</span></span><br><span class="line"><span class="comment">//2 设置初值：*pi=5;</span></span><br><span class="line"><span class="comment">//或加条件：</span></span><br><span class="line">(<span class="type">int</span>  *pi ; <span class="keyword">if</span>(pi=_new(...))*pi=<span class="number">5</span>)</span><br><span class="line"><span class="comment">//delete类似；</span></span><br><span class="line">对对象：</span><br><span class="line">Point3d *origin =<span class="keyword">new</span> Point3d;</span><br><span class="line">转换为：</span><br><span class="line">Point3d *origin;</span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">if</span>(origin =_new(<span class="built_in">sizeof</span>(Point3d))</span><br><span class="line">origin=Pointed::<span class="built_in">Point3d</span>(origin)<span class="comment">//注意这里会调用构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> origin;</span><br><span class="line">转换为：</span><br><span class="line"><span class="keyword">if</span> (!origin !=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">Point3d::~<span class="built_in">Point3d</span>(origin);</span><br><span class="line">_delete(origin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">而<span class="keyword">new</span> 一般由malloc实现，<span class="keyword">delete</span>由free实现；</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="type">size_t</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (size =<span class="number">0</span>)</span><br><span class="line">    size=<span class="number">1</span>;</span><br><span class="line">  <span class="type">void</span> *last_alloc</span><br><span class="line">  <span class="keyword">while</span>(!(last_alloc=<span class="built_in">malloc</span>(size)))</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(_new_handle)</span><br><span class="line">   (*_new_handle)();</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="keyword">return</span> last_alloc</span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>


<ul>
<li>针对数组的new和delete<br>实际上的new数组，若不存在构造函数，则只会做new的运算符函数：int *parray&#x3D;(<em>int)_new(5</em>sizeof(int));<br>待续，略复杂。。。</li>
<li>placement operator new的语意-——new的重载；</li>
</ul>
<h4 id="影响c-效率因素之一—临时性对象"><a href="#影响c-效率因素之一—临时性对象" class="headerlink" title="影响c++效率因素之一—临时性对象"></a>影响c++效率因素之一—临时性对象</h4><ul>
<li>为什么需要临时性对象<br>临时性对象是影响程序效率和引入bug的来源之一；<ul>
<li>隐式的类型转换需要临时性对象：<br>当用内建类型写下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">....</span><br><span class="line">a=b+c;<span class="comment">//内建类型将算出的值赋给a</span></span><br><span class="line"><span class="comment">//想象一下如果此时a,b,c都是对象，b+c返回一个对象呢？</span></span><br><span class="line">在c++中操作符运算本质上也是函数，则这里单纯靠b+c返回</span><br><span class="line">一个对象的值赋值给a已经不现实了，对象是一个结构性的</span><br><span class="line">变量；所以在这种情况下就需要构建一个临时性对象，并将</span><br><span class="line">此临时性对象（函数的结果）利用赋值函数拷贝给a;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>单纯传入对象作为函数参数时，即使不返回对象，也会产生临时性对象，为什么? 随意写了个例子： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">     <span class="number">1</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="number">2</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="number">3</span>         <span class="keyword">public</span>:</span><br><span class="line">    <span class="number">4</span>                 <span class="type">int</span> a;</span><br><span class="line">    <span class="number">5</span>                 <span class="built_in">Point</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;constructor&quot;</span>&lt;&lt;std::endl; a=<span class="number">4</span>;&#125;</span><br><span class="line">    <span class="number">6</span>                 <span class="function"><span class="type">void</span> <span class="title">printa</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout&lt;&lt;a&lt;&lt;<span class="number">32</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">    <span class="number">7</span>                 ~<span class="built_in">Point</span>()&#123;</span><br><span class="line">    <span class="number">8</span>                         std::cout&lt;&lt;<span class="string">&quot;~destrucot&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">&gt;&gt;  <span class="number">9</span>                <span class="built_in">Point</span>(<span class="type">const</span> Point&amp; p)</span><br><span class="line">   <span class="number">10</span>                &#123;</span><br><span class="line">   <span class="number">11</span>                                 std::cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; std::en      dl;</span><br><span class="line">   <span class="number">12</span>                &#125;</span><br><span class="line">   <span class="number">13</span> </span><br><span class="line">&gt;&gt; <span class="number">14</span>               Point&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Point&amp; p)</span><br><span class="line">   <span class="number">15</span>               &#123;</span><br><span class="line">   <span class="number">16</span>                  std::cout &lt;&lt; <span class="string">&quot;Assign&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   <span class="number">17</span>                  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   <span class="number">18</span>               &#125;</span><br><span class="line">   <span class="number">19</span> </span><br><span class="line">   <span class="number">20</span> &#125;;</span><br><span class="line">   <span class="number">21</span> <span class="function"><span class="type">void</span> <span class="title">getv</span><span class="params">(<span class="type">const</span> Point pp)</span></span></span><br><span class="line"><span class="function">   22 </span>&#123;</span><br><span class="line">   <span class="number">23</span>     <span class="comment">//= pp.a=6;</span></span><br><span class="line">   <span class="number">24</span>         pp.<span class="built_in">printa</span>();</span><br><span class="line">   <span class="number">25</span>         std::cout&lt;&lt;pp.a&lt;&lt;std::endl;</span><br><span class="line">   <span class="number">26</span> &#125;</span><br><span class="line">   <span class="number">27</span> </span><br><span class="line">   <span class="number">28</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   29 </span>&#123;</span><br><span class="line">   <span class="number">30</span>         Point pplist;</span><br><span class="line">   <span class="number">31</span>         std::cout&lt;&lt;pplist.a&lt;&lt;std::endl;</span><br><span class="line">   <span class="number">32</span>         <span class="built_in">getv</span>(pplist);<span class="comment">//这里产生临时对象是调用拷贝构造函数</span></span><br><span class="line">   <span class="number">33</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">34</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  按照内建类型来看，传入函数参数，其实传入的是值，<br>  而对于对象来说，若传入的是引用或指针则不需要产生临时性对象，但是传入的若是值，则c++编译器需要产生一个临时性对象，在函数的栈中，供函数中对该对象调用函数和值等操作；</p>
<ul>
<li>函数返回对象；<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">另一个例子：</span><br><span class="line">   如何做X xxx=bar()<span class="punctuation">;</span>如何拷贝的？双阶段初始化：</span><br><span class="line"> a 增加一个额外的引用参数给函数，如void bar(X＆　_result)</span><br><span class="line"> b 在return 前插入一个<span class="keyword">copy</span> <span class="keyword">constructor</span> </span><br><span class="line">     <span class="title function_">void</span> <span class="title function_">bar</span><span class="params">(X &amp;__result)</span><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">               X xx;</span></span><br><span class="line"><span class="comment">               xx.X::X();</span></span><br><span class="line"><span class="comment">               __result.X::XX(xx);</span></span><br><span class="line"><span class="comment">               return ;</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line">   <span class="title function_">X</span> <span class="title function_">xxx</span>=<span class="title function_">bar</span><span class="params">()</span></span><br><span class="line">   //-&gt;<span class="title function_">bar</span><span class="params">(X &amp;__result)</span>;</span><br><span class="line">       xxx=_result<span class="punctuation">;</span></span><br></pre></td></tr></table></figure></li>
<li>手动调用构造函数：此时也会生成临时性对象；</li>
<li>其他如通过构造函数调用成员函数的：单纯一个表达式 a+b这种的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tmpclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">tmpclass</span>(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tmpclass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">tmpclass</span>(<span class="number">0</span>);<span class="comment">//手动调用构造函数会产生临时对象，临时对象的a=0,故最后结果show还是无初值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tmpclass c;</span><br><span class="line">    c.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">其他：</span><br><span class="line"> tmpclass c1 = <span class="built_in">tmpclass</span>(<span class="number">6</span>);<span class="comment">//赋值构造+构造函数</span></span><br><span class="line"> <span class="built_in">tmpclass</span>(<span class="number">6</span>).<span class="built_in">show</span>()<span class="comment">//产生临时性对象；</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如何避免产生临时性对象<br>尽量不用上述的手法编程</li>
<li>临时性对象的效率（迷思，测试)<br>临时性对象会造成效率低下，在不当的代码下容易产生很多临时性对象；不当的使用也会造成非预期的结果；</li>
<li>临时性对象的生命周期：<br>可能是这个表达式的生命周期，具体可以通过构造类函数和析构函数调试；</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_static</title>
    <url>/2018/06/08/cpp-static/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c-关键词之static"><a href="#c-关键词之static" class="headerlink" title="c++关键词之static"></a>c++关键词之static</h3><h5 id="something-share"><a href="#something-share" class="headerlink" title="something share:"></a>something share:</h5><p>其实，一开始学习c++的时候，并没有想去了解它的语法原理。虽然学c的时候，附带学了汇编，也学到了内存段，和学编译原理的时候顺带了解了它的相关词法语法处理。　　<br>现在开始从原因，历史，内存，汇编等角度去看cpp，觉得清晰了一些。虽然没有去学习g++或者其他编译器<span id="more"></span><br>如何处理c++的语法词法。这个想着以后如果有时间再研究吧。应该也是有工具去看，毕竟，g++是开源的，可以直接看源码如何处理C++</p>
<h4 id="static-overiew"><a href="#static-overiew" class="headerlink" title="static overiew"></a>static overiew</h4><ul>
<li>static在c的时候就有，因存储的地方不同于局部变量(in static mem ,not in stack)，使得在函数代码块结束后不会被销毁。从而能持续整个程序.</li>
<li>静态存储区(data)：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</li>
</ul>
<h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><p>１、static概念和用法<br>２、static内存存储和汇编<br>３、static和类相关内容与原理  </p>
<h4 id="static概念："><a href="#static概念：" class="headerlink" title="static概念："></a>static概念：</h4><p>　static为静态修饰符。编译器遇到这个修饰符时将对应的变量存储在静态存储区(data)  　</p>
<ul>
<li>根据类型：static可以修饰变量和函数，修饰对象和成员函数  </li>
<li>根据位置：静态局部变量和全局静态变量 -存于静态数据区(data)</li>
</ul>
<h5 id="c中的static"><a href="#c中的static" class="headerlink" title="c中的static:"></a>c中的static:</h5><ul>
<li>修饰变量：作用域是本程序文件，局部变量默认为auto,静态变量不管局部或者全局都存储于静态数据区，使得不会因为函数调用而销毁</li>
<li>修饰函数：只能用于本程序文件，普通函数默认为extern ,能被其他文件引用，static则不行</li>
</ul>
<p>“ 举个例子：<br>在stat.h中声明static int getstats()函数.<br>并在stat.c中实现它，static int getstats(){return xxx;}<br>在main中或者其他文件中使用这个函数<br>编译时报错未能找到该函数（未定义该函数)<br>c++中的static当和类无关时同c” </p>
<h4 id="static使用和内存与汇编："><a href="#static使用和内存与汇编：" class="headerlink" title="static使用和内存与汇编："></a>static使用和内存与汇编：</h4><h5 id="static全局变量"><a href="#static全局变量" class="headerlink" title="static全局变量"></a>static全局变量</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">static</span> <span class="type">int</span> global1=<span class="number">4</span>;</span><br><span class="line">   <span class="number">12</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">   13 &#123;</span><br><span class="line">&gt;&gt; <span class="number">14</span>         <span class="type">int</span> loc1=global1;</span><br><span class="line"></span><br><span class="line">_ZL7global1:</span><br><span class="line">	.<span class="type">long</span>	<span class="number">4</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line"></span><br><span class="line">	movl	_ZL7global1(%rip), %eax</span><br><span class="line">	movl	%eax, <span class="number">-4</span>(%rbp)</span><br><span class="line"><span class="comment">//且可以通过kdbg看到在执行期，</span></span><br><span class="line"><span class="type">static</span>变量的内存位置约为：</span><br><span class="line">(<span class="type">int</span> *) <span class="number">0x601048</span> &lt;global1&gt;　数据段地址</span><br><span class="line">局部变量的位置约为：</span><br><span class="line">(<span class="type">char</span> **) <span class="number">0x7ffff7a54530</span> &lt;loc1&gt;　栈地址```</span><br><span class="line"></span><br><span class="line">##### 静态局部变量</span><br><span class="line">```c </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">   13 &#123;</span><br><span class="line">   <span class="number">14</span>         <span class="type">static</span> <span class="type">int</span> locstatic1=<span class="number">5</span>;</span><br><span class="line">&gt;&gt; <span class="number">15</span>         <span class="type">int</span> loc1=global1;</span><br><span class="line">&gt;&gt; <span class="number">16</span>         <span class="type">int</span> loc2=locstatic1;</span><br><span class="line"></span><br><span class="line">	movl	_ZZ4mainE10locstatic1(%rip), %eax</span><br><span class="line">	movl	%eax, <span class="number">-4</span>(%rbp)</span><br><span class="line"></span><br><span class="line">_ZZ4mainE10locstatic1:</span><br><span class="line">	.<span class="type">long</span>	<span class="number">5</span></span><br><span class="line">执行期：</span><br><span class="line">　　loca1 　(<span class="type">int</span> *) <span class="number">0x7fffffffd8a8</span></span><br><span class="line">　　loca2 (<span class="type">int</span> *) <span class="number">0x7fffffffd8ac</span></span><br><span class="line"></span><br><span class="line">  global1 (<span class="type">int</span> *) <span class="number">0x601048</span> &lt;global1&gt;</span><br><span class="line">  locstatic:(<span class="type">int</span> *) <span class="number">0x60104c</span> &lt;main::locstatic1&gt;</span><br></pre></td></tr></table></figure>
<h5 id="static定义的变量和函数只能在本程序文件中使用"><a href="#static定义的变量和函数只能在本程序文件中使用" class="headerlink" title="static定义的变量和函数只能在本程序文件中使用"></a>static定义的变量和函数只能在本程序文件中使用</h5><p>要知道这个的原因可能有些复杂，一时半会也说不清，得先直到函数为什么能被外部引用：存在“符号表”中，能被外部链接，静态函数不在符号表中所以不行，类似这样吧，<br>这块不太清楚，感觉是这个原因</p>
<h5 id="static函数："><a href="#static函数：" class="headerlink" title="static函数："></a>static函数：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">static</span>  <span class="type">int</span> <span class="title function_">getv</span><span class="params">()</span></span><br><span class="line">    4 &#123;</span><br><span class="line">    <span class="number">5</span>         <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="number">6</span>         a++;</span><br><span class="line">    <span class="number">7</span>         <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="number">8</span>         <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="number">9</span> &#125; </span><br><span class="line"></span><br><span class="line">	.type	_ZL4getvv, @function</span><br><span class="line">_ZL4getvv:</span><br><span class="line">.LFB1021:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">	subq	$<span class="number">16</span>, %rsp</span><br><span class="line">　　　。。。。</span><br><span class="line">　</span><br></pre></td></tr></table></figure>
<p>　    call    _ZL4getvv<br>从汇编代码看貌似跟普通函数没什么差别</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">运行时</span><br><span class="line">　　<span class="type">static</span>  <span class="type">int</span> <span class="title function_">getv</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x400816</span> push   %rbp</span><br><span class="line"><span class="number">0x400817</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x40081a</span> sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">		<span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">		a++;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> global1=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> locstatic1=<span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> loc1=global1;</span><br><span class="line">		<span class="type">int</span> loc2=locstatic1;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;getv()&lt;&lt;endl;</span></span><br><span class="line">    	getv();</span><br><span class="line"><span class="number">0x400866</span> callq  <span class="number">0x400816</span> &lt;getv()&gt;</span><br></pre></td></tr></table></figure>


<h4 id="static和类相关"><a href="#static和类相关" class="headerlink" title="static和类相关"></a>static和类相关</h4><h5 id="static成员变量的使用"><a href="#static成员变量的使用" class="headerlink" title="static成员变量的使用"></a>static成员变量的使用</h5><p> static成员变量是类的所有对象共有的，但是只有一份，通过类也可以访问到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_value; <span class="comment">// declares the static member variable</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> Something::s_value = <span class="number">1</span>; <span class="comment">// defines the static member variable (we&#x27;ll discuss this section below)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// note: we&#x27;re not instantiating any objects of type Something</span></span><br><span class="line"> </span><br><span class="line">    Something::s_value = <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; Something::s_value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_ZN9Something7s_valueE:</span><br><span class="line">	.<span class="type">long</span>	<span class="number">1</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line"></span><br><span class="line">　　</span><br><span class="line">  Something::s_value=<span class="number">3</span>;</span><br><span class="line"><span class="number">0x40081a</span> movl   $<span class="number">0x3</span>,<span class="number">0x20083c</span>(%rip)        # <span class="number">0x601060</span> &lt;Something::s_value&gt;</span><br><span class="line">（	movl	_ZN9Something7s_valueE(%rip), %eax</span><br><span class="line">	movl	%eax, %esi</span><br><span class="line">）</span><br><span class="line">可见类似于上述的，存在内存的数据段中</span><br></pre></td></tr></table></figure>

<h5 id="类静态变量作用域"><a href="#类静态变量作用域" class="headerlink" title="类静态变量作用域"></a>类静态变量作用域</h5><p>静态成员在多个文件中:<br>类中的机制，可以让定义在文件中的静态成员变量能被其他文件访问；加了作用域的声明，所以可以这样用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">在stati.h</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Some</span>&#123;</span><br><span class="line">  <span class="number">2</span>         <span class="keyword">public</span>:</span><br><span class="line">  <span class="number">3</span>                 <span class="type">static</span> <span class="type">int</span> s_v;</span><br><span class="line">  <span class="number">4</span> &#125;;</span><br><span class="line">  <span class="number">5</span> <span class="comment">//static int s_vv;//error 错误</span></span><br><span class="line"></span><br><span class="line">在stati.cpp</span><br><span class="line">   <span class="meta">#<span class="keyword">include</span><span class="string">&quot;stati.h&quot;</span></span></span><br><span class="line">  <span class="number">2</span> <span class="type">int</span> Some::s_v=<span class="number">4</span>;</span><br><span class="line">  <span class="number">3</span> <span class="comment">//static int s_vv=5;error</span></span><br><span class="line"></span><br><span class="line">在main</span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stati.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> gets= Some::s_v;</span><br><span class="line"></span><br><span class="line">other:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Whatever</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> s_value = <span class="number">4</span>; <span class="comment">// a static const int can be declared and initialized directly</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="静态成员函数的使用"><a href="#静态成员函数的使用" class="headerlink" title="静态成员函数的使用"></a>静态成员函数的使用</h5><ul>
<li>考虑一个问题，当静态成员被申明为private时，则无法使用它directly by class。<br>but you can用非静态成员函数操作或者用静态成员函数操作to use it  </li>
<li>静态成员函数也是可以用类直接调用，它没有this指针，所以不能修改和访问对象的成员； </li>
<li>（非静态成员func,它可以定义在类的内部或者外部，外部不用加static,这点和static成员不同，成员得在外部初始化－－因为public等定义成员时，非const不能赋值，而<br>static不能修饰构造函数（对象相关），所以只能在外部初始化)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IDGenerator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_nextID; <span class="comment">// Here&#x27;s the declaration for a static member</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getNextID</span><span class="params">()</span></span>; <span class="comment">// Here&#x27;s the declaration for a static function</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Here&#x27;s the definition of the static member outside the class.  Note we don&#x27;t use the static keyword here.</span></span><br><span class="line"><span class="comment">// We&#x27;ll start generating IDs at 1</span></span><br><span class="line"><span class="type">int</span> IDGenerator::s_nextID = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Here&#x27;s the definition of the static function outside of the class.  Note we don&#x27;t use the static keyword here.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">IDGenerator::getNextID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_nextID++; &#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count=<span class="number">0</span>; count &lt; <span class="number">5</span>; ++count)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The next ID is: &quot;</span> &lt;&lt; IDGenerator::<span class="built_in">getNextID</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_template_class</title>
    <url>/2021/01/10/cpp-template-class/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="类模板的基本概念"><a href="#类模板的基本概念" class="headerlink" title="类模板的基本概念"></a>类模板的基本概念</h3><h3 id="类模板的引入："><a href="#类模板的引入：" class="headerlink" title="类模板的引入："></a>类模板的引入：<span id="more"></span></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">一个例子：</span><br><span class="line">用类封装一个包含多操作的IntArray:</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INTARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> <span class="comment">// for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_length;</span><br><span class="line">    <span class="type">int</span> *m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IntArray</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">IntArray</span>(<span class="type">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(length &gt; <span class="number">0</span>);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">int</span>[length];</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">IntArray</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">用类封装一个包含多操作的DoubleArray:</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DOUBLEARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOUBLEARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> <span class="comment">// for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_length;</span><br><span class="line">    <span class="type">double</span> *m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DoubleArray</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">DoubleArray</span>(<span class="type">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(length &gt; <span class="number">0</span>);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">double</span>[length];</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">DoubleArray</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">double</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">以上两个定义内容只有里面的类型不同，那么为什么不忽略类型的差异，定义通用的容器？于是类模板出现：</span><br><span class="line">类模板的定义和使用：</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> <span class="comment">// for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// This is a template class, the user will provide the data type for T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">//注意这里可以指定具体类型；</span></span><br><span class="line">    T *m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> T[length];</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Array</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The length of the array is always an integer</span></span><br><span class="line">    <span class="comment">// It does not depend on the data type of the array</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span></span>; <span class="comment">// templated getLength() function defined below</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// member functions defined outside the class need their own template declaration</span></span><br><span class="line"><span class="type">int</span> Array&lt;T&gt;::<span class="built_in">getLength</span>() &#123; <span class="keyword">return</span> m_length; &#125; <span class="comment">// note class name is Array&lt;T&gt;, not Array</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">使用：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Array.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">intArray</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">	<span class="function">Array&lt;<span class="type">double</span>&gt; <span class="title">doubleArray</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; intArray.<span class="built_in">getLength</span>(); ++count)</span><br><span class="line">	&#123;</span><br><span class="line">		intArray[count] = count;</span><br><span class="line">		doubleArray[count] = count + <span class="number">0.5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> count = intArray.<span class="built_in">getLength</span>()<span class="number">-1</span>; count &gt;= <span class="number">0</span>; --count)</span><br><span class="line">		std::cout &lt;&lt; intArray[count] &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="类模板和标准库："><a href="#类模板和标准库：" class="headerlink" title="类模板和标准库："></a>类模板和标准库：</h3><p>从上面的例子可以看到，类模板定义的Array和Vector容器很类似，而类似vector的容器就是类模板实现的；</p>
<h3 id="模板类无法进行定义和函数实现的分离："><a href="#模板类无法进行定义和函数实现的分离：" class="headerlink" title="模板类无法进行定义和函数实现的分离："></a>模板类无法进行定义和函数实现的分离：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">如下例子，在链接时会出现问题：</span><br><span class="line">Array.h:</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> <span class="comment">// for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_length;</span><br><span class="line">    T *m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> T[length];</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Array</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The length of the array is always an integer</span></span><br><span class="line">    <span class="comment">// It does not depend on the data type of the array</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">Array.cpp:</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Array.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Array&lt;T&gt;::<span class="built_in">getLength</span>() &#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">使用时：链接时出错</span><br><span class="line">main.cpp:</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Array.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">intArray</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">	<span class="function">Array&lt;<span class="type">double</span>&gt; <span class="title">doubleArray</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; intArray.<span class="built_in">getLength</span>(); ++count)</span><br><span class="line">	&#123;</span><br><span class="line">		intArray[count] = count;</span><br><span class="line">		doubleArray[count] = count + <span class="number">0.5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> count = intArray.<span class="built_in">getLength</span>()<span class="number">-1</span>; count &gt;= <span class="number">0</span>; --count)</span><br><span class="line">		std::cout &lt;&lt; intArray[count] &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```cpp</span><br><span class="line"></span><br><span class="line">为什么呢：？</span><br><span class="line">实例化模板的必要条件：</span><br><span class="line">   为了让编译器去使用一个模板，它必须看到包括模板定义(而不是只有一个声明),和用于实例化模板的模板类型如<span class="type">int</span>等；</span><br><span class="line">上述例子为什么不成功？</span><br><span class="line">   且记住C++是单独编译文件的；当Array.h头文件被包含到main时，模板类定义被拷贝到main.cpp,当编译器看到我们需</span><br><span class="line">要两个模板实例，Array&lt;<span class="type">int</span>&gt;和Array&lt;<span class="type">double</span>&gt;,它将实例化他们，且编译他们作为main.cpp中的一部分；</span><br><span class="line">然而，当他单独的获取和编译Array.cpp时，他已经忘记我们需要一个Array&lt;<span class="type">int</span>&gt;和Array&lt;<span class="type">double</span>&gt;（单独编译，看不到main),所以Array.cpp中的模板函数不会被实例化；因此会因为找不到函数<span class="built_in">getLength</span>()的定义而得到链接错误；</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">   针对上述问题，有几种处理方式：</span><br><span class="line">     <span class="number">1</span>)把定义全放在.h头文件</span><br><span class="line">  <span class="number">2</span>)把 rename Array.cpp to Array.<span class="built_in">inl</span> (.inl stands <span class="keyword">for</span> <span class="keyword">inline</span>), <span class="keyword">and</span> then include Array.inl from the bottom of the Array.h header. That yields the same result as putting all the code in the header, but helps keep things a little cleaner.</span><br><span class="line"> <span class="number">3</span>）在main中include所有：</span><br><span class="line"><span class="comment">// Ensure the full Array template definition can be seen</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Array.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Array.cpp&quot;</span> <span class="comment">// we&#x27;re breaking best practices here, but only in this one place</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// #include other .h and .cpp template definitions you need here</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Array</span>&lt;<span class="type">int</span>&gt;; <span class="comment">// Explicitly instantiate template Array&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Array</span>&lt;<span class="type">double</span>&gt;; <span class="comment">// Explicitly instantiate template Array&lt;double&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// instantiate other templates here</span></span><br></pre></td></tr></table></figure>

<h3 id="模板类类参数多样性"><a href="#模板类类参数多样性" class="headerlink" title="模板类类参数多样性"></a>模板类类参数多样性</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">模板类参数可以是无类型，即某种特定的类型：</span><br><span class="line">A value that has an integral type <span class="keyword">or</span> enumeration</span><br><span class="line">A pointer <span class="keyword">or</span> reference to a <span class="keyword">class</span> <span class="title class_">object</span></span><br><span class="line">A pointer <span class="keyword">or</span> reference to a function</span><br><span class="line">A pointer <span class="keyword">or</span> reference to a <span class="keyword">class</span> <span class="title class_">member</span> function</span><br><span class="line">std::<span class="type">nullptr_t</span></span><br><span class="line">例子：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt; <span class="comment">// size is the non-type parameter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// The non-type parameter controls the size of the array</span></span><br><span class="line">    T m_array[size];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">getArray</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Showing how a function for a class with a non-type parameter is defined outside of the class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line">T* StaticArray&lt;T, size&gt;::<span class="built_in">getArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_array;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// declare an integer array with room for 12 integers</span></span><br><span class="line">    StaticArray&lt;<span class="type">int</span>, <span class="number">12</span>&gt; intArray;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Fill it up in order, then print it backwards</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count=<span class="number">0</span>; count &lt; <span class="number">12</span>; ++count)</span><br><span class="line">        intArray[count] = count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count=<span class="number">11</span>; count &gt;= <span class="number">0</span>; --count)</span><br><span class="line">        std::cout &lt;&lt; intArray[count] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// declare a double buffer with room for 4 doubles</span></span><br><span class="line">    StaticArray&lt;<span class="type">double</span>, <span class="number">4</span>&gt; doubleArray;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count=<span class="number">0</span>; count &lt; <span class="number">4</span>; ++count)</span><br><span class="line">        doubleArray[count] = <span class="number">4.4</span> + <span class="number">0.1</span>*count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count=<span class="number">0</span>; count &lt; <span class="number">4</span>; ++count)</span><br><span class="line">        std::cout &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类模板的特化"><a href="#类模板的特化" class="headerlink" title="类模板的特化"></a>类模板的特化</h3><p>什么是类模板的特化，为什么需要，什么时候使用？<br>类模板的特化和函数模板特化类似，当我们定义了一个类模板后，这个类模板可以实例成int ,bool,char等等类型，都是同样的处理逻辑；<br>当我们想针对bool特殊化，比如bool本身用一个bit就可以实现，节省空间，时，可以用类模板的特化，来为实例成bool时定义一个类模板的特化，这样，bool就和其他int等不同了；</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage8</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_array[<span class="number">8</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_array[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">特化<span class="type">bool</span>:</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// the following is a template class with no templated parameters</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage8</span>&lt;<span class="type">bool</span>&gt; <span class="comment">// we&#x27;re specializing Storage8 for bool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// What follows is just standard class implementation details</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Storage8</span>() : <span class="built_in">m_data</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Figure out which bit we&#x27;re setting/unsetting</span></span><br><span class="line">        <span class="comment">// This will put a 1 in the bit we&#x27;re interested in turning on/off</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> mask = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (value)  <span class="comment">// If we&#x27;re setting a bit</span></span><br><span class="line">            m_data |= mask;  <span class="comment">// Use bitwise-or to turn that bit on</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// if we&#x27;re turning a bit off</span></span><br><span class="line">            m_data &amp;= ~mask;  <span class="comment">// bitwise-and the inverse mask to turn that bit off</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Figure out which bit we&#x27;re getting</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> mask = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">        <span class="comment">// bitwise-and to get the value of the bit we&#x27;re interested in</span></span><br><span class="line">        <span class="comment">// Then implicit cast to boolean</span></span><br><span class="line">        <span class="keyword">return</span> (m_data &amp; mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Define a Storage8 for integers (instantiates Storage8&lt;T&gt;, where T = int)</span></span><br><span class="line">    Storage8&lt;<span class="type">int</span>&gt; intStorage;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count=<span class="number">0</span>; count&lt;<span class="number">8</span>; ++count)</span><br><span class="line">        intStorage.<span class="built_in">set</span>(count, count);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count=<span class="number">0</span>; count&lt;<span class="number">8</span>; ++count)</span><br><span class="line">        std::cout &lt;&lt; intStorage.<span class="built_in">get</span>(count) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Define a Storage8 for bool  (instantiates Storage8&lt;bool&gt; specialization)</span></span><br><span class="line">    Storage8&lt;<span class="type">bool</span>&gt; boolStorage;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count=<span class="number">0</span>; count&lt;<span class="number">8</span>; ++count)</span><br><span class="line">        boolStorage.<span class="built_in">set</span>(count, count &amp; <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count=<span class="number">0</span>; count&lt;<span class="number">8</span>; ++count)</span><br><span class="line">        std::cout &lt;&lt; (boolStorage.<span class="built_in">get</span>(count) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板的偏特化"><a href="#模板的偏特化" class="headerlink" title="模板的偏特化"></a>模板的偏特化</h3><p>区别于前文说的特化，偏特化指的是部分的特化，比如两个模板类型，将其中一个特化了，或者是<br>特化为指针等等；见下面例子：</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 两个类型特化了其中一个</span><br><span class="line">泛化：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">特化：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;<span class="type">bool</span>,Alloc&gt;<span class="comment">//在类型化时，若传入的第一个参数为bool，则用以下版zf本；</span></span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="偏特化为指针"><a href="#偏特化为指针" class="headerlink" title="偏特化为指针"></a>偏特化为指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">泛化：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="type">int</span> ittt;</span><br><span class="line">&#125;;</span><br><span class="line">偏特化：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>*&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="type">double</span> ittt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_template</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_template_deepin</title>
    <url>/2021/01/10/cpp-template-deepin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="模板是什么，为什么要引入模板："><a href="#模板是什么，为什么要引入模板：" class="headerlink" title="模板是什么，为什么要引入模板："></a>模板是什么，为什么要引入模板：</h3><p>模板是用来生成代码的，通过模板可以定义一组类型的共同行为；<br>为什么要引入模板：<br>继承和组合是实现重用代码的方法，而容器也是，为了实现能承载不同类型的容器，java等其他语言用所有类都继承于根类型等方式，<span id="more"></span><br>而c++这里为了减少不必要的开支，和冗余，采用预定义等方式，在预处理和编译时，将T替换为实际类型参数，并生成对应的类型；<br>来从而实现了容器；<br>所以说：模板的引入，是为了实现容器的需求；</p>
<p>那么容器呢？为什么容器被需要？<br>栈的内存管理依赖于函数本身，或者说操作系统，在函数的调用结束后，会回收相关的存于栈的结构，所以不用我们去考虑清理的事情；<br>但是当我们在堆上使用时，malloc&#x2F;new后，往往需要free&#x2F;delete,在传统的c中，malloc后会需要进行free，否则程序运行时会出现内存泄漏；<br>容器的真正需求，是在这种情景下，减轻程序员的负担，担负起自动new和清理的工作；</p>
<p>c++是怎么做的？ c++标准容器，用new创建需要的对象，将其指针放入容器中，实际使用时取出并处理，这种方法创建的只是对象，<br>清理时依赖析构函数时进行合理的free；不过需要注意，当存储的对象是指针时，此时的指针需要程序员自己去new和释放；<br>同时为了支持承载多种类型的对象，所以模板就被创建出来；</p>
<h3 id="模板的基本原理："><a href="#模板的基本原理：" class="headerlink" title="模板的基本原理："></a>模板的基本原理：</h3><p>为了解决多类型：有几个方法，模板采用的是第三个：</p>
<ol>
<li>c方法复制粘贴代码</li>
<li>继承来实现代码重用，但是需要学习基础类库</li>
<li>实现类似宏替换的逻辑，并放到编译器中，编译器识别到类似声明，就进行替换，从而重新生成类定义等，也取消类型的指定；而容器的实现则是<br> 以堆来存放一组特定类型对象。类似对象数组等；</li>
</ol>
<h3 id="模板是怎么工作的，工程上，内部结构等，编译器的作用；"><a href="#模板是怎么工作的，工程上，内部结构等，编译器的作用；" class="headerlink" title="模板是怎么工作的，工程上，内部结构等，编译器的作用；"></a>模板是怎么工作的，工程上，内部结构等，编译器的作用；</h3><h4 id="1）工程文件上，如何预编译，编译，链接等；"><a href="#1）工程文件上，如何预编译，编译，链接等；" class="headerlink" title="1）工程文件上，如何预编译，编译，链接等；"></a>1）工程文件上，如何预编译，编译，链接等；</h4><p> 模板中分为函数模板和类模板：<br>类模板：定义和成员函数实现都是写在头文件中<br>函数模板：定义声明等都是写在头文件中；<br>模板编译模型：<br>模板的完整定义都是放在每个编译单元中；例如完全放在单个文件程序中，或者放在文件程序的头文件中；和传统的编程方式背道而驰；</p>
<h5 id="1-传统的为什么要这么做？—分离模型："><a href="#1-传统的为什么要这么做？—分离模型：" class="headerlink" title="(1) 传统的为什么要这么做？—分离模型："></a>(1) 传统的为什么要这么做？—分离模型：</h5><p>不要放置分配存储空间的任何东西(这条规定是为了防止在链接期间的多重定义错误)，编译期间是单个文件的，此时不会出现，但是链接的时候是多个实现文件，若是头文件里也定义了，就会导致链接的时候多重定义，而编译器对此并没有去重；</p>
<p>头文件中的非内联函数体会导致多函数的定义，从而导致链接错误；<br>隐藏来自客户有益函数实现，减少了编译时链接；<br>隐藏代码，代码所有权；<br>头文件越小，编译时间越短；</p>
<h5 id="2-模板时包含模型，那这样客户代码想隐藏怎么办？"><a href="#2-模板时包含模型，那这样客户代码想隐藏怎么办？" class="headerlink" title="(2) 模板时包含模型，那这样客户代码想隐藏怎么办？"></a>(2) 模板时包含模型，那这样客户代码想隐藏怎么办？</h5><p>在template&lt;..&gt;后的任何东西都意味着编译器在当时不为它分配存储空间，而是一直处于等待状态直到一个模板示例告知，而此时是编译器在碰到模板示例时，往往是编译期间，然后生成对应的类，然后在运行时，才分配对象的空间；在编译器和连接器中有机制能去掉同一模板的多重定义；所以为了使用方便，几乎总是在头文件中放置全部的模板声明和定义；</p>
<p>模板代码本质上只是产生代码的指令，不是真正的代码，只有实例化了才是，一个编译器在编译期间看到模板的完整定义后，在同一个翻译单元中碰到模板实例化点时，也会在其他翻译单元碰到同样的实例化点，这样就会重复生成实例化代码；而编译器和连接器需要解决这个重复定义；<br>这种有两个缺点：<br>a  编译时间增加  b 无法隐藏实现代码；<br>如何处理？ 如何实现分离？<br>一种是显示实例化，一种是导出模板：<br>显示实例化：<br>    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	eg:</span><br><span class="line">ourMin.h :</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> OURMIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OURMIN_H</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp;,<span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">ourMin.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ourMin.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a,<span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (a&lt;b)?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UseMin1.cpp:</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;outMin.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">usemin1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">min</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UseMin2.cpp:</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#Include <span class="string">&quot;outMin.h&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">usemin2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout&lt;&lt;<span class="built_in">min</span>(<span class="number">3.2</span> ,<span class="number">4.3</span>) &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.cpp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">usemin1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">usemin2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">usemin1</span>();</span><br><span class="line">    <span class="built_in">usemin2</span>();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>建立这个程序式，连接器报告有未解析的min<int>() 和min<double>()的外部引用； 因为编译器在min的特化时，只有min的声明可见，定义不可见，编译器认为它可能来自于其他单元，所以即没有实例化，问题留给了连接器，连接器无法找到；<br>所以可用加一个显示实例化来进行，即显示特化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Minstances.cpp:</span><br><span class="line">#Include <span class="string">&quot;ourMin.cpp&quot;</span><span class="comment">//因为编译器需要模板定义来实例化；</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">const</span> <span class="type">int</span>&amp; <span class="built_in">min</span>&lt;min&gt;(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;);</span><br><span class="line"><span class="keyword">template</span> <span class="type">const</span> <span class="type">double</span>&amp; <span class="built_in">min</span>&lt;<span class="type">double</span>&gt; (<span class="type">const</span> <span class="type">double</span> &amp;,<span class="type">const</span> <span class="type">double</span>&amp;);</span><br></pre></td></tr></table></figure>

<p>导出模板：<br>export关键字： </p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp;,<span class="type">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-模板定义的几种方式："><a href="#2-模板定义的几种方式：" class="headerlink" title="2)模板定义的几种方式："></a>2)模板定义的几种方式：</h4><p>声明和内联函数的形式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> :</span><br><span class="line">       <span class="built_in">AA</span> ()&#123;&#125;;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;...&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">声明和非内联函数的形式；</span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">          <span class="keyword">enum</span> &#123; size = <span class="number">1000</span>&#125;;</span><br><span class="line">          T A[size];</span><br><span class="line">          <span class="keyword">public</span>:</span><br><span class="line">               T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index);</span><br><span class="line">    &#125;;</span><br><span class="line">       <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">      T&amp; Array&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> index) &#123;</span><br><span class="line">               .....</span><br><span class="line">              <span class="keyword">return</span> A[index];</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>声明在头文件，定义在cpp的显示实例化，注意需要cpp加显示实例声明，见上面2</p>
<h4 id="3）模板的一些使用技巧：-在stl源码解析中："><a href="#3）模板的一些使用技巧：-在stl源码解析中：" class="headerlink" title="3）模板的一些使用技巧： 在stl源码解析中："></a>3）模板的一些使用技巧： 在stl源码解析中：</h4><pre><code> 涉及以下几种： 类型萃取，迭代器，智能指针(引用释放等) ,泛型算法等等；
</code></pre>
<h3 id="模板的使用细节："><a href="#模板的使用细节：" class="headerlink" title="模板的使用细节："></a>模板的使用细节：</h3><h4 id="1-模板参数：-类型-基础或用户自定义-编译时常数值-整数，指针或某些静态实体的引用，通常作为无类型模板参数，支持默认参数-其他模板；"><a href="#1-模板参数：-类型-基础或用户自定义-编译时常数值-整数，指针或某些静态实体的引用，通常作为无类型模板参数，支持默认参数-其他模板；" class="headerlink" title="1) 模板参数： 类型(基础或用户自定义), 编译时常数值(整数，指针或某些静态实体的引用，通常作为无类型模板参数，支持默认参数),其他模板；"></a>1) 模板参数： 类型(基础或用户自定义), 编译时常数值(整数，指针或某些静态实体的引用，通常作为无类型模板参数，支持默认参数),其他模板；</h4><p>模板类型参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line">     ....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Seq</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">&#123;</span><br><span class="line">    Seq&lt;T&gt; seq;<span class="comment">//通知编译器，Seq是一个模板；本例子中Seq代表Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">使用：Container&lt;<span class="type">int</span>,Array&gt; container;</span><br><span class="line">还可以支持标准库中的容器：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>,<span class="keyword">class</span> = allocator&lt;U&gt;&gt;  <span class="keyword">class</span> Seq&gt;</span><br><span class="line"><span class="keyword">class</span> Container</span><br><span class="line">&#123;</span><br><span class="line">    Seq&lt;T&gt; seq;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用： Container&lt;int ,vector&gt; xxx;实际上容器适配器就是用类似的方法实现的，如stack<br>typename关键字用法；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">当在模板中用T::id这种类型时，编译器会默认解析为T类中的静态成员id,而不会认为这个是一个内部类，所以，当用法为：</span><br><span class="line">T::id i ;这种定义变量的方式时，会出错，此时需要向编译器说明这个是一个嵌套类；</span><br><span class="line">所以<span class="keyword">typename</span>在这里的作用： <span class="number">1</span>) 声明是一个类型，<span class="number">2</span>）可以替换<span class="keyword">class</span> <span class="title class_">template</span>&lt; <span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">X</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">typename</span>并不能起到定义新类型的作用，可以用<span class="keyword">typedef</span> <span class="keyword">typename</span> Seq&lt;it&gt;::iterator It;类似的 </span><br></pre></td></tr></table></figure>

<p>template关键字的作用：<br>1）声明模板<br>2）模板中遇到&gt; &lt;等和模板的&gt; &lt;混合时，用template声明；</p>
<h4 id="2-成员模板；"><a href="#2-成员模板；" class="headerlink" title="2)成员模板；"></a>2)成员模板；</h4><p>就是在类模板中定义一个新的内部类模板：<br>eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> :</span><br><span class="line">         <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">R</span>&gt; <span class="keyword">class</span> <span class="title class_">inter</span>&#123;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                 <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">R</span>&gt;</span><br><span class="line"><span class="type">void</span> Outer&lt;T&gt;::inter&lt;R&gt;::<span class="built_in">g</span>() &#123;</span><br><span class="line">      ..</span><br><span class="line">&#125;</span><br><span class="line">使用：</span><br><span class="line"> Outer&lt;<span class="type">int</span>&gt;::inter&lt;<span class="type">bool</span>&gt; interr;</span><br></pre></td></tr></table></figure>

<h4 id="3-有关函数模板的内容"><a href="#3-有关函数模板的内容" class="headerlink" title="3) 有关函数模板的内容"></a>3) 有关函数模板的内容</h4><ol>
<li>函数模板定义了一簇函数； —函数模板参数的类型如何推断：涉及一些参数可以省略的问题</li>
<li>函数模板重载：其实是直接定义了普通函数，这样若是符合普通函数的类型则调用的是定义的普通函数，否则是模板生成；<br>3）以一个已生成的函数模板地址作为参数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T*)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(<span class="type">void</span> (*pf)(<span class="type">int</span>*))</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">void</span> (*pf)(T*))</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">h</span>(&amp;f&lt;<span class="type">int</span>&gt;);</span><br><span class="line">    <span class="built_in">h</span>(&amp;f);</span><br><span class="line">    <span class="built_in">g</span>&lt;<span class="type">int</span>&gt;(&amp;f&lt;<span class="type">int</span>&gt;);</span><br><span class="line">    <span class="built_in">g</span>&lt;<span class="type">int</span>&gt;(&amp;f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4)将函数用到stl序列容器中：TODO<br>5）函数模板的半有序： 即T, T*,const T*的区分，优先匹配特化程度最高的那个模板；他们的特化程度逐渐递增；</p>
<h4 id="4-模板特化相关"><a href="#4-模板特化相关" class="headerlink" title="4)模板特化相关"></a>4)模板特化相关</h4><p>显示特化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>&amp; <span class="built_in">min</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(.....)</span><br></pre></td></tr></table></figure>

<p>半特化：<br>比如有两个参数，只限定了其中一个类型；<br>防止代码膨胀– TODO</p>
<h4 id="5-模板中的名称查找问题"><a href="#5-模板中的名称查找问题" class="headerlink" title="5)模板中的名称查找问题"></a>5)模板中的名称查找问题</h4><p>编译器解析模板定义，并寻找明显的语法错误，还要对其所能解析的所有名称进行解析；对于不依赖模板参数的名称，编译器使用普通名称查找解析他们，不能解析的就是关联名称，只有等到实例化才知道；<br>模板和友元：  –TODO</p>
<h4 id="6-模板编程中的习语"><a href="#6-模板编程中的习语" class="headerlink" title="6)模板编程中的习语:"></a>6)模板编程中的习语:</h4><ol>
<li>特征：将与某种类型相关联的所有声明绑定在一起的实现方式；<br>2）策略： 其实就是类似萃取类型；<br>3）神奇的递归模板，在编译期间就算出来值了；运行时只需要读取即可</li>
</ol>
<h4 id="7-模板元编程："><a href="#7-模板元编程：" class="headerlink" title="7)模板元编程："></a>7)模板元编程：</h4><p>1） 编译时编程 :模板中编译时循环，循环分解，编译时选择，编译时断言—即利用模板，在编译时就算出值，减少运行开销哈<br>2)  表达式模板：</p>
<h4 id="8-模板与继承：-模板实例也可以作为被继承方；"><a href="#8-模板与继承：-模板实例也可以作为被继承方；" class="headerlink" title="8)模板与继承： 模板实例也可以作为被继承方；"></a>8)模板与继承： 模板实例也可以作为被继承方；</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">xx</span>: <span class="keyword">public</span> tes&lt;A&gt; &#123;&#125;;</span><br><span class="line">模板其他资料；见书：c++ templates,the complete guide</span><br></pre></td></tr></table></figure>

<h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><p>懒惰初始化，使用时才分配空间，读写时分配<br>存放指针对象时，为了避免多重释放，可以实现所有权函数，拥有所有权的才有释放的权利 owns函数</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref:"></a>ref:</h3><p>c++编程思想；</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_template</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_template_func</title>
    <url>/2021/01/10/cpp-template-func/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>为什么需要函数模板：类型限制了函数的通用性，参数换一种类型，即得重新再定义一个处理流程相同的函数；<span id="more"></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">max</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>,ints等等，甚至实现了&gt;运算符函数的类也是如此；</span><br></pre></td></tr></table></figure>

<h3 id="什么是函数模板："><a href="#什么是函数模板：" class="headerlink" title="什么是函数模板："></a>什么是函数模板：</h3><p>In C++, function templates are functions that serve as a pattern for creating other similar functions.<br>在c++中，函数模板即是能作为一个模式来创建其他相似函数的一组函数；<br>在c++函数模板中，我们使用占位符来替代部分或全部的函数中具体类型的变量；<br>返回值，形参，以及函数内定义的局部变量等都能使用；<br>typename和class 的区别：<a href="http://www.cplusplus.com/forum/general/8027/">http://www.cplusplus.com/forum/general/8027/</a></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>                                                             </span></span><br><span class="line"><span class="comment">//using namespace std;导入这个为什么会出错？这里也定义了min函数，那么会冲突？                            </span></span><br><span class="line"><span class="keyword">using</span>  std::cout;                                                              </span><br><span class="line"><span class="keyword">using</span>  std::endl;                                                              </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                          </span><br><span class="line">   <span class="comment">/* T min( T x, T y)&#123; </span></span><br><span class="line"><span class="comment">            T t=x;                                          </span></span><br><span class="line"><span class="comment">        return (x+t&gt;y)?y:x;                                                      </span></span><br><span class="line"><span class="comment">&#125;   */</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">( T x, T y)</span></span>&#123;                                       </span><br><span class="line">        <span class="keyword">return</span> (x&gt;y)?y:x;                                                      </span><br><span class="line">&#125;                                                                               </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span>                                                                    </span></span><br><span class="line"><span class="function"></span>&#123;                                                                              </span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">min</span>(<span class="number">3</span>,<span class="number">4</span>);                                                          </span><br><span class="line">    cout&lt;&lt;i&lt;&lt;endl;                                                             </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="type">double</span> d=<span class="built_in">min</span>(<span class="number">6.38</span>,<span class="number">12.32</span>);                                                  </span><br><span class="line">    cout&lt;&lt;d&lt;&lt;endl;                                                             </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">min</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;6&#x27;</span>);                                                      </span><br><span class="line">    cout&lt;&lt;ch&lt;&lt;endl;                                                            </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                  </span><br><span class="line">&#125;                                     </span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">建议，这里的模板定义加上<span class="type">const</span>和使用引用会更好，使用引用的原因是传入的参数有可能是类类型(这样参数类型和返回值应为引用更通用），使用<span class="type">const</span>是为了避免对传入参数的原变量造成影响；如下：</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="built_in">min</span>(<span class="type">const</span> T&amp; x,<span class="type">const</span> T&amp; y)&#123;</span><br><span class="line">        <span class="built_in">return</span> (x&gt;y)?y:x;</span><br><span class="line">    &#125;                           </span><br></pre></td></tr></table></figure>

<h4 id="更多使用例子"><a href="#更多使用例子" class="headerlink" title="更多使用例子"></a>更多使用例子</h4><p>用于类类型:注意类需要实现对应的运算符函数等；<br>模板类型和实际类型混合<br>指针类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">average</span><span class="params">(T *array, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count=<span class="number">0</span>; count &lt; length; ++count)</span><br><span class="line">        sum += array[count];</span><br><span class="line"> </span><br><span class="line">    sum /= length;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个模板类型</p>
<h3 id="假设这里我传入了int-会怎么样？"><a href="#假设这里我传入了int-会怎么样？" class="headerlink" title="假设这里我传入了int* 会怎么样？"></a>假设这里我传入了int* 会怎么样？</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">来看一个例子：指针的话会优先匹配指针</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;导入这个为什么会出错？这里也定义了min函数，那么会冲突？                            </span></span><br><span class="line"><span class="keyword">using</span>  std::cout;</span><br><span class="line"><span class="keyword">using</span>  std::endl;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">   <span class="comment">/* T min( T x, T y)&#123; </span></span><br><span class="line"><span class="comment">            T t=x;                                          </span></span><br><span class="line"><span class="comment">        return (x+t&gt;y)?y:x;                                                      </span></span><br><span class="line"><span class="comment">&#125;   */</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">( T* x, T* y)</span></span>&#123;<span class="comment">//这样的话，这里的x实际上是指针类型，比如传入int* ==&gt; T* ，要返回int的话，得对x做*，如*x</span></span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;real&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="keyword">return</span> (*x&gt;*y)?*y:*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*template&lt;typename T&gt; 模板只能匹配参数，不能匹配返回值，所以这里和上面的是重复的；编译会报错；</span></span><br><span class="line"><span class="comment">T* min(T* x,T* y)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">     return (x&gt;y)?y:x;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T x,T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">min</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> d=<span class="built_in">min</span>(<span class="number">6.38</span>,<span class="number">12.32</span>);</span><br><span class="line">    cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">min</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">    cout&lt;&lt;ch&lt;&lt;endl;</span><br><span class="line"><span class="comment">//以上匹配的是非指针的版本+</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;now pointer&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> m =<span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> jj=<span class="built_in">min</span>(&amp;m,&amp;n); <span class="comment">//这里匹配的是指针的</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;m:&quot;</span>&lt;&lt;&amp;m&lt;&lt;<span class="string">&quot;n:&quot;</span>&lt;&lt;&amp;n&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(&amp;m,&amp;n)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;jj&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">~                                    </span><br></pre></td></tr></table></figure>

<h3 id="函数模板的特化-什么时候需要"><a href="#函数模板的特化-什么时候需要" class="headerlink" title="函数模板的特化 什么时候需要"></a>函数模板的特化 什么时候需要</h3><p>引入：有时候，针对具体的类型，我们想定义具体的函数，而不是用模板中对所有类型通用的函数时，可以定义一个函数模板的特化函数；<br>语法：<br>eg</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Storage</span>(T value)</span><br><span class="line">    &#123;</span><br><span class="line">         m_value = value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Storage</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Define some storage units</span></span><br><span class="line">    <span class="function">Storage&lt;<span class="type">int</span>&gt; <span class="title">nValue</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Storage&lt;<span class="type">double</span>&gt; <span class="title">dValue</span><span class="params">(<span class="number">6.7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print out some values</span></span><br><span class="line">    nValue.<span class="built_in">print</span>();</span><br><span class="line">    dValue.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line">那么当我们想针对<span class="type">double</span>有个特殊专属的print函数时，应该怎么做？</span><br><span class="line">答案是针对其写一个函数：特化：</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> Storage&lt;<span class="type">double</span>&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; std::scientific &lt;&lt; m_value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">这样，当编译器实例化模板时，<span class="type">double</span>时，就会使用这个特化的print;</span><br><span class="line">The <span class="keyword">template</span> &lt;&gt; tells the compiler that <span class="keyword">this</span> is a <span class="keyword">template</span> function, <span class="function">but that there are no <span class="keyword">template</span> <span class="title">parameters</span> <span class="params">(since in <span class="keyword">this</span> <span class="keyword">case</span>, we’re explicitly specifying all of the types)</span>. Some compilers may allow you to omit <span class="keyword">this</span>, but it’s proper to include it.</span></span><br></pre></td></tr></table></figure>

<h3 id="类相关例子："><a href="#类相关例子：" class="headerlink" title="类相关例子："></a>类相关例子：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类模板的构造函数也可以这样处理：</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Storage&lt;<span class="type">char</span>*&gt;::<span class="built_in">Storage</span>(<span class="type">char</span>* value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Figure out how long the string in value is</span></span><br><span class="line">    <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (value[length] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        ++length;</span><br><span class="line">    ++length; <span class="comment">// +1 to account for null terminator</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Allocate memory to hold the value string</span></span><br><span class="line">    m_value = <span class="keyword">new</span> <span class="type">char</span>[length];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Copy the actual value string into the m_value memory we just allocated</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count=<span class="number">0</span>; count &lt; length; ++count)</span><br><span class="line">        m_value[count] = value[count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_template</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_this</title>
    <url>/2018/06/09/cpp-this/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c-关键字之this"><a href="#c-关键字之this" class="headerlink" title="c++关键字之this"></a>c++关键字之this</h3><h4 id="this指针是什么"><a href="#this指针是什么" class="headerlink" title="this指针是什么"></a>this指针是什么</h4><p>this是一个指向当前正在使用的对象的指针，它是一个指针；<br>成员函数通过它来使用对象的值，通过它知道要对哪个对象的成员操作<br>如：<span id="more"></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Simple</span>(<span class="type">int</span> id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setID</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; m_id = id; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Simple <span class="title">simple</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    simple.<span class="built_in">setID</span>(<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; simple.<span class="built_in">getID</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">simple.<span class="built_in">setID</span>(<span class="number">2</span>);---&gt;</span><br><span class="line"><span class="built_in">setID</span>(&amp;simple, <span class="number">2</span>); <span class="comment">// note that simple has been changed from an object prefix to a function argument!</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; m_id = id; &#125;---&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(Simple* <span class="type">const</span> <span class="keyword">this</span>, <span class="type">int</span> id)</span> </span>&#123; <span class="keyword">this</span>-&gt;m_id = id; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="this指针用法"><a href="#this指针用法" class="headerlink" title="this指针用法"></a>this指针用法</h4><p>关键词 this 是一个纯右值表达式，其值是在调用成员函数时的对象地址。它能出现于下列语境：</p>
<ul>
<li>在任何非静态成员函数体内，含成员初始化列表</li>
<li>在非静态成员函数的声明内任何(可选) cv 限定符序列后处，包含动态异常规定(弃用)、 noexcept 规定(C++11)及尾随返回类型(C++11 起)</li>
<li>在默认成员初始化中 (C++11 起)</li>
<li>在一个对象的构造期间，若通过不直接或间接从构造函数的 this 指针获得的泛左值，访问对象的值或任何其子对象，则如此获得的对象或子对象的值是未指定的。换言之，构造函数中 this 指针不能别名使用：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">D</span> d;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> &#123;</span><br><span class="line"><span class="built_in">D</span>(<span class="type">int</span> a) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(d.a) &#123;&#125; <span class="comment">// a(a)will change to this-&gt;a(a),but b(d.a)--&gt;this-&gt;b(d.a),and will get random value,but b(a) 或 b(this-&gt;a) 是正确的</span></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line">D d = <span class="built_in">D</span>(<span class="number">1</span>);   <span class="comment">// 因为 b(d.a) 不通过 this 访问， d.b 现在是未指定的,i try in g++.find it d.b==1</span></span><br></pre></td></tr></table></figure>

<h4 id="this指针于内存哪里？"><a href="#this指针于内存哪里？" class="headerlink" title="this指针于内存哪里？"></a>this指针于内存哪里？</h4><p>this 指针是不占类的内存的，它是传入成员函数的参数，所以它在栈中  </p>
<h4 id="this-指针总是指向正在操作的对象："><a href="#this-指针总是指向正在操作的对象：" class="headerlink" title="this 指针总是指向正在操作的对象："></a>this 指针总是指向正在操作的对象：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Simple <span class="title">A</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// *this = &amp;A inside the Simple constructor</span></span><br><span class="line">    <span class="function">Simple <span class="title">B</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// *this = &amp;B inside the Simple constructor</span></span><br><span class="line">    A.<span class="built_in">setID</span>(<span class="number">3</span>); <span class="comment">// *this = &amp;A inside member function setID</span></span><br><span class="line">    B.<span class="built_in">setID</span>(<span class="number">4</span>); <span class="comment">// *this = &amp;B inside member function setID</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line">+ <span class="keyword">this</span>指针的连锁使用：  </span><br><span class="line">由<span class="keyword">this</span>指针理解cout&lt;&lt;xxx&lt;&lt;&lt;xxx&lt;&lt;&lt;xxxxx....</span><br><span class="line">对上述的表达式，cout是一个类，&lt;&lt;是该类的操作符函数，则&lt;&lt;函数返回<span class="keyword">this</span>，若返回空，则无法进行：  </span><br><span class="line">```cpp</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; userName;</span><br><span class="line">(std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span>) &lt;&lt; userName;</span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>) &lt;&lt; userName;　错误</span><br><span class="line">(std::cout) &lt;&lt; userName;正确</span><br><span class="line">如何写？</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Calc</span>() &#123; m_value = <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Calc&amp; <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; m_value += value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">sub</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; m_value -= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">mult</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; m_value *= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calc calc;</span><br><span class="line">    calc.<span class="built_in">add</span>(<span class="number">5</span>).<span class="built_in">sub</span>(<span class="number">3</span>).<span class="built_in">mult</span>(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; calc.<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">注意Calc&amp; 和<span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">###<span class="meta"># this指针到对象名代表的是什么</span></span><br><span class="line">由above和以下例子：来看对象的地址等</span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">set</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">set</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">set <span class="title">add</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_i += i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">getval</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set s;</span><br><span class="line">    s.<span class="built_in">add</span>(<span class="number">2</span>).<span class="built_in">add</span>(<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">getval</span>();</span><br><span class="line">&#125;```</span><br><span class="line"><span class="comment">//结果是２　因为函数返回的*this是一个值，它是set对象的值：</span></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">set</span></span><br><span class="line">    <span class="number">5</span> &#123;   </span><br><span class="line">    <span class="number">6</span>     <span class="type">int</span> m_e;</span><br><span class="line">    <span class="number">7</span>     <span class="type">int</span> m_i;</span><br><span class="line">    <span class="number">8</span>  <span class="keyword">public</span>:</span><br><span class="line">    <span class="number">9</span>     <span class="built_in">set</span>()</span><br><span class="line">   <span class="number">10</span>     &#123;</span><br><span class="line">   <span class="number">11</span>         m_e=<span class="number">0</span>;</span><br><span class="line">   <span class="number">12</span>         m_i=<span class="number">0</span>;</span><br><span class="line">   <span class="number">13</span>     &#125;</span><br><span class="line">   <span class="number">14</span>     <span class="function">set <span class="title">add</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">   <span class="number">15</span>             m_i+=i;</span><br><span class="line">   <span class="number">16</span>             <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   <span class="number">17</span>     &#125;</span><br><span class="line">   <span class="number">18</span>     <span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   <span class="number">19</span>             <span class="keyword">return</span> m_i;</span><br><span class="line">   <span class="number">20</span>     &#125;</span><br><span class="line">   <span class="number">21</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   33 </span>&#123;</span><br><span class="line">   <span class="number">34</span>         set s;</span><br><span class="line">   <span class="number">35</span>         set s2;</span><br><span class="line">&gt;&gt; <span class="number">36</span>         <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,s.<span class="built_in">add</span>(<span class="number">2</span>));--输出<span class="number">0</span>,返回的是*<span class="keyword">this</span>，为s的值，m_e是其第一个成员</span><br><span class="line">&gt;&gt; <span class="number">37</span>         <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,s);－－输出<span class="number">0</span></span><br><span class="line">   <span class="number">38</span>         s2=s.<span class="built_in">add</span>(<span class="number">2</span>);--s2被赋值了s，s此时的m_i=<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">   <span class="number">39</span>         s2.<span class="built_in">add</span>(<span class="number">2</span>);--s2的m_i=<span class="number">6</span></span><br><span class="line">&gt;&gt; <span class="number">40</span>         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s2);<span class="comment">//输出的是０－－－ m_e=0</span></span><br><span class="line">   <span class="number">41</span>         cout&lt;&lt;s2.<span class="built_in">getval</span>()&lt;&lt;endl;-输出<span class="number">6</span>，因为</span><br><span class="line">   <span class="number">42</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">43</span> &#125;</span><br><span class="line"> 由此可以看出<span class="keyword">this</span>-&gt;object  <span class="keyword">this</span>-&gt;s</span><br><span class="line">            *<span class="keyword">this</span>==s</span><br><span class="line">            *<span class="keyword">this</span>==s的内容</span><br><span class="line">　　　　　　取对象的地址　&amp;s</span><br></pre></td></tr></table></figure>
<p>ref:<br><a href="http://zh.cppreference.com/w/cpp/language/this">http://zh.cppreference.com/w/cpp/language/this</a><br><a href="http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/">http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/</a></p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb基础</title>
    <url>/2020/07/11/gdb%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、总体<br>GDB可以做四种主要的事情（以及支持这些事情的其他事情）来帮助您捕获行为中的错误：</p>
<span id="more"></span>
<p>1）启动程序，并指定可能影响其行为的所有内容。<br>2）使程序在指定条件下停止。<br>3）检查程序停止时发生的情况。<br>4）更改程序中的内容，以便您可以尝试纠正一个错误的影响，然后继续学习另一个错误。<br>2、一个例子：<br>gdb 调试运行一个程序：<br>$ gdb m4  –运行<br>(gdb) set width 70 –设置显示最大字符数，类似more<br>(gdb) break m4_changequote   –设置断点，断点可以是某个函数，如main<br>Breakpoint 1 at 0x62f4: file builtin.c, line 879.<br>(gdb) run<br>Starting program: &#x2F;work&#x2F;Editorial&#x2F;gdb&#x2F;gnu&#x2F;m4&#x2F;m4  –开始运行<br>(gdb) n   –next 不进入函数运行，运行下一行；<br>(gdb) s  –step 运行下一行，遇到函数会进入</p>
<p>(gdb) bt –backtrace 打印调用栈<br>(gdb) p lquote  –打印变量lquote,这个是变量名<br>(gdb) p 表达式，这个表达式可以是符合语法的表达式，比如赋值语句和函数调用等，是生效的；<br>eg (gdb) p ++a</p>
<p>$1 &#x3D; 0x35d40 “<QUOTE>“<br>(gdb) l    —list，显示源代码<br>533             xfree(rquote);<br>(gdb) Ctrl-d –退出程序<br>(gdb)quit  &#x2F;q –退出gdb<br>3、经常使用分类<br>3.1 如何开始：<br> 1）gdb programname<br>        2）gdb programname corefile<br>        3)  gdb  programname pid   &#x2F; gdb -p pid  (关联上一个-g编译过的正在运行的进程)<br>        4)  gdb –args programname arg1 2 3….<br>        eg:gdb –args gcc -O2 -c foo.c<br>        5) gdb xx     –silent&#x2F;–quit &#x2F;-q 不用输出信息<br>3.2 在gdb中也可以使用shell指令：<br>(gdb) !ifconfig</p>
<p>3.3 设置log文件<br>使用技巧：<br>1）回车表示重复上一个命令，除了run等；<br>2）step 数字，可以表示步进多少<br>3.4 设置打印方式：<br>1)要更改要打印的数组元素的限制<br>(gdb)set print elements 10<br>2)是否打印数组：<br>       (GDB) set print array on<br>       (GDB) print some_array<br>       (GDB) set print array off<br>3.5 gdb的自动补全，按tab即可，甚至可以补全函数名；<br>3.6 gdb 命令有option ,tab键可以召唤出来；<br>3.7 gdb和线程；<br>3.8 gdb的栈概念<br>4  常见命令<br>gdb栈查看命令<br>backtrace [option]… [qualifier]… [count]<br>bt [option]… [qualifier]… [count]<br>(gdb) frame 3<br>(gdb) frame level 3<br>(gdb) info frame<br>Stack level 1, frame at 0x7fffffffda30:<br>向上或向下跳帧；<br>up n<br>down n </p>
<p>(gdb) frame apply all p j<br>#0  some_function (i&#x3D;5) at fun.c:4<br>No symbol “j” in current context.<br>(gdb) frame apply all -c p j<br>#0  some_function (i&#x3D;5) at fun.c:4<br>No symbol “j” in current context.<br>打印变量：p<br>显示源码 l</p>
<p>5 参考资料</p>
<p><a href="https://scc.ustc.edu.cn/zlsc/sugon/intel/debugger/cl/index.htm#commandref/gdb_mode/cmd_set_width.htm">https://scc.ustc.edu.cn/zlsc/sugon/intel/debugger/cl/index.htm#commandref/gdb_mode/cmd_set_width.htm</a><br>more:<br><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a><br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">https://sourceware.org/gdb/current/onlinedocs/gdb/</a></p>
<p>使用例子：</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_linklist1</title>
    <url>/2018/06/03/leetcode-linklist1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="leetcode——单链表"><a href="#leetcode——单链表" class="headerlink" title="leetcode——单链表"></a>leetcode——单链表</h3><h4 id="两数相加："><a href="#两数相加：" class="headerlink" title="两数相加："></a>两数相加：</h4><ul>
<li>这道题是经一年多没刷题目之后，重新开始的第一道题，本来想着只是本地刷刷，后面开始就到leetcode提交了，毕竟写的程序还是得经过检验</li>
<li>所以这道题就纯粹的解答，未经检验，只是本地跑通，并且加上了自己的一些看法，比如对该题目该思路可能可以应用在哪些地方，这样算法才有了真正的意义，个人十分不赞同一些在公司呆久了的人说数据结构算法没什么用的人2333</li>
<li>废话不多说：  好久没写，第一道就别吐槽了，慢慢来</li>
<li>题目描述：  <span id="more"></span><br>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>Example<br>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 &#x3D; 807.<br>注意两个数字位数可能不同，所以需要一些特殊情况要处理<br><code>c #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;</code></li>
</ul>
<p>&#96;&#96;&#96;c<br>struct ListNode {<br>        struct ListNode *next;<br>        int num;<br>} *linklist,listnode;</p>
<p>&#x2F;&#x2F;这是自己加的扩展，把输入的两个大数字符串转换为链表<br>int changtolist(struct ListNode <em>list1,char num1[],struct ListNode <em>list2,char  num2[])<br>{&#x2F;&#x2F;应该在接口内计算长度好些<br>   int i&#x3D;0;<br>   int lennum1&#x3D;0;<br>   while(num1[lennum1]!&#x3D;’\0’){lennum1++;}<br>   int lennum2&#x3D;0;<br>   while(num2[lennum2]!&#x3D;’\0’){lennum2++;}<br>&#x2F;&#x2F;分配空间加字母转数字，无头节点<br>   list1-&gt;num&#x3D;num1[lennum1-1]-48;<br>   for(i&#x3D;lennum1-2;i&gt;&#x3D;0;i–)<br>   {<br>        list1-&gt;next&#x3D;(struct ListNode</em>)malloc(sizeof(struct ListNode));<br>        list1&#x3D;list1-&gt;next;<br>        list1-&gt;num&#x3D;num1[i]-48;<br>   }<br>   list1-&gt;next&#x3D;NULL;<br>   list2-&gt;num&#x3D;num2[lennum2-1]-48;<br>   for(i&#x3D;lennum2-2;i&gt;&#x3D;0;i–)<br>   {<br>        list2-&gt;next&#x3D;(struct ListNode</em>)malloc(sizeof(struct ListNode));<br>        list2&#x3D;list2-&gt;next;<br>        list2-&gt;num&#x3D;num2[i]-48;<br>   }<br>   list2-&gt;next&#x3D;NULL;<br>   return 0;<br>}<br>&#x2F;&#x2F;两个大数相加，不用头节点的方式，麻烦一些<br>int Add_two_num(struct ListNode *list1,struct ListNode <em>list2)<br>{<br>     int adding &#x3D; 0;<br>     if(list1 &#x3D;&#x3D; NULL || list2 &#x3D;&#x3D; NULL)<br>             return -1;<br>&#x2F;</em>     while(list1!&#x3D;NULL &amp;&amp; list2!&#x3D;NULL)<br>     {<br>             list1-&gt;num &#x3D; (list1-&gt;num+list2-&gt;num+adding)%10;<br>             adding &#x3D; (list1-&gt;num + list2-&gt;num+adding)&#x2F;10;<br>             list1 &#x3D; list1-&gt;next;<br>             list2 &#x3D; list2-&gt;next;<br>    }<br>     if(list1&#x3D;&#x3D;NULL &amp;&amp; list2!&#x3D;NULL)<br>    *&#x2F;<br>      struct ListNode *xx&#x3D;list1;<br>      int n&#x3D;0;<br>      int sum&#x3D;0;<br>      sum &#x3D; list1-&gt;num+list2-&gt;num+adding;<br>      list1-&gt;num &#x3D; sum%10;<br>      adding &#x3D; sum&#x2F;10;<br>    do {&#x2F;&#x2F;常规情况，两个同长度部分<br>             list1 &#x3D; list1-&gt;next;<br>             list2 &#x3D; list2-&gt;next;<br>             sum&#x3D; list1-&gt;num+list2-&gt;num+adding;<br>             list1-&gt;num &#x3D; sum %10;<br>            &#x2F;&#x2F; printf(“%d “,list1-&gt;num);<br>             adding &#x3D; sum&#x2F;10;<br>    }while(list1-&gt;next!&#x3D;NULL &amp;&amp; list2-&gt;next!&#x3D;NULL);<br>    if(list1-&gt;next &#x3D;&#x3D;NULL&amp;&amp; list2-&gt;next&#x3D;&#x3D;NULL &amp;&amp;adding!&#x3D;0)&#x2F;&#x2F;串1短于串2<br>    {<br>            list1-&gt;next &#x3D; (struct ListNode *)malloc(sizeof(struct ListNode));<br>            list1-&gt;next-&gt;num&#x3D; adding;<br>            printf(“show:%d\n”,adding);<br>    }<br>    if(list1-&gt;next&#x3D;&#x3D;NULL &amp;&amp; list2-&gt;next !&#x3D;NULL)<br>    {</p>
<pre><code>        list1-&gt;next = list2-&gt;next;
        while(list2-&gt;next!=NULL&amp;&amp;adding !=0)
        &#123;
          list2=list2-&gt;next;
          sum= list2-&gt;num+adding;
          list2-&gt;num=sum%10;
          adding = sum/10;
        &#125;
        if(adding&gt;0)
        &#123;
                list2-&gt;next=(struct ListNode *)malloc(sizeof(struct ListNode));
                list2-&gt;next-&gt;num=adding;
        &#125;
&#125;  
...//串1长于 串2
.....
  return 0;
</code></pre>
<p>}<br>&#x2F;&#x2F;需要思考，当进位到最后时，可能1,2都结束了，但是产生高位，此时要new　listnode 完成<br>&#x2F;&#x2F;或者剩下２，和进位，则考虑２加进位<br>int main ()<br>{<br>  struct ListNode <em>list1,<em>list2;<br>  list1 &#x3D; (struct ListNode</em>)malloc(sizeof(struct ListNode));<br>  list2 &#x3D; (struct ListNode</em>)malloc(sizeof(struct ListNode));<br>  list1-&gt;num&#x3D;3;<br>  list2-&gt;num&#x3D;5;<br>  struct ListNode *tmplist1&#x3D;list1;<br>  struct ListNode *tmplist2&#x3D;list2;<br>  int i;<br>  for(i&#x3D;1; i&lt;9;i++)<br>  {</p>
<pre><code>list1-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));
list2-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));
list1 = list1-&gt;next;
list2 = list2-&gt;next;
list1-&gt;num = 2;
list2-&gt;num= 8;
</code></pre>
<p>  }<br>  list2-&gt;next &#x3D; (struct ListNode*)malloc(sizeof(struct ListNode));<br>  list2-&gt;next-&gt;num&#x3D;9;<br>  struct ListNode *result&#x3D;tmplist1;<br>  struct ListNode *freelist1 &#x3D; tmplist1;<br>  struct ListNode *freelist2 &#x3D; tmplist2;<br>  for (i&#x3D;0;i&lt;9;i++,tmplist1&#x3D;tmplist1-&gt;next)<br>          printf(“%d “,tmplist1-&gt;num);<br>  printf(“\n”);</p>
<p>  for (i&#x3D;0;i&lt;10;i++,tmplist2&#x3D;tmplist2-&gt;next)<br>          printf(“%d “,tmplist2-&gt;num);<br>  printf(“\n”);<br>  Add_two_num(freelist1,freelist2);<br>  for(i&#x3D;0;result!&#x3D;NULL ;i++,result&#x3D;result-&gt;next)<br>       printf(“%d “,result-&gt;num);<br>  free(freelist1);<br>  free(freelist2);</p>
<p>  printf(“\n”);<br>&#x2F;&#x2F;——————————-<br>  struct ListNode <em>list11,<em>list22;<br>  list11 &#x3D; (struct ListNode</em>)malloc(sizeof(struct ListNode));<br>  list22 &#x3D; (struct ListNode</em>)malloc(sizeof(struct ListNode));</p>
<p>  char num1[100],num2[100];<br>  gets(num1);<br>  gets(num2);<br>  changtolist(list11,num1,list22,num2);<br>  struct ListNode *result11 &#x3D; list11;<br>  Add_two_num(list11,list22);<br>  for(i&#x3D;0;result11!&#x3D;NULL ;i++,result11&#x3D;result11-&gt;next)<br>       printf(“%d “,result11-&gt;num);<br>  free(list11);<br>  free(list22);<br>  return 0;<br>}&#96;&#96;&#96;<br>&#x2F;&#x2F;思考，扩大这道题的应用，在大数相加的时候，增加用户输入接口:”<br>&#x2F;&#x2F;5263565656554+5656537677834546<br>&#x2F;&#x2F;由char读入，int&#x2F;char相加，<br>——-极其丑的程序，以后不能这么搞，留个纪念<br>想贴下两年多前（大三吧，那会刷这道题通过的程序–看来最喜欢的还是c）</p>
<p>&#96;&#96;&#96;c<br>&#x2F;**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li><pre><code>int val;
</code></pre>
</li>
<li><pre><code>ListNode *next;
</code></pre>
</li>
<li><pre><code>ListNode(int x) : val(x), next(NULL) &#123;&#125;
</code></pre>
</li>
<li>};</li>
</ul>
<p> *&#x2F;</p>
<p> class Solution {<br> public:<br>     ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {<br>         ListNode *sum, *l4;<br>         sum &#x3D; new ListNode(0); &#x2F;&#x2F;新节点<br>         l4 &#x3D; sum;<br>         int sum_single, en &#x3D; 0;&#x2F;&#x2F;en表示进位的标志<br>         while (l1 !&#x3D; NULL&amp;&amp;l2 !&#x3D; NULL)<br>         {</p>
<pre><code>             sum-&gt;next = new ListNode(0);//这里有个问题变为sum=NULL就行
             sum = sum-&gt;next;
        // signal = 0;
         sum_single = l1-&gt;val + l2-&gt;val + en;
         if (sum_single&lt;10)
         &#123;
             sum-&gt;val = sum_single;
             en = 0;
         &#125;
         else if (sum_single &gt;= 10)
         &#123;
             sum-&gt;val = sum_single - 10;
             en = 1;
         &#125;
         l1 = l1-&gt;next;
         l2 = l2-&gt;next;
    
     &#125;
     while (l1 != NULL&amp;&amp;l2 == NULL)
     &#123; 
         sum-&gt;next = new ListNode(0);
         sum = sum-&gt;next;
         sum_single = en + l1-&gt;val;
         if (sum_single &gt;= 10)
         &#123;
             sum-&gt;val = sum_single - 10;
             en = 1;
         &#125;
         else
         &#123;
             sum-&gt;val = sum_single;
             en = 0;
         &#125;
         l1 = l1-&gt;next;
        

     &#125;
     while (l2 != NULL&amp;&amp;l1 == NULL)
     &#123; 
         sum-&gt;next = new ListNode(0);
         sum = sum-&gt;next;
         sum_single = en + l2-&gt;val;
         if (sum_single &gt;= 10)
         &#123;
             sum-&gt;val = sum_single - 10;
             en = 1;
         &#125;
         else
         &#123;
             sum-&gt;val = sum_single;
             en = 0;
         &#125;
         l2 = l2-&gt;next;
     &#125;
     if (l1 == NULL&amp;&amp;l2 == NULL&amp;&amp;en == 1)
         sum-&gt;next = new ListNode(en);
    //if(l1==NULL&amp;&amp;l2==NULL&amp;&amp;en==0)sum = NULL;
/*     while (l3)
     &#123;
         cout &lt;&lt; l3-&gt;val;
         l3 = l3-&gt;next;
     &#125;*/
     return l4-&gt;next;
 &#125;
</code></pre>
<p> };<br>&#x2F;*<br>int main()<br>{<br>    Solution sou;<br>    ListNode *l1,*l2,*l3;<br>    l1&#x3D;new ListNode(3);<br>    l1-&gt;next&#x3D;new ListNode(7);<br>    l1-&gt;next-&gt;next&#x3D;new ListNode(5);</p>
<pre><code> l2=new ListNode(7);
l2-&gt;next=new ListNode(7);
l2-&gt;next-&gt;next=new ListNode(5);
l3=sou.addTwoNumbers(l1,l2);
cout&lt;&lt;l3-&gt;val&lt;&lt;l3-&gt;next-&gt;val&lt;&lt;l3-&gt;next-&gt;next-&gt;val;
return 0;
</code></pre>
<p>}</p>
<p>*&#x2F;&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_linklist2</title>
    <url>/2018/06/03/leetcode-linklist2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="leetcode——单链表2"><a href="#leetcode——单链表2" class="headerlink" title="leetcode——单链表2"></a>leetcode——单链表2</h3><h4 id="partition-list"><a href="#partition-list" class="headerlink" title="partition list"></a>partition list</h4><p>这个是快速排序中一个很重要的步骤，即比该数大于等于的放其前小的放后。在链表中，基本思路:扫描链表，比给定数字小的不处理，比给定数字大的取下并插入到末尾 <span id="more"></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">You should preserve the original relative order of the nodes in each of the two partitions.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">partition</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next ==<span class="literal">NULL</span>)</span><br><span class="line">              <span class="keyword">return</span> head;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list</span>=</span>(<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span>  ListNode));</span><br><span class="line">        <span class="built_in">list</span>-&gt;next=head;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">head1</span>=</span><span class="built_in">list</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">cur</span> =</span> head1-&gt;next;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">tail</span>=</span>head1;</span><br><span class="line">		<span class="type">int</span> lenoflist1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(tail-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">				tail=tail-&gt;next;</span><br><span class="line">				lenoflist1++;</span><br><span class="line">		&#125;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tmp</span>=</span>tail;</span><br><span class="line">		<span class="keyword">while</span>(lenoflist1&gt;=<span class="number">1</span>)</span><br><span class="line">		&#123; </span><br><span class="line">            lenoflist1--;</span><br><span class="line">            <span class="keyword">if</span>(tail==cur)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span>(cur-&gt;val&gt;=x)</span><br><span class="line">		  &#123;</span><br><span class="line">				  head1-&gt;next=cur-&gt;next;</span><br><span class="line">				  cur-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		          tail-&gt;next=cur;</span><br><span class="line">				  tail=tail-&gt;next;<span class="comment">//not consid at first</span></span><br><span class="line">				  cur=head1-&gt;next;</span><br><span class="line"></span><br><span class="line">		  &#125; </span><br><span class="line">		  <span class="keyword">else</span>&#123;</span><br><span class="line">				  head1=head1-&gt;next;</span><br><span class="line">				  cur=cur-&gt;next;</span><br><span class="line">		  &#125;</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">//  printf(&quot;%d : &quot;,cur-&gt;num);</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//if(head1-&gt;next==NULL)head1-&gt;next=tmp;</span></span><br><span class="line">         head=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">   <span class="built_in">list</span>-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;此题目最终被accepted<br>&#x2F;&#x2F;应该在函数中添加头节点而不是依靠传入的链表带头节点,一开始没有考虑到传入的链表不带链表头。。，没有考虑到一个元素的情况，这个方案最终accept</p>
<h4 id="链表中的子链表反转，考察头插法"><a href="#链表中的子链表反转，考察头插法" class="headerlink" title="链表中的子链表反转，考察头插法"></a>链表中的子链表反转，考察头插法</h4><ul>
<li>头插法在链表的反转，倒序，常被用到</li>
</ul>
<pre><code class="c">/* reverse a linklist from m to n
 * 1-&gt;2-&gt;4-&gt;5-&gt;null and m,n(ex:2,4)
 * return 1-&gt;5-&gt;4-&gt;2-&gt;null
 */

#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
typedef struct LinkList
&#123;
    int num;
    struct LinkList  *next;
&#125;Linklist;
int reverselinklist(Linklist *list1,int m,int n,Linklist **result)
&#123;
        if(list1==NULL)
                return -1;
        int i=0;
        Linklist *head1,*head2,*cur,*tmp,*pre;
        cur=list1;
        head1=cur;
        pre=head1;
        if(m==1)
        &#123;
                cur=cur-&gt;next;
                for(i=m;i&lt;n;i++)
                &#123;
                  pre-&gt;next=cur-&gt;next;
                  cur-&gt;next=head1;
                  head1=cur;
                  cur=pre-&gt;next;
                &#125;
                *result=head1;
                return 1;
        &#125;

        for(i=1;i&lt;m;i++)//node1-&gt;node2-&gt;node3---1-&gt;2-&gt;3--ex:m=2,list1-&gt;1
        &#123;
          head1=cur;
          cur=cur-&gt;next;
        &#125;
        head2=cur;
        cur=cur-&gt;next;
        pre=head2;
        for(i=m;i&lt;n;i++)
        &#123;
           pre-&gt;next=cur-&gt;next;
           cur-&gt;next=head1-&gt;next;
           head1-&gt;next=cur;
           cur=pre-&gt;next;
        &#125;
      return 3;
&#125;

int main ()
&#123;
        Linklist *list1=(Linklist*)malloc(sizeof(Linklist));
        Linklist *result11=list1;
        int i;
        list1-&gt;num=4;
        printf(&quot;4 &quot;);
       for(i=1; i&lt;9;i++)
      &#123;
                             
            list1-&gt;next = (Linklist *)malloc(sizeof(Linklist));
            list1 = list1-&gt;next;
            list1-&gt;num = i*2;
            printf(&quot;%d &quot;,i*2);
      &#125;
       printf(&quot;\n&quot;);
       Linklist *rr=(Linklist *)malloc(sizeof(Linklist));
       Linklist **resull=&amp;rr;
       int rere=reverselinklist(result11,1,9,resull);
       if(rere==3) &#123;
        for(i=0;result11!=NULL ;i++,result11=result11-&gt;next)
                       printf(&quot;%d &quot;,result11-&gt;num); 
          free(list1);
       &#125;
      else
      &#123; 
        for(i=0;*resull!=NULL ;i++,*resull= (*resull)-&gt;next)
                       printf(&quot;%d &quot;,(*resull)-&gt;num); 
          free(*resull);
      &#125;
        return 0;
&#125;```
//此解法未经过leetcode检验，不过应该问题不大

#### 有序链表移除重复元素
+ 考察的是遍历链表删除链表中的元素，注意边缘条件控制如头部和尾部

```c
/**

 Given a sorted linked list, delete all duplicates such that each element appear only once.

Example 1:

Input: 1-&gt;1-&gt;2
Output: 1-&gt;2

Example 2:

Input: 1-&gt;1-&gt;2-&gt;3-&gt;3
Output: 1-&gt;2-&gt;3

 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     struct ListNode *next;
 * &#125;;
 */
struct ListNode* deleteDuplicates(struct ListNode* head) &#123;
    if(head==NULL)return NULL;
    if(head-&gt;next==NULL)return head;
    struct ListNode *first=head;
    struct ListNode  *second=head-&gt;next;
    struct ListNode *tmp=second;
    while(second!=NULL) 
    &#123;
        tmp=second;
        if(first-&gt;val==second-&gt;val)
        &#123;
            second=second-&gt;next;
            
        &#125;
        else
        &#123;
            first-&gt;next=second;
            first=first-&gt;next;
            second=second-&gt;next;
        &#125;
    &#125;
    if(first-&gt;val==tmp-&gt;val)
        first-&gt;next=NULL;
    return head;
&#125;```
//此方案最后被accepted

#### 删除有序链表中的有重复的node
+ 和上一道题目类似:

```c
/**

 Given a sorted linked list, delete all duplicates such that each element appear only once.

Example 1:

Input: 1-&gt;1-&gt;2
Output: 1-&gt;2

Example 2:

Input: 1-&gt;1-&gt;2-&gt;3-&gt;3
Output: 1-&gt;2-&gt;3

 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     struct ListNode *next;
 * &#125;;
 */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct ListNode &#123;
      int val;
      struct ListNode *next;
  &#125;;
struct ListNode* deleteDuplicates(struct ListNode* head) &#123;
    if(head==NULL)return NULL;
    if(head-&gt;next==NULL)return head;
    struct ListNode *headnode=(struct ListNode*)malloc(sizeof(struct ListNode));
    headnode-&gt;next=head;
    
    struct ListNode *first=head;
    struct ListNode  *second=head-&gt;next;
    int numsame=0;
    struct ListNode *tmphead=headnode;
    while(second!=NULL) 
    &#123;
        if(first-&gt;val==second-&gt;val)
        &#123;
               numsame++;
               first=first-&gt;next;
               second=second-&gt;next;
               
        &#125;
        else if(first-&gt;val !=second-&gt;val &amp;&amp; numsame==0)
        &#123;
            tmphead-&gt;next=first;
            tmphead=tmphead-&gt;next;
            first=first-&gt;next;
            second=second-&gt;next;
        &#125;
        else 
        &#123;
            first=first-&gt;next;
            second=second-&gt;next;
            numsame=0;
        &#125;
    &#125;
    if(numsame==0)tmphead-&gt;next=first;
    else tmphead-&gt;next =NULL;
    head=headnode-&gt;next;
    headnode-&gt;next=NULL;
    free(headnode);   
    return head;
&#125;


int main()
&#123;
   struct ListNode *list1=(struct ListNode *)malloc(sizeof(struct ListNode));
   struct ListNode *tmp=list1;
   struct ListNode *freelist1=list1;
   int i=0;
   for(i=1;i&lt;9;i++)
   &#123;
         list1-&gt;val=20-i;
         list1-&gt;next=(struct ListNode *)malloc(sizeof(struct ListNode));
         list1=list1-&gt;next;
         printf(&quot;%d &quot;,20-i);
   &#125;
   list1-&gt;val=12;
   tmp=deleteDuplicates(tmp);
   printf(&quot;\n&quot;);
   for(i=1;tmp!=NULL;i++)
   &#123;
           printf(&quot;%d  &quot;,tmp-&gt;val);
           tmp=tmp-&gt;next;
   &#125;
   free(freelist1);
   return 0;
&#125;


这道题做的比较顺利，一次提交就=通过了
注意：加头节点，由于解题的思路是两个指针的遍历，在第二个指针为空时停止，就会有尾巴为几种情况时的处理：如当尾巴为：4,4,4;4,5,5 这两种情况时，去掉尾巴，否则4,5,6.4,4,5时尾巴保留；见代码```
</code></pre>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_linklist3</title>
    <url>/2018/06/07/leetcode-linklist3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="leetcode-linklist3"><a href="#leetcode-linklist3" class="headerlink" title="leetcode_linklist3"></a>leetcode_linklist3</h3><p>continue..</p>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.</p>
<span id="more"></span>
<p>Example 1:</p>
<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2<br>Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
<p>Example 2:</p>
<p>Input: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4<br>Output: 2-&gt;0-&gt;1-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL<br>rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL<br>rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>&#x2F;**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li><pre><code>int val;
</code></pre>
</li>
<li><pre><code>struct ListNode *next;
</code></pre>
</li>
<li>};</li>
</ul>
<p> *&#x2F;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">rotateRight</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">headnode</span>=</span>(<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    headnode-&gt;next=head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">sumhead</span>=</span>head;</span><br><span class="line">    <span class="comment">//compute len of list</span></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sumhead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        sumhead=sumhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    sum++;</span><br><span class="line">    <span class="comment">//compare k and len,or just compute the rota num</span></span><br><span class="line">    <span class="type">int</span> num=k%sum;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dealheadf</span>=</span>head;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;sum-num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dealheadf=dealheadf-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sumhead-&gt;next=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=dealheadf-&gt;next;</span><br><span class="line">    dealheadf-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">    head=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headnode);</span><br><span class="line">    <span class="keyword">return</span>  head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="移除倒数第n个元素"><a href="#移除倒数第n个元素" class="headerlink" title="移除倒数第n个元素"></a>移除倒数第n个元素</h4><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>
<p>Example:</p>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n &#x3D; 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p>
<p>Note:</p>
<p>Given n will always be valid.</p>
<p>Follow up:</p>
<p>Could you do this in one pass?</p>
<p>&#x2F;**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li><pre><code>int val;
</code></pre>
</li>
<li><pre><code>struct ListNode *next;
</code></pre>
</li>
<li>};</li>
</ul>
<p> *&#x2F;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="comment">//这个几乎没道题都要注意</span></span><br><span class="line">         <span class="keyword">return</span> head;</span><br><span class="line">     <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>&amp;&amp;n&gt;=<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">sumhead</span>=</span>head;</span><br><span class="line">     <span class="keyword">while</span>(sumhead!=<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         sum++;</span><br><span class="line">         sumhead=sumhead-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> remove=sum-n;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">removenode</span>=</span>head;</span><br><span class="line">     <span class="keyword">while</span>(remove&gt;<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         removenode=removenode-&gt;next;</span><br><span class="line">         remove--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">rmnode</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(remove==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">rmnode</span>;</span></span><br><span class="line">     rmnode=removenode-&gt;next;</span><br><span class="line">     removenode-&gt;next=removenode-&gt;next-&gt;next;</span><br><span class="line">     rmnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">     <span class="built_in">free</span>(rmnode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//删除头</span></span><br><span class="line">    &#123;</span><br><span class="line">        rmnode=removenode;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">        rmnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(rmnode);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;一开始未考虑到删除头的情况，所以加了else 部分</p>
<h4 id="交换元素"><a href="#交换元素" class="headerlink" title="交换元素"></a>交换元素</h4><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>Example:</p>
<p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Note:</p>
<pre><code>Your algorithm should use only constant extra space.
You may not modify the values in the list&#39;s nodes, only nodes itself may be changed.
</code></pre>
<p>&#x2F;**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li><pre><code>int val;
</code></pre>
</li>
<li><pre><code>struct ListNode *next;
</code></pre>
</li>
<li>};</li>
</ul>
<p> *&#x2F;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">swapPairs</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">headNode</span>=</span>(<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">second</span>=</span>head-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">first</span>=</span>head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">curhead</span>=</span>headNode;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="literal">NULL</span>)<span class="keyword">break</span>;</span><br><span class="line">        second=first-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(second!=<span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          first-&gt;next=second-&gt;next==<span class="literal">NULL</span>?<span class="literal">NULL</span>:second-&gt;next;</span><br><span class="line">          second-&gt;next=first;</span><br><span class="line">          curhead-&gt;next=second;</span><br><span class="line">          curhead=first;</span><br><span class="line">          first=first-&gt;next==<span class="literal">NULL</span>?<span class="literal">NULL</span>:first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head=headNode-&gt;next;</span><br><span class="line">    headNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headNode);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="k组反转"><a href="#k组反转" class="headerlink" title="k组反转"></a>k组反转</h4><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>Example:</p>
<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k &#x3D; 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k &#x3D; 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>Note:</p>
<pre><code>Only constant extra memory is allowed.
You may not alter the values in the list&#39;s nodes, only nodes itself may be changed.
</code></pre>
<p>&#x2F;**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li><pre><code>int val;
</code></pre>
</li>
<li><pre><code>struct ListNode *next;
</code></pre>
</li>
<li>};</li>
</ul>
<p> <em>&#x2F;<br>&#x2F;</em><br>这道题目原想在遍历一次就解决，可是还是想不出好的方法，得遍历两次，一次计算长度，一次正真的处理；<br>在处理的过程使用头插法。注意边界条件，但因为有数量控制好些*&#x2F;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseKGroup</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">headnode</span>=</span>(<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    headnode-&gt;next=head;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">lenhead</span>=</span>head,*curhead=headnode,*cur=head,*tmp=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(lenhead!=<span class="literal">NULL</span>)<span class="comment">//计算长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        lenhead=lenhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> numofreverse=len/k;<span class="comment">//要reverse几次</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=numofreverse;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j=k;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">1</span>)<span class="comment">//每一次reverse k次，头插法</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp=curhead-&gt;next;</span><br><span class="line">            curhead-&gt;next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            curhead-&gt;next-&gt;next=tmp;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        curhead=cur;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    head=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headnode);</span><br><span class="line">    <span class="keyword">return</span> head;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>后面还有几道题，不贴了，这里简述下：  </p>
<ul>
<li><p>检查是否链表中存在循环</p>
</li>
<li><p>检查链表中是否存在循环并找到循环的起点</p>
</li>
<li><p>深度复制链表，链表中的每个节点存在一个指向任意节点的指针</p>
</li>
<li><p>设计一个LRU cache,即（最近使用的）</p>
</li>
<li><p>。。。。。</p>
</li>
<li><p>链表的套路：</p>
<ul>
<li>常使用头插法进行反转操作</li>
<li>使用两个指针解决循环问题，指针相遇测试是否存在循环，指针遍历减少时间</li>
<li>使用哈希，以空间换时间</li>
<li>加头节点，简化逻辑</li>
</ul>
</li>
<li><p>使用链表注意</p>
<ul>
<li>检查空和是否只有一个节点</li>
<li>释放空间，和放置取空指针，可以通过次数控制和判空</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_string</title>
    <url>/2018/06/24/leetcode-string/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="leetcode-string"><a href="#leetcode-string" class="headerlink" title="leetcode_string"></a>leetcode_string</h3><h4 id="传统字符串匹配："><a href="#传统字符串匹配：" class="headerlink" title="传统字符串匹配："></a>传统字符串匹配：</h4><ul>
<li>简单写写,变量命名等就先不纠结了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(<span class="type">char</span> s[],<span class="type">char</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;\0&#x27;</span>||p[<span class="number">0</span>]==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;p or s is null&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="type">int</span> k=<span class="number">0</span>,j=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;s[i]!=<span class="string">&#x27;\0&#x27;</span>&amp;&amp;s[k]!=<span class="string">&#x27;\0&#x27;</span>;)</span><br><span class="line">		&#123;</span><br><span class="line">		     <span class="keyword">if</span>(p[j]==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">				   <span class="keyword">break</span>;	 </span><br><span class="line">			 <span class="keyword">if</span>(s[k]==p[j])</span><br><span class="line">			 &#123;</span><br><span class="line">					 k++;</span><br><span class="line">					 j++;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">else</span> <span class="comment">//不匹配时重新来过</span></span><br><span class="line">			 &#123;</span><br><span class="line">					 i++;</span><br><span class="line">					 k=i;</span><br><span class="line">					 j=<span class="number">0</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span>(p[j]==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;```</span><br><span class="line">###<span class="meta"># kmp匹配算法</span></span><br><span class="line">kmp算法：基本过程见另一篇文章数据结构之字符串&lt;!--more--&gt;，这里贴写代码(未经大数据检验，谨慎观看)</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nextfunc</span><span class="params">(<span class="type">char</span> p[],<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">   next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(p[j]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">		   <span class="keyword">if</span>(k==<span class="number">0</span>||p[j]==p[k])</span><br><span class="line">		   &#123;</span><br><span class="line">				   ++j;</span><br><span class="line">				   ++k;</span><br><span class="line">				   next[j]=k;</span><br><span class="line">		   &#125;</span><br><span class="line">		   <span class="keyword">else</span></span><br><span class="line">				   k=next[k];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(<span class="type">char</span> s[],<span class="type">char</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> next[<span class="number">100</span>];</span><br><span class="line">   <span class="built_in">nextfunc</span>(p,next);</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>;s[i]!=<span class="string">&#x27;\0&#x27;</span>&amp;&amp;p[j]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">		   <span class="comment">//if(j==-1)j=0;</span></span><br><span class="line">		   <span class="keyword">if</span>(s[i]==p[j])</span><br><span class="line">		   &#123;</span><br><span class="line">		     j++;</span><br><span class="line">			 <span class="keyword">continue</span>;</span><br><span class="line">		   &#125;</span><br><span class="line">		   <span class="keyword">while</span>(s[i]!=p[j]&amp;&amp;j&gt;=<span class="number">0</span>)j=next[j];</span><br><span class="line">		   j++;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">if</span>(p[j]==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">		 <span class="keyword">return</span> i-j;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">		 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>简单测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="type">char</span> a[<span class="number">19</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>&#125;;</span><br><span class="line">		<span class="type">char</span> b[<span class="number">10</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;s&#x27;</span>&#125;;</span><br><span class="line">		<span class="type">int</span> pos=<span class="built_in">strStr</span>(a,b);</span><br><span class="line">		cout&lt;&lt;pos&lt;&lt;endl;</span><br><span class="line">		<span class="type">int</span> pos2=<span class="built_in">kmp</span>(a,b);</span><br><span class="line">		cout&lt;&lt;pos2&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他字符串算法题目："><a href="#其他字符串算法题目：" class="headerlink" title="其他字符串算法题目："></a>其他字符串算法题目：</h4><h5 id="判读字符串是否为回文串"><a href="#判读字符串是否为回文串" class="headerlink" title="判读字符串是否为回文串"></a>判读字符串是否为回文串</h5><ul>
<li>所谓回文串即正者读反着读都一样：</li>
<li>解决方案：<ul>
<li>1.设置两个索引，一个从字符串开始位置往后走，一个从字符串最后的位置往前走，比较这两个索引指向的字符是否相等，直到遍历完整个字符串；注意这里其实并不需要遍历整个字符串，一个索引只需要走一半就可以，回文串两边对称的。</li>
<li>2.利用栈，思路类似</li>
</ul>
</li>
</ul>
<h5 id="字符串转整数-atoi"><a href="#字符串转整数-atoi" class="headerlink" title="字符串转整数(atoi)"></a>字符串转整数(atoi)</h5><ul>
<li>分析：这个题目需要注意的是各种不规则的输入和其他边缘条件如int整数的范围等</li>
<li>解决方案:<ul>
<li>若是严格的检查，则判断字符ASCII码是否在0-9之间，注意整数的首位不能为0）；整数的正负；数据是否溢出；是否数据的表现形式如33x8fe；等等。</li>
<li>非严格的检查，如遇到非法的字符跳过即可；首位为0时跳过或者当成八进制等等</li>
</ul>
</li>
</ul>
<h5 id="对两个二进制字符串求和"><a href="#对两个二进制字符串求和" class="headerlink" title="对两个二进制字符串求和"></a>对两个二进制字符串求和</h5><ul>
<li>如”111”+”101”&#x3D;”1100”</li>
<li>解决方案：<ul>
<li><ol>
<li>像十进制那样直接求和，进位，从最右边的字符开始，若相加大于1则进位，注意两个字符串可能一个很长一个很短，而进位可能一直需要延续</li>
</ol>
</li>
<li>2.将两个字符串分别转换为十进制再做运算，结果再转为二进制</li>
</ul>
</li>
</ul>
<h5 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h5><ul>
<li>暴力方法：将所有子串列出来先判断哪些是回文串，再取长度最长的；<h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5></li>
<li>我对正则表达式的处理方案一直很倾向于用状态机，这种方法可以用图表示出来，方案的完备性好判断，别人也好理解；</li>
<li>递归方案<h5 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h5></li>
<li>找出字符串数组中的最长公共前缀：给定一个字符串数组，找出他们的最长公共前缀</li>
<li>分析：这道题目需求不明确，是需要 所有的字符串&#x3D;都有的公共前缀还是若只有部分字符串有公共前缀也可以？也可能我理解有误~</li>
</ul>
<h5 id="实现strtod-函数"><a href="#实现strtod-函数" class="headerlink" title="实现strtod()函数"></a>实现strtod()函数</h5><ul>
<li>即判断一个字符串是否表示一个数字如:”1.0”</li>
<li>分析：可以用状态机实现</li>
</ul>
<h5 id="整数和罗马数字的相互转换"><a href="#整数和罗马数字的相互转换" class="headerlink" title="整数和罗马数字的相互转换"></a>整数和罗马数字的相互转换</h5><ul>
<li>这道题有些无聊<h5 id="count-and-say"><a href="#count-and-say" class="headerlink" title="count and say"></a>count and say</h5></li>
<li>一个数列如下：<br>1 11 21 1211 111221,…<br>意思是1,第二个表示第一个的情况，即1个1故为11,第三个数表示第二个数的情况，即两个1,21，以此类推  </li>
<li>求数列中的第n个数</li>
<li>解决方案，直接模拟，一个一个算出来</li>
</ul>
<h5 id="Anagrams"><a href="#Anagrams" class="headerlink" title="Anagrams:"></a>Anagrams:</h5><ul>
<li>字符串中的打乱字母顺序从而得到新的单词如eat打乱后得到tea等</li>
</ul>
<h5 id="给定绝对路径简化它"><a href="#给定绝对路径简化它" class="headerlink" title="给定绝对路径简化它"></a>给定绝对路径简化它</h5><h5 id="在一个英文句子中找到最后一个单词的长度"><a href="#在一个英文句子中找到最后一个单词的长度" class="headerlink" title="在一个英文句子中找到最后一个单词的长度"></a>在一个英文句子中找到最后一个单词的长度</h5>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_string</tag>
      </tags>
  </entry>
  <entry>
    <title>live_media_audio</title>
    <url>/2021/02/18/live-media-audio/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="音频科技发展史："><a href="#音频科技发展史：" class="headerlink" title="音频科技发展史："></a>音频科技发展史：</h3><h4 id="声音的本质："><a href="#声音的本质：" class="headerlink" title="声音的本质："></a>声音的本质：</h4><p>声音的本质是一种振动，可以说是一种一维的物理信号；可以通过敲击，让物体振动产生，并且可以使空气产生振动，从而传播，不过会能量衰减，导致只能传播一定的距离，原始振动<br>能量越大，传输的距离就越大；<span id="more"></span><br>声音作为这种波动类型的物理信号的特点和表示：振幅，频率，相位，波长，共振等等，这些不赘述，有兴趣再翻阅资料；</p>
<h4 id="音频的录制发展史："><a href="#音频的录制发展史：" class="headerlink" title="音频的录制发展史："></a>音频的录制发展史：</h4><p><em>豆瓣有篇文章说的还可以：<a href="https://www.douban.com/group/topic/28212958/">https://www.douban.com/group/topic/28212958/</a></em></p>
<ul>
<li>简单来说，声音的录制经历了一下的时代:<br>声音-&lt;-&gt;动能(机械)的时代： 即通过声波振记器，比如：可以将声波变换成金属针的震动，然后将波形刻录在圆筒形腊管的锡箔上。当针再一次沿着刻录的轨迹行进时，便可以重新发出留下的声音。<br>声音&lt;–&gt;电信号的时代：即：声音–&gt;振动–麦克风振动膜放大–&gt;线圈磁铁–&gt;电信号磁信号： 由磁带记录，播放；<br>声音&lt;–&gt;数字信号和处理时代：即声音–&gt;麦克风–&gt;电信号–&gt;模拟信号处理AD&#x2F;DA转换成数字信号：具体学习数字信号和模拟信号处理，了解示波器等器件；–&gt;101010的数字信号–&gt;<br>电脑接收和处理–&gt;数字信号转模拟信号AD&#x2F;DA –&gt;转为声音信号–&gt;扬声器  增加了立体声；<br>PS:<a href="https://zhuanlan.zhihu.com/p/64050348">https://zhuanlan.zhihu.com/p/64050348</a><br>ADC&#x3D;Analog Digital Change 模数转换<br>DAC&#x3D; Digital Analog Change 数模转换<h4 id="现代声音录制采集处理的基本过程："><a href="#现代声音录制采集处理的基本过程：" class="headerlink" title="现代声音录制采集处理的基本过程："></a>现代声音录制采集处理的基本过程：</h4>即上述的第三个时代，这里稍微详细解释：现代为了提高声音的质量，在采集上也有各种细分： 环境的保证，声音无损传递，放大，麦克风的设计和材料，声音芯片的设计和材料(语音芯片有多种，涉及<br>声音从模拟信号到数字信号的过程：AD&#x2F;DA转换), 采样也有相关定理：奈奎斯特采样定律；(模拟信号数字化必须经过三个过程，即抽样、量化和编码，以实现话音数字化的脉冲编码调制（PCM，Pulse Coding Modulation）技术。)，至此，完成声音的数字化过程，但是对声音的处理还远不止于此，采集到的声音可能有噪声，对噪声的处理，降噪技术等，采集到的声音的转换，混合，传输<br>识别，智能转文本等等。</li>
</ul>
<h3 id="音频的组成："><a href="#音频的组成：" class="headerlink" title="音频的组成："></a>音频的组成：</h3><h4 id="音频的表示和基本参数："><a href="#音频的表示和基本参数：" class="headerlink" title="音频的表示和基本参数："></a>音频的表示和基本参数：</h4><pre><code>      + 简单介绍PCM 声音如何从模拟信号转换为数字信号：  
</code></pre>
<img src="/2021/02/18/live-media-audio/pcmall.png" class="" title="This is an example image">
<pre><code>      + 采样：采样是将模拟信号以其带宽两倍以上的频率提取样值，变为在时间轴上离散数据的过程：
         采样率：每秒从连续信号中提取出并组成离散信号的采样个数：用Hz表示；  
         如：
    如音频信号采样率为8000hz。
    可以理解上图采样对应图中 那段电压随时间变化的曲线 为1秒 那下面那个1 2 3 …10那就因该有1-8000个点，即将1秒均分为8000份，依次取出来那8000个点时间 对应的电压值。
      + 量化：
         可以看到，在时间轴上连续的值已经变为离散的了，但是在电压上(y轴)上的值还是可能有无限多个值的情况，所以这个时候需要将电压上的值进行量化,举个例子：
         采样位数： 即描述数字信号所用的位数：如t1时间的电压值V1用8bit的数值表示： 3： 00000011 ，8bit最大可以表示数值为256,16位类似；
         量化精度，即将一个范围的值转换为另一个范围的值，两个值之间的间隔： 比如：将0-3.3V的范围电压值存储在8位的数字里即： 3.3/256=0.0128
         量化： 即比如将0-3.3V的电压值放到8位数字中：即 电压值1.65V对应的值就是128，以此类推；
         量化的后果：量化后的抽样信号与量化前的抽样信号相比较，当然有所失真，且不再是模拟信号。这种量化失真在接收端还原模拟信号时表现为噪声，并称为量化噪声。量化噪声的大小取决于把样值分级“取整”的方式，分的级数越多，即          量化级差或间隔越小，量化噪声也越小。

      + 编码：将量化后得到的类似十进制数字码流经过一定的规则转换为二进制码流进入数字系统的过程；  
         常见的有PCM音频编码：
         PCM协议：  
PCM（PCM-clock、PCM-sync、PCM-in、PCM-out）脉冲编码调制，模拟语音信号经过采样量化以及一定数据排列就是PCM了。理论上可以传   输单声道，双声道立体声和多声道。是数字音频的raw data.
         PCM信号：PCM信号未经过任何编码和压缩处理(无损压缩)。与模拟信号比，它不易受传送系统的杂波及失真的影响。动态范围宽，可得到音质相当好的效果。编码上采用A律13折线编码。
        关于双声道的采样：  
</code></pre>
<img src="/2021/02/18/live-media-audio/channel.png" class="" title="This is an example image">
<pre><code>        +  关于采样频率：
         人对频率的识别范围是 20HZ - 20000HZ, 如果每秒钟能对声音做 20000 个采样, 回放时就足可以满足人耳的需求.
            8000hz 为电话采样。
            22050 的采样频率是常用的。
            44100已是CD音质, 超过48000的采样对人耳已经没有意义
            对采样率为44.1kHz的AAC（Advanced Audio Coding）音频进行解码时，一帧的解码时间须控制在23.22毫秒内。通常是按1024个采样点一帧。
            而一个采样点，可以理解为就是一个8bit/16bit的音频值/hz
            PS： 音频其实没有帧的概念，音频是一连串的采样值，比如采样率为44.1kHZ，采样精度为16位的音频，你可以算出bitrate（比特率）是4410016kbps，每秒的音频数据是固定的4410016/8 字节。而一般是每次返回1024个采样值；
      + 什么样的采样和音频值位数叫无损呢？
</code></pre>
<h5 id="音频的采集和表示："><a href="#音频的采集和表示：" class="headerlink" title="音频的采集和表示："></a>音频的采集和表示：</h5><ul>
<li>pcm的格式的raw data数据；<br>    在linux下的采集<br>    1）采集白噪音，播放并导入到&#x2F;null  cat &#x2F;dev&#x2F;urandom | padsp tee &#x2F;dev&#x2F;audio &gt; &#x2F;dev&#x2F;null<br>    2）采集内存内容到播放audio,和&#x2F;null cat &#x2F;dev&#x2F;mem | padsp tee &#x2F;dev&#x2F;audio &gt; &#x2F;dev&#x2F;null<br>    3)  采集白噪音并播放和保存：cat &#x2F;dev&#x2F;urandom | padsp tee &#x2F;dev&#x2F;audio &gt; &#x2F;home&#x2F;some.raw<br>    注意这里是按默认的采样率，声道数，量化位数的；<br>    更多接口：音频的linux下的编程接口；<a href="https://docs.google.com/viewerng/viewer?url=https://www.programmer-books.com/wp-content/uploads/2019/06/Linux-Sound-Programming.pdf">https://docs.google.com/viewerng/viewer?url=https://www.programmer-books.com/wp-content/uploads/2019/06/Linux-Sound-Programming.pdf</a></li>
<li>音频原始数据：<br>音频原始数据实际是什么？实际就是这1s内，每个采集的音量大小值；所以说其实音频的数据值就是音量值；但是是粒度小到如44100&#x2F;s的，或者说是数值的幅度；  <br/><br>                  我们可以从时域和频域去分析一个声音；<br>                  这些细节不展开了；<br>一段原始数据展示：<br>  00 00 00 00 ff ff 00 00 00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00 00 00<br>  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff 00 00 00 00 00 00<br>  00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 ff ff 00 00 00 00 00 00 00 00<br>  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>  00 00 00 00 ff ff 00 00 …<br>  因为对单声道，音频数值位16位，采样44100来说，一秒就有44100*16bit&#x3D;88200B；</li>
<li>音频音量，pcm格式等表示；见上</li>
<li>音频编码情况：<br>WAV:pcm是无损wav文件中音频数据的一种编码方式，但wav还可以用其它方式编码<h5 id="音频的基本参数：采样率，音频值位数，比特率等；"><a href="#音频的基本参数：采样率，音频值位数，比特率等；" class="headerlink" title="音频的基本参数：采样率，音频值位数，比特率等；"></a>音频的基本参数：采样率，音频值位数，比特率等；</h5><h4 id="音频查看的相关工具：Audacity-可以导入原始格式进行播放和查看："><a href="#音频查看的相关工具：Audacity-可以导入原始格式进行播放和查看：" class="headerlink" title="音频查看的相关工具：Audacity 可以导入原始格式进行播放和查看："></a>音频查看的相关工具：Audacity 可以导入原始格式进行播放和查看：</h4>将wav或其他格式转换为pcm: eg:<br>ffmpeg -i file.wav -f s16be -ar 8000 -acodec pcm_s16be file.raw<br>PCM数据格式：即原始的音频采样数据：<br>比如：在得到file.raw后，用audacity播放，用文本编辑器打开，删除一半或一些数据，保存后再次用audacity播放，即可得到剩一半的数据；<br>WAV数据格式：PCM的基础上加上一些头，meta信息<br>其他工具：praat</li>
</ul>
<h4 id="认识音频原始数据"><a href="#认识音频原始数据" class="headerlink" title="认识音频原始数据"></a>认识音频原始数据</h4><h5 id="在windows-x2F-linux上采集pcm原始音频"><a href="#在windows-x2F-linux上采集pcm原始音频" class="headerlink" title="在windows&#x2F;linux上采集pcm原始音频"></a>在windows&#x2F;linux上采集pcm原始音频</h5><p>1） 列出设备：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">ffmpeg -list_devices true -f dshow -i dummy  </span><br><span class="line">在DirectShow audio devices下  </span><br><span class="line">eg: &quot;xxx&quot;(Realtek Audio)&quot; 中文时可能有乱码，这个时候可以选择可选的另一个名字：  </span><br><span class="line">eg: Alternative name &quot;@device_cm_&#123;33D9A762<span class="string">-90</span>C8<span class="string">-11</span>D0-BD43<span class="string">-00</span>A0C911CE86&#125;\wave_&#123;E41DED46<span class="string">-6012</span><span class="string">-4493</span><span class="string">-8</span>D55<span class="string">-7</span>D9322A433B6&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>2）通过展示出来的设备进行录制音频：  </p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">ffmpeg.exe -f dshow -t 20 -i audio=&quot;@device_cm_&#123;33D9A762<span class="string">-90</span>C8<span class="string">-11</span>D0-BD43<span class="string">-00</span>A0C911CE86&#125;\wave_&#123;E41DED46<span class="string">-6012</span><span class="string">-4493</span><span class="string">-8</span>D55<span class="string">-7</span>D9322A433B6&#125;&quot;  -f s16le -y D:\sijiruni3.pcm </span><br></pre></td></tr></table></figure>


<ol start="3">
<li>按格式播放采集的音频：  <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ffplay<span class="selector-class">.exe</span> -channels <span class="number">2</span> -f s16le -<span class="selector-tag">i</span> D:\sijiruni<span class="selector-class">.pcm</span></span><br><span class="line">将pcm转为wav:ffmpeg<span class="selector-class">.exe</span> -f s16le -ar <span class="number">44100</span> -ac <span class="number">2</span> -<span class="selector-tag">i</span> D:\audiotest\output_halfleft<span class="selector-class">.pcm</span> out_halfleft.wav</span><br></pre></td></tr></table></figure>
注意：若播放失败，尝试用大端&#x2F;小端都尝试下；</li>
</ol>
<h5 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">-f  s16le  : </span><br><span class="line">   f: format </span><br><span class="line">   s16  ： <span class="keyword">signed</span> <span class="number">16</span><span class="keyword">bit</span></span><br><span class="line">   u16: <span class="keyword">unsigned</span> <span class="number">16</span><span class="keyword">bit</span> </span><br><span class="line">   le : little <span class="keyword">end</span>  小端</span><br><span class="line">   be: big <span class="keyword">end</span> 大端</span><br></pre></td></tr></table></figure>
<p>更多格式：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -formats | grep PCM</span><br><span class="line"> DE alaw            PCM A-law</span><br><span class="line"> DE f32be           PCM <span class="number">32</span>-bit floating-point big-endian</span><br><span class="line"> DE f32le           PCM <span class="number">32</span>-bit floating-point little-endian</span><br><span class="line"> DE f64be           PCM <span class="number">64</span>-bit floating-point big-endian</span><br><span class="line"> DE f64le           PCM <span class="number">64</span>-bit floating-point little-endian</span><br><span class="line"> DE mulaw           PCM mu-law</span><br><span class="line"> DE s16be           PCM <span class="type">signed</span> <span class="number">16</span>-bit big-endian</span><br><span class="line"> DE s16le           PCM <span class="type">signed</span> <span class="number">16</span>-bit little-endian</span><br><span class="line"> DE s24be           PCM <span class="type">signed</span> <span class="number">24</span>-bit big-endian</span><br><span class="line"> DE s24le           PCM <span class="type">signed</span> <span class="number">24</span>-bit little-endian</span><br><span class="line"> DE s32be           PCM <span class="type">signed</span> <span class="number">32</span>-bit big-endian</span><br><span class="line"> DE s32le           PCM <span class="type">signed</span> <span class="number">32</span>-bit little-endian</span><br><span class="line"> DE s8              PCM <span class="type">signed</span> <span class="number">8</span>-bit</span><br><span class="line"> DE u16be           PCM <span class="type">unsigned</span> <span class="number">16</span>-bit big-endian</span><br><span class="line"> DE u16le           PCM <span class="type">unsigned</span> <span class="number">16</span>-bit little-endian</span><br><span class="line"> DE u24be           PCM <span class="type">unsigned</span> <span class="number">24</span>-bit big-endian</span><br><span class="line"> DE u24le           PCM <span class="type">unsigned</span> <span class="number">24</span>-bit little-endian</span><br><span class="line"> DE u32be           PCM <span class="type">unsigned</span> <span class="number">32</span>-bit big-endian</span><br><span class="line"> DE u32le           PCM <span class="type">unsigned</span> <span class="number">32</span>-bit little-endian</span><br><span class="line"> DE u8              PCM <span class="type">unsigned</span> <span class="number">8</span>-bit</span><br><span class="line"> https:<span class="comment">//trac.ffmpeg.org/wiki/audio%20types</span></span><br></pre></td></tr></table></figure>

<h5 id="音频采集常见参数解释："><a href="#音频采集常见参数解释：" class="headerlink" title="音频采集常见参数解释："></a>音频采集常见参数解释：</h5><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"> channel: 通道数，可以有多个通道支持，常见有，单声道和立体声(两个通道)</span><br><span class="line">rate： 采样率： 即每秒采样的点数，比如<span class="number">44100</span>hz,则每秒采集<span class="number">44100</span>个值，这个值大小代表振幅大小，即音频音量值</span><br><span class="line">位深： 即一个采样点用多大类型的值表示： 常见有<span class="number">8</span><span class="built_in">bit</span>,<span class="number">16</span><span class="built_in">bit</span>等，见上；</span><br><span class="line">frame: 在单声道：一个帧表示一个通道下的一个采样，而双通道，则一个帧包含两个采样点；所以帧率和sample rate采样率一样；</span><br><span class="line">           比如：单声道： <span class="number">44100</span>hz,则表示 ，每秒<span class="number">44100</span>个采样点，帧率为<span class="number">44100</span>/s,而 双通道下，<span class="number">44100</span>hz,由于一帧两个采样，所以帧率也是<span class="number">44100</span>；</span><br><span class="line">           注意这里的帧率和传输上的帧率不同；</span><br><span class="line">period <span class="built_in">time</span>: 毫秒单位，两个硬件中断的时间间隔，这个中断用来刷新缓存；</span><br><span class="line">period size: 硬件中断之间的帧数量；和以下相关：</span><br><span class="line">          period <span class="built_in">time</span> = period size * <span class="built_in">time</span>/frame  : 帧数*每帧占用的时间长度；</span><br><span class="line">                             = period size * number <span class="keyword">of</span> channels * <span class="built_in">time</span>/sample : 帧数* 每个采样占用的时长</span><br><span class="line">                            = period size * number <span class="keyword">of</span> channels / samplate rate : 帧数/采样率(帧率)</span><br><span class="line">            eg:  <span class="number">48000</span>hz 双通道，periodsize = <span class="number">8192</span>frames,则 period <span class="built_in">time</span> = <span class="number">8192</span>/<span class="number">48000</span>=<span class="number">170.5</span>ms</span><br><span class="line">periods: 每个<span class="keyword">buffer</span>的periods数量</span><br><span class="line"><span class="keyword">buffer</span> <span class="built_in">time</span>: 一个<span class="keyword">buffer</span>的时长</span><br><span class="line"><span class="keyword">buffer</span> size: 一个<span class="keyword">buffer</span>的帧数；</span><br><span class="line">    一个<span class="keyword">buffer</span>的时长= <span class="keyword">buffer</span> size * <span class="built_in">time</span>/frame ： 一个<span class="keyword">buffer</span>的帧数* 一个帧的时长</span><br><span class="line">                              = <span class="keyword">buffer</span> size * number <span class="keyword">of</span> channels * <span class="built_in">time</span>/sample : 一个<span class="keyword">buffer</span>帧数 * channel数* 一个采样点的时长</span><br><span class="line">                              = <span class="keyword">buffer</span> size * number <span class="keyword">of</span> channels / sample rate</span><br><span class="line"></span><br><span class="line">注意一个<span class="keyword">buffer</span>可能是多个periods;</span><br><span class="line">https://www.alsa-project.org/wiki/FramesPeriods  更多更详细解释</span><br></pre></td></tr></table></figure>


<h5 id="音频数据组织方式和解释："><a href="#音频数据组织方式和解释：" class="headerlink" title="音频数据组织方式和解释："></a>音频数据组织方式和解释：</h5><p>音频中的数据如何排放：<br>对单声道： 每个采样点一个数据，以16bit，44100hz为例，XXOO  OOXX …. ,1s有44100个值<br>对双声道： 每个采样点一个数据，PCM16LE双声道数据中左声道和右声道的采样值是间隔存储的.<br>注意： 对单声道来讲，也是两个耳机都能播放的，关键在于左右声道平衡的设置，如audacity<br>而当双声道下，一个声道的数据为0时，则会出现左&#x2F;右 只有一个有声音的情况；默认播放时 ；<br>所以我们可以将音频数据左右交替清除来达到空间的效果；  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">只有右耳能听到；</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">simplest_pcm16le_halfvolumeleft</span><span class="params">(<span class="type">char</span> *url)</span></span>&#123;</span><br><span class="line">	FILE *fp=<span class="built_in">fopen</span>(url,<span class="string">&quot;rb+&quot;</span>);</span><br><span class="line">	FILE *fp1=<span class="built_in">fopen</span>(<span class="string">&quot;output_halfleft.pcm&quot;</span>,<span class="string">&quot;wb+&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *sample=(<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">feof</span>(fp))&#123;</span><br><span class="line">		<span class="type">short</span> *samplenum=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">fread</span>(sample,<span class="number">1</span>,<span class="number">4</span>,fp);</span><br><span class="line"> </span><br><span class="line">		samplenum=(<span class="type">short</span> *)sample;</span><br><span class="line">		*samplenum=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//L</span></span><br><span class="line">		<span class="built_in">fwrite</span>(sample,<span class="number">1</span>,<span class="number">2</span>,fp1);</span><br><span class="line">		<span class="comment">//R</span></span><br><span class="line">		<span class="built_in">fwrite</span>(sample+<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,fp1);</span><br><span class="line"> </span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Sample Cnt:%d\n&quot;</span>,cnt);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">free</span>(sample);</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">	<span class="built_in">fclose</span>(fp1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//blog.csdn.net/leixiaohua1020/article/details/50534316</span></span><br></pre></td></tr></table></figure>

<h5 id="音频技术："><a href="#音频技术：" class="headerlink" title="音频技术："></a>音频技术：</h5><ul>
<li>混音  TODO</li>
<li>重采样 TODO</li>
</ul>
<h5 id="音频压缩："><a href="#音频压缩：" class="headerlink" title="音频压缩："></a>音频压缩：</h5><p>TODO</p>
<h5 id="alsa音频编程："><a href="#alsa音频编程：" class="headerlink" title="alsa音频编程："></a>alsa音频编程：</h5><p>ref linux-sound-programming.pdf<br>mark:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">对alsa编程编译运行成功，但是貌似录制不到声音，用了arecord也不行；</span><br><span class="line">sudo arecord -D <span class="string">&quot;hw:0,0&quot;</span> -f S16_LE -r <span class="number">16000</span> -c <span class="number">2</span> -d <span class="number">20</span> -t wav test2.wav</span><br><span class="line">./<span class="keyword">test</span> hw:<span class="number">0.0</span> <span class="keyword">file</span>.pcm</span><br><span class="line">也都不行，但是其实命令和设备都是对的；</span><br><span class="line">先不搞了，本来还想依赖它搞硬件的混音，这里不了，直接录制后，从pcm或其他级别来搞混音；</span><br></pre></td></tr></table></figure>

<h4 id="next"><a href="#next" class="headerlink" title="next:"></a>next:</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">关于编码方面：</span><br><span class="line">1）学习audacity和理解各个音频功能： 混音，音频重采样等</span><br><span class="line">2）学习音频相关协议： aac,wav,ogg,flac等；</span><br><span class="line">3)  学习如何编程处理，裸，或者用ffmpeg库；</span><br></pre></td></tr></table></figure>
<p>关于全流程：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">采集：音频的原始数据，音频三要素，channel, <span class="keyword">bitdepth,sampling </span>rate等；</span><br><span class="line">原始数据下处理： 重采样，混音，采集和播放；</span><br><span class="line">编码： aac,opus,flac等</span><br><span class="line">容器：</span><br><span class="line">传输：rtp，flv,rtmp....<span class="keyword">jitterbuffer抗抖动等；</span></span><br><span class="line"><span class="keyword"></span>处理：处理缺失晚到： 音频补帧，</span><br><span class="line">解码。去噪，消音等；</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>audio</category>
      </categories>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>live_media_audioformat</title>
    <url>/2021/02/18/live-media-audioformat/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="音频编码：-aac-adts-wav-mp3-等编码的意义和基本概念"><a href="#音频编码：-aac-adts-wav-mp3-等编码的意义和基本概念" class="headerlink" title="音频编码： aac, adts, wav ,mp3 等编码的意义和基本概念"></a>音频编码： aac, adts, wav ,mp3 等编码的意义和基本概念</h3><ul>
<li>原始音频： 采集后得到的是音频的裸数据：在采集时需要指定采样率，量化位数(一般采样也会有几种协议，比如常见的PCM，里面会自带量化位数指定)，channle数，以及必要的大小端数据等<span id="more"></span></li>
<li>音频的裸数据有以下特点，在用Audacity导入原始数据播放时，需要填写相关参数(采样率，量化协议，channel数，数据的大小端情况等)：<br>由此可以知道，在播放裸数据(解释)裸音频数据时，至少需要上面的几个参数；</li>
</ul>
<p>其实采集的数据和最原始的模拟信号数据也是有偏差的，在于采样频率，表示的位深都是有限的，无法完全还原，会有失真；</p>
<ul>
<li><p>为什么要音频编码：<br>原始音频往往比较大，不利于传输和存储，<br>所以为了更快更好的进行传输和存储等，一般会对原始音频进行压缩，<br>即编码；编码过程中往往会导致失真，即对编码后的数据进行解码不一定<br>能完全和编码前的数据一致，取决于<br>编码的算法，编码的方式；</p>
</li>
<li><p>常见的音频编码：AAC,OPUS,FLAC,MP3,SBC,Vorbis等，更多可以看wiki:<br><a href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83">https://zh.wikipedia.org/wiki/%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83</a><br>wav:Waveform Audio File Format：微软和IBM公司开发，未经压缩，音质相较于采集pcm未失真；体积较大<br>mp3：动态图像专家组-1或动态图像专家组-2 音频层III（英语：MPEG-1 or MPEG-2 Audio Layer III），一种流行的数字音频编码和有损压缩格式，<br>              与MP3相关的专利已于2017年4月16日全数过期。[6][7]MP3进入公有领域后，任何人使用皆无须付专利授权费。<br>              aac：高级音频编码（英语：Advanced Audio Coding，AAC） 为MPEG系列，有多个家族，是一种有损音频压缩的<br>              专利数字音频编码标准，由由Fraunhofer IIS、杜比实验室、贝尔实验室、Sony、Nokia等公司共同开发。<br>opus：Opus是一个有损音频压缩的数字音频编码格式，由Xiph.Org基金会开发，之后由互联网工程任务组（IETF）进行标准化，目标是希望用单一格式包含声音和语音，<br>              取代Speex和Vorbis，且适用于网络上低延迟的即时声音传输，标准格式定义于RFC 6716文件。Opus格式是一个开放格式，使用上没有任何专利或限制。<br>flac：Free Lossless Audio Codec：自由无损音频压缩编码。无专利限制<br>Vorbis：是一种有损音频压缩格式，由Xiph.Org基金会所领导并开放源代码的一个免费的开源软件项目。该项目为有损音频压缩产生音频编码格式和软件参考编码器╱解码器（编解码器）。Vorbis通常以Ogg作为容器格式，所以常合称为Ogg Vorbis。<br>               已被Opus替代</p>
</li>
<li><p>音频编码在音频裸数据的基础上做了什么？可以用来干嘛?<br>那么对于音频编码来说，主要是在裸数据上做了封装，带了以下几件事：<br>1）加上音频编码的头：主要内容是采样率，channel数，量化协议，大小端等，用来告诉解码器如何解释这个音频；</p>
</li>
</ul>
<ol start="2">
<li>加上其他的元数据：比如音频编码本身的协议标志，版本号，等等</li>
<li>带上裸数据，长度size等，有的音频编码会对裸数据进行合理的压缩，去噪等等，减少文件大小等，如opus；</li>
</ol>
<ul>
<li><p>如何查看音频编码：最直接的就是用notepad++ ,vim等二进制方式打开，然后对着协议标志看等；<br>或者根据文件名使用工具查看；用播放软件查看文件信息看编码格式；但是只能看元信息；</p>
</li>
<li><p>查看AAC:<br>查看文件的格式来判断：如.wav,.mp3,.aac,.ogg等<br>使用一些软件查看，如VLC,PotPlay等查看，或者专用的AAC如AAC Audio ES Viewer；<br>直接用vim&#x2F;nodepad++等编辑软件打开，查看文件开头的字符串，一般如opus会有相应的opus&#x2F;ogg字符串标识</p>
</li>
</ul>
<h3 id="音频编码文件容器："><a href="#音频编码文件容器：" class="headerlink" title="音频编码文件容器："></a>音频编码文件容器：</h3><ul>
<li><p>音频容器是什么？<br>音频编码后，主要是音频头(包含如何解码的信息，如采用率，channel数，位深等)和压缩后的原始数据；其本身没有帧的概念，容器将音频流式化，帧化了，使得音频文件成段或者说成流；<br>能使的播放器能更好的控制音频的播放，比如1s内播放更多的帧达到倍速播放等；所以说<br>如果说编码主要是压缩和携带解析的元数据，那容器的出现，除了增加更多元数据信息外，还加了时间戳dts等信息，封装为容器，同时也更有利于传输<br>另一个重要的因素是为了和视频封装在一起，音视频做同步解码播放；</p>
</li>
<li><p>音频为什么需要容器，和音频编码的区别：<br>上文提到了容器能为播放和传输赋能，这个是需要容器的重要原因；<br>容器和音频的关系：音频容器是在音频编码的基础上增加了一些信息，和编码格式不同，比如opus编码的容器格式是oggs，是在opus封装为一页一页，并且加了页头；<br>大部分容器其实可以封装视频和音频；比如Oggs也可以封装视频，只是现在不流行；所以你看到的Oggs基本都是音频的；而纯音频容器：如wav,mp3等</p>
</li>
<li><p>音视频容器常见: flv，avi,mov,mp4,3gp等</p>
<h3 id="音频编码流媒体-比如aac是怎么在直播系统中传输的；"><a href="#音频编码流媒体-比如aac是怎么在直播系统中传输的；" class="headerlink" title="音频编码流媒体: 比如aac是怎么在直播系统中传输的；"></a>音频编码流媒体: 比如aac是怎么在直播系统中传输的；</h3><p>流媒体是在网络传输中流式媒体数据，在网络中传输音视频数据时，也是主要是压缩的数据，比如音频，在网络上传输以opus的流格式，其实可以是oggs封装再加到其他传输协议中；<br>或者是Opus直接封装到完善的协议比如Rtp中；<br>而流媒体考虑到带宽利用率等，往往不会传输太多多余的东西，所以一些头带了的信息就不会重复封装头；<br>总的理解就是： 流媒体传输中，使用适合于音视频传输的(比如专门做了网络优化)的网络协议如Srt,Rtmp等，封装流媒体编码或容器进行传输；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>audio</category>
      </categories>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>live_media_overiew</title>
    <url>/2021/02/18/live-media-overiew/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="音视频基础知识：理论-实践"><a href="#音视频基础知识：理论-实践" class="headerlink" title="音视频基础知识：理论+实践"></a>音视频基础知识：理论+实践</h3><h4 id="音频的基本原理和组成"><a href="#音频的基本原理和组成" class="headerlink" title="音频的基本原理和组成"></a>音频的基本原理和组成</h4><ul>
<li>音频的表示和基本参数： Hz, 音量，pcm等以及基本编码；</li>
<li>音频查看的相关工具； <span id="more"></span></li>
</ul>
<h4 id="视频的基本原理和组成"><a href="#视频的基本原理和组成" class="headerlink" title="视频的基本原理和组成"></a>视频的基本原理和组成</h4><ul>
<li>图像基础知识：RGB,YUV </li>
<li>图像和视频：</li>
<li>关键帧和参考帧的概念：I,P,B</li>
<li>GOP的概念和应用；</li>
</ul>
<h4 id="音频文件和直播中的音频流"><a href="#音频文件和直播中的音频流" class="headerlink" title="音频文件和直播中的音频流"></a>音频文件和直播中的音频流</h4><ul>
<li>音频文件和直播中的音频流的基本区别和原理</li>
<li>音频编码格式和容器封装，以及相关格式和特点</li>
</ul>
<h4 id="视频文件和直播中的视频流"><a href="#视频文件和直播中的视频流" class="headerlink" title="视频文件和直播中的视频流"></a>视频文件和直播中的视频流</h4><ul>
<li>视频文件和直播中的视频的基本区别和原理</li>
<li>视频编码格式和容器封装，以及相关格式和特点；</li>
</ul>
<h3 id="音视频高级知识：-理论-实践"><a href="#音视频高级知识：-理论-实践" class="headerlink" title="音视频高级知识： 理论+实践"></a>音视频高级知识： 理论+实践</h3><h4 id="音频的编码技术："><a href="#音频的编码技术：" class="headerlink" title="音频的编码技术："></a>音频的编码技术：</h4><ul>
<li>AAC和ADTS</li>
<li>OPUS和OGG</li>
<li>其他</li>
</ul>
<h4 id="视频的编码技术："><a href="#视频的编码技术：" class="headerlink" title="视频的编码技术："></a>视频的编码技术：</h4><ul>
<li>H.264&#x2F;H.265和MPEG系列</li>
<li>VP8&#x2F;VP9 google</li>
<li>其他，MS的VC-1</li>
</ul>
<h4 id="实践：ffmpeg"><a href="#实践：ffmpeg" class="headerlink" title="实践：ffmpeg:"></a>实践：ffmpeg:</h4><ul>
<li>专注在ffmpeg的接口如何使用，并构建类似播放器这种例子；在遇到问题时查阅接口的源代码，这种学习方式；<br>在这种路子，可以学习各种ffmpeg支持的常用协议</li>
</ul>
<h3 id="直播技术栈全貌"><a href="#直播技术栈全貌" class="headerlink" title="直播技术栈全貌"></a>直播技术栈全貌</h3><h4 id="直播技术架构：客户端，服务端，网络CDN等等；"><a href="#直播技术架构：客户端，服务端，网络CDN等等；" class="headerlink" title="直播技术架构：客户端，服务端，网络CDN等等；"></a>直播技术架构：客户端，服务端，网络CDN等等；</h4><h3 id="服务器后台直播技术栈：构建基本的直播后台架构；"><a href="#服务器后台直播技术栈：构建基本的直播后台架构；" class="headerlink" title="服务器后台直播技术栈：构建基本的直播后台架构；"></a>服务器后台直播技术栈：构建基本的直播后台架构；</h3><h4 id="分布式系统的技术栈"><a href="#分布式系统的技术栈" class="headerlink" title="分布式系统的技术栈"></a>分布式系统的技术栈</h4><h4 id="所在公司的直播网系统；"><a href="#所在公司的直播网系统；" class="headerlink" title="所在公司的直播网系统；"></a>所在公司的直播网系统；</h4><h4 id="所在公司的分发网系统"><a href="#所在公司的分发网系统" class="headerlink" title="所在公司的分发网系统"></a>所在公司的分发网系统</h4><h4 id="所在公司的直播网，分发网，p2p和cdn的融合；"><a href="#所在公司的直播网，分发网，p2p和cdn的融合；" class="headerlink" title="所在公司的直播网，分发网，p2p和cdn的融合；"></a>所在公司的直播网，分发网，p2p和cdn的融合；</h4><h3 id="服务器后台直播技术栈高级：-优化"><a href="#服务器后台直播技术栈高级：-优化" class="headerlink" title="服务器后台直播技术栈高级： 优化"></a>服务器后台直播技术栈高级： 优化</h3><h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><h4 id="网络本身：路由等等；延迟和卡顿-jitterbuffer-重传和fec"><a href="#网络本身：路由等等；延迟和卡顿-jitterbuffer-重传和fec" class="headerlink" title="网络本身：路由等等；延迟和卡顿(jitterbuffer,重传和fec)"></a>网络本身：路由等等；延迟和卡顿(jitterbuffer,重传和fec)</h4><h4 id="直播后台性能：缓存，资源调度和流量管理"><a href="#直播后台性能：缓存，资源调度和流量管理" class="headerlink" title="直播后台性能：缓存，资源调度和流量管理"></a>直播后台性能：缓存，资源调度和流量管理</h4><h3 id="音视频编码技术："><a href="#音视频编码技术：" class="headerlink" title="音视频编码技术："></a>音视频编码技术：</h3><h4 id="基本编码原理"><a href="#基本编码原理" class="headerlink" title="基本编码原理"></a>基本编码原理</h4><h4 id="opencv等视觉"><a href="#opencv等视觉" class="headerlink" title="opencv等视觉"></a>opencv等视觉</h4><h4 id="ai"><a href="#ai" class="headerlink" title="ai"></a>ai</h4><h3 id="更多：TODO"><a href="#更多：TODO" class="headerlink" title="更多：TODO:"></a>更多：TODO:</h3>]]></content>
      <categories>
        <category>live_media</category>
      </categories>
      <tags>
        <tag>overiew</tag>
      </tags>
  </entry>
  <entry>
    <title>live_media_video</title>
    <url>/2021/02/18/live-media-video/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="图像科技发展史："><a href="#图像科技发展史：" class="headerlink" title="图像科技发展史："></a>图像科技发展史：</h3><h4 id="图像的本质："><a href="#图像的本质：" class="headerlink" title="图像的本质："></a>图像的本质：</h4><p>图像的本质可以说是反射光的集合，不同的物质分子组成等不同，那么光照射到物质上，有部分频率的光被吸收，剩下的反射出来，就形成不同的<span id="more"></span><br>颜色，反映了物质的基本特征；可以说每个像素点是一维值，就像声音的采样值；但图片还有大小位置，等信息；所以以一个方图为例，有图片的x轴<br>大小，y轴大小，甚至z轴空间信息，反映出来就是光影形成的三维效果；另外还有物体的位置；<br>而声音其实也有这些信息，声音的位置，不同物体的振动不同，在空气中振动的大小等；只是声音这些信息不能像图像一样能被人更好的利用；<br>或者说信息含量比较小；所以自然界中动物不止出现听觉还有视觉；<br>图像作为这种波动类型的物理信号的特点和表示：振幅，频率，相位，波长，共振等等，这些不赘述，有兴趣再翻阅资料；</p>
<h4 id="图像的记录发展史："><a href="#图像的记录发展史：" class="headerlink" title="图像的记录发展史："></a>图像的记录发展史：</h4><pre><code>       图像最开始只能通过绘画记录下来，直到后来，人们发现了透镜成像原理和感光物质显像原理，即时记录图像的工具-相机才慢慢被开发出来；
</code></pre>
<ul>
<li>简单来说，图像的记录经历了一下的时代:<br>图像-&lt;-&gt;湿版摄影法： 即通过成像后，一些感光的化学物质记录，形成图像<br>图像&lt;–&gt; 胶卷相机时代：即：图像反射光-&gt;小孔成像-&gt;感光物质曝光底片-&gt;冲洗照片<br>图像&lt;–&gt;数字信号和处理时代：即图像反射光–&gt;光敏电阻(单色)–&gt;电信号–&gt;模数转换–&gt;101010的数字信号–&gt;  像素值-&gt;计算机处理–&gt;屏幕呈现<br>PS:<a href="https://zhuanlan.zhihu.com/p/161200077">https://zhuanlan.zhihu.com/p/161200077</a></li>
</ul>
<h4 id="图像基本入门："><a href="#图像基本入门：" class="headerlink" title="图像基本入门："></a>图像基本入门：</h4><img src="/2021/02/18/live-media-video/basic.png" class="" title="This is an example image">
<p>图像由像素点构成，简称像素(Pixel:picture Element）：像素是图像显示的基本单位，通常说一幅图片的大小，例如是1920*1080，即长度为1920个像素点，宽度为1080个像素点，乘积为2,073,600，即这个图片是两百万像素的，拍照中常说的也是这个；<br>PPI: 分辨率也是显示器的重要指标，而PPI是Pixels Per Inch，即每英寸像素；即手机或显示器屏幕上每英寸面积可以放多少个像素点；苹果的PPI值高达326</p>
<img src="/2021/02/18/live-media-video/pixel.png" class="" title="This is an example image">
<p>像素堆积成图片，所以像素本身需要颜色；如上那副图；每个像素点用一个数字来代表颜色，人眼的视锥细胞有三种分别过滤红蓝绿，其他颜色按照比例刺激；所以任何一种颜色可以通过R(红色), G(绿色),B(蓝色)按照一定的比例调配出来；这三种颜色被称为三原色；<br>而比例：是R,G,B的取值，分别从0-255，即8bit表示，所以一个像素点用3<em>8bit 即3个字节表示；而可以代表的颜色在256</em>256<em>256种；任何颜色，都可以用这三个值的组合表示；现在可以用画图试试；我们常说的RGB24就是3</em>8bit的形式；而一个颜色的16进制即是RGB的16进制即如：R:01,G:02,B:03–&gt; 010203</p>
<h4 id="原始图像和原始视频的文件表示和格式："><a href="#原始图像和原始视频的文件表示和格式：" class="headerlink" title="原始图像和原始视频的文件表示和格式："></a>原始图像和原始视频的文件表示和格式：</h4><ul>
<li>原始图像和原始视频：<br> 一个原始的图片是RGB或YUV格式的，即每个像素点都由8*3 24bit&#x2F;yuv的数据格式，决定即：Red Green Blue<br>一个原始的视频也是没经过编码压缩的，每一帧都是完整的图像；</li>
<li>RGB YUV 表示和打开，修改等：<br><a href="https://blog.csdn.net/leixiaohua1020/article/details/50534150">https://blog.csdn.net/leixiaohua1020/article/details/50534150</a><br>另外还有 ffmpeg对图片格式的转换，也能转换为rgb,yuv;<br>RGB和OpenCV,可以直接采集后用opencv调试；<br>RGB： 即每个像素由三个通道值组成R G B,都是8bit;<br>YUV:<br>人们常用RGB表示三基色，而且RGB也可以表示出所有颜色。但视觉心理学研究表明，人眼主要是对光的感知，人的视觉系统对光的感知程度用亮度（luminance）和色度（chrominance）两个属性表示，也就是我们常说的YUV。Y就是亮度感知，而色度感知分为两个属性：色相（hue）和色饱和度（saturation）。色相也就是U,是由光波的峰值定义的，描述的是光的颜色；色饱和度V是光波的谱宽定义的，描述的是光的纯度。 采用YUV色度空间比采用RGB颜色空间更利于视频的压缩，也能更有效的表示彩色视频图像<br><a href="https://www.jianshu.com/p/6a361e86ccd5">https://www.jianshu.com/p/6a361e86ccd5</a><br>实践：<br>1） 先通过ffmpeg 将jpg或其他通用图片格式转换为 yuv或rgb ffmpeg -i 1.jpg -vcodec rawvideo -pix_fmt rgba raw1.rgb</li>
</ul>
<ol start="2">
<li>通过程序如<a href="https://blog.csdn.net/leixiaohua1020/article/details/50534150">https://blog.csdn.net/leixiaohua1020/article/details/50534150</a> 或opencv来处理图像；<br>3） 用相关工具打开：<a href="https://github.com/leixiaohua1020/YUVplayer/blob/master/Release/yuvplayer.exe">https://github.com/leixiaohua1020/YUVplayer/blob/master/Release/yuvplayer.exe</a><br>验证；</li>
</ol>
<ul>
<li>图像基本编码：<br>从RGB–&gt;YUV–&gt;JPEG&#x2F;BMP&#x2F;JPG&#x2F;…</li>
<li>视频基本编码：<img src="/2021/02/18/live-media-video/video.png" class="" title="This is an example image">
从yuv-&gt;h264</li>
<li>I,P,B帧和GOP的基本概念：其中I帧也叫关键帧，是一副完整的画面，而P帧则是记录I帧的变化（H.264中通过补偿算法根据I帧得到的差异文件），B帧类似。<br> I 帧：一个可以独立解码的帧，size大<br> P 帧：依赖前面的帧来解码，size小<br> B 帧：依赖前后的帧来解码，size小<br> GOP: 两个I帧之间的间隔，GOP &#x3D; I(帧内编码帧) + B（双向预测帧） + P（前向预测帧）<br>其中I帧也叫关键帧，是一副完整的画面，而P帧则是记录I帧的变化（H.264中通过补偿算法根据I帧得到的差异文件），B帧类似。再简单点说，如果没有I帧，P帧和B帧也无法解码。这也很好理解，没有原始对比文件，只有差异文件是无法渲染画面的。<br>GOP结构一般两个数字，如M&#x3D;1，N&#x3D;2。M指定I帧和P帧之间的距离，N指定两个I帧之间的距离，其他都是B帧填充。如M&#x3D;1，N&#x3D;2这里的例子是IDR PB I排序。<br>有些地方会讲IDR帧，其实就是GOP的第一个I帧，这个帧很重要，因为关于首开优化基本上都在去尽可能减小IDR帧的大小</li>
<li>视频的几个参数和影响：<br>帧率：即每秒有多少帧，帧率越大，说明每秒帧数越多，即视频越流畅；若是假设一段10s的视频总帧数在200，则原本帧率为20fps,增大帧率<br>    到40fps会导致只需要5s就能放完，即加速了x2; 所以视频加速播放和慢速播放就是控制帧率的大小；<br>dts：DTS：Decode Time Stamp。DTS主要是标识读入内存中的bit流在什么时候开始送入解码器中进行解码。<br>DTS主要用于视频的解码,在解码阶段使用,每帧都有一个dts值，一般是个数值，一般视频帧之间差30，音频帧之间差20<br>pts:PTS主要用于视频的同步和输出.在display的时候使用.在没有B frame的情况下.DTS和PTS的输出顺序是一样的.<br>音视频同步的概念： 一般在看视频画面时，音频也要跟上嘴型和情节，所以音画同步需要借助dts&#x2F;pts; 线性传递时，一般是一个音频帧一个视频帧；<br>       而音频帧和视频帧的dts也是有序的，如：a1:123 v1: 134 a2: 145 v2: 155</li>
</ul>
]]></content>
      <categories>
        <category>video</category>
      </categories>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>procsysfs</title>
    <url>/2021/02/26/procsysfs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="linux-用户空间与内核的接口—内核信息的输出和修改"><a href="#linux-用户空间与内核的接口—内核信息的输出和修改" class="headerlink" title="linux 用户空间与内核的接口—内核信息的输出和修改"></a>linux 用户空间与内核的接口—内核信息的输出和修改</h3><ul>
<li><p>linux用户与内核的接口有多种,配置内核的netlink,ioctl,等特殊系统调用，其他系统调用;用户空间指令:ifconfig,route,<br>iptable等;以及内核输出信息的procfs,sysfs和修改内核参数的sysctl接口;这里介绍最后一种;<span id="more"></span></p>
</li>
<li><p>用户空间程序常常需要知道内核一些当前状态信息，且有时为了系统的稳定性和性能等，需要改变一些内核参数信息；<br>linux提供了这样的机制，用来读取内核输出信息的内存文件系统和修改的系统调用；<br>除了常规的系统调用外，还提供了sysctl系统调用和（&#x2F;proc(procfs虚拟文件系统), &#x2F;sys(sysfs虚拟文件系统）</p>
</li>
</ul>
<h3 id="procfs介绍"><a href="#procfs介绍" class="headerlink" title="procfs介绍"></a>procfs介绍</h3><ul>
<li><p>介绍：<br>  procfs:是挂载在&#x2F;proc的虚拟文件系统，允许内核以文件的形式向用户输出内部信息；这些信息存于内存中，可以通过cat或more及&gt;重定向输出输入<br>  它不能被编译为一个模块，配置菜单中相关内核选项为：“Filesystems-&gt;pseudo filesystems-&gt;&#x2F;proc file system support”  </p>
<p>  procfs目前分为&#x2F;proc&#x2F;sys和&#x2F;proc&#x2F;其他的，前者可以通过sysctl系统调用来进行写，从而改变内核的一些参数和配置，后者只读；  </p>
<p>  如果是只读的，且是涉及更为复杂的数据结构而且需要特殊格式等如缓存和统计数据,则考虑用proc&#x2F;非sys的，否则若只是简单变量，则应该使用&#x2F;proc&#x2F;sys  </p>
</li>
<li><p>实践：<br> 1）用户空间使用： 用户可以通过cat &#x2F;proc&#x2F;…   ls &#x2F;proc等方式来进行读取&#x2F;procfs的值；对于&#x2F;proc&#x2F;sys的，有单独的说明见下；  </p>
<ol start="2">
<li>解释：关于&#x2F;proc&#x2F;下的各个文件目录的含义，可以查看man <a href="https://man7.org/linux/man-pages/man5/procfs.5.html">https://man7.org/linux/man-pages/man5/procfs.5.html</a>  对网络代码注册的文件，一般位于&#x2F;proc&#x2F;net目录下，在该目录下存在不少文件，有一种比较特殊的文件，如tcp,udp有固定的格式，就像数据库的记录一样，称为综合文件(synthetic files).所以说proc文件系统适用于它，提供了对此类文件框架的支持：</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cat  /proc/net/udp:</span><br><span class="line">   sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode ref pointer drops             </span><br><span class="line">   <span class="number">6591</span>: <span class="number">00000000</span>:<span class="number">0044</span> <span class="number">00000000</span>:<span class="number">0000</span> <span class="number">07</span> <span class="number">00000000</span>:<span class="number">00000000</span> <span class="number">00</span>:<span class="number">00000000</span> <span class="number">00000000</span>     <span class="number">0</span>        <span class="number">0</span> <span class="number">14983</span> <span class="number">2</span> <span class="number">0000000000000000</span> <span class="number">0</span>         </span><br><span class="line">   <span class="number">6646</span>: <span class="number">26B</span>4450A:<span class="number">007B</span> <span class="number">00000000</span>:<span class="number">0000</span> <span class="number">07</span> <span class="number">00000000</span>:<span class="number">00000000</span> <span class="number">00</span>:<span class="number">00000000</span> <span class="number">00000000</span>     <span class="number">0</span>        <span class="number">0</span> <span class="number">28063</span> <span class="number">2</span> <span class="number">0000000000000000</span> <span class="number">0</span>         </span><br><span class="line">   <span class="number">6646</span>: <span class="number">0100007F</span>:<span class="number">007B</span> <span class="number">00000000</span>:<span class="number">0000</span> <span class="number">07</span> <span class="number">00000000</span>:<span class="number">00000000</span> <span class="number">00</span>:<span class="number">00000000</span> <span class="number">00000000</span>     <span class="number">0</span>        <span class="number">0</span> <span class="number">28061</span> <span class="number">2</span> <span class="number">0000000000000000</span> <span class="number">0</span>         </span><br><span class="line">   <span class="number">6646</span>: <span class="number">00000000</span>:<span class="number">007B</span> <span class="number">00000000</span>:<span class="number">0000</span> <span class="number">07</span> <span class="number">00000000</span>:<span class="number">00000000</span> <span class="number">00</span>:<span class="number">00000000</span> <span class="number">00000000</span>     <span class="number">0</span>        <span class="number">0</span> <span class="number">28057</span> <span class="number">2</span> <span class="number">0000000000000000</span> <span class="number">0</span>         </span><br><span class="line">   <span class="number">6660</span>: FFFF12AC:<span class="number">0089</span> <span class="number">00000000</span>:<span class="number">0000</span> <span class="number">07</span> <span class="number">00000000</span>:<span class="number">00000000</span> <span class="number">00</span>:<span class="number">00000000</span> <span class="number">00000000</span>     <span class="number">0</span>        <span class="number">0</span> <span class="number">72326708</span> <span class="number">2</span> <span class="number">0000000000000000</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>内核中如何添加&#x2F;proc&#x2F;目录等信息：<br>eg: 大多数网络功能在初始化时，都会在&#x2F;proc&#x2F;net中注册一个或多个文件，无论初始化动作发生在系统启动时还是模块加载时。当用户读取某个文件时，内核会调用一组内核函数来输出相应信息：<br>代码中如何创建：<br>  proc_mkdir:创建&#x2F;proc中的目录<br>  create_proc_entry&#x2F;remove_proc_entry:创建和除名文件<br>  可以用包裹函数如：<br>  proc_net_fops_create&#x2F;proc_net_remove:&#x2F;proc&#x2F;net&#x2F;中文件的注册和除名<br>  现在的版本和之前的版本不同，一些接口比如底层的create_proc_entry已经没有了，所以现在一些书本的例子不能用，需要参考内核代码，等看到时，再总结出例子来更新文章</li>
</ol>
<h3 id="sysctl和-x2F-proc-x2F-sys"><a href="#sysctl和-x2F-proc-x2F-sys" class="headerlink" title="sysctl和 &#x2F;proc&#x2F;sys"></a>sysctl和 &#x2F;proc&#x2F;sys</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>sysctl:这个接口允许用户空间读取或修改内核变量的值；不能用此接口对每个内核变量进行操作，内核应明确指出哪些变量从此接口是可见的；<br>从用户空间，你可以用两种方式访问sysctl输出的变量：一种是系统调用sysctl(man sysctl),一种则是依赖procfs(因为内核会在&#x2F;proc中添加一个特殊目录&#x2F;proc&#x2F;sys,为每个sysctl所输出的内核变量引入一个文件</li>
<li>内核配置选项：General setup-&gt;sysctl support</li>
<li>sysctl的信息大多可写，但是只有超级用户可写，一个简单内核变量或数据结构相关的一些文件</li>
</ul>
<h4 id="命令行工具sysctl和运维"><a href="#命令行工具sysctl和运维" class="headerlink" title="命令行工具sysctl和运维"></a>命令行工具sysctl和运维</h4><p>有时候需要查内核相关参数，并做调整来改变内核行为，以支持更多功能或者恢复手段等；这个时候可以使用sysctl指令：  </p>
<ul>
<li><p>展示：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ sysctl -a 展示所有的sysctl参数</span><br><span class="line">$ sysctl vm.swapiness 展示这个的值，会打印：</span><br><span class="line">vm.swappiness = <span class="number">60</span></span><br><span class="line">sysctl命令实际上就是读取<span class="regexp">/proc/</span>sys目录下的内容；它是一个虚拟目录，只包含当前内核参数值</span><br><span class="line">sysctl vm.swapiness 和 cat <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>swapiness 是一样的效果</span><br></pre></td></tr></table></figure>

</li>
<li><p>修改：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ sysctl -w paramter=value  临时改变参数值，重启会恢复默认值</span><br><span class="line">eg： sysctl -w net.ipv4.ip_forward=<span class="number">1</span></span><br><span class="line">如果值包括空格或特殊字符，请用双引号括起来；</span><br><span class="line">如果想要重启后也用这个值，可以：</span><br><span class="line"><span class="variable">$sysctl</span> -w net.ipv4.ip_forward=<span class="number">1</span> &gt;&gt; <span class="regexp">/etc/</span>sysctl.conf</span><br><span class="line">其他临时写的方式：</span><br><span class="line">$ echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/net/i</span>pv4/ip_forward</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载值：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ sysctl -p <span class="regexp">/etc/</span>sysctl.d/file_name.conf</span><br><span class="line">当没有指定文件名：使用<span class="regexp">/etc/</span>sysctl.conf文件；</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="用户程序如何系统调用sysctl"><a href="#用户程序如何系统调用sysctl" class="headerlink" title="用户程序如何系统调用sysctl:"></a>用户程序如何系统调用sysctl:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//man7.org/linux/man-pages/man2/sysctl.2.html</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sysctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _sysctl(<span class="keyword">struct</span> __sysctl_args *args );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSNAMESZ 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__sysctl_args</span> args;</span><br><span class="line">    <span class="type">char</span> osname[OSNAMESZ];</span><br><span class="line">    <span class="type">size_t</span> osnamelth;</span><br><span class="line">    <span class="type">int</span> name[] = &#123; CTL_KERN, KERN_OSTYPE &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __sysctl_args));</span><br><span class="line">    args.name = name;</span><br><span class="line">    args.nlen = <span class="built_in">sizeof</span>(name)/<span class="built_in">sizeof</span>(name[<span class="number">0</span>]);</span><br><span class="line">    args.oldval = osname;</span><br><span class="line">    args.oldlenp = &amp;osnamelth;</span><br><span class="line"></span><br><span class="line">   osnamelth = <span class="built_in">sizeof</span>(osname);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">syscall</span>(SYS__sysctl, &amp;args) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;_sysctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This machine is running %*s\n&quot;</span>, osnamelth, osname);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内核中如何添加-x2F-proc-x2F-sys下的目录和文件"><a href="#内核中如何添加-x2F-proc-x2F-sys下的目录和文件" class="headerlink" title="内核中如何添加&#x2F;proc&#x2F;sys下的目录和文件"></a>内核中如何添加&#x2F;proc&#x2F;sys下的目录和文件</h4><p>（代码中如何呈现：<br>   用户在&#x2F;proc&#x2F;sys下看到的一个文件，实际上是一个内核变量；就每个变量而言，内核可以定义：<br>   A:要将其放在&#x2F;proc&#x2F;sys的何处，与相同内核组件或功能相关联的变量，，通常位于一个目录中，如&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4<br>   B:命名：一般文件名和相关联的变量名相同<br>   C:权限：一般所有可读，超级可写<br>）</p>
<ul>
<li><p>简单例子1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sysctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_hello_data = <span class="number">1024</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_callback</span><span class="params">(<span class="keyword">struct</span> ctl_table *table, <span class="type">int</span> write,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span> __user *buffer, <span class="type">size_t</span> *lenp, <span class="type">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="type">int</span> *data = table-&gt;data;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;original value = %d\n&quot;</span>, *data);</span><br><span class="line"> </span><br><span class="line">    rc = <span class="built_in">proc_dointvec</span>(table, write, buffer, lenp, ppos);</span><br><span class="line">    <span class="keyword">if</span> (write)</span><br><span class="line">        <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;this is write operation, current value = %d\n&quot;</span>, *</span><br><span class="line">data);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ctl_table</span> hello_ctl_table[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .procname       = <span class="string">&quot;helloctl&quot;</span>,</span><br><span class="line">        .data           = &amp;sysctl_hello_data,</span><br><span class="line">        .maxlen         = <span class="built_in">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">        .mode           = <span class="number">0644</span>,</span><br><span class="line">        .proc_handler   = hello_callback,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* sentinel */</span> <span class="comment">//哨兵的作用，见数据结构</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ctl_table_header</span> *sysctl_header;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">sysctl_example_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sysctl_header = <span class="built_in">register_sysctl_table</span>(hello_ctl_table);</span><br><span class="line">    <span class="keyword">if</span> (sysctl_header == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;ERR: register_sysctl_table!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;sysctl register success.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">sysctl_example_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unregister_sysctl_table</span>(sysctl_header);</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;sysctl unregister success.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module_init</span>(sysctl_example_init);</span><br><span class="line"><span class="built_in">module_exit</span>(sysctl_example_exit);</span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">  * Author: ksx</span></span><br><span class="line"><span class="comment">  * File name: sysctl_example.c</span></span><br><span class="line"><span class="comment">  * Description: sysctl example</span></span><br><span class="line"><span class="comment">  * Date: 2021-02-26</span></span><br><span class="line"><span class="comment">  *********************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sysctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> min_virdev_frags = <span class="number">3</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> max_virdev_frags = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> virdev_sum1=<span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> virdev_array[<span class="number">4</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_max_virdev_frags=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">set_default_something</span><span class="params">(<span class="keyword">struct</span> ctl_table *table, <span class="type">int</span> write,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span> __user *buffer, <span class="type">size_t</span> *lenp, <span class="type">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;set default something value =\n&quot;</span>);</span><br><span class="line">      <span class="comment">//you can do other ，可以自己实现类似proc_dointvec功能的函数，其实就是赋值；参考sysctl_net_core.c</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ctl_table</span> virdev_table1[] = &#123;</span><br><span class="line">    &#123; </span><br><span class="line">      .procname     = <span class="string">&quot;virdev_sum1&quot;</span>,</span><br><span class="line">      .data         = &amp;virdev_sum1,</span><br><span class="line">      .maxlen       = <span class="built_in">sizeof</span>(virdev_sum1),</span><br><span class="line">      .mode         = <span class="number">0644</span>,</span><br><span class="line">      .proc_handler = &amp;proc_dointvec </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">		.procname	= <span class="string">&quot;max_virdev_frags&quot;</span>,</span><br><span class="line">		.data		= &amp;sysctl_max_virdev_frags,</span><br><span class="line">		.maxlen		= <span class="built_in">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		.proc_handler	= proc_dointvec_minmax, <span class="comment">//若设置的值不在extra1-extra2之间，则设置失败</span></span><br><span class="line">		.extra1		= &amp;min_virdev_frags,</span><br><span class="line">		.extra2		= &amp;max_virdev_frags,</span><br><span class="line">	&#125;,</span><br><span class="line">    <span class="comment">//只是回调来设置到某个值中或者做其他事，不需要data,但回调函数也必须符合格式</span></span><br><span class="line">    &#123;</span><br><span class="line">		.procname	= <span class="string">&quot;default_something&quot;</span>,</span><br><span class="line">		.mode		= <span class="number">0644</span>,</span><br><span class="line">		.maxlen		= <span class="number">16</span>,</span><br><span class="line">		.proc_handler	= set_default_something</span><br><span class="line">	&#125;,    </span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ctl_table</span> virdev_table2[] = &#123;</span><br><span class="line">    &#123; </span><br><span class="line">      .procname     = <span class="string">&quot;virdev_array&quot;</span>,</span><br><span class="line">      .data         = &amp;virdev_array,</span><br><span class="line">      .maxlen       = <span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="comment">//是指data的大小，而data其实是void *,不管怎样其实就是指针大小</span></span><br><span class="line">      .mode         = <span class="number">0644</span>,</span><br><span class="line">      .proc_handler = &amp;proc_dostring   <span class="comment">//会将接收到的用户传入的buff数据，解析并，写到data中，具体见实际例子；</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ctl_table</span> virdev_dir_table[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .procname = <span class="string">&quot;virsub1&quot;</span>,</span><br><span class="line">        .mode     = <span class="number">0555</span>,</span><br><span class="line">        .child    = virdev_table1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .procname = <span class="string">&quot;virsub2&quot;</span>,</span><br><span class="line">        .mode     = <span class="number">0555</span>,</span><br><span class="line">        .child    = virdev_table2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ctl_table</span> virdev_root_table[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .procname       = <span class="string">&quot;virdev&quot;</span>,</span><br><span class="line">        .mode           = <span class="number">0555</span>,</span><br><span class="line">        .child          = virdev_dir_table</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* sentinel */</span></span><br><span class="line">    &#125;, <span class="comment">//多出的一个应该是哨兵的作用，参考数据结构设计</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ctl_table_header</span> *sysctl_header;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">sysctl_example_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sysctl_header = <span class="built_in">register_sysctl_table</span>(virdev_root_table);</span><br><span class="line">    <span class="keyword">if</span> (sysctl_header == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;ERR: register_sysctl_table!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;sysctl register success.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">sysctl_example_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unregister_sysctl_table</span>(sysctl_header);</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;sysctl unregister success.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module_init</span>(sysctl_example_init);</span><br><span class="line"><span class="built_in">module_exit</span>(sysctl_example_exit);</span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>接口解释：</p>
</li>
</ul>
<ol>
<li>结构体ctl_table<br>每一个sysctl条目对应一个 struct ctl_table 结构，在该结构体定义在文件&#x2F;include&#x2F;linux&#x2F;sysctl.h中，定义及解释如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ctl_table</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *procname; <span class="comment">/* Text ID for /proc/sys, or zero */</span> <span class="comment">/* 表示在proc/sys/下显示的文件名称 */</span></span><br><span class="line">    <span class="type">void</span> *data; <span class="comment">/* 表示对应于内核中的变量名称    */</span> <span class="comment">//是一个指针，如上，可以是int,数组等</span></span><br><span class="line">    <span class="type">int</span> maxlen;<span class="comment">//  /* 表示条目允许的最大长度         */</span></span><br><span class="line">    <span class="type">mode_t</span> mode;<span class="comment">/* 条目在proc文件系统下的访问权限 */</span><span class="comment">//见 stat.h</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ctl_table</span> *child; <span class="comment">//子目录的结构，见上面的例子，但内核代码注释不建议这样用，甚至弃用；</span></span><br><span class="line">    proc_handler *proc_handler; <span class="comment">/* Callback for text         formatting */</span><span class="comment">//当sysctl或echo等方式写时，触发这个回调函数将值写到注册的ctl_table中</span></span><br><span class="line">    <span class="type">void</span> *extra1;<span class="comment">//proc_dointvec_minmax等有范围的限定用，下限</span></span><br><span class="line">    <span class="type">void</span> *extra2;<span class="comment">//上限</span></span><br><span class="line">&#125;</span><br><span class="line">maxlen: 它主要用于字符串内核变量，以便在对该条目设置时，对超过该最大长度的字符串截掉后面超长的部分.</span><br></pre></td></tr></table></figure></li>
<li>注册和卸载：<br>注册register_sysctl_table<br>注册sysctl条目使用函数register_sysctl_table，函数原型如下：<br>struct ctl_table_header *register_sysctl_table(struct ctl_table *table)<br>第一个参数为定义的struct ctl_table结构的sysctl条目或条目数组指针；</li>
</ol>
<p>卸载unregister_sysctl_table<br>当模块卸载时，需要使用函数unregister_sysctl_table，其原型：<br>void unregister_sysctl_table(struct ctl_table_header * header)<br>其中struct ctl_table_header是通过函数register_sysctl_table<br>注册时返回的结构体指针。</p>
<ol start="3">
<li>关于信息和参考，如linux版本更新后，接口变化：<br>内核源码例子：&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core的添加<br>socket.c :sock_init<br>net&#x2F;core&#x2F;sysctl_net_core.c<br>源码：<br>proc_dointvec_minmax系列函数定义：kernel&#x2F;sysctl.c sysctl.h<br>也可以参考：其中的说明<br><a href="http://www.embeddedlinux.org.cn/linux_net/0596002556/understandlni-CHP-3-SECT-2.html">http://www.embeddedlinux.org.cn/linux_net/0596002556/understandlni-CHP-3-SECT-2.html</a></li>
</ol>
<h3 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h3><p> sysfs:是挂载在&#x2F;sys下的虚拟文件系统：它不仅可以把设备和驱动程序的信息从内核空间导到用户空间，也可以对设备和驱动进行配置；<br>目的是将一些原本在procfs中的设备独立出来，以设备树的形式呈现给用户；最初，sysfs名driverfs; 而后来对其他子系统也有用所以就更名；<br>sysfs在用户空间使用和procfs类似，对内核中的实现和使用，和设备模型相关，等总结完设备模型后，再总结；</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux_procsysfs</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_IP</title>
    <url>/2018/06/03/tcpip-IP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="IP-协议和路由"><a href="#IP-协议和路由" class="headerlink" title="IP 协议和路由"></a>IP 协议和路由</h3><h4 id="IP的作用–路由"><a href="#IP的作用–路由" class="headerlink" title="IP的作用–路由"></a>IP的作用–路由</h4><h5 id="路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作"><a href="#路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作" class="headerlink" title="路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?"></a>路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?</h5><ol>
<li><p>从广义上讲，路由是路线图，就像百度地图上源地址到目的地址的路线，路线有很多，故路由也很多；  <span id="more"></span><br>   从网络层面讲，路由是一个数据包从源地址到目的地的传输路径，它如何被决定怎么走，即中间经过哪些路由器，选择哪一条路线等等。</p>
</li>
<li><p>一个数据包在网络上传输实例：<br> A,B连上AP进行上网，AP和外网连接，AP的下一站是D;<br> A 在构造了数据包后选择发送，要查询路由表，若该数据包发送给B,则通过路由表中的直连路由，找到B的ip,发送时不知道B的mac地址，故先做arp,得到后将数据包发给B:<br>  数据包：源ip：A,源mac A ，目的IP:B,目的mac:B<br>若A在构造了数据包后，查询路由，该数据包是发送给外网，目的地址是百度ip,则无此条目，向默认路由；即发给路由器，此时若不知道mac地址会做arp;<br>数据包：源ip:A,源mac：A  ,目的ip:百度，目的mac：路由器(arp代理）<br>数据包到路由器后，将做下一步转发：<br>在路由发送的数据包：源ip:路由外网地址，源mac:路由，目的ip:百度ip.目的mac,D<br>(注意，在源ip改为路由外网地址后，此时ip唯一，源地址在传输过程中不会再改变）  </p>
</li>
<li><p>内网的路由器会将源地址改为路由器的外网地址</p>
</li>
</ol>
<p>—想想像192.168.0.4这样的源地址是内网地址，如果在包的传输过程中不做处理，到达目的地如QQ的服务器，那QQ处理完要发给你，这时得到包是从192.168.0.4来的，它作为内网地址，全世界很多个，怎么决定—–所以ip首部中的源地址和目的地址必须是全球唯一的ip地址，即外网地址；<br> 4. 路由器会对ttl做减1,然后再重新做校验和–即直接加1<br> 5. 路由器会将数据包的mac首部，源地址改为路由的mac地址，目的地址改为默认路由（或其他导向路由）ip对应的mac地址</p>
<h4 id="网络地址和子网"><a href="#网络地址和子网" class="headerlink" title="网络地址和子网"></a>网络地址和子网</h4><p>这里不记录太多的ip地址相关的内容，毕竟比较基础，且协议卷或者网上很多介绍</p>
<h5 id="网络地址简介"><a href="#网络地址简介" class="headerlink" title="网络地址简介"></a>网络地址简介</h5><p>网络地址用来在网络上代表一台设备，就像家庭地址一样，当然现在的设备，如手机可以同时拥有几个ip地址（数据网，wifi，等等，可以理解为家有多个门）<br>而现在的网络地址从32位点分十进制地址，  </p>
<ul>
<li>决定了它的数量–&gt;一个网络中的设备数量决定了它如何划分网络   </li>
<li>网络中的设备数量动态性，可能很少，ip地址不够用–&gt;子网出现（CIDR)  </li>
<li>网络地址不够用了–&gt;NAT出现，内网</li>
</ul>
<h5 id="网段，网络范围内，由谁主导生效进行实际的网络隔离和连接"><a href="#网段，网络范围内，由谁主导生效进行实际的网络隔离和连接" class="headerlink" title="网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?"></a>网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?</h5><p>—其实本质上，设备间可以通过知道mac地址相互通信，即没有网络的隔离（只要介质支持如wifi,或者有线网下设备能被连在一起)在二层上考虑的    </p>
<ul>
<li>到了三层，ip层，设备与设备之间的通信，取决于网络的大小，在同一个局域网中，设备间可以直接通信，但是不同局域网，就必须借助路由器，网络，为什么?<br> 首先，考虑他们的距离，若很远，则单纯直连很难，则需要转发，转发单知道mac地址（好吧，假设一开始知道对方的mac地址），很难像现在用ip地址的方式去找到它emm感觉考虑到协议设计了。。。<br> 其次，考虑相邻的不同网络，对应不同的网段，路由表规定了只能和该网络地址范围的主机直接连接，否则就要用默认路由了</li>
<li>考虑这样一个例子：A 在子网192.168.0.0中，地址为192.168.0.3,B在子网10.170.3.0,地址为10.170.3.2,使用wifi,他们之间相邻，此时，A向B发送ARP请求，广播帧，所以B可以接收到，接着B给A回复了响应帧，单波能收到，因为在二层传递，能接收到，不被内核过滤，此时arp表中应该多了条目；接着为了能在三层通信，在路由表中增加一条路由指示不同网段的一个地址，表示他们可以直连，接着测试看看能不能相互发送ip包，ping通，当然可能因为防火墙等；就理论而言，应该是能通的，没试过~–&gt;问题总结：IP地址网段不同的两个设备，一定不能直接通信码?</li>
<li>网关地址必须是.1结尾码?<br>恩当然可以是别的地址</li>
<li>路由表和路由规则决定了这些<br>路由表如何决定了网络的方向，下一跳，和限制了网络范围？</li>
</ul>
<h5 id="IP封包简介"><a href="#IP封包简介" class="headerlink" title="IP封包简介"></a>IP封包简介</h5><ul>
<li>ip封包网上能找到详情，这里记录几个注意点：</li>
<li>网络字节序的概念，是大端字节序，传输的次序是先0-7bit—最后到24-31这样，所以小端的设备需要线转换为网络字节序再传输</li>
<li>首部长度字段是指占32bit的数量，有4bit，最大1111*4bytes&#x3D;60bytes,即ip首部最长为60字节，普通ip同不带选项时是20字节</li>
<li>服务类型现在已经不怎么用，主要是指在不同服务下拥有不同的最小时延，最大吞吐，最高可靠性的情况，具体见协议卷１图3-2</li>
<li>总长度，指整个ip数据包的长度，包含首部和数据报，16位，即最大2^16&#x3D;65535个字节，（考虑超级通道的mtu&#x3D;65535并非是真正的mtu,而是最长ip数据报），数据报分片时会随着变化</li>
<li>标示和分片偏移等后面补充</li>
<li>校验和为ip首部校验和:首先校验和设置为0，接着每个16bit进行反码求和。rfc1071</li>
</ul>
<h4 id="网络的拓扑结构"><a href="#网络的拓扑结构" class="headerlink" title="网络的拓扑结构:"></a>网络的拓扑结构:</h4><p>理论上，网络中的每台设备都能相互通信，即使是点对点通信p2p.但是这要求设备能在网络上被唯一标示，如外网ip地址；</p>
<ul>
<li>所以常见的设备A和B的通信借助服务器如：<br>主机A&lt;–&gt;路由器(给主机唯一标识)&lt;–&gt;服务器&lt;–&gt;路由器&lt;–&gt;主机B<br>(现有的大部分通信软件等都是这样的)</li>
<li>而主机A可以直接和主机B通信不通过服务器吗?<br>答案是可以，我们使用的迅雷，bt,这些下载资源就是利用的各个主机的资源，其结构如何：<br>主机A&lt;–&gt;路由器(做NAPT等)&lt;–&gt;路由器&lt;–&gt;主机B<br>那和主机A和B如何在网络上被唯一标示，且被B知道该地址呢?路由器在其中充当什么角色，会做什么限制呢？<br>见下NAT和NAT穿透<h4 id="路由深入–NAT和NAT穿透"><a href="#路由深入–NAT和NAT穿透" class="headerlink" title="路由深入–NAT和NAT穿透"></a>路由深入–NAT和NAT穿透</h4>感谢这两篇文章把我带进门：<br><a href="https://blog.csdn.net/u012908515/article/details/53518062">https://blog.csdn.net/u012908515/article/details/53518062</a><br><a href="https://blog.csdn.net/ustcgy/article/details/5655050">https://blog.csdn.net/ustcgy/article/details/5655050</a><br>rfc ：nat<br><a href="https://tools.ietf.org/html/rfc1631">https://tools.ietf.org/html/rfc1631</a><br><a href="https://tools.ietf.org/html/rfc2663">https://tools.ietf.org/html/rfc2663</a><br>rfc：p2p<br><a href="https://tools.ietf.org/html/rfc5694">https://tools.ietf.org/html/rfc5694</a><h5 id="NAT的由来"><a href="#NAT的由来" class="headerlink" title="NAT的由来"></a>NAT的由来</h5></li>
<li>NAT的出现是因为ipv4的地址不够用，所以大量主机在内网使用内网地址，这样在互联网上通信的时候不能被寻找到，此时路由器将内网的设备发送的包中的ip转换为外网的ip,并记录映射在路由器中，这样就能实现主机在互联网上的正常通信，即发包和收包都能找到；</li>
<li>而这种方式阻碍了不同内网的主机之间的通信，即p2p;<h4 id="NAT的分类（路由器决定）"><a href="#NAT的分类（路由器决定）" class="headerlink" title="NAT的分类（路由器决定）"></a>NAT的分类（路由器决定）</h4></li>
<li>静态NAT:即内网的一个IP对应外网的一个IP，且一一对应，即每次分配的时候都是相同的，永久的</li>
<li>动态NAT：即内网的一个IP对应外网的一个IP,但是每次分配的外网IP可能不同，映射不同</li>
<li>NAPT:即为了使同一个外网IP能被多个内网的主机使用而出现；<br>如何区分各个主机？即路由器发包时和收包时，如收包时，如何确定该包是发给主机A还是B?即用NAPT,IP加端口号的形式来区分  </li>
<li>NAPT分为以下两大类：cone锥形NAT和symmetric 对称NAT</li>
</ul>
<ol>
<li>cone NAT的特点是对内网的主机A，和外网所有的服务器通信，都使用相同的端口号；<br>如：内网：192.168.4.5:4323–&gt;server:222.33.22.334:80<br>则经过路由器：外网ip:122.332.43.32:1234–&gt;server:22…路由器把源地址改为122.332.43.32:1234后发送<br>进过服务器2也是类似的，使用同一个端口1234<br>&#x2F;&#x2F;这里有个疑问，即内网下相同的ip地址，不同的端口时，经过路由器转换后是否为不同端口<br>考虑在接收服务器回复的内容时:</li>
</ol>
<p>222.33.22.334:80–&gt;122.332.43.32：1234此时路由器根据映射，即端口122.332.43.32：1234对应的是192.168.4.5把目的地址和端口更改为它后发送。所以为了能让包在主机内找到对应端口的程序，路由器的设置应为内网同ip不同端口，映射外网的ip+不同端口（待验证）</p>
<ul>
<li>锥形NAT类型：完全锥形full cone和受限锥形( restricted cone) 以及端口受限锥形（port restricted cone)  <ul>
<li>完全锥形：任何知道主机B银蛇在NAT上的外部地址和端口的主机都可以通过它发包给内部主机B,即使A在内网(在内网时通过映射的外网地址）</li>
<li>受限锥形：只有内部主机B向其发送过包的主机A才能对这个内部主机B发包（通过主机B映射在外部的地址端口）</li>
<li>端口受限：在受限锥形的基础上加了端口限制</li>
</ul>
</li>
</ul>
<ol start="2">
<li>对称NAT(symmetric nat):<br>会为新的session分配新的端口，即和服务器1通信时使用端口1234，接着发起新的服务器2访问时，使用端口1235等<br>如何检测类型？<a href="https://blog.csdn.net/u012908515/article/details/53518062">https://blog.csdn.net/u012908515/article/details/53518062</a></li>
</ol>
<h5 id="ipv6不需要NAT"><a href="#ipv6不需要NAT" class="headerlink" title="ipv6不需要NAT"></a>ipv6不需要NAT</h5><p>ipv6地址很多，有人形容世界上的每个沙子都能被定址，所以地址够用，也就不用内网，所以用来做p2p更适用，自然也就不用什么nat转换</p>
<h5 id="p2p网络架构和内网穿透"><a href="#p2p网络架构和内网穿透" class="headerlink" title="p2p网络架构和内网穿透"></a>p2p网络架构和内网穿透</h5><p>基于上面的napt类型介绍，可以知道内网的主机如何和外网的服务器通信，那内网的主机1如何和另一个内网的主机2直接通信?（不借助服务器）<br>答案:基于上面的限制，有几种方案：  </p>
<ul>
<li>针对full cone类型的，内网主机2只要知道内网主机1映射到外部的ip地址和端口，就可以直接发送数据包给1，且能接收；</li>
<li>针对受限的cone类型，内网机2像上面的方式是不行的：得满足两个条件：1是知道主机1映射到外部的ip和端口，2是主机1曾向主机2发送过请求，相当于开了个口，显然这个条件下2为服务器或者有公网ip的设备；所以针对此受限的类型，有一下场景+方案：</li>
<li>场景1：主机1在nat后，打开了和服务器A通信，主机2想和1通信，主机2不在nat后；显然直接向主机1发起请求是不行的，上述条件2不满足，主机1不曾向2发起请求；  </li>
<li>解决方案是，借助服务器A请求主机1做一个反向连接，即向2发起请求，从而打开通道，进而2就可以跟1通信了</li>
<li>场景2：主机1在nat后，主机2在nat后，主机1，2均打开了和服务器A通信，主机1想直接和2通过双方映射到外网的地址端口进行通信 </li>
<li>解决方案：UDP打洞：假如1开始发送一个UDP信息到2的公网地址上,与此同时,他又通过A中转发送了一个邀请信息给2,请求2也给1发送一个UDP信息到1的公网地址上.这时1向2的公网IP发送的信息导致 NAT 1 打开一个处于1的私有地址和2的公网地址之间的新的通信会话,与此同时NAT 2也打开了一个处于2的私有地址和1的公网地址之间的新的通信会话.一旦这个新的UDP会话各自向对方打开了,1和2之间就可以直接通信,而无需A来牵线搭桥了.这就是所谓的打洞技术.一旦这种处于NAT之后的端对端的直连建立之后,连接的双方可以轮流担任对方的”媒人”,把对方介绍给其他的客户端,这样就极大的降低了服务器A的工作量.</li>
<li>场景3：主机1和2处于同一个NAT下，他们却不知道：</li>
<li>解决方案：综合相同内网下主机可以直接相互通信原理：在主机1发送给A的包中携带其内网地址和端口，A从而知道了1的外网端口地址和内网端口地址，相互都发给1,2，若接着1发起请求给2能收到回复说明在同一个内网，否则采用场景2的解决方案</li>
<li>场景4：主机1处于多层NAT下</li>
<li>问题：udp空闲状态下超时断开的问题：使用心跳包</li>
<li>扩展：tcp的打洞，同时开放tcp连接，原理类似，较复杂</li>
<li>针对对称性的cone,不定因素多，不建议写</li>
<li>所以p2p网络即是多个内网主机1,2,3,4等之间的相互直接通信，即他们之间的下载数据可以相互共享，也就是平常说的挂种子，bt下载，也是为什么能达到那么快速的原因;当然可想这个过程和普通的cs架构区别：</li>
<li>p2p架构，bt模型（猜测)：首先客户端负责下载和挂种的基本功能。下载:需要向服务器取得可以获取资源的主机的nat外网地址和ip,接着服务器为其打洞，将正在挂种的客户ip等提供给该客户端，从而能下载；挂种：给服务器声明自己能提供资源，并通过心跳维持一个持续的洞；BT服务器做什么?综合客户端资源和打洞，即让下载方能方访问挂种放 。   这个过程需要考虑：下载方面对多个挂种方，如何下载文件块和组装，最多同时和几个挂种方下载等等；</li>
<li>回忆：之前学校的rs bt站就是这样，只是开放在学校的内网，可以说是相同nat下的不同主机???好像也不能这么说。。然后采用的原理就是上述的，记得一开始速度不是很快，但是后面15年吧，下载速度能达到10+m&#x2F;s,很快的，我想可能是优化了下载多个挂种方的方案，增加了最多的下载源，或者学校的网络变优～<h5 id="Cbitterrot源码分析（待"><a href="#Cbitterrot源码分析（待" class="headerlink" title="Cbitterrot源码分析（待~)"></a>Cbitterrot源码分析（待~)</h5> <a href="https://linux.cn/thread-5529-1-1.html">https://linux.cn/thread-5529-1-1.html</a><br> 对于p2p架构的软件设计，其实跟平常的cs架构很象，都需要用到socket等</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_MAC</title>
    <url>/2018/06/03/tcpip-MAC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="mac数据链路层的理解"><a href="#mac数据链路层的理解" class="headerlink" title="mac数据链路层的理解"></a>mac数据链路层的理解</h3><h4 id="mac层的功能介绍"><a href="#mac层的功能介绍" class="headerlink" title="mac层的功能介绍"></a>mac层的功能介绍</h4><p>mac层在理论上赋予了较全的功能，但是其实，实际上在使用的时候，由于无噪声通道，或者一些功能交给了上层的协议，所以实际的mac功能没有理论那么全面。mac层的实现包括在驱动和固件中，所以实际的功能得看芯片和固件的支持，比如是否支持监听模式；  <span id="more"></span><br>理论上：建议书籍《数据通信与网络》<br>寻址：实际的端到端通信，都是需要先知到对方的mac地址(通过arp),才能进行实际传输的；<br>帧构建：这一层结束后就是完成了包封装，下一步传送给物理层编码发送了；<br>数据差错检查；传送控制，流量控制，差错控制，编码，校验和等等；，编码是指在原始数据mac封包后，在实际传输时进行编码（按照某个80x协议等，这个属于偏物理层的事情了）<br>实际上：数据差错检查，流量控制，差错控制等都没做，或者要看具体的厂商实现如高通，mtk等</p>
<h4 id="mac层的传输限制"><a href="#mac层的传输限制" class="headerlink" title="mac层的传输限制"></a>mac层的传输限制</h4><p> 考虑一个包从电脑发出去，最后一次封包根据接口不同(有线，无线),协议不同，采用的mac头也不同，如ppp协议要加其他信息；<br> –&gt;简述:接着可能发给无线路由器或者交换机，路由器会判断是wifi的mac头，接着要向以太网传输时，或者无线传输时，需要去掉mac头，并加上自己的mac头，改变mac源地址为自己，目的地址为(路由表对应)arp寻找的下一跳mac地址;若为以太网，还要转换为以太网的头类型等<br> …<br> 整个过程，从物理层角度看，是可以顺利进行的，但是实际为了效率，不接受无用的包，不发送无效的包和安全等，在驱动和固件都会有做相应的过滤处理，从而使发包收包，转发包等受到了限制，见下实验等；</p>
<h4 id="mac层的封包-mtu-msdu-mpdu"><a href="#mac层的封包-mtu-msdu-mpdu" class="headerlink" title="mac层的封包,mtu,msdu,mpdu"></a>mac层的封包,mtu,msdu,mpdu</h4><p>在包的封装上，有线网和无线网不同，更确切的是协议不同，其mac层封包也不同–对相同的ip包(ip头+上层数据&#x2F;arp&#x2F;…）带有不同的mac头：<br>例如对以太网（有线）：常见有一下四种mac头封装的帧：</p>
<ul>
<li>EthernetII:  dest addr+src addr+type+data+fcs</li>
<li>Ethernet 802.2:dest addr+srcaddr+len+ llc+data+fcs</li>
<li>Ethernet 802.3:dest addr+src addr+len+data+fcs </li>
<li>Ethernet SNAP:dest addr+src addr+len+llc+snap+data+fcs<br>参考：<a href="https://blog.csdn.net/xiao628945/article/details/8006022">https://blog.csdn.net/xiao628945/article/details/8006022</a><br>针对无线网络：802.11n等，更复杂些：</li>
<li>802.11头+msdu(数据部分)+fcs(crc)<br>而802.11wifi无线帧分为控制帧，管理帧和数据帧，因为在无线网络中的安全性等考虑，需要扫描，关联，认证四次握手等步骤,在802.11头就包含了subtype，即数据部分是什么类型（控制，。。）<a href="https://blog.csdn.net/suiyuan19840208/article/details/17200745%E6%88%96%E8%80%85%E5%95%83spec:%E6%96%87%E6%9C%AB">https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末</a><br><a href="https://blog.csdn.net/robertsong2004/article/details/42805803%E8%BF%99%E7%AF%87%E6%9B%B4%E8%AF%A6%E7%BB%86%EF%BC%8C%E8%83%BD%E6%9F%A5%E5%88%B0%E7%9A%84%E4%B8%8D%E6%83%B3%E8%AE%B0%E5%BD%95%E4%BA%86">https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了</a><br>这么多的封包类型，除却ip层只有一种，那在传递的过程中如何处理?即有线到无线，怎么识别?答案是在路由器，主机中进行去头和加头<br>不同厂商实现不同，在无线中，非数据帧部分：底层的实现分为full mac driver（Full Mac的Driver，一般Auth和Assoc的包直接在芯片里边处理了，Driver通过command形式告诉Firmware要连接AP的信息，Firmware处理了Assoc Response之后，report给Driver一个Event，说明连接的情况（result和AID）以及assoc相关的IE，Driver会直接调用cfg80211的接口报告给supplicant，然后处理EAPOL的握手过程，因为之后的EAPOL Data的处理会用到Assoc Response里边的IE）  而用soft mac则软件可以控制较多的事情(Soft Mac模块开源代码mac80211的WiFi芯片，会将这两种包送到Mac80211处理，mac80211处理完后调用cfg80211的接口通过nl80211(netlink)通知wpa_supplicant准备认证以及四次握手的状态机，等待处理EAPOL包，EAPOL是二层的Data包，会在Supplicant里边处理，连接加密的路由情况就是这样处理的，如果不加密，那就直接DHCP了)；扯远了。。<br>在pc等设备中，在封装到数据链路层时，封装时用的是ethernetII，到底层驱动时就被替换为对应的802.11的头了，进而发送出去，而在接收数据包的时候，底层上报上来又会把802.11格式的转换为ehternetII的形式，所以我在实验wifi的时候，用的PF_PACKET来操作数据包，加的是ethernetII的头，接收到打印出来后还是ethernetII的头<br>晒张空中包的和本地tcpdump抓到的包对比：<br>&#x2F;&#x2F;to do</li>
</ul>
<p>当然除却mac头的不同，mtu的概念还是存在:<br>mac层在传输时一次传输一帧，这一帧即是封装了mac头的数据包，它常为[46-1500]+mac头,而mtu即是最大的传输单元，是去掉mac头的负载部分最大值，如1500<br>而在实际传输的空中包，情况又可能不同，这里看msdu 和mpdu:<br><a href="https://blog.csdn.net/zhengnice/article/details/51923132">https://blog.csdn.net/zhengnice/article/details/51923132</a><br>这篇文章讲的很好，在理解了上述的内容后，看这篇文章里面的msdu和mpdu就能很好的理解了，spec的416页也有相关的内容</p>
<h5 id="mac头格式：不同协议可能不同："><a href="#mac头格式：不同协议可能不同：" class="headerlink" title="mac头格式：不同协议可能不同："></a>mac头格式：不同协议可能不同：</h5><p>常见：dest addr,src addr ,proto type; 14byte<br>见上文</p>
<h4 id="mac层的发包和收包限制"><a href="#mac层的发包和收包限制" class="headerlink" title="mac层的发包和收包限制"></a>mac层的发包和收包限制</h4><p>考虑一个问题，即在不考虑网络网段的情况下，两台设备在开启wifi或者连接网线的情况下，能相互直接通信吗？<br>从理论上是可以的，首先是发送，无问题，接收，可以接收；其次，接收之后解码，需要双方使用相同的编码协议等；<br>其次：实际上，需要几个条件，且有线和无线的方式不同：</p>
<ul>
<li>有线：需要双方相同的编码，直连的情况下，可以直接通信；</li>
<li>无线: (分为数据部分和管理部分，需要双方相同的编码)，但是仅开启wifi，只能接收小量信息的beacon帧；即wifi为了安全性，效率等(wifi本身可以接收所有数据），做了连接前的扫描，关联认证，四次握手等过程，并且对mac地址进行过滤，使不同网段的两个相邻设备不能通过直接发送接收mac层数据来交互；具体见厂商的实现，可以参考实验部分；  </li>
<li>所以关键看厂商怎么实现，底层的东西，他们提供接口给你，你就能操作了balalal<h5 id="普通模式，混杂模式和监听模式"><a href="#普通模式，混杂模式和监听模式" class="headerlink" title="普通模式，混杂模式和监听模式"></a>普通模式，混杂模式和监听模式</h5><h4 id="mac层的几个实验"><a href="#mac层的几个实验" class="headerlink" title="mac层的几个实验"></a>mac层的几个实验</h4>普通模式下，wifi实验，以station架构进行：<br>设备A，B,路由器C，D;  </li>
<li>A,B连接同一个路由器C,A,B通过PF_PACKET发送和接收mac头加任意数据，成功发送接收，即使arp表无对方的条目  </li>
<li>A,B都不连接wifi,只是打开wifi，此时无法发送和接收数据，厂商默认的只会发送主动扫苗和接收beacon帧，扫描的具体过程待文章写,在没有连接上时，只会发送小数据</li>
<li>A,B间任意设备连上路由器，同上</li>
<li><em>A连接路由C,B连接路由D,相互发送和接收mac头加任意数据，目的地址为对方mac，源地址为自己的mac—失败，其实一开始是怀着疑问的，从理论分析是可以的，但是还是不行，若只是在二层的话，对方怎么知道这个源mac地址是在不同网段并做过滤?难道发之前，底层进行了隐式arp？但是我发的包里面没有带ip信息啊，同时进行了广播帧的发送接收，还是失败了；应该都是出在接收的环节；也有可能是两个ap使用的协议不同导致编码方式不同从而接收失败</em></li>
<li>考虑到可能是两个路由器编码和使用的协议如一个是802.11n,一个是ac，等，可能导致接收不到，所以可以再尝试使用两个相同的型号的路由器；&#x2F;&#x2F;待测试</li>
<li>发送方普通模式，接收方监听模式，接收方可以收到所有包，所以可以接收到</li>
</ul>
<h4 id="openwrt开源路由系统，驱动，固件"><a href="#openwrt开源路由系统，驱动，固件" class="headerlink" title="openwrt开源路由系统，驱动，固件"></a>openwrt开源路由系统，驱动，固件</h4><p>了解一下。。。<br>spec:Wireless LAN Medium Access Control<br>(MAC)<br>and Physical Layer (PHY) Specifications</p>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_PF_PACKET</title>
    <url>/2018/05/27/tcpip-PF-PACKET/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="/2018/05/27/tcpip-PF-PACKET/pf_packet.jpg" class="" title="it just picture">
<h3 id="PF-PACKET的使用："><a href="#PF-PACKET的使用：" class="headerlink" title="PF_PACKET的使用："></a>PF_PACKET的使用：</h3><h3 id="PF-PACKET简介："><a href="#PF-PACKET简介：" class="headerlink" title="PF_PACKET简介："></a>PF_PACKET简介：</h3><p>是linux下的用于发送和接收二层(mac层)的套接字：</p>
<span id="more"></span>
<h3 id="PF-PACKET基本使用："><a href="#PF-PACKET基本使用：" class="headerlink" title="PF_PACKET基本使用："></a>PF_PACKET基本使用：</h3><ul>
<li>基本的几个操作：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span>```</span></span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">//获取硬件网卡的相应信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="type">char</span> *name ,  <span class="type">char</span> *MAC_addr , <span class="keyword">struct</span> in_addr * IP_addr)</span><span class="comment">//传入接口名，取回mac和ip</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">ifreq</span>  eth;  <span class="comment">//结构用于存放最初获取的接口信息</span></span><br><span class="line">   <span class="comment">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class="line">   <span class="type">int</span> fd;             <span class="comment">//用于创建套接字</span></span><br><span class="line">   <span class="type">int</span> temp=<span class="number">0</span>;         <span class="comment">//用于验证接口调用</span></span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;            <span class="comment">//用于循环</span></span><br><span class="line">   <span class="built_in">strncpy</span>(eth.ifr_name,name,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ifreq)<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class="line">  <span class="comment">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class="line">    fd=<span class="built_in">socket</span>(AF_PACKET,SOCK_DGRAM,<span class="built_in">htons</span>(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;socket failed!\n&quot;</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class="line">     temp = <span class="built_in">ioctl</span>(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class="line">     <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl--get hardware addr failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="built_in">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class="number">6</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The MAC_addr is:&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%4X&quot;</span>,(<span class="type">unsigned</span> <span class="type">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class="line">      temp = <span class="built_in">ioctl</span>(fd,SIOCGIFADDR,&amp;eth);</span><br><span class="line">      <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;ioctl--get hardware addr failed!\n&quot;</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(IP_addr ,&amp;(((<span class="keyword">struct</span> sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class="number">4</span>);</span><br><span class="line">      <span class="comment">//关闭套接口</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;got ipaddr:%s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(*IP_addr)); </span><br><span class="line">      <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取得网络接口的索引：int值,传入fd和接口名</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_IfaceIndex</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* interfaceName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ifreq</span> ifr;</span><br><span class="line"><span class="keyword">if</span> (interfaceName == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="built_in">sizeof</span>(ifr));</span><br><span class="line"><span class="built_in">strcpy</span>(ifr.ifr_name, interfaceName);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ioctl</span>(fd, SIOCGIFINDEX, &amp;ifr) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;RED ioctl error\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ifr.ifr_ifindex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_Iface_promisc</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> dev_id)</span><span class="comment">//传入fd和index</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">packet_mreq</span> mr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;mr,<span class="number">0</span>,<span class="built_in">sizeof</span>(mr));</span><br><span class="line">mr.mr_ifindex = dev_id;</span><br><span class="line">mr.mr_type = PACKET_MR_PROMISC;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">setsockopt</span>(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&amp;mr,<span class="built_in">sizeof</span>(mr))==<span class="number">-1</span>)<span class="comment">//退出混杂模式使用这个：PACKET_DROP_MEMBERSHIP</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;GREEN set promisc failed! \n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;```</span><br><span class="line">使用</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">char</span> MAC_ADDR[<span class="number">6</span>];</span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">in_addr</span> IP_ADDR;<span class="comment">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class="line">	 <span class="comment">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class="line">    <span class="built_in">GetEthInfor</span>(<span class="string">&quot;wlp2s0&quot;</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">     fd=<span class="built_in">socket</span>(AF_PACKET,SOCK_DGRAM,<span class="built_in">htons</span>(ETH_P_ARP));</span><br><span class="line">    <span class="type">int</span> index=<span class="built_in">Get_IfaceIndex</span>(fd,<span class="string">&quot;enp1s0&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;index:%d\n&quot;</span>,index);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="PF-PACKET的接收："><a href="#PF-PACKET的接收：" class="headerlink" title="PF_PACKET的接收："></a>PF_PACKET的接收：</h3><p>简单说明：<br>创建套结字的时候，有以下的组合：更多见：man packet</p>
<ul>
<li>利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</li>
<li>第二个参数： 套接字类型：<br>   SOCK_DGRAM—-以太网头已经构造好了<br>   SOCK_RAW——自己构造以太头<br>   * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字<br>   * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux&#x2F;if_ether.h中，ethhdr），<br>   * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，<br>   * 而发送时也无须用户添加头部字段。</li>
</ul>
<ul>
<li>第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP<ul>
<li>以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：<br>1）头文件Linux&#x2F;if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)<br>和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)</li>
</ul>
</li>
</ul>
<ol start="2">
<li>IEEE维护的注册以太网类型列表<br>  3）半官方的列表由IANA维护<br>ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。<br>0x88b5和0x88b6是保留以太网类型，供实验或私人使用。<br>(若指定socket_type为SOCK_RAW则意味着原始数据包包含了链路层头部，若指定为SOCK_DGRAM则将做一些处理以剥掉链路层头部。链路层头部信息的通用格式是一个sockaddr_ll结构。protocol填入网络字节序的IEEE 802.3协议号。参见&lt;linux&#x2F;if_ether.h&gt;头文件了解允许的协议。如果protocol被设置为htons(ETH_P_ALL)，则意味着接受所有协议。所有接入的协议类型为protocol的数据包将在传递给内核之前传递到PACKET套接字。)</li>
</ol>
<ul>
<li>收包可以使用的接口：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="type">int</span> readnum = <span class="built_in">recvfrom</span>(rawsock, buffer,<span class="number">2048</span>,<span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)(&amp;eth_info),&amp;leneth_info);</span><br><span class="line">  <span class="type">int</span> readnum = <span class="built_in">read</span>(rawsock, buffer,<span class="number">2048</span>);</span><br><span class="line">  <span class="type">int</span> readnum = <span class="built_in">recvfrom</span>(rawsock, buffer,<span class="number">2048</span>,<span class="number">0</span>, <span class="literal">NULL</span>,<span class="literal">NULL</span>);```</span><br><span class="line">        </span><br><span class="line">+ 一个简单的接收包的例子：</span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_MAX 2048```</span></span><br><span class="line"></span><br><span class="line">```<span class="function">c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>((rawsock=<span class="built_in">socket</span>(PF_PACKET,SOCK_RAW,<span class="built_in">htons</span>(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: create raw socket!!!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="type">int</span> readnum = <span class="built_in">read</span>(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf(&quot;recv buffer:%s\n&quot;,buffer);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;```</span><br><span class="line">  </span><br><span class="line">+ 指定从某个接口接收数据：</span><br><span class="line">```<span class="function">c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_ll</span> eth_info;<span class="comment">//结构体的定义在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class="line">  eth_info.sll_family = PF_PACKET;  <span class="comment">//PF_PACKET定义在sys/types.h中</span></span><br><span class="line">  eth_info.sll_ifindex = if_nametoindex(<span class="string">&quot;lo&quot;</span>);<span class="comment">//返回输入的接口名称的索引值　　//次函数定义在net/if.h中</span></span><br><span class="line"> <span class="keyword">if</span>((rawsock=<span class="built_in">socket</span>(PF_PACKET,SOCK_RAW,<span class="built_in">htons</span>(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: create raw socket!!!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">bind</span>(rawsock,(<span class="keyword">struct</span> sockaddr *)(&amp;eth_info),<span class="built_in">sizeof</span>(eth_info))==<span class="number">-1</span>)<span class="comment">//绑定接口，从而只接收那个接口上的数据</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;error: bind!!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="type">int</span> readnum = <span class="built_in">read</span>(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf(&quot;recv buffer:%s\n&quot;,buffer);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;```</span><br><span class="line">  </span><br><span class="line">+ 接收后的包如何读取：以包括mac头的形式来看：粗暴的形式</span><br><span class="line">```<span class="function">c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rawsock;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_MAX];</span><br><span class="line">    <span class="type">char</span> *ethhead;</span><br><span class="line">    <span class="type">char</span> *iphead;</span><br><span class="line">    <span class="type">char</span> *tcphead;</span><br><span class="line">    <span class="type">char</span> *udphead;</span><br><span class="line">    <span class="type">char</span> *icmphead;</span><br><span class="line">    <span class="type">char</span> *pHead;</span><br><span class="line"> <span class="keyword">if</span>((rawsock=<span class="built_in">socket</span>(PF_PACKET,SOCK_RAW,<span class="built_in">htons</span>(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: create raw socket!!!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="type">int</span> readnum = <span class="built_in">read</span>(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf(&quot;recv buffer:%s\n&quot;,buffer);</span></span><br><span class="line">         <span class="keyword">if</span>(readnum &lt; <span class="number">42</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error: Header is incomplete!!!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//  for(j;j&lt;readnum;j++)</span></span><br><span class="line">      <span class="comment">//     printf(&quot;%.2X:&quot;,buffer[j]&amp;0xFF);</span></span><br><span class="line">        ethhead = (<span class="type">char</span> *)buffer;</span><br><span class="line">        pHead = ethhead;</span><br><span class="line">        <span class="type">int</span> ethernetmask = <span class="number">0XFF</span>;</span><br><span class="line">        framecount++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------------Analysis   Packet [%d]---------------------\n&quot;</span>,framecount);</span><br><span class="line">       <span class="comment">// printf(&quot;all:-----%s\n&quot;,ethhead);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MAC:&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;=<span class="number">11</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2X:&quot;</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;=<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2X:&quot;</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proto: %.2x:&quot;</span>,pHead[<span class="number">12</span>]&amp;ethernetmask);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proto2: %.2x:\n&quot;</span>,pHead[<span class="number">13</span>]&amp;ethernetmask);        </span><br><span class="line">        iphead = ethhead + <span class="number">14</span>;</span><br><span class="line">        pHead = iphead + <span class="number">14</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;=<span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">10</span>; i &lt;=<span class="number">13</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">13</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> prototype = (iphead + <span class="number">9</span>)[<span class="number">0</span>];</span><br><span class="line">     <span class="comment">//   printf(&quot;Protocol: %.2X:&quot;,prototype);</span></span><br><span class="line">        <span class="comment">//int prototype = (iphead + 9)[0];</span></span><br><span class="line">        pHead = iphead + <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Protocol: &quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span>(prototype)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_ICMP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ICMP\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_IGMP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;IGMP\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_IPIP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;IP\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_TCP :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;TCP | source port: %u | &quot;</span>,(pHead[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">1</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;dest port: %u\n&quot;</span>, (pHead[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">3</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_UDP :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;UDP | source port: %u | &quot;</span>,(pHead[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">1</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;dest port: %u\n&quot;</span>, (pHead[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">3</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_RAW :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;RAW\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Unkown\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;-------------------------end-----------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;```</span><br><span class="line">收包处理的方式，也可以把指针赋给内核的结构：<span class="keyword">struct</span> <span class="title class_">iphdr</span></span><br><span class="line">如：   </span><br><span class="line">```cpp</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">iphdr</span> ip;</span><br><span class="line"> ip = (<span class="keyword">struct</span> iphdr *)(buffer + <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ethhdr));</span><br></pre></td></tr></table></figure>
内核提供了很多的包结构，在发包或者收包的时候可以直接使用这些结构解析或者粗暴的用字符串解析</li>
</ul>
<h3 id="PF-PACKET发送包："><a href="#PF-PACKET发送包：" class="headerlink" title="PF_PACKET发送包："></a>PF_PACKET发送包：</h3><ul>
<li>发包和接收包类似：<br><code>cpp num = sendto(rawsock, buffer,2048 , 0 ,(struct sockaddr*)(&amp;eth_info),sizeof(eth_info));  if(num&lt;0)  &#123; printf(&quot;sendto failed!\n&quot;); exit(1);  &#125;  printf(&quot;success:%d\n&quot;,num);</code></li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>PF_PACKET</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_mtu</title>
    <url>/2018/05/20/tcpip-mtu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍：</p>
<h3 id="理论部分："><a href="#理论部分：" class="headerlink" title="理论部分："></a>理论部分：</h3><h4 id="１、MTU-Maximum-Transmission-Unit-如何定义"><a href="#１、MTU-Maximum-Transmission-Unit-如何定义" class="headerlink" title="１、MTU(Maximum Transmission Unit)如何定义:"></a>１、MTU(Maximum Transmission Unit)如何定义:</h4><ul>
<li>指的是通信协议中的某一层上面所能通过的最大数据包大小</li>
<li>这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？  <span id="more"></span><br>   　答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B&gt;1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:<br>分片：ip净载荷：MTU-IP头：1500-20&#x3D;1480;<br> 3008B 需要分为3片，3008&#x3D;1480,1480,48<br> 总结：MTU就是MAC承载的载荷的最大值</li>
</ul>
<h4 id="2、MTU会影响什么"><a href="#2、MTU会影响什么" class="headerlink" title="2、MTU会影响什么:"></a>2、MTU会影响什么:</h4><ul>
<li>数据包太大-&gt;分片重组-&gt;网络性能变差  </li>
<li>数据包太小-&gt;一次能传输的数据小-&gt;网速差  </li>
<li>路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191)</li>
</ul>
<p>　　</p>
<h4 id="3、如何知道这个值呢？"><a href="#3、如何知道这个值呢？" class="headerlink" title="3、如何知道这个值呢？"></a>3、如何知道这个值呢？</h4><p>路径最大传输单元发现方法(RFC1191)　　</p>
<ul>
<li>越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。  </li>
<li>MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：<br>ping -c 3 -s 1474 -M do 192.168.0.1<br>PING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.<br>ping: local error: Message too long, mtu&#x3D;1500<br>提示错误即消息太大且未设置分片</li>
</ul>
<h4 id="4-MTU大小的来源"><a href="#4-MTU大小的来源" class="headerlink" title="4 MTU大小的来源:"></a>4 MTU大小的来源:</h4><p>ref <a href="https://www.zhihu.com/question/31460305/answer/183766816">https://www.zhihu.com/question/31460305/answer/183766816</a><br>以太网传输帧的最小值：    </p>
<ul>
<li>最早的以太网工作方式：载波多路复用&#x2F;冲突检测（CSMA&#x2F;D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。</li>
<li>假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。</li>
</ul>
<p>为什么标准以太网帧长度上限为1518字节?  </p>
<ul>
<li>IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 &#x3D; 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。</li>
<li>由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload &#x3D; 218 - Ethernet Header - IP Header - TCP Header &#x3D; 218 - 18 - 20 - 20 &#x3D; 160 byte那有效传输效率&#x3D; 160 &#x2F; 218 &#x3D; 73%而如果以太网长度为1518，那有效传输效率&#x3D; 1460 &#x2F; 1518 &#x3D; 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题.</li>
<li>于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。</li>
</ul>
<p>其他疑问：  </p>
<ul>
<li>最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？</li>
<li>这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到&gt; 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。</li>
<li>有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度&gt;接口MTU，怎么办？<br>丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。</li>
<li>所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？</li>
<li>我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU &#x3D; MRU，但比如9000侧的数据到达1500，由于9000 &gt; MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样<h3 id="实践部分："><a href="#实践部分：" class="headerlink" title="实践部分："></a>实践部分：</h3>如何设置MTU：<br> ifconfig eth0 mtu 1460<br>如何查看mtu:<br>netstat -i</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_pingtraceroute</title>
    <url>/2018/06/24/tcpip-pingtraceroute/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="ping-and-traceroute"><a href="#ping-and-traceroute" class="headerlink" title="ping and traceroute"></a>ping and traceroute</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>ping是ICMP中的回显报文类型：</p>
<ul>
<li>ping 对应的icmp，type字段为0&#x2F;8,code字段为0</li>
<li>ICMP回显请求和应答报文格式：<span id="more"></span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类型(<span class="number">0</span>/<span class="number">8</span>）       <span class="built_in">code</span>(<span class="number">0</span>)       检验和 -<span class="number">-4B</span></span><br><span class="line">标示符（unix系统中为进程pid)   序号   -<span class="number">-4B</span></span><br><span class="line">           选项数据</span><br></pre></td></tr></table></figure>

<ul>
<li>最常见，回显时间，得到往返时间：<br>通过在icmp数据报文中存放发送请求的时间值来计算往返时间，当应答返回时，用当前时间减去存放在ICMP报文中的时间值，即是往返时间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类型(<span class="number">0</span>/<span class="number">8</span>）       <span class="built_in">code</span>(<span class="number">0</span>)       检验和 -<span class="number">-4B</span></span><br><span class="line">标示符（unix系统中为进程pid)   序号   -<span class="number">-4B</span></span><br><span class="line">           <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;         -<span class="number">-8B</span></span><br></pre></td></tr></table></figure>

<p>共16Byte,除开ip头</p>
<ul>
<li>放抓包的图片，ping回显示时间</li>
<li>ping程序代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">addr_conv</span><span class="params">(<span class="type">char</span> *address,<span class="keyword">struct</span> in_addr *inaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hostent</span> *he;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">inet_aton</span>(address,inaddr)==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">	he=<span class="built_in">gethostbyname</span>(address);</span><br><span class="line">	<span class="keyword">if</span>(he!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*inaddr=*((<span class="keyword">struct</span> in_addr *)he-&gt;h_addr_list[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_icmp</span><span class="params">(<span class="type">int</span> sockfd,sockaddr_in send_addr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recv_icmp</span><span class="params">(<span class="type">int</span> sockfd,sockaddr_in send_addr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">	sockfd=<span class="built_in">socket</span>(AF_INET,SOCK_RAW,IPPROTO_ICMP);</span><br><span class="line">    <span class="keyword">if</span>(sockfd&lt;<span class="number">0</span>)</span><br><span class="line"> 	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;creat socket error&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sockaddr_in send_addr;</span><br><span class="line">	<span class="built_in">bzero</span>(&amp;send_addr,<span class="built_in">sizeof</span>(send_addr));</span><br><span class="line">	send_addr.sin_family=AF_INET;</span><br><span class="line">	<span class="built_in">addr_conv</span>(argv[<span class="number">1</span>],&amp;send_addr.sin_addr);</span><br><span class="line"><span class="comment">//send_addr.sin_addr.s_addr=inet_addr(&quot;192.168.0.110&quot;);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line"> 	&#123;</span><br><span class="line">		<span class="built_in">send_icmp</span>(sockfd,send_addr);</span><br><span class="line">		<span class="built_in">recv_icmp</span>(sockfd,send_addr);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">checksum</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> *addr,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> nleft=len;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> *w=addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> answer=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(nleft&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=*w++;</span><br><span class="line">		nleft-=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(nleft==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*(<span class="type">unsigned</span> <span class="type">char</span> *)(&amp;answer)=*(<span class="type">unsigned</span> <span class="type">char</span> *)w;</span><br><span class="line">		sum+=answer;</span><br><span class="line">	&#125;</span><br><span class="line">	sum=(sum&gt;&gt;<span class="number">16</span>)+(sum&amp;<span class="number">0xffff</span>);</span><br><span class="line">	sum+=(sum&gt;&gt;<span class="number">16</span>);</span><br><span class="line">	answer=~sum;</span><br><span class="line">	<span class="comment">//answer=(unsigned short)sum&amp;0xffff;</span></span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_icmp</span><span class="params">(<span class="type">int</span> sockfd,sockaddr_in send_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">short</span> <span class="type">int</span> seq=<span class="number">10</span>;</span><br><span class="line">	<span class="type">char</span>  buf[<span class="number">8</span>+<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">icmphdr</span> *icmp=(<span class="keyword">struct</span> icmphdr *)buf;</span><br><span class="line">	<span class="comment">//填充icmp首部</span></span><br><span class="line">	icmp-&gt;type=ICMP_ECHO;<span class="comment">//类型</span></span><br><span class="line">	icmp-&gt;code=<span class="number">0</span>;<span class="comment">//和编码共同决定是回显报文</span></span><br><span class="line">	icmp-&gt;checksum=<span class="number">0</span>;<span class="comment">//头部包含校验和</span></span><br><span class="line">	icmp-&gt;un.echo.id=<span class="built_in">getpid</span>();<span class="comment">//标识符，唯一性，一般填充pid，这样即使几个程序发送ping也能识别，写成其他时接收失败</span></span><br><span class="line">	icmp-&gt;un.echo.sequence=seq++;<span class="comment">//顺序号，回显时，显示，一般无规定，但是会在此基础上加１，接着加１，，</span></span><br><span class="line">	<span class="comment">//填充icmp数据(时间)//这里报文数据只有时间戳</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">	<span class="comment">//tv=(struct timeval*)icmp-&gt;icmp_data;</span></span><br><span class="line">	<span class="built_in">gettimeofday</span>(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(buf+<span class="number">8</span>,&amp;tv,<span class="built_in">sizeof</span>(tv));</span><br><span class="line">	<span class="type">int</span> buflen=<span class="built_in">sizeof</span>(<span class="keyword">struct</span> icmphdr)+<span class="built_in">sizeof</span>(<span class="keyword">struct</span> timeval);</span><br><span class="line">	<span class="comment">//计算校验和</span></span><br><span class="line">	icmp-&gt;checksum=<span class="built_in">checksum</span>((<span class="type">unsigned</span> <span class="type">short</span> *)buf,buflen);</span><br><span class="line">	<span class="comment">//发送icmp数据包</span></span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">sendto</span>(sockfd,buf,buflen,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr *)&amp;send_addr,<span class="built_in">sizeof</span>(send_addr));</span><br><span class="line">	<span class="keyword">if</span>(len&lt;<span class="number">0</span>)</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;send icmp error&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;senmd ok&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recv_icmp</span><span class="params">(<span class="type">int</span> sockfd,sockaddr_in send_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">icmphdr</span> *icmp;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ip</span> *ip;</span><br><span class="line">	<span class="type">int</span> ipheadlen;</span><br><span class="line">	<span class="type">int</span> icmplen;</span><br><span class="line">	<span class="comment">//接收icmp响应</span></span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n=<span class="built_in">recvfrom</span>(sockfd,buf,<span class="built_in">sizeof</span>(buf),<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;recv error&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ip=(<span class="keyword">struct</span> ip *)buf;	</span><br><span class="line">		ipheadlen=ip-&gt;ip_hl&lt;&lt;<span class="number">2</span>;</span><br><span class="line">		icmplen=n-ipheadlen;</span><br><span class="line">		<span class="keyword">if</span>(icmplen&lt;<span class="number">16</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		icmp=(<span class="keyword">struct</span> icmphdr *)(buf+ipheadlen);</span><br><span class="line">		<span class="keyword">if</span>(icmp-&gt;type==ICMP_ECHOREPLY&amp;&amp;icmp-&gt;un.echo.id==<span class="built_in">getpid</span>())</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算时间差</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timeval</span> recv_tv;</span><br><span class="line">	<span class="built_in">gettimeofday</span>(&amp;recv_tv,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timeval</span> send_tv;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;send_tv,icmp+<span class="number">1</span>,<span class="built_in">sizeof</span>(send_tv));</span><br><span class="line">	recv_tv.tv_sec-=send_tv.tv_sec;</span><br><span class="line">	recv_tv.tv_usec+=recv_tv.tv_sec*<span class="number">1000000L</span>;</span><br><span class="line">	<span class="type">long</span> interval=recv_tv.tv_usec-send_tv.tv_usec;</span><br><span class="line">	<span class="comment">//输出信息</span></span><br><span class="line">	cout&lt;&lt;icmplen&lt;&lt; <span class="string">&quot; bytes fromfdfd &quot;</span>&lt;&lt;<span class="built_in">inet_ntoa</span>(send_addr.sin_addr);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot; icmp_seq=&quot;</span>&lt;&lt;icmp-&gt;un.echo.sequence&lt;&lt;<span class="string">&quot; bytes=&quot;</span>&lt;&lt;icmplen&lt;&lt;<span class="string">&quot; ttl=&quot;</span>&lt;&lt;(<span class="type">int</span>)ip-&gt;ip_ttl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot; time=&quot;</span>&lt;&lt;(<span class="type">float</span>)interval/<span class="number">1000.0</span>&lt;&lt;<span class="string">&quot;ms&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ip 记录路由选项：<br>利用ip头，ip头长度字段为4bit,最长的ip首部为15x32bit&#x3D;60字节，所以除去头20字节，选项字段最大40字节，除去3字节的code,len.ptr三个字节，剩下37个字节，可以容纳9个ip地址<br>windows下可以通过ping -r ip来尝试</li>
<li>ip时间戳选项</li>
</ul>
<h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><h5 id="traceroute主要两点"><a href="#traceroute主要两点" class="headerlink" title="traceroute主要两点"></a>traceroute主要两点</h5><ul>
<li>利用ttl,ttl是一个有限值，每经过一个路由器减1，这样放置循环发包。</li>
<li>利用icmp报文，当路由器接收到ttl为0或1时，不转发，而是丢弃，并给信源回复一个icmp超时信息，且包含该路由器的ip</li>
<li>具体流程：<br>traceroute发送一份ttl字段为1的ip数据报给目的主机，处理这个数据报的第一个路由器将ttl值减去1，丢弃该数据报，并发送一份超时icmp报文，这样就得到了该路径的第一个路由器的地址；<br>以此类推，发送ttl为2的数据报，则得到第二个路由器的地址；直到到达目的地址；<br>怎么知道到达了目的地?<br>traceroute发送了一份udp数据包给目的主机，但它选择了一个不可能的值作为udp端口号（大于30000)，使目的主机的任何一个应用程序都不可能使用该端口号，则当包到达目的主机时，目的主机的udp模块会产生一个端口不可达的错误icmp报文。traceroute要做的是区分icmp是超时还是端口不可达，以判断什么时候结束</li>
</ul>
<h5 id="traceroute命令"><a href="#traceroute命令" class="headerlink" title="traceroute命令"></a>traceroute命令</h5><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">traceroute</span> www.baidu.com</span><br><span class="line"><span class="attribute">traceroute</span> to www.baidu.com (<span class="number">119.75.216.20</span>), <span class="number">30</span> hops max, <span class="number">60</span> byte packets//ttl字段为<span class="number">30</span>跳，每个数据包为<span class="number">60</span>字节（<span class="number">20</span>ip头等）</span><br><span class="line"> <span class="attribute">1</span>  <span class="number">192.168.0.1</span> (<span class="number">192.168.0.1</span>)  <span class="number">2</span>.<span class="number">762</span> ms  <span class="number">3</span>.<span class="number">485</span> ms  <span class="number">3</span>.<span class="number">477</span> ms/发到网关<span class="number">1</span>,针对每个ttl值发送三份包，分别在<span class="number">2</span>.<span class="number">762</span>,<span class="number">3</span>.<span class="number">485</span>,<span class="number">3</span>.<span class="number">477</span>收到</span><br><span class="line"> <span class="attribute">2</span>  <span class="number">192.168.1.1</span> (<span class="number">192.168.1.1</span>)  <span class="number">3</span>.<span class="number">466</span> ms  <span class="number">3</span>.<span class="number">453</span> ms  <span class="number">3</span>.<span class="number">443</span> ms</span><br><span class="line"> <span class="attribute">3</span>  <span class="number">101.232.192.1</span> (<span class="number">101.232.192.1</span>)  <span class="number">6</span>.<span class="number">807</span> ms  <span class="number">6</span>.<span class="number">813</span> ms  <span class="number">7</span>.<span class="number">412</span> ms</span><br><span class="line"> <span class="attribute">4</span>  <span class="number">10.144.11.37</span> (<span class="number">10.144.11.37</span>)  <span class="number">7</span>.<span class="number">405</span> ms  <span class="number">7</span>.<span class="number">393</span> ms  <span class="number">7</span>.<span class="number">381</span> ms</span><br><span class="line"> <span class="attribute">5</span>  <span class="number">10.144.14.138</span> (<span class="number">10.144.14.138</span>)  <span class="number">7</span>.<span class="number">369</span> ms  <span class="number">7</span>.<span class="number">362</span> ms  <span class="number">7</span>.<span class="number">340</span> ms</span><br><span class="line"> <span class="attribute">6</span>  * * <span class="number">14.197.242.145</span> (<span class="number">14.197.242.145</span>)  <span class="number">10</span>.<span class="number">329</span> ms</span><br><span class="line"> <span class="attribute">7</span>  <span class="number">14.197.218.173</span> (<span class="number">14.197.218.173</span>)  <span class="number">7</span>.<span class="number">240</span> ms <span class="number">14.197.248.253</span> (<span class="number">14.197.248.253</span>)  <span class="number">6</span>.<span class="number">855</span> ms  <span class="number">7</span>.<span class="number">212</span> ms</span><br><span class="line"> <span class="attribute">8</span>  <span class="number">14.197.240.249</span> (<span class="number">14.197.240.249</span>)  <span class="number">44</span>.<span class="number">799</span> ms <span class="number">14.197.252.189</span> (<span class="number">14.197.252.189</span>)  <span class="number">42</span>.<span class="number">107</span> ms <span class="number">14.197.253.145</span> (<span class="number">14.197.253.145</span>)  <span class="number">50</span>.<span class="number">051</span> ms</span><br><span class="line"> <span class="attribute">9</span>  <span class="number">14.197.252.54</span> (<span class="number">14.197.252.54</span>)  <span class="number">49</span>.<span class="number">394</span> ms  <span class="number">49</span>.<span class="number">414</span> ms <span class="number">14.197.248.94</span> (<span class="number">14.197.248.94</span>)  <span class="number">49</span>.<span class="number">406</span> ms</span><br><span class="line"><span class="attribute">10</span>  <span class="number">14.197.149.178</span> (<span class="number">14.197.149.178</span>)  <span class="number">49</span>.<span class="number">406</span> ms  <span class="number">49</span>.<span class="number">383</span> ms <span class="number">14.197.178.102</span> (<span class="number">14.197.178.102</span>)  <span class="number">49</span>.<span class="number">382</span> ms</span><br><span class="line"><span class="attribute">11</span>  <span class="number">182.61.253.119</span> (<span class="number">182.61.253.119</span>)  <span class="number">49</span>.<span class="number">912</span> ms <span class="number">182.61.253.117</span> (<span class="number">182.61.253.117</span>)  <span class="number">50</span>.<span class="number">916</span> ms <span class="number">182.61.253.119</span> (<span class="number">182.61.253.119</span>)  <span class="number">50</span>.<span class="number">554</span> ms</span><br><span class="line"><span class="attribute">12</span>  <span class="number">182.61.253.126</span> (<span class="number">182.61.253.126</span>)  <span class="number">47</span>.<span class="number">975</span> ms *  <span class="number">50</span>.<span class="number">625</span> ms//<span class="number">5</span>s未收到时打印一个*号并发送下一份数据包</span><br><span class="line"><span class="attribute">13</span>  * * *</span><br><span class="line"><span class="attribute">14</span>  * * *</span><br><span class="line"><span class="attribute">15</span>  * * *</span><br><span class="line"><span class="attribute">16</span>  * * *</span><br><span class="line"><span class="attribute">17</span>  * * *</span><br><span class="line"><span class="attribute">18</span>  * * *</span><br><span class="line"><span class="attribute">19</span>  * * *</span><br><span class="line"><span class="attribute">20</span>  * * *</span><br><span class="line"><span class="attribute">21</span>  * * *</span><br><span class="line"><span class="attribute">22</span>  * * *</span><br><span class="line"><span class="attribute">23</span>  * * *</span><br><span class="line"><span class="attribute">24</span>  * * *</span><br><span class="line"><span class="attribute">25</span>  * * *</span><br><span class="line"><span class="attribute">26</span>  * * *</span><br><span class="line"><span class="attribute">27</span>  * * *</span><br><span class="line"><span class="attribute">28</span>  * * *</span><br><span class="line"><span class="attribute">29</span>  * * *</span><br><span class="line"><span class="attribute">30</span>  * * *</span><br></pre></td></tr></table></figure>

<p>tcpdump输出：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">traceroute www.baidu.com(<span class="number">119.75</span><span class="number">.213</span><span class="number">.61</span>)</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span><span class="number">.39650</span> &gt; <span class="number">119.75</span><span class="number">.213</span><span class="number">.61</span><span class="number">.33434</span>: [udp <span class="built_in">sum</span> ok] UDP, <span class="built_in">length</span> <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009075</span> IP (tos <span class="number">0x0</span>, ttl <span class="number">1</span>, id <span class="number">5354</span>, <span class="built_in">offset</span> <span class="number">0</span>, flags [<span class="literal">none</span>], proto UDP (<span class="number">17</span>), <span class="built_in">length</span> <span class="number">60</span><span class="comment">)//ttl=1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> &gt; <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span>: ICMP <span class="built_in">time</span> exceeded <span class="keyword">in</span>-transit, <span class="built_in">length</span> <span class="number">68</span>//网关回复icmp超时</span><br><span class="line">	IP (tos <span class="number">0x0</span>, ttl <span class="number">1</span>, id <span class="number">941</span>, <span class="built_in">offset</span> <span class="number">0</span>, flags [<span class="literal">none</span>], proto UDP (<span class="number">17</span>), <span class="built_in">length</span> <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span><span class="number">.48912</span> &gt; <span class="number">119.75</span><span class="number">.213</span><span class="number">.61</span><span class="number">.33435</span>: [udp <span class="built_in">sum</span> ok] UDP, <span class="built_in">length</span> <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009114</span> IP (tos <span class="number">0x0</span>, ttl <span class="number">1</span>, id <span class="number">5355</span>, <span class="built_in">offset</span> <span class="number">0</span>, flags [<span class="literal">none</span>], proto UDP (<span class="number">17</span>), <span class="built_in">length</span> <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span><span class="number">.43061</span> &gt; <span class="number">119.75</span><span class="number">.213</span><span class="number">.61</span><span class="number">.33436</span>: [udp <span class="built_in">sum</span> ok] UDP, <span class="built_in">length</span> <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009148</span> IP (tos <span class="number">0x0</span>, ttl <span class="number">2</span>, id <span class="number">5356</span>, <span class="built_in">offset</span> <span class="number">0</span>, flags [<span class="literal">none</span>], proto UDP (<span class="number">17</span>), <span class="built_in">length</span> <span class="number">60</span><span class="comment">)//ttl=2</span></span><br><span class="line"> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> &gt; <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span>: ICMP <span class="built_in">time</span> exceeded <span class="keyword">in</span>-transit, <span class="built_in">length</span> <span class="number">68</span></span><br><span class="line">	IP (tos <span class="number">0x0</span>, ttl <span class="number">1</span>, id <span class="number">942</span>, <span class="built_in">offset</span> <span class="number">0</span>, flags [<span class="literal">none</span>], proto UDP (<span class="number">17</span>), <span class="built_in">length</span> <span class="number">60</span>)<span class="comment"></span></span><br><span class="line"><span class="comment">//第2个路由器回复超时</span></span><br><span class="line">    <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span><span class="number">.52554</span> &gt; <span class="number">119.75</span><span class="number">.213</span><span class="number">.61</span><span class="number">.33437</span>: [udp <span class="built_in">sum</span> ok] UDP, <span class="built_in">length</span> <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009189</span> IP (tos <span class="number">0x0</span>, ttl <span class="number">2</span>, id <span class="number">5357</span>, <span class="built_in">offset</span> <span class="number">0</span>, flags [<span class="literal">none</span>], proto UDP (<span class="number">17</span>), <span class="built_in">length</span> <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span><span class="number">.51967</span> &gt; <span class="number">119.75</span><span class="number">.213</span><span class="number">.61</span><span class="number">.33438</span>: [udp <span class="built_in">sum</span> ok] UDP, <span class="built_in">length</span> <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009243</span> IP (tos <span class="number">0x0</span>, ttl <span class="number">2</span>, id <span class="number">5358</span>, <span class="built_in">offset</span> <span class="number">0</span>, flags [<span class="literal">none</span>], proto UDP (<span class="number">17</span>), <span class="built_in">length</span> <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span><span class="number">.45922</span> &gt; <span class="number">119.75</span><span class="number">.213</span><span class="number">.61</span><span class="number">.33439</span>: [udp <span class="built_in">sum</span> ok] UDP, <span class="built_in">length</span> <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009281</span> IP (tos <span class="number">0x0</span>, ttl <span class="number">3</span>, id <span class="number">5359</span>, <span class="built_in">offset</span> <span class="number">0</span>, flags [<span class="literal">none</span>], proto UDP (<span class="number">17</span>), <span class="built_in">length</span> <span class="number">60</span><span class="comment">)//ttl==3</span></span><br><span class="line">    <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span><span class="number">.34392</span> &gt; <span class="number">119.75</span><span class="number">.213</span><span class="number">.61</span><span class="number">.33440</span>: [udp <span class="built_in">sum</span> ok] UDP, <span class="built_in">length</span> <span class="number">32</span>  </span><br><span class="line">    <span class="number">101.232</span><span class="number">.192</span><span class="number">.1</span> &gt; <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span>: ICMP <span class="built_in">time</span> exceeded <span class="keyword">in</span>-transit, <span class="built_in">length</span> <span class="number">60</span></span><br><span class="line">	IP (tos <span class="number">0x0</span>, id <span class="number">945</span>, <span class="built_in">offset</span> <span class="number">0</span>, flags [<span class="literal">none</span>], proto UDP (<span class="number">17</span>), <span class="built_in">length</span> <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span><span class="number">.57724</span> &gt; <span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span><span class="number">.33440</span>: UDP, <span class="built_in">length</span> <span class="number">32</span><span class="comment"></span></span><br><span class="line"><span class="comment">//第三个路由器回复icmpc超时</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">59.304604</span> IP (tos <span class="number">0x0</span>, ttl <span class="number">59</span>, id <span class="number">0</span>, <span class="built_in">offset</span> <span class="number">0</span>, flags [DF], proto UDP (<span class="number">17</span>), <span class="built_in">length</span> <span class="number">161</span>)</span><br></pre></td></tr></table></figure>

<p>从上面包的情况可以看到:</p>
<ul>
<li>设备首先发送ucp包。若用更详细的打印看到端口号为源55050 目的端口:33443别的设备可能不同，但是都很大，这样到达时会发出端口不可达；ttl字段从1递增，源地址目的地址不变</li>
<li>路由器根据ttl的值，回复icmp超时包，回复给设备，从源地址可以看到，经过的路由器；</li>
<li>该icmp的包格式：<br>类型11  code 0&#x2F;1  校验和<br>ip首部（包括选项)+原始ip数据报中数据的前8个字节</li>
<li>注意：每一次的路由都可能不一样</li>
</ul>
<h5 id="关于ip源站选路选项"><a href="#关于ip源站选路选项" class="headerlink" title="关于ip源站选路选项"></a>关于ip源站选路选项</h5><ul>
<li>ip通常都是动态的，即每个路由都要判断数据报下面该转发到哪个路由器，一般不对此进行控制；这里提供的思想是：</li>
<li>由源站发送者指定路由，即经过哪些ip</li>
<li>分为严格的源路由选择和宽松的源站选路</li>
<li>前者必须采用确切的路由，若发现失败则路由器返回源站选路失败的icmp报文；</li>
<li>后者致命一个数据包经过的ip清单，但是数据包在清单上指明的任意两个地址之间可以通过其他路由器；</li>
<li>ip源站路由选项的格式：<br>包含在ip头部的选项中，因长度有限只能包含9个ip:<br>code(1) len(1) ptr(1) ip1(4) ip2(4)….</li>
<li>eg: traceroute -g 192.168.23.1 <a href="http://www.baidu.com/">www.baidu.com</a></li>
</ul>
<h5 id="traceroute实现"><a href="#traceroute实现" class="headerlink" title="traceroute实现"></a>traceroute实现</h5><ul>
<li>参考linux traceroute源码实现；</li>
<li>主要就是发送一多个dp包设置ttl递增，并将接收到的icmp报文打印出来；直到收到端口不可达报文时退出；</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_routeicmp</title>
    <url>/2018/06/10/tcpip-routeicmp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="IP选路和ICMP协议"><a href="#IP选路和ICMP协议" class="headerlink" title="IP选路和ICMP协议"></a>IP选路和ICMP协议</h3><h4 id="IP如何选路概述："><a href="#IP如何选路概述：" class="headerlink" title="IP如何选路概述："></a>IP如何选路概述：</h4><ul>
<li>ip选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组，区别于选路策略，后者是一组决定把哪些路由放入路由表的规则；ip执行选路机制，而路由守护程序则一般提供选路策略如rip,ospf</li>
<li>点对点时，直接送到  </li>
<li>非点对点时，经过路由器送到  </li>
<li>Ip层可以是配置为路由或者主机前者非则转发，后者非则丢弃</li>
<li>路由表项：每一项为<span id="more"></span><ul>
<li>目的ip地址（网络地址指定网络中所有主机或主机地址);</li>
<li>下一站路由器的ip地址，可能充当中继转发的，下一站非终点；</li>
<li>标志：指明目的地址是网络还是主机，下一站是路由器还是直连的接口</li>
<li>数据传输的网络接口如wlan0,eth0</li>
</ul>
</li>
<li>ip选路是逐跳进行的，</li>
<li>例子：<br>没连接热点前：<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">ernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.42.0.0       *               255.255.255.0   U    <span class="number"> 600 </span>  <span class="number"> 0 </span>      <span class="number"> 0 </span>wlp2s0</span><br><span class="line">link-local      *               255.255.0.0     U    <span class="number"> 1000 </span> <span class="number"> 0 </span>      <span class="number"> 0 </span>wlp2s0```</span><br><span class="line"></span><br><span class="line">连接热点后：</span><br></pre></td></tr></table></figure>
Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>default         192.168.0.1     0.0.0.0         UG    600    0        0 wlp2s0<br>link-local      *               255.255.0.0     U     1000   0        0 wlp2s0</li>
</ul>
<p>192.168.0.0     *               255.255.255.0   U     600    0        0 wlp2s0</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">Destination 	目标网段或者主机</span><br><span class="line">Gateway 	网关地址，”*” 表示目标是本主机所属的网络，不需要路由</span><br><span class="line">Genmask 	网络掩码</span><br><span class="line">Flags 	标记。一些可能的标记如下：</span><br><span class="line">  	U — 路由是活动的</span><br><span class="line">  	H — 目标是一个主机</span><br><span class="line">  	G — 路由指向网关</span><br><span class="line">  	R — 恢复动态路由产生的表项</span><br><span class="line">  	D — 由路由的后台程序动态地安装,(由重定向报文创建）</span><br><span class="line">  	M — 由路由的后台程序修改(已被重定向报文修改）</span><br><span class="line">  	! — 拒绝路由</span><br><span class="line">Metric 	路由距离，到达指定网络所需的中转数（linux 内核中没有使用）</span><br><span class="line">Ref 	路由项引用次数（linux 内核中没有使用）</span><br><span class="line">Use 	此路由项被路由软件查找的次数</span><br><span class="line">Iface 	该路由表项对应的输出接口```</span><br><span class="line"></span><br><span class="line">##### 如何搜索路由表</span><br><span class="line">+ 搜索路由表，目的ip地址匹配条母时，送到该条目的下一站，否则下一步：</span><br><span class="line">+ 搜索路由表，寻找与目的网络相匹配的条目，找到则送到下一站，如本地局域网；否则下一步：</span><br><span class="line">+ 搜索路由表，寻找标为默认的条目，有则使用它</span><br><span class="line">+ 若走完最后一步都没有，则数据包无法被传送，会向生成数据包的程序返回主机不可达或者网络不可达的错误</span><br><span class="line">+ 详细例子见卷１，这里较清楚了</span><br><span class="line"></span><br><span class="line">##### 子网寻址rfc950</span><br><span class="line">+ 主机号再分为子网号和主机号，子网掩码也跟着变化；这样可以缩小路由表规模，想象一个包含<span class="number">30</span>个子网的B类地址和<span class="number">30</span>个C类地址相比</span><br><span class="line">+ 此时，外网--&gt;网关--&gt;局域网１--&gt;局域网１中的子网（局域网）<span class="number">10</span>--&gt;子网<span class="number">11</span>。。。</span><br><span class="line">+ 所以此时网关并非就是其直接路由器，若主机在子网<span class="number">11</span>,<span class="number">10</span>中，路由器需要知道发往哪个子网，通过子网掩码</span><br><span class="line">+ 给定ip地址和子网掩码后能知道什么：</span><br><span class="line">知道该主机所在的子网；路由器可以知道是本子网的主机还是本网络中其他子网的主机还是其他网络的主机。。。路由进行的比较不需要比较到主机，如先比较类别网络地址如A,B,C:  </span><br><span class="line">如我们主机为<span class="number">140.252</span><span class="number">.1</span><span class="number">.1</span>,子掩码为<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>,则与目的ip地址比较：<span class="number">140.252</span><span class="number">.4</span><span class="number">.5</span>,可以知道B类网络地址相同但是子网不同(<span class="number">1</span>,<span class="number">4</span>),就不用再比较主机了，</span><br><span class="line"></span><br><span class="line">#####  特殊的网络地址</span><br><span class="line">##### ifconfig命令</span><br><span class="line">+ ifconfig -a</span><br></pre></td></tr></table></figure>
<p>wlp2s0    Link encap:Ethernet  HWaddr 48:5a:b6:6e:c9:5f<br>          inet addr:192.168.0.110  Bcast:192.168.0.255  Mask:255.255.255.0<br>          inet6 addr: fe80::d713:7c0f:b40c:c085&#x2F;64 Scope:Link<br>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br>          RX packets:7032 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:4297 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:1000<br>          RX bytes:3668623 (3.6 MB)  TX bytes:703812 (703.8 KB)</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">##### netstat命令</span><br><span class="line">+ 其实这个命令的功能很强，可以相互开服务端客户端通信和反向shell</span><br><span class="line">+ netstat -<span class="keyword">in</span></span><br></pre></td></tr></table></figure>
<p>Kernel Interface table<br>Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg<br>enp1s0     1500 0         0      0      0 0             0      0      0      0 BMU<br>lo        65536 0      1404      0      0 0          1404      0      0      0 LRU<br>wlp2s0     1500 0      7257      0      0 0          4311      0      0      0 BMRU</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>netstat -rn<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface<br>0.0.0.0         192.168.0.1     0.0.0.0         UG        0 0          0 wlp2s0<br>169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 wlp2s0<br>192.168.0.0     0.0.0.0         255.255.255.0   U         0 0          0 wlp2s0</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">##### 初始化路由表</span><br><span class="line">+ ifconfig设置接口地址，并用route　命令添加或删除路由表项</span><br><span class="line">##### 主机可以选择转发或者不转发报文</span><br><span class="line">+ 在配置文件中配置ipfordwarding:</span><br><span class="line">+ echo <span class="number">1</span> &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot</span><br><span class="line">#### ICMP协议rfc792</span><br><span class="line">##### Icmp报文：</span><br><span class="line">+ ICMP：IP头(<span class="number">20</span>字节）+ICMP报文</span><br><span class="line">+ IP头：</span><br></pre></td></tr></table></figure>
<pre><code>0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
</code></pre>
<p>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |Version|  IHL  |Type of Service|          Total Length         |<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |         Identification        |Flags|      Fragment Offset    |<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |  Time to Live |    Protocol   |         Header Checksum       |<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |                       Source Address                          |<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |                    Destination Address                        |<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |                    Options                    |    Padding    |<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">其中options和<span class="attribute">padding</span>不一定有</span><br><span class="line">+ ICMP报文：type+<span class="selector-tag">code</span>共同决定ICMP类型，如回显or差错，，，</span><br></pre></td></tr></table></figure>
<p>   0                   1                   2                   3<br>    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |     Type      |     Code      |          Checksum             |<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |       different type and code has different content           |<br>   |                                                               |<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p>
<p>&#96;&#96;&#96;</p>
<ul>
<li>被封装于ip报文中，ip头加icmp,所有报文前四个字节都相同<br>(8位类型，8位代码，16位校验和）</li>
<li>类型+代码决定ICMP的报文类型，种类很多，见协议卷表</li>
<li>下列几种不会导致icmp差错报文：</li>
<li>icmp差错报文；</li>
<li>目的地址为广播地址</li>
<li>作为链路层的广播地址</li>
<li>不是ip分片第一片</li>
<li>源地址不能为零地址，环回地址，广播地址或多播地址</li>
<li>上述是为了防止过去允许icmp差错报文对广播分组带来的广播风暴</li>
<li><h5 id="ICMP协议总结几种类型："><a href="#ICMP协议总结几种类型：" class="headerlink" title="ICMP协议总结几种类型："></a>ICMP协议总结几种类型：</h5></li>
<li>主机不可达</li>
<li>重定向错误</li>
<li>路由发现报文</li>
<li>icmp地址掩码请求和应答</li>
<li>icmp时间戳请求和应答</li>
<li>icmp端口不可达</li>
<li>ping 回显请求：</li>
<li>等等见表</li>
<li>且类型不同发送的报文格式不同</li>
<li>主机不可达：当路由器收到一份ip数据报但是在路由表中搜索后找不到，不能转发时，会发送一份icmp主机不可达的差错报文</li>
<li>还有可能是已经经过了几个路由器后出现主机或网络不可达的情况，所以若是测试局域网，则先让路由器断开网络，ping路由器则确保问题不是在本地，而是在网络上；</li>
<li>icmp重定向错误：<br>举个例子，主机在路由表中搜索后将数据包发给默认路由，R1路由器，接着R1路由器搜索后发送给R2路由器，并同时发现它正在发送的接口(R2)和数据报到达的接口相同，即主机和两个路由器所在lan，即在同一个lan中）此时主机可以直接发送给R2,所以R1就发送一份ICMP重定向报文给主机，这样主机下次就可以直接发给R2了</li>
<li>如何更新路由表?通过ICMP的路由器发现报文：<br>以及利用路由器的定期广播多播它们的路由器通告报文rfc1256,而它一般是由用户守护进程来创建和处理</li>
<li>icmp地址掩码请求和应答，发送对某个ip地址请求地址掩码，并接收到子网掩码。路由器回复或者主机回复</li>
<li>icmp时间戳请求和应答，通过向某个IP主机发送这个，从而得到时间信息，telnet也可以进行，如NTP协议（网络时间协议）</li>
<li>icmp端口不可达：udp报文发送给主机后，若端口不匹配，对方主机会发送端口不可达的差错报文</li>
<li>ping回显，后面有文章记录ping程序编写<h4 id="动态选路"><a href="#动态选路" class="headerlink" title="动态选路"></a>动态选路</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5>上述讲的是静态路由表的情况：适合于1网络较小，2且与其他网络只有单个连接点，3且没有多余的路由时（如主路由失败，可以选择备用路由）；</li>
<li>总结：一种更新路由表的动态协议，从而达到最短路径  </li>
<li>上述三个条件不满足时，通常使用动态选路协议</li>
<li>当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时出现动态选路，路由器之间必须采用选路协议进行通信；路由器上有一个称为路由守护程序的进程，它运行选路协议，并与相邻的路由器通信，根据收到的信息，更新路由表</li>
</ul>
<h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><p>RIP ,OSPF(开放最短路径优先）,BGP</p>
<h5 id="宏观上看"><a href="#宏观上看" class="headerlink" title="宏观上看"></a>宏观上看</h5><p>在internet上，存在大量的主机，路由器等；并以一组自治系统(AS)的方式组织的，每个自治系统通常由单个实体管理，比如大学校园，公司，常常被定义为一个自治系统，NSFNET的internet骨干网形成一个自治系统；</p>
<ul>
<li>自治系统中使用的选路协议，称为内部网关协议IGP或者称为域内选路协议，这些协议有RIP,OSPF</li>
<li>用于不同自治系统之间的路由器，称为外部网关协议EGP,常见有BGP</li>
<li>unix选路守护程序：routed,gated等</li>
</ul>
<h5 id="RIP：rfc1058"><a href="#RIP：rfc1058" class="headerlink" title="RIP：rfc1058"></a>RIP：rfc1058</h5><ul>
<li>rip采用udp报文，端口号位520，为一种采用距离向量的协议,易受攻击</li>
<li>流程：<ul>
<li>初始化：启动一个路由守护进程时，先判断启动了哪些接口，接着在每个接口上发送请求报文，要求其他路由器发送完整的路由表，广播或点对点</li>
<li>接收请求：接收到上述请求后，会回复完整的路由表，否则处理请求报文每一个表项，若有链接到指明地址路由，则度量设置为我们的值，否则设置为16表示无穷大。返回响应</li>
<li>接收到响应后，更新路由表，如增加或修改或删除,采用Dijkstra算法得到最短路径树</li>
<li>定期选路更新，30s一次，进行广播发送完整路由表给相邻的路由器</li>
<li>触发更新：即每当度量发生变化，则对它进行更新，只需要发送度量变化的表项</li>
<li>定时器：3min内无更新路由，则度量设置为无穷大，标注为删除，再过60s删除并传波</li>
</ul>
</li>
<li>注:度量就是跳数，相邻路由度量为１</li>
<li>rip问题：无子网概念；路由器或链路故障要很久才能稳定下来，即收敛慢；易发生环回路由；跳数限制了网络大小15</li>
</ul>
<h5 id="OSPF开放最短路径优先：rfc1247"><a href="#OSPF开放最短路径优先：rfc1247" class="headerlink" title="OSPF开放最短路径优先：rfc1247"></a>OSPF开放最短路径优先：rfc1247</h5><ul>
<li>是一个链路状态协议；</li>
<li>使用ip协议而不是udp.tcp,</li>
<li>不与邻站交换距离信息而是主动测试与其他邻站相连链路状态，并将这些信息发送给它的其他邻站，邻站接着广播出去，每个路由器接收到后更新路由表</li>
<li>收敛快</li>
<li>可以对每个ip服务类型计算各自的路由集，意味着对任何目的，可以有多个路由表表项，每个表项对应一个ip服务类型；</li>
<li>给每个接口指派一个费用，通过吞吐率，往返时间，可靠性等，可以给每个ip服务类型指派一个费用</li>
<li><strong>同一个目的地址存在多个相同费用的路由时，在这些路由上平均分配流量，即流量平衡</strong></li>
<li><strong>支持子网</strong></li>
<li>路由器之间的点对点链路不需要每端都有一个ip地址，－无编号网络，节省ip</li>
<li>多播而非广播</li>
</ul>
<h5 id="BGP边界网关协议rfc1268"><a href="#BGP边界网关协议rfc1268" class="headerlink" title="BGP边界网关协议rfc1268"></a>BGP边界网关协议rfc1268</h5><ul>
<li>自治系统分类：</li>
<li>残桩自治系统，他和其他自治系统只有单个连接，只有本地流量</li>
<li>多接口自治系统，和其他多个自治系统有多个链接，但是拒绝传送流量</li>
<li>转送自治系统，多链接且在一些策略准则下，它可以传送本地流量和通过流量</li>
<li>是距离向量协议，用于自治系统之间，定期发送keepalive报文，30s<h5 id="CIDR无类型域间选路：rfc1518-1519"><a href="#CIDR无类型域间选路：rfc1518-1519" class="headerlink" title="CIDR无类型域间选路：rfc1518,1519"></a>CIDR无类型域间选路：rfc1518,1519</h5>待探索</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title>test_article_picture</title>
    <url>/2018/05/20/test-article-picture/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>##this is a test of picture with test again in 2019</p>
<img src="/2018/05/20/test-article-picture/example.jpg" class="" title="This is an example image">
<p>end</p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>video_encode_format</title>
    <url>/2022/03/26/video-encode-format/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="视频编码压缩基本："><a href="#视频编码压缩基本：" class="headerlink" title="视频编码压缩基本："></a>视频编码压缩基本：</h3><ul>
<li><p>视频是什么？视频是连续的图片，以时间为x轴； <span id="more"></span><br>衡量视频的指标：帧率：FPS:Frame per second,即每秒画面数量，帧率越高，越流畅</p>
</li>
<li><p>视频的存储和传输：<br>没有经过编码压缩的视频，是一个图片一个图片构成的，那么：<br>一个视频，如果未经编码，它的体积是非常庞大的。以一个分辨率1920×1280，帧率30的视频<br>为例。1920×1280&#x3D;2,073,600（Pixels 像素）每个像素点是24bit（前面算过的哦）也就是每幅<br>图片2073600×24&#x3D;49766400bit   8 bit（位）&#x3D;1 byte（字节），所<br>以，49766400bit&#x3D;6220800byte≈6.22MB。这是一幅1920×1280图片的原始大小，再乘以帧率<br>30，也就是说，每秒视频的大小是186.6MB，每分钟大约是11GB，一部90分钟的电影，约是<br>1000GB。。。如果按照100M的网速（12.5MB&#x2F;s），下刚才那部电影，需要22个小时  </p>
</li>
<li><p>视频的压缩(编码)：编码就是为了压缩，即把原视频格式文件转换成另外一种格式文件  </p>
</li>
<li><p>编码的方式,如何压缩：<br>采集设备采集一帧图像会生成无损的**.bmp文件格式的图片文件，一个6M通过有损压缩得到200kb的JPEG文件，压缩比就是1&#x2F;30。<br>但是视频不需要单独传输一张张压缩图，只需要记录每帧之间的差别即可。于是，根据I帧（200K原始图像）生成差异文件P帧，通过I帧和P帧再生成B帧。<br>这，就是H.264编码。</p>
</li>
</ul>
<p>编码压缩就像魔术一般，一段视频，如果经过编码压缩后，可以大幅度的缩小体积。而各种不同的压缩算法就是编码格式**，如今主流的音视频编码格式就是H.264+AAC，视频内容经过编码压缩大幅度的减少体积后，有利于存储和压缩。但是相应的，传输时也是被压缩算法所“加密”的视频。所以，在播放端也需要一个“解密”的过程。 因此，在编码和解码之间，显然需要一个编码器和解码器都可以理解的约定，就图像而言：生产端的编码器将多张图像进行编码后生成一段端的GOP（Group of pictures）， 播放端的解码器则是读取一段段的GOP解码后读取画面再渲染显示。<br>举个例子，如果一幅图（1920×1080分辨率），全是红色的，我有没有必要说2073600次[255,0,0]？我只要说一次[255,0,0]，然后再说2073599次“同上”，即去除冗余信息：冗余信息和编码：</p>
<img src="/2022/03/26/video-encode-format/1.png" class="" title="tes">


<ul>
<li>视频编码优先消除空间冗余和时间冗余：<br>空间冗余：即一张图片的重复信息<br>时间冗余：即图片和图片之间的重复信息；<br>于是出现了I,P,B帧的策略；</li>
</ul>
<img src="/2022/03/26/video-encode-format/2.png" class="" title="tes">

<ul>
<li>I,P,B帧：</li>
</ul>
<p>视频是由不同的帧画面连续播放形成的；这些帧，分为三类，即I帧，P帧，B帧：<br>I帧：是自带全部信息的独立帧，是最完整的画面（占用的空间最大），无需参考其它图像便可独立进行解码。视频序列中的第一个帧，始终都是I帧<br>P帧：帧间预测编码帧”，需要参考前面的I帧和&#x2F;或P帧的不同部分，才能进行编码。P帧对前面的P和I参考帧有依赖性。但是，P帧压缩率比较高，占用的空间较小<br>B帧：“双向预测编码帧”，以前帧和后作为参考帧。不仅参考前面，还参考后面的帧，所以，它的压缩率最高，可以达到200:1。不过，因为依赖后面的帧，所以不适合实时传输（例如视频会议）  </p>
<img src="/2022/03/26/video-encode-format/3.png" class="" title="tes">
<ul>
<li>视频中图像的切块：</li>
</ul>
<p>即并不是按照一张图片(比如分辨率为1920*1080)而是把图像切割为不同的“块（Block）”或“宏块（MacroBlock）”，对它们进行计算。一个宏块一般为16像素×16像素  </p>
<ul>
<li><p>帧内和帧间，即上面提到的空间冗余去除和时间冗余去除：</p>
<img src="/2022/03/26/video-encode-format/4.png" class="" title="tes">
<p>帧内处理：</p>
<img src="/2022/03/26/video-encode-format/5.png" class="" title="tes">

</li>
<li><p>IDR帧，PTS,DTS,GOP:<br>IDR:把第一个首个I帧叫IDRPTS：Presentation Time Stamp。PTS主要用于度量解码后的视频帧什么时候被显示出来<br>DTS：Decode Time Stamp。DTS主要是标识读入内存中的bit流在什么时候开始送入解码器中进行解码。<br>DTS主要用于视频的解码,在解码阶段使用.PTS主要用于视频的同步和输出.在display的时候使用.在没有B frame的情况下.DTS和PTS的输出顺序是一样的.  </p>
</li>
<li><p>衡量编码的效果：信噪比&#x2F;峰值信噪比；客观人眼评价  </p>
</li>
<li><p>一个视频的采集，编码解码过程：</p>
<img src="/2022/03/26/video-encode-format/6.png" class="" title="tes"></li>
</ul>
<h4 id="视频编码相关标准组织："><a href="#视频编码相关标准组织：" class="headerlink" title="视频编码相关标准组织："></a>视频编码相关标准组织：</h4><ul>
<li>ITU（国际电信联盟）<img src="/2022/03/26/video-encode-format/7.png" class="" title="tes"></li>
<li>ISO&#x2F;IEC：<br>ISO和IEC联合成立了一个专家组，负责开发电视图像数据和声音数据的编码、解码和它们的同步等标准。这个专家组，就是大名鼎鼎的MPEG，Moving Picture Expert Group（动态图像专家组）</li>
<li>ITU和ISO&#x2F;IEC的关系：<br>ITU提出了H.261、H.262、H.263、H.263+、H.263++，这些统称为H.26X系列，主要应用于实时视频通信领域，如会议电视、可视电话等。<br>ISO&#x2F;IEC提出了MPEG1、MPEG2、MPEG4、MPEG7、MPEG21，统称为MPEG系列。<br>ITU和ISO&#x2F;IEC一开始是各自捣鼓，后来，两边成立了一个联合小组，名叫JVT（Joint Video Team，视频联合工作组）。</li>
</ul>
<img src="/2022/03/26/video-encode-format/8.png" class="" title="tes">
<img src="/2022/03/26/video-encode-format/9.png" class="" title="tes">
<img src="/2022/03/26/video-encode-format/10.png" class="" title="tes">

<h4 id="视频加音频：封装技术："><a href="#视频加音频：封装技术：" class="headerlink" title="视频加音频：封装技术："></a>视频加音频：封装技术：</h4><p>只有视频，则是无声的，所以需要加上音频才完整：<br>封装，就是封装格式，简单来说，就是将已经编码压缩好的视频轨和音频轨按照一定的格式放到一个文件中。再通俗点，视频轨相当于饭，而音频轨相当于菜，封装格式就是一个饭盒，用来盛放饭菜的容器。<br>目前主要的视频容器有如下：MPG、VOB、MP4、3GP、ASF、RMVB、WMV、MOV、Divx、MKV、FLV、TS&#x2F;PS等。</p>
<h4 id="互联网视频播放过程："><a href="#互联网视频播放过程：" class="headerlink" title="互联网视频播放过程："></a>互联网视频播放过程：</h4><img src="/2022/03/26/video-encode-format/11.png" class="" title="tes">
<p>解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。</p>
<p>解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。</p>
<p>解码的作用，就是将视频&#x2F;音频压缩编码数据，解码成为非压缩的视频&#x2F;音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。</p>
<p>视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来</p>
<h4 id="流媒体传输协议："><a href="#流媒体传输协议：" class="headerlink" title="流媒体传输协议："></a>流媒体传输协议：</h4><p>区分于视频封装，即视频文件，流媒体传输的是视频，但是不是以视频文件容器的形式传递的，除非下载整个视频文件，但这时也会封装更多的数据，以便于传输；<br>所以流媒体传输协议就是为了便于网络传输(带宽，网络复杂性等)，将视频数据和音频数据，以一定的格式和头，控制信息等封装起来形成一个包，并载于tcp&#x2F;udp上传输的协议；<br>流媒体传输会存在两种需求：顺序流式传输（progressive streaming）和实时流式传输（real time streaming）。<br>从本质上讲，直播就是一帧帧的数据加上时序标签流式传输。 这里有个悖论：一个容器封装好后的视频是“结构化”的，即不可变的，那直播又是怎么产生的呢？或者说，怎么去打破这个已经产生的“结果”，从而还往里面加上时序标签流式传输的呢？ 很简单，那就是**“边生产边传输边播放”</p>
<ul>
<li>所以在直播流中，为了保证一些特性：比如音视频同步，实时播放等，需要做一些处理：</li>
</ul>
<ol>
<li>传输中音画同步dts<br>2）传输中实时携带解码信息，比如每个I帧都带视频头等；<br>3）本地保存流头，在拉流时先下发头；</li>
</ol>
<h4 id="顺序传输和实时传输："><a href="#顺序传输和实时传输：" class="headerlink" title="顺序传输和实时传输："></a>顺序传输和实时传输：</h4><ul>
<li><p>顺序流式传输（progressive streaming）的特点：期望音视频数据无错误无丢失顺序的从一端传输到另一端，<br>例如警方对视频监控录像回放取证、网络电影播放等都需要数据正常到达然后解码播放，<br>对于这种情况一般采用可靠的 tcp 方式传输。  </p>
</li>
<li><p>实时流式传输（real time streaming）的特点：期望音视频数据实时的的从一段传输到另一端，<br>例如数字电视行业的电视直播，由于 tcp 的包确认机制的开销大，基于窗口的拥塞控制技术不<br>太适应稳定的流媒体传输，tcp 重传机制对实时流没有必要，对于这种情况一般采用 udp 方式传输。  </p>
</li>
<li><p>解决方案为：http（基于 tcp）做控制信息的传输，rtp（基于udp）做实时数据流的传输；http live streaming (hls) 码流自适应也可作为实时流传输的解决方案<br>直播就是将每帧数据（Video&#x2F;Audio&#x2F;Data Frame(元信息)），打上时序标签后进行流式传输的过程。<br>发送端源源不断的采集音视频数据，经过编码、封包、推流，再经过中继分发网络进行扩散传播。<br>播放端则源源不断的下载数据并按时序进行解码播放。 这样就完成了“边生产、边传输、边播放”的直播过程了。<br> 简而言之，视频直播技术，就是将视频内容的最小颗粒（I&#x2F;P&#x2F;B帧）,基于时序标签，以流式传输的一种技术。</p>
</li>
<li><p>PS:GOP越长，所包含的B帧和P帧越多，响应的压缩比也会更高。<br> GOP越短，I帧比例增高，压缩比增加，同码率下视频质量会下降。</p>
</li>
</ul>
<h4 id="下载视频，点播，边下边播，直播；"><a href="#下载视频，点播，边下边播，直播；" class="headerlink" title="下载视频，点播，边下边播，直播；"></a>下载视频，点播，边下边播，直播；</h4><ul>
<li><p>从流媒体传输的方式看，有：<br>渐进式下载：即边下边播：属于本地播放<br>单纯文件下载：属于本地播放  </p>
</li>
<li><p>点播即在线播放：索引文件包含所有切片下载地址，依次下载切片文件。建立一个Connection，边下边播，实时传输</p>
</li>
</ul>
<h4 id="直播中的关键词："><a href="#直播中的关键词：" class="headerlink" title="直播中的关键词："></a>直播中的关键词：</h4><p>码率，转码等</p>
<h4 id="流媒体相关协议："><a href="#流媒体相关协议：" class="headerlink" title="流媒体相关协议："></a>流媒体相关协议：</h4><p>FLV,RTMP,HLS，RTP,RTCP等。</p>
<ul>
<li>直播：实时更新索引文件，根据索引文件下载切片文件建立一个Connection，边放边播，实时更新流。</li>
</ul>
]]></content>
      <categories>
        <category>video</category>
      </categories>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>我理解的心理模型</title>
    <url>/2020/04/04/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E5%BF%83%E7%90%86%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下内容均为本人构想理解提出，如有雷同纯属巧合，仅为本人粗略观点，不期赞同；</p>
<h3 id="一、模型概念"><a href="#一、模型概念" class="headerlink" title="一、模型概念"></a>一、模型概念</h3><h4 id="1）模型的广义解释"><a href="#1）模型的广义解释" class="headerlink" title="1）模型的广义解释"></a>1）模型的广义解释</h4><p>模型用于抽象化一类事物的特点和规律，甚至是发展周期；模型常见有数学模型，物理模型，工业模型等等；<span id="more"></span><br>如数学模型，是用来处理一类问题，通过输入，模型处理，得到想要的预测输出，模型常用来预测和计算问题的结果和答案；逼近结果甚至计算出结果本身；最简单如: 1天卖10斤菜，预测10天卖多少斤这种简单问题，则模型就是10*天数；输入就是天数，输出就是卖了多少斤；复杂一点可以加上条件，阴天卖多少斤，晴天卖多少斤，阴天有几天，或者甚至让你预测天气等等；</p>
<h4 id="2）复杂的模型"><a href="#2）复杂的模型" class="headerlink" title="2）复杂的模型"></a>2）复杂的模型</h4><p>用于解释数学的模型，还可以用来解释更多内容，并归结升级到当下流行的人工智能中的机器学习模型和深度学习等等；这些大部分也是通过输入和模型获得输出；而模型的建立将是一个很复杂繁琐的过程；模型的正确性也是个重要因素；</p>
<h3 id="二、心理模型"><a href="#二、心理模型" class="headerlink" title="二、心理模型"></a>二、心理模型</h3><h4 id="1）起源"><a href="#1）起源" class="headerlink" title="1）起源"></a>1）起源</h4><p>PS: 博主其实从初中就开始关注心理学，不过没有深入了解；最初想探寻人的心理模型，是在博主遇到19年创伤事件后，不明白心理为什么会出现如此变化；且还没有去借助外在心理学知识来解释，尝试自己去理解时，总结出来的；</p>
<h5 id="（1）动物行为基本分析："><a href="#（1）动物行为基本分析：" class="headerlink" title="（1）动物行为基本分析："></a>（1）动物行为基本分析：</h5><p>​       动物通过感知周围的环境刺激如食物，猎食者等，和自身的内在刺激如饥饿等，输入，进入到自己的简单模型，处理后进行反应即输出，比如见到猎食者，输入刺激，模型处理的结果是要逃跑，于是反应为逃跑等等；而动物的几乎一切的行为活动，贯穿一生，都是这样度过的；所以动物的本质，是个输入输出模型；从这个角度理解的话。</p>
<h5 id="（2）人类"><a href="#（2）人类" class="headerlink" title="（2）人类"></a>（2）人类</h5><p>​       人类其实也是动物，只是因为人类有高级的模型，所以能使得有控制输入输出，以及控制模型的能力；但因为基因和自身的认知等影响，导致不同的人对这些控制能力不同，就算是最强的人，对这些控制也不是100%的；</p>
<p>​        人的模型很复杂，人需要适应多变的环境，并安稳的生存下来，需要得到更多的信息，来应对种种危险等等；所以人类进化出了各种感官器，处理器如最强的大脑；内在神经感受器等等；</p>
<h4 id="2）模型基本框架"><a href="#2）模型基本框架" class="headerlink" title="2）模型基本框架"></a>2）模型基本框架</h4><p>人的心理模型在：</p>
<p>外界的输入–&gt;人对应的感受器–&gt;进入处理器模型–&gt;决策后输出；</p>
<p>以下是处理器模型，优先从第一层传递到第五层；</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">第五层<span class="symbol">:---------</span>自我意识：理性思考(一般有多个)------------</span><br><span class="line">第四层<span class="symbol">:-------</span>受限的自我意识：感受----------------------</span><br><span class="line">第三层：------受约束的自我意识：道德，法律-----------------</span><br><span class="line">第二层：------潜意识，习惯-----------------------------</span><br><span class="line">第一层：------身体，物理感受和直接处理------------------</span><br></pre></td></tr></table></figure>

<p>身体：比如膝跳反应等；</p>
<p>潜意识习惯：比如交流中的口头禅等；</p>
<p>其他类似；总是先经过第一层，第一层处理不了或者不需要则往上传递；严格来说也不是层级关系，是一种分类的处理；</p>
<p>输入输出方式：</p>
<p>可以分为两种：</p>
<p>1、接收输入，处理(处理包括思维层面，感受等等)，表现出来输出(可能是行为或者单纯的感受并会存储记忆，内反馈形成下次处理同类型问题的经验或者进步)；</p>
<p>2、进行输出(可能之前得到输入或单纯想输出)，得到输入，处理，感受；</p>
<h4 id="3）人心理模型的基本组成分析"><a href="#3）人心理模型的基本组成分析" class="headerlink" title="3）人心理模型的基本组成分析"></a>3）人心理模型的基本组成分析</h4><h5 id="（1）-组成：输入源，感受器，处理器，输出器"><a href="#（1）-组成：输入源，感受器，处理器，输出器" class="headerlink" title="（1） 组成：输入源，感受器，处理器，输出器"></a>（1） 组成：输入源，感受器，处理器，输出器</h5><h5 id="（2）各个组成分析："><a href="#（2）各个组成分析：" class="headerlink" title="（2）各个组成分析："></a>（2）各个组成分析：</h5><h6 id="A-输入源："><a href="#A-输入源：" class="headerlink" title="A 输入源："></a>A 输入源：</h6><p>​    一个是外部输入源，对应于第一种方式：输入-&gt;处理-&gt;输出的方式：很多，几乎是无限的，而感受器却只有有限种类型，而为了缔结输入源，感受器和输出等的联系，所建立的缔结关系，也是无限的；即体现为知识，能力等等；输入源举例：不同的食物，不同的感受刺激如漂亮的花朵等等；深层的如赞美的话，得到礼物等等，其他人也是一种输入源；</p>
<p>​     一个是内部的输入源：对应于第二种方式：输出-&gt;输入-&gt;处理的方式：很多，推理，瞎想，想象，创作等等；甚至简单如思考后的说话等等；</p>
<h6 id="B-感受器："><a href="#B-感受器：" class="headerlink" title="B 感受器："></a>B 感受器：</h6><p>   感受器目前我了解到的有：</p>
<p>外在实体：触觉，嗅觉，味觉，听觉，视觉，痛觉，温觉；</p>
<h6 id="C-处理器："><a href="#C-处理器：" class="headerlink" title="C 处理器："></a>C 处理器：</h6><p> 见上图；最低层次为身体，这个和动物也类似，即本能，人会本能的躲避危险，碰到烫的东西会自动收回；这些是不经过大脑的；</p>
<p>接着是潜意识和习惯等，大部分没有被大脑意识到；这个层面反应很快；类似口头禅，可以理解为一个map,针对某个输入，有确定的输出；所以往往直接表现出来；</p>
<p>接着是感受和道德层面：某个事物让自己感受到开心或伤心，可能还来不及去考虑，就直接反应，而道德法律也是，即自己的底线；这种一般不用思考；这个其实也是意识层面，只是是较浅的意识；当然有些人是感受强势些，有些人是理性意识强势些；</p>
<p>意识层面：即在感受和道德无法做决定时，则到了意识层面，经过处理后得到反应；而这个层面的思考，取决于人的认知，学识，智慧，即智商，情商等等；更多的是：涉及计算，规律，预测，分析问题本质，多因素考虑等等；</p>
<h6 id="D-输出器"><a href="#D-输出器" class="headerlink" title="D 输出器"></a>D 输出器</h6><p>​    内在感受：快乐感受器，悲伤感受器，愤怒感受器，害怕感受器等自尊感受器，安全感受器，归属感，等等；基本感受表现器，这个和输入其实息息相关；只有很少的处理过程；比如快乐往往很简单；不用经过太多的思考；偏向于对应于输入输出方式</p>
<p>输出方式也有：行为，选择决策，语言等等；</p>
<h4 id="4）人类模型的复杂度分析"><a href="#4）人类模型的复杂度分析" class="headerlink" title="4）人类模型的复杂度分析"></a>4）人类模型的复杂度分析</h4><p>(1)  人的感受器丰富，不仅有外在感受器如：视觉，听觉，触觉，嗅觉，味觉，还有如痛觉等内在感受器，甚至高级的自尊感，安全感，归属感等等一些进化的非显性但是实际存在的感觉器；（这些感受器大多是因为社交体系，和他人的情感体系环境下产生的，和等级等观念也相关）</p>
<p>(2)  人的感受器特性：感受器有个特点，对初次刺激记忆最深，敏感度最高，对之后的相同刺激习惯了，就显得表现的不是很强烈，可能是因为进化的原因，第一次不知道是不是危险，所以显得最警惕，之后熟悉了便失去了焦点；所以才会有腻了，味觉疲劳等现象；而对于隔了很久的没有的刺激，再次刺激也会有比较大的反应，这个也是很容易理解的；也就是边际递减效应；</p>
<p>(3)  外界输入类型的多样性，有些输入是人类自身创造的；而这个太多了；比如游戏；</p>
<p>(4)  人的处理器复杂度高：正常处理：输入到达身体层面能处理则不会传递上去：如人碰到烫的东西自动收回等等；若能传递，则到潜意识，接着到意识进行逻辑等处理，而意识层面的处理是最复杂的；</p>
<p>(5)  人的感受器对应的是输入，而人的一部分感受器可以作为输出，而输出同样也是复杂，不同类型的人不同环境下等等输出的效果可能类似，但是输出方式不同；</p>
<h3 id="三、详解输入源等"><a href="#三、详解输入源等" class="headerlink" title="三、详解输入源等"></a>三、详解输入源等</h3><p>输入源分为外部输入源和内部输入源：当你的输入源能量大，形成一个能量场，别人也会被你吸引，到你的能量场，于是你可能成为别人眼中的有趣的人；而最好这些不要太过依赖外部能量的提供；生活的品质和热爱表现于此；</p>
<p>1） 外部输入源：</p>
<p>划分方式1：根据特性划分</p>
<p>人或其他活物：亲人朋友爱人，崇拜对象，宠物等等，这种可以提供长期的源，和刺激；</p>
<p>一次性物：食物，视频等等</p>
<p>游戏&#x2F;竞技&#x2F;运动：同时刺激多个感官，而且高反馈即时反馈的特性让人享受其中；</p>
<p>…</p>
<p>划分方式2：根据归属划分：</p>
<p>现实物理世界日常活动：</p>
<p>吃-食物和怎样获取食物：自己下厨，外卖刷剧，堂食探索，各种体验不同；</p>
<p>穿-衣服化妆护肤等颜值相关，保暖舒适好看漂亮气质吸引别人等等；</p>
<p>住-居家环境宜家家居：居住环境构成和特点：干净整洁安全安静床舒适度气味等等；</p>
<p>行-交通工具：汽车高铁公交飞机走路自行车跑步平衡车轮滑等不同体验；空间方位认路等体验；”</p>
<p>健康-健身等；喝茶泡脚吃等等，</p>
<p>纯玩：打球游戏等等；</p>
<p>工作-知识技能解决问题需求，</p>
<p>社交-人</p>
<p>网络世界：游戏，视频媒体，文字信息，虚拟化，创作编程等，社交购物等和现实挂钩的，统称信息；而媒介可以是手机，平板，电脑，手表，智能硬件等等；</p>
<p>2） 内部输入源：</p>
<p>内心世界：</p>
<p>关系情感：友情爱情亲情等；</p>
<p>欲望：性，贪，懒</p>
<p>自尊自信等需求；</p>
<h3 id="四、心理模型的影响因素和发展周期"><a href="#四、心理模型的影响因素和发展周期" class="headerlink" title="四、心理模型的影响因素和发展周期"></a>四、心理模型的影响因素和发展周期</h3><ol>
<li><p>模型的影响因素：基因，家庭环境，学校环境，社会环境；环境包括人；</p>
</li>
<li><p>模型的变化特性：人格，气质，性格，等是不容易变化的，可以理解为硬编码，强缔结；而意识层面涉及情商，智商等认知是容易改变的，而道德，感受涉及三观等等，也是能改变的，不过比意识层面更难；</p>
</li>
<li><p>模型的发展周期：</p>
</li>
</ol>
<p>人诞生时，是婴儿时期，此时还未被环境影响，各个感受器处于初始状态；模型原始由基因决定；婴儿期性本善，性本偏外向</p>
<p>孩童时期：在接受家庭环境影响，父母等影响后，感受器特质发生改变，此时比如接收到的某种刺激较少，比如爱，则缺爱，则长大后，第一次感受到爱后，会比别人表现更强烈；内向或者外向：一开始是外向的，通过输出能量，但是得到的反馈，输入进来的时候被判断为不好的感受，即负能量，则长此以往，则不愿意再去输出，形成内向的性格，即只喜欢输出到内部环境；</p>
<p> 青少年：开始受到身体激素影响，并开始更理性的关注周围的事物，受到学校影响较大；</p>
<p> 成年期：模型基本稳定，会轻微调整，不过受到创伤等大事会重新建立等；</p>
<p>PS:模型的影响，包括模型的感受器，处理器和表现(输出);感受器的特质:敏感度等是能被随着发展周期改变的；</p>
<p>学校环境：更多的是改变道德，感受和意识层面，少量的改变潜意识和习惯；</p>
<h3 id="五、用此心理模型来解释一些心理现象"><a href="#五、用此心理模型来解释一些心理现象" class="headerlink" title="五、用此心理模型来解释一些心理现象"></a>五、用此心理模型来解释一些心理现象</h3><p>1） 人格：人格指一个人在一定情况下所作行为反应的特质，即人们在生活、工作中独特的行为表现，包括思考方式、决策方式等；包括了内向外向，感觉直觉，思考情感，判断知觉；</p>
<p>内向外向：内向的人偏向于第一种方式：即输入-&gt;处理-&gt;输出；而外向的人偏向于输出-&gt;处理-&gt;输入的方式；和小时候的经历等有关；</p>
<p>感觉直觉：获取信息的方式：是感官获取听到看到还是自己推理瞎想；模型解释：感官感觉针对第一种输入输出方式:即输入-&gt;处理-&gt;输出，而直觉：第二种：输出-&gt;输入-&gt;处理，而输入往往作为一种验证的方式；</p>
<p>思考情感：决策方式：对应于模型中的处理器中的意识层面中哪个占主导，是感受还是理性；而这其中其实还有道德在作用；</p>
<p>判断还是知觉：喜欢做计划还是灵活处理适应环境？做计划其实是由内而外，因为计划是偏向于自己做的，且更容易控制，而适应环境则是针对环境的输入，来做对应的输出，针对的是第一种输入输出方式，所以和内向外向有关；可能还涉及到安全感等；</p>
<p>2） 气质：其实是一个人的输出，表现，这个多是自我的主动输出，少部分是针对输入做的输出；气质，这个词太虚：</p>
<p>来看普世解释：气质是人的个性心理特征之一，它是指在人的认识、情感、言语、行动中，心理活动发生时力量的强弱、变化的快慢和均衡程度等稳定的动力特征。主要表现在情绪体验的快慢、强弱、表现的隐显以及动作的灵敏或迟钝方面，因而它为人的全部心理活动表现染上了一层浓厚的色彩。</p>
<p>可以理解为感受器，表现器的特质吧；</p>
<h3 id="六、马斯洛需求解释"><a href="#六、马斯洛需求解释" class="headerlink" title="六、马斯洛需求解释"></a>六、马斯洛需求解释</h3><p>最高层面的即价值，自我实现，创造等等，即对应了模型类别中的输出类模型，即模型本身偏向于输出源，能源源不断的给其他人(模型)提供输入，所以其他模型在感兴趣的情况下，被吸引，建立缔结，从而记得记住这个人；所以这个人的价值被体现出来；</p>
<p>尊重需要：更深层次的内在感受器，凌驾于开心等之上，表现为舒适，满足，安全，信心等等；</p>
<p>社会需要：亲情，爱情，友情：实际上是和某个输入源(包括方式1和2)，缔结了强烈的关系，这个源能提供源源不断的输入，好的或不好的，但是缔结的联系深深的印在脑子里了；所以一旦这个源不存在了，就体现为难受，其实这是一种上瘾；所以这种情况可以是建立一个相似的输入源不同的缔结；或者等自己适应了这种缔结的消失，而不再需要这种缔结；类似的还有和动物的情感，特殊物品的情感等等；</p>
<p>安全需要：安全感：财产人身等安全，工作等：这个是属于内在高级的感受器：但是它可能依赖的东西并不高级，因人而异，比如在一间新房子还是旧房子里；</p>
<p>生理需求：吃喝拉撒睡性穿住行；身体需求层面，本能，低级感受器；</p>
<p>没有了身体，就没有大脑，所以身体的感受是最强烈的但是短暂，而越靠近上层，感觉越不强烈但是可能长远；除非，和身体的感受形成了缔结；</p>
<p>预测行为；了解自己行动原因，深层原因，从而改变自己，完善自己，善待自己；</p>
<h3 id="七、模型和现代互联网AI"><a href="#七、模型和现代互联网AI" class="headerlink" title="七、模型和现代互联网AI"></a>七、模型和现代互联网AI</h3><p>模型编程和如何塑造一个你，TODO</p>
]]></content>
      <categories>
        <category>心理</category>
      </categories>
  </entry>
  <entry>
    <title>c++_keyword</title>
    <url>/2021/05/23/c-keyword/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c-中的关键字和基本解释"><a href="#c-中的关键字和基本解释" class="headerlink" title="c++中的关键字和基本解释"></a>c++中的关键字和基本解释</h3><h5 id="alignas"><a href="#alignas" class="headerlink" title="alignas:"></a>alignas:<span id="more"></span></h5><ul>
<li>语法：<br>alignas( expression ) 即expression是值为合法正数常量的表达式，可以是0或者其他1，2,4这种2的n次方值<br>alignas( type-id )    即类型，比如alignas(int)，等价于alignas(alignof(type))<br>alignas( pack … ) 等价于应用于同一声明的多个alignas说明符，一个用于 parameter pack的每个成员，形参包可以是type parameter pack，也可以是non-type parameter pack  </li>
<li>解释：<br>用于对齐：</li>
</ul>
<ol>
<li>class&#x2F;struct&#x2F;union或enum类型的声明或定义中的字节对齐  </li>
<li>类数据成员中的非位域类型的字节对齐  </li>
<li>变量的声明的对齐，除了函数参数和exception 中catch中的参数；<br>由这种声明声明的对象或类型的对齐要求将等于声明中使用的所有alignas说明符中最严格的(最大的)非零表达式，但它不会削弱类型的自然对齐，即最小是该类型的字节数对齐：<br>如果声明上最严格(最大)的对齐比没有任何对齐说明符时的对齐要弱(也就是说，弱于它的自然对齐或弱于同一对象或类型的另一个声明上的对齐)，则程序是非法的:<br>eg: 不允许</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">alignas</span>(<span class="number">1</span>) <span class="type">int</span> a; <span class="comment">//error</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">8</span>) S &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">1</span>) U &#123; S s; &#125;; <span class="comment">// error: alignment of U would have been 8 without alignas(1)</span></span><br><span class="line">无效值不能用于对齐：如<span class="built_in">alignas</span>(<span class="number">3</span>);,若是<span class="number">0</span> ，则被忽略</span><br><span class="line">Note: c++<span class="number">11</span>才有的关键字：</span><br><span class="line">As of the ISO C11 standard, the C language has the _Alignas keyword <span class="keyword">and</span> defines <span class="keyword">alignas</span> as a preprocessor macro expanding to the keyword in the header &lt;stdalign.h&gt;, but in C++ <span class="keyword">this</span> is a keyword, <span class="keyword">and</span> the headers &lt;stdalign.h&gt; <span class="keyword">and</span> &lt;cstdalign&gt; (until C++<span class="number">20</span>) <span class="keyword">do</span> <span class="keyword">not</span> define such macro. They <span class="keyword">do</span>, however, define the macro constant __alignas_is_defined.</span><br><span class="line">例子：</span><br><span class="line"><span class="comment">// every object of type struct_float will be aligned to alignof(float) boundary</span></span><br><span class="line"><span class="comment">// (usually 4)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="type">float</span>) struct_float &#123;</span><br><span class="line">    <span class="comment">// your definition here</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// every object of type sse_t will be aligned to 256-byte boundary</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">256</span>) <span class="type">sse_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> sse_data[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// the array &quot;cacheline&quot; will be aligned to 128-byte boundary</span></span><br><span class="line"><span class="built_in">alignas</span>(<span class="number">128</span>) <span class="type">char</span> cacheline[<span class="number">128</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sse_t</span> x, y, z;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">default_aligned</span> &#123; <span class="type">float</span> data[<span class="number">4</span>]; &#125; a, b, c;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;alignof(struct_float) = &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(struct_float) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;alignof(sse_t) = &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">sse_t</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;alignof(alignas(128) char[128]) = &quot;</span> </span><br><span class="line">                  &lt;&lt; <span class="built_in">alignof</span>(<span class="built_in">alignas</span>(<span class="number">128</span>) <span class="type">char</span>[<span class="number">128</span>]) &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase</span><br><span class="line">              &lt;&lt; <span class="string">&quot;&amp;x: &quot;</span> &lt;&lt; &amp;x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;&amp;y: &quot;</span> &lt;&lt; &amp;y &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;&amp;z: &quot;</span> &lt;&lt; &amp;z &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;&amp;a: &quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;&amp;b: &quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;&amp;c: &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">alignof</span>(struct_float) = <span class="number">4</span></span><br><span class="line"><span class="built_in">alignof</span>(<span class="type">sse_t</span>) = <span class="number">256</span></span><br><span class="line"><span class="built_in">alignof</span>(<span class="built_in">alignas</span>(<span class="number">128</span>) <span class="type">char</span>[<span class="number">128</span>]) = <span class="number">128</span></span><br><span class="line"> </span><br><span class="line">&amp;x: <span class="number">0x7fffd901bb00</span></span><br><span class="line">&amp;y: <span class="number">0x7fffd901bc00</span></span><br><span class="line">&amp;z: <span class="number">0x7fffd901bd00</span></span><br><span class="line">&amp;a: <span class="number">0x7fffd901bad0</span></span><br><span class="line">&amp;b: <span class="number">0x7fffd901bae0</span></span><br><span class="line">&amp;c: <span class="number">0x7fffd901baf0</span></span><br></pre></td></tr></table></figure>

<h5 id="关于字节对齐的解释："><a href="#关于字节对齐的解释：" class="headerlink" title="关于字节对齐的解释："></a>关于字节对齐的解释：</h5><p>对齐是指，访问的变量是按照指定的对齐(或类型本身大小)来寻址的，则比如int ，则按4的整数倍地址寻址，所以分给int这个变量的地址需要可以被4B整除；<br>放在struct中，体现为该成员的地址是可以被4整除，所以前面至少是4B，若前面是char 则填充3个字节；由此，还需要考虑到struct数组或单纯int数组的情况，前后之间需要对齐：<br>两个典型例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">9</span>];</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">16</span>) <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;</span><br><span class="line">考虑最大的<span class="number">16</span>，则a这里要填充<span class="number">7</span>才能保证访问b的地址是<span class="number">16</span>字节对齐的，按道理加完就是<span class="number">33</span>，但是如果是数组，下个<span class="keyword">struct</span>结构就不是<span class="number">16</span>对齐的，或者说<span class="keyword">struct</span>基地址本身也要是<span class="number">16</span>对齐的，所以</span><br><span class="line">应该是<span class="number">48</span>；  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">long</span> <span class="type">double</span> a; <span class="number">16B</span></span><br><span class="line">     <span class="built_in">alignas</span>(<span class="number">32</span>) <span class="type">int</span> b;</span><br><span class="line">     <span class="type">int</span> *c;</span><br><span class="line">     <span class="type">int</span> d;</span><br><span class="line">&#125;</span><br><span class="line">这里考虑最大<span class="number">32</span>，则a要填充<span class="number">16</span>-&gt; <span class="number">32</span>+<span class="number">4</span> ,到c是<span class="number">8</span>字节对齐，所以又需要填充为<span class="number">8</span>的整数倍，为<span class="number">32</span>+<span class="number">4</span>+<span class="number">4</span>，接着最后的d，不用填充，而考虑到数组的情况，下个<span class="keyword">struct</span>也要对齐<span class="number">32</span>，</span><br><span class="line">因为<span class="number">32</span>+<span class="number">4</span>+<span class="number">4</span>+<span class="number">8</span>+<span class="number">4</span> =<span class="number">52</span> ，<span class="number">52</span>+<span class="number">32</span>不是<span class="number">32</span>整除的，所以需要填充到<span class="number">64</span>，所以其大小为<span class="number">64</span>  </span><br><span class="line">eg2:</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">    <span class="type">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">   <span class="built_in">alignas</span>(<span class="number">16</span>) <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">A4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> a;</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">32</span>) <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> *c;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) A5</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> a;</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">32</span>) <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> *c;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot; A:&quot;</span>  &lt;&lt; <span class="built_in">sizeof</span>(<span class="keyword">struct</span> A) &lt;&lt; std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot; A1:&quot;</span>  &lt;&lt; <span class="built_in">sizeof</span>(<span class="keyword">struct</span> A1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot; A3:&quot;</span>  &lt;&lt; <span class="built_in">sizeof</span>(<span class="keyword">struct</span> A3) &lt;&lt; std::endl;</span><br><span class="line">    A3 a3;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;a3: &quot;</span> &lt;&lt; &amp;a3 &lt;&lt; std::endl;</span><br><span class="line">    A4 a4;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;a4:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a4) &lt;&lt; <span class="string">&quot;addr:&quot;</span> &lt;&lt; &amp;a4 &lt;&lt; std::endl;</span><br><span class="line">    A5 a5;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;a5:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a5) &lt;&lt; <span class="string">&quot;addr:&quot;</span> &lt;&lt; &amp;a5 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> A:<span class="number">12</span></span><br><span class="line"> A1:<span class="number">12</span></span><br><span class="line"> A3:<span class="number">32</span></span><br><span class="line">a3: <span class="number">0x7ffccf181a60</span></span><br><span class="line">a4:<span class="number">64</span>addr:<span class="number">0x7ffccf181ac0</span></span><br><span class="line">a5:<span class="number">64</span>addr:<span class="number">0x7ffccf181a80</span></span><br></pre></td></tr></table></figure>
<h5 id="alinof-用来判断对齐数的："><a href="#alinof-用来判断对齐数的：" class="headerlink" title="alinof: 用来判断对齐数的："></a>alinof: 用来判断对齐数的：</h5><p>alignof( type-id )：Returns a value of type std::size_t.<br>如果类型是引用类型，操作符返回被引用类型的对齐;如果类型是数组类型，则返回元素类型的对齐要求<br>eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span>   i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span>  c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Note: `alignas(alignof(long double))` below can be simplified to simply </span></span><br><span class="line"><span class="comment">// `alignas(long double)` if desired.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="built_in">alignof</span>(<span class="type">long</span> <span class="type">double</span>)) Foo2 &#123;</span><br><span class="line">    <span class="comment">// put your definition here</span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) Empty64 &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alignment of&quot;</span>  <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- char             : &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">char</span>)    &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- pointer          : &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">int</span>*)    &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- class Foo        : &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Foo)     &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- class Foo2       : &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Foo2)    &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- empty class      : &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Empty)   &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- alignas(64) Empty: &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Empty64) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Possible output:</span><br><span class="line"></span><br><span class="line">Alignment of</span><br><span class="line">- <span class="type">char</span>             : <span class="number">1</span></span><br><span class="line">- pointer          : <span class="number">8</span></span><br><span class="line">- <span class="keyword">class</span> <span class="title class_">Foo</span>        : <span class="number">4</span></span><br><span class="line">- <span class="keyword">class</span> <span class="title class_">Foo2</span>       : <span class="number">16</span></span><br><span class="line">- empty <span class="keyword">class</span>      : <span class="number">1</span></span><br><span class="line">- <span class="built_in">alignas</span>(<span class="number">64</span>) Empty: <span class="number">64</span></span><br></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> std::cout&lt;&lt;<span class="string">&quot; more :&quot;</span>&lt;&lt; <span class="built_in">alignof</span>( <span class="type">char</span>[<span class="number">150</span>]) &lt;&lt; std::endl;<span class="comment">//1</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot; more :&quot;</span>&lt;&lt; <span class="built_in">alignof</span>(<span class="built_in">alignas</span>(<span class="number">256</span>) <span class="type">char</span>[<span class="number">150</span>]) &lt;&lt; std::endl;<span class="comment">//1</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot; more :&quot;</span>&lt;&lt; <span class="built_in">alignof</span>(<span class="built_in">alignas</span>(<span class="number">256</span>) <span class="type">char</span>[<span class="number">128</span>]) &lt;&lt; std::endl;<span class="comment">//1</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot; more :&quot;</span>&lt;&lt; <span class="built_in">alignof</span>(<span class="built_in">alignas</span>(<span class="number">128</span>) <span class="type">char</span>[<span class="number">150</span>]) &lt;&lt; std::endl;<span class="comment">//1</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot; more :&quot;</span>&lt;&lt; <span class="built_in">alignof</span>(<span class="built_in">alignas</span>(<span class="number">128</span>) <span class="type">char</span>[<span class="number">128</span>]) &lt;&lt; std::endl;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">和&amp;&amp;一样的效果：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n &gt; <span class="number">0</span> <span class="keyword">and</span> n &lt; <span class="number">5</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;n is small and positive\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">and_eq</span>：和&amp;=一样的效果，亦或的意思：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::bitset&lt;<span class="number">4</span>&gt; <span class="built_in">mask</span>(<span class="string">&quot;1100&quot;</span>);</span><br><span class="line">    <span class="function">std::bitset&lt;4&gt; <span class="title">val</span><span class="params">(<span class="string">&quot;0111&quot;</span>)</span></span>;</span><br><span class="line">    val <span class="keyword">and_eq</span> mask;</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">out:<span class="number">0100</span></span><br></pre></td></tr></table></figure>




<h5 id="asm"><a href="#asm" class="headerlink" title="asm"></a>asm</h5><p>asm声明提供了在c++程序中嵌入汇编语言源代码的能力。该声明是有条件支持的，并且定义了实现，这意味着它可能不存在，即使是由实现提供，它也没有固定的含义。<br>语法：asm ( string_literal ) ;<br>string_literal通常是一个用汇编语言编写的短程序，每当执行此声明时就执行该程序。不同的c++编译器对于asm声明有不同的规则，对于与周围c++代码的交互有不同的约定。<br>与其他块声明一样，这个声明可以出现在块(函数体或另一个复合语句)中，也可以出现在块的外部<br>例如以下在linux x86_64下运行的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// the definition of func is written in assembly language</span></span><br><span class="line"><span class="comment">// raw string literal could be very useful</span></span><br><span class="line"><span class="built_in">asm</span>(<span class="string">R&quot;(</span></span><br><span class="line"><span class="string">.globl func</span></span><br><span class="line"><span class="string">    .type func, @function</span></span><br><span class="line"><span class="string">    func:</span></span><br><span class="line"><span class="string">    .cfi_startproc</span></span><br><span class="line"><span class="string">    movl $7, %eax</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string">    .cfi_endproc</span></span><br><span class="line"><span class="string">)&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">// extended inline assembly</span></span><br><span class="line">    <span class="built_in">asm</span> (<span class="string">&quot;leal (%0,%0,4),%0&quot;</span></span><br><span class="line">         : <span class="string">&quot;=r&quot;</span> (n)</span><br><span class="line">         : <span class="string">&quot;0&quot;</span> (n));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;7*5 = &quot;</span> &lt;&lt; n &lt;&lt; std::endl; <span class="comment">// flush is intentional</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// standard inline assembly</span></span><br><span class="line">    <span class="built_in">asm</span> (<span class="string">&quot;movq $60, %rax\n\t&quot;</span> <span class="comment">// the exit syscall number on Linux</span></span><br><span class="line">         <span class="string">&quot;movq $2,  %rdi\n\t&quot;</span> <span class="comment">// this program returns 2</span></span><br><span class="line">         <span class="string">&quot;syscall&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">out:<span class="number">7</span>*<span class="number">5</span> = <span class="number">35</span></span><br></pre></td></tr></table></figure>
<h5 id="atomic系列"><a href="#atomic系列" class="headerlink" title="atomic系列"></a>atomic系列</h5><h5 id="auto-编译期间的类型推导；"><a href="#auto-编译期间的类型推导；" class="headerlink" title="auto:编译期间的类型推导；"></a>auto:编译期间的类型推导；</h5><h5 id="bitand-按位与：位操作，和-amp-一样："><a href="#bitand-按位与：位操作，和-amp-一样：" class="headerlink" title="bitand:按位与：位操作，和&amp;一样："></a>bitand:按位与：位操作，和&amp;一样：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> bin = std::bitset&lt;<span class="number">8</span>&gt;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(bin z, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) std::cout &lt;&lt; <span class="string">&quot;┌────────────┬──────────┐\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) std::cout &lt;&lt; <span class="string">&quot;│ &quot;</span> &lt;&lt;s&lt;&lt; <span class="string">&quot; │ &quot;</span> &lt;&lt;z&lt;&lt;<span class="string">&quot; │\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) std::cout &lt;&lt; <span class="string">&quot;└────────────┴──────────┘\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bin x&#123; <span class="string">&quot;01011010&quot;</span> &#125;; <span class="built_in">show</span>(x, <span class="string">&quot;x &quot;</span>, <span class="number">0</span>);</span><br><span class="line">bin y&#123; <span class="string">&quot;00111100&quot;</span> &#125;; <span class="built_in">show</span>(y, <span class="string">&quot;y &quot;</span>, <span class="number">1</span>);</span><br><span class="line">bin z = x <span class="keyword">bitand</span> y; <span class="built_in">show</span>(z, <span class="string">&quot;x bitand y&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">┌────────────┬──────────┐</span><br><span class="line">│ x │ <span class="number">01011010</span> │</span><br><span class="line">│ y │ <span class="number">00111100</span> │</span><br><span class="line">│ x <span class="keyword">bitand</span> y │ <span class="number">00011000</span> │</span><br><span class="line">└────────────┴──────────┘</span><br><span class="line"></span><br><span class="line"><span class="keyword">bitor</span>: 和|等效：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> bin = std::bitset&lt;<span class="number">8</span>&gt;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(bin z, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) std::cout &lt;&lt; <span class="string">&quot;┌───────────┬──────────┐\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) std::cout &lt;&lt; <span class="string">&quot;│ &quot;</span> &lt;&lt;s&lt;&lt; <span class="string">&quot; │ &quot;</span> &lt;&lt;z&lt;&lt;<span class="string">&quot; │\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) std::cout &lt;&lt; <span class="string">&quot;└───────────┴──────────┘\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bin x&#123; <span class="string">&quot;01011010&quot;</span> &#125;; <span class="built_in">show</span>(x, <span class="string">&quot;x &quot;</span>, <span class="number">0</span>);</span><br><span class="line">bin y&#123; <span class="string">&quot;00111100&quot;</span> &#125;; <span class="built_in">show</span>(y, <span class="string">&quot;y &quot;</span>, <span class="number">1</span>);</span><br><span class="line">bin z = x <span class="keyword">bitor</span> y; <span class="built_in">show</span>(z, <span class="string">&quot;x bitor y&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">┌───────────┬──────────┐</span><br><span class="line">│ x │ <span class="number">01011010</span> │</span><br><span class="line">│ y │ <span class="number">00111100</span> │</span><br><span class="line">│ x <span class="keyword">bitor</span> y │ <span class="number">01111110</span> │</span><br><span class="line">└───────────┴──────────┘</span><br></pre></td></tr></table></figure>

<h5 id="bool-布尔类型；"><a href="#bool-布尔类型；" class="headerlink" title="bool: 布尔类型；"></a>bool: 布尔类型；</h5><h5 id="break-用在switch-for等封闭复合语句中"><a href="#break-用在switch-for等封闭复合语句中" class="headerlink" title="break:用在switch,for等封闭复合语句中"></a>break:用在switch,for等封闭复合语句中</h5><p>在此语句之后，控制权被转移到紧接在外围循环或开关之后的语句。与任何块退出一样，在封闭复合语句或循环&#x2F;开关条件中声明的所有自动存储对象都将在封闭循环后的第一行执行之前销毁，按构造顺序相反。</p>
<h5 id="case-在swtich中使用"><a href="#case-在swtich中使用" class="headerlink" title="case: 在swtich中使用"></a>case: 在swtich中使用</h5><h5 id="catch-在try-catch语句块中，在语句中一并解释；"><a href="#catch-在try-catch语句块中，在语句中一并解释；" class="headerlink" title="catch: 在try-catch语句块中，在语句中一并解释；"></a>catch: 在try-catch语句块中，在语句中一并解释；</h5><h5 id="char-char8-t-char16-t-char32-t-class-是类型标识符"><a href="#char-char8-t-char16-t-char32-t-class-是类型标识符" class="headerlink" title="char,char8_t,char16_t,char32_t,class,是类型标识符"></a>char,char8_t,char16_t,char32_t,class,是类型标识符</h5><h5 id="compl-和-一样的效果，是按位取反"><a href="#compl-和-一样的效果，是按位取反" class="headerlink" title="compl: 和~一样的效果，是按位取反"></a>compl: 和~一样的效果，是按位取反</h5><h5 id="concepts：c-20新特性，TD—和模板类型萃取合并解释"><a href="#concepts：c-20新特性，TD—和模板类型萃取合并解释" class="headerlink" title="concepts：c++20新特性，TD—和模板类型萃取合并解释"></a>concepts：c++20新特性，TD—和模板类型萃取合并解释</h5><h5 id="const和cv"><a href="#const和cv" class="headerlink" title="const和cv"></a>const和cv</h5><h5 id="consteval（since-c-20）-x2F-constexpr-x2F-constinit"><a href="#consteval（since-c-20）-x2F-constexpr-x2F-constinit" class="headerlink" title="consteval（since c++20）&#x2F;constexpr&#x2F;constinit"></a>consteval（since c++20）&#x2F;constexpr&#x2F;constinit</h5><h5 id="const-cast-在具有不同cv限定符的类型之间转换"><a href="#const-cast-在具有不同cv限定符的类型之间转换" class="headerlink" title="const_cast:在具有不同cv限定符的类型之间转换"></a>const_cast:在具有不同cv限定符的类型之间转换</h5><p>const_cast &lt; new_type &gt; ( expression )<br>Returns a value of type new_type.<br>解释： 只有以下转换可以用const_cast实现，通常，only const_cast may be used to cast away (remove) constness or volatility.<br>1 同一个类型的两个可能是多级指针可以相互转换，而不管每个级别上的cv限定符是什么。<br>2 任何类型T的左值都可以转换为相同类型T的左值或右值引用，或多或少符合cv要求。同样，类类型的prvalue或任何类型的xvalue都可以转换为符合cv要求的右值引用。引用const_cast的结果指向原对象if表达式为glvalue，以及实体化临时表达式(自c++ 17起)。<br>3 同样的规则适用于可能指向数据成员的多级指针，也适用于可能指向已知和未知绑定的数组的多级指针(指向cv限定元素的数组本身被认为是cv限定的)(从c++ 17开始)<br>4 空指针值可以转换为new_type的空指针值<br>对于所有的cast表达式，结果可以是：<br>1） 如果new_type是左值引用类型或函数类型的右值引用，则为左值;<br>2）如果new_type是对象类型的右值引用，则为xvalue<br>3）一个prvalue ，对其他情况<br>note:指向函数和成员函数的指针不受const_cast约束<br>const_cast使实际引用const对象的非const类型的引用或指针，或者实际引用volatile对象的非volatile类型的引用或指针成为可能。通过非const访问路径修改const对象和通过非volatile glvalue引用volatile对象会导致未定义的行为 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">type</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">type</span>(): <span class="built_in">i</span>(<span class="number">3</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// this-&gt;i = v; // compile error: this is a pointer to const</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;type*&gt;(<span class="keyword">this</span>)-&gt;i = v; <span class="comment">// OK as long as the type object isn&#x27;t const</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>; <span class="comment">// i is not declared const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rci = i; </span><br><span class="line"><span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(rci) = <span class="number">4</span>; <span class="comment">// OK: modifies i</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">type t; <span class="comment">// if this was const type t, then t.f(4) would be undefined behavior</span></span><br><span class="line">t.<span class="built_in">f</span>(<span class="number">4</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;type::i = &quot;</span> &lt;&lt; t.i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = <span class="number">3</span>; <span class="comment">// j is declared const</span></span><br><span class="line">[[maybe_unused]]</span><br><span class="line"><span class="type">int</span>* pj = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;j);</span><br><span class="line"><span class="comment">// *pj = 4; // undefined behavior</span></span><br><span class="line">[[maybe_unused]]</span><br><span class="line"><span class="built_in">void</span> (type::* pmf)(<span class="type">int</span>) <span class="type">const</span> = &amp;type::f; <span class="comment">// pointer to member function</span></span><br><span class="line"><span class="comment">// const_cast&lt;void(type::*)(int)&gt;(pmf); // compile error: const_cast does</span></span><br><span class="line"><span class="comment">// not work on function pointers</span></span><br><span class="line">&#125;</span><br><span class="line">Output:</span><br><span class="line">i = <span class="number">4</span></span><br><span class="line">type::i = <span class="number">4</span></span><br></pre></td></tr></table></figure>



















<h5 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h5><h4 id="以下三个是关于协程的，单独记录"><a href="#以下三个是关于协程的，单独记录" class="headerlink" title="以下三个是关于协程的，单独记录"></a>以下三个是关于协程的，单独记录</h4><h5 id="co-await-since-c-20"><a href="#co-await-since-c-20" class="headerlink" title="co_await(since c++20)"></a>co_await(since c++20)</h5><h5 id="co-return-since-c-20"><a href="#co-return-since-c-20" class="headerlink" title="co_return(since c++20)"></a>co_return(since c++20)</h5><h5 id="co-yield-since-c-20"><a href="#co-yield-since-c-20" class="headerlink" title="co_yield(since c++20)"></a>co_yield(since c++20)</h5><h4 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h4><h5 id="decltype-编译时类型推导，基本用法见下面例子："><a href="#decltype-编译时类型推导，基本用法见下面例子：" class="headerlink" title="decltype:编译时类型推导，基本用法见下面例子："></a>decltype:编译时类型推导，基本用法见下面例子：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line">   <span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">   <span class="type">int</span> *ptr = arr;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">S</span>&#123; <span class="type">double</span> d; &#125;s ;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Overloaded</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Overloaded</span><span class="params">(<span class="type">char</span>)</span></span>;<span class="comment">//重载的函数</span></span><br><span class="line">   <span class="function"><span class="type">int</span> &amp;&amp; <span class="title">RvalRef</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">const</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//规则一：推导为其类型</span></span><br><span class="line">   <span class="keyword">decltype</span> (arr) var1; <span class="comment">//int 标记符表达式</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">decltype</span> (ptr) var2;<span class="comment">//int *  标记符表达式</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">decltype</span>(s.d) var3;<span class="comment">//doubel 成员访问表达式</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//decltype(Overloaded) var4;//重载函数。编译错误。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//规则二：将亡值。推导为类型的右值引用。</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">decltype</span> (<span class="built_in">RvalRef</span>()) var5 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//规则三：左值，推导为类型的引用。</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">decltype</span> ((i))var6 = i;     <span class="comment">//int&amp;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">decltype</span> (<span class="literal">true</span> ? i : i) var7 = i; <span class="comment">//int&amp;  条件表达式返回左值。</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">decltype</span> (++i) var8 = i; <span class="comment">//int&amp;  ++i返回i的左值。</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">decltype</span>(arr[<span class="number">5</span>]) var9 = i;<span class="comment">//int&amp;. []操作返回左值</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">decltype</span>(*ptr)var10 = i;<span class="comment">//int&amp; *操作返回左值</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">decltype</span>(<span class="string">&quot;hello&quot;</span>)var11 = <span class="string">&quot;hello&quot;</span>; <span class="comment">//const char(&amp;)[9]  字符串字面常量为左值，且为const左值。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//规则四：以上都不是，则推导为本类型</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">decltype</span>(<span class="number">1</span>) var12;<span class="comment">//const int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">decltype</span>(<span class="built_in">Func</span>(<span class="number">1</span>)) var13=<span class="literal">true</span>;<span class="comment">//const bool</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">decltype</span>(i++) var14 = i;<span class="comment">//int i++返回右值</span></span><br></pre></td></tr></table></figure>
<h5 id="default，delete用于虚基类的函数声明，c-11"><a href="#default，delete用于虚基类的函数声明，c-11" class="headerlink" title="default，delete用于虚基类的函数声明，c++11"></a>default，delete用于虚基类的函数声明，c++11</h5><h5 id="do-while"><a href="#do-while" class="headerlink" title="do(-while),"></a>do(-while),</h5><h5 id="double类型"><a href="#double类型" class="headerlink" title="double类型"></a>double类型</h5><h5 id="动态类型转换：dynamic-cast-见类型，泛型总结"><a href="#动态类型转换：dynamic-cast-见类型，泛型总结" class="headerlink" title="动态类型转换：dynamic_cast 见类型，泛型总结"></a>动态类型转换：dynamic_cast 见类型，泛型总结</h5><h5 id="else-enum"><a href="#else-enum" class="headerlink" title="else,enum,"></a>else,enum,</h5><h5 id="explicit-在C-中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。"><a href="#explicit-在C-中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。" class="headerlink" title="explicit:在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。"></a>explicit:在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>) &#123; &#125;      <span class="comment">// 转换构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>, <span class="type">int</span>) &#123; &#125; <span class="comment">// 转换构造函数 (C++11)</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1 = <span class="number">1</span>;      <span class="comment">// OK：复制初始化选择 A::A(int)</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK：直接初始化选择 A::A(int)</span></span><br><span class="line">    A a3 &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK：直接列表初始化选择 A::A(int, int)</span></span><br><span class="line">    A a4 = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// OK：复制列表初始化选择 A::A(int, int)</span></span><br><span class="line">    A a5 = (A)<span class="number">1</span>;   <span class="comment">// OK：显式转型进行 static_cast</span></span><br><span class="line">    <span class="keyword">if</span> (a1) ;      <span class="comment">// OK：A::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> na1 = a1; <span class="comment">// OK：复制初始化选择 A::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> na2 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(a1); <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//  B b1 = 1;      // 错误：复制初始化不考虑 B::B(int)</span></span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK：直接初始化选择 B::B(int)</span></span><br><span class="line">    B b3 &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK：直接列表初始化选择 B::B(int, int)</span></span><br><span class="line"><span class="comment">//  B b4 = &#123;4, 5&#125;; // 错误：复制列表初始化不考虑 B::B(int,int)</span></span><br><span class="line">    B b5 = (B)<span class="number">1</span>;   <span class="comment">// OK：显式转型进行 static_cast</span></span><br><span class="line">    <span class="keyword">if</span> (b2) ;      <span class="comment">// OK：B::operator bool()</span></span><br><span class="line"><span class="comment">//  bool nb1 = b2; // 错误：复制初始化不考虑 B::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> nb2 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b2); <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="export-用于标注一个模板定义被导出，并允许在其他翻译单元中声明，但不定义同一模板，c-11前可用，c-11起，不使用，但保留该关键字；"><a href="#export-用于标注一个模板定义被导出，并允许在其他翻译单元中声明，但不定义同一模板，c-11前可用，c-11起，不使用，但保留该关键字；" class="headerlink" title="export:用于标注一个模板定义被导出，并允许在其他翻译单元中声明，但不定义同一模板，c++11前可用，c++11起，不使用，但保留该关键字；"></a>export:用于标注一个模板定义被导出，并允许在其他翻译单元中声明，但不定义同一模板，c++11前可用，c++11起，不使用，但保留该关键字；</h5><p>通常情况下，你会在.h文件中声明函数和类，而将它们的定义放置在一个单独的.cpp文件中。但是在使用模板时，这种习惯性做法将变得不再有用，因为当实例化一个模板时，编译器必须看到模板确切的定义，而不仅仅是它的声明。 因此，最好的办法就是将模板的声明和定义都放置在同一个.h文件中。这就是为什么所有的STL头文件都包含模板定义的原因。<br>另外一个方法就是使用关键字“export”！你可以在.h文件中，声明模板类和模板函数；在.cpp文件中，使用关键字export来定义具体的模板类对象和模板函数；然后在其他用户代码文件中，包含声明头文件后，就可以使用该这些对象和函数了。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// output.h - 声明头文件  </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">void</span> <span class="title">output</span> <span class="params">(<span class="type">const</span> T&amp; t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out.cpp - 定义代码文件   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;****&gt;</span>   </span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span> <span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;std::cerr &lt;&lt; t;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp:用户代码文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;output.h&quot;</span>   void main() <span class="comment">// 使用output()   &#123;   output(4);  </span></span></span><br><span class="line"><span class="built_in">output</span>(<span class="string">&quot;Hello&quot;</span>);   &#125;</span><br><span class="line">大多数编译器不支持，如vs,gcc,不去使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="extern-false-float-for-friend-goto-if-inline-int"><a href="#extern-false-float-for-friend-goto-if-inline-int" class="headerlink" title="extern,false,float,for,friend,goto,if,inline,int"></a>extern,false,float,for,friend,goto,if,inline,int</h5><p>已知略</p>
<h5 id="long"><a href="#long" class="headerlink" title="long"></a>long</h5><p>已知略</p>
<h5 id="mutable"><a href="#mutable" class="headerlink" title="mutable:"></a>mutable:</h5><p>在C++中，mutable也是为了突破const的限制而设置的，被mutable修饰的变量将永远处于可变的状态。</p>
<p>mutable的作用有两点：<br>（1）保持常量对象中大部分数据成员仍然是“只读”的情况下，实现对个别数据成员的修改；<br>（2）使类的const函数可以修改对象的mutable数据成员。</p>
<p>使用mutable的注意事项：<br>（1）mutable只能作用于类的非静态和非常量数据成员。<br>（2）在一个类中，应尽量或者不用mutable，大量使用mutable表示程序设计存在缺陷。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mutable int test;//编译出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> getNum;</span><br><span class="line">	<span class="comment">//mutable const int test;    //编译出错</span></span><br><span class="line">	<span class="comment">//mutable static int static1;//编译出错</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">char</span>* name)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">		getNum=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		++getNum;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pintTimes</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;getNum&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">const</span> Student <span class="title">s</span><span class="params">(<span class="string">&quot;张三&quot;</span>)</span></span>;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">getName</span>().<span class="built_in">c_str</span>()&lt;&lt;endl;</span><br><span class="line">	s.<span class="built_in">pintTimes</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="namespace-new"><a href="#namespace-new" class="headerlink" title="namespace,new"></a>namespace,new</h5><p>已知略</p>
<h5 id="noexcept-用于声明函数等是否有异常抛出，以及检测函数等是否有异常抛出；异常处理部分会涵盖"><a href="#noexcept-用于声明函数等是否有异常抛出，以及检测函数等是否有异常抛出；异常处理部分会涵盖" class="headerlink" title="noexcept: 用于声明函数等是否有异常抛出，以及检测函数等是否有异常抛出；异常处理部分会涵盖"></a>noexcept: 用于声明函数等是否有异常抛出，以及检测函数等是否有异常抛出；异常处理部分会涵盖</h5><h5 id="not"><a href="#not" class="headerlink" title="not"></a>not</h5><p>已知略</p>
<h5 id="not-eq"><a href="#not-eq" class="headerlink" title="not_eq"></a>not_eq</h5><p>已知略</p>
<h5 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h5><p>已知略</p>
<h5 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h5><p>已知略</p>
<h5 id="or-or-eq"><a href="#or-or-eq" class="headerlink" title="or or_eq"></a>or or_eq</h5><p>已知略</p>
<h5 id="private-protected-public"><a href="#private-protected-public" class="headerlink" title="private,protected,public;"></a>private,protected,public;</h5><p>已知略</p>
<h5 id="reflexpr-和反射相关，c-20"><a href="#reflexpr-和反射相关，c-20" class="headerlink" title="reflexpr: 和反射相关，c++20"></a>reflexpr: 和反射相关，c++20</h5><h5 id="register：存储有关，c-17后弃用"><a href="#register：存储有关，c-17后弃用" class="headerlink" title="register：存储有关，c++17后弃用"></a>register：存储有关，c++17后弃用</h5><h5 id="reinterpret-cast：-类型转换，可以在任何指针类型转换，但是风险大，不安全，使用频率低，具体在泛型相关内容统一解释；"><a href="#reinterpret-cast：-类型转换，可以在任何指针类型转换，但是风险大，不安全，使用频率低，具体在泛型相关内容统一解释；" class="headerlink" title="reinterpret_cast： 类型转换，可以在任何指针类型转换，但是风险大，不安全，使用频率低，具体在泛型相关内容统一解释；"></a>reinterpret_cast： 类型转换，可以在任何指针类型转换，但是风险大，不安全，使用频率低，具体在泛型相关内容统一解释；</h5><h5 id="requires-c-20后，在模板的泛型中使用"><a href="#requires-c-20后，在模板的泛型中使用" class="headerlink" title="requires:c++20后，在模板的泛型中使用"></a>requires:c++20后，在模板的泛型中使用</h5><h5 id="return-short-signed-sizeof-static"><a href="#return-short-signed-sizeof-static" class="headerlink" title="return,short,signed,sizeof,static"></a>return,short,signed,sizeof,static</h5><h5 id="static-assert-c-11-编译期间的断言检查"><a href="#static-assert-c-11-编译期间的断言检查" class="headerlink" title="static_assert(c++11);编译期间的断言检查"></a>static_assert(c++11);编译期间的断言检查</h5><h5 id="static-cast-类型转换，泛型中统一"><a href="#static-cast-类型转换，泛型中统一" class="headerlink" title="static_cast 类型转换，泛型中统一"></a>static_cast 类型转换，泛型中统一</h5><h5 id="struct-switch"><a href="#struct-switch" class="headerlink" title="struct, switch"></a>struct, switch</h5><p>已知略</p>
<h5 id="synchronized-规划中"><a href="#synchronized-规划中" class="headerlink" title="synchronized 规划中"></a>synchronized 规划中</h5><h5 id="template"><a href="#template" class="headerlink" title="template"></a>template</h5><h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><h5 id="thread-local-存储连接中统一解释：线程存储"><a href="#thread-local-存储连接中统一解释：线程存储" class="headerlink" title="thread_local: 存储连接中统一解释：线程存储"></a>thread_local: 存储连接中统一解释：线程存储</h5><h5 id="throw-异常捕获相关"><a href="#throw-异常捕获相关" class="headerlink" title="throw:异常捕获相关"></a>throw:异常捕获相关</h5><h5 id="true"><a href="#true" class="headerlink" title="true"></a>true</h5><h5 id="try"><a href="#try" class="headerlink" title="try"></a>try</h5><h5 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h5><h5 id="typeid-用于在运行时确定表达式的类型"><a href="#typeid-用于在运行时确定表达式的类型" class="headerlink" title="typeid:用于在运行时确定表达式的类型"></a>typeid:用于在运行时确定表达式的类型</h5><h5 id="typename"><a href="#typename" class="headerlink" title="typename"></a>typename</h5><h5 id="union-unsigned-using-virtual"><a href="#union-unsigned-using-virtual" class="headerlink" title="union,unsigned,using,virtual"></a>union,unsigned,using,virtual</h5><h5 id="volatile-cv限定中的v"><a href="#volatile-cv限定中的v" class="headerlink" title="volatile:  cv限定中的v"></a>volatile:  cv限定中的v</h5><h5 id="void"><a href="#void" class="headerlink" title="void"></a>void</h5><h5 id="wchar-t-while"><a href="#wchar-t-while" class="headerlink" title="wchar_t,while"></a>wchar_t,while</h5><h5 id="xor-xor-eq"><a href="#xor-xor-eq" class="headerlink" title="xor,xor_eq"></a>xor,xor_eq</h5>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++keyword</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_datamember_memory</title>
    <url>/2018/06/09/cpp-datamember-memory/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c-class-datamemory"><a href="#c-class-datamemory" class="headerlink" title="c++ class  datamemory"></a>c++ class  datamemory</h3><p>详细介绍c++的成员布局，类本身的布局和在各种情况下的布局</p>
<h4 id="“类”本身的大小："><a href="#“类”本身的大小：" class="headerlink" title="“类”本身的大小："></a>“类”本身的大小：</h4><ul>
<li>the simplest 引入</li>
<li>1.2 多少内存能表现一个class?<br>最小是１　  size<span id="more"></span></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span> &#125;;   --<span class="number">-1</span> 一个<span class="type">char</span> 表示这个类型</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> :</span>public virtual T&#123;&#125;;　　--指针大小，指针指向T  virtual base <span class="class"><span class="keyword">class</span> <span class="title">subobject</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span>public virtual T&#123;&#125;;  --指针大小</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>public X,public Y &#123;&#125;;　--两个指针大小　```  </span><br><span class="line">－－从深入那本书中说有两种方式，体现<span class="class"><span class="keyword">class</span>的大小，这里是优化的特殊的类型，这些好理解，但是需要类的空间的真正原因是什么？这<span class="title">T</span>的一个<span class="title">char</span>存储了什么？  </span></span><br><span class="line"><span class="class">用来干嘛？那在<span class="title">X</span>中指向<span class="title">T</span>的又是为什么需要？  </span></span><br><span class="line"><span class="class">最小１<span class="title">char</span>?  </span></span><br><span class="line"><span class="class">我们知道，当一个类中仅包含一个<span class="title">nonstatic</span> <span class="title">member</span>时，如<span class="title">int</span> ,则对象为<span class="title">int</span>大小，但是当类为空时，对象如何去分配内存？</span></span><br><span class="line"><span class="class">如果同时定义了两个对象，那如何去区分这两个对象？让他们地址不相同？－－－所以这里需要一个<span class="title">char</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">+ 注意，类本身也是一个类型，像<span class="title">int</span>，<span class="keyword">struct</span>一样，它的大小为４，<span class="keyword">struct</span>成员和对齐，则类也一样，<span class="title">sizeof</span>是在编译期间（确定<span class="title">c89</span>中）  </span></span><br><span class="line"><span class="class">一个例子：</span></span><br><span class="line"><span class="class">```<span class="title">cpp</span></span></span><br><span class="line"><span class="class">#<span class="title">include</span>&lt;</span>iostream&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _sizeof(T) ((size_t)((T*)0+1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>:</span>public virtual T&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>:</span>public virtual T&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span>public X,public Y&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TT</span>&#123;</span>public:<span class="type">int</span> q;<span class="type">int</span> x;&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		T t1,t2;</span><br><span class="line">		<span class="type">int</span> xx;</span><br><span class="line">		<span class="keyword">if</span> (&amp;t1==&amp;t2)</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;same&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,&amp;t1);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,&amp;t2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,&amp;xx);</span><br><span class="line">	<span class="comment">//	int sie=(Y*)0+1;</span></span><br><span class="line">	<span class="comment">//	printf(&quot;%x\n&quot;,X&#123;&#125;);</span></span><br><span class="line">	    <span class="type">int</span> s= _sizeof(TT);　８　编译期间确定，直接把８赋给内存</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;_sizeof(T)&lt;&lt;<span class="built_in">endl</span>;　１</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(TT)&lt;&lt;<span class="built_in">endl</span>;　　８</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(T)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(X)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;```</span><br><span class="line">自然t1,t2地址不同，相邻</span><br><span class="line"></span><br><span class="line">#### 那么一个类大的方面需要这些：</span><br><span class="line">１）类中定义的普通成员  </span><br><span class="line">２）语言本身所造成的额外负担如virtual机制，virtual table ,virtual base <span class="class"><span class="keyword">class</span> <span class="title">subobject</span>  </span></span><br><span class="line"><span class="class">３）<span class="title">Aligmnment</span>带来的  </span></span><br><span class="line"><span class="class">（编译器的优化会带来内存布局的影响）</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">上述例子：当编译器不做优化时，为１，8+1+3,8+1+3 ,1(<span class="title">X</span>)+8+8+3(<span class="title">ali</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#### 总结<span class="title">datamember</span>的布局</span></span><br><span class="line"><span class="class">+ 对象只存非静态的成员变量，而无论中间放置了几个静态变量都不会影响他们之间的排布。</span></span><br><span class="line"><span class="class">　　　大部分的编译器将先定义的非静态成员变量放在低地址，而后的放在高地址。最好用时先用<span class="title">kdbg</span>或测试程序等看下</span></span><br><span class="line"><span class="class">+ 静态成员的存取不通过对象，他们放在数据段中</span></span><br><span class="line"><span class="class">+ <span class="title">vptr</span>一般会放在哪里？　</span></span><br><span class="line"><span class="class">　　对象的头或者尾巴</span></span><br><span class="line"><span class="class">+ <span class="title">align</span>:</span>C++标准要求，在同一个access <span class="title function_">section</span><span class="params">(private,public,protect等区段），member的排列只需要符和较晚出现放在较高的地址“即可，</span></span><br><span class="line"><span class="params">　　access sections的多少并不会带来额外的负担</span></span><br><span class="line"><span class="params">+ 我在g++上做了测试:</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">```cpp</span></span><br><span class="line"><span class="params">class TT&#123;</span></span><br><span class="line"><span class="params"> public:</span></span><br><span class="line"><span class="params">    <span class="type">int</span> a;</span></span><br><span class="line"><span class="params">    <span class="type">char</span> b;</span></span><br><span class="line"><span class="params">    &#125;;</span></span><br><span class="line"><span class="params">   <span class="keyword">sizeof</span>&#123;TT)</span>;   <span class="number">8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TT</span>&#123;</span></span><br><span class="line"> public:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line"> protect:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">   <span class="keyword">sizeof</span>(TT)=<span class="number">16</span></span><br><span class="line">class TT&#123;</span><br><span class="line"> public:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line"> protect:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line"> public:</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="type">char</span> f;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">sizeof</span>(TT)=<span class="number">24</span> </span><br><span class="line">class TT&#123;</span><br><span class="line"> public:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="type">char</span> f;</span><br><span class="line"> protect:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">sizeof</span>(TT)=<span class="number">24</span></span><br><span class="line">class TT&#123;</span><br><span class="line"> public:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="type">char</span> f;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line"> protect:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">sizeof</span>(TT)=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>  由此看来这个编译器是按着c的struct对齐来的啊， </p>
<h4 id="data-member的存取："><a href="#data-member的存取：" class="headerlink" title="data member的存取："></a>data member的存取：</h4><ul>
<li><p>成本<br>比较：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">        TT tt1;</span><br><span class="line">		TT *tt2=&amp;tt1;</span><br><span class="line"><span class="number">0x400b87</span> lea    <span class="number">-0x20</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400b8b</span> mov    %rax,<span class="number">-0x48</span>(%rbp)</span><br><span class="line">		<span class="type">int</span> d=tt1.d;</span><br><span class="line"><span class="number">0x400b8f</span> mov    <span class="number">-0x1c</span>(%rbp),%eax</span><br><span class="line"><span class="number">0x400b92</span> mov    %eax,<span class="number">-0x68</span>(%rbp)</span><br><span class="line">		<span class="type">int</span> f=tt2-&gt;d;</span><br><span class="line"><span class="number">0x400b95</span> mov    <span class="number">-0x48</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400b99</span> mov    <span class="number">0x4</span>(%rax),%eax</span><br><span class="line"><span class="number">0x400b9c</span> mov    %eax,<span class="number">-0x64</span>(%rbp)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对static成员啊而言，实际是在数据段中，所以不管什么形式的访问都是相同的<br>待测试</p>
</li>
<li><p>通过成员函数<br>需要通过this 指针，则同上例子中的指针访问</p>
</li>
</ul>
<h3 id="总结几种情况下的的布局"><a href="#总结几种情况下的的布局" class="headerlink" title="总结几种情况下的的布局"></a>总结几种情况下的的布局</h3><h4 id="单一继承不含多态"><a href="#单一继承不含多态" class="headerlink" title="单一继承不含多态"></a>单一继承不含多态</h4><h5 id="一个典型的例子如下"><a href="#一个典型的例子如下" class="headerlink" title="一个典型的例子如下"></a>一个典型的例子如下</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point2d</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point2d</span>( <span class="type">float</span> x=<span class="number">0.0</span>,<span class="type">float</span> y=<span class="number">0.0</span>):_x(x),_y(y)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">x</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">y</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _y;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">x</span><span class="params">(<span class="type">float</span> newX)</span> </span>&#123; _x=newX;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">y</span><span class="params">(<span class="type">float</span> newY)</span> </span>&#123; _y=newY;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>+= (<span class="type">const</span> Point2d&amp;  rhs) &#123;</span><br><span class="line">        _x+=rhs.<span class="built_in">x</span>();</span><br><span class="line">        _y+=rhs.<span class="built_in">y</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    ...more member;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Point3d</span>: <span class="keyword">public</span> Point2d&#123;</span><br><span class="line">     <span class="keyword">public</span>: </span><br><span class="line">        <span class="built_in">Point3d</span>(<span class="type">float</span> x=<span class="number">0.0</span>,<span class="type">float</span> y=<span class="number">0.0</span>,<span class="type">float</span> z=<span class="number">0.0</span>):<span class="built_in">Point2d</span>(x,y),_z(z)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">float</span> <span class="title">z</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">z</span><span class="params">(<span class="type">float</span> newZ)</span></span>&#123;_z=newZ;&#125; </span><br><span class="line">        <span class="type">void</span> <span class="keyword">operator</span>+=(<span class="type">const</span> Point3d&amp; rhs) &#123;</span><br><span class="line">           Point2d::<span class="keyword">operator</span>+=(rhs);</span><br><span class="line">           _z+=rhs.<span class="built_in">z</span>();</span><br><span class="line">           &#125;</span><br><span class="line">          ...more member               </span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h5><p>则　基类的成员被子类包含，放在较低的地址；相比之下，多了对齐的空间；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Concrete</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     <span class="type">char</span> c1;</span><br><span class="line">     <span class="type">char</span> c2;</span><br><span class="line">     <span class="type">char</span> c3;</span><br><span class="line">     &#125;;```</span><br><span class="line">则需要占用８bytes;</span><br><span class="line"></span><br><span class="line">而当被继承实现时：</span><br><span class="line">```cpp</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Concrete1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">       <span class="type">int</span> val;</span><br><span class="line">       <span class="type">char</span> bit1;</span><br><span class="line">   &#125;;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Concrete2</span>：<span class="keyword">public</span> Concrete1&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">         <span class="type">char</span> bit2;</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">class</span>  <span class="title class_">Concrete3</span>:<span class="keyword">public</span> Concrete2&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">char</span> bit3;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>
<p>  由此带来成本 8+4+4&#x3D;16</p>
<ul>
<li>那为什么要这么做的？继承的时候不能挤在一起吗？<br>  （在深入c++对象模型中有图容易理解。这里仅说明：<br>  　　　若：　Concrete2  *pc2;<br>    Concrete1 *pc1_1,*pc1_2;<br>    *pc1_2&#x3D;*pc1_1; -默认复制构造<br>    pc1_1 &#x3D; pc2; &#x2F;&#x2F;pc1_1指向pc2;<br>    *pc1_2&#x3D;*pc1_1;&#x2F;&#x2F;覆盖掉了，如果继承是成员挤在一起，而不是对齐来的</li>
</ul>
<h5 id="单一继承含多态："><a href="#单一继承含多态：" class="headerlink" title="单一继承含多态："></a>单一继承含多态：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Point2d</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point2d</span>( <span class="type">float</span> x=<span class="number">0.0</span>,<span class="type">float</span> y=<span class="number">0.0</span>):_x(x),_y(y)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">x</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">y</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">z</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">0.0</span>;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">z</span><span class="params">(<span class="type">float</span>)</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">x</span><span class="params">(<span class="type">float</span> newX)</span> </span>&#123; _x=newX;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">y</span><span class="params">(<span class="type">float</span> newY)</span> </span>&#123; _y=newY;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> <span class="keyword">operator</span>+= (<span class="type">const</span> Point2d&amp;  rhs) &#123;</span><br><span class="line">        _x+=rhs.<span class="built_in">x</span>();</span><br><span class="line">        _y+=rhs.<span class="built_in">y</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    ...more member;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Point3d</span>: <span class="keyword">public</span> Point2d&#123;</span><br><span class="line">     <span class="keyword">public</span>: </span><br><span class="line">        <span class="built_in">Point3d</span>(<span class="type">float</span> x=<span class="number">0.0</span>,<span class="type">float</span> y=<span class="number">0.0</span>,<span class="type">float</span> z=<span class="number">0.0</span>):<span class="built_in">Point2d</span>(x,y),_z(z)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">z</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">z</span><span class="params">(<span class="type">float</span> newZ)</span></span>&#123;_z=newZ;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">virtual</span> <span class="type">void</span> <span class="keyword">operator</span>+=(<span class="type">const</span> Point3d&amp; rhs) &#123;</span><br><span class="line">           Point2d::<span class="keyword">operator</span>+=(rhs);</span><br><span class="line">           _z+=rhs.<span class="built_in">z</span>();</span><br><span class="line">           &#125;</span><br><span class="line">          ...more member     </span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">float</span> _z;</span><br><span class="line">&#125;;```</span><br><span class="line">由此可以满足</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function">　　　<span class="type">void</span> <span class="title">fool</span><span class="params">(Point2d &amp;p1,Point2d &amp;p2)</span></span>&#123;</span><br><span class="line">     p1+=p2;</span><br><span class="line">     &#125;```</span><br><span class="line">可以是Point2d和Point3d 这种弹性，牺牲了时间和空间</span><br><span class="line">加入了什么呢？  </span><br><span class="line"></span><br><span class="line">       <span class="keyword">virtual</span> table</span><br><span class="line">       vptr</span><br><span class="line">	   add constructor vptr setting</span><br><span class="line">       add destructor vptr <span class="keyword">virtual</span> table dele</span><br><span class="line"></span><br><span class="line">所以需要视情况而定，如若只是涉及到<span class="number">2</span>d&amp;<span class="number">3</span>d之间，则可以是</span><br><span class="line">```cpp</span><br><span class="line">  <span class="keyword">virtual</span> <span class="type">void</span> <span class="keyword">operator</span>+=(<span class="type">const</span> Point２d&amp; rhs) &#123;</span><br><span class="line">           Point2d::<span class="keyword">operator</span>+=(rhs);</span><br><span class="line">           _z+=rhs.<span class="built_in">z</span>();<span class="comment">//此时＋０</span></span><br><span class="line">           &#125;</span><br><span class="line"><span class="function">Point2d <span class="title">p2d</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">Point3d <span class="title">p3d</span><span class="params">(,,,,)</span></span>;</span><br><span class="line">p3d+=p2d</span><br></pre></td></tr></table></figure>
<p>另外：对vptr的摆放位置，若放在最后面，则兼容c<br>但是损失了对继承的更好支持，所以现在放在最前面</p>
<h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>多重继承考虑的问题较多？但从设计角度看，你可能会问？<br>对比单一继承，子类成员起始地址和基类相同，那多重继承，和哪个基类一样？其他基类怎么办，在向上转型如何处理，指针呢？</p>
<p>另外，在单一继承中，vptr放在最开始的地方，如果base class没有virtual func而derived　class有呢？则此时单一继承的自然多态被打破，<br>若此时把一个derived class 转换为base class则　需要编译器介入，在多重继承+虚拟继承下就更有必要了</p>
<p>考虑这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　<span class="keyword">class</span> <span class="title class_">Point2d</span>&#123; 带<span class="keyword">virtual</span> 接口</span><br><span class="line">   <span class="keyword">public</span>: </span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">       <span class="type">float</span> _x _y;</span><br><span class="line">       &#125;;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Point3d</span>:<span class="keyword">public</span> Point2d&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    protectd:</span><br><span class="line">       <span class="type">float</span> _z;</span><br><span class="line">       &#125;&#x27;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;带<span class="keyword">virtual</span>接口</span><br><span class="line">      <span class="keyword">protected</span>:</span><br><span class="line">         Vertex *next;</span><br><span class="line">    &#125;;    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Vertex3d</span>:<span class="keyword">public</span> Point3d,<span class="keyword">public</span> Vertex &#123;</span><br><span class="line">    protexted:</span><br><span class="line">      <span class="type">float</span> mumble;</span><br><span class="line">      &#125; ```</span><br><span class="line"></span><br><span class="line">对多重继承派生对象，若将其地址　指定给最左端的base <span class="keyword">class</span>则情况同单一继承一样，因为二者指向相同的地址。但是对第二个及以上时</span><br><span class="line">需要将地址修改，加上或减去　介于中间的base <span class="keyword">class</span> <span class="title class_">subobject</span></span><br><span class="line">```cpp</span><br><span class="line">  eg:  Vertex3d v3d;</span><br><span class="line">        Vertex *pv;</span><br><span class="line">        Point２d *p2d</span><br><span class="line">        POint3d  *p3d;  </span><br><span class="line">        pv=&amp;v3d</span><br><span class="line">     则内部为：pv=(Vertex*)(((<span class="type">char</span>*)&amp;v3d)+<span class="built_in">sizeof</span>(Point3d));     </span><br><span class="line">     而对p2d=&amp;v3d;</span><br><span class="line">         p3d=&amp;v3d则只需要简单的拷贝</span><br><span class="line">```              </span><br><span class="line">      若为Vertex3d　*v3d;  pv=v3d;则内部还要进行判断空。因为*v3d可能为空，</span><br><span class="line">      而引用不用，因为引用不可能参考到无</span><br><span class="line">对存取其第二个基类成员，也是做类似的offset操作</span><br><span class="line">##### 虚拟继承</span><br><span class="line">在多重继承加虚拟继承时，如ios istream ostream</span><br><span class="line">前面的内容会好理解一些，这部分的内容不好理解，也有些繁琐，于是，我回到之前学习的方法，即为什么，出现的原因，如果是自己实现又如何，等思考：</span><br><span class="line">+ 为什么需要虚拟继承？  </span><br><span class="line">虚拟继承出现，是因为当基类<span class="number">2</span>和<span class="number">3</span>都继承了基类<span class="number">1</span>，而基类<span class="number">4</span>继承了<span class="number">2</span>和<span class="number">3</span>，则基类<span class="number">4</span>会同时拥有两份基类<span class="number">1</span>，而虚拟继承就是为了让基类<span class="number">4</span>只包含一份基类<span class="number">1</span>，形成菱形继承结构</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ios</span>&#123;..&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">istream</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> ios&#123;..&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ostream</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> ios&#123;..&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iostream</span>:</span><br><span class="line"><span class="keyword">public</span> istream, <span class="keyword">public</span> ostream &#123;..&#125;```</span><br><span class="line">那么，虚拟继承是如何做，使得类<span class="number">4</span>能只包含<span class="number">1</span>份基类<span class="number">1</span>，而不影响其他功能呢：</span><br><span class="line">+ 梳理下：  </span><br><span class="line">上述例子：挑战在于，将istream 和ostream 各自维护的一个ios subobj ，折叠为一个由iostream维护的单一ios subobj ，</span><br><span class="line">并且还可以保存base <span class="keyword">class</span> 和derived <span class="keyword">class</span>的指针（以及reference)之间的多态操作  </span><br><span class="line"> 一般的实现方式如下： <span class="keyword">class</span> 如果内含一个或者多个<span class="keyword">virtual</span> base <span class="keyword">class</span> <span class="title class_">obj</span>,像istream那样，将被分割为两部分，一个不变的局部和一个共享局部  </span><br><span class="line"> 不变的局部中的数据，不管后继如何演化，都总是拥有固定的<span class="built_in">offset</span>(从obj头算起），这部分数据可以直接存取，共享局部，则是<span class="keyword">virtual</span> base <span class="keyword">class</span> subject，这部分数据位置会因为每次派生发生变化，所以他们只能被间接存取  </span><br><span class="line"> </span><br><span class="line"> 所以就是：istream 中有自己的和ios相关的部分，这部分为共享部分</span><br><span class="line">```cpp</span><br><span class="line">  <span class="keyword">class</span> Point2d _x _y</span><br><span class="line"> <span class="keyword">class</span> Point3d:<span class="keyword">public</span> <span class="keyword">virtual</span> Point2d  _z</span><br><span class="line"> <span class="keyword">class</span> Vertex:<span class="keyword">public</span> <span class="keyword">virtual</span> Point2d</span><br><span class="line"> <span class="keyword">class</span> Vertex3d:<span class="keyword">public</span> Point3d <span class="keyword">public</span> Vertex </span><br></pre></td></tr></table></figure>
<p> 那 istream 如何存取这部分共享的数据？和iostream共享？感觉有点像单例模式</p>
<ul>
<li><p>cfront是这样实现的：（这语言没见过）： 会在每个derived class obj中安插一些指针，每个指针 指向一个virtual base class 存取继承得来的virtual base<br>class member;所以在存取时通过这个指针存取<br>在多层继承时间接存取次数多；每个对象需要为每个virtual base class 背负一个指针）<br>              void Point3d::operator+&#x3D;(const Point3d &amp;rhs) {<br>               _x+&#x3D;rhs._x;<br>               _y+&#x3D;rhs._y;<br>               _z+&#x3D;rhs._z;<br>               }<br>              则在这里：被转为：伪代码：_vbcPoint2d-&gt;_x+&#x3D;rhs.__vbcPoint2d-&gt;_x;&#x2F;&#x2F;vbc&#x3D;&#x3D;virtual base class<br>              ….<br><br>             而Point2d *2d&#x3D;3d;<br>             Point2d *2d&#x3D;3d? 3d-&gt;__vbcPoint2d:0;
             
             </p>
</li>
<li><p>microsoft ：引入类似于vbtable的方法，引入virtual base class table 。而在对象中放一个指针指向该表，表则放置那些指向virtual base class 指针<br> Bjarne: g++等（现在可能变了，但是类似）：<br>    在虚函数表中放置virtual base class 的offset而不是地址。<br>    在这里，上面的例子：（this+__vbtr__point3d[-1])-&gt;_x+&#x3D; (&amp;rhs+rhs.__vptr__point3d[-1])-&gt;_x;<br>    …<br>    Point2d *2d&#x3D;3d?3d+3d-&gt;__vptr__point3d[-1]:0
    </p>
</li>
<li><p>注意：若是基类1含有virtual func则会拥有一个vptr指向自己的vtable. 而虚拟继承它的基类2,3，基类2,3本身含有virtual func则不会通过继承基类1的方式<br> 继承它的vptr,所以可以看到在书中的图中point3d有两个指针vptr,以下例子通过kdbg调试可以看到这个两个vptr</p>
</li>
<li><p>两个问题：</p>
</li>
<li><p>基类1在继承连增加时位置如何变化？</p>
</li>
<li><p>在基类自己有virtual func时为什么要自己独用一个vptr?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2d</span> &#123;</span><br><span class="line">                <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">printx</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="type">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> Point2d&#123;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				Vertex *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3d</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> Point2d&#123;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="type">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex3d</span>:<span class="keyword">public</span> Vertex,<span class="keyword">public</span> Point3d&#123;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="type">float</span> mumble;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PO</span>&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">		    <span class="comment">// virtual ~PO();</span></span><br><span class="line">			 <span class="type">static</span> <span class="type">int</span> origin;</span><br><span class="line">			 <span class="type">float</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> PO::origin =<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		Point2d d2d;</span><br><span class="line">		Point3d d3d;</span><br><span class="line">		Vertex vx;</span><br><span class="line">		Vertex3d v3x;</span><br><span class="line">		PO po;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp; PO::z);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;po);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;po.x);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;po.y);</span><br><span class="line"><span class="comment">//		printf(&quot;%d\n&quot;,&amp;po.origin);</span></span><br><span class="line">		<span class="type">float</span> PO::*p1=<span class="number">0</span>;</span><br><span class="line">		<span class="type">float</span> PO::*p2=&amp;PO::x;</span><br><span class="line">		<span class="keyword">if</span>(p1==p2)</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;sma&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;          </span><br></pre></td></tr></table></figure>
<h5 id="使用gdb调试："><a href="#使用gdb调试：" class="headerlink" title="使用gdb调试："></a>使用gdb调试：</h5><p>写完程序后：<br>编译时加-g<br>gdb 科执行程序名</p>
</li>
<li><p>设置断点：break 行号<br>s向下执行<br>set p obj &lt;on&#x2F;off&gt;: 在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。 使用show print object查看对象选项的设置。<br>set p pertty &lt;on&#x2F;off&gt;: 按照层次打印结构体。可以从设置前后看到这个区别。on的确更容易阅读。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> p obj on</span><br><span class="line"><span class="built_in">set</span> p pertty on</span><br><span class="line">p 对象名</span><br><span class="line">p /a ((<span class="type">void</span> ***)d3d)[<span class="number">0</span>]@<span class="number">18</span> <span class="comment">//看到更详细的内存 @18为打印的成员数，[0]指从第0个开始打印--感觉不太对</span></span><br><span class="line">p /a ((<span class="type">void</span> **)vx)[<span class="number">0</span>]@<span class="number">16</span><span class="comment">//同上</span></span><br><span class="line">(gdb) p b</span><br><span class="line">$<span class="number">1</span> = &#123;_vptr.Base = <span class="number">0x400a60</span> &lt;vtable <span class="keyword">for</span> Base+<span class="number">16</span>&gt;&#125;</span><br><span class="line">(gdb) x/<span class="number">16</span>x <span class="number">0x400a60</span></span><br><span class="line"><span class="number">0x400a60</span> &lt;_ZTV4Base+<span class="number">16</span>&gt;:    <span class="number">0x0040094c</span>  <span class="number">0x00000000</span>  <span class="number">0x72654437</span>  <span class="number">0x64657669</span></span><br><span class="line">(gdb) x/<span class="number">16</span>x <span class="number">0x0040094c</span></span><br><span class="line"><span class="number">0x40094c</span> &lt;Base::f()&gt;:   <span class="number">0xe5894855</span>  <span class="number">0x10ec8348</span>  <span class="number">0xf87d8948</span>  <span class="number">0x400a15be</span></span><br><span class="line"><span class="number">0x40095c</span> &lt;Base::f()+<span class="number">16</span>&gt;:    <span class="number">0x10c0bf00</span>  <span class="number">0xf9e80060</span>  <span class="number">0xc9fffffd</span>  <span class="number">0x485590c3</span></span><br><span class="line"><span class="number">0x40096c</span> &lt;Derived::f()+<span class="number">2</span>&gt;:  <span class="number">0x8348e589</span>  <span class="number">0x894810ec</span>  <span class="number">0x1bbef87d</span>  <span class="number">0xbf00400a</span></span><br><span class="line"><span class="number">0x40097c</span> &lt;Derived::f()+<span class="number">18</span>&gt;: <span class="number">0x006010c0</span>  <span class="number">0xfffddbe8</span>  <span class="number">0x66c3c9ff</span>  <span class="number">0x00841f0f</span></span><br><span class="line">  (gdb) <span class="built_in">set</span> $i = <span class="number">0</span></span><br><span class="line">  (gdb) <span class="keyword">while</span> $i &lt; <span class="number">10</span></span><br><span class="line">     &gt;print $i</span><br><span class="line">     &gt;p /a (*(<span class="type">void</span> ***)obj)[$i]</span><br><span class="line">     &gt;<span class="built_in">set</span> $i = $i + <span class="number">1</span></span><br><span class="line">     &gt;end</span><br><span class="line">Where <span class="string">&quot;obj&quot;</span> is the object whose vtable yo<span class="string">u&#x27;d like to print, and 10 is the number of methods.</span></span><br><span class="line"><span class="string">p /a (*(void ***)obj)[0]@10</span></span><br><span class="line"><span class="string">info address _ZTV3Bar</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="对象成员的效率"><a href="#对象成员的效率" class="headerlink" title="对象成员的效率"></a>对象成员的效率</h4><h4 id="指向对象成员变量的指针"><a href="#指向对象成员变量的指针" class="headerlink" title="指向对象成员变量的指针"></a>指向对象成员变量的指针</h4><p>可以用于测试底层布局，如vptr放在哪，access section 次序。等<br>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　<span class="keyword">class</span> <span class="title class_">Point3d</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> :</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Point3d</span>();</span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">        <span class="type">static</span> Point3d origin；</span><br><span class="line">        <span class="type">float</span> x,y,z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1)&amp;Point3d::z  –得到z在class obj中的偏移量<br>需用printf</p>
<p>书中说的为了使得指向对象和对象成员的指针区分，而+1,在g++中没有怎么体现：</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
class Point3d&#123;
        public:
    //            virtual ~Point3d()&#123;;&#125;
                static Point3d origin;
                float x,y,z;
&#125;;
Point3d Point3d::origin;
int main ()
&#123;
        Point3d p3d;
        printf(&quot;&amp;Point3d=%p\n&quot;,&amp;p3d);
        printf(&quot;&amp;Point3d=%p\n&quot;,&amp;p3d.x);//这两个地址相同
        printf(&quot;&amp;Point3d=%p\n&quot;,&amp;p3d.y);
        printf(&quot;&amp;Point3d::x=%p\n&quot;,&amp;Point3d::x);//nil,若Point3d带virtual func,则为8
        printf(&quot;&amp;Point3d::y=%p\n&quot;,&amp;Point3d::y);
        printf(&quot;&amp;Point3d::z=%p\n&quot;,&amp;Point3d::z);
        if((float*)&amp;p3d==(float*)&amp;p3d.x)cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl; //输出yes
        float Point3d::*p1=0;
        float Point3d::*p2=&amp;Point3d::x;
        float Point3d::*p3=NULL;
        if(p1==p2)//未输出
        &#123;
                cout&lt;&lt;&quot;p1==p2&quot;&lt;&lt;endl;//no output in g++
        &#125;
        if(p2==p3)
        &#123;
                cout&lt;&lt;&quot;p2==p3&quot;&lt;&lt;endl;//no output in g++
        &#125;
        return 0;
&#125;```
在这里若是加了virtual func则，x为8，说明是vptr是放在前面的
通过指针取得对象成员:  
```cpp
                    float *p=origin.z  
                    struct  Base1&#123;int val1;&#125;
                    struct Base2 (int val2;&#125;
                    struct Derved:Base1,Base2&#123;..&#125;
                    void func1(int Derved::*bmp,Derved *pd)//传入offset等，多继承时易出错
                    &#123;
                       pd-&gt;*dmp;.....```
</code></pre>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_funcmember_memory</title>
    <url>/2018/06/09/cpp-funcmember-memory/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c-function语意学"><a href="#c-function语意学" class="headerlink" title="c++ function语意学"></a>c++ function语意学</h3><p>something:<br>恩，这部分记录自己对c++中的函数特殊性的理解，本想深入函数本质，之前接触过，记得在linux内核剖析那本书讲的很好。<br> 可以参考；<span id="more"></span></p>
<ul>
<li><p>实现类的成员函数和类之间的关联，即通过对象能调用成员函数。这种实现，可以是以下几种方式：<br> 1）struct+函数指针：结构体中，一个成员函数对应一个指针，增加空间 如何操作成员？<br> 2）函数+this指针，普通函数，this指针一个，不添加额外多的空间，this 操作成员<br> 。。。</p>
</li>
<li><p>c++的类主要是将成员和函数封装起来。那么成员的封装就像struct一样，而函数呢？成员函数如何和类，对象联系起来？–this指针</p>
</li>
<li><p>c++中的成员函数和普通函数一样，只是多了个this指针，这个指针指向当前调用这个函数的对象，并以形参传入，这样，成员函数就可以使用对象成员了，通过<br> this指针；</p>
</li>
<li><p>这里也是根据深入探索c++模型中第四章，function语义学总结的：</p>
<h4 id="引入这个问题："><a href="#引入这个问题：" class="headerlink" title="引入这个问题："></a>引入这个问题：</h4><p> 通过对象和对象指针来调用成员函数的不同：<br>Point3d obj;<br>Point3d *p&#x3D;&amp;obj;<br>两者效率有何不同？</p>
<p>通过上面分析：当这个成员函数为普通的成员函数时，则直接调用函数，传入this指针，所以基本没有大的区别</p>
</li>
</ul>
<h4 id="以下分为几种函数讨论："><a href="#以下分为几种函数讨论：" class="headerlink" title="以下分为几种函数讨论："></a>以下分为几种函数讨论：</h4><h5 id="非静态成员函数："><a href="#非静态成员函数：" class="headerlink" title="非静态成员函数："></a>非静态成员函数：</h5><p>   为了支持this指针等构成成员函数，c++做了如下步骤：  </p>
<ul>
<li><p>a;改写函数原型：安插了一个this参数</p>
</li>
<li><p>b；对对象成员的操作，通过this</p>
</li>
<li><p>c;对成员函数写成外部函数，并将其名称进行mangling处理，成独一无二～类似：函数名___类名参数名 等等</p>
</li>
<li><p>如何命名：成员函数和成员都会被名称特殊化处理：一般加上base class &amp;derived class名<br>   对重载函数而言如何区分：加上参数链表；<br>   当extern C时，会压抑这种特殊命名化<br>   具体编译器实现不同，可以通过汇编等。gdb等看</p>
</li>
<li><p>鉴于此：看一个例子：<br>当你需要构造一个（拷贝构造函数）或者改变一个类的成员： 伪代码：  </p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">normalize__Point</span><span class="params">(<span class="keyword">register</span> <span class="type">const</span> Point3d *<span class="type">const</span> <span class="keyword">this</span>,Point3d &amp;_result)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    _reuslt.Point3d::<span class="built_in">Point3d</span>() <span class="comment">//默认构造函数：</span></span><br><span class="line">    _result._x=<span class="keyword">this</span>-&gt;__x/<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"> 那么，以下这种方式：更好：</span><br><span class="line"> <span class="function">Point3d <span class="title">Point3d::normmalize</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  <span class="built_in">Point3d</span>(_x/<span class="number">2</span> ...)直接构建会更快） </span><br><span class="line">  =》转换为<span class="keyword">return</span> <span class="built_in">Point3d</span>(<span class="keyword">this</span>-&gt;_x/<span class="number">2</span>,...)   </span><br></pre></td></tr></table></figure>
<h5 id="virtual-func"><a href="#virtual-func" class="headerlink" title="virtual func"></a>virtual func</h5><p> 若normilaze是虚拟函数，则<br> ptr-&gt;normilaze()&#x3D;》 （*ptr-&gt;vptr[1])(ptr);<br> 可以看到效率较低，所以当确认不用多态机制的时候，最好抑制它，直接使用：Point3d::xxx  这种方式调用函数<br> 而若被写成内连函数会更优–原因待探索：</p>
</li>
</ul>
<h5 id="静态成员函数："><a href="#静态成员函数：" class="headerlink" title="静态成员函数："></a>静态成员函数：</h5><p> 显然这种能被类直接调用的函数，没有this指针，从而也就无法用成员<br> 这种函数的出现，是因为一种需求：即不用每个成员函数都会使用成员，不一定需要this<br> 不用声明一个对象就可以调用函数，当非要对象不可，又不用成员时：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> ((Point3d*)<span class="number">0</span>)-&gt;<span class="built_in">object_count</span>() ;```</span><br><span class="line"> 有了<span class="type">static</span>后，就不用上述方式了  </span><br><span class="line"> 所以<span class="type">static</span>的特性完全来源它的原理：  </span><br><span class="line">+ 它不能直接存取non <span class="type">static</span> 成员</span><br><span class="line">+ 它不能被声明为<span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">virtual</span></span><br><span class="line">+ 能直接被类调用  </span><br><span class="line"> 静态成员函数和普通函数更像，因为它没有<span class="keyword">this</span>指针，也就不是这种类型：~ <span class="function"><span class="type">unsigned</span> <span class="title">int</span><span class="params">(*)</span> <span class="params">()</span></span>;</span><br><span class="line"> 所以更可以和类之外的元素沟通，比如回调函数</span><br><span class="line"> </span><br><span class="line"> ##### 虚拟成员函数</span><br><span class="line"> + a 为了支持多态，需要在执行期间能判断到底调用哪个函数？即pz-&gt;<span class="built_in">z</span>()这个函数，pz为基类指针，而能调用子类函数</span><br><span class="line"> + b 基类指针或引用参考到的（指向的）子类，，子类中的重写父类的函数，在调用时并不知道传入哪个<span class="keyword">this</span>,即表现为调用哪个函数</span><br><span class="line"> +  c　那么为了支持通过基类能调用它，通过子类也能调用该函数，则需要基类和子类共享某个东西，他能正确决议出要调用的函数</span><br><span class="line"> </span><br><span class="line">+  带来：额外的空间，和c的兼容性</span><br><span class="line">##### 积极多态的概念：</span><br><span class="line">（１）被指出的对象真正被使用；（２）<span class="keyword">dynamic_cast</span>  </span><br><span class="line"> 那么哪些函数需要支持这样的特性－－－》由<span class="keyword">virtual</span>标志来指出  </span><br><span class="line"> 如何在执行期间调用真正的函数？－－－》ptr所指的对象真实类型＋函数的位置　真实类型放在vtable[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">+ 编译期间做的：  </span><br><span class="line">在每个对象中加入：一个字符串或数字来表示<span class="keyword">class</span>　类型＋一个指针，指向表格vtable,它带有程序的<span class="keyword">virtual</span> func执行期地址</span><br><span class="line">确定表格中的函数指针，执行期无法改变表格一个类对应一个表格，每个<span class="keyword">virtual</span> func被指定一个固定的索引值</span><br><span class="line">+ 执行期间做的：</span><br><span class="line"> 为vptr分配内存地址。它的值在编译期间确定，类似于x=<span class="number">3</span>;  指向vtable</span><br><span class="line">调用函数时激活　。编译器已经为其转换语义为xxx-&gt;vptr[n](<span class="keyword">this</span>).. </span><br><span class="line">+ 注意，当一个子类继承基类时，vptr继承过来，当子类改写<span class="keyword">virtual</span>函数时，则改变表中的指针指向子类的；当子类添加一个新的<span class="keyword">virtual</span> func时，则在表中加一个slot</span><br><span class="line">+ 唯一在执行期间才知道的：<span class="built_in">slot</span>(n)到底指向哪个函数实体</span><br><span class="line"> 细想一下：  </span><br><span class="line">      derived de; <span class="comment">//编译期间，符号表确认要分配的对象类型,执行期间分配内存和调用构造函数等，构造函数中会初始化vptr,    </span></span><br><span class="line">      base *p=&amp;de;<span class="comment">//编译期间，类似于int x=3;,执行期间分</span></span><br><span class="line">      配内存给x,并将３给x,确定p所指的真正对象，从而才能取得vptr,到调用到最终的函数</span><br><span class="line">      p-&gt;<span class="built_in">xx</span>();<span class="comment">//xx为virtual (*p-&gt;vptr[1])(p)</span></span><br><span class="line">     </span><br><span class="line">####<span class="meta"># some question     </span></span><br><span class="line"> <span class="comment">//关于执行期和编译期确定的东西，有些困惑，为啥编译器不能在p-&gt;xx()的时候指定调用子类的xx()?</span></span><br><span class="line"> <span class="comment">//在编译器扫描代码的时候，知道定义了一个derived类型的变量，知道，定义了一个base指针，并指向的变量类型为derived,后面调用时也能</span></span><br><span class="line"> 确定函数名，为啥不能根据已存的这些信息。来得到哦。这时p指向的是derive类型的。所以调用derived的函数？</span><br><span class="line"> 不过也是，编译器从做词汇扫描，到语义扫描，出符号表，到语法检查，语义规则等</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">##### 多重继承下面的<span class="keyword">virtual</span> func</span><br><span class="line"> 考虑以下例子：</span><br><span class="line"> ```cpp</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">base1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">     <span class="type">int</span> a;</span><br><span class="line"> 　　　<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> base1* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">base2</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">b</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> base2* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">derive</span>:<span class="keyword">public</span> base1,<span class="keyword">public</span> base2</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">c</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> c;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> derive* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br> 对于和derived有相同起点的base1不用考虑太多，关键是base2,;有三个问题要解决：</p>
<pre><code>  　(1)virtual destructor (记得之前是逐层调用）
 　（２）被继承下来的b()
    (3）一组clone函数 
  （a)   做base2 *pbase2=new derive;
  　　　　＆＆＆编译期间确定：＆＆＆
   =&gt;  derived *tmp=new derive;
   　　　base2 *pbase2=tmp?tmp+sizeof(base1):0;```
      
 为了使pbase2能访问到　b 即pbase２-&gt;b, 多重继承下使用 base *p=de;时，注意此时需要调整，让p指向的是de中的base对应部分
+ 当通过delete pbase2时，此时需要删除完整的对象，所以pbase２指针需要调整到指出完整对象的起始点  
  他也要通过上述a类似的加法，以及调用virtual destructor函数  
```cpp 
   如base2 *pbase2=new derive;  
  delete pbase2;//invoke derive class&#39;s destructor (virtual )```
  
 　首先这个调用要通过vptr,其次，传入的this指针需要调整
  ＆＆＆执行期间确定＆＆＆
+ 注意：然而，这种offset加法无法在编译期间直接设定。pbase2所指的真正对象只有在执行期间才能确定  
//如何调整；早期的想法是：将vtable中的slot改为一个slot放置函数指针faddr和this的offset  
 //则：（*pbase2-&gt;vptr[1])(pbase2);  
 //改为　（*pbase2-&gt;vptr[1].faddr)(pbase2+pbase2-  &gt;vptr[1].offset);但是连带处罚了其他形式virtual func调用，
  
 + 那如何处理？  
 + [１]方法１：thunk
  　　　～：this+=sizeof(base1)
          Derived::~Derived(this);//只有汇编才有效率
   如何使能？在virtual table slot继续内含一个简单的指针，slot中的地址可以指向一个virtual func或者一个thunk(若需要调整this)
  其实多重继承来讲，每个继承的基类，都需要一个virtual table;,这样派生类就会维护多个基类的vtable
  + 1)经由derived或第一个base class)调用，不需要调整this
  + 2)经由&gt;=2的base class 调用，同一种函数在virtual table中可能需要多笔对应的slot
        base1 *pbase1 =new derived;
        base2 *pbase2=new derived;
        delete pbase1//不需要调整this,virtual table slot放置正真的destructor地址
        
        delete pbase2//需要调整this ,放置thunk
        vptr和vtable命名也会被特殊化
        参考图在书中，这里不放
+ [２]方法２　：  
   因为动态链接器的原因，使得符号链接变得缓慢
   为了调整执行期链接器的效率，sun编译器将多个vtable 连锁为一个，指向次要表格的指针可以由主要表格加offset
　  其他类似。
例子：
```cpp
　　　　　　　base2 *ptr =new derived;
       delete ptr;//此时调用derived::~deirved,故ptr需要被调整，若为virtual，需要更多
       
       derived *pder=new derived;
       pder-&gt;b();//注意b没有被改写，所以需要调整pder指向base2 subobj
       
       base2 *pb1=new derived;
       base2 *pb2=pb1-&gt;clone()//注意是调用derived:clone,所以调用后返回值要改变器指向base2 subobj
       
       当函数被认为足够小　，sun编译器会采用某种算法优化，split。。，否则不会，具体待了解。
       所以virtual func的通常大小为８行```
+ [３]IBM:  
函数若支持多重进入点，将不必有许多thunk;将thunk操作放在virtual func中，里面判断是否需要调整this指针
     
     
##### 虚拟继承下的virtual func
这种情况相当复杂了。需要探索上述的这些问题：point2d.point3d的对象不再相符，即使只继承一个，即单一虚拟继承，也需要调整this指针
```cpp
class point2d&#123;
  public:
  point2d()
  virtual ~point2d()
  virtual void mumble()
  virutal  float z()
  protected:
  float _x,_y;
  &#125; 
  class point3d:public virtual point2d&#123;
    public:
    point3d()
    ~point3d
    protected:
    float _z;
    &#125;```
    可以尝试下写出例子比较point2d和point3d指针看指向是否相同
    当virtual base class中包含virtual func和nonstatic member时，各个厂商实现不同，复杂，作者不建议这么做
    
    －－－－－－－－－－－－－－－－－－－
#### 函数的效能：
  这部分可以通过函数的调用方式感性的了解，或者根据不同的编译器。测试对比几种调用的时间，以及是否已经开启优化等
  （如编译器将被视为不变的表达式提到循环之外）
  （通过消除局部对象的使用可以消除对constructor的调用）
  
#### 指向memeber　func的指针：
  取一个nonstatic member func的地址，若为nonvirtual 则为其在内存中的真正地址。
  但需要this参数。　
  指向member func的指针：double (Point::*pmf)();类似
  定义：double (point::*coord)() =&amp;point::x;
       赋值:coord=&amp;point::y
       调用：（origin.*coord)()/(ptr-&gt;*coord)()
       转换为：(coord)(&amp;origin)/(coord)(ptr)
       
##### 指向virtual memeber func指针
  在g++中
  ```cpp
  #include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
class Base1 &#123;
        public:
                virtual float getp() &#123; return mp;&#125;
                void setp(float mmp)&#123;mp=mmp;&#125;
                virtual int test()&#123;return 3;&#125;
                virtual int test1()&#123;return 4;&#125;
        private:
                float mp;
&#125;; 
int main()
&#123;  
        float (Base1::*pmf)()=&amp;Base1::getp;
        Base1 *ptr=new Base1;
        ptr-&gt;setp(3.2);
        cout&lt;&lt;ptr-&gt;getp()&lt;&lt;endl;//3.2
        cout&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;endl;//3.2　　会被内部转换：（*ptr-&gt;vptr[(int)pmf])(ptr)
        printf(&quot;%p\n&quot;,&amp;Base1::getp);//1　索引值
        printf(&quot;%p\n&quot;,&amp;Base1::setp);//40xxx真实地址
        printf(&quot;%p\n&quot;,&amp;Base1::test);// 9，为什么是９不清楚
        printf(&quot;%p\n&quot;,&amp;Base1::test1);//11
        
        return  0;
&#125;```
　　所以，对于虚拟函数也是可以通过函数指针来访问的，只不过得到的地址是索引值，但不影响访问
或者对以下
```cpp
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
class Base1 &#123;
        public:
                virtual float getp() &#123; return mp;&#125;
                void setp(float mmp)&#123;mp=mmp;&#125;
                    int test()&#123;return 3;&#125;
                virtual int test1()&#123;return 4;&#125;
        private:
                float mp;
&#125;; 
int main()
&#123;  
        float (Base1::*pmf)()=&amp;Base1::getp;
        Base1 *ptr=new Base1;
        ptr-&gt;setp(3.2);
        cout&lt;&lt;ptr-&gt;getp()&lt;&lt;endl;
        cout&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;endl;
        printf(&quot;%p\n&quot;,&amp;Base1::getp);
        printf(&quot;%p\n&quot;,&amp;Base1::setp);
        printf(&quot;%p\n&quot;,&amp;Base1::test);
        printf(&quot;%p\n&quot;,&amp;Base1::test1);
                  
                int (Base1::*pmi)()=&amp;Base1::test1;//or test　可以指向两种，编译器如何区分呢？cfront２　通过判断是索引（may &lt;127)还是函数地址来区分
                Base1 *ptr2=new Base1;
                cout&lt;&lt;(ptr2-&gt;*pmi)()&lt;&lt;endl;
                delete ptr;
                delete ptr2;
        
        return  0;
&#125;```
##### 多重继承下指向member func指针
为了让mem func point能支持多重继承和虚拟继承：
噢这种情况很复杂了。你得知道它指向的是virtual 还是non virtual
书中并没有探讨太多，野比较复杂，这里举一个例子，探索细节可以看编译器，gdb等结果：
```cpp
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
class Base1 &#123;
        public:
                virtual float getp() &#123; return mp;&#125;
                void setp(float mmp)&#123;mp=mmp;&#125;
                    int test()&#123;return 3;&#125;
                virtual int test1()&#123;return 4;&#125;
        private:
                float mp;
&#125;;
class Base2 &#123;
        public:
                virtual float get2p()&#123;return m2p;&#125;
                virtual void set2p(float m2pp)&#123;m2p=m2pp;&#125;
                int test22() &#123;return 5;&#125;
                virtual int test21()&#123;return 6;&#125;
        private:
                float m2p;
&#125;;
class Der:public Base1,public Base2&#123;
        public:
                virtual float get3p()&#123;return m3p;&#125;
        private:
                float m3p;

&#125;;
int main()
&#123;  
        float (Base1::*pmf)()=&amp;Base1::getp;//这后面的调用就发挥想象把，想怎么尝试都行
        Base1 *ptr=new Der;
        ptr-&gt;setp(3.2);
        cout&lt;&lt;ptr-&gt;getp()&lt;&lt;endl;
        cout&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;endl;
        printf(&quot;%p\n&quot;,&amp;Der::getp);
        printf(&quot;%p\n&quot;,&amp;Base1::setp);
        printf(&quot;%p\n&quot;,&amp;Base1::test);
        printf(&quot;%p\n&quot;,&amp;Base1::test1);
                  
                int (Base1::*pmi)()=&amp;Base1::test1;//or test
                Base1 *ptr2=new Base1;
                cout&lt;&lt;(ptr2-&gt;*pmi)()&lt;&lt;endl;
                delete ptr;
                delete ptr2;
        
        return  0;
&#125;```
##### 效能
##### inline func:
首先得直到，内联函数实际上表现为什么？函数本质上被经过栈调用，而内联函数是直接　在主函数中铺开为表达式，所以调用内联函数　能提高效率，但是响应的
源代码会变大，而且有参数的限制
应用：在操作符函数中，指定set,get类函数，使得操作符函数能被写成普通的函数。　而set get 写成inline函数，会减少效率降低
inline关键词只是请求，并不会所有都inline展开，编译器会做判断权衡
具体看书，不是很细
内联函数两个注意点：
形式参数：inline扩展时，每一个形式参数会被对应的实际参数代替：
```cpp
　　　　　　　　inline int min (int i,int j)&#123;
                   return i&lt;j?i:j;
                   &#125;
         三个调用：
         inline int bar() &#123;
            int minval;
            int val1=1024;
            int val2=2048;
            minval=min(val1,val2); 参数直接替换val1&lt;val2?val1:val2;
            minval=min(1024,2048);替换后直接使用常量：1024
            minval=min(fool(),bar()+1) 引发参数副作用，需要导入一个临时对象，以避免重复求值：
            　　　　     int t1,t2; minval=(t1=foo()),(t2=bar()+1),t1&lt;t2?...)
           
           
            return minval&#125;```
 局部变量:在内联函数中加入局部变量，会导致因为维护局部变量带来的成本；  
 内联函数在替代c宏，是比较安全的；但是若宏中参数有副作用的话，如上，会导致大的扩展码以维护局部变量或者生成临时的变量
            
</code></pre>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_polymorphism</title>
    <url>/2018/06/09/cpp-polymorphism/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h3><h4 id="为什么需要多态？"><a href="#为什么需要多态？" class="headerlink" title="为什么需要多态？"></a>为什么需要多态？</h4><p>引入几个点：<br>　　继承的机制中，基类的指针和引用能指向派生类，（派生类对象中的基类成员是在内存前面的，即指向派生类对象的指针指向的是第一个基类的第一个成员）  </p>
<ul>
<li>指针的值本质上是内存地址，也就是说指向不同变量(int char.)，对象的指针本身的值都是地址的value)</li>
<li>指针的类型限定了指针的操作内存范围和取值的方式，如通过int指针取值的时候，取到４byte,通过char指针取值时取得1byte;）<span id="more"></span></li>
<li>因此，基类指针限定了，即使它指向派生类，它也只能操作基类自身的成员和方法；就像char形指针指向int形，取得的只是一部分）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="number">4</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 5 </span>&#123;</span><br><span class="line"> <span class="number">6</span>     <span class="type">int</span> in=<span class="number">2</span>;</span><br><span class="line"> <span class="number">7</span>     <span class="type">char</span> *pc=(<span class="type">char</span>*)&amp;in;</span><br><span class="line"> <span class="number">8</span>     cout&lt;&lt;*pc&lt;&lt;endl;<span class="comment">//乱码</span></span><br><span class="line"> <span class="number">9</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure>

<p>所以基类指针可以指向子类，但是只能调用基类的函数，即使子类复写了父类的函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Base&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Derived&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;rBase = derived;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rBase is a &quot;</span> &lt;&lt; rBase.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This example prints the result:</p>
<p>rBase is a Base</p>
<p>&#x2F;＝》简化：如何让下面的例子得到想要的结果？  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Animal *animals[] = &#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> iii=<span class="number">0</span>; iii &lt; <span class="number">6</span>; iii++)</span><br><span class="line">        std::cout &lt;&lt; animals[iii]-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; says &quot;</span> &lt;&lt; animals[iii]-&gt;<span class="built_in">speak</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如何让父类指针指向子类对象，可以调用子类函数呢？<br>－－－多态</li>
<li>调用的子类函数要满足:<br>A derived function is considered a match if it has the same signature (name, parameter types, and whether it is const) and return type as the base version of the function. Such functions are called overrides.</li>
</ul>
<h4 id="如何使用－－－例子"><a href="#如何使用－－－例子" class="headerlink" title="如何使用－－－例子"></a>如何使用－－－例子</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Base&quot;</span>; &#125; <span class="comment">// note addition of virtual keyword</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Derived&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;rBase = derived;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rBase is a &quot;</span> &lt;&lt; rBase.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This example prints the result:</p>
<p>rBase is a Derived<br>－－－－－－－－－－－－－－－－－－－－－－－<br>再盗一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We&#x27;re making this constructor protected because</span></span><br><span class="line">    <span class="comment">// we don&#x27;t want people creating Animal objects directly,</span></span><br><span class="line">    <span class="comment">// but we still want derived classes to be able to use it.</span></span><br><span class="line">    <span class="built_in">Animal</span>(std::string name)</span><br><span class="line">        : <span class="built_in">m_name</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;???&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>: <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(std::string name)</span><br><span class="line">        : <span class="built_in">Animal</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Meow&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(std::string name)</span><br><span class="line">        : <span class="built_in">Animal</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Woof&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(Animal &amp;animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; animal.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; says &quot;</span> &lt;&lt; animal.<span class="built_in">speak</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cat <span class="title">cat</span><span class="params">(<span class="string">&quot;Fred&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">dog</span><span class="params">(<span class="string">&quot;Garbo&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">report</span>(cat);</span><br><span class="line">    <span class="built_in">report</span>(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意多态的方式："><a href="#注意多态的方式：" class="headerlink" title="注意多态的方式："></a>注意多态的方式：</h4><p>调用基类指针指向子类，函数时，会调用到继承琏最底端，且该最低端的子类有该virtual函数的，否则只调用到最下且复写了该函数的。如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="number">1</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="number">2</span> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="number">3</span> <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">  <span class="number">4</span> &#123;</span><br><span class="line">  <span class="number">5</span>         <span class="keyword">public</span>:</span><br><span class="line">  <span class="number">6</span>                     <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">  <span class="number">7</span> &#125;;</span><br><span class="line">  <span class="number">8</span> </span><br><span class="line">  <span class="number">9</span> <span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line"> <span class="number">10</span> &#123;</span><br><span class="line"> <span class="number">11</span>         <span class="keyword">public</span>:</span><br><span class="line"> <span class="number">12</span>                     <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line"> <span class="number">13</span> &#125;;</span><br><span class="line"> <span class="number">14</span> </span><br><span class="line"> <span class="number">15</span> <span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> B</span><br><span class="line"> <span class="number">16</span> &#123;</span><br><span class="line"> <span class="number">17</span>         <span class="keyword">public</span>:</span><br><span class="line"> <span class="number">18</span>                     <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">                        <span class="comment">//or const char * getName()&#123;..&#125; and default virtual</span></span><br><span class="line"> <span class="number">19</span> &#125;;</span><br><span class="line"> <span class="number">20</span> </span><br><span class="line"> <span class="number">21</span> <span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> C</span><br><span class="line"> <span class="number">22</span> &#123;</span><br><span class="line"> <span class="number">23</span>         <span class="keyword">public</span>:</span><br><span class="line"> <span class="number">24</span>                    <span class="comment">// virtual const char* getName() &#123; return &quot;D&quot;; &#125;</span></span><br><span class="line"> <span class="number">25</span> &#125;;</span><br><span class="line"> <span class="number">26</span> </span><br><span class="line"> <span class="number">27</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 28 </span>&#123;</span><br><span class="line"> <span class="number">29</span>             D d;</span><br><span class="line"> <span class="number">30</span>             A &amp;rBase = d;</span><br><span class="line"> <span class="number">31</span>             std::cout &lt;&lt; <span class="string">&quot;rBase is a &quot;</span> &lt;&lt; rBase.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> <span class="number">32</span> </span><br><span class="line"> <span class="number">33</span>             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">34</span> &#125;```</span><br><span class="line">     输出c</span><br><span class="line">     </span><br><span class="line">#### 注意点：</span><br><span class="line">+ <span class="keyword">virtual</span>关键字是否都需要写？：  </span><br><span class="line">Only the most base <span class="keyword">class</span> <span class="title class_">function</span> needs to be tagged as <span class="keyword">virtual</span> <span class="keyword">for</span> all of the derived </span><br><span class="line">functions to work virtually. However, having the keyword <span class="keyword">virtual</span> on the derived functions</span><br><span class="line"> does <span class="keyword">not</span> hurt, <span class="keyword">and</span> it serves as a useful reminder that the function is a <span class="keyword">virtual</span> function </span><br><span class="line"> rather than a normal one.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">+ 不能在构造函数和西沟函数中调用它，因为此时子类对象还没有被构造</span><br><span class="line"> </span><br><span class="line">+ c++<span class="number">11</span>引入<span class="keyword">override</span>和<span class="keyword">final</span>来防止避免不匹配的复写和阻止继承：  </span><br><span class="line"> １）<span class="keyword">override</span>:  </span><br><span class="line"> 出现错误的例子:</span><br><span class="line"> ```cpp</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName1</span><span class="params">(<span class="type">short</span> <span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// note: parameter is a short int</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName2</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// note: function is const</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	A &amp;rBase = b;</span><br><span class="line">	std::cout &lt;&lt; rBase.<span class="built_in">getName1</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	std::cout &lt;&lt; rBase.<span class="built_in">getName2</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 由于参数返回值不匹配，所以编译器认为不是复写，结果：<br> A<br>A</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">加入<span class="keyword">override</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName3</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName1</span><span class="params">(<span class="type">short</span> <span class="type">int</span> x)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// compile error, function is not an override</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName2</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// compile error, function is not an override</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName3</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// okay, function is an override of A::getName3(int) </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">Rule: Apply the <span class="keyword">override</span> specifier to every intended <span class="keyword">override</span> function you write.</span><br></pre></td></tr></table></figure>
<ul>
<li>final: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> 加了<span class="keyword">final</span>的函数无法被复写：</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// note use of final specifier on following line -- that makes this function no longer overridable</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// okay, overrides A::getName()</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>; &#125; <span class="comment">// compile error: overrides B::getName(), which is final</span></span><br><span class="line">&#125;;</span><br><span class="line"> 加了<span class="keyword">final</span>的类不能被继承：</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">final</span> : <span class="keyword">public</span> A <span class="comment">// note use of final specifier here</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B <span class="comment">// compile error: cannot inherit from final class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> ````</span><br><span class="line"> </span><br><span class="line">+ 对匹配返回值的一个“例外”：covariant <span class="keyword">return</span> types:</span><br><span class="line"> ```cpp</span><br><span class="line"> <span class="keyword">class</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// This version of getThis() returns a pointer to a Base class</span></span><br><span class="line">    <span class="keyword">virtual</span> Base* <span class="built_in">getThis</span>() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Normally override functions have to return objects of the same type as the base function</span></span><br><span class="line">    <span class="comment">// However, because Derived is derived from Base, it&#x27;s okay to return Derived* instead of Base*</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;```</span><br><span class="line"></span><br><span class="line">注意当base=&amp;derive;</span><br><span class="line">     base.<span class="built_in">getThis</span>()----取得的任然是base</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#### 当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：</span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;base = derived;</span><br><span class="line">    <span class="comment">// Calls Base::GetName() instead of the virtualized Derived::GetName()</span></span><br><span class="line">    std::cout &lt;&lt; base.Base::<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;　　</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="虚析构函数-："><a href="#虚析构函数-：" class="headerlink" title="虚析构函数　："></a>虚析构函数　：</h3><h4 id="为什么需要虚析构函数："><a href="#为什么需要虚析构函数：" class="headerlink" title="为什么需要虚析构函数："></a>为什么需要虚析构函数：</h4><p> 当基类指针指向派生类时，当析构后，只会调用基类的析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() <span class="comment">// note: not virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling ~Base()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* m_array;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_array = <span class="keyword">new</span> <span class="type">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="comment">// note: not virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling ~Derived()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *derived = <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="number">5</span>);</span><br><span class="line">    Base *base = derived ;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;```</span><br><span class="line"> 只输出Calling ~<span class="built_in">Base</span>()</span><br><span class="line"> + 所以为了调用派生类的析构函数，需要定义为虚析构函数：</span><br><span class="line"> ```cpp</span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() <span class="comment">// note: virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling ~Base()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* m_array;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_array = <span class="keyword">new</span> <span class="type">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() <span class="comment">// note: virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling ~Derived()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *derived = <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="number">5</span>);</span><br><span class="line">    Base *base = derived;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Now <span class="keyword">this</span> program produces the following result:</span><br><span class="line">Calling ~<span class="built_in">Derived</span>()</span><br><span class="line">Calling ~<span class="built_in">Base</span>()</span><br><span class="line">Rule: Whenever you are dealing with inheritance, you should make any <span class="keyword">explicit</span> destructors <span class="keyword">virtual</span>. ```</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> ### 虚表：</span><br><span class="line"> #### Early binding（静态绑定） <span class="keyword">and</span> late binding（动态绑定）</span><br><span class="line"> 前者指的是直接在代码里调用函数，通过函数名，即编译期间就可以直到函数的地址的（偏移，非真实的内存地址）  </span><br><span class="line"><span class="string">&quot;&quot;</span> <span class="function">Early <span class="title">binding</span> <span class="params">(also called <span class="type">static</span> binding)</span> means the <span class="title">compiler</span> <span class="params">(<span class="keyword">or</span> linker)</span> is able to directly associate the identifier <span class="title">name</span> <span class="params">(such as a function <span class="keyword">or</span> variable name)</span> with a machine address. </span></span><br><span class="line"><span class="function"> Remember that all functions have a unique address. So when the <span class="title">compiler</span> <span class="params">(<span class="keyword">or</span> linker)</span> encounters a function call, </span></span><br><span class="line"><span class="function">  it replaces the function call with a machine language instruction that tells the CPU to jump to the address of the function.&quot;&quot;</span></span><br><span class="line"><span class="function"> ```cpp</span></span><br><span class="line"><span class="function"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter another number: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; y;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter an operation (0=add, 1=subtract, 2=multiply): &quot;</span>;</span><br><span class="line">        std::cin &gt;&gt; op;</span><br><span class="line">    &#125; <span class="keyword">while</span> (op &lt; <span class="number">0</span> || op &gt; <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// call the target function directly using early binding</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: result = <span class="built_in">add</span>(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: result = <span class="built_in">subtract</span>(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: result = <span class="built_in">multiply</span>(x, y); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The answer is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;```</span><br><span class="line"> 后者指的是通过函数指针等方式，即在编译期间无法确定调用什么函数，需要通过指针来访问函数（函数指针），效率比前者低</span><br><span class="line"> in some programs, <span class="function">it is <span class="keyword">not</span> possible to know which function will be called until <span class="title">runtime</span> <span class="params">(when the program is run)</span>. </span></span><br><span class="line"><span class="function"> This is known as late <span class="title">binding</span> <span class="params">(<span class="keyword">or</span> dynamic binding)</span>. In C++, one way to get late binding is to use function pointers. </span></span><br><span class="line"><span class="function"> ```cpp</span></span><br><span class="line"><span class="function"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a function pointer and make it point to the Add function</span></span><br><span class="line">    <span class="built_in">int</span> (*pFcn)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">pFcn</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// add 5 + 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h4><p> 为什么虚函数能成立－－基类指针指向派生类能调用派生类的函数：<br> 实际上，在定义了虚函数的基类中维护了一个虚指针：它指向一张表，表中包含各个虚函数指针；在这个继承琏中的每一个类有自己的一张虚表，这张表由编译器在编译期间生成, 虚指针在包含虚函数的类的对象被创建时自动创建</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;; </span><br><span class="line"> 实际上为：</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FunctionPointer *__vptr;<span class="comment">//虚指针</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> base</span><br><span class="line">    *__vptr;--------------------------&gt;<span class="function">base vtable</span></span><br><span class="line"><span class="function">   <span class="keyword">virtual</span> <span class="title">function1</span><span class="params">()</span>&lt;----------------<span class="title">function1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">|-&gt;<span class="keyword">virtual</span> <span class="title">function2</span><span class="params">()</span>&lt;----------------<span class="title">function2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">-----------------------------------------------------|</span></span><br><span class="line"><span class="function">   D1:public base                                    |</span></span><br><span class="line"><span class="function">   *__vptr,(inherited) ----------------D1 vtable     |</span></span><br><span class="line"><span class="function">   virtual function1();</span> &lt;--------------<span class="built_in">function1</span>()   |</span><br><span class="line">                                       <span class="built_in">function2</span>()----</span><br><span class="line"> D2类似D1</span><br></pre></td></tr></table></figure>
<h3 id="纯虚函数和纯虚类："><a href="#纯虚函数和纯虚类：" class="headerlink" title="纯虚函数和纯虚类："></a>纯虚函数和纯虚类：</h3><h4 id="什么是纯虚函数和纯虚类："><a href="#什么是纯虚函数和纯虚类：" class="headerlink" title="什么是纯虚函数和纯虚类："></a>什么是纯虚函数和纯虚类：</h4><ul>
<li>没有定义函数体的虚成员函数成为纯虚函数：<br>  virtual int getValue() &#x3D; 0; &#x2F;&#x2F; a pure virtual function<br>  包含一个或多个纯虚函数的类成为纯虚类<br>  虚基类是不能被对象化的，当对象化后调用纯虚函数，就会出现错误  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base; <span class="comment">// We can&#x27;t instantiate an abstract base class, but for the sake of example, pretend this was allowed</span></span><br><span class="line">    base.<span class="built_in">getValue</span>(); <span class="comment">// what would this do?</span></span><br><span class="line">&#125;```</span><br><span class="line">#### 为什么需要纯虚函数和纯虚类？</span><br><span class="line">当子类继承了基类后，对虚函数来讲，需要复写基类的虚函数，而当忘记去写时，默认就会调用基类的虚函数；  </span><br><span class="line">而如果将基类的虚函数定义为纯虚函数。就会通过编译报错来提醒我们要复写子类的虚函数：  </span><br><span class="line"> 例子：  </span><br><span class="line"> ```cpp</span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="comment">// This Animal is an abstract base class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(std::string name)</span><br><span class="line">        : <span class="built_in">m_name</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// note that speak is now a pure virtual function</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cow</span>: <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cow</span>(std::string name)</span><br><span class="line">        : <span class="built_in">Animal</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We forgot to redefine speak</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">cow</span><span class="params">(<span class="string">&quot;Betsy&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; cow.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; says &quot;</span> &lt;&lt; cow.<span class="built_in">speak</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cow</span>: <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cow</span>(std::string name)</span><br><span class="line">        : <span class="built_in">Animal</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Moo&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">cow</span><span class="params">(<span class="string">&quot;Betsy&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; cow.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; says &quot;</span> &lt;&lt; cow.<span class="built_in">speak</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当想要使用虚基类的实现时，又同时想让虚基类不能对象化且子类能提示需要实现纯虚函数时，应该怎么做？<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="comment">// This Animal is an abstract base class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(std::string name)</span><br><span class="line">        : <span class="built_in">m_name</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// note that speak is a pure virtual function</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Animal::speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;buzz&quot;</span>; <span class="comment">// some default implementation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dragonfly</span>: <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dragonfly</span>(std::string name)</span><br><span class="line">        : <span class="built_in">Animal</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">speak</span><span class="params">()</span> <span class="comment">// this class is no longer abstract because we defined this function</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Animal::<span class="built_in">speak</span>(); <span class="comment">// use Animal&#x27;s default implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Dragonfly <span class="title">dfly</span><span class="params">(<span class="string">&quot;Sally&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; dfly.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; says &quot;</span> &lt;&lt; dfly.<span class="built_in">speak</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">The above code prints:</span><br><span class="line">Sally says buzz</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="接口类："><a href="#接口类：" class="headerlink" title="接口类："></a>接口类：</h4><p>接口类的类中没有成员变量。全部由纯虚函数构成；常命名为I开头的:如IErrorLog,类似于java中的接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IErrorLog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">openLog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">closeLog</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">writeError</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *errorMessage)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IErrorLog</span>() &#123;&#125;; <span class="comment">// make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called</span></span><br><span class="line">&#125;;```</span><br><span class="line">###<span class="meta"># virtual base class</span></span><br><span class="line">当普通的继承，即一个子类继承自两个不同的父类，这两个父类继承自同一个基类时。就容易出现问题：</span><br><span class="line">如：</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoweredDevice</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PoweredDevice</span>(<span class="type">int</span> power)</span><br><span class="line">    &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;PoweredDevice: &quot;</span> &lt;&lt; power &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scanner</span>: <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Scanner</span>(<span class="type">int</span> scanner, <span class="type">int</span> power)</span><br><span class="line">        : <span class="built_in">PoweredDevice</span>(power)</span><br><span class="line">    &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Scanner: &quot;</span> &lt;&lt; scanner &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>: <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="type">int</span> printer, <span class="type">int</span> power)</span><br><span class="line">        : <span class="built_in">PoweredDevice</span>(power)</span><br><span class="line">    &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Printer: &quot;</span> &lt;&lt; printer &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Copier</span>: <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Copier</span>(<span class="type">int</span> scanner, <span class="type">int</span> printer, <span class="type">int</span> power)</span><br><span class="line">        : <span class="built_in">Scanner</span>(scanner, power), <span class="built_in">Printer</span>(printer, power)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Copier <span class="title">copier</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">PoweredDevice: <span class="number">3</span></span><br><span class="line">Scanner: <span class="number">1</span></span><br><span class="line">PoweredDevice: <span class="number">3</span></span><br><span class="line">Printer: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>从输出看，基类被构造了两次<br>如何防止构造两个基类呢？使用virtual base class</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PoweredDevice</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scanner</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Copier</span>: <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoweredDevice</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PoweredDevice</span>(<span class="type">int</span> power)</span><br><span class="line">    &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;PoweredDevice: &quot;</span> &lt;&lt; power &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scanner</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice <span class="comment">// note: PoweredDevice is now a virtual base class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Scanner</span>(<span class="type">int</span> scanner, <span class="type">int</span> power)</span><br><span class="line">        : <span class="built_in">PoweredDevice</span>(power) <span class="comment">// this line is required to create Scanner objects, but ignored in this case</span></span><br><span class="line">    &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Scanner: &quot;</span> &lt;&lt; scanner &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice <span class="comment">// note: PoweredDevice is now a virtual base class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="type">int</span> printer, <span class="type">int</span> power)</span><br><span class="line">        : <span class="built_in">PoweredDevice</span>(power) <span class="comment">// this line is required to create Printer objects, but ignored in this case</span></span><br><span class="line">    &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Printer: &quot;</span> &lt;&lt; printer &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Copier</span>: <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Copier</span>(<span class="type">int</span> scanner, <span class="type">int</span> printer, <span class="type">int</span> power)</span><br><span class="line">        : <span class="built_in">Scanner</span>(scanner, power), <span class="built_in">Printer</span>(printer, power),</span><br><span class="line">        <span class="built_in">PoweredDevice</span>(power) <span class="comment">// PoweredDevice is constructed here</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">This time, our previous example:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Copier <span class="title">copier</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">produces the result:</span><br><span class="line">PoweredDevice: <span class="number">3</span></span><br><span class="line">Scanner: <span class="number">1</span></span><br><span class="line">Printer: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这样的话，基类的构造交给了继承琏最底层的类</p>
<ul>
<li>注意：</li>
<li>virtual base class在子类对象之前就创建了</li>
<li>if Copier was singly inherited from Printer, and Printer was virtually inherited from PoweredDevice, Copier is still responsible for creating PoweredDevice</li>
<li>Fourth, a virtual base class is always considered a direct base of its most derived class<br>(which is why the most derived class is responsible for its construction).</li>
<li>But classes inheriting the virtual base still need access to it. So in order to facilitate this, the compiler creates a virtual table for each class directly inheriting the virtual class (Printer and Scanner). These virtual tables point to the functions in the most derived class. Because the derived classes have a virtual table,  that also means they are now larger by a pointer (to the virtual table).</li>
</ul>
<h4 id="对象分割："><a href="#对象分割：" class="headerlink" title="对象分割："></a>对象分割：</h4><p>当子类对象赋值给基类会发生什么？<br>子类对象的基类部分会给基类对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    Base base = derived; <span class="comment">// what happens here?</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;base is a &quot;</span> &lt;&lt; base.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; and has value &quot;</span> &lt;&lt; base.<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">传值给基类</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(<span class="type">const</span> Base base)</span> <span class="comment">// note: base passed by value, not reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;I am a &quot;</span> &lt;&lt; base.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">This is a pretty simple function with a <span class="type">const</span> base object parameter that is passed by value. If we call <span class="keyword">this</span> function like such:	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printName</span>(d); <span class="comment">// oops, didn&#x27;t realize this was pass by value on the calling end </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector<base>和vector&lt;&amp;base&gt;和vector&lt;base*&gt;<br>第一种可以但是只能调用基类的部分<br>第二种不行：std::vector&lt;Base&amp;&gt; v;<br>Unfortunately, this won’t compile. The elements of std::vector must be assignable, whereas references can’t be reassigned (only initialized).<br>第三种可以但是要做delete</p>
<pre><code class="cpp">#include &lt;vector&gt;
int main()
&#123;
    std::vector&lt;Base*&gt; v;
    v.push_back(new Base(5)); // add a Base object to our vector
    v.push_back(new Derived(6)); // add a Derived object to our vector
        // Print out all of the elements in our vector
    for (int count = 0; count &lt; v.size(); ++count)
        std::cout &lt;&lt; &quot;I am a &quot; &lt;&lt; v[count]-&gt;getName() &lt;&lt; &quot; with value &quot; &lt;&lt; v[count]-&gt;getValue() &lt;&lt; &quot;\n&quot;;
    for (int count = 0; count &lt; v.size(); ++count)
        delete v[count];
    return 0;
&#125;
用智能指针可以避免：
#include &lt;vector&gt;
#include &lt;functional&gt; // for std::reference_wrapper
int main()
&#123;
    std::vector&lt;std::reference_wrapper&lt;Base&gt; &gt; v; // our vector is a vector of std::reference_wrapper wrapped Base (not Base&amp;)
    Base b(5); // b and d can&#39;t be anonymous objects
    Derived d(6);
    v.push_back(b); // add a Base object to our vector
    v.push_back(d); // add a Derived object to our vector
    // Print out all of the elements in our vector
    for (int count = 0; count &lt; v.size(); ++count)
        std::cout &lt;&lt; &quot;I am a &quot; &lt;&lt; v[count].get().getName() &lt;&lt; &quot; with value &quot; &lt;&lt; v[count].get().getValue() &lt;&lt; &quot;\n&quot;; // we use .get() to get our element from the wrapper
    return 0;
&#125;```


一种极端情况：
```cpp
int main()
&#123;
    Derived d1(5);
    Derived d2(6);
    Base &amp;b = d2;//b为d2的引用
    b = d1; // this line is problematic　导致b的基类部分为d1,子类部分为d2,因为b是d2的引用，导致现在d2的基类部分是d1而子类部分是d2
    return 0;
&#125;```

#### 总结多态的方式＋dynamic_cast:
+ 　shape *ps=new circle();
    经由virtual func:  ps-&gt;rotate()    //virtual func
    经由dynamic_cast:和type运算符：
    if(circle *pc=dynamic_cast&lt;circle*&gt;(ps))
    
    (理解了指针类型的本质就可以理解它和理解分割的内容了:指针的类型会教导编译器如何解释某个特定地址的内容和大小:
    所以一个void*的指针无法去确定涵盖多大的地址空间，所以它只能含有一个地址但是不能操作它指向的Ｏｂｊｅｃｔ
    所以转型只是一种编译器指令，不改变真正的地址，而是改变解读指针的方式让它指出其内存的大小和内容）
    更多见内存布局第一章图就能理解）
</code></pre>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_neighbor</title>
    <url>/2021/05/22/linux-neighbor/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="linux下邻居子系统的实现："><a href="#linux下邻居子系统的实现：" class="headerlink" title="linux下邻居子系统的实现："></a>linux下邻居子系统的实现：</h4><h5 id="什么是邻居子系统："><a href="#什么是邻居子系统：" class="headerlink" title="什么是邻居子系统："></a>什么是邻居子系统：</h5><p>在linux下，是一个用来管理网络中，二层的数据正确发送的系统，维护着二层地址相关结构，以及和三层地址映射等结构，<br>并提供更新，查询等缓存和接口；形成一个系统；供在发送数据时查询并正确发送到指定的机器上；</p>
<span id="more"></span>
<h5 id="邻居子系统的系统参数分类和总结："><a href="#邻居子系统的系统参数分类和总结：" class="headerlink" title="邻居子系统的系统参数分类和总结："></a>邻居子系统的系统参数分类和总结：</h5><ul>
<li><p>参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">base_reachable_time_ms: 邻居项有效期初始值，这个值会被来自更高协议正反馈延长；</span><br><span class="line">delay_first_probe_time: 邻居项过期后发送第一个探测之前的延迟时间，默认<span class="number">5</span>s</span><br><span class="line">gc_stale_time: 确定多久检测一次邻居项过期，默认<span class="number">60</span>s</span><br><span class="line">gc_interval:垃圾回收处理邻居项的时间间隔，默认<span class="number">30</span>s</span><br><span class="line"></span><br><span class="line">echo <span class="number">30</span> &gt; /proc/sys/net/ipv4/neigh/<span class="keyword">default</span>/gc_stale_time</span><br><span class="line">echo <span class="number">175</span> &gt; /proc/sys/net/ipv4/route/gc_timeout</span><br><span class="line">echo <span class="number">20000</span> &gt; /proc/sys/net/ipv4/neigh/<span class="keyword">default</span>/base_reachable_time_ms</span><br><span class="line">echo <span class="number">30</span> &gt; /proc/sys/net/ipv4/route/gc_interval</span><br><span class="line"></span><br><span class="line">pherricoxide@midigaurd:~$ ip -s neighbor list</span><br><span class="line"><span class="number">192.168</span><span class="number">.42</span><span class="number">.1</span> dev eth0 lladdr <span class="number">00</span>:<span class="number">25</span>:<span class="number">90</span>:<span class="number">7</span>d:<span class="number">7</span>e:cd ref <span class="number">2</span> used <span class="number">184</span>/<span class="number">184</span>/<span class="number">139</span> probes <span class="number">4</span> STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.10</span><span class="number">.2</span> dev eth0 lladdr <span class="number">00</span>:<span class="number">1</span>c:<span class="number">23</span>:cf:<span class="number">0b</span>:<span class="number">6</span>a ref <span class="number">3</span> used <span class="number">33</span>/<span class="number">28</span>/<span class="number">0</span> probes <span class="number">1</span> REACHABLE</span><br><span class="line"><span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span> dev eth0 lladdr <span class="number">00</span>:<span class="number">17</span>:c5:d8:<span class="number">90</span>:a4 ref <span class="number">219</span> used <span class="number">275</span>/<span class="number">4</span>/<span class="number">121</span> probes <span class="number">1</span> REACHABLE</span><br></pre></td></tr></table></figure></li>
<li><p>参数定义和使用的位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">---- <span class="function">base_reachable_time_ms <span class="title">Matches</span> <span class="params">(<span class="number">8</span> in <span class="number">4</span> files)</span> ----</span></span><br><span class="line"><span class="function">ndisc_ifinfo_sysctl_change in ndisc.<span class="title">c</span> <span class="params">(net\ipv6)</span> : 		 (strcmp(ctl-&gt;procname, <span class="string">&quot;base_reachable_time_ms&quot;</span>) =</span>= <span class="number">0</span>))</span><br><span class="line">neigh_proc_base_reachable_time in neighbour.<span class="built_in">c</span> (net\core) : 	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ctl-&gt;procname, <span class="string">&quot;base_reachable_time_ms&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">neighbour.<span class="built_in">c</span> (net\core) line <span class="number">3076</span> : 		<span class="built_in">NEIGH_SYSCTL_MS_JIFFIES_REUSED_ENTRY</span>(BASE_REACHABLE_TIME_MS, BASE_REACHABLE_TIME, <span class="string">&quot;base_reachable_time_ms&quot;</span>),</span><br><span class="line">neigh_sysctl_register in neighbour.<span class="built_in">c</span> (net\core) : 		t-&gt;neigh_vars[NEIGH_VAR_BASE_REACHABLE_TIME_MS].proc_handler = handler;</span><br><span class="line">neigh_sysctl_register in neighbour.<span class="built_in">c</span> (net\core) : 		t-&gt;neigh_vars[NEIGH_VAR_BASE_REACHABLE_TIME_MS].proc_handler =</span><br><span class="line">neighbour.<span class="built_in">h</span> (include\net) line <span class="number">59</span> : 	NEIGH_VAR_BASE_REACHABLE_TIME_MS, <span class="comment">/* same data as NEIGH_VAR_BASE_REACHABLE_TIME */</span></span><br><span class="line">sysctl_binary.<span class="built_in">c</span> (kernel) line <span class="number">285</span> : 	&#123; CTL_INT,	NET_NEIGH_REACHABLE_TIME_MS,	<span class="string">&quot;base_reachable_time_ms&quot;</span> &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">neigh_table</span> *neigh_tables[NEIGH_NR_TABLES] __read_mostly;</span><br><span class="line"><span class="built_in">neigh_table_init</span>(<span class="type">int</span> index, <span class="keyword">struct</span> neigh_table *tbl)</span><br><span class="line">neigh_tables[index] = tbl;</span><br><span class="line"></span><br><span class="line">一个邻居协议，对应一个neigh_table表实例：多个邻居协议实例，放在上面的数组中，</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">neigh_table</span> &#123;</span><br><span class="line">	<span class="type">int</span>			family;<span class="comment">//邻居协议所属的地址簇，如ARP为ipv4 ,AF_INET</span></span><br><span class="line">	<span class="type">int</span>			entry_size;<span class="comment">//邻居表中有多个邻居项，这个是邻居项结构的大小，对arp_tbl来说，初始化为sizeof(neighbour+4);</span></span><br><span class="line">                                                        <span class="comment">//因为在ARP中neighbour结构的最后一个成员primary_key，实际指向一个ipv4地址，4为ipv4地址长度；</span></span><br><span class="line">	<span class="type">int</span>			key_len;<span class="comment">//哈希函数用的key长度，key一般是三层协议地址，所以一般是4</span></span><br><span class="line">	__be16			protocol;</span><br><span class="line">	__u32			(*hash)(<span class="type">const</span> <span class="type">void</span> *pkey,  <span class="comment">//哈希函数，用来计算哈希值，arp为arp_hash()</span></span><br><span class="line">					<span class="type">const</span> <span class="keyword">struct</span> net_device *dev,</span><br><span class="line">					__u32 *hash_rnd);</span><br><span class="line">	<span class="built_in">bool</span>			(*key_eq)(<span class="type">const</span> <span class="keyword">struct</span> neighbour *, <span class="type">const</span> <span class="type">void</span> *pkey);</span><br><span class="line">	<span class="built_in">int</span>			(*constructor)(<span class="keyword">struct</span> neighbour *);<span class="comment">//邻居项初始化函数，用于初始化一个新的neighbour结构中的相关字段，arp</span></span><br><span class="line">                                                                                <span class="comment">//为arp_constructor</span></span><br><span class="line">	<span class="built_in">int</span>			(*pconstructor)(<span class="keyword">struct</span> pneigh_entry *);</span><br><span class="line">	<span class="built_in">void</span>			(*pdestructor)(<span class="keyword">struct</span> pneigh_entry *); <span class="comment">//创建和释放一个代理项时被调用，ipv4没用，ipv6用了</span></span><br><span class="line">	<span class="built_in">void</span>			(*proxy_redo)(<span class="keyword">struct</span> sk_buff *skb);<span class="comment">//用来处理neigh_table-&gt;proxy_queue缓存队列中的代理arp报文</span></span><br><span class="line">	<span class="type">char</span>			*id;<span class="comment">// 用来分配neighbour实例的缓冲池名字符串，arp为arp_cache</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">neigh_parms</span>	parms;   <span class="comment">//存储一些和协议相关的可调节参数，如重传超时时间，proxy_queue队列长</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	parms_list;</span><br><span class="line">	<span class="type">int</span>			gc_interval;<span class="comment">//垃圾回收时钟gc_timer的到期间隔时间，即到期时触发一次垃圾回收，初始值是30s</span></span><br><span class="line">	<span class="type">int</span>			gc_thresh1;</span><br><span class="line">	<span class="type">int</span>			gc_thresh2;</span><br><span class="line">	<span class="type">int</span>			gc_thresh3; <span class="comment">//这三个阈值对应内存对邻居项作垃圾回收处理的不同级别，若缓存邻居项数少于gc_thresh1,则不执行删除，超过gc_thresh2则在新建邻居项时若超过5s为刷新，则立即刷新，并做强制回收处理，超过gc_thresh3则，新建邻居项时，立即刷新并强制垃圾回收</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		last_flush;<span class="comment">//记录最近一次调用neigh_forced_gc强制刷新邻居表的时间；用于判断是否回收</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">delayed_work</span>	gc_work;<span class="comment">//垃圾回收的相关结构，包括垃圾回收定时器</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timer_list</span> 	proxy_timer; <span class="comment">//处理proxy_queue队列的定时器，当proxy_queue为空，则第一个arp报文加入队列时，会启动这个定时器；在neigh_table_init中初始化，处理在neigh_proxy_process中处理；</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff_head</span>	proxy_queue;<span class="comment">//对于接收到需要进行代理的arp报文，需要先缓存到这个队列，在定时器处理函数中再处理它；</span></span><br><span class="line">	<span class="type">atomic_t</span>		entries; <span class="comment">//整个邻居表中邻居项的数目</span></span><br><span class="line">	<span class="type">rwlock_t</span>		lock; <span class="comment">//用于控制邻居表的读写锁 如look_up只需要读，而neigh_periodic_timer需要写</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		last_rand; <span class="comment">//用于记录neigh_params结构中的reachable_time成员最近一次被更新的时间</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">neigh_statistics</span>	__percpu *stats; <span class="comment">//各类统计数据</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">neigh_hash_table</span> __rcu *nht; <span class="comment">// 见下</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">pneigh_entry</span>	**phash_buckets;<span class="comment">//见下</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	NEIGH_ARP_TABLE = <span class="number">0</span>,</span><br><span class="line">	NEIGH_ND_TABLE = <span class="number">1</span>,</span><br><span class="line">	NEIGH_DN_TABLE = <span class="number">2</span>,</span><br><span class="line">	NEIGH_NR_TABLES,</span><br><span class="line">	NEIGH_LINK_TABLE = NEIGH_NR_TABLES <span class="comment">/* Pseudo table for neigh_xmit */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	neighbour table manipulation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEIGH_NUM_HASH_RND	4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">neigh_hash_table</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">neighbour</span> __rcu	**hash_buckets; <span class="comment">//用于存储邻居项的散列表，改散列表在分配邻居项时，若邻居项数量超过散列表容量，可以动态扩容</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		hash_shift;</span><br><span class="line">	__u32			hash_rnd[NEIGH_NUM_HASH_RND];<span class="comment">//随机数，用来在hash_buckets散列表扩容时计算关键字，以避免受到arp攻击</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rcu_head</span>		rcu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pneigh_entry</span> &#123; <span class="comment">//存储arp代理三层协议地址的散列表，在neigh_table_init_no_netlink中完成初始化</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">pneigh_entry</span>	*next;</span><br><span class="line">	<span class="type">possible_net_t</span>		net;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span>	*dev;</span><br><span class="line">	u8			flags;</span><br><span class="line">	u8			key[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">邻居表中一个邻居项的表示的结构体：</span><br><span class="line">邻居项存储了邻居相关信息，包括状态，二层，三层协议地址，提供给三层协议的函数指针，定时器和缓存的二层首部等；注意一个邻居不代表一个主机，而是一个三层协议地址，因为对于配置了多接口的主机，一个主机将对应多个三层地址;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">neighbour</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">neighbour</span> __rcu	*next; <span class="comment">//通过next串起来邻居表的所有邻居项</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">neigh_table</span>	*tbl;<span class="comment">//指向所属的邻居表的指针</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">neigh_parms</span>	*parms; <span class="comment">//用于调节邻居协议的参数，在创建邻居项的neigh_create中会调用alloc分配，其中会进行初始化，接着调constructor进行设置</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		confirmed;<span class="comment">//记录最近一次确认该邻居可达性的时间，用来描述邻居可达性；接收到回复时更新；传输层通过neigh_confirm来更新，而邻居子系统则通过neigh_update来更新</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		updated;<span class="comment">//记录最近一次被neigh_update更新的时间；和confirm不同；他们针对不同的特性</span></span><br><span class="line">	<span class="type">rwlock_t</span>		lock; <span class="comment">//用来控制访问邻居项的读写锁</span></span><br><span class="line">	<span class="type">atomic_t</span>		refcnt;<span class="comment">//引用计数</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff_head</span>	arp_queue;<span class="comment">//当邻居项状态处于无效时，用来缓存要发送的报文。若处于INCOMPLETE时，发送第一个要更新的；。。。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		arp_queue_len_bytes;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timer_list</span>	timer;<span class="comment">//管理多种超时情况的定时器</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		used;<span class="comment">//最近一次被使用时间，不同状态下被不同函数更新，如neigh_event_send()和gc_timer</span></span><br><span class="line">	<span class="type">atomic_t</span>		probes; <span class="comment">//尝试发送请求报文而未能得到应答的次数；在定时器中被检测，当达到阈值时 ，进入NUD_FAILED状态</span></span><br><span class="line">	__u8			flags; <span class="comment">//记录一些标志和特性</span></span><br><span class="line">	__u8			nud_state; <span class="comment">//邻居项状态</span></span><br><span class="line">	__u8			type; <span class="comment">//邻居地址的类型：对arp: RTN_UNICAST，RIN_LOCAL等</span></span><br><span class="line">	__u8			dead;<span class="comment">//生存标志，为1则表示正被删除</span></span><br><span class="line">	<span class="type">seqlock_t</span>		ha_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		ha[<span class="built_in">ALIGN</span>(MAX_ADDR_LEN, <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>))]; <span class="comment">//与存储在primary_key中的三层地址对应的二进制二层硬件地址；6B,其他链路可能更长，以太网是6B</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hh_cache</span>		hh;<span class="comment">//缓存的二层协议首部hh_cache</span></span><br><span class="line">	<span class="built_in">int</span>			(*output)(<span class="keyword">struct</span> neighbour *, <span class="keyword">struct</span> sk_buff *);<span class="comment">//输出函数，用来将报文输出到该邻居；在邻居项生命周期中，由于其状态不断变化，所以该函数指针会指向不同的输出函数，如可达时调用neigh_connect()将output置为 neigh_ops--&gt;connected_output</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">neigh_ops</span>	*ops;<span class="comment">//指向邻居项函数指针实例</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rcu_head</span>		rcu;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span>	*dev;  <span class="comment">//通过此网络设备可访问到该邻居；对每个邻居而言，只有一个</span></span><br><span class="line">	u8			primary_key[<span class="number">0</span>];<span class="comment">//存储哈希函数使用的三层协议地址；</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">neigh_ops</span> &#123;</span><br><span class="line">	<span class="type">int</span>			family;</span><br><span class="line">	<span class="built_in">void</span>			(*solicit)(<span class="keyword">struct</span> neighbour *, <span class="keyword">struct</span> sk_buff *);<span class="comment">//发送请求报文函数，在发送第一个报文时，需要新的邻居项，发送的报文会被缓存到arp_queue中，然后调用solicit()发送请求报文</span></span><br><span class="line">	<span class="built_in">void</span>			(*error_report)(<span class="keyword">struct</span> neighbour *, <span class="keyword">struct</span> sk_buff *);<span class="comment">//当邻居项缓存着未发送的数据报文时，而该邻居项又不可达，被调用来向三层报告错误的函数，如arp_error_report(),最后会向报文发送方发送一个主机不可达的icmp差错报文</span></span><br><span class="line">	<span class="built_in">int</span>			(*output)(<span class="keyword">struct</span> neighbour *, <span class="keyword">struct</span> sk_buff *);<span class="comment">//最通用的output函数，可用于所有情况；实现了完整的输出过程，此函数消耗资源。注意不要将neigh_ops-&gt;output和neighbour-&gt;output混淆</span></span><br><span class="line">	<span class="built_in">int</span>			(*connected_output)(<span class="keyword">struct</span> neighbour *, <span class="keyword">struct</span> sk_buff *);<span class="comment">//邻居可达时，即状态为NUD_CONNECTED时；只是简单的加二层头，所以比上面的output快</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">neigh_parms</span> &#123;<span class="comment">//邻居协议参数配置块，用来存储可调节的邻居协议参数，如重传超时时间，proxy_queueu长度等；</span></span><br><span class="line">	<span class="type">possible_net_t</span> net;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span> *dev;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> list;</span><br><span class="line">	<span class="built_in">int</span>	(*neigh_setup)(<span class="keyword">struct</span> neighbour *);<span class="comment">//提供给老式接口设备的初始化和销毁接口，注意区分net_device中的setup成员函数</span></span><br><span class="line">	<span class="built_in">void</span>	(*neigh_cleanup)(<span class="keyword">struct</span> neighbour *);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">neigh_table</span> *tbl;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>	*sysctl_table;<span class="comment">//邻居表的sysctl表 ，arp_init中初始化，这样用户可以通过proc来读写</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> dead;</span><br><span class="line">	<span class="type">atomic_t</span> refcnt;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rcu_head</span> rcu_head;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>	reachable_time;</span><br><span class="line">	<span class="type">int</span>	data[NEIGH_VAR_DATA_MAX];</span><br><span class="line">	<span class="built_in">DECLARE_BITMAP</span>(data_state, NEIGH_VAR_DATA_MAX);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pneigh_entry</span> &#123;<span class="comment">//用来保存允许代理的条件，只有和结构中的接收设备以及目标地址相匹配才能代理，保存在phash_buckets散列表中，称为代理项，可以通过ip neigh add proxy命令添加；</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">pneigh_entry</span>	*next;</span><br><span class="line">	<span class="type">possible_net_t</span>		net;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span>	*dev;<span class="comment">//通过该设备接收到的arp请求报文才能代理</span></span><br><span class="line">	u8			flags;</span><br><span class="line">	u8			key[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//统计数据：一个该结构实例对应一个网络设备上的一种邻居协议</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">neigh_statistics</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> allocs;		<span class="comment">/* number of allocated neighs */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> destroys;		<span class="comment">/* number of destroyed neighs */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> hash_grows;	<span class="comment">/* number of hash resizes */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> res_failed;	<span class="comment">/* number of failed resolutions */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> lookups;		<span class="comment">/* number of lookups */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> hits;		<span class="comment">/* number of hits (among lookups) */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rcv_probes_mcast;	<span class="comment">/* number of received mcast ipv6 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rcv_probes_ucast; <span class="comment">/* number of received ucast ipv6 */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> periodic_gc_runs;	<span class="comment">/* number of periodic GC runs */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> forced_gc_runs;	<span class="comment">/* number of forced GC runs */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> unres_discards;	<span class="comment">/* number of unresolved drops */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> table_fulls;      <span class="comment">/* times even gc couldn&#x27;t help */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hh_cache定义在netdevice.h中，是用来缓存二层首部的，这样可以复制而不是逐个设置，加快输出报文</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hh_cache</span> &#123;</span><br><span class="line">	u16		hh_len;</span><br><span class="line">	u16		__pad;</span><br><span class="line">	<span class="type">seqlock_t</span>	hh_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cached hardware header; allow for machine alignment needs.        */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HH_DATA_MOD	16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HH_DATA_OFF(__len) \</span></span><br><span class="line"><span class="meta">	(HH_DATA_MOD - (((__len - 1) &amp; (HH_DATA_MOD - 1)) + 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HH_DATA_ALIGN(__len) \</span></span><br><span class="line"><span class="meta">	(((__len)+(HH_DATA_MOD-1))&amp;~(HH_DATA_MOD - 1))</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	hh_data[<span class="built_in">HH_DATA_ALIGN</span>(LL_MAX_HEADER) / <span class="built_in">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>邻居表的初始化：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">neigh_table_init</span><span class="params">(<span class="type">int</span> index, <span class="keyword">struct</span> neigh_table *tbl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> now = jiffies;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> phsize;</span><br><span class="line">           <span class="comment">//就是将表中的字段复制到项中</span></span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;tbl-&gt;parms_list);</span><br><span class="line">	<span class="built_in">list_add</span>(&amp;tbl-&gt;parms.list, &amp;tbl-&gt;parms_list);</span><br><span class="line">	<span class="built_in">write_pnet</span>(&amp;tbl-&gt;parms.net, &amp;init_net);</span><br><span class="line">	<span class="built_in">atomic_set</span>(&amp;tbl-&gt;parms.refcnt, <span class="number">1</span>);</span><br><span class="line">	tbl-&gt;parms.reachable_time =</span><br><span class="line">			  <span class="built_in">neigh_rand_reach_time</span>(<span class="built_in">NEIGH_VAR</span>(&amp;tbl-&gt;parms, BASE_REACHABLE_TIME));</span><br><span class="line"></span><br><span class="line">	tbl-&gt;stats = <span class="built_in">alloc_percpu</span>(<span class="keyword">struct</span> neigh_statistics);</span><br><span class="line">	<span class="keyword">if</span> (!tbl-&gt;stats)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create neighbour cache statistics&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">proc_create_data</span>(tbl-&gt;id, <span class="number">0</span>, init_net.proc_net_stat,</span><br><span class="line">			      &amp;neigh_stat_seq_fops, tbl))</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create neighbour proc dir entry&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">RCU_INIT_POINTER</span>(tbl-&gt;nht, <span class="built_in">neigh_hash_alloc</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">	phsize = (PNEIGH_HASHMASK + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> pneigh_entry *);</span><br><span class="line">	tbl-&gt;phash_buckets = <span class="built_in">kzalloc</span>(phsize, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tbl-&gt;nht || !tbl-&gt;phash_buckets)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot allocate neighbour cache hashes&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tbl-&gt;entry_size)</span><br><span class="line">		tbl-&gt;entry_size = <span class="built_in">ALIGN</span>(<span class="built_in">offsetof</span>(<span class="keyword">struct</span> neighbour, primary_key) +</span><br><span class="line">					tbl-&gt;key_len, NEIGH_PRIV_ALIGN);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">WARN_ON</span>(tbl-&gt;entry_size % NEIGH_PRIV_ALIGN);</span><br><span class="line">           <span class="comment">//建立定时器，并初始化定时器，包括两个定时器，老化(垃圾回收)定时器和proxy代理定时器</span></span><br><span class="line">	<span class="built_in">rwlock_init</span>(&amp;tbl-&gt;lock);</span><br><span class="line">	<span class="built_in">INIT_DEFERRABLE_WORK</span>(&amp;tbl-&gt;gc_work, neigh_periodic_work);<span class="comment">//老化定时器对应的处理函数是neigh_periodic_work</span></span><br><span class="line">	<span class="built_in">queue_delayed_work</span>(system_power_efficient_wq, &amp;tbl-&gt;gc_work,</span><br><span class="line">			tbl-&gt;parms.reachable_time);</span><br><span class="line">	<span class="built_in">setup_timer</span>(&amp;tbl-&gt;proxy_timer, neigh_proxy_process, (<span class="type">unsigned</span> <span class="type">long</span>)tbl);<span class="comment">//proxy_timer对应的处理函数是neigh_proxy_process</span></span><br><span class="line">	<span class="built_in">skb_queue_head_init_class</span>(&amp;tbl-&gt;proxy_queue,</span><br><span class="line">			&amp;neigh_table_proxy_queue_class);</span><br><span class="line"></span><br><span class="line">	tbl-&gt;last_flush = now;</span><br><span class="line">	tbl-&gt;last_rand	= now + tbl-&gt;parms.reachable_time * <span class="number">20</span>;</span><br><span class="line">           <span class="comment">//放到全局数组中</span></span><br><span class="line">	neigh_tables[index] = tbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>邻居表的老化定时器和对应的状态机：<br>邻居表项有一个对于管理和维护邻居表来说很重要的成员： nud_state; 表示邻居项当前的状态；7种；<br>邻居表老化定时器定时扫描所有邻居表项，然后进行如下的状态迁移和处理<br>图+各个状态解释</p>
</li>
<li><p>邻居项的创建： 分配和创建初始化；<br>neigh_create: neigh_alloc</p>
</li>
<li><p>邻居表项扩容：<br>static struct neigh_hash_table *neigh_hash_grow(struct neigh_table *tbl,<br>                  unsigned long new_shift)</p>
</li>
<li><p>邻居表的各种操作：<br>邻居项的查找： neigh_look_up 查找频繁，添加和删除等都需要先查找<br>邻居项的更新： neigh_update: 更新内容：硬件地址和状态，并根据状态更新输出函数<br>垃圾回收：<br>同步回收： 在创建新的邻居项时，达到条件触发；<br>异步回收： 定时检测并看是否触发回收<br>外部事件的通知和处理：当网络设备NETDEV_UNREGISTER事件发生时，若邻居协议模块对此感兴趣，会调用此接口：neigh_ifdown;<br>如arp: arp_ifdown-&gt;neigh_ifdown; 另外还有neigh_changeaddr  </p>
</li>
<li><p>每个邻居项的定时函数：<br>邻居项的状态中，有些属于定时状态； 每个邻居项都有一个定时器，在创建邻居项时被初始化</p>
</li>
<li><p>关于代理项：phash_buckets<br>查找： pneigh_lookup  删除 pneigh_delete<br>延时处理代理的请求报文：pneigh_enqueue</p>
</li>
<li><p>关于输出函数：<br>丢弃： neigh_blackhole();<br>慢速发送：neigh_resolve_output<br>快速发送： dst_output后–&gt; neigh_hh_output &#x2F; neigh_connected_output</p>
</li>
<li><p>关于邻居代理，arp代理：<br>arp代理：<br>对一个二层协议，在一个局域网内，则使用二层地址寻找，当不在此局域网了，则通过路由器网关转发出去；<br>但是可能在一个局域网内有多个子网，通过路由器或交换机转发，但是主机不知道，所以这个时候依然用相同的方式去发送arp请求，当处于不同子网的两个主机arp时，<br>则此时需要依赖路由器打开arp代理转发功能，若开启，则会在收到arp请求时，返回自己的mac地址，这样相当于转发功能，会收到数据，转发给对方主机，然后从对方主机收到后又进行转发；</p>
</li>
</ul>
<p>注意到整个流程：<br>   arp会缓存数据包，然后等到arp邻居项可用了，再把数据包发出去；</p>
<ul>
<li><p>arp外部事件通知：<br> 当一个设备的ip地址发生变化，arp模块通过注册到通知链中arp_netdev_notifier收到通知，调用arp_netdev_event来处理NETDEV_CHANGEADDR事件；删除释放与禁用网络设备相关的邻居项；等</p>
</li>
<li><p>路由表项与邻居项的绑定：<br>  在路由模块中，每当添加一条输出路由或是单播转发路由时，会尝试将 该路由与该路由目的地址相对应的邻居项绑定；<br>arp_bind_neighbour 实现了路由表项与邻居绑定的功能；在绑定过程中，若对应的邻居项不存在，则新建一个邻居项后绑定；之后 再输出报文时就可以通过路由缓存找到<br>输出函数了；</p>
</li>
</ul>
<h4 id="内核中的arp实现："><a href="#内核中的arp实现：" class="headerlink" title="内核中的arp实现："></a>内核中的arp实现：</h4><ul>
<li>arp收包：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Receive an arp request from the device layer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">arp_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">struct</span> packet_type *pt, <span class="keyword">struct</span> net_device *orig_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">arphdr</span> *arp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do not tweak dropwatch on an ARP we will ignore */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;flags &amp; IFF_NOARP ||</span><br><span class="line">	    skb-&gt;pkt_type == PACKET_OTHERHOST ||</span><br><span class="line">	    skb-&gt;pkt_type == PACKET_LOOPBACK)</span><br><span class="line">		<span class="keyword">goto</span> consumeskb;</span><br><span class="line"></span><br><span class="line">	skb = <span class="built_in">skb_share_check</span>(skb, GFP_ATOMIC);<span class="comment">//检测并返回skb,当被检测的skb被引用多次时，则克隆此skb,并返回克隆得到的skb;</span></span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">goto</span> out_of_mem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ARP header, plus 2 device addresses, plus 2 IP addresses.  */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">pskb_may_pull</span>(skb, <span class="built_in">arp_hdr_len</span>(dev)))<span class="comment">// 在skb中加4个地址？</span></span><br><span class="line">		<span class="keyword">goto</span> freeskb;</span><br><span class="line">           /这个函数的解释： <span class="built_in">pskb_may_pull</span>(..)</span><br><span class="line">             <span class="comment">/* Moves tail of skb head forward, copying data from fragmented part,</span></span><br><span class="line"><span class="comment"> * when it is necessary.</span></span><br><span class="line"><span class="comment"> * 1. It may fail due to malloc failure.</span></span><br><span class="line"><span class="comment"> * 2. It may change skb pointers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is pretty complicated. Luckily, it is called only in exceptional cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">       /</span><br><span class="line"></span><br><span class="line">	arp = <span class="built_in">arp_hdr</span>(skb);  <span class="comment">//从skb中拿arp头，然后下面做检测</span></span><br><span class="line">	<span class="keyword">if</span> (arp-&gt;ar_hln != dev-&gt;addr_len || arp-&gt;ar_pln != <span class="number">4</span>)</span><br><span class="line">		<span class="keyword">goto</span> freeskb;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(<span class="built_in">NEIGH_CB</span>(skb), <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> neighbour_cb));<span class="comment">//把skb中的cb字段清空，见下的解释 control buffer</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">NF_HOOK</span>(NFPROTO_ARP, NF_ARP_IN,</span><br><span class="line">		       <span class="built_in">dev_net</span>(dev), <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">		       arp_process); <span class="comment">//通过netfilter 处理后再转到arp_process</span></span><br><span class="line"></span><br><span class="line">consumeskb:</span><br><span class="line">	<span class="built_in">consume_skb</span>(skb);</span><br><span class="line">	<span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line">freeskb:</span><br><span class="line">	<span class="built_in">kfree_skb</span>(skb);</span><br><span class="line">out_of_mem:</span><br><span class="line">	<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">The control buffer is an e­junkyard that can be used as a scratch pad during processing by a given</span><br><span class="line">layer of the protocol.   Its main use is by the IP layer to compile header options.</span><br><span class="line"> <span class="number">265</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 266 * This is the control buffer. It is free to use for every</span></span><br><span class="line"><span class="comment"> 267 * layer. Please put your private variables there. If you</span></span><br><span class="line"><span class="comment"> 268 * want to keep them across layers you have to skb_clone()</span></span><br><span class="line"><span class="comment"> 269 * first. This is owned by whoever has the skb queued ATM.</span></span><br><span class="line"><span class="comment"> 270 */</span></span><br><span class="line"> <span class="number">271</span> <span class="type">char</span> cb[<span class="number">48</span>];</span><br><span class="line"> <span class="number">272</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来进入到arp_process，主要做arp包的头的校验及：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Process an arp request.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">arp_process</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span> *dev = skb-&gt;dev;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">in_device</span> *in_dev = __in_dev_get_rcu(dev);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">arphdr</span> *arp;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *arp_ptr;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rtable</span> *rt;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *sha;</span><br><span class="line">	__be32 sip, tip;</span><br><span class="line">	u16 dev_type = dev-&gt;type;</span><br><span class="line">	<span class="type">int</span> addr_type;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">neighbour</span> *n;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dst_entry</span> *reply_dst = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> is_garp = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* arp_rcv below verifies the ARP header and verifies the device</span></span><br><span class="line"><span class="comment">	 * is ARP&#x27;able.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!in_dev)</span><br><span class="line">		<span class="keyword">goto</span> out_free_skb;</span><br><span class="line">           <span class="comment">//拿到arp的头</span></span><br><span class="line">	arp = <span class="built_in">arp_hdr</span>(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (dev_type) &#123;</span><br><span class="line">	<span class="keyword">default</span>:    <span class="comment">//三层一样的，所以先做检测三层协议格式是不是ip,以及二层的和dev的是不是一样</span></span><br><span class="line">		<span class="keyword">if</span> (arp-&gt;ar_pro != <span class="built_in">htons</span>(ETH_P_IP) ||</span><br><span class="line">		    <span class="built_in">htons</span>(dev_type) != arp-&gt;ar_hrd)</span><br><span class="line">			<span class="keyword">goto</span> out_free_skb;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//检查二层的格式</span></span><br><span class="line">	<span class="keyword">case</span> ARPHRD_ETHER:</span><br><span class="line">	<span class="keyword">case</span> ARPHRD_FDDI:</span><br><span class="line">	<span class="keyword">case</span> ARPHRD_IEEE802:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * ETHERNET, and Fibre Channel (which are IEEE 802</span></span><br><span class="line"><span class="comment">		 * devices, according to RFC 2625) devices will accept ARP</span></span><br><span class="line"><span class="comment">		 * hardware types of either 1 (Ethernet) or 6 (IEEE 802.2).</span></span><br><span class="line"><span class="comment">		 * This is the case also of FDDI, where the RFC 1390 says that</span></span><br><span class="line"><span class="comment">		 * FDDI devices should accept ARP hardware of (1) Ethernet,</span></span><br><span class="line"><span class="comment">		 * however, to be more robust, we&#x27;ll accept both 1 (Ethernet)</span></span><br><span class="line"><span class="comment">		 * or 6 (IEEE 802.2)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((arp-&gt;ar_hrd != <span class="built_in">htons</span>(ARPHRD_ETHER) &amp;&amp;</span><br><span class="line">		     arp-&gt;ar_hrd != <span class="built_in">htons</span>(ARPHRD_IEEE802)) ||</span><br><span class="line">		    arp-&gt;ar_pro != <span class="built_in">htons</span>(ETH_P_IP))</span><br><span class="line">			<span class="keyword">goto</span> out_free_skb;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ARPHRD_AX25:</span><br><span class="line">		<span class="keyword">if</span> (arp-&gt;ar_pro != <span class="built_in">htons</span>(AX25_P_IP) ||</span><br><span class="line">		    arp-&gt;ar_hrd != <span class="built_in">htons</span>(ARPHRD_AX25))</span><br><span class="line">			<span class="keyword">goto</span> out_free_skb;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ARPHRD_NETROM:</span><br><span class="line">		<span class="keyword">if</span> (arp-&gt;ar_pro != <span class="built_in">htons</span>(AX25_P_IP) ||</span><br><span class="line">		    arp-&gt;ar_hrd != <span class="built_in">htons</span>(ARPHRD_NETROM))</span><br><span class="line">			<span class="keyword">goto</span> out_free_skb;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Understand only these message types */</span></span><br><span class="line">            <span class="comment">//这里只会处理arp请求和回复</span></span><br><span class="line">	<span class="keyword">if</span> (arp-&gt;ar_op != <span class="built_in">htons</span>(ARPOP_REPLY) &amp;&amp;</span><br><span class="line">	    arp-&gt;ar_op != <span class="built_in">htons</span>(ARPOP_REQUEST))</span><br><span class="line">		<span class="keyword">goto</span> out_free_skb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Extract fields</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	arp_ptr = (<span class="type">unsigned</span> <span class="type">char</span> *)(arp + <span class="number">1</span>);</span><br><span class="line">	sha	= arp_ptr;</span><br><span class="line">	arp_ptr += dev-&gt;addr_len;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;sip, arp_ptr, <span class="number">4</span>);</span><br><span class="line">	arp_ptr += <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">switch</span> (dev_type) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_FIREWIRE_NET)</span></span><br><span class="line">	<span class="keyword">case</span> ARPHRD_IEEE1394:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		arp_ptr += dev-&gt;addr_len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;tip, arp_ptr, <span class="number">4</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Check for bad requests for 127.x.x.x and requests for multicast</span></span><br><span class="line"><span class="comment"> *	addresses.  If this is one such, delete it.</span></span><br><span class="line"><span class="comment"> */</span>         <span class="comment">//对本地环回的不需要处理？</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ipv4_is_multicast</span>(tip) ||</span><br><span class="line">	    (!<span class="built_in">IN_DEV_ROUTE_LOCALNET</span>(in_dev) &amp;&amp; <span class="built_in">ipv4_is_loopback</span>(tip)))</span><br><span class="line">		<span class="keyword">goto</span> out_free_skb;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *	For some 802.11 wireless deployments (and possibly other networks),</span></span><br><span class="line"><span class="comment">  *	there will be an ARP proxy and gratuitous ARP frames are attacks</span></span><br><span class="line"><span class="comment">  *	and thus should not be accepted.</span></span><br><span class="line"><span class="comment">  */</span>        <span class="comment">//对80211无线网络，可能是arp攻击，所以也不接受</span></span><br><span class="line">	<span class="keyword">if</span> (sip == tip &amp;&amp; <span class="built_in">IN_DEV_ORCONF</span>(in_dev, DROP_GRATUITOUS_ARP))</span><br><span class="line">		<span class="keyword">goto</span> out_free_skb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     Special case: We must set Frame Relay source Q.922 address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">if</span> (dev_type == ARPHRD_DLCI)</span><br><span class="line">		sha = dev-&gt;broadcast;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Process entry.  The idea here is we want to send a reply if it is a</span></span><br><span class="line"><span class="comment"> *  request for us or if it is a request for someone else that we hold</span></span><br><span class="line"><span class="comment"> *  a proxy for.  We want to add an entry to our cache if it is a reply</span></span><br><span class="line"><span class="comment"> *  to us or if it is a request for our address.</span></span><br><span class="line"><span class="comment"> *  (The assumption for this last is that if someone is requesting our</span></span><br><span class="line"><span class="comment"> *  address, they are probably intending to talk to us, so it saves time</span></span><br><span class="line"><span class="comment"> *  if we cache their address.  Their address is also probably not in</span></span><br><span class="line"><span class="comment"> *  our cache, since ours is not in their cache.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Putting this another way, we only care about replies if they are to</span></span><br><span class="line"><span class="comment"> *  us, in which case we add them to the cache.  For requests, we care</span></span><br><span class="line"><span class="comment"> *  about those for us and those for our proxies.  We reply to both,</span></span><br><span class="line"><span class="comment"> *  and in the case of requests for us we add the requester to the arp</span></span><br><span class="line"><span class="comment"> *  cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">           <span class="comment">//对arp请求的处理</span></span><br><span class="line">	<span class="keyword">if</span> (arp-&gt;ar_op == <span class="built_in">htons</span>(ARPOP_REQUEST) &amp;&amp; <span class="built_in">skb_metadata_dst</span>(skb))</span><br><span class="line">		reply_dst = (<span class="keyword">struct</span> dst_entry *)</span><br><span class="line">			    <span class="built_in">iptunnel_metadata_reply</span>(<span class="built_in">skb_metadata_dst</span>(skb),</span><br><span class="line">						    GFP_ATOMIC);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Special case: IPv4 duplicate address detection packet (RFC2131) */</span></span><br><span class="line">	<span class="keyword">if</span> (sip == <span class="number">0</span>) &#123;<span class="comment">//请求报文的源ip为0，则该arp报文是用来检测ipv4地址冲突的 rfc2131,因此在确定请求报文的目标ip地址为本地ip后，以该ip地址为源地址及目标地址发送arp应答报文</span></span><br><span class="line">		<span class="keyword">if</span> (arp-&gt;ar_op == <span class="built_in">htons</span>(ARPOP_REQUEST) &amp;&amp;</span><br><span class="line">		    <span class="built_in">inet_addr_type_dev_table</span>(net, dev, tip) == RTN_LOCAL &amp;&amp;</span><br><span class="line">		    !<span class="built_in">arp_ignore</span>(in_dev, sip, tip))</span><br><span class="line">			<span class="built_in">arp_send_dst</span>(ARPOP_REPLY, ETH_P_ARP, sip, dev, tip,</span><br><span class="line">				     sha, dev-&gt;dev_addr, sha, reply_dst);</span><br><span class="line">		<span class="keyword">goto</span> out_consume_skb;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arp-&gt;ar_op == <span class="built_in">htons</span>(ARPOP_REQUEST) &amp;&amp; <span class="comment">//若为arp请求报文且能找到目的ip地址tip对应的路由</span></span><br><span class="line">	    <span class="built_in">ip_route_input_noref</span>(skb, tip, sip, <span class="number">0</span>, dev) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		rt = <span class="built_in">skb_rtable</span>(skb);</span><br><span class="line">		addr_type = rt-&gt;rt_type;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (addr_type == RTN_LOCAL) &#123;<span class="comment">//若是本地接收的</span></span><br><span class="line">			<span class="type">int</span> dont_send;</span><br><span class="line"></span><br><span class="line">			dont_send = <span class="built_in">arp_ignore</span>(in_dev, sip, tip);</span><br><span class="line">			<span class="keyword">if</span> (!dont_send &amp;&amp; <span class="built_in">IN_DEV_ARPFILTER</span>(in_dev))</span><br><span class="line">				dont_send = <span class="built_in">arp_filter</span>(sip, tip, dev);<span class="comment">//过滤</span></span><br><span class="line">			<span class="keyword">if</span> (!dont_send) &#123;</span><br><span class="line">				n = <span class="built_in">neigh_event_ns</span>(&amp;arp_tbl, sha, &amp;sip, dev);<span class="comment">//调用来更新邻居项</span></span><br><span class="line">				<span class="keyword">if</span> (n) &#123;</span><br><span class="line">					<span class="built_in">arp_send_dst</span>(ARPOP_REPLY, ETH_P_ARP,<span class="comment">//发送arp应答报文</span></span><br><span class="line">						     sip, dev, tip, sha,</span><br><span class="line">						     dev-&gt;dev_addr, sha,</span><br><span class="line">						     reply_dst);</span><br><span class="line">					<span class="built_in">neigh_release</span>(n);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">goto</span> out_consume_skb;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IN_DEV_FORWARD</span>(in_dev)) &#123;<span class="comment">//若不是发送给本地的，看看是否要做代理缓存</span></span><br><span class="line">			<span class="keyword">if</span> (addr_type == RTN_UNICAST  &amp;&amp;</span><br><span class="line">			    (<span class="built_in">arp_fwd_proxy</span>(in_dev, dev, rt) ||</span><br><span class="line">			     <span class="built_in">arp_fwd_pvlan</span>(in_dev, dev, rt, sip, tip) ||</span><br><span class="line">			     (rt-&gt;dst.dev != dev &amp;&amp;</span><br><span class="line">			      <span class="built_in">pneigh_lookup</span>(&amp;arp_tbl, net, &amp;tip, dev, <span class="number">0</span>)))) &#123;</span><br><span class="line">				n = <span class="built_in">neigh_event_ns</span>(&amp;arp_tbl, sha, &amp;sip, dev);</span><br><span class="line">				<span class="keyword">if</span> (n)</span><br><span class="line">					<span class="built_in">neigh_release</span>(n);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">NEIGH_CB</span>(skb)-&gt;flags &amp; LOCALLY_ENQUEUED ||</span><br><span class="line">				    skb-&gt;pkt_type == PACKET_HOST ||</span><br><span class="line">				    <span class="built_in">NEIGH_VAR</span>(in_dev-&gt;arp_parms, PROXY_DELAY) == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">arp_send_dst</span>(ARPOP_REPLY, ETH_P_ARP,</span><br><span class="line">						     sip, dev, tip, sha,</span><br><span class="line">						     dev-&gt;dev_addr, sha,</span><br><span class="line">						     reply_dst);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="built_in">pneigh_enqueue</span>(&amp;arp_tbl,</span><br><span class="line">						       in_dev-&gt;arp_parms, skb);</span><br><span class="line">					<span class="keyword">goto</span> out_free_dst;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">goto</span> out_consume_skb;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update our ARP tables */</span></span><br><span class="line">            <span class="comment">//下面做更新arp表的操作</span></span><br><span class="line">	n = __neigh_lookup(&amp;arp_tbl, &amp;sip, dev, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IN_DEV_ARP_ACCEPT</span>(in_dev)) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> addr_type = <span class="built_in">inet_addr_type_dev_table</span>(net, dev, sip);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Unsolicited ARP is not accepted by default.</span></span><br><span class="line"><span class="comment">		   It is possible, that this option should be enabled for some</span></span><br><span class="line"><span class="comment">		   devices (strip is candidate)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		is_garp = arp-&gt;ar_op == <span class="built_in">htons</span>(ARPOP_REQUEST) &amp;&amp; tip == sip &amp;&amp;</span><br><span class="line">			  addr_type == RTN_UNICAST;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!n &amp;&amp;</span><br><span class="line">		    ((arp-&gt;ar_op == <span class="built_in">htons</span>(ARPOP_REPLY)  &amp;&amp;</span><br><span class="line">				addr_type == RTN_UNICAST) || is_garp))</span><br><span class="line">			n = __neigh_lookup(&amp;arp_tbl, &amp;sip, dev, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n) &#123;</span><br><span class="line">		<span class="type">int</span> state = NUD_REACHABLE;</span><br><span class="line">		<span class="type">int</span> <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If several different ARP replies follows back-to-back,</span></span><br><span class="line"><span class="comment">		   use the FIRST one. It is possible, if several proxy</span></span><br><span class="line"><span class="comment">		   agents are active. Taking the first reply prevents</span></span><br><span class="line"><span class="comment">		   arp trashing and chooses the fastest router.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">override</span> = <span class="built_in">time_after</span>(jiffies,</span><br><span class="line">				      n-&gt;updated +</span><br><span class="line">				      <span class="built_in">NEIGH_VAR</span>(n-&gt;parms, LOCKTIME)) ||</span><br><span class="line">			   is_garp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Broadcast replies and request packets</span></span><br><span class="line"><span class="comment">		   do not assert neighbour reachability.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (arp-&gt;ar_op != <span class="built_in">htons</span>(ARPOP_REPLY) ||</span><br><span class="line">		    skb-&gt;pkt_type != PACKET_HOST)</span><br><span class="line">			state = NUD_STALE;</span><br><span class="line">		<span class="built_in">neigh_update</span>(n, sha, state,</span><br><span class="line">			     <span class="keyword">override</span> ? NEIGH_UPDATE_F_OVERRIDE : <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">neigh_release</span>(n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_consume_skb:</span><br><span class="line">	<span class="built_in">consume_skb</span>(skb);</span><br><span class="line"></span><br><span class="line">out_free_dst:</span><br><span class="line">	<span class="built_in">dst_release</span>(reply_dst);</span><br><span class="line">	<span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line"></span><br><span class="line">out_free_skb:</span><br><span class="line">	<span class="built_in">kfree_skb</span>(skb);</span><br><span class="line">	<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>arp发送时和发送接口：</li>
</ul>
<ol>
<li>一些发送接口；注意是发送arp请求的，不是数据包<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">arp_send</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> ptype, __be32 dest_ip,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="keyword">struct</span> net_device *dev, __be32 src_ip,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dest_hw, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *src_hw,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *target_hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">arp_send_dst</span>(type, ptype, dest_ip, dev, src_ip, dest_hw, src_hw,  --有三个接口会调用它：arp_send/arp_solicit/arp_process</span><br><span class="line">		     target_hw, <span class="literal">NULL</span>); ---会调用arp_create创建+arp_xmit发送</span><br><span class="line">&#125;</span><br><span class="line">创建arp报文：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Create an arp packet. If dest_hw is not set, we create a broadcast</span></span><br><span class="line"><span class="comment"> *	message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff</span> *<span class="built_in">arp_create</span>(<span class="type">int</span> type, <span class="type">int</span> ptype, __be32 dest_ip,</span><br></pre></td></tr></table></figure>
2）三层发送数据包时：<br>三层发送需要时会把数据包缓存起来，arp邻居项状态达到connected时发送；</li>
</ol>
<ul>
<li><p>arp老化定时器：结合图</p>
</li>
<li><p>邻居表老化定时器<br>neigh_periodic_work</p>
</li>
<li><p>邻居项定时器：<br>neigh_timer_handler</p>
</li>
<li><p>代理项定时器<br>neigh_proxy_process</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>neighbor</tag>
      </tags>
  </entry>
  <entry>
    <title>my_funds_and_stocks</title>
    <url>/2021/02/10/my-funds-and-stocks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="简介和写这篇文章的目的："><a href="#简介和写这篇文章的目的：" class="headerlink" title="简介和写这篇文章的目的："></a>简介和写这篇文章的目的：</h3><p>  其实在上大学，大三大四的时候就有财商的思考了，而触发这个思考一开始是大学期间看的穷爸爸和富爸爸那本书，和那个老鼠赛跑的游戏，再之后，财商这个词，<span id="more"></span>主要源于一个做生意的初中同学在某句话中出现了这个词，其实不用解释很多，仅仅是一个新概念，就足以引人深思；但是那会其实没有钱，也没啥概念，也单单只是停留在如何通过一些渠道更快更便捷的赚更多的钱；所以那个时候做一些兼职，也停留在简单的生意层面；  </p>
<p>  直到开始工作，因为繁忙，多加班，让我没有更多的精力去做斜杠青年，而老家的房子问题，让我第一份工作，即头两年左右的时间，都将工资，年终奖等，去掉生活费攒下的钱，都交给家里了；<br>没有时间消费，加上其他福利，少社交等，让我的生活基本只有工作；于是第一份工作，在完成家里的房子后，我也没剩下什么钱了；于是。累的我，跳槽了；  </p>
<p>  之后，才是我自己的生活，而这个时候已经毕业两年了；第二份工作时2019年11月底开始的，拿到工资的时候，钱也终于能自由支配；于是顺理成章的，我会去思考，如何理财，而无非，就是如何进行资产配置，如何记账，如何管理财富等等；<br>  于是我开始查理财的知识，直到加入一个线上低价的小白课入门，渐渐开始了解这个基金，股票的世界，而最让我感觉到希望的是，可以借此财富自由；毕竟，在这之前，我以为财富自由要赚很多很多钱，或者是要有类似书籍版权等类似的睡后收入；  </p>
<p>  于是我开始学习基金，股票知识，慢慢的，接触到螺丝钉和他的书，接着在2020年02月开始通过蛋卷基金买基金等；到现在2021年02月，整整一年，我的收益年化在15%左右；我了解的知识不多，只是跟着大螺买，了解基金的基本原理；<br>而后来我要自选一些基金，加上想在下一年进军美股港股等，所以，要接着继续学习；  </p>
<p>  于是这篇文章，想记录下我这2020年的资产配置和投资的总结；  </p>
<h3 id="关于资产的概念和资产配置："><a href="#关于资产的概念和资产配置：" class="headerlink" title="关于资产的概念和资产配置："></a>关于资产的概念和资产配置：</h3><ul>
<li>家庭日常消费规划一般：消费计划，投资计划，保险计划，教育金计划，养老金计划等；都是理财，凡是和钱有关的安排都是理财；</li>
<li>生钱资产，耗钱资产和其他资产，这三个重要概念：<ul>
<li>1)资产：房子，车子，手机，钱，桌子，椅子，基金，股票等等；</li>
<li>2)流动资产和非流动资产：流动资产：方便变现的如股票，基金等；非流动资产：不方便变现的如：房子，车子等；</li>
<li>3)资产的内涵：现金流</li>
<li>4)生钱资产：能给你持续带来净现金流入的东西，可以躺着赚钱，睡后收入；如基金，余额宝，债券等，变富有</li>
<li>5)耗钱资产：能给你持续带来净现金流出的东西，可以躺着付钱，睡后支出；如贷款的房子，车子；变穷</li>
<li>6)其他资产：净现金流为0 的资产，如黄金等；</li>
<li>7)注意耗钱资产在某个情况条件下也能变为生钱资产，若其生钱大于耗钱；且不用支出劳动力；</li>
</ul>
</li>
<li>财富自由<ul>
<li>收入低：分清楚必要开支和不必要开支；好支出和坏支出；<br>开源，提高工资收入；建议30岁前，多花时间在工作技能上；工资的增长比投资快多了；</li>
<li>工资收入和非工资收入要同步进行；</li>
<li>中产阶级的现金流和富人现金流的不同：中产：房贷等等；</li>
<li>财务自由的概念：你的非工资收入大于日常开支</li>
<li>财富自由度：年非工资收入(年投资收入)&#x2F;年生活支出&#x3D;&#x3D;1是最基本的自由度，数字越大，自由度越高；</li>
<li>富人的两个秘密：<ul>
<li>1）生钱资产占总资产的80%</li>
<li>2）好支出占总支出的80%；比如学习的，健康的；</li>
</ul>
</li>
</ul>
</li>
<li>从一万到100万的理财法则<ul>
<li>复利的强大力量：印度宰相米粒摆棋盘的故事；</li>
<li>复利的一些计算例子：</li>
<li>复利公式：最终收益&#x3D;本金*（1+收益率）^时间—其实就是以前学政治的里面的公式；</li>
<li>复利曲线和单利曲线，单利就是比如本金10万，利率10%，那么第一年1万，第10年10万(除开本金),…而复利是把利息也投进去了；<br>从公式看y&#x3D;x*z^t ,可见哪个因素影响大；从曲线来看，时间和z影响很大；所以越早投资越好；</li>
<li>复利计算器：<a href="http://www.yaocaiwuziyou.com/calculator.html">www.yaocaiwuziyou.com/calculator.html</a>;</li>
</ul>
</li>
<li>财富配置举例：</li>
<li>3：家庭年收入的30%用来作为应急金（包括日常消费），以备不时之需，可以通过无风险工具管理处置，灵活存取</li>
<li>1: 家庭年收入的10%用来配置家庭保险，作为家庭资产的后盾</li>
<li>4：家庭年收入的40%用来养鹅，钱生钱</li>
<li>2：家庭年收入的20%用来投资自己，学习相关技巧，增加自己的工资和非工资收入<br>关于通货膨胀；~</li>
</ul>
<h3 id="本文主要写投资计划"><a href="#本文主要写投资计划" class="headerlink" title="本文主要写投资计划"></a>本文主要写投资计划</h3><h3 id="基金的相关知识"><a href="#基金的相关知识" class="headerlink" title="基金的相关知识"></a>基金的相关知识</h3><h4 id="股票，股权，股东，股份，原始股等概念："><a href="#股票，股权，股东，股份，原始股等概念：" class="headerlink" title="股票，股权，股东，股份，原始股等概念："></a>股票，股权，股东，股份，原始股等概念：</h4><ul>
<li><p>什么是股票?<br>股票（stock）是指股份公司发行的所有权凭证，是股份证书的简称，每家上市公司都会发行股票，是股份公司为筹集资金而发行给股东作为持股凭证并借以取得股息和红利的一种有价证券。<br>每股股票都代表股东对企业拥有一个基本单位的所有权。这种所有权是一种综合权利，如参加股东大会、投票表决、参与公司的重大决策、收取股息或分享红利等。同一类别的每一份股票所代表的公司所有权是相等的。每个股东所拥有的公司所有权份额的大小，取决于其持有的股票数量占公司总股本的比重。股票是股份公司资本的构成部分，可以转让、买卖或作价抵押，是资本市场的主要长期信用工具，但不能要求公司返还其出资。股东与公司之间的关系不是债权债务关系。股东是公司的所有者，以其出资份额为限对公司负有限责任，承担风险，分享收益。  –来自MBA智库  </p>
</li>
<li><p>为什么会有股票：<br>举个例子：<br>假设小明开了一家餐饮公司，名字就叫A公司吧。为了筹集更多资金扩大公司规模，小明准备把A公司上市，股价定为10元。<br>为了让大家购买股票，成为股东，小明承诺每年拿出A公司的部分利润分给股东。—这是投资股票的本质，也是价值投资最看重的，价值来自于公司盈利。<br>(除此之外，还可能承诺给与一定的权利，比如管理权，决策权等)<br>小红花了1000元，买了100股A公司股票，股价10元。<br>去年A公司利润算出来了，准备每股分红1元。分红前股价10元，分红后，小红得到现金1元，股价可能因此变成9元。小红总资产没有变化。—这个后面讨论为什么会可能变为9元  </p>
</li>
<li><p>股权，股份和股东：</p>
<ul>
<li>股权可以理解为对股票的一种权利，这种权利可以有多种，比如表决权，分红权等等，根据所拥有的股票种类和股票份数，权利也有对应的不同，份数越多，股权越大，越有话语权和管理权；  </li>
<li>股东可以理解为拥有股权的个人或机构；大股东是指拥有份数占比较大股票的个人或机构，这种对应的股权也会比较大；  </li>
<li>股份即拥有股票总数的占比等；</li>
</ul>
</li>
<li><p>股票的分类：<br>股票有很多种类：  </p>
<ul>
<li><ol>
<li>按股东权利分类，股票可分为普通股、优先股和后配股。</li>
</ol>
<ul>
<li>普通股：在公司的经营管理和盈利及财产分配上有普通权利的股份，代表满足所有债权偿付要求及优先股东的收益权与求偿权要求后对企业盈利和剩余财产的索取权，它构成公司资本的基础，是股票的一种基本形式，也是发行量最大，最为重要的股票。目前在上海和深圳证券交易所上中交易的股票，都是普通股。</li>
<li>优先股：相对于普通股而言的。主要指在利润分红及剩余财产分配的权利方面，优先于普通股。</li>
<li>后配股：是与优先股相反的一种股票。它是指利润分配和剩余财产分配后于普通股的股票。正因为它在财产和股息上的权利顺序比普通股要落后，故称之为后配股。</li>
</ul>
</li>
<li><ol start="2">
<li>根据上市地区可以分为，我国上市公司的股票有A股、B股、H股、N股和S股等的区分。这一区分主要依据股票的上市地点和所面对的投资者而定。</li>
</ol>
</li>
<li><ol start="3">
<li>根据业绩也分为：ST股、垃圾股、绩优股、蓝筹股 。</li>
</ol>
</li>
<li><ol start="4">
<li>其他分类：</li>
</ol>
<ul>
<li>记名股票和无记名股票：是否记载股东姓名来划分股票</li>
<li>有票面值股票和无票面值股票：这主要是根据股票是否记明每股金额来划分的。有票面值股票，是在股票上记载每股的金额。无票面值股票，只是记明股票和公司资本总额，或每股占公司资本总额的比例。</li>
<li>单一股票和复数股票：这主要是根据股票上表示的份数来划分的。单一股票是指每张股票表示一股。复数股票是指每张股票表示数股。</li>
<li>普通股票和特别股票：普通股票的股息随公司利润大小而增减。特别股票一般按规定利率优先取得固定股息，但其股东的表决权有所限制。</li>
<li>表决权股票和无表决权股票：普通股票持有者都有表决权，而那些在某些方面享有特别利益的优先股票持有者在表决权上常受到限制。无表决权的股东，不能参与公司决策。</li>
<li>原始股： 公司申请上市之前发行的股票；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="股权和债权的区别："><a href="#股权和债权的区别：" class="headerlink" title="股权和债权的区别："></a>股权和债权的区别：</h4><ul>
<li>债权：对方借了你的钱，需要还你本金和利息，比如银行的定期存款，利息约定多少，到期还你多少，而活期，贷款等都是这种；  </li>
<li>股权：你花钱买了上市公司股票，成为公司股东，公司定期给你分红。不存在本金和利息。你只要还持有，就继续享受分红；公司不会还你本金和利息；而你要回本或者赚取利益，只能卖出股票或者继续持有通过分红等享受收益；</li>
</ul>
<h4 id="分红，填权，除权和股票下跌上涨的关系"><a href="#分红，填权，除权和股票下跌上涨的关系" class="headerlink" title="分红，填权，除权和股票下跌上涨的关系"></a>分红，填权，除权和股票下跌上涨的关系</h4><ul>
<li><p>分红：  </p>
<ul>
<li><p>前提：其实股票是一种权利的凭证，股票本身的价值是一种非实体价值，在公司盈利的情况下，且扩张需求不大，无资金需求时，上不上市其实无关紧要，比如华为，OPPO就没上市，而是类似全员持股，或者管理者持股等等；<br>在这种情况下，一家企业的经营，盈利后抛去人力等成本，剩下的钱由老板和管理者，创始人拥有，并决定分配等；和股票和上市没有半毛钱关系；<br>当企业经营不善，或者寻求更进一步的扩张，需要资金支持或者仅仅是资本扩张等，会选择进行融资，上市，而上市前一般是融资，比如天使轮融资，A轮，B轮等直到上市；融资是寻求外部资金，那投资者为什么会给你投资呢？<br>你通过介绍产品等，承诺未来有希望做大，且给与一定的股权和分红等等，于是股票诞生，持有股票越多，股权越大，权利越大等等，至于后面的拆股以及一些手段，有兴趣的再查；  </p>
</li>
<li><p>所以分红，就是：给投资者利益，红利，钱等；有两种形式：向股东派发现金股利和股票股利，上市公司可根据情况选择其中一种形式进行分红，也可以两种形式同时用。  </p>
<ul>
<li>现金股利是指以现金形式向股东发放股利，称为派股息或派息；  </li>
<li>股票股利是指上市公司向股东分发股票，红利以股票的形式出现，又称为送红股或送股；</li>
</ul>
</li>
</ul>
</li>
<li><p>分红派息，分红的意义？<br>分红即派息，是对投资者回报的一种方式，比如小红买了A公司股票后，股价每股10元，每年派息1元，则10年可以回本，之后还能继续派息；<br>但是投资回报还可以是利用股票的涨跌套利，这种可能是当前比较火的方式；时间也比较短；</p>
</li>
<li><p>那股票一定会分红吗？股票分红对套利的人来讲有意义吗？<br>股票是否分红是上市公司自己决定的，一般要赚钱了才会分红，且分红需要扣税，加上除权的影响，可能分红后持有的股票总资产可能反而有所下降；</p>
</li>
<li><p>PS:<br>对于投资者来说，很多人觉得分红没用其实是站在一个短期投资的角度来看的，如果是长期投资，每年的分红累计起来，过几年就可以收回成本。<br>分红的时候股价降低了，但是持股份额没有变，只要公司能够持续盈利，产生持续分红，那么基本上就是稳赚的。要知道公司只有赚了钱才能分红，能够持续分红的上市公司，一定是优质的投资公司。所以有的公司为了吸引投资者，还会进行强制分红，就是为了吸收更多的资金。<br>不过市场上真正的长期投资者并不是，大多都是短期投资者，所以分红的存在感就很弱，很多人都觉得股票分红没什么用。<br>对于上市公司来说，股票分红后，股价低了，就可以吸引更多的散户买入，同时也更容易获得投资者的信任，获得稳定的资金来源，稳定股价。这是一个良性循环。</p>
</li>
<li><p>除权，除息：<br>继续上面的例子：<br>去年A公司利润算出来了，准备每股分红1元。分红前股价10元，分红后，小红得到现金1元，股价可能因此变成9元。小红总资产没有变化。<br>因为股票在市场上一直在投资者之间进行转让买卖，当上市公司在一定时期向股东分派股利进行配股时，为使本公司的股东真正得到其应得的分红配股权利，就存在着一个这种权利应该分配给股票的买入者还是卖出者才合理的问题，由此产生了股票除息与除权交易。<br>比如上面的小红在分红日卖出股票，这个时候分红算给谁？ 或者说分红给小红，然后小红再以同样价格的股价卖出？是否合理？<br>此外，由于公司分红配股引起公司股本以及每股股票所代表的企业的实际价值（每股净资产）的变动，需要在发生该事实之后以股票市场价格中剔除这部分因素。<br>比如上面的，本来如果利润以净资产等方式保留下来，那股票价值应该是上涨的，但是因为分红导致少了，所以这个时候需要将每股价格进行下调，即除权：<br>而比如上面的，分红后，小红的总资产可能不变，不过这种情况比较少；毕竟股价和很多因素有关；<br>更多： 除息报价，股权登记日，送股率等等；</p>
</li>
<li><p>填权：<br>在除权（息）后的一段时间内，如果多数投资者对该股看好，使得该股股价上涨，其价格高于除权（息）报价，即股价比除（息）前有所上涨，这种行情称为填权。如果股价上涨到除权（息）前的价格水平，称为填满权。<br>相反，如果多数投资者不看好该股，使得该股价下跌，其价格低于除权（息）报价，即股价比除权（息）前有所下降，则为贴权。</p>
</li>
</ul>
<p>所以，除权和填权，是股票上涨和下跌的一个基础因素之一；<br>除此之外，供需关系，和投资者的看好，也会推高股价，比如这双鞋，我觉得价值高，我在市场上出价就高，即投资者推高股价；同样想买的人多，也会推高股价；  </p>
<h4 id="一级市场和二级市场"><a href="#一级市场和二级市场" class="headerlink" title="一级市场和二级市场"></a>一级市场和二级市场</h4><p>  这篇文章对一级市场和二级市场讲的比较清楚：<br><a href="https://www.zhihu.com/question/36594463">https://www.zhihu.com/question/36594463</a><br>简单来讲：  </p>
<ul>
<li><p>一级市场：就是股票最先发行的市场，比如批发市场，而在股市中，一级市场是最开始发行的，对符合条件的机构投资者线下配售的和对个人的网上发行(打新股), 这个时候，往往是股价比较低的，可以理解为批发价，批发市场；</p>
</li>
<li><p>二级市场：就是在批发市场后，由投资机构和打新者，通过交易在零售市场上进行流通；这个时候会有很多散户等入场，于是将价格推高，就像平常的经销商将批发价进价的鞋提高到零售价发售的过程，而打新者因为拿到的是批发价，所以在交易时卖掉可以得到不错的收入；</p>
</li>
<li><p>关于破发：<br>如果股票定价1,000元，但二级市场上压根没有想要购买的交易者或者交易者非常少，如果想尽快出售股票就要承担一个比发行价更低市场价格，比如800块，这个过程就叫做股票破发（跌破发行价）。</p>
</li>
<li><p>一级市场的范围：<br>一级市场被称作发行市场其实是不严谨的，因为一级市场的范围其实更广，除了首次公开募股IPO的股票发行外，还包括了股票在公开发行和上市前的私募股权数轮融资过程，通常会以风投Venture Capital&#x2F;私募股权Private Equity的形式来完成，对应着天使轮-A轮-B轮-C轮有些独角兽企业会一直进行到F轮直至上市退出。这些VC&#x2F;PE，因为投资的都是一级市场未上市的股权，所以也被称为一级市场基金。</p>
</li>
<li><p>为什么要有一级二级市场：<br>就像鞋一样，如果一开始就投入零售市场，价格比较难确定，因为散户对这个鞋的价值认同不一样，需要经过较长时间的定价才能投入；</p>
</li>
</ul>
<h4 id="关于股票投资和股权投资："><a href="#关于股票投资和股权投资：" class="headerlink" title="关于股票投资和股权投资："></a>关于股票投资和股权投资：</h4><ul>
<li><p>股权投资：是一种价值投资，长期投资：<br>股权投资是投到实体经济、投到企业，投资人变成企业长期股东，投资人把自己的资源和隐性能力嫁接到这个公司，为公司的长期发展做出持续性贡献。所以，股权投资有两个非常鲜明的特点：一是增量资金进入公司；二是投资人作为股东会为这个公司做持续性的增值或服务。</p>
</li>
<li><p>股票投资：是一种零和游戏，是赚取波动的钱；<br>在投资者多空博弈中，股价会出现上涨和下跌，幅度有时候会远远超过业绩的变动幅度，意味着股价可能会涨太多偏离内在价值，之后又下跌进行修复，股民通过股价的涨跌波动赚取差价，就是赚波动的钱。那么这部分钱从哪里来，就是从对手的账户中来，有人赚必然就有人亏，你赚的钱就是别人亏的钱。</p>
</li>
<li><p>其他：央行印发钞票，这个时候大家都赚钱：央行印发钞票，为市场提供流动性，流动性充足甚至流动性泛滥，就会出现资产价格上涨，有时还会持续上涨，在由巨量流动性推升的行情中，所有人都赚到钱了，公司盈利没有明显增加，也没有对手博弈亏钱，这赚的就是央行的钱。</p>
</li>
<li><p>PS:<br>股票盈利靠价格波动，股权盈利靠价值增长。<br>A股（二级市场）遍布“铁公鸡”，有钱也不分红，投资人只能通过不断的交易，然后赢得差价。<br>而在一级市场中，较长的锁定期使得股权流动性大大降低，公司未来的估值提升才是盈利核心。<br>在中国，股票市场的绝大多数投资者是散户，而绝大多数上市公司的分红很少，具备持续成长能力的上市公司数量也少。<br>　　所以，中国的股票投资本质是我的钱进到别人兜里，我赚的钱是从别人口袋掏出来的，钱并没有进入公司，而是在不同股东之间高速流转，某种程度上是一种资金的空转。<br>　　股票投资是在交易市场里赚取交易的不对称性、不平衡性，某些人赚钱就意味着其他人一定亏钱，基本上是一个零和游戏。  </p>
</li>
<li><p>如何做股权投资？ TODO;</p>
</li>
</ul>
<h4 id="基金是什么，基金分类"><a href="#基金是什么，基金分类" class="headerlink" title="基金是什么，基金分类"></a>基金是什么，基金分类</h4><p>股票和债券(债权)都是直接投资，而基金，是一种间接投资：  </p>
<ul>
<li><p>基金：代表一种委托关系，委托专业机构帮你理财，收益受专业机构的理财能力影响。一般来说，基金收益小于股票，大于债券，相对应，风险小于股票，大于债券。基金是一种间接投资，是委托专业的人员帮你理财，而专业人员往往会分散投资等等，基金公司将各种投资方案包装为一个个套餐供你选择；而专业人员如基金经理，可能会购买如股票，债券，银行存款等或者混合，来进行投资，并将收益转换为基金收益，返利给投资者等；而基金投资的东西不同，则有不同的基金分类，如股票基金，混合基金等；</p>
</li>
<li><p>因此：</p>
<ul>
<li>股票基金，收益大，风险高；</li>
<li>混合基金，收益中等，风险相对小；</li>
<li>债券基金，收益低，风险小；</li>
<li>还有一种指数基金：如果说普通的基金是由基金经理去主动挑选股票，债券等，那指数基金则是被动的跟踪某个指数来买入股票等组合；</li>
</ul>
</li>
<li><p>引用知乎上的一个解释：<br>指数就是一个选股规则。<br>指数基金它跟踪特定的指数，并按照这个指数成分股的比例买入同样的股票组合。<br>举个例子：学校选取校花有三个标准：身高1.68以上，腰围65cm以下，体重100斤以下。小A（身高1.71，腰围63cm，体重98斤）小B（身高1.70，腰围63cm，体重99斤）小C （身高1.69，腰围64cm，体重98斤）她们三个的身高，体重，腰围都符合选校花的三个标准，就被分到校花之列。<br>而有一天小B由于最近夜宵吃多了长胖了，体重达到了102，那么她就被踢出校花之列，而小D的身高，体重，腰围达标，她就被分到校花之列，只要选择校花的标准不变，就会有源源不断的符合校花条件的人列入其中。<br>计算纳入校花的人群各自美貌分，在加权平均一下，变成一个校花指数。<br>所以，金融市场上的指数的编制，就注定了会有源源不断的好公司被纳入指数中来。而且指数基金，不需要基金经理主动选股，直接买这些指数背后的成分股，构成对应的指数基金。</p>
</li>
</ul>
<h4 id="为什么指数基金值得投资："><a href="#为什么指数基金值得投资：" class="headerlink" title="为什么指数基金值得投资："></a>为什么指数基金值得投资：</h4><ol>
<li>不依赖基金经理选股，而是依赖特定指数；<br>2）不依赖某家公司，公司倒闭了，也不受影响；<br>3）指数基金通过投资指数成分股来获得和市场持平的收益，所以长期看好就有收益；</li>
</ol>
<h4 id="基金中的名词概念："><a href="#基金中的名词概念：" class="headerlink" title="基金中的名词概念："></a>基金中的名词概念：</h4><ul>
<li>净值：基金单位净值即每份基金单位的净资产价值，等于基金的总资产减去总负债后的余额再除以基金全部发行的单位份额总数</li>
<li>申购和申购费率：认购费与申购费性质相似，都是向基金管理人购买基金单位时所支付的手续费<h4 id="基金的相关时间："><a href="#基金的相关时间：" class="headerlink" title="基金的相关时间："></a>基金的相关时间：</h4></li>
<li>基金交易时间：指开放式基金接受申购、转换、赎回或其它交易的时间段。<br>基金主要投资于股票和债券，所以交易时间和股票的开盘时间相同。一般为周一至周五上午9：30-下午3：00，国家法定假日除外，因此这和我们平时说的工作日并不完全相同。  </li>
<li>T日交易规则：<br>T日交易规则中的T日指的是不包括周末和节假日的交易日，一般以股市收市时间15:00为界。<br>一般来说，如果在交易日的15:00前申购，会按当天的净值计算，当天的净值一般在晚上8-10点更新后查看；如果在交易日3点之后购买，那么则按照下个交易日（T+1）当天的净值，具体以基金购买后被确认的信息为准。<br>在提交申购申请的T+1日，基金公司会确认份额，也就是交易确认日。在提交申购申请的T+2日可以查看基金的收益，也就是收益查看日。<br>这里要注意的是，我们在买入基金的时候其实并不知道买入的价格，因为具体的净值要等到当天收盘，基金公司根据收盘价计算后才会更新。</li>
</ul>
<p>举例来说：<br>小明预计下周一市场上涨，因此在周五收盘后提交了订单，但是这和小红在周一下午3点前提交订单是一个效果，都是以周一收盘价计算，而周一的上涨和他都没有关系。因此，在当天下午2点左右操作是一个最佳时间点，因为越接近下午三点买入，就越接近收盘价格。  </p>
<ul>
<li>赎回时间：<br>一般的开放式基金赎回的流程为：T日卖出→ T+1确认→T+3到账。<br>赎回和购买时一样，如果在交易日下午3点前赎回，会按照当天收盘价格计算净值，如果在下午3点后申报赎回，赎回的基金净值则会按照下一个工作日的基金净值计算，资金一般在T+3日到账。<br>不过，具体的基金到账时间要根据实际情况为准，可以在每只基金的交易规则中查看。</li>
</ul>
<h4 id="基金怎么算收益："><a href="#基金怎么算收益：" class="headerlink" title="基金怎么算收益："></a>基金怎么算收益：</h4><p>申购：<br>用1万元申购某基金，申购费率是1.5％，该基金当日净值是1.2000。<br>申购手续费＝10000.00×1.5％＝150.00(元)<br>申购份额＝(10000.00－150.00)÷1.2000＝8208.33(份)<br>赎回：<br>      1个月后赎回该基金，当日净值是1.4000，赎回费率是0.5％。<br>      赎回总额＝8208.33×1.4000＝11491.66(元)<br>      赎回手续费＝11491.66×0.5％＝57.46(元)<br>      赎回净额＝11491.66－57.46＝11434.20(元)<br>      净收益＝11434.20－10000.00＝1434.20(元)</p>
<h3 id="买基金需要看什么："><a href="#买基金需要看什么：" class="headerlink" title="买基金需要看什么："></a>买基金需要看什么：</h3><h4 id="持仓-规模，增长曲线，历史收益，净值估算，最大回撤，基金公告；"><a href="#持仓-规模，增长曲线，历史收益，净值估算，最大回撤，基金公告；" class="headerlink" title="持仓,规模，增长曲线，历史收益，净值估算，最大回撤，基金公告；"></a>持仓,规模，增长曲线，历史收益，净值估算，最大回撤，基金公告；</h4><ul>
<li>持仓：在蛋卷基金或其他基金软件，通过详情可以看到持仓，从而可以看到这个基金购买的公司股票或具体实体。以此判断公司和行业是否值得购买，是否是估值偏高等；</li>
<li>规模：通过详情可以看到规模，即这个基金有多少规模，投入多少money,一般越大越好，即基金净值乘以总数，净值受股价和供需的影响，一般购买规模大的比较稳定，比如100亿以上的；</li>
<li>增长曲线，通过净值年曲线，月曲线等，可以看到这个基金的总体收益等情况；</li>
<li>净值估算：比如支付宝可以看到实时的基金净值估算，从而判断改天的净值走势；</li>
<li>最大回撤： 即最大跌幅是多少；</li>
<li>基金公告：有些基金会进入封闭期等，此时可以通过公告来看什么时候开放等；</li>
</ul>
<h4 id="公司财报"><a href="#公司财报" class="headerlink" title="公司财报"></a>公司财报</h4><p>买股票和基金等，其实是在对公司的投资，所以需要对公司进行分析，只有公司，企业盈利，发展好等，才能有更大的上涨；而分析公司财报，可以看出这家公司的盈利情况等等；<br>公司财报没怎么看过，所以没啥记录的，只有一点宏观的：  </p>
<ul>
<li>A  衡量一个公司的还坏，营收能力，需要看以下几个点：<br>应付预收<ul>
<li>1)应付：【先用货，后给钱】，我大海天要产酱油了，我没有黄豆了，我先跟供货商说，你把豆子给我，然后我晚点结账。帅吧！不给钱就能空手套白狼</li>
<li>2)预收：【先收钱，后发货】，我跟经销商说，我酱油马上做好了，你先打钱，然后我再给你发货。快打钱，不打钱没货了啊，别人订走了。牛吧，先给钱后发货。</li>
</ul>
</li>
</ul>
<p>应收预付</p>
<ul>
<li>1)应收：【先发货，收不到钱】，我先发酱油给经销商，但是人家不给我钱，谁让他卖得好呢。哎不牛了。</li>
<li>2)预付：【先给钱，收不到货】，哎，我黄豆钱都打过去了，黄豆还没给我呢，谁让人既黄豆好呢。不帅。不牛。</li>
<li>B:通过什么科目判断公司的安全性：？<br>资产负债率：&#x3D;总负债&#x2F;总资产；负债率大于70%的公司偿债风险比较大，而小于40%的几乎没有偿债风险；<br>股票可以参考A,B指标来购买；</li>
<li>C:如何下载上市公司的财报：<br><a href="http://www.cninfo.com.cn/new/index%E5%B7%A8%E6%BD%AE%E8%B5%84%E8%AE%AF%E7%BD%91%EF%BC%9B">http://www.cninfo.com.cn/new/index巨潮资讯网；</a><br>财报分析看结构，有23个步骤；</li>
<li>D:找工作跳槽等也是可以参考该上市公司的财务报表情况来看这家公司是不是一家好公司；<br>  要选择好的行业；</li>
</ul>
<h4 id="公司的ROE等参数"><a href="#公司的ROE等参数" class="headerlink" title="公司的ROE等参数"></a>公司的ROE等参数</h4><ul>
<li><p>市盈率：<br>公司市值&#x2F;公司盈利 (即PE&#x3D;P&#x2F;E),P为公司市值，E表示公司盈利；(市值是指一家上市公司的发行股份按市场价格计算出来的股票总价值，其计算方法为每股股票的市场价格乘以发行总股数）<br>反映了我们愿意为获取1元的净利润付出多少代价：比如一个公司的市盈率是10，则代表我们愿意为这个公司的1元盈利付出10元；<br>适用范围：流通性好，盈利稳定的品种；周期行业也不适用市盈率；</p>
</li>
<li><p>盈利收益率<br>市盈率的倒数：公司盈利除以公司市值 E&#x2F;P，即收益率</p>
</li>
<li><p>市净率<br>每股股价与每股净资产的比率：账面价值；PB&#x3D;P&#x2F;B P：公司市值，B：公司净资产；(资产-负债)  —越小越好</p>
</li>
<li><p>ROE: 净资产收益率  净利润&#x2F;净资产   ： ROE越高，则资产运作效率越高</p>
</li>
<li><p>股息率<br>股息：是公司现金分红除以公司的市值，得到的就是股息率了；–越高越好</p>
</li>
</ul>
<h4 id="什么时候开始定投？"><a href="#什么时候开始定投？" class="headerlink" title="什么时候开始定投？"></a>什么时候开始定投？</h4><p>盈利收益率大于10%时，开始定投，6.4%到10%时，坚持持有<br>盈利收益率低于6.4%时，分批卖出基金  </p>
<h3 id="基金的投资指南–参考《指数基金投资指南》"><a href="#基金的投资指南–参考《指数基金投资指南》" class="headerlink" title="基金的投资指南–参考《指数基金投资指南》"></a>基金的投资指南–参考《指数基金投资指南》</h3><p>这本书主要讲述，指数基金的投资：<br>包括指数基金的解释，<br>指数基金的分类和特点，涵盖宽基，行业指数等等，<br>基金的投资理念：价值投资，估值等方法；<br>如何定投和如何制定属于自己的投资计划；<br>家庭资产配置和如何做长期投资的心理建设，不被短期涨跌影响；<br>更多具体可以查，当工具书等；  </p>
<h3 id="我目前买的组合和持仓："><a href="#我目前买的组合和持仓：" class="headerlink" title="我目前买的组合和持仓："></a>我目前买的组合和持仓：</h3><p>目前主要关注螺丝钉和螺丝钉相关组合，通过蛋卷基金投资，另外一些自选主要有易方达系列，汇添系列，兴全系列，银华富裕主题混合，招行中证白酒指数，华夏上证50AH优选指数(LOF)A,沪深300大盘，钉钉宝365组合等等；  </p>
<h3 id="一些基金软件等："><a href="#一些基金软件等：" class="headerlink" title="一些基金软件等："></a>一些基金软件等：</h3><p>天天基金，蛋卷基金，易方达基金<br>东方财富，雪球</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>打算玩点美股，港股打新，正在学习和搞账号，下一篇记录下美股和美股的一些知识，比如做空等等是什么意思；</p>
]]></content>
      <categories>
        <category>Financial_management</category>
      </categories>
      <tags>
        <tag>Funds_and_stocks</tag>
      </tags>
  </entry>
  <entry>
    <title>sk_buff</title>
    <url>/2021/02/21/sk-buff/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="关于skb"><a href="#关于skb" class="headerlink" title="关于skb"></a>关于skb</h3><p>skb是网络协议栈中对包的底层操作结构，它需要满足以下特性：</p>
<ol>
<li>能方便的处理可变长缓存，因为发送和接收的数据长时不固定的<br>2）能容易实现头尾部增加和移除数据，因为这些缓存区需要在不同网络层次间进行传递<br>3）添加和移除数据能尽量避免数据的复制<span id="more"></span><br>sk_buffer定义：<br>include&#x2F;linux&#x2F;skbuff.h<br>net&#x2F;core&#x2F;skbuff.c<br>在下载的linux源码中能找到(下来看的或者是ubuntu中下来编译内核的)</li>
</ol>
<p>ref:&lt;linux内核源码剖析–TCP&#x2F;IP实现&gt;</p>
<h3 id="sk-buff的结构"><a href="#sk-buff的结构" class="headerlink" title="sk_buff的结构"></a>sk_buff的结构</h3><h4 id="大体结构："><a href="#大体结构：" class="headerlink" title="大体结构："></a>大体结构：</h4><p>分类：</p>
<ol>
<li>与skb组织相关的成员变量</li>
<li>通用成员变量</li>
<li>标志性变量</li>
<li>与特性相关的成员变量<br>这些与特性相关的成员，往往用#ifdef来限制，若要使用他们，需要系统定义这些宏，而这个需要在编译内核时开启，比如：<br>编译时选中 Networking-&gt;Networking options-&gt;QoS and&#x2F;or fair queueing-&gt;action，选中包分类器的功能，对应宏：<br>CONFIG_NET_CLS_ACT<br>注意的是：若某个内核模块包含了使用未定义的宏限制的变量，则无法被内核使用；</li>
</ol>
<p>skb被哪些网络层次处理？<br>二层的mac或者其他链路层协议，三层的ip协议，四层的tcp和udp协议，某些成员会在层次间传递的时候发生改变，如四层向三层传递时会加一个ip头，<br>三层向二层传递时会加一个mac头等，反之则删除，而传递时只增加头部可以提高效率；这个需要复杂的指针操作，内核提供了一个函数： skb_reserve();<br>起到在向下传递skb前，在数据缓存区头部预留空间的作用；</p>
<h4 id="skb相关的两个链表"><a href="#skb相关的两个链表" class="headerlink" title="skb相关的两个链表"></a>skb相关的两个链表</h4><p>在正式看skb的结构之前，先看看组织skb的两个链表，来看skb的全局：<br>在数据被传递进来时，触发中断，中断处理程序会将数据传递进内核，接着一步步拷贝到skb；skb由链表组织：<br>在sk_buff中有两个成员结构：<br>struct sk_buff *next;<br>struct sk_buff *prev;<br>以此构成skb_buff双向链表；<br>为了能使每个skb都能被整个链表的头部快速找到，在第一个skb结点前加了一个辅助的sk_buff_head结构的头结点，就像链表头一样，作为<br>链表的头结点，可以由此遍历skb链表；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff_head</span> &#123;</span><br><span class="line">	<span class="comment">/* These two members must be first. */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span>	*next;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span>	*prev;</span><br><span class="line"></span><br><span class="line">	__u32		qlen;</span><br><span class="line">	<span class="type">spinlock_t</span>	lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构组织：<br>&lt;-&gt; sk_buff_head &lt;-&gt; skb1 &lt;-&gt; skb2 …&lt;-&gt; 链接到sk_buff_head形成环形双向链表</p>
<h4 id="skb结构："><a href="#skb结构：" class="headerlink" title="skb结构："></a>skb结构：</h4><p>skb结构可以被大致分为 描述符(skb本身) 和数据缓冲区 (head等成员指针指向的数据)<br>以下是内核4.4.0中的include&#x2F;linux&#x2F;定义的sk_buff结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *	struct sk_buff - socket buffer</span></span><br><span class="line"><span class="comment"> *	@next: Next buffer in list </span></span><br><span class="line"><span class="comment"> *	@prev: Previous buffer in list</span></span><br><span class="line"><span class="comment"> *	@tstamp: Time we arrived/left 接收或发送时间戳，在网络设备收到一个数据包后，由netif_receive_skb()或netif_rx()调用net_timestamp()设置</span></span><br><span class="line"><span class="comment"> *	@rbnode: RB tree node, alternative to next/prev for netem/tcp</span></span><br><span class="line"><span class="comment"> *	@sk: Socket we are owned by //skb的宿主，当源ip和目的ip都不是本机时，为NULL,否则在数据发送接收时通过这个结构传递给到上层和应有程序挂钩；</span></span><br><span class="line"><span class="comment"> *	@dev: Device we arrived on/are leaving by 从网卡接收数据时，需要分配skb接收缓存队列，这个时候分配成功，就会设置这个结构为对应网卡，发送类似，复杂些；</span></span><br><span class="line"><span class="comment"> *	@cb: Control buffer. Free for use by every layer. Put private vars here</span></span><br><span class="line"><span class="comment"> *	@_skb_refdst: destination entry (with norefcount bit) 目的路由缓存；</span></span><br><span class="line"><span class="comment"> *	@sp: the security path, used for xfrm ipsec协议用来跟踪传输信息</span></span><br><span class="line"><span class="comment"> *	@len: Length of actual data  skb实际数据部分长度，包括线性缓存区中数据长度和(data-&gt;)和SG类型的聚合分散io的数据和FRAGLIST类型的聚合分散io数据，以及传递时增加或减去的协议首部；</span></span><br><span class="line"><span class="comment"> *	@data_len: Data length SG类型的聚合分散io的数据和FRAGLIST类型的聚合分散io数据长</span></span><br><span class="line"><span class="comment"> *	@mac_len: Length of link layer header</span></span><br><span class="line"><span class="comment"> *	@hdr_len: writable header length of cloned skb</span></span><br><span class="line"><span class="comment"> *	@csum: Checksum (must include start/offset pair)</span></span><br><span class="line"><span class="comment"> *	@csum_start: Offset from skb-&gt;head where checksumming should start</span></span><br><span class="line"><span class="comment"> *	@csum_offset: Offset from csum_start where checksum should be stored</span></span><br><span class="line"><span class="comment"> *	@priority: Packet queueing priority 发送或转发数据包的Qos类别，若包本地生成，则套接口层会设置该字段；</span></span><br><span class="line"><span class="comment"> *	@ignore_df: allow local fragmentation 允许本地分片</span></span><br><span class="line"><span class="comment"> *	@cloned: Head may be cloned (check refcnt to be sure) 标记所属的skb是否已克隆</span></span><br><span class="line"><span class="comment"> *	@ip_summed: Driver fed us an IP checksum  用于标记传输层校验和的状态：CHECKSUM_NONE/CHECKSUM_PARTIAL/..</span></span><br><span class="line"><span class="comment"> *	@nohdr: Payload reference only, must not modify header payload是否被单独引用，不存在协议首部。若被单独引用，则不能修改首部，也不能由data访问首部</span></span><br><span class="line"><span class="comment"> *	@nfctinfo: Relationship of this skb to the connection </span></span><br><span class="line"><span class="comment"> *	@pkt_type: Packet class 帧类型：PACKET_HOST/PACKET_BROADCAST/PACKET_MULTICAST/PACKET_OTHERHOST/...</span></span><br><span class="line"><span class="comment"> *	@fclone: skbuff clone status 当前克隆状态：SKB_FCLONE_UNAVAILABLE/SKB_FCLONE_ORIG/SKB_FCLONE_CLONE:</span></span><br><span class="line"><span class="comment"> *	@ipvs_property: skbuff is owned by ipvs</span></span><br><span class="line"><span class="comment"> *	@peeked: this packet has been seen already, so stats have been</span></span><br><span class="line"><span class="comment"> *		done for it, don&#x27;t do them again</span></span><br><span class="line"><span class="comment"> *	@nf_trace: netfilter packet trace flag </span></span><br><span class="line"><span class="comment"> *	@protocol: Packet protocol from driver，重要的字段，即链路层承载的三层协议类型，如ip ipv6 arp,在if_ether.h中有定义，这个用来确定收包时传给哪个协议处理函数，因此必须提前初始化；</span></span><br><span class="line"><span class="comment"> *	@destructor: Destruct function  析构函数</span></span><br><span class="line"><span class="comment"> *	@nfct: Associated connection, if any</span></span><br><span class="line"><span class="comment"> *	@nf_bridge: Saved data about a bridged frame - see br_netfilter.c</span></span><br><span class="line"><span class="comment"> *	@skb_iif: ifindex of device we arrived on</span></span><br><span class="line"><span class="comment"> *	@tc_index: Traffic control index  输入流量控制</span></span><br><span class="line"><span class="comment"> *	@tc_verd: traffic control verdict  输入流量控制</span></span><br><span class="line"><span class="comment"> *	@hash: the packet hash</span></span><br><span class="line"><span class="comment"> *	@queue_mapping: Queue mapping for multiqueue devices</span></span><br><span class="line"><span class="comment"> *	@xmit_more: More SKBs are pending for this queue</span></span><br><span class="line"><span class="comment"> *	@pfmemalloc: skbuff was allocated from PFMEMALLOC reserves</span></span><br><span class="line"><span class="comment"> *	@ndisc_nodetype: router type (from link layer)</span></span><br><span class="line"><span class="comment"> *	@ooo_okay: allow the mapping of a socket to a queue to be changed</span></span><br><span class="line"><span class="comment"> *	@l4_hash: indicate hash is a canonical 4-tuple hash over transport</span></span><br><span class="line"><span class="comment"> *		ports.</span></span><br><span class="line"><span class="comment"> *	@sw_hash: indicates hash was computed in software stack</span></span><br><span class="line"><span class="comment"> *	@wifi_acked_valid: wifi_acked was set</span></span><br><span class="line"><span class="comment"> *	@wifi_acked: whether frame was acked on wifi or not</span></span><br><span class="line"><span class="comment"> *	@no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS</span></span><br><span class="line"><span class="comment"> *	@dst_pending_confirm: need to confirm neighbour</span></span><br><span class="line"><span class="comment">  *	@napi_id: id of the NAPI struct this skb came from</span></span><br><span class="line"><span class="comment"> *	@secmark: security marking</span></span><br><span class="line"><span class="comment"> *	@offload_fwd_mark: fwding offload mark</span></span><br><span class="line"><span class="comment"> *	@mark: Generic packet mark</span></span><br><span class="line"><span class="comment"> *	@vlan_proto: vlan encapsulation protocol</span></span><br><span class="line"><span class="comment"> *	@vlan_tci: vlan tag control information</span></span><br><span class="line"><span class="comment"> *	@inner_protocol: Protocol (encapsulation)</span></span><br><span class="line"><span class="comment"> *	@inner_transport_header: Inner transport layer header (encapsulation) 传输层首部</span></span><br><span class="line"><span class="comment"> *	@inner_network_header: Network layer header (encapsulation) 网络层首部</span></span><br><span class="line"><span class="comment"> *	@inner_mac_header: Link layer header (encapsulation) 链路层首部，这几个首部，在层与层传输中，data会发生指向的改变；</span></span><br><span class="line"><span class="comment"> *	@transport_header: Transport layer header</span></span><br><span class="line"><span class="comment"> *	@network_header: Network layer header</span></span><br><span class="line"><span class="comment"> *	@mac_header: Link layer header </span></span><br><span class="line"><span class="comment"> *	@tail: Tail pointer</span></span><br><span class="line"><span class="comment"> *	@end: End pointer</span></span><br><span class="line"><span class="comment"> *	@head: Head of buffer</span></span><br><span class="line"><span class="comment"> *	@data: Data head pointer</span></span><br><span class="line"><span class="comment"> *	@truesize: Buffer size  整个缓存区长度 len+sizeof(sk_buff)</span></span><br><span class="line"><span class="comment"> *	@users: User count - see &#123;datagram,tcp&#125;.c 引用计数，为0时才释放此结构，否则只是单纯的递增递减，skb_get(),kfree_skb()等操作函数；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff</span> &#123;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="comment">/* These two members must be first. */</span></span><br><span class="line">			<span class="keyword">struct</span> <span class="title class_">sk_buff</span>		*next;</span><br><span class="line">			<span class="keyword">struct</span> <span class="title class_">sk_buff</span>		*prev;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">union</span> &#123;</span><br><span class="line">				<span class="type">ktime_t</span>		tstamp;</span><br><span class="line">				<span class="keyword">struct</span> <span class="title class_">skb_mstamp</span> skb_mstamp;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rb_node</span>		rbnode; <span class="comment">/* used in netem, ip4 defrag, and tcp stack */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">sock</span>		*sk; </span><br><span class="line">		<span class="type">int</span>			ip_defrag_offset;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span>	*dev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is the control buffer. It is free to use for every</span></span><br><span class="line"><span class="comment">	 * layer. Please put your private variables there. If you</span></span><br><span class="line"><span class="comment">	 * want to keep them across layers you have to do a skb_clone()</span></span><br><span class="line"><span class="comment">	 * first. This is owned by whoever has the skb queued ATM.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span>			cb[<span class="number">48</span>] __aligned(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		_skb_refdst;</span><br><span class="line">	<span class="built_in">void</span>			(*destructor)(<span class="keyword">struct</span> sk_buff *skb);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_XFRM</span></span><br><span class="line">	<span class="keyword">struct</span>	<span class="title class_">sec_path</span>	*sp;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">nf_conntrack</span>	*nfct;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_BRIDGE_NETFILTER)</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">nf_bridge_info</span>	*nf_bridge;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		len,</span><br><span class="line">				data_len;</span><br><span class="line">	__u16			mac_len,</span><br><span class="line">				hdr_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Following fields are _not_ copied in __copy_skb_header()</span></span><br><span class="line"><span class="comment">	 * Note that queue_mapping is here mostly to fill a hole.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">kmemcheck_bitfield_begin</span>(flags1);</span><br><span class="line">	__u16			queue_mapping;</span><br><span class="line">	__u8			cloned:<span class="number">1</span>,</span><br><span class="line">				nohdr:<span class="number">1</span>,</span><br><span class="line">				fclone:<span class="number">2</span>,</span><br><span class="line">				peeked:<span class="number">1</span>,</span><br><span class="line">				head_frag:<span class="number">1</span>,</span><br><span class="line">				xmit_more:<span class="number">1</span>,</span><br><span class="line">				pfmemalloc:<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">kmemcheck_bitfield_end</span>(flags1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fields enclosed in headers_start/headers_end are copied</span></span><br><span class="line"><span class="comment">	 * using a single memcpy() in __copy_skb_header()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* private: */</span></span><br><span class="line">	__u32			headers_start[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">/* public: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* if you move pkt_type around you also must adapt those constants */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BIG_ENDIAN_BITFIELD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PKT_TYPE_MAX	(7 &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PKT_TYPE_MAX	7</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PKT_TYPE_OFFSET()	offsetof(struct sk_buff, __pkt_type_offset)</span></span><br><span class="line"></span><br><span class="line">	__u8			__pkt_type_offset[<span class="number">0</span>];</span><br><span class="line">	__u8			pkt_type:<span class="number">3</span>;</span><br><span class="line">	__u8			ignore_df:<span class="number">1</span>;</span><br><span class="line">	__u8			nfctinfo:<span class="number">3</span>;</span><br><span class="line">	__u8			nf_trace:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	__u8			ip_summed:<span class="number">2</span>;</span><br><span class="line">	__u8			ooo_okay:<span class="number">1</span>;</span><br><span class="line">	__u8			l4_hash:<span class="number">1</span>;</span><br><span class="line">	__u8			sw_hash:<span class="number">1</span>;</span><br><span class="line">	__u8			wifi_acked_valid:<span class="number">1</span>;</span><br><span class="line">	__u8			wifi_acked:<span class="number">1</span>;</span><br><span class="line">	__u8			no_fcs:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Indicates the inner headers are valid in the skbuff. */</span></span><br><span class="line">	__u8			encapsulation:<span class="number">1</span>;</span><br><span class="line">	__u8			encap_hdr_csum:<span class="number">1</span>;</span><br><span class="line">	__u8			csum_valid:<span class="number">1</span>;</span><br><span class="line">	__u8			csum_complete_sw:<span class="number">1</span>;</span><br><span class="line">	__u8			csum_level:<span class="number">2</span>;</span><br><span class="line">	__u8			csum_bad:<span class="number">1</span>;</span><br><span class="line">	__u8			dst_pending_confirm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IPV6_NDISC_NODETYPE</span></span><br><span class="line">	__u8			ndisc_nodetype:<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	__u8			ipvs_property:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	__u8			inner_protocol_type:<span class="number">1</span>;</span><br><span class="line">	__u8			remcsum_offload:<span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* 3 or 5 bit hole */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_SCHED</span></span><br><span class="line">	__u16			tc_index;	<span class="comment">/* traffic control index */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_CLS_ACT</span></span><br><span class="line">	__u16			tc_verd;	<span class="comment">/* traffic control verdict */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		__wsum		csum;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			__u16	csum_start;</span><br><span class="line">			__u16	csum_offset;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u32			priority;</span><br><span class="line">	<span class="type">int</span>			skb_iif;</span><br><span class="line">	__u32			hash;</span><br><span class="line">	__be16			vlan_proto;</span><br><span class="line">	__u16			vlan_tci;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_NET_RX_BUSY_POLL) || defined(CONFIG_XPS)</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>	napi_id;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>	sender_cpu;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETWORK_SECMARK</span></span><br><span class="line">		__u32		secmark;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_SWITCHDEV</span></span><br><span class="line">		__u32		offload_fwd_mark;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		__u32		mark;</span><br><span class="line">		__u32		reserved_tailroom;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		__be16		inner_protocol;</span><br><span class="line">		__u8		inner_ipproto;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	__u16			inner_transport_header;</span><br><span class="line">	__u16			inner_network_header;</span><br><span class="line">	__u16			inner_mac_header;</span><br><span class="line"></span><br><span class="line">	__be16			protocol;</span><br><span class="line">	__u16			transport_header;</span><br><span class="line">	__u16			network_header;</span><br><span class="line">	__u16			mac_header;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* private: */</span></span><br><span class="line">	__u32			headers_end[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">/* public: */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line">	<span class="type">sk_buff_data_t</span>		tail;</span><br><span class="line">	<span class="type">sk_buff_data_t</span>		end;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		*head,</span><br><span class="line">				*data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		truesize;</span><br><span class="line">	<span class="type">atomic_t</span>		users;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一张图片来表示skb的线性缓存区：发送和接收时会动态变化；<br>struct sk_buff<br>…<br>head —&gt;headroom起点<br>data —&gt;data起点<br>tail —&gt;tailroom起点<br>end  —&gt;skb_shared_info起点<br>|headroom|data|tailroom|skb_shared_info|</p>
<h3 id="skb-shared-info结构"><a href="#skb-shared-info结构" class="headerlink" title="skb_shared_info结构"></a>skb_shared_info结构</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This data is invariant across clones and lives at</span></span><br><span class="line"><span class="comment"> * the end of the header data, ie. at skb-&gt;end.</span></span><br><span class="line"><span class="comment"> */</span> <span class="comment">//即end指针指向的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">skb_shared_info</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	nr_frags;</span><br><span class="line">	__u8		tx_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	gso_size;</span><br><span class="line">	<span class="comment">/* Warning: this field is not always filled in (UFO)! */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	gso_segs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>  gso_type;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span>	*frag_list;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">skb_shared_hwtstamps</span> hwtstamps;</span><br><span class="line">	u32		tskey;</span><br><span class="line">	__be32          ip6_frag_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Warning : all fields before dataref are cleared in __alloc_skb()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_t</span>	dataref;<span class="comment">//引用计数器：当一个数据缓存区被多个skb描述符引用时，就会设置相应的计数，如克隆一个skb</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Intermediate layers must ensure that destructor_arg</span></span><br><span class="line"><span class="comment">	 * remains valid until skb destructor */</span></span><br><span class="line">	<span class="type">void</span> *		destructor_arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* must be last field, see pskb_expand_head() */</span></span><br><span class="line">	<span class="type">skb_frag_t</span>	frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="通过网络接口在两个本地文件间传输数据下，如何避免四次拷贝"><a href="#通过网络接口在两个本地文件间传输数据下，如何避免四次拷贝" class="headerlink" title="通过网络接口在两个本地文件间传输数据下，如何避免四次拷贝"></a>通过网络接口在两个本地文件间传输数据下，如何避免四次拷贝</h4><p>在数据发送到接收时，往往send&#x2F;write -&gt;recv&#x2F;read 这期间会涉及四次拷贝：<br>发送app用户进程空间缓存–&gt;内核态缓存-（DMA复制)-&gt;硬件驱动 —-发送—-接收方硬件网络模块-(DMA复制)-&gt;内核态缓存–&gt;用户空间缓存；<br>如果是本地文件–网络接口—本地文件，这种也是四次拷贝，就有点耗费时间了；（或者是收到数据原封不动传输出去,这个貌似还没实现）<br>调用方式改变：从read&#x2F;write&#x3D;&#x3D;&#x3D;&#x3D;&gt;open&#x2F;sendfile<br>实际路径改变：接收硬件网络模块(DMA复制)–&gt;内核态缓存—&gt; 发送硬件驱动</p>
<h4 id="什么是聚合分散io数据以及skb-shared-info中对它支持的结构；"><a href="#什么是聚合分散io数据以及skb-shared-info中对它支持的结构；" class="headerlink" title="什么是聚合分散io数据以及skb_shared_info中对它支持的结构；"></a>什么是聚合分散io数据以及skb_shared_info中对它支持的结构；</h4><p>这里的聚合分散IO相关数据成员：<br>struct sk_buff *frag_list; &#x2F;&#x2F;FRAGLIST类型的IP分片相关结构<br>unsigned short nr_frags; &#x2F;&#x2F;聚合分散IO分片数量<br>skb_frag_t frags[MAX_SKB_FRAGS];&#x2F;&#x2F;聚合分散IO page相关结构指针；<br>先理解下网络发送接收和组合分片相关的流程：<br>发送：用户数据–&gt;四层tcp&#x2F;udp–&gt;IP:此时包需要一层层传递组合各层头，需要进行比较多的拷贝，此时是组合；在内核传递发送报文给hard_start_xmit()之前，需要判断网络是否<br>支持NETIF_F_SG,否则只能线性化处理，是则检查nr_frags的值，确定片段数，之后进行分片聚合；<br>接受：IP分片–IP分片重组–&gt;udp&#x2F;tcp–&gt;用户；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* To allow 64K frame to be packed as single skb without frag_list we</span></span><br><span class="line"><span class="comment"> * require 64K/PAGE_SIZE pages plus 1 additional page to allow for</span></span><br><span class="line"><span class="comment"> * buffers which do not start on a page boundary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since GRO uses frags we allocate at least 16 regardless of page</span></span><br><span class="line"><span class="comment"> * size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (65536/PAGE_SIZE + 1) &lt; 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SKB_FRAGS 16UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SKB_FRAGS (65536/PAGE_SIZE + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//所有最多支持64K个分片</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">skb_frag_struct</span> <span class="type">skb_frag_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">skb_frag_struct</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">page</span> *p;</span><br><span class="line">	&#125; page;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (BITS_PER_LONG &gt; 32) || (PAGE_SIZE &gt;= 65536)</span></span><br><span class="line">	__u32 page_offset;</span><br><span class="line">	__u32 size;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	__u16 page_offset;</span><br><span class="line">	__u16 size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>frag_list的使用：</li>
</ul>
<ol>
<li>在接受分片组后链接多个分片，组成一个完整的IP数据报；</li>
<li>UDP数据输出时，将待分片的SKB链接到一个SKB中，然后在输出时快速分片；</li>
<li>用于存放FRAGLIST类型的聚合分散IO数据包；</li>
</ol>
<ul>
<li>nr_frag SG类型的聚合分散IO的使用：</li>
</ul>
<ol>
<li>在输出时需要判断nr_frag&#x3D;0? 且frag_list&#x3D;&#x3D;NULL，则没有分片，若nr_frag不为0且frag_list为NULL,则是聚合分散IO;<br>nr_frag表示数量，内容由frags数组指出：eg:<br>nr_frag &#x3D;2; frags[0].page&#x3D;p1, frags[0].page_offset&#x3D;0,size&#x3D;S1; frags[1].page&#x3D;p1,frags[1].page_offset&#x3D;S1,size&#x3D;S2;</li>
<li>不同的skb实例中的page指向相同的内存，即共享分片结构（共享内存),这个需要两方都不去修改它；</li>
</ol>
<ul>
<li>FRAGLIST类型的聚合分散IO<br> frag_lsit直接指向了一个skb结构的实例；</li>
</ul>
<h4 id="关于GSO-x2F-GRO-x2F-TSO-x2F-TRO的基本概念；"><a href="#关于GSO-x2F-GRO-x2F-TSO-x2F-TRO的基本概念；" class="headerlink" title="关于GSO&#x2F;GRO&#x2F;TSO&#x2F;TRO的基本概念；"></a>关于GSO&#x2F;GRO&#x2F;TSO&#x2F;TRO的基本概念；</h4><h4 id="如何访问skb-shared-info结构："><a href="#如何访问skb-shared-info结构：" class="headerlink" title="如何访问skb_shared_info结构："></a>如何访问skb_shared_info结构：</h4><p>可以借助skb_info宏来访问此结构： 它其实就是简单的返回sk_buff结构的end指针的类型转换结果；<br>#define skb_shinfo(SKB) ((struct skb_shared_info*) ((SKB)-&gt;end))<br>eg: skb_shinfo(skb)-&gt;dataref++;</p>
<h3 id="skb的相关管理函数："><a href="#skb的相关管理函数：" class="headerlink" title="skb的相关管理函数："></a>skb的相关管理函数：</h3><p>内核提供了很多小函数来操作skb变量和链表等，这些函数都有两个版本：do_something和__do_something(),前者是在调用后者的情况下加上<br>锁和检查等；一般使用用前者的；这些函数定义在skbuff.h和skbuff.c中，我们称为skb的管理操作函数；<br>以下介绍每个类型的函数，并给出一些简单的例子，可以是demo或者是内核中的相关调用；</p>
<h4 id="SKB的缓存池介绍"><a href="#SKB的缓存池介绍" class="headerlink" title="SKB的缓存池介绍"></a>SKB的缓存池介绍</h4><p>在网络模块中，用告诉缓存来为skb分配空间，在初始化skb_init()中，创建了两个用来分配skb的高速缓存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __init <span class="title">skb_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	skbuff_head_cache = <span class="built_in">kmem_cache_create</span>(<span class="string">&quot;skbuff_head_cache&quot;</span>,</span><br><span class="line">					      <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sk_buff),</span><br><span class="line">					      <span class="number">0</span>,</span><br><span class="line">					      SLAB_HWCACHE_ALIGN|SLAB_PANIC,</span><br><span class="line">					      <span class="literal">NULL</span>);</span><br><span class="line">	skbuff_fclone_cache = <span class="built_in">kmem_cache_create</span>(<span class="string">&quot;skbuff_fclone_cache&quot;</span>,</span><br><span class="line">						<span class="built_in">sizeof</span>(<span class="keyword">struct</span> sk_buff_fclones),</span><br><span class="line">						<span class="number">0</span>,</span><br><span class="line">						SLAB_HWCACHE_ALIGN|SLAB_PANIC,</span><br><span class="line">						<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Layout of fast clones : [skb1][skb2][fclone_ref] */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff_fclones</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span>	skb1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span>	skb2;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_t</span>	fclone_ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一般情况下用第一个，当在分配skb的时候知道可能被克隆，则用第二个，因为第二个中会同时分配一个后备的skb，在克隆的时候直接用后备的skb就可以，不用重新分配；<br>可以看到第二个的单位内存区域是2*size+atomic_t,后者是用来做引用计数的；引用计数取0,1,2分别代表两个都没有被引用，1表示引用了其中一个，2表示两个都被引用；</p>
<h4 id="如何分配SKB"><a href="#如何分配SKB" class="headerlink" title="如何分配SKB"></a>如何分配SKB</h4><ol>
<li>alloc_skb()<br>skb的数据缓存区和skb本身描述符是两个不同的实体，所以在分配一个skb时，实际上需要分配两块内存：<br>一个是skb描述符，一个是数据缓存区；在4.8的内核版本可以看到：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> <span class="title class_">sk_buff</span> *<span class="built_in">alloc_skb</span>(<span class="type">unsigned</span> <span class="type">int</span> size,</span><br><span class="line">					<span class="type">gfp_t</span> priority)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __alloc_skb(size, priority, <span class="number">0</span>, NUMA_NO_NODE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>函数传入一个size和priority,返回一个sk_buff指针；<br>而__alloc_skb()则有四个参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	__alloc_skb	-	allocate a network buffer</span></span><br><span class="line"><span class="comment"> *	@size: size to allocate 分配的长度</span></span><br><span class="line"><span class="comment"> *	@gfp_mask: allocation mask  分配内存的方式</span></span><br><span class="line"><span class="comment"> *	@flags: If SKB_ALLOC_FCLONE is set, allocate from fclone cache</span></span><br><span class="line"><span class="comment"> *		instead of head cache and allocate a cloned (child) skb.</span></span><br><span class="line"><span class="comment"> *		If SKB_ALLOC_RX is set, __GFP_MEMALLOC will be used for</span></span><br><span class="line"><span class="comment"> *		allocations in case the data is required for writeback </span></span><br><span class="line"><span class="comment">        预测是否会克隆，以此判断是从哪个告诉缓存中分配</span></span><br><span class="line"><span class="comment">        若 SKB_ALLOC_RX is set。。。</span></span><br><span class="line"><span class="comment"> *	@node: numa node to allocate memory on 当支持NUMA时，用于确定从哪个内存区中分配SKB</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Allocate a new &amp;sk_buff. The returned buffer has no headroom and a</span></span><br><span class="line"><span class="comment"> *	tail room of at least size bytes. The object has a reference count</span></span><br><span class="line"><span class="comment"> *	of one. The return is the buffer. On a failure the return is %NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Buffers may only be allocated from interrupts using a @gfp_mask of</span></span><br><span class="line"><span class="comment"> *	%GFP_ATOMIC.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff</span> *__alloc_skb(<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">gfp_t</span> gfp_mask,</span><br><span class="line">			    <span class="type">int</span> flags, <span class="type">int</span> node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">kmem_cache</span> *cache;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">skb_shared_info</span> *shinfo;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span> *skb;</span><br><span class="line">	u8 *data;</span><br><span class="line">	<span class="type">bool</span> pfmemalloc;</span><br><span class="line"></span><br><span class="line">	cache = (flags &amp; SKB_ALLOC_FCLONE)</span><br><span class="line">		? skbuff_fclone_cache : skbuff_head_cache;<span class="comment">//判断是用哪种高速缓存，上面已解释</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">sk_memalloc_socks</span>() &amp;&amp; (flags &amp; SKB_ALLOC_RX))<span class="comment">//判断是否可以用紧急的缓存</span></span><br><span class="line">		gfp_mask |= __GFP_MEMALLOC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the HEAD */</span></span><br><span class="line">	skb = <span class="built_in">kmem_cache_alloc_node</span>(cache, gfp_mask &amp; ~__GFP_DMA, node);<span class="comment">//从选定的告诉缓存中分配一个SKB描述符,一般在slab分配</span></span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="built_in">prefetchw</span>(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We do our best to align skb_shared_info on a separate cache</span></span><br><span class="line"><span class="comment">	 * line. It usually works because kmalloc(X &gt; SMP_CACHE_BYTES) gives</span></span><br><span class="line"><span class="comment">	 * aligned memory blocks, unless SLUB/SLAB debug is enabled.</span></span><br><span class="line"><span class="comment">	 * Both skb-&gt;head and skb_shared_info are cache line aligned.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = <span class="built_in">SKB_DATA_ALIGN</span>(size);<span class="comment">//给size先做下对齐</span></span><br><span class="line">	size += <span class="built_in">SKB_DATA_ALIGN</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> skb_shared_info));<span class="comment">//加上缓存区尾部的skb_shared_info结构后</span></span><br><span class="line">	data = <span class="built_in">kmalloc_reserve</span>(size, gfp_mask, node, &amp;pfmemalloc);<span class="comment">//分配数据缓存区</span></span><br><span class="line">	<span class="keyword">if</span> (!data)</span><br><span class="line">		<span class="keyword">goto</span> nodata;</span><br><span class="line">	<span class="comment">/* kmalloc(size) might give us more room than requested.</span></span><br><span class="line"><span class="comment">	 * Put skb_shared_info exactly at the end of allocated zone,</span></span><br><span class="line"><span class="comment">	 * to allow max possible filling before reallocation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = <span class="built_in">SKB_WITH_OVERHEAD</span>(<span class="built_in">ksize</span>(data));</span><br><span class="line">	<span class="built_in">prefetchw</span>(data + size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only clear those fields we need to clear, not those that we will</span></span><br><span class="line"><span class="comment">	 * actually initialise below. Hence, don&#x27;t put any more fields after</span></span><br><span class="line"><span class="comment">	 * the tail pointer in struct sk_buff!</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(skb, <span class="number">0</span>, <span class="built_in">offsetof</span>(<span class="keyword">struct</span> sk_buff, tail));</span><br><span class="line">	<span class="comment">/* Account for allocated memory : skb + skb-&gt;head */</span></span><br><span class="line">	skb-&gt;truesize = <span class="built_in">SKB_TRUESIZE</span>(size);</span><br><span class="line">	skb-&gt;pfmemalloc = pfmemalloc;</span><br><span class="line">	<span class="built_in">atomic_set</span>(&amp;skb-&gt;users, <span class="number">1</span>);</span><br><span class="line">	skb-&gt;head = data;</span><br><span class="line">	skb-&gt;data = data;</span><br><span class="line">	<span class="built_in">skb_reset_tail_pointer</span>(skb);</span><br><span class="line">	skb-&gt;end = skb-&gt;tail + size;</span><br><span class="line">	skb-&gt;mac_header = (<span class="built_in">typeof</span>(skb-&gt;mac_header))~<span class="number">0U</span>;</span><br><span class="line">	skb-&gt;transport_header = (<span class="built_in">typeof</span>(skb-&gt;transport_header))~<span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* make sure we initialize shinfo sequentially */</span></span><br><span class="line">	shinfo = <span class="built_in">skb_shinfo</span>(skb);</span><br><span class="line">	<span class="built_in">memset</span>(shinfo, <span class="number">0</span>, <span class="built_in">offsetof</span>(<span class="keyword">struct</span> skb_shared_info, dataref));</span><br><span class="line">	<span class="built_in">atomic_set</span>(&amp;shinfo-&gt;dataref, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">kmemcheck_annotate_variable</span>(shinfo-&gt;destructor_arg);</span><br><span class="line">    <span class="comment">//置克隆相关位</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SKB_ALLOC_FCLONE) &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">sk_buff_fclones</span> *fclones;</span><br><span class="line"></span><br><span class="line">		fclones = <span class="built_in">container_of</span>(skb, <span class="keyword">struct</span> sk_buff_fclones, skb1);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">kmemcheck_annotate_bitfield</span>(&amp;fclones-&gt;skb2, flags1);</span><br><span class="line">		skb-&gt;fclone = SKB_FCLONE_ORIG;</span><br><span class="line">		<span class="built_in">atomic_set</span>(&amp;fclones-&gt;fclone_ref, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		fclones-&gt;skb2.fclone = SKB_FCLONE_CLONE;</span><br><span class="line">		fclones-&gt;skb2.pfmemalloc = pfmemalloc;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> skb;</span><br><span class="line">nodata:</span><br><span class="line">	<span class="built_in">kmem_cache_free</span>(cache, skb);</span><br><span class="line">	skb = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(__alloc_skb);</span><br></pre></td></tr></table></figure>
<p>注意：__alloc_skb通常不被直接调用，而是封装调用，被封装在__netdev_alloc_skb(),alloc_skb(),alloc_skb_fclone()等；<br>dev_alloc_skb()也是一个缓存区分配函数，也是返回sk_buff*,通常在设备驱动中断上下文中，是一个alloc_skb()的封装函数，因为在中断处理函数中被调用，所以要求<br>原子操作(GFP_ATOMIC),4.8版本已经变了，封装的是别的函数，但是类似；</p>
<h4 id="如何释放SKB"><a href="#如何释放SKB" class="headerlink" title="如何释放SKB"></a>如何释放SKB</h4><p>dev_kfree_skb()和kfree_skb()都可以用来释放skb，把它返回给高速缓存；dev_kfree_skb()只是简单的封装kfree_skb();<br>调用时只是简单的递减skb-&gt;users的值，直到减完为0才真的释放内存；<br>具体见skbuff.h&#x2F;skbuff.c</p>
<h4 id="数据预留和对齐"><a href="#数据预留和对齐" class="headerlink" title="数据预留和对齐"></a>数据预留和对齐</h4><p>主要是通过skb_reserve(),skb_put,skb_push,skb_pull,等函数，对数据缓存区相关指针进行更新来做预留空间的操作；<br>具体怎么移动，要看是接收方向还是发送方向：</p>
<ol>
<li>skb_reserve()<br>skb_reserve()通常用来在数据缓存区头部预留一定的空间，比如插入协议首部或者在某个边界上对齐，而预留操作主要是移动data和tail指针；<br>注意只能用于空的skb，所以通常在分配后就会调用该函数；此时tail和data一同指向数据区的起始位置；<br>例如：某个以太网设备驱动接收函数在分配skb后，在向skb缓存区填充数据前，会通过skb_reserve(skb,2)来预留两个字节，因为以太网首部是14B,加了后正好16B对齐；此时是data指针往下移动两个字节；<br>当数据从上往下传递时，则每层将skb-&gt;data指针往上移动，然后复制本层首部，更新len;</li>
<li>skb_push()<br>在数据缓存区前头增加一块数据。也是只移动data和tail指针，和reserve类似</li>
<li>skb_put()<br>修改指向末尾的tail指针，使之向下移动len字节，然后更新len</li>
<li>skb_pull()<br>data指针向下移动；从而在数据区首部忽略len字节长度，用于收到包后往上传递忽略首部；<h4 id="克隆和复制SKB"><a href="#克隆和复制SKB" class="headerlink" title="克隆和复制SKB"></a>克隆和复制SKB</h4></li>
<li>skb_clone() 用来克隆skb，克隆时只复制skb描述符，而对数据缓存区则，引用计数+1；</li>
<li>pskb_copy() 当一个函数不仅要修改skb描述符，还要修改数据缓存区的时候，就需要同时复制数据缓存区；如果要修改的数据在head-end之间，就可以用这个函数，<br>不然若还要修改聚合分散IO中的数据，则用skb_copy()做完全的拷贝；</li>
</ol>
<h4 id="SKB链表的管理函数"><a href="#SKB链表的管理函数" class="headerlink" title="SKB链表的管理函数"></a>SKB链表的管理函数</h4><p>在skb链表操作中，为了防止被中断，则必须先获得自旋锁；然后才能访问队列中的元素；<br>skb_queue_head_init() :初始化skb链表头结点，创建一个空的skb链表；<br>skb_queue_head()&#x2F;skb_queue_tail(),加入队列头&#x2F;尾部，<br>skb_dequeue和skb_dequeue_tail，从首部和尾部取下一个skb;<br>skb_queue_purge() ,清空skb链表；<br>skb_queue_walk() 循环遍历skb链表中每个元素的宏；</p>
<h4 id="添加和删除尾部数据"><a href="#添加和删除尾部数据" class="headerlink" title="添加和删除尾部数据"></a>添加和删除尾部数据</h4><p>注意这里指的尾部数据，是data指向数据的结尾，而tail指向的是结尾的空间部分，一般是空的；<br>skb_add_data() tail指针下移，data尾部增加用户空间传递的数据，len加加；<br>skb_trim()和上面相反；<br>pskb_trim() 也处理到聚合分散iO;</p>
<h4 id="拆分数据"><a href="#拆分数据" class="headerlink" title="拆分数据"></a>拆分数据</h4><p>就是把一个skb拆成两个skb:<br>skb_split();分两种情况，一种是拆分的len小于线性缓存区长(即不包含聚合分散IO的)，另一种是大于，即分拆点在聚合分散IO中的某个位置；</p>
<h4 id="重新分配SKB的线性数据区；"><a href="#重新分配SKB的线性数据区；" class="headerlink" title="重新分配SKB的线性数据区；"></a>重新分配SKB的线性数据区；</h4><p>pskb_expand_head(),可以理解为realloc,就是扩展空间，将原数据复制过去；</p>
<h4 id="其他函数；"><a href="#其他函数；" class="headerlink" title="其他函数；"></a>其他函数；</h4><p>pskb_may_pull: 检测skb中的数据是否有指定长度<br>skb_queue_empty:检测skb队列是否为空<br>skb_realloc_headroom: 根据指定的skb得到一个新的skb,并确保新的skb存在指定的headroom空间；<br>skb_get() :引用并返回一个skb;<br>skb_shared() :检测指定的skb是否被多次引用；<br>skb_share_check():检测并返回skb,当被检测的skb被引用多次时，则克隆此skb,并返回克隆得到的skb;<br>skb_unshare():检测并返回skb,当被检查的skb被克隆时，则复制此skb,并返回复制得到的skb;<br>skb_orphan(): 使得此skb不属于任何传输控制块；<br>skb_cow(): 确保skb存在指定的head空间，若不足，则会重新分配<br>skb_pagelen(): 获得skb中线性数据区和SG类型聚合分散io分片中的数据的长度；</p>
<h4 id="关于虚拟设备和物理设备："><a href="#关于虚拟设备和物理设备：" class="headerlink" title="关于虚拟设备和物理设备："></a>关于虚拟设备和物理设备：</h4><p>linux支持多种形式的虚拟网络设备，并通过一个虚拟网络设备驱动管理。当这个虚拟设备被使用时，dev指针指向该虚拟设备的net_device结构。<br>在输出时，虚拟设备驱动会在一组设备中选择其中的某个合适的设备，并将dev指针修改为指向这个设备的net_device结构；<br>在输入时，当原始网络设备收到报文后，根据某种算法选择某个合适的虚拟网络设备，并将dev指针修改为指向这个虚拟设备的net_device结构。<br>因此，在某些情况下，指向传输设备的指针会在包处理过程中改变；</p>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_code</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_ARP</title>
    <url>/2018/05/28/tcpip-ARP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h3><h4 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h4><ul>
<li>ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信；</li>
<li>在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：<br>端设备手机pc等–&gt;(交换机)路由器—&gt;下一个路由器—&gt;下一个终端设备  <span id="more"></span><br>端设备默认路由到网关–&gt;网关收到包后，将源地址改为网关的外网地址—&gt;下一个路由–&gt;….-&gt;设备地址为目的地址时，接收而不转发</li>
<li>考虑一个问题：在上述的网络上发送时，如pc发给路由器时，只知道它的ip地址，怎么发给它：<br>即端到端的发送：是借助设备唯一的mac地址来发送的<br>在有线网中。利用了交换机的端口和mac地址关系，转发<br>在wifi中，能接收到所有的包，但是会在驱动中将mac目的地址非本地的包丢弃，除非开启了混杂监听模式</li>
<li>但是路由器怎么知道设备如手机的mac地址呢？<br>通过arp协议来获取，arp是依赖mac和ip的”映射”</li>
<li>tcpip卷1中4.2举了一个完整的例子，可以去看<h4 id="ARP协议的交互过程"><a href="#ARP协议的交互过程" class="headerlink" title="ARP协议的交互过程"></a>ARP协议的交互过程</h4></li>
<li>基本的交互方式：<br>例如ping网关：<br>station  —ARP request—-&gt;   AP  ARP请求，广播帧<br>station  &lt;—ARP response —  AP  ARP应答 ,单播帧<br>通过上述的方式，station得到了AP的mac地址，之后将AP的MAC地址存在缓存中，在下次数据包等包的时候就可以将该mac地址填在mac头中，即知道了AP的地址后，包就可以顺利的被AP接收了</li>
<li>AP(路由器)也会主动的向station发送arp request，当它不知道station的mac地址（或缓存过期），例如，AP收到一个外网的包，要转发给对应192.168.0.4的staton,但是没有他的mac地址，或者过期了或者其他情况，则向该station发出arp请求。从而得打station的mac地址</li>
<li>什么时候会触发arp请求？<br>1.在ping的时候<br>2.在发送tcp，ip包的时候<br>3.在缓存过期时主动发出，这个由arp状态机中实现<h4 id="ARP代理和免费ARP"><a href="#ARP代理和免费ARP" class="headerlink" title="ARP代理和免费ARP"></a>ARP代理和免费ARP</h4></li>
<li>当我们通过ping百度，或者想访问百度的时候，怎么在mac头中填写目的mac地址呢？即怎么找到百度?（另一个网络)</li>
<li>是通过在mac头目的mac地址填写网关的mac地址实现的，借助w网关的来帮我们寻找，这个叫做ARP代理,其实欺骗了主机</li>
<li>tcpip卷对此有较详细解说4.6</li>
<li>免费ARP是用于检测是否周围有使用相同的ip地址的设备，即通过ping自己，寻找有自己的ip的主机<h4 id="ARP协议的包封装格式和抓包分析"><a href="#ARP协议的包封装格式和抓包分析" class="headerlink" title="ARP协议的包封装格式和抓包分析"></a>ARP协议的包封装格式和抓包分析</h4></li>
<li>分组格式：  ()为字节数<br>mac头：以太网目的地址(6) mac源地址(6) 帧类型(2)(0x0806)<br>28byte arp帧：硬件类型(2)|协议类型(2)|硬件地址长度(1)|协议地址长度(1)|op(请求或应答或rarp 2)|发送端mac地址(6)|发送端ip(4)|接收端mac地址(6)|接收端ip(4)  </li>
<li>请求广播帧：目的mac地址为全1，电缆上所有的以太网接口都要接收广播帧,硬件类型为1表示以太网地址，协议类型为要映射的协议地址类型0x0800,表示为ip地址，op（arp请求为1，答应为2，rarp请求为3，rarp答应为4）</li>
<li>arp填充：以太网帧最小值为60，mac头14，所以&#x3D;46，要填充：46-28&#x3D;18个字节</li>
<li>arp抓包，可以用wireshark,Omnipeek - Savvius,tcpdump,或者自己写一个程序来抓～<br> tcpdump : sudo tcpdump -vv arp   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> tcpdump: listening on wlp2s0, link-type <span class="title function_">EN10MB</span> <span class="params">(Ethernet)</span>, capture size 262144 bytes</span><br><span class="line">21:51:21.134575 ARP, <span class="title function_">Ethernet</span> <span class="params">(len <span class="number">6</span>)</span>, <span class="title function_">IPv4</span> <span class="params">(len <span class="number">4</span>)</span>, Request who-has 192.168.0.101 tell 192.168.0.1, length 28 <span class="comment">//ap ask me</span></span><br><span class="line">21:51:21.135404 ARP, <span class="title function_">Ethernet</span> <span class="params">(len <span class="number">6</span>)</span>, <span class="title function_">IPv4</span> <span class="params">(len <span class="number">4</span>)</span>, Request who-has 192.168.0.110 tell 192.168.0.1, length 28</span><br><span class="line">21:51:21.135413 ARP, <span class="title function_">Ethernet</span> <span class="params">(len <span class="number">6</span>)</span>, <span class="title function_">IPv4</span> <span class="params">(len <span class="number">4</span>)</span>, Reply 192.168.0.110 is-at 48:5a:b6:6e:c9:5<span class="title function_">f</span> <span class="params">(oui Unknown)</span>, length 28<span class="comment">// i reply ap</span></span><br><span class="line">21:51:32.081916 ARP, <span class="title function_">Ethernet</span> <span class="params">(len <span class="number">6</span>)</span>, <span class="title function_">IPv4</span> <span class="params">(len <span class="number">4</span>)</span>, Request who-has 192.168.0.106 tell 192.168.0.1, length 28 <span class="comment">//ask other</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">01</span>:<span class="number">27.149947</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.107</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span></span><br><span class="line">	<span class="number">0x0000</span>:  <span class="number">0001</span> <span class="number">0800</span> <span class="number">0604</span> <span class="number">0001</span> <span class="number">206b</span> e70f <span class="number">1b</span>42 c0a8  .........k...B..</span><br><span class="line">	<span class="number">0x0010</span>:  <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> c0a8 <span class="number">006b</span>            ...........k</span><br><span class="line">    </span><br><span class="line">    <span class="number">22</span>:<span class="number">04</span>:<span class="number">17.114593</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Reply <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> is-at <span class="number">48</span>:<span class="number">5</span>a:b6:<span class="number">6</span>e:c9:<span class="number">5f</span> (oui Unknown), length <span class="number">28</span></span><br><span class="line">	<span class="number">0x0000</span>:  <span class="number">0001</span> <span class="number">0800</span> <span class="number">0604</span> <span class="number">0002</span> <span class="number">485</span>a b66e c95f c0a8  ........HZ.n._..</span><br><span class="line">	<span class="number">0x0010</span>:  <span class="number">006</span>e <span class="number">206b</span> e70f <span class="number">1b</span>42 c0a8 <span class="number">0001</span>            .n.k...B....</span><br></pre></td></tr></table></figure>

<h4 id="ARP协议的常用命令和调试分析"><a href="#ARP协议的常用命令和调试分析" class="headerlink" title="ARP协议的常用命令和调试分析"></a>ARP协议的常用命令和调试分析</h4><ul>
<li>查看ARP缓存：即现在保存的arp映射表:  <figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">arp -<span class="keyword">a</span></span><br><span class="line">? (<span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span>) <span class="keyword">at</span> <span class="number">4</span>c:<span class="number">32</span>:<span class="number">75</span>:<span class="number">3</span><span class="keyword">a</span>:<span class="number">09</span>:b3 [ether] <span class="keyword">on</span> <span class="title">wlp2s0</span></span><br><span class="line">? (<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>) <span class="keyword">at</span> <span class="number">20</span>:<span class="number">6</span>b:e7:<span class="number">0</span>f:<span class="number">1</span>b:<span class="number">42</span> [ether] <span class="keyword">on</span> <span class="title">wlp2s0</span></span><br><span class="line">? (<span class="number">192.168</span><span class="number">.0</span><span class="number">.108</span>) <span class="keyword">at</span> <span class="number">94</span>:d0:<span class="number">29</span>:<span class="number">9</span>d:<span class="number">74</span>:dd [ether] <span class="keyword">on</span> <span class="title">wlp2s0</span></span><br><span class="line">? (<span class="number">192.168</span><span class="number">.0</span><span class="number">.107</span>) <span class="keyword">at</span> <span class="number">94</span>:<span class="number">65</span>:<span class="number">2</span>d:ab:<span class="number">88</span>:<span class="number">8</span>b [ether] <span class="keyword">on</span> <span class="title">wlp2s0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">arp</span> </span><br><span class="line"><span class="attribute">Address</span>                  HWtype  HWaddress           Flags Mask            Iface</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">101</span>            ether   <span class="number">4</span>c:<span class="number">32</span>:<span class="number">75</span>:<span class="number">3</span>a:<span class="number">09</span>:b3   C                     wlp2s0</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">1</span>              ether   <span class="number">20</span>:<span class="number">6</span>b:e7:<span class="number">0</span>f:<span class="number">1</span>b:<span class="number">42</span>   C                     wlp2s0</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ip neigh</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span> dev wlp2s0 lladdr <span class="number">4</span>c:<span class="number">32</span>:<span class="number">75</span>:<span class="number">3</span>a:<span class="number">09</span>:b3 STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> dev wlp2s0 lladdr <span class="number">20</span>:<span class="number">6b</span>:e7:<span class="number">0f</span>:<span class="number">1b</span>:<span class="number">42</span> STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.108</span> dev wlp2s0 lladdr <span class="number">94</span>:d0:<span class="number">29</span>:<span class="number">9</span>d:<span class="number">74</span>:dd STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.107</span> dev wlp2s0 lladdr <span class="number">94</span>:<span class="number">65</span>:<span class="number">2</span>d:ab:<span class="number">88</span>:<span class="number">8b</span> STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.104</span> dev wlp2s0 lladdr e4:<span class="number">9</span>a:dc:b0:a5:<span class="number">36</span> STALE</span><br></pre></td></tr></table></figure></li>
<li>arping命令：<br><a href="http://man.linuxde.net/arping">http://man.linuxde.net/arping</a></li>
<li>arp 命令<br>man arp 包括删除arp表项等，有问题，找男人~<h4 id="ARP协议内核状态机"><a href="#ARP协议内核状态机" class="headerlink" title="ARP协议内核状态机"></a>ARP协议内核状态机</h4></li>
<li>对不存在的主机，arp请求的超时机制  </li>
<li>arp缓存和老化时间：<br><a href="http://www.jb51.net/LINUXjishu/65693.html%EF%BC%9A">http://www.jb51.net/LINUXjishu/65693.html：</a><br>改变老化时间：在Linux上如果你想设置你的ARP缓存老化时间，那么执行sysctl -w net.ipv4.neigh.ethX&#x3D;Y即<h4 id="ARP协议的编程"><a href="#ARP协议的编程" class="headerlink" title="ARP协议的编程"></a>ARP协议的编程</h4></li>
<li>在PF_PACKET中发出ARP包</li>
<li>直接贴例子，具体可以看博客的PF_PACKET文章：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取硬件网卡的相应信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="type">char</span> *name , <span class="type">char</span> *MAC_addr , <span class="keyword">struct</span> in_addr * IP_addr)</span></span>;</span><br><span class="line"><span class="comment">//arp包的结构定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ARP_PACKET</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">//以太网首部</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> dest_mac[<span class="number">6</span>]; <span class="comment">//6字节</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> sorce_mac[<span class="number">6</span>];<span class="comment">//6字节</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> type;       <span class="comment">//2字节</span></span><br><span class="line">  <span class="comment">//arp——内容</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> hw_type;   <span class="comment">//2字节：硬件地址类型     0x0001 表示mac地址</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> pro_type;  <span class="comment">//2字节：软件地址类型    0x0806 表示IPV4地址</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> hw_len;     <span class="comment">//1字节：硬件地址长度  </span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> pro_len;    <span class="comment">//1字节：软件地址长度</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> op;        <span class="comment">//2字节：操作类型           0x0001表示ARP请求；0x0002表示ARP应答</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> from_mac[<span class="number">6</span>];<span class="comment">//6字节</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> from_ip[<span class="number">4</span>]; <span class="comment">//4字节</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> to_mac[<span class="number">6</span>];  <span class="comment">//6字节</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> to_ip[<span class="number">4</span>];   <span class="comment">//4字节</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> padding[<span class="number">18</span>];<span class="comment">//18字节：填充字节，因为以太网数据最少要46字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> fd = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> MAC_ADDR[<span class="number">6</span>];</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">in_addr</span> IP_ADDR;<span class="comment">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">ARP_PACKET</span> arp_pk=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_ll</span> eth_info;<span class="comment">//结构体的定义//在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class="line"> <span class="comment">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class="line"> <span class="built_in">GetEthInfor</span>(<span class="string">&quot;wlp2s0&quot;</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class="line">   <span class="comment">/*printf(&quot;The MAC_addr is:&quot;);</span></span><br><span class="line"><span class="comment"> for(i =0 ;i&lt;6;i++)</span></span><br><span class="line"><span class="comment">    printf(&quot;%4X&quot;,MAC_ADDR[i]); </span></span><br><span class="line"><span class="comment"> printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;the IP is:%s\n&quot;,inet_ntoa(IP_ADDR));*/</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//第二步：填充ARP数据包的内容</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充以太网首部的目的mac地址</span></span><br><span class="line"> &#123;</span><br><span class="line">  arp_pk.dest_mac[i]=<span class="number">0XFF</span>;      </span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充以太网首部的源mac地址</span></span><br><span class="line"> &#123;</span><br><span class="line">  arp_pk.sorce_mac[i]=MAC_ADDR[i];</span><br><span class="line"> &#125;</span><br><span class="line">   arp_pk.type = <span class="built_in">htons</span>(<span class="number">0x0806</span>);    <span class="comment">//填充以太网首部的侦类型</span></span><br><span class="line">   arp_pk.hw_type = <span class="built_in">htons</span>(<span class="number">0x0001</span>); <span class="comment">//填充硬件地址类型：0x0001表示的是MAC地址</span></span><br><span class="line">   arp_pk.pro_type = <span class="built_in">htons</span>(<span class="number">0x0800</span>);<span class="comment">//填充协议地址类型：0x0800表示的是IP地址</span></span><br><span class="line">   arp_pk.hw_len = <span class="number">6</span>;              <span class="comment">//填充硬件地址长度</span></span><br><span class="line">   arp_pk.pro_len = <span class="number">4</span>;             <span class="comment">//填充协议地址长度</span></span><br><span class="line">   arp_pk.op = <span class="built_in">htons</span>(<span class="number">0x0001</span>);      <span class="comment">//填充操作类型：0x0001表示ARP请求</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充源mac地址</span></span><br><span class="line">   &#123;</span><br><span class="line">  arp_pk.from_mac[i]=MAC_ADDR[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">in_addr_t</span> ipaddr=<span class="built_in">inet_network</span>(<span class="built_in">inet_ntoa</span>(IP_ADDR));</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)                 <span class="comment">//填充源IP地址</span></span><br><span class="line">   &#123;</span><br><span class="line">  arp_pk.from_ip[i]=(<span class="type">unsigned</span> <span class="type">char</span>)ipaddr&amp;<span class="number">0xFF</span>;</span><br><span class="line">   ipaddr=ipaddr&gt;&gt;<span class="number">8</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;-%d-&quot;</span>,arp_pk.from_ip[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">/* arp_pk.from_ip[0]=192;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[1]=168;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[2]=199;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[3]=145;*/</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充欲获取的目的mac地址</span></span><br><span class="line">   &#123;</span><br><span class="line">    arp_pk.to_mac[i]=<span class="number">0X00</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   arp_pk.to_ip[<span class="number">0</span>]=<span class="number">0X0B</span>;        <span class="comment">//填充想要装换为MAC地址的IP地址。可以使用命令行参数来做</span></span><br><span class="line">   arp_pk.to_ip[<span class="number">1</span>]=<span class="number">0X40</span>;</span><br><span class="line">   arp_pk.to_ip[<span class="number">2</span>]=<span class="number">0X39</span>;</span><br><span class="line">   arp_pk.to_ip[<span class="number">3</span>]=<span class="number">0X0A</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第三步：填充sockaddr_ll eth_info结构</span></span><br><span class="line">    eth_info.sll_family = PF_PACKET;</span><br><span class="line"> eth_info.sll_ifindex = if_nametoindex(<span class="string">&quot;wlp2s0&quot;</span>);<span class="comment">//返回输入的接口名称的索引值</span></span><br><span class="line"> <span class="comment">//printf(&quot;number is:%d\n&quot;,eth_info.sll_family);</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第四步：创建原始套接字</span></span><br><span class="line"> fd = <span class="built_in">socket</span>(PF_PACKET,SOCK_RAW,<span class="built_in">htons</span>(ETH_P_ALL));  <span class="comment">//</span></span><br><span class="line"> <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;socket SOCK_RAW failed!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="comment">//第五步：发送ARP数据包</span></span><br><span class="line"> num = <span class="built_in">sendto</span>(fd , &amp;arp_pk , <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ARP_PACKET) , <span class="number">0</span> ,(<span class="keyword">struct</span> sockaddr*)(&amp;eth_info),<span class="built_in">sizeof</span>(eth_info));</span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sendto failed!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">        <span class="comment">//第六步：接受ARP应答</span></span><br><span class="line"> num = <span class="built_in">recvfrom</span>(fd , &amp;arp_pk , <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ARP_PACKET) ,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;rcvfrom failed!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I receive %d bytes!\n&quot;</span>,num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;the mac  is:&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%4X &quot;</span>,arp_pk.from_mac[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;op:%d\n&quot;</span>,arp_pk.op);</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d. &quot;</span>,arp_pk.to_ip[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">close</span>(fd);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="type">char</span> *name ,  <span class="type">char</span> *MAC_addr , <span class="keyword">struct</span> in_addr * IP_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">ifreq</span>  eth;  <span class="comment">//够结构用于存放最初多获取的接口信息</span></span><br><span class="line"><span class="comment">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class="line">   <span class="type">int</span> fd;             <span class="comment">//用于创建套接字</span></span><br><span class="line"> <span class="type">int</span> temp=<span class="number">0</span>;         <span class="comment">//用于验证接口调用</span></span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;            <span class="comment">//用于循环</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">strncpy</span>(eth.ifr_name,name,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ifreq)<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class="line"> <span class="comment">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class="line">    fd=<span class="built_in">socket</span>(AF_PACKET,SOCK_DGRAM,<span class="built_in">htons</span>(ETH_P_ALL));</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;socket failed!\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class="line">   temp = <span class="built_in">ioctl</span>(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class="line"> <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ioctl--get hardware addr failed!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="built_in">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class="number">6</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;The MAC_addr is:&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%4X&quot;</span>,(<span class="type">unsigned</span> <span class="type">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class="line">   temp = <span class="built_in">ioctl</span>(fd,SIOCGIFADDR,&amp;eth);</span><br><span class="line"> <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ioctl--get hardware addr failed!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="built_in">memcpy</span>(IP_addr ,&amp;(((<span class="keyword">struct</span> sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class="number">4</span>);</span><br><span class="line"> <span class="comment">//关闭套接口</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;got ipaddr:%s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(*IP_addr));</span><br><span class="line"><span class="comment">/*i=0;</span></span><br><span class="line"><span class="comment">printf(&quot;get the MAC_ADDR:\n&quot;);</span></span><br><span class="line"><span class="comment">for(i;i&lt;6;i++)</span></span><br><span class="line"><span class="comment">  printf(&quot;%.2X:&quot;,MAC_addr[i]&amp;0xFF);*/</span></span><br><span class="line">   <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步填充arp数据包的时候，填充的数据和类型根据需要进行。</span></span><br><span class="line"><span class="comment">//这里的arp数据包结构体是自己定义的，也可以是利用linux的相关结构：</span></span><br><span class="line"><span class="comment">/*eg:</span></span><br><span class="line"><span class="comment">typedef struct _tagARP_PACKET&#123;    </span></span><br><span class="line"><span class="comment">    struct ether_header  eh;    ///net/ethernet.h</span></span><br><span class="line"><span class="comment">    struct ether_arp arp;    </span></span><br><span class="line"><span class="comment">&#125;ARP_PACKET_OBJ, *ARP_PACKET_HANDLE; /netinet/if_ether.h;/net/if_arp.h</span></span><br><span class="line"><span class="comment">各个字段的填充见头文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三步：填充sockaddr_ll eth_info结构,关键是填充网络接口索引值，最直接的方法是上面的函数，</span></span><br><span class="line"><span class="comment">还有另外的方法:利用ioctl函数获取struct ifreq结构的信息，该结构放置了很多网络接口的相关信息*/</span></span><br><span class="line"><span class="comment">/*  struct sockaddr_ll&#123;</span></span><br><span class="line"><span class="comment">    unsigned short sll_family; //总是 AF_PACKET </span></span><br><span class="line"><span class="comment">    unsigned short sll_protocol; // 物理层的协议 </span></span><br><span class="line"><span class="comment">    int sll_ifindex; //接口号 </span></span><br><span class="line"><span class="comment">    unsigned short sll_hatype; // 报头类型 </span></span><br><span class="line"><span class="comment">    unsigned char sll_pkttype; // 分组类型 </span></span><br><span class="line"><span class="comment">    unsigned char sll_halen; // 地址长度 </span></span><br><span class="line"><span class="comment">    unsigned char sll_addr[8]; // 物理层地址 </span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">eg:</span></span><br><span class="line"><span class="comment">*     struct sockaddr_ll peer_addr;  </span></span><br><span class="line"><span class="comment">*    memset(&amp;peer_addr, 0, sizeof(peer_addr));    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_family = AF_PACKET;    </span></span><br><span class="line"><span class="comment">        struct ifreq req;  </span></span><br><span class="line"><span class="comment">    bzero(&amp;req, sizeof(struct ifreq));  </span></span><br><span class="line"><span class="comment">        strcpy(req.ifr_name, &quot;eth0&quot;);    </span></span><br><span class="line"><span class="comment">        if(ioctl(sockfd, SIOCGIFINDEX, &amp;req) != 0)  </span></span><br><span class="line"><span class="comment">        perror(&quot;ioctl()&quot;);    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_ifindex = req.ifr_ifindex;    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_protocol = htons(ETH_P_ARP);  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*第四步，创建套结字的时候，有以下的组合：更多见：man packet</span></span><br><span class="line"><span class="comment"> * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</span></span><br><span class="line"><span class="comment"> * 第二个参数： 2）套接字类型：</span></span><br><span class="line"><span class="comment">          SOCK_DGRAM----以太网头已经构造好了</span></span><br><span class="line"><span class="comment">          SOCK_RAW------自己构造以太头 </span></span><br><span class="line"><span class="comment">          * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字</span></span><br><span class="line"><span class="comment">          * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），</span></span><br><span class="line"><span class="comment">          * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，</span></span><br><span class="line"><span class="comment">          * 而发送时也无须用户添加头部字段。</span></span><br><span class="line"><span class="comment">   第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP</span></span><br><span class="line"><span class="comment">   * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：</span></span><br><span class="line"><span class="comment">   1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)</span></span><br><span class="line"><span class="comment">  和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)</span></span><br><span class="line"><span class="comment">    2)IEEE维护的注册以太网类型列表</span></span><br><span class="line"><span class="comment">     3）半官方的列表由IANA维护</span></span><br><span class="line"><span class="comment">      ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。</span></span><br><span class="line"><span class="comment">      0x88b5和0x88b6是保留以太网类型，供实验或私人使用。 </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">   <span class="comment">/*第五步发送和接收套接字的函数可以是read write操作套结字，也可以是上文的UDP无连接用的函数*/</span></span><br></pre></td></tr></table></figure>

<p>处理的时候可能需要获取网关的ip地址：</p>
<pre><code class="cpp">/*proc方法获取网关地址*/
void GetGateWayIP(uint8 *ip_addr)
&#123;
      char inf[100];
      FILE *file_fd;
      uint8 high=0,low=0,value;
      int i;
      file_fd = fopen(&quot;/proc/net/route&quot;,&quot;r&quot;);
      if(file_fd==NULL)
      &#123;
            printf(&quot;can not open /proc/net/route\n&quot;);
      &#125;
      else
     &#123;
             while(!feof(file_fd))
             &#123;
                     memset(inf,0,sizeof(inf));
                     fgets(inf,100,file_fd);
                     if(inf[5]==&#39;0&#39;&amp;&amp;inf[6]==&#39;0&#39;&amp;&amp;inf[7]==&#39;0&#39;&amp;&amp;inf[8]==&#39;0&#39;&amp;&amp;inf[9]==&#39;0&#39;&amp;&amp;inf[10]==&#39;0&#39;&amp;&amp;inf[11]==&#39;0&#39;&amp;&amp;inf[12]==&#39;0&#39;)
                     &#123;
                              for(i=20;i&gt;=14;i-=2)
                              &#123;
                                         if(inf[i]&gt;=65)
                                                 high = inf[i]-55;
                                         else
                                                 high = inf[i]-48;
                                         if(inf[i+1]&gt;=65)
                                                 low = inf[i+1]-55;
                                         else
                                                 low = inf[i+1]-48;
                                        value = high*16+low;
                                       ip_addr[10-i/2] = value;
                              &#125;
                              break;
                       &#125;
              &#125;
      &#125;
&#125;```
#### ARP攻击
+ ARP包可以直接发送给对端不经过路由器，有趣
在一个局域网中，客户端的几乎所有的包都是发往路由器的，这归结于默认路由设置，而在无线网，网卡其实可以接收所有数据，毕竟空气介质，所以，局域网中的设备可以直接通信  
实验：在文件全能王中开启wifi文件传输，和它在同一个局域网的sta能访问该地址，抓包，发现目的地址和源地址都为同一个局域网的不同ip,且不为路由器网关ip，证明其两个设备是可以直接通信的
+ 再来做一个实验：通过pf_packet  
1、在电脑A上写一个程序，mac目的地址为B,源地址为A,协议类型随机，数据随意，发送给B  
   同时在B端进行接收，过滤掉其他mac地址，看是否可以接收到，在连接ap和不连接ap的条件下  
2、在A和B设置静态ip地址，且不同网段，都不连接AP ,让A向B 发送ARP请求包，B接收到后回复arp响应包，接着做ping或其他操作，看是否能互相通信
+ 编程可以参考上述程序，改一下地址什么的就可以，或者参考其他：
http://www.freebuf.com/articles/system/5157.html
这篇文章讲的很具体，个人也喜欢这个网站，emm,实验过了，还可以，can also make your own program,具体程序不贴了  
+ arp欺骗的基本原理：   
在局域网中，设备A,B连接同一个路由器，他们之间可以直接相互通信，因此可以直接向对方发送arp包；   
设备A ,B都会定期和AP交互arp请求和回复，相互知道对方的mac地址，这样，就能给ap发送请求，ap也能知道回复给谁；    
arp欺骗的基本原理在于，如B是攻击方，则B向A发送ARP回复自己是AP ,即在ARP回复包中带上自己的mac地址，ap的ip地址；
同时向AP回复自己是A，即带上A的ip地址，自己的mac地址；   
这样A就会以为B是AP，就会把请求发给B ,同时AP以为B是A，会把回复传给B,但是同时得配置B的转发功能，  
echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot  
该博文中有一处错误，见评论
</code></pre>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_tc</title>
    <url>/2021/05/22/tcpip-tc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="流量控制概述"><a href="#流量控制概述" class="headerlink" title="流量控制概述"></a>流量控制概述</h3><p>linux下通过tc traffic control 框架及系列实现和工具来实现对出口，甚至入口流量的控制，所谓的控制，就是进行包延迟传输，<br>丢包，包损坏，带宽限制，针对某个ip规则进行限制等等，来达到模拟网络异常状况，包优先级传输，或者更多功能；<span id="more"></span><br>从手册上看：主要提供一下几种控制：<br>SHAPING: 平滑突发流量，如限制传输速率，小于有效带宽，作用于出口<br>       When traffic is shaped, its rate of transmission is under<br>       control. Shaping may be more than lowering the available<br>       bandwidth - it is also used to smooth out bursts in<br>       traffic for better network behaviour. Shaping occurs on<br>       egress.<br>SCHEDULING : 作用于出口，调度数据包的传输，比如优先级等<br>       By scheduling the transmission of packets it is possible<br>       to improve interactivity for traffic that needs it while<br>       still guaranteeing bandwidth to bulk transfers. Reordering<br>       is also called prioritizing, and happens only on egress.<br>POLICING： 作用于入口流量<br>       Whereas shaping deals with transmission of traffic,<br>       policing pertains to traffic arriving. Policing thus<br>       occurs on ingress.<br>DROPPING： 当流量超过阈值，丢弃数据包，作用于入口和出口；<br>       Traffic exceeding a set bandwidth may also be dropped<br>       forthwith, both on ingress and on egress.</p>
<!--more-->
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>ref:  <a href="https://netbeez.net/blog/how-to-use-the-linux-traffic-control/">https://netbeez.net/blog/how-to-use-the-linux-traffic-control/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">查看：当前只有默认的先入先出规则</span><br><span class="line">think@think-VirtualBox:~$ tc qdisc</span><br><span class="line">qdisc noqueue <span class="number">0</span>: dev lo root refcnt <span class="number">2</span> </span><br><span class="line">qdisc pfifo_fast <span class="number">0</span>: dev eth0 root refcnt <span class="number">2</span> bands <span class="number">3</span> priomap  <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">准备设置延迟：</span><br><span class="line">think@think-VirtualBox:~$ ping www.baidu.com</span><br><span class="line">PING www.baidu.<span class="built_in">com</span> (<span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">56</span> time=<span class="number">9.13</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">56</span> time=<span class="number">9.38</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">56</span> time=<span class="number">9.09</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">56</span> time=<span class="number">9.68</span> ms</span><br><span class="line">^C</span><br><span class="line">--- www.baidu.com ping statistics ---</span><br><span class="line"><span class="number">4</span> packets transmitted, <span class="number">4</span> received, <span class="number">0</span>% packet loss, time <span class="number">7048</span>ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">9.093</span>/<span class="number">9.324</span>/<span class="number">9.687</span>/<span class="number">0.256</span> ms</span><br><span class="line"></span><br><span class="line">添加延迟规则：</span><br><span class="line">think@think-VirtualBox:~$ sudo tc qdisc add dev eth0 root netem delay <span class="number">200</span>ms</span><br><span class="line"></span><br><span class="line">think@think-VirtualBox:~$ ping www.baidu.com</span><br><span class="line">PING www.baidu.<span class="built_in">com</span> (<span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">56</span> time=<span class="number">209</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">56</span> time=<span class="number">212</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">56</span> time=<span class="number">211</span> ms</span><br><span class="line"></span><br><span class="line">删除规则： sudo tc qdisc del dev eth0 root netem delay <span class="number">200</span>ms</span><br><span class="line">/ sudo tc qdisc del dev eth0 root </span><br><span class="line"></span><br><span class="line">设置丢包规则：</span><br><span class="line">think@think-VirtualBox:~$ sudo tc qdisc add dev eth0 root netem loss <span class="number">20</span>%</span><br><span class="line">[sudo] password <span class="keyword">for</span> think: </span><br><span class="line">think@think-VirtualBox:~$ ping www.baidu.com -c <span class="number">100</span></span><br><span class="line">PING www.baidu.<span class="built_in">com</span> (<span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">56</span> time=<span class="number">9.68</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">56</span> time=<span class="number">8.92</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">56</span> time=<span class="number">8.92</span> ms</span><br><span class="line">。。。</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>: icmp_seq=<span class="number">100</span> ttl=<span class="number">56</span> time=<span class="number">10.1</span> ms</span><br><span class="line"></span><br><span class="line">--- www.baidu.com ping statistics ---</span><br><span class="line"><span class="number">100</span> packets transmitted, <span class="number">80</span> received, <span class="number">20</span>% packet loss, time <span class="number">103846</span>ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">8.510</span>/<span class="number">9.537</span>/<span class="number">23.505</span>/<span class="number">1.655</span> ms</span><br><span class="line">删除规则：</span><br><span class="line">think@think-VirtualBox:~$ sudo tc qdisc del dev eth0 root netem loss <span class="number">20</span>%</span><br><span class="line"></span><br><span class="line">设置带宽限制规则：</span><br><span class="line">tc qdisc add dev eth0 root tbf rate <span class="number">1</span>mbit burst <span class="number">32</span>kbit latency <span class="number">400</span>ms</span><br><span class="line"></span><br><span class="line">tbf: use the token buffer filter to manipulate traffic rates</span><br><span class="line">rate: sustained maximum rate</span><br><span class="line">burst: maximum allowed burst</span><br><span class="line">latency: packets with higher latency get dropped</span><br><span class="line"></span><br><span class="line">通过iperf测试：</span><br><span class="line">iperf -c <span class="number">172.31</span><span class="number">.0</span><span class="number">.142</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Client connecting to <span class="number">172.31</span><span class="number">.0</span><span class="number">.142</span>, TCP port <span class="number">5001</span></span><br><span class="line">TCP window size: <span class="number">85.3</span> <span class="built_in">KByte</span> (<span class="keyword">default</span>)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">[  <span class="number">3</span>] local <span class="number">172.31</span><span class="number">.0</span><span class="number">.25</span> port <span class="number">40233</span> connected with <span class="number">172.31</span><span class="number">.0</span><span class="number">.142</span> port <span class="number">5001</span></span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  <span class="number">3</span>]  <span class="number">0.0</span><span class="number">-10.0</span> sec   <span class="number">113</span> MBytes  <span class="number">95.0</span> Mbits/sec ---&gt; <span class="number">1.1</span>Mbits/sec</span><br></pre></td></tr></table></figure>

<ul>
<li>指令解释：<br>qdisc: modify the scheduler (aka queuing discipline) 即实际的使用是依赖的qidsc机制<br>add: add a new rule 添加一个排队规则<br>dev eth0: rules will be applied on device eth0 排队规则作用对象一般是网卡<br>root: modify the outbound traffic scheduler (aka known as the egress qdisc) 修改出口流量调度程序<br>netem: use the network emulator to emulate a WAN property 使用wan网络模拟器<br>delay: the network property that is modified<br>200ms: introduce delay of 200 ms</li>
</ul>
<p>tc是系统如linux提供的用户层操作指令，这里用的是shell指令：<br>更多  <a href="https://man7.org/linux/man-pages/man8/tc.8.html">https://man7.org/linux/man-pages/man8/tc.8.html</a> </p>
<h3 id="流量控制的基本实现原理"><a href="#流量控制的基本实现原理" class="headerlink" title="流量控制的基本实现原理"></a>流量控制的基本实现原理</h3><p>在linux内核中，流量控制用Qos实现，实际上使用了qdisc队列；主要是出口队列；（egress)<br>在链路层，每个数据包通过邻居子系统后，或者说离开协议栈后，都会由dev_queue_xmit(dev.c)来进一步调用相关设备驱动的发送函数<br>来发送出去； 而qdisc队列，和相关的排队规则即作用在dev_queue_xmit之后，设备驱动发送函数之前；</p>
<h3 id="流量控制的实现和基本流程："><a href="#流量控制的实现和基本流程：" class="headerlink" title="流量控制的实现和基本流程："></a>流量控制的实现和基本流程：</h3><h4 id="相关代码："><a href="#相关代码：" class="headerlink" title="相关代码："></a>相关代码：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sch_generic.c</span><br><span class="line">sch_generic.h</span><br><span class="line">sch_api.c</span><br><span class="line">pkt_sched.h</span><br><span class="line">net/core/dev.c</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>在内核中的整体处理流程，及位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">net/core/dev.<span class="function">c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dev_queue_xmit</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span> --发送函数</span></span><br><span class="line"><span class="function">    <span class="comment">// 1 从设备中拿到设备下的qdisc结构，每个设备net_device结构都有</span></span></span><br><span class="line"><span class="function">  	txq </span>= <span class="built_in">netdev_pick_tx</span>(dev, skb, accel_priv);</span><br><span class="line">	q = <span class="built_in">rcu_dereference_bh</span>(txq-&gt;qdisc);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">trace_net_dev_queue</span>(skb);</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;enqueue) &#123;</span><br><span class="line">		rc = __dev_xmit_skb(skb, q, dev, txq);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//2 插入根排队规则中，并启动运行：</span></span><br><span class="line">	rc = q-&gt;<span class="built_in">enqueue</span>(skb, q, &amp;to_free) &amp; NET_XMIT_MASK; <span class="comment">//插入根排队规则</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">qdisc_run_begin</span>(q)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">unlikely</span>(contended)) &#123;</span><br><span class="line">				<span class="built_in">spin_unlock</span>(&amp;q-&gt;busylock);</span><br><span class="line">				contended = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			__qdisc_run(q);<span class="comment">//会走netif_schedule来调度数据包输出软中断 net_tx_action,然后在合适的时机，比如延迟200ms，发送数据包；</span></span><br><span class="line">			在调度前会检查网络设备的启动情况，以及是否已经在调度了；</span><br><span class="line">			<span class="type">void</span> __qdisc_run(<span class="keyword">struct</span> Qdisc *q)</span><br><span class="line">              &#123;</span><br><span class="line">              	<span class="type">int</span> quota = weight_p;</span><br><span class="line">              	<span class="type">int</span> packets;</span><br><span class="line">              </span><br><span class="line">              	<span class="keyword">while</span> (<span class="built_in">qdisc_restart</span>(q, &amp;packets)) &#123;</span><br><span class="line">              		<span class="comment">/*</span></span><br><span class="line"><span class="comment">              		 * Ordered by possible occurrence: Postpone processing if</span></span><br><span class="line"><span class="comment">              		 * 1. we&#x27;ve exceeded packet quota</span></span><br><span class="line"><span class="comment">              		 * 2. another process needs the CPU;</span></span><br><span class="line"><span class="comment">              		 */</span></span><br><span class="line">              		quota -= packets;</span><br><span class="line">              		<span class="keyword">if</span> (quota &lt;= <span class="number">0</span> || <span class="built_in">need_resched</span>()) &#123;</span><br><span class="line">              			__netif_schedule(q);</span><br><span class="line">              			<span class="keyword">break</span>;</span><br><span class="line">              		&#125;</span><br><span class="line">              	&#125;</span><br><span class="line">              </span><br><span class="line">              	<span class="built_in">qdisc_run_end</span>(q);</span><br><span class="line">              &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    dev.c:</span><br><span class="line">	net_tx_action:</span><br><span class="line">	<span class="built_in">smp_mb__before_atomic</span>();</span><br><span class="line">			<span class="built_in">clear_bit</span>(__QDISC_STATE_SCHED, &amp;q-&gt;state);</span><br><span class="line">			<span class="built_in">qdisc_run</span>(q);</span><br><span class="line">			<span class="built_in">spin_unlock</span>(root_lock);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3 qdisc_run/ __qdisc_run都会调用qdisc_restart，当可以发送时</span></span><br><span class="line">	<span class="comment">//这个restart函数，将包从根排队规则中取出，然后调用设备发送函数发送：</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">qdisc_restart</span><span class="params">(<span class="keyword">struct</span> Qdisc *q, <span class="type">int</span> *packets)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">struct</span> <span class="title class_">netdev_queue</span> *txq;</span><br><span class="line">    	<span class="keyword">struct</span> <span class="title class_">net_device</span> *dev;</span><br><span class="line">    	<span class="type">spinlock_t</span> *root_lock;</span><br><span class="line">    	<span class="keyword">struct</span> <span class="title class_">sk_buff</span> *skb;</span><br><span class="line">    	<span class="type">bool</span> validate;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">/* Dequeue packet */</span></span><br><span class="line">    	skb = <span class="built_in">dequeue_skb</span>(q, &amp;validate, packets);</span><br><span class="line">    	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(!skb))</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    	root_lock = <span class="built_in">qdisc_lock</span>(q);</span><br><span class="line">    	dev = <span class="built_in">qdisc_dev</span>(q);</span><br><span class="line">    	txq = <span class="built_in">skb_get_tx_queue</span>(dev, skb);</span><br><span class="line">         <span class="comment">//4 发送</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">sch_direct_xmit</span>(skb, q, dev, txq, root_lock, validate);----&gt;ops-&gt;<span class="built_in">ndo_start_xmit</span>(skb, dev);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="流量控制的结构："><a href="#流量控制的结构：" class="headerlink" title="流量控制的结构："></a>流量控制的结构：</h4><p>构成流量控制的基本元素有三种： 排队规则，类和过滤器</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="literal">----------</span><span class="comment">排队规则1:0</span><span class="literal">--------------</span>  <span class="literal">--</span>&gt;<span class="comment">根排队规则，提供两个外部接口，enqueue和dequeue</span></span><br><span class="line"><span class="literal">---</span><span class="comment">过滤器1</span><span class="literal">---</span><span class="comment">过滤器2</span><span class="literal">----</span><span class="comment">过滤器3</span><span class="literal">-----</span></span><br><span class="line"><span class="literal">---</span><span class="comment">|</span><span class="literal">-------------</span><span class="comment">|</span><span class="literal">------</span><span class="comment">|</span><span class="literal">---------</span></span><br><span class="line"><span class="literal">--</span><span class="comment">类1:1</span><span class="literal">---------</span><span class="comment">(类  1:2  )</span><span class="literal">-------</span></span><br><span class="line"><span class="literal">--</span><span class="comment">|</span><span class="literal">-----------------</span><span class="comment">|</span><span class="literal">-------------</span></span><br><span class="line"><span class="literal">--</span><span class="comment">排队规则2:0</span><span class="literal">-----</span><span class="comment">排队规则3:0</span><span class="literal">-------</span> <span class="literal">--</span>&gt;<span class="comment">内部规则</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>排队规则：<br>  在启用了流量控制的情况下，每个网络设备至少会配置一个排队规则；排队规则包括简单的fifo缓冲和令牌桶等，而精确的排队规则通常需要管理多个队列；<br>常见的排队规则由 fifo,令牌桶tbf(token bucket filter)等；</p>
</li>
<li><p>排队规则的分类：<br>排队规则至少有一个队列，可能简单，如fifo排队规则，也有复杂如令牌桶；通常排队规则分无类和有类两种，无类规则简单，内部不能包含可配置的子类及内部规则<br>而有类则可包含多个类，如上图，且每个类又可以包含一个排队规则，这里的排队规则叫内部规则，可以是有类和无类的；<br>无类规则不可被用户配置，而有类的可以；</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">   分为可分类的qdisc和不可分类的qdisc实现：</span><br><span class="line">不可分类：pfifo ,pfifo_fast,<span class="built_in">red</span>,sfq,tbf</span><br><span class="line">可分类：cbq,htb,prio</span><br></pre></td></tr></table></figure>
<p>如默认：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">qdisc pfifo_fast <span class="number">0</span>: dev eth0 root refcnt <span class="number">2</span> bands <span class="number">3</span> priomap  <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在tc指令中，如下的，其中结尾的 qdisc [qdisc specific parameters] 就是指定具体的排队规则类型；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">创建qdisc 规则</span><br><span class="line">tc [ OPTIONS ] qdisc [ add | change | replace | link | <span class="keyword">delete</span> ]</span><br><span class="line">       dev DEV [ parent qdisc-id | root ] [ handle qdisc-id ] [</span><br><span class="line">       ingress_block BLOCK_INDEX ] [ egress_block BLOCK_INDEX ] qdisc [</span><br><span class="line">       qdisc specific parameters ]</span><br><span class="line">eg:</span><br><span class="line"></span><br><span class="line">目前支持的qdisc: 无类的：</span><br><span class="line">The classless qdiscs are:</span><br><span class="line"></span><br><span class="line">       <span class="function">choke  <span class="title">CHOKe</span> <span class="params">(CHOose <span class="keyword">and</span> Keep <span class="keyword">for</span> responsive flows, CHOose <span class="keyword">and</span></span></span></span><br><span class="line"><span class="params"><span class="function">              Kill <span class="keyword">for</span> unresponsive flows)</span> is a classless qdisc designed</span></span><br><span class="line"><span class="function">              to both identify <span class="keyword">and</span> penalize flows that monopolize the</span></span><br><span class="line"><span class="function">              queue. CHOKe is a variation of RED, <span class="keyword">and</span> the configuration</span></span><br><span class="line"><span class="function">              is similar to RED.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       codel  <span class="title">CoDel</span> <span class="params">(pronounced <span class="string">&quot;coddle&quot;</span>)</span> is an adaptive &quot;no-knobs&quot;</span></span><br><span class="line"><span class="function">              active queue management <span class="title">algorithm</span> <span class="params">(AQM)</span> scheme that was</span></span><br><span class="line"><span class="function">              developed to address the shortcomings of RED <span class="keyword">and</span> its</span></span><br><span class="line"><span class="function">              variants.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       [p|b]fifo</span></span><br><span class="line"><span class="function">              Simplest usable qdisc, pure First In, First Out behaviour.</span></span><br><span class="line"><span class="function">              Limited in packets <span class="keyword">or</span> in bytes.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       fq     Fair Queue Scheduler realises TCP pacing <span class="keyword">and</span> scales to</span></span><br><span class="line"><span class="function">              millions of concurrent flows per qdisc.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       fq_codel</span></span><br><span class="line"><span class="function">              Fair Queuing Controlled Delay is queuing discipline that</span></span><br><span class="line"><span class="function">              combines Fair Queuing with the CoDel AQM scheme. FQ_Codel</span></span><br><span class="line"><span class="function">              uses a stochastic model to classify incoming packets into</span></span><br><span class="line"><span class="function">              different flows <span class="keyword">and</span> is used to provide a fair share of the</span></span><br><span class="line"><span class="function">              bandwidth to all the flows <span class="keyword">using</span> the queue. Each such flow</span></span><br><span class="line"><span class="function">              is managed by the CoDel queuing discipline. Reordering</span></span><br><span class="line"><span class="function">              within a flow is avoided since Codel internally uses a</span></span><br><span class="line"><span class="function">              FIFO queue.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       fq_pie FQ-<span class="title">PIE</span> <span class="params">(Flow Queuing with Proportional Integral controller</span></span></span><br><span class="line"><span class="params"><span class="function">              Enhanced)</span> is a queuing discipline that combines Flow</span></span><br><span class="line"><span class="function">              Queuing with the PIE AQM scheme. FQ-PIE uses a Jenkins</span></span><br><span class="line"><span class="function">              hash function to classify incoming packets into different</span></span><br><span class="line"><span class="function">              flows <span class="keyword">and</span> is used to provide a fair share of the bandwidth</span></span><br><span class="line"><span class="function">              to all the flows <span class="keyword">using</span> the qdisc. Each such flow is</span></span><br><span class="line"><span class="function">              managed by the PIE algorithm.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       gred   Generalized Random Early Detection combines multiple RED</span></span><br><span class="line"><span class="function">              queues in order to achieve multiple drop priorities. This</span></span><br><span class="line"><span class="function">              is required to realize Assured <span class="title">Forwarding</span> <span class="params">(RFC <span class="number">2597</span>)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       hhf    Heavy-Hitter Filter differentiates between small flows <span class="keyword">and</span></span></span><br><span class="line"><span class="function">              the opposite, heavy-hitters. The goal is to <span class="keyword">catch</span> the</span></span><br><span class="line"><span class="function">              heavy-hitters <span class="keyword">and</span> move them to a separate queue with less</span></span><br><span class="line"><span class="function">              priority so that bulk traffic does <span class="keyword">not</span> affect the latency</span></span><br><span class="line"><span class="function">              of critical traffic.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       ingress</span></span><br><span class="line"><span class="function">              This is a special qdisc as it applies to incoming traffic</span></span><br><span class="line"><span class="function">              on an interface, allowing <span class="keyword">for</span> it to be filtered <span class="keyword">and</span></span></span><br><span class="line"><span class="function">              policed.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       mqprio The Multiqueue Priority Qdisc is a simple queuing</span></span><br><span class="line"><span class="function">              discipline that allows mapping traffic flows to hardware</span></span><br><span class="line"><span class="function">              queue ranges <span class="keyword">using</span> priorities <span class="keyword">and</span> a configurable priority</span></span><br><span class="line"><span class="function">              to traffic <span class="keyword">class</span> mapping. A traffic <span class="keyword">class</span> in <span class="keyword">this</span> context</span></span><br><span class="line"><span class="function">              is a set of contiguous qdisc classes which map 1:<span class="number">1</span> to a</span></span><br><span class="line"><span class="function">              set of hardware exposed queues.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       multiq Multiqueue is a qdisc optimized for devices with multiple</span></span><br><span class="line"><span class="function">              Tx queues. It has been added for hardware that wishes to</span></span><br><span class="line"><span class="function">              avoid head-of-line blocking.  It will cycle though the</span></span><br><span class="line"><span class="function">              bands and verify that the hardware queue associated with</span></span><br><span class="line"><span class="function">              the band is not stopped prior to dequeuing a packet.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       netem  Network Emulator is an enhancement of the Linux traffic</span></span><br><span class="line"><span class="function">              control facilities that allow to add delay, packet loss,</span></span><br><span class="line"><span class="function">              duplication and more other characteristics to packets</span></span><br><span class="line"><span class="function">              outgoing from a selected network interface.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       pfifo_fast</span></span><br><span class="line"><span class="function">              Standard qdisc for <span class="string">&#x27;Advanced Router&#x27;</span> enabled kernels.</span></span><br><span class="line"><span class="function">              Consists of a three-band queue which honors Type of</span></span><br><span class="line"><span class="function">              Service flags, as well as the priority that may be</span></span><br><span class="line"><span class="function">              assigned to a packet.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       pie    Proportional Integral controller-Enhanced (PIE) is a</span></span><br><span class="line"><span class="function">              control theoretic active queue management scheme. It is</span></span><br><span class="line"><span class="function">              based on the proportional integral controller but aims to</span></span><br><span class="line"><span class="function">              control delay.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       red    Random Early Detection simulates physical congestion by</span></span><br><span class="line"><span class="function">              randomly dropping packets when nearing configured</span></span><br><span class="line"><span class="function">              bandwidth allocation. Well suited to very large bandwidth</span></span><br><span class="line"><span class="function">              applications.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       rr     Round-Robin qdisc with support for multiqueue network</span></span><br><span class="line"><span class="function">              devices. Removed from Linux since kernel version <span class="number">2.6</span><span class="number">.27</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       sfb    Stochastic Fair Blue is a classless qdisc to manage</span></span><br><span class="line"><span class="function">              congestion based on packet loss and link utilization</span></span><br><span class="line"><span class="function">              history while trying to prevent non-responsive flows (i.e.</span></span><br><span class="line"><span class="function">              flows that do not react to congestion marking or dropped</span></span><br><span class="line"><span class="function">              packets) from impacting performance of responsive flows.</span></span><br><span class="line"><span class="function">              Unlike RED, where the marking probability has to be</span></span><br><span class="line"><span class="function">              configured, BLUE tries to determine the ideal marking</span></span><br><span class="line"><span class="function">              probability automatically.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       sfq    Stochastic Fairness Queueing reorders queued traffic so</span></span><br><span class="line"><span class="function">              each <span class="string">&#x27;session&#x27;</span> gets to send a packet in turn.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       tbf    The Token Bucket Filter is suited for slowing traffic down</span></span><br><span class="line"><span class="function">              to a precisely configured rate. Scales well to large</span></span><br><span class="line"><span class="function">              bandwidths.</span></span><br><span class="line"><span class="function">无类的，在添加规则时需要注意：</span></span><br><span class="line"><span class="function">In the absence of classful qdiscs, classless qdiscs can only be</span></span><br><span class="line"><span class="function">       attached at the root of a device. Full syntax:</span></span><br><span class="line"><span class="function">       tc qdisc add dev DEV root QDISC QDISC-PARAMETERS</span></span><br><span class="line"><span class="function">To remove, issue</span></span><br><span class="line"><span class="function">       tc qdisc del dev DEV root</span></span><br><span class="line"><span class="function"> The pfifo_fast qdisc is the automatic default in the absence of a</span></span><br><span class="line"><span class="function">       configured qdisc.</span></span><br><span class="line"><span class="function">有类的：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       ATM    Map flows to virtual circuits of an underlying</span></span><br><span class="line"><span class="function">              asynchronous transfer mode device.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       CBQ    Class Based Queueing implements a rich linksharing</span></span><br><span class="line"><span class="function">              hierarchy of classes.  It contains shaping elements as</span></span><br><span class="line"><span class="function">              well as prioritizing capabilities. Shaping is performed</span></span><br><span class="line"><span class="function">              using link idle time calculations based on average packet</span></span><br><span class="line"><span class="function">              size and underlying link bandwidth. The latter may be ill-</span></span><br><span class="line"><span class="function">              defined for some interfaces.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       DRR    The Deficit Round Robin Scheduler is a more flexible</span></span><br><span class="line"><span class="function">              replacement for Stochastic Fairness Queuing. Unlike SFQ,</span></span><br><span class="line"><span class="function">              there are no built-in queues -- you need to add classes</span></span><br><span class="line"><span class="function">              and then set up filters to classify packets accordingly.</span></span><br><span class="line"><span class="function">              This can be useful e.g. for using RED qdiscs with</span></span><br><span class="line"><span class="function">              different settings for particular traffic. There is no</span></span><br><span class="line"><span class="function">              default class -- if a packet cannot be classified, it is</span></span><br><span class="line"><span class="function">              dropped.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       DSMARK Classify packets based on TOS field, change TOS field of</span></span><br><span class="line"><span class="function">              packets based on classification.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       ETS    The ETS qdisc is a queuing discipline that merges</span></span><br><span class="line"><span class="function">              functionality of PRIO and DRR qdiscs in one scheduler. ETS</span></span><br><span class="line"><span class="function">              makes it easy to configure a set of strict and bandwidth-</span></span><br><span class="line"><span class="function">              sharing bands to implement the transmission selection</span></span><br><span class="line"><span class="function">              described in <span class="number">802.1</span>Qaz.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       HFSC   Hierarchical Fair Service Curve guarantees precise</span></span><br><span class="line"><span class="function">              bandwidth and delay allocation for leaf classes and</span></span><br><span class="line"><span class="function">              allocates excess bandwidth fairly. Unlike HTB, it makes</span></span><br><span class="line"><span class="function">              use of packet dropping to achieve low delays which</span></span><br><span class="line"><span class="function">              interactive sessions benefit from.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       HTB    The Hierarchy Token Bucket implements a rich linksharing</span></span><br><span class="line"><span class="function">              hierarchy of classes with an emphasis on conforming to</span></span><br><span class="line"><span class="function">              existing practices. HTB facilitates guaranteeing bandwidth</span></span><br><span class="line"><span class="function">              to classes, while also allowing specification of upper</span></span><br><span class="line"><span class="function">              limits to inter-class sharing. It contains shaping</span></span><br><span class="line"><span class="function">              elements, based on TBF and can prioritize classes.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       PRIO   The PRIO qdisc is a non-shaping container for a</span></span><br><span class="line"><span class="function">              configurable number of classes which are dequeued in</span></span><br><span class="line"><span class="function">              order. This allows for easy prioritization of traffic,</span></span><br><span class="line"><span class="function">              where lower classes are only able to send if higher ones</span></span><br><span class="line"><span class="function">              have no packets available. To facilitate configuration,</span></span><br><span class="line"><span class="function">              Type Of Service bits are honored by default.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       QFQ    Quick Fair Queueing is an O(<span class="number">1</span>) scheduler that provides</span></span><br><span class="line"><span class="function">              near-optimal guarantees, and is the first to achieve that</span></span><br><span class="line"><span class="function">              goal with a constant cost also with respect to the number</span></span><br><span class="line"><span class="function">              of groups and the packet length. The QFQ algorithm has no</span></span><br><span class="line"><span class="function">              loops, and uses very simple instructions and data</span></span><br><span class="line"><span class="function">              structures that lend themselves very well to a hardware</span></span><br><span class="line"><span class="function">              implementation.</span></span><br><span class="line"><span class="function">			  </span></span><br><span class="line"><span class="function">#创建规则：</span></span><br><span class="line"><span class="function">tc qdisc add dev eth0 root handle <span class="number">1</span>:<span class="number">0</span> htb default <span class="number">1</span> </span></span><br><span class="line"><span class="function">#添加一个tbf规则，绑定到eth0上，命名为<span class="number">1</span>:<span class="number">0</span> ，默认归类为<span class="number">1</span></span></span><br><span class="line"><span class="function">#handle：为规则命名或指定某规则</span></span><br></pre></td></tr></table></figure>
<p>排队规则在内核中的表示结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">描述排队规则的结构：</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Qdisc</span> &#123;</span><br><span class="line">	<span class="built_in">int</span> 			(*enqueue)(<span class="keyword">struct</span> sk_buff *skb,   --上面提到的两个函数</span><br><span class="line">					   <span class="keyword">struct</span> Qdisc *sch,</span><br><span class="line">					   <span class="keyword">struct</span> sk_buff **to_free);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span> *	(*dequeue)(<span class="keyword">struct</span> Qdisc *sch);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">Qdisc_ops</span>	*ops;<span class="comment">//队列操作的接口，每个排队规则都必须实现该接口，如pfifo,tbf</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">qdisc_size_table</span>	__rcu *stab;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	list;</span><br><span class="line">	u32			handle; <span class="comment">//和tc的handle对应 句柄，排队规则，类和过滤器都有一个32位的句柄标识；</span></span><br><span class="line">	u32			parent; <span class="comment">//父句柄</span></span><br><span class="line">	<span class="type">void</span>			*u32_node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">netdev_queue</span>	*dev_queue;<span class="comment">//和netdevice挂钩</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff_head</span>	q;<span class="comment">//队列当前的数据包数</span></span><br><span class="line">    ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Qdisc_ops</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Qdisc_ops</span>	*next;<span class="comment">//用于链接已注册的各种排队规则的操作接口</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">Qdisc_class_ops</span>	*cl_ops;<span class="comment">//所在规则提供的类操作接口</span></span><br><span class="line">	<span class="type">char</span>			id[IFNAMSIZ];</span><br><span class="line">	<span class="type">int</span>			priv_size;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> 			(*enqueue)(<span class="keyword">struct</span> sk_buff *skb, <span class="comment">//将数据包加入排队规则的函数</span></span><br><span class="line">					   <span class="keyword">struct</span> Qdisc *sch,</span><br><span class="line">					   <span class="keyword">struct</span> sk_buff **to_free);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span> *	(*dequeue)(<span class="keyword">struct</span> Qdisc *);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span> *	(*peek)(<span class="keyword">struct</span> Qdisc *);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span>			(*init)(<span class="keyword">struct</span> Qdisc *, <span class="keyword">struct</span> nlattr *arg);<span class="comment">//排队规则的初始化</span></span><br><span class="line">	<span class="built_in">void</span>			(*reset)(<span class="keyword">struct</span> Qdisc *);</span><br><span class="line">	<span class="built_in">void</span>			(*destroy)(<span class="keyword">struct</span> Qdisc *);</span><br><span class="line">	<span class="built_in">int</span>			(*change)(<span class="keyword">struct</span> Qdisc *, <span class="keyword">struct</span> nlattr *arg);</span><br><span class="line">	<span class="built_in">void</span>			(*attach)(<span class="keyword">struct</span> Qdisc *);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span>			(*dump)(<span class="keyword">struct</span> Qdisc *, <span class="keyword">struct</span> sk_buff *);</span><br><span class="line">	<span class="built_in">int</span>			(*dump_stats)(<span class="keyword">struct</span> Qdisc *, <span class="keyword">struct</span> gnet_dump *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">module</span>		*owner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类：<br>类： 定义在排队规则中，报文通过过滤器，过滤，分配到不同的类中；排队规则可以没有类，如fifo先进先出，也可以有多个类<br>类中也可以有内部的排队规则，包被过滤器过滤为某个类后，在这个类中通过fifo的排队规则出去，或者其他规则，这里的规则就是内部规则；<br>创建类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> tc [ OPTIONS ] <span class="keyword">class</span> [ add | change | replace | <span class="keyword">delete</span> ] dev DEV</span><br><span class="line">       parent qdisc-id [ classid <span class="keyword">class</span>-id ] qdisc [ qdisc specific</span><br><span class="line">       parameters ]</span><br><span class="line">eg:</span><br><span class="line">#创建分类</span><br><span class="line">tc <span class="keyword">class</span> <span class="title class_">add</span> dev eth0 parent <span class="number">1</span>:<span class="number">0</span> classid <span class="number">1</span>:<span class="number">1</span> htb rate <span class="number">10</span>Mbit burst <span class="number">15</span>k</span><br><span class="line">#为eth0下的root队列<span class="number">1</span>:<span class="number">0</span>添加一个分类并命名为<span class="number">1</span>:<span class="number">1</span>，类型为htb，带宽为<span class="number">10</span>M</span><br><span class="line"><span class="meta">#rate: 是一个类保证得到的带宽值.如果有不只一个类,请保证所有子类总和是小于或等于父类.</span></span><br><span class="line"><span class="meta">#ceil: ceil是一个类最大能得到的带宽值.</span></span><br></pre></td></tr></table></figure>
<p>类的表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">在linux中，以xxx_class来表示，如htb:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">htb_class</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Qdisc_class_common</span> common;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">psched_ratecfg</span>	rate;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">psched_ratecfg</span>	ceil;</span><br><span class="line">	s64			buffer, cbuffer;<span class="comment">/* token bucket depth/rate */</span></span><br><span class="line">	s64			mbuffer;	<span class="comment">/* max wait time */</span></span><br><span class="line">	u32			prio;		<span class="comment">/* these two are used only by leaves... */</span></span><br><span class="line">	<span class="type">int</span>			quantum;	<span class="comment">/* but stored for parent-to-leaf return */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tcf_proto</span> __rcu	*filter_list;	<span class="comment">/* class attached filters */</span> 类的过滤器链</span><br><span class="line">	<span class="type">int</span>			filter_cnt;</span><br><span class="line">	<span class="type">int</span>			refcnt;		<span class="comment">/* usage count of this class */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>			level;		<span class="comment">/* our level (see above) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		children;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">htb_class</span>	*parent;	<span class="comment">/* parent class */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">gnet_stats_rate_est64</span> rate_est;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Written often fields</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">gnet_stats_basic_packed</span> bstats;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tc_htb_xstats</span>	xstats;	<span class="comment">/* our special stats */</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>过滤器<br>过滤器： 具体的过滤规则，用来分类；包含若干个匹配条件，如果符合条件的包，被分类到具体的类中；</p>
</li>
</ul>
<p>一个类至少有一个过滤器，可能有多个过滤器，<br>tc指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tc [ OPTIONS ] filter [ add | change | replace | <span class="keyword">delete</span> | get ]</span><br><span class="line">       dev DEV [ parent qdisc-id | root ] [ handle filter-id ] protocol</span><br><span class="line">       protocol prio priority filtertype [ filtertype specific</span><br><span class="line">       parameters ] flowid flow-id</span><br><span class="line">内核目前提供的过滤器有：</span><br><span class="line"> The available filters are:</span><br><span class="line"></span><br><span class="line">       basic  Filter packets based on an ematch expression. See</span><br><span class="line">              tc-<span class="built_in">ematch</span>(<span class="number">8</span>) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">       <span class="function">bpf    Filter packets <span class="title">using</span> <span class="params">(e)</span>BPF, see tc-<span class="title">bpf</span><span class="params">(<span class="number">8</span>)</span> <span class="keyword">for</span> details.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       cgroup Filter packets based on the control group of their</span></span><br><span class="line"><span class="function">              process. See tc-<span class="title">cgroup</span><span class="params">(<span class="number">8</span>)</span> <span class="keyword">for</span> details.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       flow, flower</span></span><br><span class="line"><span class="function">              Flow-based classifiers, filtering packets based on their</span></span><br><span class="line"><span class="function">              <span class="title">flow</span> <span class="params">(identified by selectable keys)</span>. See tc-<span class="title">flow</span><span class="params">(<span class="number">8</span>)</span> <span class="keyword">and</span></span></span><br><span class="line"><span class="function">              tc-<span class="title">flower</span><span class="params">(<span class="number">8</span>)</span> <span class="keyword">for</span> details.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       fw     Filter based on fwmark. Directly maps fwmark value to</span></span><br><span class="line"><span class="function">              traffic <span class="keyword">class</span>. See tc-<span class="title">fw</span><span class="params">(<span class="number">8</span>)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       route  Filter packets based on routing table. See tc-<span class="title">route</span><span class="params">(<span class="number">8</span>)</span> <span class="keyword">for</span></span></span><br><span class="line"><span class="function">              details.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       rsvp   Match Resource Reservation <span class="title">Protocol</span> <span class="params">(RSVP)</span> packets.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       tcindex</span></span><br><span class="line"><span class="function">              Filter packets based on traffic control index. See</span></span><br><span class="line"><span class="function">              tc-<span class="title">tcindex</span><span class="params">(<span class="number">8</span>)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       u32    Generic filtering on arbitrary packet data, assisted by</span></span><br><span class="line"><span class="function">              syntax to abstract common operations. See tc-<span class="title">u32</span><span class="params">(<span class="number">8</span>)</span> <span class="keyword">for</span></span></span><br><span class="line"><span class="function">              details.</span></span><br><span class="line"><span class="function">    matchall</span></span><br><span class="line"><span class="function">              Traffic control filter that matches every packet. See</span></span><br><span class="line"><span class="function">              tc-<span class="title">matchall</span><span class="params">(<span class="number">8</span>)</span> <span class="keyword">for</span> details.</span></span><br><span class="line"><span class="function">eg:</span></span><br><span class="line"><span class="function">#使用u32创建过滤器</span></span><br><span class="line"><span class="function">tc filter add dev eth0 protocol ip parent <span class="number">1</span>:<span class="number">0</span> prio <span class="number">1</span> u32 match ip sport <span class="number">22</span> flowid <span class="number">1</span>:<span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>在内核中的结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tcf_proto</span> &#123;</span><br><span class="line">	<span class="comment">/* Fast access part */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tcf_proto</span> __rcu	*next;<span class="comment">//将多个过滤器连接起来</span></span><br><span class="line">	<span class="type">void</span> __rcu		*root;</span><br><span class="line">	<span class="built_in">int</span>			(*classify)(<span class="keyword">struct</span> sk_buff *,</span><br><span class="line">					    <span class="type">const</span> <span class="keyword">struct</span> tcf_proto *,</span><br><span class="line">					    <span class="keyword">struct</span> tcf_result *); <span class="comment">//报文分类函数--&gt; tcf_proto_ops上</span></span><br><span class="line">	__be16			protocol;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* All the rest */</span></span><br><span class="line">	u32			prio;</span><br><span class="line">	u32			classid;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Qdisc</span>		*q;</span><br><span class="line">	<span class="type">void</span>			*data;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">tcf_proto_ops</span>	*ops;<span class="comment">//过滤器操作函数接口</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rcu_head</span>		rcu;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="qdisc的例子：-pfifo-ftb等"><a href="#qdisc的例子：-pfifo-ftb等" class="headerlink" title="qdisc的例子： pfifo ,ftb等"></a>qdisc的例子： pfifo ,ftb等</h3><p>通过fifo学习如何实现一个规则；<br>默认情况下是pfifo，这个通过dev_open挂到设备上；如果需要其他的，通过tc后-&gt;netlink再操作到dev结构等上；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Qdisc</span> noop_qdisc = &#123;</span><br><span class="line">	.enqueue	=	noop_enqueue,</span><br><span class="line">	.dequeue	=	noop_dequeue,</span><br><span class="line">	.flags		=	TCQ_F_BUILTIN,</span><br><span class="line">	.ops		=	&amp;noop_qdisc_ops,</span><br><span class="line">	.list		=	<span class="built_in">LIST_HEAD_INIT</span>(noop_qdisc.list),</span><br><span class="line">	.q.lock		=	__SPIN_LOCK_UNLOCKED(noop_qdisc.q.lock),</span><br><span class="line">	.dev_queue	=	&amp;noop_netdev_queue,</span><br><span class="line">	.running	=	<span class="built_in">SEQCNT_ZERO</span>(noop_qdisc.running),</span><br><span class="line">	.busylock	=	__SPIN_LOCK_UNLOCKED(noop_qdisc.busylock),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Qdisc_ops</span> pfifo_fast_ops __read_mostly = &#123;</span><br><span class="line">	.id		=	<span class="string">&quot;pfifo_fast&quot;</span>,</span><br><span class="line">	.priv_size	=	<span class="built_in">sizeof</span>(<span class="keyword">struct</span> pfifo_fast_priv),</span><br><span class="line">	.enqueue	=	pfifo_fast_enqueue,</span><br><span class="line">	.dequeue	=	pfifo_fast_dequeue,</span><br><span class="line">	.peek		=	pfifo_fast_peek,</span><br><span class="line">	.init		=	pfifo_fast_init,</span><br><span class="line">	.reset		=	pfifo_fast_reset,</span><br><span class="line">	.dump		=	pfifo_fast_dump,</span><br><span class="line">	.owner		=	THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="tc工具的netlink接口"><a href="#tc工具的netlink接口" class="headerlink" title="tc工具的netlink接口"></a>tc工具的netlink接口</h3><p>定义在sch_api.c，主要操作排队规则中的类和过滤器；<br>tc是通过netlink向内核通信，从而实现创建，修改qos等功能</p>
<p>本文只是给了一个流程和具体认知，通过本文来知道tc大致原理和框架，从而为进一步提供便利和查找依据；</p>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_tc</tag>
      </tags>
  </entry>
  <entry>
    <title>audio_flac</title>
    <url>/2022/03/26/audio-flac/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Flac"><a href="#Flac" class="headerlink" title="Flac:"></a>Flac:</h3><p>This is a detailed description of the FLAC format. There is also a companion document that describes FLAC-to-Ogg mapping.<br>For a user-oriented overview, see About the FLAC Format.<span id="more"></span></p>
<h4 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h4><ul>
<li>Acknowledgments</li>
<li>Scope</li>
<li>Architecture</li>
<li>Definitions</li>
<li>Blocking</li>
<li>Interchannel Decorrelation</li>
<li>Prediction</li>
<li>Residual Coding</li>
<li>Format</li>
<li>FLAC Subset</li>
<li>Specification<ul>
<li>STREAM<ul>
<li>METADATA_BLOCK<ul>
<li>METADATA_BLOCK_HEADER</li>
<li>METADATA_BLOCK_DATA<ul>
<li>METADATA_BLOCK_STREAMINFO</li>
<li>METADATA_BLOCK_PADDING</li>
<li>METADATA_BLOCK_APPLICATION</li>
<li>METADATA_BLOCK_SEEKTABLE<ul>
<li>SEEKPOINT</li>
</ul>
</li>
<li>METADATA_BLOCK_VORBIS_COMMENT</li>
<li>METADATA_BLOCK_CUESHEET<ul>
<li>CUESHEET_TRACK<ul>
<li>CUESHEET_TRACK_INDEX</li>
</ul>
</li>
</ul>
</li>
<li>METADATA_BLOCK_PICTURE</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>FRAME<ul>
<li>FRAME_HEADER</li>
<li>FRAME_FOOTER</li>
<li>SUBFRAME<ul>
<li>SUBFRAME_HEADER</li>
<li>SUBFRAME_CONSTANT</li>
<li>SUBFRAME_FIXED</li>
<li>SUBFRAME_LPC</li>
<li>SUBFRAME_VERBATIM<ul>
<li>RESIDUAL<ul>
<li>RESIDUAL_CODING_METHOD_PARTITIONED_RICE<ul>
<li>RICE_PARTITION</li>
</ul>
</li>
</ul>
</li>
<li>RESIDUAL_CODING_METHOD_PARTITIONED_RICE2<br>  + RICE2_PARTITION</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Acknowledgments"><a href="#Acknowledgments" class="headerlink" title="Acknowledgments"></a>Acknowledgments</h4><p>FLAC owes much to the many people who have advanced the audio compression field so freely. For instance:<br>FLAC 非常感谢许多人如此自由地推进音频压缩领域。例如：<br>A. J. Robinson for his work on Shorten; his paper is a good starting point on some of the basic methods used by FLAC. FLAC trivially extends and improves the fixed predictors, LPC coefficient quantization, and Rice coding used in Shorten.<br>A. J. Robinson 在 Shorten 方面的工作；他的论文是 FLAC 使用的一些基本方法的一个很好的起点。 FLAC 简单地扩展和改进了 Shorten 中使用的固定预测器、LPC 系数量化和 Rice 编码。<br>S. W. Golomb and Robert F. Rice; their universal codes are used by FLAC’s entropy coder.<br>S. W. Golomb 和 Robert F. Rice； FLAC 的熵编码器使用它们的通用代码。<br>N. Levinson and J. Durbin; the reference encoder uses an algorithm developed and refined by them for determining the LPC coefficients from the autocorrelation coefficients.<br>And of course, Claude Shannon<br>N. 莱文森和 J. 德宾；参考编码器使用由他们开发和改进的算法来根据自相关系数确定 LPC 系数。<br>当然，克劳德·香农</p>
<h4 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h4><p>It is a known fact that no algorithm can losslessly compress all possible input, so most compressors restrict themselves to a useful domain and try to work as well as possible within that domain. FLAC’s domain is audio data. Though it can losslessly code any input, only certain kinds of input will get smaller. FLAC exploits the fact that audio data typically has a high degree of sample-to-sample correlation.</p>
<p>众所周知没有算法能无损的压缩所有可能的输入，所以大多数压缩器把它们自己限制在一个有用的范围领域，并且尝试去在该领域工作的好。 FLAC的领域是音频数据。尽管它能无损编码任何输入，但是只有确定类型的输入才会更小。 FLAC 暴露的事实是，典型的音频有更高程度的 采样到采样的关联。</p>
<p>Within the audio domain, there are many possible subdomains. For example: low bitrate speech, high-bitrate multi-channel music, etc. FLAC itself does not target a specific subdomain but many of the default parameters of the reference encoder are tuned to CD-quality music data (i.e. 44.1kHz, 2 channel, 16 bits per sample). The effect of the encoding parameters on different kinds of audio data will be examined later.</p>
<p>在音频领域内，有很多可能的子领域。如： 低码率演讲，高码率多通道音乐等。<br>FLAC 本身并不针对特定的子域，但参考编码器的许多默认参数已调整为 CD 质量的音乐数据（即 44.1kHz、2 通道、每个样本 16 位）。稍后将检查编码参数对不同类型的音频数据的影响。</p>
<p>FLAC stands for Free Lossless Audio Codec: it is designed to reduce<br>   the amount of computer storage space needed to store digital audio<br>   signals without needing to remove information in doing so (i.e.<br>   lossless).  FLAC is free in the sense that its specification is open,<br>   its reference implementation is open-source and it is not encumbered<br>   by any known patent.<br>FLAC 代表免费无损音频编解码器：被设计用来减少存储数字音频所需的计算机存储空间量，无需删除信息即可发出信号。即无损。<br>FLAC是免费的，因为它的规范是开放的，它的参考实现是源码开放的，并且不被任何已知专利受累。</p>
<p>   FLAC is able to achieve lossless compression because samples in audio<br>   signals tend to be highly correlated with their close neighbors.  In<br>   contrast with general purpose compressors, which often use<br>   dictionaries, do run-length coding or exploit long-term repetition,<br>   FLAC removes redundancy solely in the very short term, looking back<br>   at most 32 samples.FLAC<br>   能够实现无损压缩，因为音频中的样本<br>信号往往与其近邻高度相关。在<br>与通常使用的通用压缩机相比<br>字典，进行游程编码或利用长期重复，<br>FLAC 仅在很短的时间内消除冗余，回顾过去<br>最多 32 个样本。</p>
<p>   The FLAC format is suited for pulse-code modulated (PCM) audio with 1<br>   to 8 channels, sample rates from 1 to 1048576 Hertz and bit depths<br>   between 4 and 32 bits.  Most tools for reading and writing the FLAC<br>   format have been optimized for CD-audio, which is PCM audio with 2<br>   channels, a sample rate of 44.1 kHz and a bit depth of 16 bits.<br>FLAC 格式适用于脉冲编码调制 (PCM) 音频，具有 1<br>到 8 个通道，采样率从 1 到 1048576 赫兹和位深度<br>4 到 32 位之间。大多数用于读写 FLAC 的工具<br>格式已针对 CD 音频进行了优化，这是 PCM 音频，带有 2<br>通道，采样率为 44.1 kHz，位深度为 16 位。</p>
<p>   Compared to other lossless (audio) coding formats, FLAC is a format<br>   with low complexity and can be coded to and from with little<br>   computing resources.  Decoding of FLAC has seen many independent<br>   implementations on many different platforms, and both encoding and<br>   decoding can be implemented without needing floating-point<br>   arithmetic.<br>与其他无损（音频）编码格式相比，FLAC 是一种格式<br>复杂度低，可以用很少的时间进行编码<br>计算资源。 FLAC 的解码已经看到许多独立的<br>许多不同平台上的实现，以及编码和<br>无需浮点数即可实现解码<br>算术。<br>   The coding methods provided by the FLAC format works best on PCM<br>   audio signals of which the samples have a signed representation and<br>   are centered around zero.  Audio signals in which samples have an<br>   unsigned representation must be transformed to a signed<br>   representation as described in this document in order to achieve<br>   reasonable compression.  The FLAC format is not suited to compress<br>   audio that is not PCM.  Pulse-density modulated audio, e.g.  DSD,<br>   cannot be compressed by FLAC.  </p>
<p>FLAC 格式提供的编码方法在 PCM 上效果最好<br>特别那些，样本具有带符号表示的音频信号和<br>以零为中心。音频信号，其中样本具有<br>无符号表示必须转换为有符号<br>本文档中描述的表示，以实现<br>合理压缩。 FLAC 格式不适合压缩<br>不是 PCM 的音频。脉冲密度调制音频，例如渠务署，<br>不能被 FLAC 压缩。  </p>
<h4 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h4><p>Similar to many audio coders, a FLAC encoder has the following stages:和许多音频编码器类似，一个FLAC编码器有如下阶段：<br>Blocking. The input is broken up into many contiguous blocks. With FLAC, the blocks may vary in size. The optimal size of the block is usually affected by many factors, including the sample rate, spectral characteristics over time, etc. Though FLAC allows the block size to vary within a stream, the reference encoder uses a fixed block size.<br>Blocking.<br>分段。 输入被分拆成多个连续的块。 用FLAC,则块可能是可变长的。 block的最佳长度通常被多种因素影响，包括sample rate，随时间变化的曲调特性等等。<br>尽管FLAC允许一个流内的block长度可变，参考编码器还是会使用一个固定的block size.</p>
<p>Interchannel Decorrelation. In the case of stereo streams, the encoder will create mid and side signals based on the average and difference (respectively) of the left and right channels. The encoder will then pass the best form of the signal to the next stage.</p>
<p>通道间去相关性。 在立体声流的例子下：编码器将根据左右声道的平均值和差值（分别）创建中音和侧音信号。然后编码器将信号的最佳形式传递到下一阶段。</p>
<p>Prediction. The block is passed through a prediction stage where the encoder tries to find a mathematical description (usually an approximate one) of the signal. This description is typically much smaller than the raw signal itself. Since the methods of prediction are known to both the encoder and decoder, only the parameters of the predictor need be included in the compressed stream. FLAC currently uses four different classes of predictors (described in the prediction section), but the format has reserved space for additional methods. FLAC allows the class of predictor to change from block to block, or even within the channels of a block.</p>
<p>预测：块被传递到一个预测阶段，在该阶段编码器尝试找到信号的数学描述（通常是近似描述）这种描述通常比原始信号本身小得多。由于编码器和解码器都知道预测方法，因此只需将预测器的参数包含在压缩流中。FLAC 当前使用四种不同类别的预测器（在预测部分中进行了描述），但该格式为其他方法保留了空间。 FLAC 允许预测器的类别在块之间变化，甚至在块的通道内变化。</p>
<p>Residual coding. If the predictor does not describe the signal exactly, the difference between the original signal and the predicted signal (called the error or residual signal) must be coded losslessy. If the predictor is effective, the residual signal will require fewer bits per sample than the original signal. FLAC currently uses only one method for encoding the residual (see the Residual coding section), but the format has reserved space for additional methods. FLAC allows the residual coding method to change from block to block, or even within the channels of a block.</p>
<p>残差编码：<br>      如果预测器不能准确描述信号，则必须对原始信号和预测信号（称为误差或残差信号）之间的差异进行无损编码。如果预测器有效，则残差信号每个样本所需的位数将比原始信号少。 FLAC 目前仅使用一种方法对残差进行编码（参见残差编码部分），但该格式为其他方法保留了空间。FLAC 允许残差编码方法从块到块改变，甚至在块的通道内改变。<br>In addition, FLAC specifies a metadata system, which allows arbitrary information about the stream to be included at the beginning of the stream.<br>此外，FLAC 指定了一个元数据系统，它允许在流的开头包含有关流的任意信息。<br>Definitions</p>
<p>Many terms like “block” and “frame” are used to mean different things in differenct encoding schemes. For example, a frame in MP3 corresponds to many samples across several channels, whereas an S&#x2F;PDIF frame represents just one sample for each channel. The definitions we use for FLAC follow. Note that when we talk about blocks and subblocks we are referring to the raw unencoded audio data that is the input to the encoder, and when we talk about frames and subframes, we are referring to the FLAC-encoded data.<br>许多术语如“块”和“帧”在不同的编码方案中用于表示不同的事物。例如，MP3 中的帧对应多个通道的多个样本，而 S&#x2F;PDIF 帧仅代表每个通道的一个样本。我们用于 FLAC 的定义如下。请注意，当我们谈论块和子块时，我们指的是作为编码器输入的原始未编码音频数据，而当我们谈论帧和子帧时，我们指的是 FLAC 编码的数据。<br>Block: One or more audio samples that span several channels.跨越多个通道的一个或多个音频样本。<br>Subblock: One or more audio samples within a channel. So a block contains one subblock for each channel, and all subblocks contain the same number of samples.一个通道内的一个或多个音频样本。因此一个块包含每个通道的一个子块，并且所有子块包含相同数量的样本。<br>Blocksize: The number of samples in any of a block’s subblocks. For example, a one second block sampled at 44.1KHz has a blocksize of 44100, regardless of the number of channels.块的任何子块中的样本数。例如，以 44.1KHz 采样的一秒块的块大小为 44100，与通道数无关。<br>Frame: A frame header plus one or more subframes.一个帧头加上一个或多个子帧。<br>Subframe: A subframe header plus one or more encoded samples from a given channel. All subframes within a frame will contain the same number of samples.子帧头加上来自给定通道的一个或多个编码样本。一个帧内的所有子帧将包含相同数量的样本。</p>
<p><em>Bit depth</em> or <em>bits per sample</em>: the number of bits used to<br>      contain each sample.  This MUST be the same for all subblocks in a<br>      block but MAY be different for different subframes in a frame<br>     because of interchannel decorrelation (#interchannel-<br>      decorrelation). 位深或每个采样的位数，这个在一个块中所有的子块的每个采样必须相同。但是在一个frame中的不同子frame可以不同；因为通道间的去相关性。</p>
<ul>
<li><p><em>Predictor</em>: a model used to predict samples in an audio signal<br>   based on past samples.  FLAC uses such predictors to remove<br>   redundancy in a signal in order to be able to compress it.<br>   预测器： 一个模型被用于预测采样，在一个音频信号中，基于过去的采样。FLAC使用这样的预测器去移除信号的冗余，来保障压缩。</p>
</li>
<li><p><em>Linear predictor</em>: a predictor using linear prediction<br>   (<a href="https://en.wikipedia.org/wiki/Linear_prediction">https://en.wikipedia.org/wiki/Linear_prediction</a>).  This is also<br>   called <em>linear predictive coding (LPC)</em>. With a linear predictor<br>   each prediction is a linear combination of past samples, hence the<br>   name.  A linear predictor has a causal discrete-time finite<br>   impulse response (<a href="https://en.wikipedia.org/wiki/">https://en.wikipedia.org/wiki/</a><br>   Finite_impulse_response).</p>
<p>线性预测： 一个预测器使用线性预测。</p>
<ul>
<li><p><em>Fixed predictor</em>: a linear predictor in which the model<br>parameters are the same across all FLAC files, and thus not need<br>to be stored.</p>
</li>
<li><p><em>Predictor order</em>: the number of past samples that a predictor<br>uses.  For example, a 4th order predictor uses the 4 samples<br>directly preceding a certain sample to predict it.  In FLAC,<br>samples used in a predictor are always consecutive, and are always<br>the samples directly before the sample that is being predicted</p>
</li>
</ul>
</li>
<li><p><em>Residual</em>: The audio signal that remains after a predictor has<br> been subtracted from a subblock.  If the predictor has been able<br> to remove redundancy from the signal, the samples of the remaining<br> signal (the <em>residual samples</em>) will have, on average, a smaller<br> numerical value than the original signal.</p>
</li>
<li><p><em>Rice code</em>: A variable-length code<br>(<a href="https://en.wikipedia.org/wiki/Variable-length_code">https://en.wikipedia.org/wiki/Variable-length_code</a>) which<br>compresses data by making use of the observation that, after using<br>an effective predictor, most residual samples are closer to zero<br>than the original samples, while still allowing for a small part<br>of the samples to be much larger.</p>
</li>
</ul>
<h4 id="Blocking"><a href="#Blocking" class="headerlink" title="Blocking"></a>Blocking</h4><p>The size used for blocking the audio data has a direct effect on the compression ratio. If the block size is too small, the resulting large number of frames mean that excess bits will be wasted on frame headers. If the block size is too large, the characteristics of the signal may vary so much that the encoder will be unable to find a good predictor. In order to simplify encoder&#x2F;decoder design, FLAC imposes a minimum block size of 16 samples, and a maximum block size of 65535 samples. This range covers the optimal size for all of the audio data FLAC supports.<br>用于音频数据的块的大小对压缩率有直接影响。如果块大小太小，则产生的大量帧意味着多余的比特将浪费在帧头上。如果块大小太大，信号的特征可能变化很大，以至于编码器将无法找到一个好的预测器。为了简化编码器&#x2F;解码器设计，FLAC 规定最小块大小为 16 个样本，最大块大小为 65535 个样本。此范围涵盖 FLAC 支持的所有音频数据的最佳大小。<br>Currently the reference encoder uses a fixed block size, optimized on the sample rate of the input. Future versions may vary the block size depending on the characteristics of the signal.<br>目前，参考编码器使用固定块大小，并针对输入的采样率进行了优化。未来版本可能会根据信号的特性改变块大小。<br>Blocked data is passed to the predictor stage one subblock (channel) at a time. Each subblock is independently coded into a subframe, and the subframes are concatenated into a frame. Because each channel is coded separately, it means that one channel of a stereo frame may be encoded as a constant subframe, and the other an LPC subframe.<br>成块的数据一次传递到预测器阶段一个子块（通道）。每个子块被独立地编码成一个子帧，并且这些子帧被连接成一个帧。因为每个通道是单独编码的，这意味着立体声帧的一个通道可以被编码为一个恒定的子帧，而另一个可以被编码为一个LPC子帧。</p>
<h4 id="Interchannel-Decorrelation"><a href="#Interchannel-Decorrelation" class="headerlink" title="Interchannel Decorrelation"></a>Interchannel Decorrelation</h4><p>通道间去相关性<br>In stereo streams, many times there is an exploitable amount of correlation between the left and right channels. FLAC allows the frames of stereo streams to have different channel assignments, and an encoder may choose to use the best representation on a frame-by-frame basis.<br>在立体声流中，很多时候左右声道之间存在可利用的相关性。 FLAC 允许立体声流的帧具有不同的通道分配，并且编码器可以逐帧选择使用最佳表示。</p>
<ul>
<li>Independent. The left and right channels are coded independently.左右声道独立编码。</li>
<li>Mid-side. The left and right channels are transformed into mid and side channels. The mid channel is the midpoint (average) of the left and right signals, and the side is the difference signal (left minus right).左右声道转换为中声道和侧声道。中声道是左右信号的中点（平均值），边是差分信号（左减右）</li>
<li>Left-side. The left channel and side channel are coded.左声道和侧声道被编码。</li>
<li>Right-side. The right channel and side channel are coded右声道和侧声道编码</li>
</ul>
<p>Surprisingly, the left-side and right-side forms can be the most efficient in many frames, even though the raw number of bits per sample needed for the original signal is slightly more than that needed for independent or mid-side coding.<br>令人惊讶的是，左侧和右侧形式在许多帧中可能是最有效的，即使原始信号所需的每个样本的原始位数略多于独立或中侧编码所需的位数。</p>
<h4 id="Prediction"><a href="#Prediction" class="headerlink" title="Prediction"></a>Prediction</h4><p>FLAC uses four methods for modeling the input signal:FLAC 使用四种方法对输入信号进行建模：</p>
<ul>
<li><p>Verbatim. This is essentially a zero-order predictor of the signal. The predicted signal is zero, meaning the residual is the signal itself, and the compression is zero. This is the baseline against which the other predictors are measured. If you feed random data to the encoder, the verbatim predictor will probably be used for every subblock. Since the raw signal is not actually passed through the residual coding stage (it is added to the stream ‘verbatim’), the encoding results will not be the same as a zero-order linear predictor.<br>逐字：这本质上是信号的零阶预测器。预测信号为零，意味着残差是信号本身，压缩为零。这是衡量其他预测变量的基线。如果将随机数据提供给编码器，则逐字预测器可能会用于每个子块。由于原始信号实际上并未通过残差编码阶段（它被添加到“逐字”流中），因此编码结果将与零阶线性预测器不同。</p>
</li>
<li><p>Constant. This predictor is used whenever the subblock is pure DC (“digital silence”), i.e. a constant value throughout. The signal is run-length encoded and added to the stream.<br>常量：翻译有限，看原文。</p>
</li>
<li><p>Fixed linear predictor. FLAC uses a class of computationally-efficient fixed linear predictors (for a good description, see audiopak and shorten). FLAC adds a fourth-order predictor to the zero-to-third-order predictors used by Shorten. Since the predictors are fixed, the predictor order is the only parameter that needs to be stored in the compressed stream. The error signal is then passed to the residual coder.<br>固定线性预测器。FLAC 使用一类计算效率高的固定线性预测器（有关详细说明，请参阅 audiopak 和缩短）。 FLAC 将四阶预测器添加到 Shorten 使用的零到三阶预测器。由于预测器是固定的，因此预测器顺序是需要存储在压缩流中的唯一参数。然后将误差信号传递给残差编码器。</p>
</li>
<li><p>FIR Linear prediction. For more accurate modeling (at a cost of slower encoding), FLAC supports up to 32nd order FIR linear prediction (again, for information on linear prediction, see audiopak and shorten). The reference encoder uses the Levinson-Durbin method for calculating the LPC coefficients from the autocorrelation coefficients, and the coefficients are quantized before computing the residual. Whereas encoders such as Shorten used a fixed quantization for the entire input, FLAC allows the quantized coefficient precision to vary from subframe to subframe. The FLAC reference encoder estimates the optimal precision to use based on the block size and dynamic range of the original signal.<br>FIR 线性预测：为了更准确的建模（以较慢的编码为代价），FLAC 支持高达 32 阶的 FIR 线性预测（同样，有关线性预测的信息，请参阅 audiopak 和缩短）。参考编码器使用 Levinson-Durbin 方法从自相关系数计算 LPC 系数，并在计算残差之前对系数进行量化。虽然 Shorten 等编码器对整个输入使用固定量化，但 FLAC 允许量化系数精度因子帧而异。 FLAC 参考编码器根据原始信号的块大小和动态范围估计要使用的最佳精度。</p>
</li>
</ul>
<h4 id="Residual-Coding"><a href="#Residual-Coding" class="headerlink" title="Residual Coding"></a>Residual Coding</h4><p>残差编码<br>FLAC currently defines two similar methods for the coding of the error signal from the prediction stage. The error signal is coded using Rice codes in one of two ways: 1) the encoder estimates a single Rice parameter based on the variance of the residual and Rice codes the entire residual using this parameter; 2) the residual is partitioned into several equal-length regions of contiguous samples, and each region is coded with its own Rice parameter based on the region’s mean. (Note that the first method is a special case of the second method with one partition, except the Rice parameter is based on the residual variance instead of the mean.)<br>FLAC 目前定义了两种类似的方法来对来自预测阶段的误差信号进行编码。误差信号以两种方式之一使用莱斯编码进行编码：1) 编码器根据残差的方差估计单个莱斯参数，莱斯使用该参数对整个残差进行编码； 2）残差被分割成几个等长的连续样本区域，每个区域根据区域的均值用自己的Rice参数编码。 （请注意，第一种方法是第二种方法的特殊情况，只有一个分区，不同的是 Rice 参数基于残差方差而不是均值。）</p>
<p>The FLAC format has reserved space for other coding methods. Some possiblities for volunteers would be to explore better context-modeling of the Rice parameter, or Huffman coding. See LOCO-I and pucrunch for descriptions of several universal codes.<br>FLAC 格式为其他编码方法保留了空间。志愿者的一些可能性是探索更好的 Rice 参数或霍夫曼编码的上下文建模。有关几种通用代码的说明，请参阅 LOCO-I 和 pucrunch。</p>
<h4 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h4><p>This section specifies the FLAC bitstream format. FLAC has no format version information, but it does contain reserved space in several places. Future versions of the format may use this reserved space safely without breaking the format of older streams. Older decoders may choose to abort decoding or skip data encoded with newer methods. Apart from reserved patterns, in places the format specifies invalid patterns, meaning that the patterns may never appear in any valid bitstream, in any prior, present, or future versions of the format. These invalid patterns are usually used to make the synchronization mechanism more robust.<br>这节具体了FLAC的位流格式。FLAC没有格式版本信息，但它确实包含了预留格式在几个位置。格式的未来版本可能会使用这个预留空间，而不用打破老的格式。老的解码器也可选择终止解码或跳过这种新的方式的编码数据。除了保留模式之外，格式在某些地方指定了无效模式，这意味着模式可能永远不会出现在任何有效比特流中，在任何先前、现在或未来版本的格式中。这些无效模式通常用于使同步机制更加健壮。</p>
<p>All numbers used in a FLAC bitstream are integers; there are no floating-point representations. All numbers are big-endian coded. All numbers are unsigned unless otherwise specified.</p>
<p>FLAC 比特流中使用的所有数字都是整数；没有浮点表示。所有数字都是大端编码的。除非另有说明，所有数字都是无符号的。</p>
<p>Before the formal description of the stream, an overview might be helpful.在正式描述流之前，概述可能会有所帮助。<br>    音频头或解码重要信息块<br>– A FLAC bitstream consists of the “fLaC” marker at the beginning of the stream, followed by a mandatory metadata block (called the STREAMINFO block), any number of other metadata blocks, then the audio frames.FLAC 比特流由流开头的“fLaC”标记组成，后跟强制性元数据块（称为 STREAMINFO 块）、任意数量的其他元数据块，然后是音频帧。<br>音频元数据块。<br>– FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:FLAC 支持多达 128 种元数据块；目前定义了以下内容：</p>
<ul>
<li><p>STREAMINFO: This block has information about the whole stream, like sample rate, number of channels, total number of samples, etc. It must be present as the first metadata block in the stream. Other metadata blocks may follow, and ones that the decoder doesn’t understand, it will skip.该块包含有关整个流的信息，例如采样率、通道数、样本总数等。它必须作为流中的第一个元数据块出现。其他元数据块可能会跟随，解码器不理解的，它会跳过。</p>
</li>
<li><p>APPLICATION: This block is for use by third-party applications. The only mandatory field is a 32-bit identifier. This ID is granted upon request to an application by the FLAC maintainers. The remainder is of the block is defined by the registered application. Visit the registration page if you would like to register an ID for your application with FLAC.<br>此块供第三方应用程序使用。唯一的必填字段是 32 位标识符。此 ID 是应 FLAC 维护者对应用程序的请求授予的。块的其余部分由注册的应用程序定义。如果您想在 FLAC 中为您的应用程序注册 ID，请访问注册页面。</p>
</li>
<li><p>PADDING: This block allows for an arbitrary amount of padding. The contents of a PADDING block have no meaning. This block is useful when it is known that metadata will be edited after encoding; the user can instruct the encoder to reserve a PADDING block of sufficient size so that when metadata is added, it will simply overwrite the padding (which is relatively quick) instead of having to insert it into the right place in the existing file (which would normally require rewriting the entire file).<br>该块允许任意数量的填充。 PADDING 块的内容没有意义。当知道元数据将在编码后被编辑时，这个块很有用；用户可以指示编码器保留足够大小的 PADDING 块，以便在添加元数据时，它会简单地覆盖填充（相对较快），而不必将其插入到现有文件中的正确位置（这将通常需要重写整个文件）。</p>
</li>
<li><p>SEEKTABLE: This is an optional block for storing seek points. It is possible to seek to any given sample in a FLAC stream without a seek table, but the delay can be unpredictable since the bitrate may vary widely within a stream. By adding seek points to a stream, this delay can be significantly reduced. Each seek point takes 18 bytes, so 1% resolution within a stream adds less than 2k. There can be only one SEEKTABLE in a stream, but the table can have any number of seek points. There is also a special ‘placeholder’ seekpoint which will be ignored by decoders but which can be used to reserve space for future seek point insertion.<br>这是用于存储搜索点的可选块。可以在没有查找表的情况下查找 FLAC 流中的任何给定样本，但延迟可能无法预测，因为比特率可能在流内变化很大。通过向流添加查找点，可以显着减少此延迟。每个搜索点占用 18 个字节，因此流中 1% 的分辨率增加了不到 2k。一个流中只能有一个 SEEKTABLE，但该表可以有任意数量的搜索点。还有一个特殊的“占位符”搜索点，它会被解码器忽略，但可用于为将来的搜索点插入保留空间。</p>
</li>
<li><p>VORBIS_COMMENT: This block is for storing a list of human-readable name&#x2F;value pairs. Values are encoded using UTF-8. It is an implementation of the Vorbis comment specification (without the framing bit). This is the only officially supported tagging mechanism in FLAC. There may be only one VORBIS_COMMENT block in a stream. In some external documentation, Vorbis comments are called FLAC tags to lessen confusion.<br>此块用于存储人类可读的名称&#x2F;值对列表。值使用 UTF-8 编码。它是 Vorbis 注释规范的一个实现（没有帧位）。这是 FLAC 中唯一官方支持的标记机制。一个流中可能只有一个 VORBIS_COMMENT 块。在一些外部文档中，Vorbis 注释被称为 FLAC 标签以减少混淆。</p>
</li>
<li><p>CUESHEET: This block is for storing various information that can be used in a cue sheet. It supports track and index points, compatible with Red Book CD digital audio discs, as well as other CD-DA metadata such as media catalog number and track ISRCs. The CUESHEET block is especially useful for backing up CD-DA discs, but it can be used as a general purpose cueing mechanism for playback.此块用于存储可在提示表中使用的各种信息。它支持曲目和索引点，与 Red Book CD 数字音频光盘以及其他 CD-DA 元数据（如媒体目录编号和曲目 ISRC）兼容。 CUESHEET 块对于备份 CD-DA 光盘特别有用，但它可以用作播放的通用提示机制。</p>
</li>
<li><p>PICTURE: This block is for storing pictures associated with the file, most commonly cover art from CDs. There may be more than one PICTURE block in a file. The picture format is similar to the APIC frame in ID3v2. The PICTURE block has a type, MIME type, and UTF-8 description like ID3v2, and supports external linking via URL (though this is discouraged). The differences are that there is no uniqueness constraint on the description field, and the MIME type is mandatory. The FLAC PICTURE block also includes the resolution, color depth, and palette size so that the client can search for a suitable picture without having to scan them all.<br>此块用于存储与文件相关的图片，最常见的是 CD 中的封面艺术。一个文件中可能有多个 PICTURE 块。图片格式类似于ID3v2中的APIC帧。 PICTURE 块具有类型、MIME 类型和 UTF-8 描述（如 ID3v2），并支持通过 URL 进行外部链接（尽管不鼓励这样做）。不同之处在于描述字段没有唯一性约束，MIME 类型是强制性的。 FLAC PICTURE 块还包括分辨率、颜色深度和调色板大小，以便客户无需全部扫描即可搜索合适的图片。</p>
</li>
</ul>
<h4 id="音频数据："><a href="#音频数据：" class="headerlink" title="音频数据："></a>音频数据：</h4><p>The audio data is composed of one or more audio frames. Each frame consists of a frame header, which contains a sync code, information about the frame like the block size, sample rate, number of channels, et cetera, and an 8-bit CRC. The frame header also contains either the sample number of the first sample in the frame (for variable-blocksize streams), or the frame number (for fixed-blocksize streams). This allows for fast, sample-accurate seeking to be performed. Following the frame header are encoded subframes, one for each channel, and finally, the frame is zero-padded to a byte boundary. Each subframe has its own header that specifies how the subframe is encoded.<br>音频数据由一个或多个音频帧组成。每个帧由一个帧头组成，其中包含一个同步代码、有关帧的信息，如块大小、采样率、通道数等，以及一个 8 位 CRC。帧头还包含帧中第一个样本的样本编号（对于可变块大小的流）或帧编号（对于固定块大小的流）。这允许执行快速、样本准确的搜索。在帧头之后是编码子帧，每个通道一个，最后，帧被零填充到字节边界。每个子帧都有自己的标头，用于指定子帧的编码方式。<br>Since a decoder may start decoding in the middle of a stream, there must be a method to determine the start of a frame. A 14-bit sync code begins each frame. The sync code will not appear anywhere else in the frame header. However, since it may appear in the subframes, the decoder has two other ways of ensuring a correct sync. The first is to check that the rest of the frame header contains no invalid data. Even this is not foolproof since valid header patterns can still occur within the subframes. The decoder’s final check is to generate an 8-bit CRC of the frame header and compare this to the CRC stored at the end of the frame header.<br>由于解码器可能在流的中间开始解码，因此必须有一种方法来确定帧的开始。每帧开始一个 14 位同步代码。同步代码不会出现在帧头中的任何其他地方。然而，由于它可能出现在子帧中，解码器有两种其他方式来确保正确的同步。首先是检查帧头的其余部分是否不包含无效数据。即使这也不是万无一失的，因为有效的报头模式仍然可以出现在子帧内。解码器的最终检查是生成帧头的 8 位 CRC，并将其与存储在帧头末尾的 CRC 进行比较。<br>Again, since a decoder may start decoding at an arbitrary frame in the stream, each frame header must contain some basic information about the stream because the decoder may not have access to the STREAMINFO metadata block at the start of the stream. This information includes sample rate, bits per sample, number of channels, etc. Since the frame header is pure overhead, it has a direct effect on the compression ratio. To keep the frame header as small as possible, FLAC uses lookup tables for the most commonly used values for frame parameters. For instance, the sample rate part of the frame header is specified using 4 bits. Eight of the bit patterns correspond to the commonly used sample rates of 8&#x2F;16&#x2F;22.05&#x2F;24&#x2F;32&#x2F;44.1&#x2F;48&#x2F;96 kHz. However, odd sample rates can be specified by using one of the ‘hint’ bit patterns, directing the decoder to find the exact sample rate at the end of the frame header. The same method is used for specifying the block size and bits per sample. In this way, the frame header size stays small for all of the most common forms of audio data.<br>同样，由于解码器可以在流中的任意帧开始解码，每个帧头必须包含一些关于流的基本信息，因为解码器可能无法访问流开始处的 STREAMINFO 元数据块。该信息包括采样率、每个样本的位数、通道数等。由于帧头是纯开销，它对压缩率有直接影响。为了使帧头尽可能小，FLAC 使用查找表来查找最常用的帧参数值。例如，帧头的采样率部分使用 4 位指定。八个位模式对应于常用的采样率 8&#x2F;16&#x2F;22.05&#x2F;24&#x2F;32&#x2F;44.1&#x2F;48&#x2F;96 kHz。但是，可以通过使用“提示”位模式之一来指定奇数采样率，指示解码器在帧头的末尾找到确切的采样率。相同的方法用于指定块大小和每个样本的位数。通过这种方式，对于所有最常见的音频数据形式，帧头大小保持较小。<br>Individual subframes (one for each channel) are coded separately within a frame, and appear serially in the stream. In other words, the encoded audio data is NOT channel-interleaved. This reduces decoder complexity at the cost of requiring larger decode buffers. Each subframe has its own header specifying the attributes of the subframe, like prediction method and order, residual coding parameters, etc. The header is followed by the encoded audio data for that channel.<br>单个子帧（每个通道一个）在一个帧内单独编码，并连续出现在流中。换句话说，编码的音频数据不是通道交错的。这以需要更大的解码缓冲器为代价降低了解码器的复杂性。每个子帧都有自己的标头，指定子帧的属性，如预测方法和顺序、残差编码参数等。标头后面是该通道的编码音频数据。</p>
<p>FLAC specifies a subset of itself as the Subset format. The purpose of this is to ensure that any streams encoded according to the Subset are truly “streamable”, meaning that a decoder that cannot seek within the stream can still pick up in the middle of the stream and start decoding. It also makes hardware decoder implementations more practical by limiting the encoding parameters such that decoder buffer sizes and other resource requirements can be easily determined. flac generates Subset streams by default unless the “–lax” command-line option is used. The Subset makes the following limitations on what may be used in the stream:<br>FLAC 将自身的子集指定为子集格式。这样做的目的是确保根据子集编码的任何流都是真正“可流式传输的”，这意味着无法在流中查找的解码器仍然可以在流中间拾取并开始解码。它还通过限制编码参数使硬件解码器实现更加实用，以便可以轻松确定解码器缓冲区大小和其他资源要求。除非使用“–lax”命令行选项，否则flac默认生成子集流。子集对流中可能使用的内容进行了以下限制：</p>
<p>The blocksize bits in the frame header must be 0001-1110. The blocksize must be &lt;&#x3D;16384; if the sample rate is &lt;&#x3D; 48000Hz, the blocksize must be &lt;&#x3D;4608.<br>The sample rate bits in the frame header must be 0001-1110.<br>The bits-per-sample bits in the frame header must be 001-111.<br>If the sample rate is &lt;&#x3D; 48000Hz, the filter order in LPC subframes must be less than or equal to 12, i.e. the subframe type bits in the subframe header may not be 101100-111111.<br>The Rice partition order in a Rice-coded residual section must be less than or equal to 8.<br>The following tables constitute a formal description of the FLAC format. Numbers in angle brackets indicate how many bits are used for a given field.</p>
<h4 id="ref："><a href="#ref：" class="headerlink" title="ref："></a>ref：</h4><p><a href="https://xiph.org/flac/format.html#acknowledgments">https://xiph.org/flac/format.html#acknowledgments</a><br><a href="https://xiph.org/flac/format.html">https://xiph.org/flac/format.html</a><br>rfc：<br><a href="https://datatracker.ietf.org/doc/html/draft-ietf-cellar-flac">https://datatracker.ietf.org/doc/html/draft-ietf-cellar-flac</a><br>见文档来查更多的格式和位数：<a href="https://xiph.org/flac/format.html#acknowledgments">https://xiph.org/flac/format.html#acknowledgments</a><br>对应开源库的位置：<a href="https://ftp.osuosl.org/pub/xiph/releases/flac/">https://ftp.osuosl.org/pub/xiph/releases/flac/</a></p>
]]></content>
      <categories>
        <category>audio</category>
      </categories>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>audio_ogg</title>
    <url>/2022/03/27/audio-oggs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Ogg简述"><a href="#Ogg简述" class="headerlink" title="Ogg简述"></a>Ogg简述</h4><p>rfc: <a href="https://datatracker.ietf.org/doc/html/rfc3533">https://datatracker.ietf.org/doc/html/rfc3533</a><br>  Ogg是一种音频的容器格式，常见的音频容器格式还有：mp3,aac,wav等等；<br> “Ogg”意指一种文件格式，可以纳入各式各样自由和开放源代码的编解码器，包含音效、视频、文字（像字幕）与元数据的处理。  <span id="more"></span><br> OGGVobis(oggVorbis)是一种新的音频压缩格式，类似于MP3等的音乐格式。<br> OggVobis是完全免费、开放和没有专利限制的。OggVorbis文件的扩展名是.OGG。<br> Ogg文件格式可以不断地进行大小和音质的改良，而不影响旧有的编码器或播放器。OGG Vorbis有一个特点是支持多声道。  </p>
<h4 id="Ogg的特点"><a href="#Ogg的特点" class="headerlink" title="Ogg的特点"></a>Ogg的特点</h4><ul>
<li>Ogg封装多种格式的二进制数据，它可以封装任何类型的： video, audio,image, text, or, generally speaking, any time-continuously sampled data.  </li>
<li>Ogg可以被那些能提供自己的帧分离机制的传输协议如(UDP,RTP)直接使用；OggS是一个基于流式存储(如文件)和传输(如tcp&#x2F;管道)的方案；而传输时需要指明其承载的是哪种编码协议；</li>
<li>Ogg可以封装多种类型的编码格式，并以逻辑流来呈现区分，Ogg传输比特流被设计用来提供帧式的，具备错误校验和包含未封装的数据包组成的高层次编码流，例如<br>作为Vorbis音频编解码器或即将到来的Tarkin和Theora视频</li>
<li>它能够交错不同的二进制媒体和其他时间连续的数据流，这些数据流由编码器准备成一个数据包序列。Ogg提供了足够的信息来正确地将数据分离回这种编码器在原始数据包边界处创建的数据包中，而不需要依赖解码来寻找数据包边界。</li>
</ul>
<h4 id="Ogg的物理流和逻辑流的概念"><a href="#Ogg的物理流和逻辑流的概念" class="headerlink" title="Ogg的物理流和逻辑流的概念"></a>Ogg的物理流和逻辑流的概念</h4><ul>
<li>Ogg的实际文件称为物理流，而其中封装的一个或多个的不同编码流，称为逻辑流；一个逻辑流提供给ogg的封装过程，有一个结构，<br>例如，它被分离成一系列称为包的东西；包由该逻辑位流的编码器创建，仅代表该编码器的有意义的实体(例如，未压缩的流可以使用<br>视频帧作为信息包)。它们不包含边界信息——它们串在一起就像是没有标志的随机字节流。(注意这里的包和网络的包不同)</li>
<li>Ogg背后的设计理念是提供一种通用的线性媒体传输格式支持基于文件的存储和基于流的存储独立的一个或几个交叉媒体流的传输<br>媒体数据的编码格式。这样一个封装格式需要提供: 其实就是Ogg本身支持的特性： <ul>
<li>framing for logical bitstreams  逻辑位流的帧</li>
<li>interleaving(交错) of different logical bitstreams.</li>
<li>detection of corruption. 校验差错</li>
<li>recapture after a parsing error 解析错误重新捕获</li>
<li>position landmarks for direct random access of arbitrary positions in the bitstream.</li>
<li>streaming capability (i.e., no seeking is needed to build a 100% complete bitstream)small overhead (i.e., use no more than approximately 1-2% of bitstream bandwidth for packet boundary marking, high-level framing, sync and seeking).     </li>
<li>simplicity to enable fast parsing.</li>
<li>simple concatenation mechanism of several physical bitstreams.<br>Ogg支持逻辑流，可以封装多个逻辑流，每个逻辑流有自己的头和数据页；</li>
</ul>
</li>
</ul>
<h4 id="Ogg物理流和逻辑流的封装，bos-eos等"><a href="#Ogg物理流和逻辑流的封装，bos-eos等" class="headerlink" title="Ogg物理流和逻辑流的封装，bos,eos等"></a>Ogg物理流和逻辑流的封装，bos,eos等</h4><ul>
<li><p>物理流包含了多个逻辑流，由页交错组成；并在页的级别上有序；<br>每个逻辑流被一个唯一的序列号标识，在物理页的头部中；这个号是随机的，和内容和编码器没有任何关系；<br>多个逻辑流是共存的，他们不需要有序，仅需要在自己的逻辑流上有序就行；在重组时，会依赖头部的相关字段进行有序的重组<br>恢复每个逻辑流；  </p>
</li>
<li><p>每个逻辑流只能包含一种类型的数据，但是页是变长的，并且有一个页头部包含封装信息和错误恢复信息；每个逻辑流都以bos页<br>（begining of stream）开头，并以eos页(end of stream)结尾  </p>
</li>
<li><p>bos页需要包含的内容，对音频：采样率，通道数等解码需要的字段，而在最前面的多个字节往往是编码的标识魔数，bos也支持第二个辅助头，<br>因为不知道这个头什么时候结束，或者有多大；它也不包含任何实际的载荷数据，所以一个物理流开始于bos页，接着是辅助头，接着实际数据</p>
</li>
<li><p>封装一个或多个逻辑流被称为媒体映射，一个例子是Ogg Vorbis,即使用了Ogg封装了Vorbis编码的音频流，并进行tcp传输</p>
</li>
<li><p>Ogg提供了两种混合的方式，grouping和chaining,前者是交错的，不同的编码逻辑流交错一起，用于需要类似音画同步的多编码同步中；而chaining是一种简单的有序形式，一个逻辑流之后才是下一个逻辑流</p>
</li>
<li><p>在grouping方式下的基本特点，即bos连在一起，接着是secondary header辅助头连在一起，接着是数据，最后是eos,eos不用全都连在一起，见下面的例子，且每个逻辑流有唯一的id，在实际封装的物理流中</p>
</li>
<li><p>这两种方式可以共存，但是得保持他们各自的特点,grouped和chained可以共存，如上，在grouped结束后紧跟着chained的</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">            physical bitstream with pages of</span><br><span class="line">    different logical bitstreams grouped and chained</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">|<span class="string">*A*</span>|<span class="string">*B*</span>|<span class="string">*C*</span>|<span class="string">A</span>|<span class="string">A</span>|<span class="string">C</span>|<span class="string">B</span>|<span class="string">A</span>|<span class="string">B</span>|<span class="string">#A#</span>|<span class="string">C</span>|<span class="string">...</span>|<span class="string">B</span>|<span class="string">C</span>|<span class="string">#B#</span>|<span class="string">#C#</span>|<span class="string">*D*</span>|<span class="string">D</span>|<span class="string">...</span>|<span class="string">#D#</span>|</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"> bos bos bos             eos           eos eos bos       eos</span><br></pre></td></tr></table></figure>
<p>  解释：<br>A B C是三个不同的逻辑流，被封装在一个物理流中； <em>A</em>为流A的bos,以此类推，#A# 是流A的eos，<br>ABC逻辑流是grouping的方式，而D是chaining的方式，以为是放在ABC之后的（不一定有辅助头）</p>
</li>
<li><p>ogg不知道时间只知道需要，依赖上层给出来和位置等,无音画时间同步等<br>Ogg does not know any specifics about the codec data except that each</p>
</li>
<li><p>logical bitstream belongs to a different codec,ogg 不知道数据更具体的细节，除了每个逻辑流属于不同的编码， 编码的数按序写入，并带了位置标记Granule position.)<br> Ogg不知道时间，它只知道顺序增长。以及无单位的位置标记。app只能通过更高层的拿到时间信息，那些能调用编解码API,来分配和转换granule positions or time.</p>
</li>
</ul>
<h4 id="Ogg如何封装一个编码的逻辑流：-一个Packet可能跨页，或者包含多个包"><a href="#Ogg如何封装一个编码的逻辑流：-一个Packet可能跨页，或者包含多个包" class="headerlink" title="Ogg如何封装一个编码的逻辑流： 一个Packet可能跨页，或者包含多个包"></a>Ogg如何封装一个编码的逻辑流： 一个Packet可能跨页，或者包含多个包</h4><ul>
<li>包packet是从编码器编码后的数据，它依赖于编码的格式；</li>
<li>从Ogg角度看，包可以是任意size,一个具体的媒体映射将定义如何组装和分拆包，从一个媒体编码器；Ogg有最大64KB的限制，为了简化，Ogg分割每个包成255B长的chunks 加最后一个比较短的chunk（即packet size%255后剩下的）这些chunk称为 Ogg Segments, 它们只是逻辑上的构建，并且自己没有header；</li>
<li>一组连续的seg 被封装在长度可变的page中，并在page前插入一个header; page header中的seg table告诉关于每个seg的长度；页头中有个字段Header_type ，表示是否是和上个页属于同个packet(即同个packet的连续页的下一页); 可以通过判断255这个数字，来判断是否是packet的最后一个page</li>
<li>编码是比较快的，并且期望每个包大小在20-200bytes之间的大小；这个是设计上的调整而不是建议；极端的2字节小，则每个都加header，则开销很大，而若分的大，则有分两段的情况；<br>下面是一个实际的例子：<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">    logical bitstream with packet boundaries</span><br><span class="line"> -----------------------------------------------------------------</span><br><span class="line"> &gt; |<span class="string">       packet_1             </span>|<span class="string"> packet_2         </span>|<span class="string"> packet_3 </span>|<span class="string">  &lt;</span></span><br><span class="line"><span class="string"> -----------------------------------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     </span>|<span class="string">segmentation (logically only)</span></span><br><span class="line"><span class="string">                     v</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      packet_1 (5 segments)          packet_2 (4 segs)    p_3 (2 segs)</span></span><br><span class="line"><span class="string">     ------------------------------ -------------------- ------------</span></span><br><span class="line"><span class="string"> .. </span>|<span class="string">seg_1</span>|<span class="string">seg_2</span>|<span class="string">seg_3</span>|<span class="string">seg_4</span>|<span class="string">s_5 </span>|<span class="string"> </span>|<span class="string">seg_1</span>|<span class="string">seg_2</span>|<span class="string">seg_3</span>|<span class="string">s_4</span>|<span class="string"> </span>|<span class="string">seg_1</span>|<span class="string">s_2 </span>|<span class="string"> ..</span></span><br><span class="line"><span class="string">     ------------------------------ -------------------- ------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     </span>|<span class="string"> page encapsulation</span></span><br><span class="line"><span class="string">                     v</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> page_1 (packet_1 data)   page_2 (pket_1 data)   page_3 (packet_2 data)</span></span><br><span class="line"><span class="string">------------------------  ----------------  ------------------------</span></span><br><span class="line"><span class="string"></span>|<span class="string">H</span>|<span class="string">------------------- </span>|<span class="string">  </span>|<span class="string">H</span>|<span class="string">----------- </span>|<span class="string">  </span>|<span class="string">H</span>|<span class="string">------------------- </span>|</span><br><span class="line">|<span class="string">D</span>||<span class="string">seg_1</span>|<span class="string">seg_2</span>|<span class="string">seg_3</span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">D</span>|<span class="string">seg_4</span>|<span class="string">s_5 </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">D</span>||<span class="string">seg_1</span>|<span class="string">seg_2</span>|<span class="string">seg_3</span>|<span class="string"> </span>|<span class="string"> ...</span></span><br><span class="line"><span class="string"></span>|<span class="string">R</span>|<span class="string">------------------- </span>|<span class="string">  </span>|<span class="string">R</span>|<span class="string">----------- </span>|<span class="string">  </span>|<span class="string">R</span>|<span class="string">------------------- </span>|</span><br><span class="line">------------------------  ----------------  ------------------------</span><br><span class="line"></span><br><span class="line">                    |<span class="string"></span></span><br><span class="line"><span class="string">pages of            </span>|</span><br><span class="line">other    --------|<span class="string">  </span>|</span><br><span class="line">logical         -------</span><br><span class="line">bitstreams      |<span class="string"> MUX </span>|</span><br><span class="line">                -------</span><br><span class="line">                   |<span class="string"></span></span><br><span class="line"><span class="string">                   v</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">              page_1  page_2          page_3</span></span><br><span class="line"><span class="string">      ------  ------  -------  -----  -------</span></span><br><span class="line"><span class="string"> ...  </span>||<span class="string">   </span>|<span class="string">  </span>||<span class="string">   </span>|<span class="string">  </span>||<span class="string">    </span>|<span class="string">  </span>||<span class="string">  </span>|<span class="string">  </span>||<span class="string">    </span>|<span class="string">  ...</span></span><br><span class="line"><span class="string">      ------  ------  -------  -----  -------</span></span><br><span class="line"><span class="string">              physical Ogg bitstream</span></span><br></pre></td></tr></table></figure>
<h4 id="Ogg的页头部封装格式："><a href="#Ogg的页头部封装格式：" class="headerlink" title="Ogg的页头部封装格式："></a>Ogg的页头部封装格式：</h4>&#x2F;&#x2F; ogg格式<br>&#x2F;&#x2F;    ——————————————————————————–<br>&#x2F;&#x2F;    域名称　　　　　　占用字节　　描述<br>&#x2F;&#x2F;    ——————————————————————————–<br>&#x2F;&#x2F;    capture_pattern　　　 4　　页标识，”OggS”的ASCII字符 4F 67 67 53<br>&#x2F;&#x2F;    structure_version　　 1　　版本ID，当前版本默认＝0<br>&#x2F;&#x2F;    Header_type_flag　　　1　　页头部类型<br>&#x2F;&#x2F;    Granule_position　　　8　　区段位置<br>&#x2F;&#x2F;    Serial_number　　　　 4　　逻辑流的序列号<br>&#x2F;&#x2F;    Page_seguence_number　4　　本页在逻辑流的序号，OGG解码器据此识别有无页丢失。<br>&#x2F;&#x2F;    CRC_cbecksum　　　　　4　　循环冗余校验码校验和<br>&#x2F;&#x2F;    Number_page_segments　1　　本页的区段数量，指明区段表中有多少个区段长度，≤<br>&#x2F;&#x2F;    Segment_table　　　　≤255 区段长度表，每个字节表示一个区段的长度<br>&#x2F;&#x2F;    ——————————————————————————–<br>详细说明：<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">  The Ogg page header has the following format:</span></span><br><span class="line"></span><br><span class="line"><span class="code"> 0                   1                   2                   3</span></span><br><span class="line"><span class="section"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1| Byte</span></span><br><span class="line"><span class="section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="section">| capture_pattern: Magic number for page start &quot;OggS&quot;           | 0-3</span></span><br><span class="line"><span class="section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="section">| version       | header_type   | granule_position     8B       | 4-7</span></span><br><span class="line"><span class="section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="section">|                                                               | 8-11</span></span><br><span class="line"><span class="section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="section">|                               | bitstream_serial_number       | 12-15</span></span><br><span class="line"><span class="section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="section">|                               | page_sequence_number          | 16-19</span></span><br><span class="line"><span class="section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="section">|                               | CRC_checksum                  | 20-23</span></span><br><span class="line"><span class="section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="section">|                               |page_segments  | segment_table | 24-27</span></span><br><span class="line"><span class="section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="section">| ...                                                           | 28-</span></span><br><span class="line"><span class="section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="code">   The fields in the page header have the following meaning:</span></span><br><span class="line"></span><br><span class="line"><span class="code">   1. capture_pattern: a 4 Byte field that signifies the beginning of a</span></span><br><span class="line"><span class="code">      page.  It contains the magic numbers:魔数</span></span><br><span class="line"></span><br><span class="line"><span class="code">            0x4f &#x27;O&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="code">            0x67 &#x27;g&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="code">            0x67 &#x27;g&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="code">            0x53 &#x27;S&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="code">      It helps a decoder to find the page boundaries and regain</span></span><br><span class="line"><span class="code">      synchronisation after parsing a corrupted stream.  Once the</span></span><br><span class="line"><span class="code">      capture pattern is found, the decoder verifies page sync and</span></span><br><span class="line"><span class="code">      integrity by computing and comparing the checksum.</span></span><br><span class="line"></span><br><span class="line"><span class="code">   2. stream_structure_version: 1 Byte signifying the version number of</span></span><br><span class="line"><span class="code">      the Ogg file format used in this stream (this document specifies</span></span><br><span class="line"><span class="code">      version 0). 版本号</span></span><br><span class="line"></span><br><span class="line"><span class="code">   3. header_type_flag: the bits in this 1 Byte field identify the</span></span><br><span class="line"><span class="code">      specific type of this page. 头标记</span></span><br><span class="line"></span><br><span class="line"><span class="code">      *  bit 0x01</span></span><br><span class="line"></span><br><span class="line"><span class="code">         set: page contains data of a packet continued from the previous</span></span><br><span class="line"><span class="code">            page 和前一个page属于同个packet</span></span><br><span class="line"></span><br><span class="line"><span class="code">         unset: page contains a fresh packet 新packet中的page</span></span><br><span class="line"></span><br><span class="line"><span class="code">      *  bit 0x02</span></span><br><span class="line"></span><br><span class="line"><span class="code">         set: this is the first page of a logical bitstream (bos)</span></span><br><span class="line"></span><br><span class="line"><span class="code">         unset: this page is not a first page 逻辑流的第一个包bos</span></span><br><span class="line"></span><br><span class="line"><span class="code">      *  bit 0x04</span></span><br><span class="line"></span><br><span class="line"><span class="code">         set: this is the last page of a logical bitstream (eos)</span></span><br><span class="line"></span><br><span class="line"><span class="code">         unset: this page is not a last page</span></span><br><span class="line"></span><br><span class="line"><span class="code">   4. granule_position: an 8 Byte field containing position information.</span></span><br><span class="line"><span class="code">      For example, for an audio stream, it MAY contain the total number</span></span><br><span class="line"><span class="code">      of PCM samples encoded after including all frames finished on this</span></span><br><span class="line"><span class="code">      page.  For a video stream it MAY contain the total number of video</span></span><br><span class="line"></span><br><span class="line"><span class="code">      frames encoded after this page.  This is a hint for the decoder</span></span><br><span class="line"><span class="code">      and gives it some timing and position information.  Its meaning is</span></span><br><span class="line"><span class="code">      dependent on the codec for that logical bitstream and specified in</span></span><br><span class="line"><span class="code">      a specific media mapping.  A special value of -1 (in two&#x27;s</span></span><br><span class="line"><span class="code">      complement) indicates that no packets finish on this page.  比较复杂</span></span><br><span class="line"><span class="code">      </span></span><br><span class="line"><span class="code">   5. bitstream_serial_number: a 4 Byte field containing the unique</span></span><br><span class="line"><span class="code">      serial number by which the logical bitstream is identified. 逻辑流id</span></span><br><span class="line"></span><br><span class="line"><span class="code">   6. page_sequence_number: a 4 Byte field containing the sequence</span></span><br><span class="line"><span class="code">      number of the page so the decoder can identify page loss.  This</span></span><br><span class="line"><span class="code">      sequence number is increasing on each logical bitstream </span></span><br><span class="line"><span class="code">      separately.逻辑流中的页id,每个逻辑流中增加</span></span><br><span class="line"></span><br><span class="line"><span class="code">   7. CRC_checksum: a 4 Byte field containing a 32 bit CRC checksum of</span></span><br><span class="line"><span class="code">      the page (including header with zero CRC field and page content).</span></span><br><span class="line"><span class="code">      The generator polynomial is 0x04c11db7. CRC 校验</span></span><br><span class="line"></span><br><span class="line"><span class="code">   8. number_page_segments: 1 Byte giving the number of segment entries</span></span><br><span class="line"><span class="code">      encoded in the segment table.seg的数量 ，一个页由多个seg构成，一个packet可能包含多个页；其实是packet分为多个seg后封装到page中；见上；</span></span><br><span class="line"></span><br><span class="line"><span class="code">   9. segment_table: number_page_segments Bytes containing the lacing</span></span><br><span class="line"><span class="code">      values of all segments in this page.  Each Byte contains one</span></span><br><span class="line"><span class="code">      lacing value.     number_page_segments个字节，包含页中所有segments的lacing values, 每个字节为一个lacing value</span></span><br><span class="line"></span><br><span class="line"><span class="code">   The total header size in bytes is given by:</span></span><br><span class="line"><span class="code">   header_size = number_page_segments + 27 [Byte]</span></span><br><span class="line"></span><br><span class="line"><span class="code">   The total page size in Bytes is given by: 一个完整页的大小：</span></span><br><span class="line"><span class="code">   page_size = header_size + sum(lacing_values: 1..number_page_segments)</span></span><br><span class="line"><span class="code">   [Byte]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ogg格式文件和例子："><a href="#ogg格式文件和例子：" class="headerlink" title="ogg格式文件和例子："></a>ogg格式文件和例子：</h4><p>见附件有一个ogg格式的音频：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">4f<span class="number"> 67 </span>67<span class="number"> 53 </span>00<span class="number"> 02 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>5c<span class="number"> 59 </span></span><br><span class="line">48 bg<span class="number"> 00 </span>00<span class="number"> 00 </span>00 e1 8f c5 fe<span class="number"> 01 </span>1e<span class="number"> 01 </span>76 6f<span class="number"> 72 </span>62<span class="number"> 69 </span>73  </span><br><span class="line"> </span><br><span class="line">4f<span class="number"> 67 </span>67<span class="number"> 53 </span>: 4字节的页标识：字符 OggS</span><br><span class="line">00：1B的版本号，0</span><br><span class="line">02：1B的header_type,这里表示是一个bos</span><br><span class="line">00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00 00:8B的Granule_position区段位置为0</span><br><span class="line">5c<span class="number"> 59 </span>48 bg：4B的逻辑流ID</span><br><span class="line">00<span class="number"> 00 </span>00 00： 4B的页Id,本页在逻辑流中的序号为0</span><br><span class="line">e1 8f c5 fe: 4B的CRC循环冗余校验码校验和 </span><br><span class="line">01 :seg数量</span><br><span class="line">1e :第一个seg长度：1e</span><br><span class="line">76 6f<span class="number"> 72 </span>62<span class="number"> 69 </span>73:vorbis的Ascii码</span><br><span class="line">之后是vorbis协议的数据；见相关协议；</span><br><span class="line">当然还可以承载Opus 如OpusHeader这样的；详见Opus介绍</span><br></pre></td></tr></table></figure>

<h4 id="ogg和它的媒体协议；"><a href="#ogg和它的媒体协议；" class="headerlink" title="ogg和它的媒体协议；"></a>ogg和它的媒体协议；</h4><p>首页数据的最开始的几个字节就是描述编码的标识的ascii码；<br>有：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">    Codec Identifier             | Codecs Parameter</span><br><span class="line"> <span class="comment">-----------------------------------------------------------</span></span><br><span class="line">  <span class="type">char</span>[<span class="number">5</span>]: <span class="string">&#x27;BBCD\0&#x27;</span>            | dirac</span><br><span class="line">  <span class="type">char</span>[<span class="number">5</span>]: <span class="string">&#x27;\177FLAC&#x27;</span>          | flac</span><br><span class="line">  <span class="type">char</span>[<span class="number">7</span>]: <span class="string">&#x27;\x80theora&#x27;</span>        | theora</span><br><span class="line">  <span class="type">char</span>[<span class="number">7</span>]: <span class="string">&#x27;\x01vorbis&#x27;</span>        | vorbis</span><br><span class="line">  <span class="type">char</span>[<span class="number">8</span>]: <span class="string">&#x27;CELT    &#x27;</span>          | celt</span><br><span class="line">  <span class="type">char</span>[<span class="number">8</span>]: <span class="string">&#x27;CMML\0\0\0\0&#x27;</span>      | cmml</span><br><span class="line">  <span class="type">char</span>[<span class="number">8</span>]: <span class="string">&#x27;\213JNG\r\n\032\n&#x27;</span> | jng</span><br><span class="line">  <span class="type">char</span>[<span class="number">8</span>]: <span class="string">&#x27;\x80kate\0\0\0&#x27;</span>    | kate</span><br><span class="line">  <span class="type">char</span>[<span class="number">8</span>]: <span class="string">&#x27;OggMIDI\0&#x27;</span>         | midi</span><br><span class="line">  <span class="type">char</span>[<span class="number">8</span>]: <span class="string">&#x27;\212MNG\r\n\032\n&#x27;</span> | mng</span><br><span class="line">  <span class="type">char</span>[<span class="number">8</span>]: <span class="string">&#x27;PCM     &#x27;</span>          | pcm</span><br><span class="line">  <span class="type">char</span>[<span class="number">8</span>]: <span class="string">&#x27;\211PNG\r\n\032\n&#x27;</span> | png</span><br><span class="line">  <span class="type">char</span>[<span class="number">8</span>]: <span class="string">&#x27;Speex   &#x27;</span>          | speex</span><br><span class="line">  <span class="type">char</span>[<span class="number">8</span>]: <span class="string">&#x27;YUV4MPEG&#x27;</span>          | yuv4mpeg</span><br><span class="line"></span><br><span class="line">  An up-<span class="keyword">to</span>-<span class="type">date</span> <span class="keyword">version</span> <span class="keyword">of</span> this <span class="keyword">table</span> <span class="keyword">is</span> kept at Xiph.org (see</span><br><span class="line">[Codecs]). </span><br><span class="line">  现在加了Opus，具体见opus编码rfc      https://datatracker.ietf.org/doc/html/rfc7845</span><br></pre></td></tr></table></figure>
<h4 id="Ogg相关重要概念的解释："><a href="#Ogg相关重要概念的解释：" class="headerlink" title="Ogg相关重要概念的解释："></a>Ogg相关重要概念的解释：</h4><ul>
<li>Granule Position<br>类似于dts，一些实现将dts填充到这个字段上。<br>   granule翻译为颗粒，在这里应该表示为单位时间的采样数，。在首页和comment header中，必须是0。即逻辑流的音频数据前的头都是0<br>   The granule position MUST be zero for the ID header page and the page<br>   where the comment header completes.  That is, the first page in the<br>   logical stream and the last header page before the first audio data<br>   page both have a granule position of zero.</li>
</ul>
<p>   在音频数据页中的granule position, encodes(表示）PCM采样的总数，在这个流直到这个页的最后一个可解码的采样，所以一般是大于0的 :所以可以用dts直接填充？<br>   The granule position of an audio data page encodes the total number<br>   of PCM samples in the stream up to and including the last fully<br>   decodable sample from the last packet completed on that page.  The<br>   granule position of the first audio data page will usually be larger<br>   than zero, as described in Section 4.5.</p>
<p>   跨页的情况，中间的是-1<br>   A page that is entirely spanned by a single packet (that completes on<br>   a subsequent page) has no granule position, and the granule position<br>   field is set to the special value ‘-1’ in two’s complement.</p>
<p>   在一个音频数据页中的采样颗粒位置是以PCM音频为单位采样频率固定为48千赫；但是可能运行Opus 解码是不同的采样率，但所有的Opus包编码的采样是在一个采样率48Khz下； 因此，granule position还是总是count samples假设是48KHz<br>   The granule position of an audio data page is in units of PCM audio<br>   samples at a fixed rate of 48 kHz (per channel; a stereo stream’s<br>   granule position does not increment at twice the speed of a mono<br>   stream).  It is possible to run an Opus decoder at other sampling<br>   rates, but all Opus packets encode samples at a sampling rate that<br>   evenly divides 48 kHz.  Therefore, the value in the granule position<br>   field always counts samples assuming a 48 kHz decoding rate, and the<br>   rest of this specification makes the same assumption.</p>
<pre><code>一个Opus包的时长，可以是任意2.5ms的倍数，最大是120ms.duration被编码在TOC sequence，在每个包开始地方；采样数被解码器返回，根据这个duration,即使是头几个包
例如：一个20ms的包 喂到一个解码器，以48KHz的，将返回960个采样；一个demuxer分流器可能在每个ogg包的开始解析TOC sequence，从一个已知的包根据一个已知的granule position向后或向前工作
为了分配一个granule位置给每个包；或设置每个单独的采样
</code></pre>
<p>   The duration of an Opus packet as defined in [RFC6716] can be any<br>   multiple of 2.5 ms, up to a maximum of 120 ms.  This duration is<br>   encoded in the TOC sequence at the beginning of each packet.  The<br>   number of samples returned by a decoder corresponds to this duration<br>   exactly, even for the first few packets.  For example, a 20 ms packet<br>   fed to a decoder running at 48 kHz will always return 960 samples.  A<br>   demuxer can parse the TOC sequence at the beginning of each Ogg<br>   packet to work backwards or forwards from a packet with a known<br>   granule position (i.e., the last packet completed on some page) in<br>   order to assign granule positions to every packet, or even every<br>   individual sample.  The one exception is the last page in the stream,<br>   as described below.唯一的例外是流的最后一页，</p>
<p>   如下所述。<br>   所有其他有带完整包的页，在第一个之后， 必须有一个等于该页中完整的packets中包含的采样数量的granule position，加上最近的带完整包的页的granule position<br>   All other pages with completed packets after the first MUST have a<br>   granule position equal to the number of samples contained in packets<br>   that complete on that page plus the granule position of the most<br>   recent page with completed packets.<br>   这个保证了一个分流器能分配独立的包相同的granule position，当向前或向后工作。对这个情况，没有任何的gap<br>    This guarantees that a demuxer<br>   can assign individual packets the same granule position when working<br>   forwards as when working backwards.  For this to work, there cannot<br>   be any gaps.</p>
<pre><code> 更多解释：https://wiki.xiph.org/OggOpus
 
</code></pre>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">This</span> is packed in the same way the rest of Ogg data is packed<span class="comment">; LSb of LSB first. Note that the &#x27;position&#x27; data specifies a &#x27;sample&#x27; number (eg, in a CD quality sample is four octets, 16 bits for left and 16 bits for right; in video it would likely be the frame number. It is up to the specific codec in use to define the semantic meaning of the granule position value). The position specified is the total samples encoded after including all packets finished on this page (packets begun on this page but continuing on to the next page do not count). The rationale here is that the position specified in the frame header of the last page tells how long the data coded by the bitstream is. A truncated stream will still return the proper number of samples that can be decoded fully.</span></span><br><span class="line">A special value of <span class="symbol">&#x27;-1</span>&#x27; (<span class="name">in</span> two<span class="symbol">&#x27;s</span> complement) indicates that no packets finish on this page.</span><br><span class="line">这个打包和之后的ogg数据的打包方式一样。LSb of LSB first.注意到这个位置数据具体化采样的数量。(<span class="name">例如，在一个CD中采样是4B</span>,<span class="number">16</span>bit左声 <span class="number">16</span>bit右声。就像在视频中的frame number,如何具体定义取决于具体的编解码器）。</span><br><span class="line">位置的具体值是在这个page包含了所有完成的packet后的所有的采样值；(<span class="name">注意若packet在这个page开始，但下个page还持续，则不统计到这个page的granule</span> position上）。这里的基本原理是，</span><br><span class="line">在最后一页的帧头中指定的位置告诉了由位流编码的数据的长度。被截断的流仍然会返回适当数量的可以被完全解码的样本。</span><br><span class="line">一个特殊值<span class="symbol">&#x27;-1</span>&#x27;(在2的补码中)表示该页上没有包完成。</span><br><span class="line"> byte value</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span>  <span class="number">0</span>xXX LSB</span><br><span class="line">  <span class="number">7</span>  <span class="number">0</span>xXX</span><br><span class="line">  <span class="number">8</span>  <span class="number">0</span>xXX</span><br><span class="line">  <span class="number">9</span>  <span class="number">0</span>xXX</span><br><span class="line"> <span class="number">10</span>  <span class="number">0</span>xXX</span><br><span class="line"> <span class="number">11</span>  <span class="number">0</span>xXX</span><br><span class="line"> <span class="number">12</span>  <span class="number">0</span>xXX</span><br><span class="line"> <span class="number">13</span>  <span class="number">0</span>xXX MSB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https://www.xiph.org/ogg/doc/framing.html</span><br></pre></td></tr></table></figure>


<h4 id="Ogg封包成帧的过程："><a href="#Ogg封包成帧的过程：" class="headerlink" title="Ogg封包成帧的过程："></a>Ogg封包成帧的过程：</h4><ul>
<li><p>1 PCM采集原始音频：<br>sample: 即采样，单位，一般说48Khz则是1s有48000个采样； 即48000samples per second;<br>对48khz而言，PCM 1s采样 48000个samples;<br>音频帧： 对50fps而言，1s有50帧，则1帧是20ms，对48Khz而言，则1帧有 20ms&#x2F;1000ms * 48000 个samples</p>
</li>
<li><p>2 将帧打包进入opus编码<br>一个Opus包的时长，可以是任意2.5ms的倍数，最大是120ms.duration被编码在TOC sequence，在每个包开始地方；采样数被解码器返回，根据这个duration,即使是头几个包<br>例如：一个20ms的包 喂到一个解码器，以48KHz的，将返回960个采样；<br>Opus包的格式可以是：<a href="https://datatracker.ietf.org/doc/html/rfc6716#section-3">https://datatracker.ietf.org/doc/html/rfc6716#section-3</a><br>每个Opus包以TOC或类似的头开始，有几种方式：1帧一包，2帧一包，多帧一包；注意这里的toc中的config配置的对应的ms是对应的packet中的compressed frame对应的，若一个packet有多个frame，计算这个packet的总<br>samples时，要乘以 packet中的frames的数量；以此来判断&lt;120ms,否则异常：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">   +-----------------------+-----------+-----------+-------------------+</span><br><span class="line">   |<span class="string"> Configuration         </span>|<span class="string"> Mode      </span>|<span class="string"> Bandwidth </span>|<span class="string"> Frame Sizes       </span>|</span><br><span class="line">   |<span class="string"> Number(s)             </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   +-----------------------+-----------+-----------+-------------------+</span><br><span class="line">   |<span class="string"> 0...3                 </span>|<span class="string"> SILK-only </span>|<span class="string"> NB        </span>|<span class="string"> 10, 20, 40, 60 ms </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 4...7                 </span>|<span class="string"> SILK-only </span>|<span class="string"> MB        </span>|<span class="string"> 10, 20, 40, 60 ms </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 8...11                </span>|<span class="string"> SILK-only </span>|<span class="string"> WB        </span>|<span class="string"> 10, 20, 40, 60 ms </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 12...13               </span>|<span class="string"> Hybrid    </span>|<span class="string"> SWB       </span>|<span class="string"> 10, 20 ms         </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 14...15               </span>|<span class="string"> Hybrid    </span>|<span class="string"> FB        </span>|<span class="string"> 10, 20 ms         </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 16...19               </span>|<span class="string"> CELT-only </span>|<span class="string"> NB        </span>|<span class="string"> 2.5, 5, 10, 20 ms </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 20...23               </span>|<span class="string"> CELT-only </span>|<span class="string"> WB        </span>|<span class="string"> 2.5, 5, 10, 20 ms </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 24...27               </span>|<span class="string"> CELT-only </span>|<span class="string"> SWB       </span>|<span class="string"> 2.5, 5, 10, 20 ms </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 28...31               </span>|<span class="string"> CELT-only </span>|<span class="string"> FB        </span>|<span class="string"> 2.5, 5, 10, 20 ms </span>|</span><br><span class="line">   +-----------------------+-----------+-----------+-------------------+</span><br><span class="line"> eg:</span><br><span class="line">  0                   1                   2                   3</span><br><span class="line">      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |<span class="string"> config  </span>|<span class="string">s</span>|<span class="string">1</span>|<span class="string">0</span>|<span class="string"> N1 (1-2 bytes):                               </span>|</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               :</span><br><span class="line">     |<span class="string">               Compressed frame 1 (N1 bytes)...                </span>|</span><br><span class="line">     :                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |<span class="string">                               </span>|<span class="string">                               </span>|</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |<span class="string"></span></span><br><span class="line"><span class="string">     </span>|<span class="string">                     Compressed frame 2...                     :</span></span><br><span class="line"><span class="string">     :                                                               </span>|</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">/<span class="symbol">*</span>Returns the duration of the packet (in samples at 48 kHz), or a negative</span><br><span class="line">   value on error.<span class="symbol">*</span>/</span><br><span class="line">static int op_get_packet_duration(const unsigned char <span class="symbol">*</span>_data,int _len)&#123;</span><br><span class="line">  int nframes;</span><br><span class="line">  int frame_size;</span><br><span class="line">  int nsamples;</span><br><span class="line">  nframes=opus_packet_get_nb_frames(_data,_len);</span><br><span class="line">  if(OP_UNLIKELY(nframes<span class="variable">&lt;0))return OP_EBADPACKET;</span></span><br><span class="line"><span class="variable">  frame_size=opus_packet_get_samples_per_frame(_data,48000);</span></span><br><span class="line"><span class="variable">  nsamples=nframes*frame_size;</span></span><br><span class="line"><span class="variable">  if(OP_UNLIKELY(nsamples&gt;</span>120<span class="symbol">*</span>48))return OP_EBADPACKET;</span><br><span class="line">  return nsamples;</span><br><span class="line">&#125;</span><br><span class="line">更多打包方式见opus协议</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 将opus编码打包到Ogg</p>
</li>
</ul>
<p>oggs从 opus编码器拿到packet后，因为oggs本身的封装是最大255个segtable,每个seg的最大值是255Byte，所以oggs页最大是64K;但是因为网络等问题，需要分段，即将opus传递进来的packet分成255byte的chunk,和<br>packet分完最后的小的：如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">raw packet:</span><br><span class="line">  <span class="strong">____</span><span class="strong">____</span><span class="strong">____</span><span class="strong">____</span><span class="strong">____</span><span class="strong">____</span><span class="strong">____</span><span class="strong">____</span><span class="strong">____</span><span class="strong">____</span><span class="strong">__<span class="emphasis">_</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"> |_</span>__</span><span class="strong">____</span><span class="strong">____</span><span class="strong">__<span class="emphasis">_packet data_</span>__</span><span class="strong">____</span><span class="strong">____</span><span class="strong">____</span><span class="strong">__<span class="emphasis">_| 753 bytes</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">lacing values for page header segment table: 255,255,243</span></span></span><br></pre></td></tr></table></figure>
<p>From Ogg’s perspective, packets can be of any arbitrary size.  A<br>   specific media mapping will define how to group or break up packets<br>   from a specific media encoder.  As Ogg pages have a maximum size of<br>   about 64 kBytes, sometimes a packet has to be distributed over<br>   several pages.  To simplify that process, Ogg divides each packet<br>   into 255 byte long chunks plus a final shorter chunk.  These chunks<br>   are called “Ogg Segments”.  They are only a logical construct and do<br>   not have a header for themselves.<br>所以这里可以理解：下图中packet是opus封包后的一个packet对应一个toc头，可能压缩了多个frame; 一个packet被拆为多个seg，装到page中；带头下发；</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">    logical bitstream with packet boundaries</span><br><span class="line"> -----------------------------------------------------------------</span><br><span class="line"> &gt; |<span class="string">       packet_1             </span>|<span class="string"> packet_2         </span>|<span class="string"> packet_3 </span>|<span class="string">  &lt;</span></span><br><span class="line"><span class="string"> -----------------------------------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     </span>|<span class="string">segmentation (logically only)</span></span><br><span class="line"><span class="string">                     v</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      packet_1 (5 segments)          packet_2 (4 segs)    p_3 (2 segs)</span></span><br><span class="line"><span class="string">     ------------------------------ -------------------- ------------</span></span><br><span class="line"><span class="string"> .. </span>|<span class="string">seg_1</span>|<span class="string">seg_2</span>|<span class="string">seg_3</span>|<span class="string">seg_4</span>|<span class="string">s_5 </span>|<span class="string"> </span>|<span class="string">seg_1</span>|<span class="string">seg_2</span>|<span class="string">seg_3</span>|<span class="string">s_4</span>|<span class="string"> </span>|<span class="string">seg_1</span>|<span class="string">s_2 </span>|<span class="string"> ..</span></span><br><span class="line"><span class="string">     ------------------------------ -------------------- ------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     </span>|<span class="string"> page encapsulation</span></span><br><span class="line"><span class="string">                     v</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> page_1 (packet_1 data)   page_2 (pket_1 data)   page_3 (packet_2 data)</span></span><br><span class="line"><span class="string">------------------------  ----------------  ------------------------</span></span><br><span class="line"><span class="string"></span>|<span class="string">H</span>|<span class="string">------------------- </span>|<span class="string">  </span>|<span class="string">H</span>|<span class="string">----------- </span>|<span class="string">  </span>|<span class="string">H</span>|<span class="string">------------------- </span>|</span><br><span class="line">|<span class="string">D</span>||<span class="string">seg_1</span>|<span class="string">seg_2</span>|<span class="string">seg_3</span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">D</span>|<span class="string">seg_4</span>|<span class="string">s_5 </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">D</span>||<span class="string">seg_1</span>|<span class="string">seg_2</span>|<span class="string">seg_3</span>|<span class="string"> </span>|<span class="string"> ...</span></span><br><span class="line"><span class="string"></span>|<span class="string">R</span>|<span class="string">------------------- </span>|<span class="string">  </span>|<span class="string">R</span>|<span class="string">----------- </span>|<span class="string">  </span>|<span class="string">R</span>|<span class="string">------------------- </span>|</span><br><span class="line">------------------------  ----------------  ------------------------</span><br><span class="line"></span><br><span class="line">                    |<span class="string"></span></span><br><span class="line"><span class="string">pages of            </span>|</span><br><span class="line">other    --------|<span class="string">  </span>|</span><br><span class="line">logical         -------</span><br><span class="line">bitstreams      |<span class="string"> MUX </span>|</span><br><span class="line">                -------</span><br><span class="line">                   |<span class="string"></span></span><br><span class="line"><span class="string">                   v</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">              page_1  page_2          page_3</span></span><br><span class="line"><span class="string">      ------  ------  -------  -----  -------</span></span><br><span class="line"><span class="string"> ...  </span>||<span class="string">   </span>|<span class="string">  </span>||<span class="string">   </span>|<span class="string">  </span>||<span class="string">    </span>|<span class="string">  </span>||<span class="string">  </span>|<span class="string">  </span>||<span class="string">    </span>|<span class="string">  ...</span></span><br><span class="line"><span class="string">      ------  ------  -------  -----  -------</span></span><br><span class="line"><span class="string">              physical Ogg bitstream</span></span><br></pre></td></tr></table></figure>

<pre><code>  + 一个Ogg页，若不限制，可以封装&lt;=255个segment,一个seg是一个帧，根据oggopus rfc，opus packet 是2.5ms的倍数，最大是120ms；故若一个Oggs页最多可以包255个音频帧：
    This is allowed to be up to 32 bits to support the maximum duration of a single Ogg page (255 packets * 120 ms per
   packet == 1,468,800 samples at 48 kHz).  255*120/1000 *48000 =1468800  这里的packet，就是上面提到的音频帧
  + 常见的是一个page有一个segment
  + 协议里的lacing value，是segment的大小，在segment table中有多个lacing value，每个表示每个seg的大小；
  + lacing value的大小推荐： &lt;=255Bytes, 即一个seg的大小，:https://www.xiph.org/ogg/doc/framing.html
</code></pre>
<ul>
<li>4 将原始音频进行封装：<br> 1）在网络传输中，以包的形式传输，包的大小和网络协议等有关，对udp而言，包的大小受udp包的大小影响，又进一步被MTU影响；<br> 2）根据包和帧的关系，将帧打包到包中，可以是一帧一包，或者一帧多包，或者多帧一包；</li>
</ul>
<h4 id="其他：libopus中对ganule-posiontion的检查"><a href="#其他：libopus中对ganule-posiontion的检查" class="headerlink" title="其他：libopus中对ganule posiontion的检查"></a>其他：libopus中对ganule posiontion的检查</h4><p>因为在使用库的过程中，踩过坑，这个字段填充的不太对导致解码失败：<br>下面看看源码对这个字段怎么检查：<br>前言：<br>对ganule posiontion的解释： 是至今到此page 时，已完成的packet的采样数量：<br>若对于20ms每帧来说，第一帧完成时的ganule posiontion是20&#x2F;1000 *48000 &#x3D; 960,所以对于1page1seg1frame下来说，第一个page音频数据页中的ganule postion是960，以此类推；<br>相关库：<br>opusfile-0.11<br>opus-1.3<br>libopusenc-0.2.1<br>…  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Starting from current cursor position, get the initial PCM offset of the next</span></span><br><span class="line"><span class="comment">   page.</span></span><br><span class="line"><span class="comment">  This also validates the granule position on the first page with a completed</span></span><br><span class="line"><span class="comment">   audio data packet, as required by the spec.</span></span><br><span class="line"><span class="comment">  If this link is completely empty (no pages with completed packets), then this</span></span><br><span class="line"><span class="comment">   function sets pcm_start=pcm_end=0 and returns the BOS page of the next link</span></span><br><span class="line"><span class="comment">   (if any).</span></span><br><span class="line"><span class="comment">  In the seekable case, we initialize pcm_end=-1 before calling this function,</span></span><br><span class="line"><span class="comment">   so that later we can detect that the link was empty before calling</span></span><br><span class="line"><span class="comment">   op_find_final_pcm_offset().</span></span><br><span class="line"><span class="comment">  [inout] _link: The link for which to find pcm_start.</span></span><br><span class="line"><span class="comment">  [out] _og:     Returns the BOS page of the next link if this link was empty.</span></span><br><span class="line"><span class="comment">                 In the unseekable case, we can then feed this to</span></span><br><span class="line"><span class="comment">                  op_fetch_headers() to start the next link.</span></span><br><span class="line"><span class="comment">                 The caller may pass NULL (e.g., for seekable streams), in</span></span><br><span class="line"><span class="comment">                  which case this page will be discarded.</span></span><br><span class="line"><span class="comment">  Return: 0 on success, 1 if there is a buffered BOS page available, or a</span></span><br><span class="line"><span class="comment">           negative value on unrecoverable error.*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">op_find_initial_pcm_offset</span><span class="params">(OggOpusFile *_of,</span></span></span><br><span class="line"><span class="params"><span class="function"> OggOpusLink *_link,ogg_page *_og)</span></span>&#123;</span><br><span class="line">  ogg_page     og;</span><br><span class="line">  opus_int64   page_offset;</span><br><span class="line">  <span class="type">ogg_int64_t</span>  pcm_start;</span><br><span class="line">  <span class="type">ogg_int64_t</span>  prev_packet_gp;</span><br><span class="line">  <span class="type">ogg_int64_t</span>  cur_page_gp;</span><br><span class="line">  <span class="type">ogg_uint32_t</span> serialno;</span><br><span class="line">  opus_int32   total_duration;</span><br><span class="line">  <span class="type">int</span>          durations[<span class="number">255</span>];</span><br><span class="line">  <span class="type">int</span>          cur_page_eos;</span><br><span class="line">  <span class="type">int</span>          op_count;</span><br><span class="line">  <span class="type">int</span>          pi;</span><br><span class="line">  <span class="keyword">if</span>(_og==<span class="literal">NULL</span>)_og=&amp;og;</span><br><span class="line">  serialno=_of-&gt;os.serialno;</span><br><span class="line">  op_count=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">/*We shouldn&#x27;t have to initialize total_duration, but gcc is too dumb to</span></span><br><span class="line"><span class="comment">     figure out that op_count&gt;0 implies we&#x27;ve been through the whole loop at</span></span><br><span class="line"><span class="comment">     least once.*/</span></span><br><span class="line">  total_duration=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    page_offset=<span class="built_in">op_get_next_page</span>(_of,_og,_of-&gt;end);</span><br><span class="line">    <span class="comment">/*We should get a page unless the file is truncated or mangled.</span></span><br><span class="line"><span class="comment">      Otherwise there are no audio data packets in the whole logical stream.*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">OP_UNLIKELY</span>(page_offset&lt;<span class="number">0</span>))&#123;</span><br><span class="line">      <span class="comment">/*Fail if there was a read error.*/</span></span><br><span class="line">      <span class="keyword">if</span>(page_offset&lt;OP_FALSE)<span class="keyword">return</span> (<span class="type">int</span>)page_offset;</span><br><span class="line">      <span class="comment">/*Fail if the pre-skip is non-zero, since it&#x27;s asking us to skip more</span></span><br><span class="line"><span class="comment">         samples than exist.*/</span></span><br><span class="line">      <span class="keyword">if</span>(_link-&gt;head.pre_skip&gt;<span class="number">0</span>)<span class="keyword">return</span> OP_EBADTIMESTAMP;</span><br><span class="line">      _link-&gt;pcm_file_offset=<span class="number">0</span>;</span><br><span class="line">      <span class="comment">/*Set pcm_end and end_offset so we can skip the call to</span></span><br><span class="line"><span class="comment">         op_find_final_pcm_offset().*/</span></span><br><span class="line">      _link-&gt;pcm_start=_link-&gt;pcm_end=<span class="number">0</span>;</span><br><span class="line">      _link-&gt;end_offset=_link-&gt;data_offset;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Similarly, if we hit the next link in the chain, we&#x27;ve gone too far.*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">OP_UNLIKELY</span>(<span class="built_in">ogg_page_bos</span>(_og)))&#123;</span><br><span class="line">      <span class="keyword">if</span>(_link-&gt;head.pre_skip&gt;<span class="number">0</span>)<span class="keyword">return</span> OP_EBADTIMESTAMP;</span><br><span class="line">      <span class="comment">/*Set pcm_end and end_offset so we can skip the call to</span></span><br><span class="line"><span class="comment">         op_find_final_pcm_offset().*/</span></span><br><span class="line">      _link-&gt;pcm_file_offset=<span class="number">0</span>;</span><br><span class="line">      _link-&gt;pcm_start=_link-&gt;pcm_end=<span class="number">0</span>;</span><br><span class="line">      _link-&gt;end_offset=_link-&gt;data_offset;</span><br><span class="line">      <span class="comment">/*Tell the caller we&#x27;ve got a buffered page for them.*/</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Ignore pages from other streams (not strictly necessary, because of the</span></span><br><span class="line"><span class="comment">       checks in ogg_stream_pagein(), but saves some work).*/</span></span><br><span class="line">    <span class="keyword">if</span>(serialno!=(<span class="type">ogg_uint32_t</span>)<span class="built_in">ogg_page_serialno</span>(_og))<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">ogg_stream_pagein</span>(&amp;_of-&gt;os,_og);</span><br><span class="line">    <span class="comment">/*Bitrate tracking: add the header&#x27;s bytes here.</span></span><br><span class="line"><span class="comment">      The body bytes are counted when we consume the packets.*/</span></span><br><span class="line">    _of-&gt;bytes_tracked+=_og-&gt;header_len;</span><br><span class="line">    <span class="comment">/*Count the durations of all packets in the page.*/</span></span><br><span class="line">    <span class="keyword">do</span> total_duration=<span class="built_in">op_collect_audio_packets</span>(_of,durations);</span><br><span class="line">    <span class="comment">/*Ignore holes.*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">OP_UNLIKELY</span>(total_duration&lt;<span class="number">0</span>));</span><br><span class="line">    op_count=_of-&gt;op_count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(op_count&lt;=<span class="number">0</span>);</span><br><span class="line">  <span class="comment">/*We found the first page with a completed audio data packet: actually look</span></span><br><span class="line"><span class="comment">     at the granule position.</span></span><br><span class="line"><span class="comment">    RFC 3533 says, &quot;A special value of -1 (in two&#x27;s complement) indicates that</span></span><br><span class="line"><span class="comment">     no packets finish on this page,&quot; which does not say that a granule</span></span><br><span class="line"><span class="comment">     position that is NOT -1 indicates that some packets DO finish on that page</span></span><br><span class="line"><span class="comment">     (even though this was the intention, libogg itself violated this intention</span></span><br><span class="line"><span class="comment">     for years before we fixed it).</span></span><br><span class="line"><span class="comment">    The Ogg Opus specification only imposes its start-time requirements</span></span><br><span class="line"><span class="comment">     on the granule position of the first page with completed packets,</span></span><br><span class="line"><span class="comment">     so we ignore any set granule positions until then.*/</span></span><br><span class="line">  cur_page_gp=_of-&gt;op[op_count<span class="number">-1</span>].granulepos;</span><br><span class="line">  <span class="comment">/*But getting a packet without a valid granule position on the page is not</span></span><br><span class="line"><span class="comment">     okay.*/</span></span><br><span class="line">  <span class="keyword">if</span>(cur_page_gp==<span class="number">-1</span>)<span class="keyword">return</span> OP_EBADTIMESTAMP;</span><br><span class="line">  cur_page_eos=_of-&gt;op[op_count<span class="number">-1</span>].e_o_s;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">OP_LIKELY</span>(!cur_page_eos))&#123;</span><br><span class="line">    <span class="comment">/*The EOS flag wasn&#x27;t set.</span></span><br><span class="line"><span class="comment">      Work backwards from the provided granule position to get the starting PCM</span></span><br><span class="line"><span class="comment">       offset.*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">OP_UNLIKELY</span>(<span class="built_in">op_granpos_add</span>(&amp;pcm_start,cur_page_gp,-total_duration)&lt;<span class="number">0</span>))&#123;</span><br><span class="line">      <span class="comment">/*The starting granule position MUST not be smaller than the amount of</span></span><br><span class="line"><span class="comment">         audio on the first page with completed packets.*/</span></span><br><span class="line">      <span class="keyword">return</span> OP_EBADTIMESTAMP;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">/*The first page with completed packets was also the last.*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">OP_LIKELY</span>(<span class="built_in">op_granpos_add</span>(&amp;pcm_start,cur_page_gp,-total_duration)&lt;<span class="number">0</span>))&#123; <span class="comment">//这里会拿当前的ganule_pos和算出来的duration的应该有的sample来对比，若小，则返回异常；</span></span><br><span class="line">      <span class="comment">/*If there&#x27;s less audio on the page than indicated by the granule</span></span><br><span class="line"><span class="comment">         position, then we&#x27;re doing end-trimming, and the starting PCM offset</span></span><br><span class="line"><span class="comment">         is zero by spec mandate.*/</span></span><br><span class="line">      pcm_start=<span class="number">0</span>;</span><br><span class="line">      <span class="comment">/*However, the end-trimming MUST not ask us to trim more samples than</span></span><br><span class="line"><span class="comment">         exist after applying the pre-skip.*/</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">OP_UNLIKELY</span>(<span class="built_in">op_granpos_cmp</span>(cur_page_gp,_link-&gt;head.pre_skip)&lt;<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> OP_EBADTIMESTAMP;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*Timestamp the individual packets.*/</span></span><br><span class="line">  prev_packet_gp=pcm_start;</span><br><span class="line">  <span class="keyword">for</span>(pi=<span class="number">0</span>;pi&lt;op_count;pi++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur_page_eos)&#123;</span><br><span class="line">      <span class="type">ogg_int64_t</span> diff;</span><br><span class="line">      <span class="built_in">OP_ALWAYS_TRUE</span>(!<span class="built_in">op_granpos_diff</span>(&amp;diff,cur_page_gp,prev_packet_gp));</span><br><span class="line">      diff=durations[pi]-diff;</span><br><span class="line">      <span class="comment">/*If we have samples to trim...*/</span></span><br><span class="line">      <span class="keyword">if</span>(diff&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*If we trimmed the entire packet, stop (the spec says encoders</span></span><br><span class="line"><span class="comment">           shouldn&#x27;t do this, but we support it anyway).*/</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">OP_UNLIKELY</span>(diff&gt;durations[pi]))<span class="keyword">break</span>;</span><br><span class="line">        _of-&gt;op[pi].granulepos=prev_packet_gp=cur_page_gp;</span><br><span class="line">        <span class="comment">/*Move the EOS flag to this packet, if necessary, so we&#x27;ll trim the</span></span><br><span class="line"><span class="comment">           samples.*/</span></span><br><span class="line">        _of-&gt;op[pi].e_o_s=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Update the granule position as normal.*/</span></span><br><span class="line">    <span class="built_in">OP_ALWAYS_TRUE</span>(!<span class="built_in">op_granpos_add</span>(&amp;_of-&gt;op[pi].granulepos,</span><br><span class="line">     prev_packet_gp,durations[pi]));</span><br><span class="line">    prev_packet_gp=_of-&gt;op[pi].granulepos;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*Update the packet count after end-trimming.*/</span></span><br><span class="line">  _of-&gt;op_count=pi;</span><br><span class="line">  _of-&gt;cur_discard_count=_link-&gt;head.pre_skip;</span><br><span class="line">  _link-&gt;pcm_file_offset=<span class="number">0</span>;</span><br><span class="line">  _of-&gt;prev_packet_gp=_link-&gt;pcm_start=pcm_start;</span><br><span class="line">  _of-&gt;prev_page_offset=page_offset;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收集所有包的duration：</span></span><br><span class="line"><span class="comment">/*Grab all the packets currently in the stream state, and compute their</span></span><br><span class="line"><span class="comment">   durations.</span></span><br><span class="line"><span class="comment">  _of-&gt;op_count is set to the number of packets collected.</span></span><br><span class="line"><span class="comment">  [out] _durations: Returns the durations of the individual packets.</span></span><br><span class="line"><span class="comment">  Return: The total duration of all packets, or OP_HOLE if there was a hole.*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> opus_int32 <span class="title">op_collect_audio_packets</span><span class="params">(OggOpusFile *_of,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">int</span> _durations[<span class="number">255</span>])</span></span>&#123;</span><br><span class="line">  opus_int32 total_duration;</span><br><span class="line">  <span class="type">int</span>        op_count;</span><br><span class="line">  <span class="comment">/*Count the durations of all packets in the page.*/</span></span><br><span class="line">  op_count=<span class="number">0</span>;</span><br><span class="line">  total_duration=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*This takes advantage of undocumented libogg behavior that returned</span></span><br><span class="line"><span class="comment">       ogg_packet buffers are valid at least until the next page is</span></span><br><span class="line"><span class="comment">       submitted.</span></span><br><span class="line"><span class="comment">      Relying on this is not too terrible, as _none_ of the Ogg memory</span></span><br><span class="line"><span class="comment">       ownership/lifetime rules are well-documented.</span></span><br><span class="line"><span class="comment">      But I can read its code and know this will work.*/</span></span><br><span class="line">    ret=<span class="built_in">ogg_stream_packetout</span>(&amp;_of-&gt;os,_of-&gt;op+op_count);</span><br><span class="line">    <span class="keyword">if</span>(!ret)<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">OP_UNLIKELY</span>(ret&lt;<span class="number">0</span>))&#123;</span><br><span class="line">      <span class="comment">/*We shouldn&#x27;t get holes in the middle of pages.*/</span></span><br><span class="line">      <span class="built_in">OP_ASSERT</span>(op_count==<span class="number">0</span>);</span><br><span class="line">      <span class="comment">/*Set the return value and break out of the loop.</span></span><br><span class="line"><span class="comment">        We want to make sure op_count gets set to 0, because we&#x27;ve ingested a</span></span><br><span class="line"><span class="comment">         page, so any previously loaded packets are now invalid.*/</span></span><br><span class="line">      total_duration=OP_HOLE;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Unless libogg is broken, we can&#x27;t get more than 255 packets from a</span></span><br><span class="line"><span class="comment">       single page.*/</span></span><br><span class="line">    <span class="built_in">OP_ASSERT</span>(op_count&lt;<span class="number">255</span>);</span><br><span class="line">    _durations[op_count]=<span class="built_in">op_get_packet_duration</span>(_of-&gt;op[op_count].packet,<span class="comment">//返回的duration是packet的duration,若一个packet多个frame，要按照*来算；</span></span><br><span class="line">     _of-&gt;op[op_count].bytes);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">OP_LIKELY</span>(_durations[op_count]&gt;<span class="number">0</span>))&#123;</span><br><span class="line">      <span class="comment">/*With at most 255 packets on a page, this can&#x27;t overflow.*/</span></span><br><span class="line">      total_duration+=_durations[op_count++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Ignore packets with an invalid TOC sequence.*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op_count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">/*But save the granule position, if there was one.*/</span></span><br><span class="line">      _of-&gt;op[op_count<span class="number">-1</span>].granulepos=_of-&gt;op[op_count].granulepos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _of-&gt;op_pos=<span class="number">0</span>;</span><br><span class="line">  _of-&gt;op_count=op_count;</span><br><span class="line">  <span class="keyword">return</span> total_duration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解析toc:</span><br><span class="line"><span class="comment">/*Returns the duration of the packet (in samples at 48 kHz), or a negative</span></span><br><span class="line"><span class="comment">   value on error.*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">op_get_packet_duration</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *_data,<span class="type">int</span> _len)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> nframes;</span><br><span class="line">  <span class="type">int</span> frame_size;</span><br><span class="line">  <span class="type">int</span> nsamples;</span><br><span class="line">  nframes=<span class="built_in">opus_packet_get_nb_frames</span>(_data,_len);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">OP_UNLIKELY</span>(nframes&lt;<span class="number">0</span>))<span class="keyword">return</span> OP_EBADPACKET;</span><br><span class="line">  frame_size=<span class="built_in">opus_packet_get_samples_per_frame</span>(_data,<span class="number">48000</span>);</span><br><span class="line">  nsamples=nframes*frame_size; <span class="comment">//一个packet的采样大小等于 toc的config中解析出来的每frame samples * 一个packet中的frames数量，</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">OP_UNLIKELY</span>(nsamples&gt;<span class="number">120</span>*<span class="number">48</span>))<span class="keyword">return</span> OP_EBADPACKET; <span class="comment">//一packet不能大于120ms</span></span><br><span class="line">  <span class="keyword">return</span> nsamples;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析toc中的count:看是1packet封了几个frame</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">opus_packet_get_nb_frames</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> packet[], opus_int32 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> count;</span><br><span class="line">   <span class="keyword">if</span> (len&lt;<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> OPUS_BAD_ARG;</span><br><span class="line">   count = packet[<span class="number">0</span>]&amp;<span class="number">0x3</span>;</span><br><span class="line">   <span class="keyword">if</span> (count==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (count!=<span class="number">3</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (len&lt;<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">return</span> OPUS_INVALID_PACKET;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> packet[<span class="number">1</span>]&amp;<span class="number">0x3F</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析toc中的config，拿到具体的ms，即一帧是多少ms--&gt;一帧多少sample</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">opus_packet_get_samples_per_frame</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *data,</span></span></span><br><span class="line"><span class="params"><span class="function">      opus_int32 Fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> audiosize;</span><br><span class="line">   <span class="keyword">if</span> (data[<span class="number">0</span>]&amp;<span class="number">0x80</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      audiosize = ((data[<span class="number">0</span>]&gt;&gt;<span class="number">3</span>)&amp;<span class="number">0x3</span>);</span><br><span class="line">      audiosize = (Fs&lt;&lt;audiosize)/<span class="number">400</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((data[<span class="number">0</span>]&amp;<span class="number">0x60</span>) == <span class="number">0x60</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      audiosize = (data[<span class="number">0</span>]&amp;<span class="number">0x08</span>) ? Fs/<span class="number">50</span> : Fs/<span class="number">100</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      audiosize = ((data[<span class="number">0</span>]&gt;&gt;<span class="number">3</span>)&amp;<span class="number">0x3</span>);</span><br><span class="line">      <span class="keyword">if</span> (audiosize == <span class="number">3</span>)</span><br><span class="line">         audiosize = Fs*<span class="number">60</span>/<span class="number">1000</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         audiosize = (Fs&lt;&lt;audiosize)/<span class="number">100</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> audiosize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ogg文件实践"><a href="#ogg文件实践" class="headerlink" title="ogg文件实践:"></a>ogg文件实践:</h4><p>在网上暂时没有找到相关parse,可以用Audacity打开；或者自己写</p>
<h4 id="ogg相关库和官网，ref"><a href="#ogg相关库和官网，ref" class="headerlink" title="ogg相关库和官网，ref"></a>ogg相关库和官网，ref</h4><p><a href="https://www.xiph.org/ogg/doc/rfc3533.txt">https://www.xiph.org/ogg/doc/rfc3533.txt</a><br><a href="https://www.xiph.org/ogg/doc/libogg/datastructures.html">https://www.xiph.org/ogg/doc/libogg/datastructures.html</a><br><a href="https://rfc2cn.com/rfc3533.html">https://rfc2cn.com/rfc3533.html</a></p>
]]></content>
      <categories>
        <category>audio</category>
      </categories>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>audio_opus</title>
    <url>/2022/03/27/audio-opus/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="content"><a href="#content" class="headerlink" title="content:"></a>content:</h4><p>1 简介<br>2 opus编码总览<br>   控制参数：<span id="more"></span><br>      2.1. Control Parameters ………………………………….10<br>           2.1.1. Bitrate ……………………………………..10<br>           2.1.2. Number of Channels (Mono&#x2F;Stereo) ……………….11<br>           2.1.3. Audio Bandwidth ………………………………11<br>           2.1.4. Frame Duration ……………………………….11<br>           2.1.5. Complexity …………………………………..11<br>           2.1.6. Packet Loss Resilience ………………………..12<br>           2.1.7. Forward Error Correction (FEC) …………………12<br>           2.1.8. Constant&#x2F;Variable Bitrate ……………………..12<br>           2.1.9. Discontinuous Transmission (DTX) ……………….13<br>3 internal framing<br>       3.1. The TOC Byte ……………………………………….13<br>       3.2. Frame Packing ………………………………………16<br>           3.2.1. Frame Length Coding …………………………..16<br>           3.2.2. Code 0: One Frame in the Packet ………………..16<br>           3.2.3. Code 1: Two Frames in the Packet, Each with<br>                  Equal Compressed Size …………………………17<br>           3.2.4. Code 2: Two Frames in the Packet, with<br>                  Different Compressed Sizes …………………….17<br>           3.2.5. Code 3: A Signaled Number of Frames in the Packet ..18<br>      3.3. Examples …………………………………………..21<br>      3.4. Receiving Malformed Packets ………………………….22<br>4 opus decoder<br> 4.1. Range Decoder ………………………………………23<br>           4.1.1. Range Decoder Initialization …………………..25<br>           4.1.2. Decoding Symbols ……………………………..25<br>           4.1.3. Alternate Decoding Methods …………………….27<br>           4.1.4. Decoding Raw Bits …………………………….29<br>           4.1.5. Decoding Uniformly Distributed Integers …………29<br>           4.1.6. Current Bit Usage …………………………….30<br>      4.2. SILK Decoder ……………………………………….32<br>           4.2.1. SILK Decoder Modules ………………………….32<br>           4.2.2. LP Layer Organization …………………………33<br>           4.2.3. Header Bits ………………………………….35<br>           4.2.4. Per-Frame LBRR Flags ………………………….36<br>           4.2.5. LBRR Frames ………………………………….36<br>           4.2.6. Regular SILK Frames …………………………..37<br>           4.2.7. SILK Frame Contents …………………………..37<br>                  4.2.7.1. Stereo Prediction Weights ……………..40<br>                  4.2.7.2. Mid-Only Flag ………………………..42<br>                  4.2.7.3. Frame Type …………………………..43<br>                  4.2.7.4. Subframe Gains ……………………….44<br>                  4.2.7.5. Normalized Line Spectral Frequency<br>                           (LSF) and Linear Predictive Coding (LPC)<br>                           Coeffieients …………………………46<br>                  4.2.7.6. Long-Term Prediction (LTP) Parameters …..74<br>                  4.2.7.7. Linear Congruential Generator (LCG) Seed ..86<br>                  4.2.7.8. Excitation …………………………..86<br>                  4.2.7.9. SILK Frame Reconstruction ……………..98<br>           4.2.8. Stereo Unmixing ……………………………..102<br>           4.2.9. Resampling ………………………………….103<br>      4.3. CELT Decoder ………………………………………104<br>           4.3.1. Transient Decoding …………………………..108<br>           4.3.2. Energy Envelope Decoding ……………………..108<br>           4.3.3. Bit Allocation ………………………………110<br>           4.3.4. Shape Decoding ………………………………116<br>           4.3.5. Anti-collapse Processing ……………………..120<br>           4.3.6. Denormalization ……………………………..121<br>           4.3.7. Inverse MDCT ………………………………..121<br>      4.4. Packet Loss Concealment (PLC) ……………………….122<br>           4.4.1. Clock Drift Compensation ……………………..122<br>      4.5. Configuration Switching …………………………….123<br>           4.5.1. Transition Side Information (Redundancy) ……….124<br>           4.5.2. State Reset …………………………………127<br>           4.5.3. Summary of Transitions ……………………….128<br>5 opus encoder<br>     5.1. Range Encoder ……………………………………..132<br>           5.1.1. Encoding Symbols …………………………….133<br>           5.1.2. Alternate Encoding Methods ……………………134<br>           5.1.3. Encoding Raw Bits ……………………………135<br>           5.1.4. Encoding Uniformly Distributed Integers ………..135<br>           5.1.5. Finalizing the Stream ………………………..135<br>           5.1.6. Current Bit Usage ……………………………136<br>      5.2. SILK Encoder ………………………………………136<br>           5.2.1. Sample Rate Conversion ……………………….137<br>           5.2.2. Stereo Mixing ……………………………….137<br>           5.2.3. SILK Core Encoder ……………………………138<br>      5.3. CELT Encoder ………………………………………150<br>           5.3.1. Pitch Pre-filter …………………………….150<br>           5.3.2. Bands and Normalization ………………………151<br>           5.3.3. Energy Envelope Quantization ………………….151<br>           5.3.4. Bit Allocation ………………………………151<br>           5.3.5. Stereo Decisions …………………………….152<br>           5.3.6. Time-Frequency Decision ………………………153<br>           5.3.7. Spreading Values Decision …………………….153<br>           5.3.8. Spherical Vector Quantization …………………154<br>6. Conformance ……………………………………………155<br>      6.1. Testing …………………………………………..155<br>      6.2. Opus Custom ……………………………………….156<br>7. Security Considerations …………………………………157<br>8. Acknowledgements ……………………………………….158<br>9. References …………………………………………….159<br>     9.1. Normative References ……………………………….159<br>     9.2. Informative References ……………………………..159</p>
<h4 id="opus简述："><a href="#opus简述：" class="headerlink" title="opus简述："></a>opus简述：</h4><ul>
<li><p>Opus编解码器是一种实时交互式音频编解码器，旨在满足[要求]中所述的要求。它由一个基于线性预测（LP）[LPC]的层和一个基于改进的离散余弦变换（MDCT）[MDCT]的层组成。使用两层的主要思想如下：在语音中，<br>线性预测技术（如code - excited linear prediction 码激励线性预测，或CELP）比变换（如MDCT）域技术更有效地编码低频，而音乐和更高的语音频率则相反。因此，具有两个可用层的编解码器可以在比单独使用其中一个更宽的范围内运行，并且通过组合它们可以实现比单独使用其中一个更好的质量。</p>
</li>
<li><p>本规范的主要规范性部分由附录A中的源代码提供。尽管编码器和解码器共享大量代码，但本软件的解码器部分是规范性的。第6节提供了解码器一致性测试。解码器包含大量需要精确执行的整数和定点算法，包括所有舍入考虑，因此任何有用的规范都需要特定于域的符号语言来充分定义这些操作。此外，必须解决符号表示和包含的引用实现之间的任何冲突。出于兼容性和可测试性的实际原因，在任何不一致的情况下，给予参考实现优先权都是有利的。C语言也是最广泛理解的、人类可读的机器行为符号表示之一。由于这些原因，此RFC使用参考实现作为编解码器的唯一符号表示。</p>
</li>
<li><p>虽然符号表示是明确和完整的，但它并不总是理解编解码器操作的最简单方法。因此，本文档还以散文的形式描述了编解码器的重要部分，并借此机会解释了设计中许多更令人惊讶的元素背后的基本原理。这些描述旨在准确且信息丰富，但普通英语的局限性有时会导致歧义，因此预计读者将始终在阅读符号表示的同时阅读这些描述。为此目的，提供了大量实施参考。这些描述有时在顺序上或通过数学简化与参考不同，因为这种偏差使得解释更容易理解。例如，参考实现中的右移和左移操作通常使用除法和除法来描述</p>
</li>
</ul>
<h5 id="1-1符号约定："><a href="#1-1符号约定：" class="headerlink" title="1.1符号约定："></a>1.1符号约定：</h5><p>编解码器中的各种操作需要位精确的定点行为，即使在编写浮点实现时也是如此。符号“Q<n>”，其中n是整数，表示定点数字中小数点右侧的二进制位数。例如，16位字中的有符号Q14值可以表示从-2.0到1.999938964875（包括-2.0）的值。此符号仅供参考。当描述算术时，总是对基础整数进行运算。例如，文本将明确指示乘法后所需的任何移位。</p>
<p>文本中包含的表达式遵循C运算符规则和优先级，但语法“x**y”表示x升为y的幂。本文还使用了以下功能。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1</span>.<span class="number">1</span>.  <span class="built_in">min</span>(x,y)</span><br><span class="line"></span><br><span class="line">   The smallest of two values x and y.</span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span>.<span class="number">2</span>.  <span class="built_in">max</span>(x,y)</span><br><span class="line"></span><br><span class="line">   The largest of two values x and y.</span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span>.<span class="number">3</span>.  <span class="built_in">clamp</span>(lo,x,hi)</span><br><span class="line"></span><br><span class="line">                     <span class="built_in">clamp</span>(lo,x,hi) = <span class="built_in">max</span>(lo,<span class="built_in">min</span>(x,hi))</span><br><span class="line"></span><br><span class="line">   With this definition, <span class="keyword">if</span> lo &gt; hi, then lo is returned.</span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span>.<span class="number">4</span>.  <span class="built_in">sign</span>(x)</span><br><span class="line"></span><br><span class="line">   The sign of x, <span class="selector-tag">i</span><span class="selector-class">.e</span>.,</span><br><span class="line"></span><br><span class="line">                                    ( -<span class="number">1</span>,  x &lt; <span class="number">0</span></span><br><span class="line">                          <span class="built_in">sign</span>(x) = &lt;  <span class="number">0</span>,  x == <span class="number">0</span></span><br><span class="line">                                    (  <span class="number">1</span>,  x &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span>.<span class="number">5</span>.  <span class="built_in">abs</span>(x)</span><br><span class="line"></span><br><span class="line">   The absolute value of x, <span class="selector-tag">i</span><span class="selector-class">.e</span>.,</span><br><span class="line"></span><br><span class="line">                             <span class="built_in">abs</span>(x) = <span class="built_in">sign</span>(x)*x</span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span>.<span class="number">6</span>.  <span class="built_in">floor</span>(f)</span><br><span class="line"></span><br><span class="line">   The largest integer z such that z &lt;= f.</span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span>.<span class="number">7</span>.  <span class="built_in">ceil</span>(f)</span><br><span class="line"></span><br><span class="line">   The smallest integer z such that z &gt;= f.</span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span>.<span class="number">8</span>.  <span class="built_in">round</span>(f)</span><br><span class="line"></span><br><span class="line">   The integer z nearest to f, with ties rounded towards negative</span><br><span class="line">   infinity, <span class="selector-tag">i</span><span class="selector-class">.e</span>.,</span><br><span class="line"></span><br><span class="line">                           <span class="built_in">round</span>(f) = <span class="built_in">ceil</span>(f - <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span>.<span class="number">9</span>.  <span class="built_in">log2</span>(f)</span><br><span class="line"></span><br><span class="line">   The base-two logarithm of f.</span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span>.<span class="number">10</span>.  <span class="built_in">ilog</span>(n)</span><br><span class="line"></span><br><span class="line">   The minimum number of bits required to store <span class="selector-tag">a</span> positive integer n <span class="keyword">in</span></span><br><span class="line">   binary, or <span class="number">0</span> <span class="keyword">for</span> <span class="selector-tag">a</span> non-positive integer n.</span><br><span class="line"></span><br><span class="line">                              ( <span class="number">0</span>,                 n &lt;= <span class="number">0</span></span><br><span class="line">                    <span class="built_in">ilog</span>(n) = &lt;</span><br><span class="line">                              ( <span class="built_in">floor</span>(<span class="built_in">log2</span>(n))+<span class="number">1</span>,  n &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   Examples:</span><br><span class="line"></span><br><span class="line">   o  <span class="built_in">ilog</span>(-<span class="number">1</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   o  <span class="built_in">ilog</span>(<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   o  <span class="built_in">ilog</span>(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   o  <span class="built_in">ilog</span>(<span class="number">2</span>) = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">   o  <span class="built_in">ilog</span>(<span class="number">3</span>) = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">   o  <span class="built_in">ilog</span>(<span class="number">4</span>) = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-Opus编解码器概述："><a href="#2-Opus编解码器概述：" class="headerlink" title="2 Opus编解码器概述："></a>2 Opus编解码器概述：</h4><p>Opus编解码器从6 kbit&#x2F;s窄带单声道语音扩展到510 kbit&#x2F;s全波段立体声音乐，算法延迟从5 ms到65.2 ms。在任何给定时间，LP层、MDCT层或两者都可能处于活动状态。它可以在所有不同的操作模式之间无缝切换，使其具有很大的灵活性以适应不同的内容和网络条件，而无需重新协商当前会话。编解码器允许输入和输出各种音频带宽，定义如下：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+----------------------+-----------------+-------------------------+</span><br><span class="line">   |<span class="string"> Abbreviation         </span>|<span class="string"> Audio Bandwidth </span>|<span class="string"> Sample Rate (Effective) </span>|</span><br><span class="line">   +----------------------+-----------------+-------------------------+</span><br><span class="line">   |<span class="string"> NB (narrowband)      </span>|<span class="string">           4 kHz </span>|<span class="string">                   8 kHz </span>|</span><br><span class="line">   |<span class="string">                      </span>|<span class="string">                 </span>|<span class="string">                         </span>|</span><br><span class="line">   |<span class="string"> MB (medium-band)     </span>|<span class="string">           6 kHz </span>|<span class="string">                  12 kHz </span>|</span><br><span class="line">   |<span class="string">                      </span>|<span class="string">                 </span>|<span class="string">                         </span>|</span><br><span class="line">   |<span class="string"> WB (wideband)        </span>|<span class="string">           8 kHz </span>|<span class="string">                  16 kHz </span>|</span><br><span class="line">   |<span class="string">                      </span>|<span class="string">                 </span>|<span class="string">                         </span>|</span><br><span class="line">   |<span class="string"> SWB (super-wideband) </span>|<span class="string">          12 kHz </span>|<span class="string">                  24 kHz </span>|</span><br><span class="line">   |<span class="string">                      </span>|<span class="string">                 </span>|<span class="string">                         </span>|</span><br><span class="line">   |<span class="string"> FB (fullband)        </span>|<span class="string">      20 kHz (*) </span>|<span class="string">                  48 kHz </span>|</span><br><span class="line">   +----------------------+-----------------+-------------------------+</span><br><span class="line">                          表1</span><br></pre></td></tr></table></figure>
<p>（*）尽管采样定理允许带宽高达采样率的一半，但Opus从未对20 kHz以上的音频进行编码，因为这是公认的人类听力上限。  </p>
<ul>
<li><p>Opus定义了有效采样率为24 kHz的超宽带（SWB），与其他一些使用32 kHz的音频编码标准不同。选择这一点有很多原因。MDCT层中的频带布局自然允许跳过12 kHz以上频率的系数，但不允许仅将那些超过16 kHz的频率完全丢弃。24 kHz的采样率也使得MDCT层中的重采样更容易，因为24均匀地除以48，并且当24 kHz足够时，它可以节省其他处理中的计算，例如声学回波消除（AEC）。对频带布局进行实验性更改，以允许16 kHz截止（32 kHz有效采样率）显示在其他采样率下存在潜在的质量下降，并且在典型比特率下，使用这种截止而不是在全频带（FB）模式下编码所节省的比特数非常少。因此，如果应用程序希望处理以32 kHz采样的信号，则应仅使用FB。</p>
</li>
<li><p>LP层基于SILK编解码器[SILK]。它支持10毫秒到60毫秒的NB、MB或WB音频和帧大小，并且需要额外的5毫秒前瞻以进行噪声整形估计。采样率转换可能需要额外的小延迟（高达1.5 ms）。与Vorbis[Vorbis-WEBSITE]和许多其他现代编解码器一样，SILK天生就是为可变比特率（VBR）编码而设计的，尽管编码器也可以产生恒定比特率（CBR）流。Opus中使用的SILK版本实质上是从Skype先前部署的独立SILK编解码器修改而来的，与之不兼容。本文档不用于定义该格式，但对原始SILK编解码器感兴趣的人应该查看[SILK]。</p>
</li>
<li><p>MDCT层基于受限能量重叠变换（CELT）编解码器[CELT]。它支持NB、WB、SWB或FB音频,并且其帧大小从2.5 ms到20 ms，并且由于MDCT窗口重叠，需要额外的2.5 ms前瞻。CELT编解码器本质上是为CBR编码而设计的，但与许多CBR编解码器不同，它不限于一组预定速率。它在内部分配位来精确地填充任何给定的目标预算，编码器可以通过每帧改变目标来生成VBR流。当音频带宽为WB或更低时，MDCT层不用于语音，因为它在那里没有用处。另一方面，非语音信号并不总是使用线性预测进行充分编码。因此，MDCT层应用于音乐信号。</p>
</li>
<li><p>“混合”模式允许以10或20 ms的帧大小和SWB或FB音频带宽同时使用两层。LP层通过将信号重采样到WB来对低频进行编码。随后是MDCT层，对信号的高频部分进行编码。两者之间的截止频率为8 kHz，即最大WB音频带宽。在MDCT层中，所有低于8 kHz的频带都被丢弃，因此两层之间没有编码冗余。</p>
</li>
<li><p>采样率（与实际音频带宽相反）可在编码器和解码器侧独立选择，例如，全频带(fullband)信号可解码为宽带(wideband)，反之亦然。这种方法确保发送方和接收方始终可以互操作，而不管其实际音频硬件的功能如何。在内部，LP层始终以音频带宽两倍的采样率运行，最高可达16 kHz，它将继续用于SWB和FB。解码器只需重新采样其输出，以支持不同的采样率。MDCT层始终以48 kHz的采样率在内部运行。由于所有支持的采样率均匀地划分该速率，并且由于解码器可以容易地将频域中频谱的高频部分归零，因此它可以简单地抽取MDCT层输出，以非常便宜地实现其他支持的采样率。</p>
</li>
<li><p>在转换到普通的、期望的输出采样率之后，解码器将两层的输出简单地相加。为了补偿各层所需的不同前瞻性，CELT编码器输入额外延迟2.7毫秒。这确保低频和高频同时到达。编码器可以通过使用较少的噪声整形前瞻或在LP层中使用更简单的重采样器来减少额外延迟，但这会降低质量。然而，在编码器中不能减少CELT层中的基本2.5 ms前瞻，因为MDCT重叠需要它，其大小由解码器固定。</p>
</li>
<li><p>这两层都使用相同的熵编码器，避免了它们之间“填充位”的浪费。这种混合方法使得CBR和VBR编码都可以很容易地支持。尽管LP层是VBR，但MDCT层的位分配可以通过使用LP层未使用的所有位来生成最终的CBR流。</p>
</li>
</ul>
<h5 id="2-1-控制参数："><a href="#2-1-控制参数：" class="headerlink" title="2.1 控制参数："></a>2.1 控制参数：</h5><p>Opus编解码器包括许多控制参数，这些参数可以在编解码器的常规操作期间动态更改，而不会中断从编码器到解码器的音频流。这些参数仅影响编码器，因为它们对比特流的任何影响都在带内发出信号，使得解码器可以在没有带外信号的情况下解码任何Opus流。任何Opus实现都可以添加或修改这些控制参数，而不会影响互操作性。参考编码器中最重要的编码器控制参数如下所示。</p>
<h6 id="2-1-1-比特率"><a href="#2-1-1-比特率" class="headerlink" title="2.1.1. 比特率"></a>2.1.1. 比特率</h6><p>Opus支持从6 kbit&#x2F;s到510 kbit&#x2F;s的所有比特率。所有其他参数相等时，比特率越高，质量越高。对于20 ms的帧大小，以下是各种配置中OPU的比特率“最佳点”：<br>o 8-12 kbit&#x2F;s for NB speech,<br>o 16-20 kbit&#x2F;s for WB speech,<br>o 28-40 kbit&#x2F;s for FB speech,<br>o 48-64 kbit&#x2F;s for FB mono music, and<br>o 64-128 kbit&#x2F;s for FB stereo music.</p>
<h6 id="2-1-2-通道数（单声道-x2F-立体声）"><a href="#2-1-2-通道数（单声道-x2F-立体声）" class="headerlink" title="2.1.2 通道数（单声道&#x2F;立体声）"></a>2.1.2 通道数（单声道&#x2F;立体声）</h6><p>Opus可以在单个流中传输单声道或立体声帧。在立体声解码器中解码单声道帧时，左声道和右声道是相同的，在单声道解码器中解码立体声帧时，单声道输出是左声道和右声道的平均值。在某些情况下，希望以单声道编码立体声输入流（例如，因为比特率太低，无法以足够的质量编码立体声）。编码的通道数可以实时选择，但默认情况下，参考编码器会尝试在给定当前比特率的情况下做出最佳决策。</p>
<h6 id="2-1-3-音频带宽"><a href="#2-1-3-音频带宽" class="headerlink" title="2.1.3. 音频带宽"></a>2.1.3. 音频带宽</h6><p>Opus支持的音频带宽如表1所示。就像信道数量一样，任何解码器都可以对在任何带宽上编码的音频进行解码。例如，以8khz工作的任何Opus解码器可以解码FB Opus帧，并且以48khz工作的任何Opus解码器可以解码NB帧。类似地，参考编码器可以获取48 kHz输入信号并将其编码为NB。音频带宽越高，达到可接受质量所需的比特率越高。音频带宽可以实时明确指定，但默认情况下，参考编码器会尝试在给定当前比特率的情况下做出最佳带宽决策。</p>
<h6 id="2-1-4-帧持续时间"><a href="#2-1-4-帧持续时间" class="headerlink" title="2.1.4. 帧持续时间"></a>2.1.4. 帧持续时间</h6><p>Opus可以对2.5、5、10、20、40或60毫秒的帧进行编码。它还可以将多个帧组合成高达120毫秒的数据包。对于实时应用程序，每秒发送更少的数据包可以降低比特率，因为它减少了IP、UDP和RTP报头的开销。然而，它增加了延迟和对数据包丢失的敏感性，因为丢失一个数据包就意味着丢失更大的音频块。增加帧持续时间也会略微提高编码效率，但对于大于20 ms的帧大小，增益会变小。因此，对于大多数应用，20 ms帧是一个不错的选择。</p>
<h6 id="2-1-5-复杂性"><a href="#2-1-5-复杂性" class="headerlink" title="2.1.5. 复杂性"></a>2.1.5. 复杂性</h6><p>Opus编码过程的各个方面都可以在CPU复杂性和质量&#x2F;比特率之间进行权衡。在参考编码器中，使用0到10之间的整数选择复杂度，其中0是最低复杂度，10是最高复杂度。可能出现此类权衡的计算示例如下：</p>
<ul>
<li>The order of the pitch analysis whitening filter [WHITENING],基音分析白化滤波器的阶数[白化]，</li>
<li>The order of the short-term noise shaping filter,短期噪声整形滤波器的阶数</li>
<li>The number of states in delayed decision quantization of the residual signal, and 剩余信号的延迟判决量化中的状态数，以及</li>
<li>The use of certain bitstream features such as variable time-frequency resolution and the pitch post-filter.某些比特流特性的使用，如可变时频分辨率和基音后置滤波器。</li>
</ul>
<h6 id="2-1-6-丢包恢复能力"><a href="#2-1-6-丢包恢复能力" class="headerlink" title="2.1.6. 丢包恢复能力"></a>2.1.6. 丢包恢复能力</h6><p>音频编解码器通常利用帧间相关性来降低比特率，但要以错误传播为代价：丢失一个数据包后，需要接收多个数据包，解码器才能准确地重建语音信号。Opus利用帧间相关性的程度可以动态调整，以在比特率和错误传播量之间进行权衡。</p>
<h6 id="2-1-7-前向纠错（FEC）"><a href="#2-1-7-前向纠错（FEC）" class="headerlink" title="2.1.7. 前向纠错（FEC）"></a>2.1.7. 前向纠错（FEC）</h6><p>提供抗分组丢失鲁棒性的另一种机制是带内前向纠错（FEC）。被确定为包含感知上重要的语音信息（例如启动或瞬态）的分组以较低的比特率再次编码，并且该重新编码的信息被添加到后续分组中。</p>
<h6 id="2-1-8-恒定-x2F-可变比特率"><a href="#2-1-8-恒定-x2F-可变比特率" class="headerlink" title="2.1.8. 恒定&#x2F;可变比特率"></a>2.1.8. 恒定&#x2F;可变比特率</h6><p>Opus在使用默认的可变比特率（VBR）操作时效率更高。当需要通过相对较慢的连接进行低延迟传输时，也可以使用受限VBR。这以模拟“比特库”的方式使用VBR，相当于MP3（MPEG 1，第3层）和AAC（高级音频编码）所称的CBR（即，由于比特库而不是真正的CBR）。在某些（罕见）应用中，需要恒定比特率（CBR）。在CBR模式下运行有两个主要原因：</p>
<ul>
<li>当传输仅支持每个压缩帧的固定大小时，或</li>
<li>当加密用于高度受限（例如，是&#x2F;否，录制的提示）或高度敏感[SRTP-VBR]的音频流时。<br>即使使用敏感数据，只要变化不是由输入信号驱动的（例如，为了匹配不断变化的网络条件），比特率仍然可以变化。要实现这一点，应用程序仍应在CBR模式下运行Opus，但在每个数据包之前更改目标速率。</li>
</ul>
<h6 id="2-1-9-不连续传输（DTX）"><a href="#2-1-9-不连续传输（DTX）" class="headerlink" title="2.1.9. 不连续传输（DTX）"></a>2.1.9. 不连续传输（DTX）</h6><p>不连续传输（DTX）在静音或背景噪声期间降低比特率。启用DTX时，每400毫秒仅对一帧进行编码。</p>
<h4 id="3-内部组帧："><a href="#3-内部组帧：" class="headerlink" title="3 内部组帧："></a>3 内部组帧：</h4><p>Opus编码器产生“数据包”，每个数据包都是一组连续的字节，将作为单个单元传输。这里描述的数据包不包括诸如IP、UDP或RTP头之类的东西，它们通常在传输层数据包中找到。一个数据包可以包含多个音频帧，只要它们共享一组公共参数，包括操作模式、音频带宽、帧大小和通道计数（单声道与立体声）。本节描述了这些参数和用于将多个帧打包到单个数据包中的内部帧的可能组合。这种组帧不是自我界定的。相反，它假设较低的层（例如UDP或RTP[RFC3550]或Ogg[RFC3533]或Matroska[Matroska-WEBSITE]）将传输数据包的长度（以字节为单位），并使用此信息来减少数据包本身的帧开销。解码器实现必须支持本节中描述的帧。附录B中描述了框架的另一种自定界变体。该变体的支持是可选的。</p>
<p>本文档中的所有位图都对位进行了编号，因此位0是第一个字节的最高有效位，位7是最低有效位。因此，第8位是第二字节的最高有效位，等等。格式良好的Opus数据包遵守某些要求，标记为下面的[R1]到[R7]。第3.4节总结了这些问题以及处理格式错误数据包的适当方法。</p>
<h5 id="3-1-TOC字节-（单字节）"><a href="#3-1-TOC字节-（单字节）" class="headerlink" title="3.1 TOC字节 （单字节）"></a>3.1 TOC字节 （单字节）</h5><p>格式良好的Opus数据包必须至少包含一个字节[R1]。该字节形成一个目录（TOC）头，该头表示给定数据包使用的各种模式和配置中的哪一种。它由配置号“config”、立体声标志“s”和帧计数代码“c”组成，如图1所示。下面是对这些字段的描述。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code"> 0</span></span><br><span class="line"><span class="section"> 0 1 2 3 4 5 6 7</span></span><br><span class="line"><span class="section">+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="section">| config  |s| c |</span></span><br><span class="line"><span class="section">+-+-+-+-+-+-+-+-+</span></span><br><span class="line">图1:TOC字节</span><br></pre></td></tr></table></figure>

<ul>
<li><p>TOC字节的前五位标记为“config”，对32种可能的操作模式、音频带宽和帧大小配置之一进行编码。As described, the LP (SILK) layer and MDCT (CELT) layer can be combined in three possible operating modes:</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">   1.  A SILK-only mode for use in low bitrate connections with an audio bandwidth of WB(wideband) or less,</span><br><span class="line">   2.  A Hybrid (SILK+CELT) mode for SWB(super-wideband) or FB(fullband) speech at medium bitrates, and</span><br><span class="line">   3.  A CELT-only mode for very low delay speech transmission as well  as music transmission (NB(narrowband) to FB).</span><br><span class="line">   32种可能的配置分别标识数据包使用哪种操作模式，以及音频带宽和帧大小。表2列出了每个配置的参数。</span><br><span class="line">   +-----------------------+-----------+-----------+-------------------+</span><br><span class="line">   |<span class="string"> Configuration         </span>|<span class="string"> Mode      </span>|<span class="string"> Bandwidth </span>|<span class="string"> Frame Sizes       </span>|</span><br><span class="line">   |<span class="string"> Number(s)             </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   +-----------------------+-----------+-----------+-------------------+</span><br><span class="line">   |<span class="string"> 0...3                 </span>|<span class="string"> SILK-only </span>|<span class="string"> NB        </span>|<span class="string"> 10, 20, 40, 60 ms </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 4...7                 </span>|<span class="string"> SILK-only </span>|<span class="string"> MB        </span>|<span class="string"> 10, 20, 40, 60 ms </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 8...11                </span>|<span class="string"> SILK-only </span>|<span class="string"> WB        </span>|<span class="string"> 10, 20, 40, 60 ms </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 12...13               </span>|<span class="string"> Hybrid    </span>|<span class="string"> SWB       </span>|<span class="string"> 10, 20 ms         </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 14...15               </span>|<span class="string"> Hybrid    </span>|<span class="string"> FB        </span>|<span class="string"> 10, 20 ms         </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 16...19               </span>|<span class="string"> CELT-only </span>|<span class="string"> NB        </span>|<span class="string"> 2.5, 5, 10, 20 ms </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 20...23               </span>|<span class="string"> CELT-only </span>|<span class="string"> WB        </span>|<span class="string"> 2.5, 5, 10, 20 ms </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 24...27               </span>|<span class="string"> CELT-only </span>|<span class="string"> SWB       </span>|<span class="string"> 2.5, 5, 10, 20 ms </span>|</span><br><span class="line">   |<span class="string">                       </span>|<span class="string">           </span>|<span class="string">           </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string"> 28...31               </span>|<span class="string"> CELT-only </span>|<span class="string"> FB        </span>|<span class="string"> 2.5, 5, 10, 20 ms </span>|</span><br><span class="line">   +-----------------------+-----------+-----------+-------------------+</span><br><span class="line">        </span><br><span class="line">Table 2: TOC Byte Configuration Parameters</span><br><span class="line">每个范围内的配置编号(e.g., 0...3 for NB SILK-only)以相同的顺序对应不同的frame size选择。例如，配置0的帧大小为10毫秒，配置3的帧大小为60毫秒。</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来的一bit，表示是否为立体声：  One additional bit, labeled “s”, signals mono vs. stereo, with 0indicating mono and 1 indicating stereo.</p>
</li>
<li><p>接下来的两位，表示一个packet有几个frame:The remaining two bits of the TOC byte, labeled “c”, code the number of frames per packet (codes 0 to 3) as follows:</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">o  <span class="number">0</span>: <span class="number">1</span> frame <span class="keyword">in</span> <span class="keyword">the</span> packet</span><br><span class="line">o  <span class="number">1</span>: <span class="number">2</span> frames <span class="keyword">in</span> <span class="keyword">the</span> packet, <span class="keyword">each</span> <span class="keyword">with</span> equal compressed size</span><br><span class="line">o  <span class="number">2</span>: <span class="number">2</span> frames <span class="keyword">in</span> <span class="keyword">the</span> packet, <span class="keyword">with</span> different compressed sizes</span><br><span class="line">o  <span class="number">3</span>: <span class="keyword">an</span> arbitrary <span class="built_in">number</span> <span class="keyword">of</span> frames <span class="keyword">in</span> <span class="keyword">the</span> packet</span><br><span class="line"></span><br><span class="line">This document refers <span class="built_in">to</span> <span class="keyword">a</span> packet <span class="keyword">as</span> <span class="keyword">a</span> code <span class="number">0</span> packet, code <span class="number">1</span> packet,</span><br><span class="line">etc., based <span class="keyword">on</span> <span class="title">the</span> <span class="title">value</span> <span class="title">of</span> <span class="string">&quot;c&quot;</span>.</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-2-frame-packing-帧如何打包："><a href="#3-2-frame-packing-帧如何打包：" class="headerlink" title="3.2 frame packing 帧如何打包："></a>3.2 frame packing 帧如何打包：</h5><p>本节描述如何根据TOC字节中每个可能的“c”值打包帧。</p>
<h6 id="3-2-1-Frame-Length-Coding"><a href="#3-2-1-Frame-Length-Coding" class="headerlink" title="3.2.1  Frame Length Coding"></a>3.2.1  Frame Length Coding</h6><p>当数据包包含多个VBR帧（即code 2或3）时，这些帧中的一个或多个的压缩长度用一个或两个字节序列表示，第一个字节的含义如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">o</span> <span class="number">0</span>：无帧（不连续传输（DTX）或丢失数据包）</span><br><span class="line"><span class="attribute">o</span> <span class="number">1</span>…<span class="number">251</span>：帧的长度（字节）</span><br><span class="line"><span class="attribute">o</span> <span class="number">252</span>…<span class="number">255</span>:需要第二个字节。总长度为（第二个字节*<span class="number">4</span>）+第一个字节</span><br></pre></td></tr></table></figure>
<ul>
<li><p>特殊长度0表示没有可用的帧，这可能是因为它在传输过程中被某个中介丢弃，也可能是因为编码器选择不传输它。任何模式下的任何Opus帧的长度都可以为0。</p>
</li>
<li><p>最大可表示长度为255*4+255&#x3D;1275字节。对于20 ms帧，这表示510 kbit&#x2F;s的比特率，这大约是无损压缩全波段立体声音乐的最高有用速率。除此之外，无损编解码器更合适。它也大致是MDCT层的最大可用速率，因为此后不久，由于码本大小的限制，质量不再随附加比特而提高。</p>
</li>
<li><p>对于VBR数据包中的最后一帧或CBR数据包中的任何帧，不传输长度，因为可以从数据包的总大小和数据包中所有其他数据的大小推断长度。但是，任何单个帧的长度不得超过1275字节[R2]，以允许通过网关、会议网桥或其他软件重新打包。</p>
</li>
</ul>
<h6 id="3-2-2-Code-0-One-Frame-in-the-Packet-数据包中只有一个帧"><a href="#3-2-2-Code-0-One-Frame-in-the-Packet-数据包中只有一个帧" class="headerlink" title="3.2.2. Code 0: One Frame in the Packet 数据包中只有一个帧"></a>3.2.2. Code 0: One Frame in the Packet 数据包中只有一个帧</h6><p>对于code 0数据包，TOC字节后面紧跟着单个帧的N-1字节压缩数据（其中N是数据包的大小），如图2所示。</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">    <span class="number"> 0 </span>                 <span class="number"> 1 </span>                 <span class="number"> 2 </span>                  3</span><br><span class="line">     <span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     | config  |s|0|0|                                               |</span><br><span class="line">     +-+-+-+-+-+-+-+-+                                               |</span><br><span class="line">     |                    Compressed frame<span class="number"> 1 </span>(N-1 bytes)...          :</span><br><span class="line">     :                                                               |</span><br><span class="line">     |                                                               |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        </span><br><span class="line">Figure 2: A Code<span class="number"> 0 </span>Packet</span><br></pre></td></tr></table></figure>

<h6 id="3-2-3-code-1：数据包中的两个帧，每个帧具有相同的压缩大小"><a href="#3-2-3-code-1：数据包中的两个帧，每个帧具有相同的压缩大小" class="headerlink" title="3.2.3. code 1：数据包中的两个帧，每个帧具有相同的压缩大小"></a>3.2.3. code 1：数据包中的两个帧，每个帧具有相同的压缩大小</h6><p>对于code 1数据包，TOC字节后面紧跟第一帧的（N-1）&#x2F;2字节压缩数据，然后紧跟第二帧的（N-1）&#x2F;2字节压缩数据，如图3所示。对于所有code 1数据包，可用于压缩数据的有效负载字节数N-1必须为偶数[R3]。</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">    <span class="number"> 0 </span>                 <span class="number"> 1 </span>                 <span class="number"> 2 </span>                  3</span><br><span class="line">     <span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     | config  |s|0|1|                                               |</span><br><span class="line">     +-+-+-+-+-+-+-+-+                                               :</span><br><span class="line">     |             Compressed frame<span class="number"> 1 </span>((N-1)/2 bytes)...             |</span><br><span class="line">     :                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |                               |                               |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               :</span><br><span class="line">     |             Compressed frame<span class="number"> 2 </span>((N-1)/2 bytes)...             |</span><br><span class="line">     :                                               +-+-+-+-+-+-+-+-+</span><br><span class="line">     |                                               |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        </span><br><span class="line">Figure 3: A Code<span class="number"> 1 </span>Packet</span><br></pre></td></tr></table></figure>

<h6 id="3-2-4-code-2：数据包中有两个帧，压缩后大小不同"><a href="#3-2-4-code-2：数据包中有两个帧，压缩后大小不同" class="headerlink" title="3.2.4. code 2：数据包中有两个帧，压缩后大小不同"></a>3.2.4. code 2：数据包中有两个帧，压缩后大小不同</h6><ul>
<li><p>对于code 2数据包，TOC字节后面是一个单字节或双字节序列，指示第一帧的长度（图4中标记为N1），然后是第一帧的N1字节压缩数据。剩余的N-N1-2或N-N1-3字节是第二帧的压缩数据。这如图4所示。<br>code 2数据包必须包含足够的字节来表示有效长度。例如，1字节code 2数据包始终无效，而第二个字节在252…255范围内的2字节code 2数据包也无效。</p>
</li>
<li><p>第一帧的长度N1也必须不大于对所有code 2分组解码该长度后剩余有效载荷的大小[R4]。例如，这使得第二个字节在1…251范围内的2字节code 2数据包也无效（唯一有效的2字节code 2数据包是两个帧的长度均为零的数据包）。</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">    <span class="number"> 0 </span>                 <span class="number"> 1 </span>                 <span class="number"> 2 </span>                  3</span><br><span class="line">     <span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     | config  |s|1|0| N1 (1-2 bytes):                               |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               :</span><br><span class="line">     |               Compressed frame<span class="number"> 1 </span>(N1 bytes)...                |</span><br><span class="line">     :                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |                               |                               |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |</span><br><span class="line">     |                     Compressed frame 2...                     :</span><br><span class="line">     :                                                               |</span><br><span class="line">     |                                                               |</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        </span><br><span class="line">Figure 4: A Code<span class="number"> 2 </span>Packet</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="Code-3-A-Signaled-Number-of-Frames-in-the-Packet"><a href="#Code-3-A-Signaled-Number-of-Frames-in-the-Packet" class="headerlink" title="Code 3: A Signaled Number of Frames in the Packet"></a>Code 3: A Signaled Number of Frames in the Packet</h6><ul>
<li><p>Code 3 packets将帧的数量填充在包中的字段，as well as additional padding,称为“Opus padding”，以指示此填充是在Opus层而不是在传输层添加的。</p>
</li>
<li><p>Code 3数据包必须至少有2个字节[R6，R7]。TOC字节后接一个字节，该字节编码数据包中的帧数，其位为2到7（图5中标记为“M”），位1表示是否插入了Opus填充（图5中标记为“p”），位0表示VBR（图5中标记为“v”）。M不得为零，且数据包中包含的音频持续时间不得超过120毫秒[R5]。这将任何帧大小的最大帧计数限制为48（对于2.5毫秒帧），对于较长的帧大小，限制为较低。图5显示了帧计数字节的布局。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">  <span class="number">0</span></span><br><span class="line">                              <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">                             +-+-+-+-+-+-+-+-+</span><br><span class="line">                             |<span class="type">v</span>|<span class="type">p</span>|     <span class="type">M</span>     |</span><br><span class="line">                             <span class="type">+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="type">        </span></span><br><span class="line"><span class="type">Figure</span> <span class="number">5</span>: The frame count byte</span><br></pre></td></tr></table></figure></li>
<li><p>使用Opus填充时，填充的字节数以帧计数字节后的字节进行编码。0…254的值表示除了0…254字节之外，还包括0…254字节的填充</p>
</li>
<li><p>用于指示填充大小的字节。如果值为255，则附加填充的大小为254字节，加上下一个字节中编码的填充值。在这种情况下，数据包中必须至少还有一个字节[R6，R7]。额外的填充字节出现在数据包的末尾，编码器必须将其设置为零，以避免创建隐蔽通道。但是，解码器必须接受填充字节的任何值。</p>
</li>
<li><p>尽管这种编码提供了多种方法来指示给定数量的填充字节，但每种方法都使用不同数量的字节来指示填充大小，因此将以不同的量增加总数据包大小。例如，要向数据包添加255个字节，请将填充位p设置为1，在帧计数字节后插入一个值为254的单字节，并将值为零的254个填充字节追加到数据包的末尾。要向数据包添加256个字节，请将填充位设置为1，在帧计数字节后插入两个字节，分别为255和0，并在数据包末尾追加254个填充字节，值为0。通过多次使用值255，可以创建任意特定、所需大小的数据包。设P为用于指示填充大小的报头字节数加上填充字节数（即，P为添加到数据包的总字节数）。那么，P必须不大于N-2[R6，R7]。</p>
</li>
<li><p>在CBR情况下，让R&#x3D;N-2-P为减去（可选）填充后数据包中剩余的字节数。然后，每个帧的压缩长度（以字节为单位）等于R&#x2F;M。值R必须是M[R6]的非负整数倍。所有M帧的压缩数据如下，每个大小为R&#x2F;M字节，如图6所示。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line">      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |<span class="string"> config  </span>|<span class="string">s</span>|<span class="string">1</span>|<span class="string">1</span>|<span class="string">0</span>|<span class="string">p</span>|<span class="string">     M     </span>|<span class="string">  Padding length (Optional)    :</span></span><br><span class="line"><span class="string">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">     </span>|<span class="string">                                                               </span>|</span><br><span class="line">     :               Compressed frame 1 (R/M bytes)...               :</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     :               Compressed frame 2 (R/M bytes)...               :</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     :                              ...                              :</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     :               Compressed frame M (R/M bytes)...               :</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     :                  Opus Padding (Optional)...                   |<span class="string"></span></span><br><span class="line"><span class="string">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">Figure 6: A CBR Code 3 Packet</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在VBR的情况下，（可选）填充长度后面是M-1帧长度（在图7中由“N1”到“N[M-1]”表示），每个帧长度按照如上所述的一个或两个字节序列进行编码。删除（可选）填充后，数据包必须包含足够的M-1长度数据，并且这些长度的总和不得大于解码后数据包中剩余的字节数[R7]。所有M帧的压缩数据如下，每个帧由指定数量的字节组成，最终帧在最终填充之前消耗任何剩余字节，如图6所示。报头字节数（TOC字节、帧计数字节、填充长度字节和帧长度字节）加上前M-1帧本身的信号长度，再加上填充的信号长度不得大于数据包总大小N。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |<span class="string"> config  </span>|<span class="string">s</span>|<span class="string">1</span>|<span class="string">1</span>|<span class="string">1</span>|<span class="string">p</span>|<span class="string">     M     </span>|<span class="string"> Padding length (Optional)     :</span></span><br><span class="line"><span class="string">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">     : N1 (1-2 bytes): N2 (1-2 bytes):     ...       :     N[M-1]    </span>|</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     :               Compressed frame 1 (N1 bytes)...                :</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     :               Compressed frame 2 (N2 bytes)...                :</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     :                              ...                              :</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     :                     Compressed frame M...                     :</span><br><span class="line">     |<span class="string">                                                               </span>|</span><br><span class="line">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     :                  Opus Padding (Optional)...                   |<span class="string"></span></span><br><span class="line"><span class="string">     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">Figure 7: A VBR Code 3 Packet</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-3-examples"><a href="#3-3-examples" class="headerlink" title="3.3 examples:"></a>3.3 examples:</h5><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">Simplest case, one NB mono<span class="number"> 20 </span>ms SILK frame:</span><br><span class="line"><span class="number"> 0 </span>                 <span class="number"> 1 </span>                 <span class="number"> 2 </span>                  3</span><br><span class="line">   <span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   |   <span class="number"> 1 </span>   |0|0|0|               compressed data...              :</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        </span><br><span class="line">                             Figure 8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   Two FB mono<span class="number"> 5 </span>ms CELT frames of the same compressed size:</span><br><span class="line"></span><br><span class="line">   <span class="number"> 0 </span>                 <span class="number"> 1 </span>                 <span class="number"> 2 </span>                  3</span><br><span class="line">   <span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   |  <span class="number"> 29 </span>   |0|0|1|               compressed data...              :</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">                                 Figure 9</span><br><span class="line"></span><br><span class="line">   Two FB mono<span class="number"> 20 </span>ms Hybrid frames of different compressed size:</span><br><span class="line"></span><br><span class="line">   <span class="number"> 0 </span>                 <span class="number"> 1 </span>                 <span class="number"> 2 </span>                  3</span><br><span class="line">   <span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   |  <span class="number"> 15 </span>   |0|1|1|1|0|    <span class="number"> 2 </span>    |      N1       |               |</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |</span><br><span class="line">   |                       compressed data...                      :</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">                                 Figure 10</span><br><span class="line"></span><br><span class="line">   Four FB stereo<span class="number"> 20 </span>ms CELT frames of the same compressed size:</span><br><span class="line"></span><br><span class="line">   <span class="number"> 0 </span>                 <span class="number"> 1 </span>                 <span class="number"> 2 </span>                  3</span><br><span class="line">   <span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 0 </span>1</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   |  <span class="number"> 31 </span>   |1|1|1|0|0|    <span class="number"> 4 </span>    |      compressed data...       :</span><br><span class="line">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">                                 Figure 11</span><br></pre></td></tr></table></figure>

<h5 id="3-4-Receiving-Malformed-Packets-接收格式错误的数据包"><a href="#3-4-Receiving-Malformed-Packets-接收格式错误的数据包" class="headerlink" title="3.4 Receiving Malformed Packets 接收格式错误的数据包"></a>3.4 Receiving Malformed Packets 接收格式错误的数据包</h5><p>接收方不得将违反上述任何规则的数据包作为正常Opus数据包进行处理。它们是为将来的应用程序保留的，例如带内标头（包含元数据等）。违反这些约束的数据包可能会导致该规范的实现将其视为格式错误并丢弃。<br>此处总结了这些约束条件，以供参考：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[R1]  Packets are <span class="keyword">at</span> least one byte.</span><br><span class="line"></span><br><span class="line">[R2]  No implicit frame <span class="built_in">length</span> <span class="keyword">is</span> larger than <span class="number">1275</span> bytes.</span><br><span class="line"></span><br><span class="line">[R3]  Code <span class="number">1</span> packets have an odd total <span class="built_in">length</span>, N, so <span class="keyword">that</span> (N<span class="number">-1</span>)/<span class="number">2</span> <span class="keyword">is</span></span><br><span class="line">      an <span class="built_in">integer</span>.</span><br><span class="line"></span><br><span class="line">[R4]  Code <span class="number">2</span> packets have enough bytes <span class="keyword">after</span> <span class="keyword">the</span> TOC <span class="keyword">for</span> a valid</span><br><span class="line">      frame <span class="built_in">length</span>, <span class="keyword">and</span> <span class="keyword">that</span> <span class="built_in">length</span> <span class="keyword">is</span> no larger than <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span></span><br><span class="line">      bytes remaining <span class="keyword">in</span> <span class="keyword">the</span> packet.</span><br><span class="line"></span><br><span class="line">[R5]  Code <span class="number">3</span> packets <span class="keyword">contain</span> <span class="keyword">at</span> least one frame, <span class="keyword">but</span> no more than</span><br><span class="line">      <span class="number">120</span> ms <span class="keyword">of</span> audio total.</span><br><span class="line"></span><br><span class="line">[R6]  The <span class="built_in">length</span> <span class="keyword">of</span> a CBR code <span class="number">3</span> packet, N, <span class="keyword">is</span> <span class="keyword">at</span> least two bytes,</span><br><span class="line">      <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> bytes added <span class="keyword">to</span> indicate <span class="keyword">the</span> padding size plus <span class="keyword">the</span></span><br><span class="line">      trailing padding bytes themselves, P, <span class="keyword">is</span> no more than N<span class="number">-2</span>, <span class="keyword">and</span></span><br><span class="line">      <span class="keyword">the</span> frame <span class="built_in">count</span>, M, satisfies <span class="keyword">the</span> constraint <span class="keyword">that</span> (N<span class="number">-2</span>-P) <span class="keyword">is</span> a</span><br><span class="line">      non-negative <span class="built_in">integer</span> multiple <span class="keyword">of</span> M.</span><br><span class="line"></span><br><span class="line">[R7]  VBR code <span class="number">3</span> packets are large enough <span class="keyword">to</span> <span class="keyword">contain</span> all <span class="keyword">the</span> header</span><br><span class="line">      bytes (TOC byte, frame <span class="built_in">count</span> byte, any padding <span class="built_in">length</span> bytes,</span><br><span class="line">      <span class="keyword">and</span> any frame <span class="built_in">length</span> bytes), plus <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">first</span> M<span class="number">-1</span></span><br><span class="line">      frames, plus any trailing padding bytes.</span><br></pre></td></tr></table></figure>
<h4 id="Opus解码器"><a href="#Opus解码器" class="headerlink" title="Opus解码器"></a>Opus解码器</h4><p>The Opus decoder consists of two main blocks: the SILK decoder and the CELT decoder.<br>在任何给定时间，一个或两个SILK和CELT解码器都可能处于活动状态。Opus解码的输出是来自SILK和CELT解码器的输出的总和，在SILK侧具有适当的采样率转换和延迟补偿，在CELT侧具有可选的抽取（当解码到采样率小于48 kHz时），如下图所示。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">                     +---------+    +------------+</span><br><span class="line">                         |<span class="string">  SILK   </span>|<span class="string">    </span>|<span class="string">   Sample   </span>|</span><br><span class="line">                      +-&gt;|<span class="string"> Decoder </span>|<span class="string">---&gt;</span>|<span class="string">    Rate    </span>|<span class="string">----+</span></span><br><span class="line"><span class="string">Bit-    +---------+   </span>|<span class="string">  </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string"> Conversion </span>|<span class="string">    v</span></span><br><span class="line"><span class="string">stream  </span>|<span class="string">  Range  </span>|<span class="string">---+  +---------+    +------------+  /---\  Audio</span></span><br><span class="line"><span class="string">-------&gt;</span>|<span class="string"> Decoder </span>|<span class="string">                                     </span>|<span class="string"> + </span>|<span class="string">------&gt;</span></span><br><span class="line"><span class="string">        </span>|<span class="string">         </span>|<span class="string">---+  +---------+    +------------+  \---/</span></span><br><span class="line"><span class="string">        +---------+   </span>|<span class="string">  </span>|<span class="string">  CELT   </span>|<span class="string">    </span>|<span class="string"> Decimation </span>|<span class="string">    ^</span></span><br><span class="line"><span class="string">                      +-&gt;</span>|<span class="string"> Decoder </span>|<span class="string">---&gt;</span>|<span class="string"> (Optional) </span>|<span class="string">----+</span></span><br><span class="line"><span class="string">                         </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">            </span>|</span><br><span class="line">                         +---------+    +------------+</span><br></pre></td></tr></table></figure>
<p>more :<br><a href="https://datatracker.ietf.org/doc/html/rfc6716">https://datatracker.ietf.org/doc/html/rfc6716</a><br>参考翻译：<br><a href="https://rfc2cn.com/rfc6716.html">https://rfc2cn.com/rfc6716.html</a>  </p>
<p>ref:<br><a href="https://datatracker.ietf.org/doc/html/rfc6716">https://datatracker.ietf.org/doc/html/rfc6716</a><br><a href="https://xiph.org/ogg/doc/oggstream.html">https://xiph.org/ogg/doc/oggstream.html</a>  </p>
<h4 id="PS-Webrtc中相关代码："><a href="#PS-Webrtc中相关代码：" class="headerlink" title="PS Webrtc中相关代码："></a>PS Webrtc中相关代码：</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void WebRtcWrap::create<span class="constructor">OggFirstPage()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> oggString;</span><br><span class="line"></span><br><span class="line">    ogg_packet data;</span><br><span class="line"></span><br><span class="line">    ogg_page page;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> headString;</span><br><span class="line">    data.b_o_s = <span class="number">1</span>;</span><br><span class="line">    data.e_o_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    headString.append(<span class="string">&quot;OpusHead&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">char</span> version = <span class="number">1</span>;</span><br><span class="line">    headString.append(<span class="number">1</span>, version);</span><br><span class="line">    <span class="built_in">char</span> channels = <span class="number">2</span>;</span><br><span class="line">    headString.append(<span class="number">1</span>, channels);</span><br><span class="line">    <span class="built_in">char</span> padding = <span class="number">0</span>;</span><br><span class="line">    headString.append(<span class="number">2</span>, padding);</span><br><span class="line">    uint32_t sampleRate = <span class="number">48000</span>;</span><br><span class="line">    headString.append((<span class="built_in">char</span>*)&amp; sampleRate, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">char</span> gain = <span class="number">0</span>;</span><br><span class="line">    headString.append(<span class="number">2</span>, gain);</span><br><span class="line">    <span class="built_in">char</span> mapping = <span class="number">0</span>;</span><br><span class="line">    headString.append(<span class="number">1</span>, mapping);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//oggString.append((char*)rtpData.payLoad.data() + pRtpHeader-&gt;getHeaderLength(), rtpData.payLoad.size() - pRtpHeader-&gt;getHeaderLength());</span></span><br><span class="line">    data.packet = (unsigned <span class="built_in">char</span>*)headString.data<span class="literal">()</span>;</span><br><span class="line">    data.<span class="built_in">bytes</span> = headString.size<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    data.packetno = <span class="number">0</span>;</span><br><span class="line">    data.granulepos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ogg<span class="constructor">_stream_packetin(&amp;<span class="params">m_oggEncoder</span>, &amp;<span class="params">data</span>)</span>;</span><br><span class="line">    <span class="comment">//ogg_stream_flush(&amp;m_oggEncoder, &amp;page);</span></span><br><span class="line">    <span class="built_in">int</span> result = ogg<span class="constructor">_stream_flush(&amp;<span class="params">m_oggEncoder</span>, &amp;<span class="params">page</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">    &#123;</span><br><span class="line">        oggString.append((<span class="built_in">char</span>*)page.header, (<span class="built_in">int</span>)page.header_len);</span><br><span class="line">        oggString.append((<span class="built_in">char</span>*)page.body, (<span class="built_in">int</span>)page.body_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2nd packet</span></span><br><span class="line">    <span class="built_in">string</span> comment;</span><br><span class="line">    comment.append(<span class="string">&quot;OpusTags&quot;</span>);</span><br><span class="line">    uint32_t len = <span class="number">4</span>;</span><br><span class="line">    comment.append((<span class="built_in">char</span>*)&amp; len, <span class="number">4</span>);</span><br><span class="line">    comment.append(<span class="string">&quot;huya&quot;</span>);</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    comment.append((<span class="built_in">char</span>*)&amp; len, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    data.packet = (unsigned <span class="built_in">char</span>*)comment.data<span class="literal">()</span>;</span><br><span class="line">    data.<span class="built_in">bytes</span> = comment.size<span class="literal">()</span>;</span><br><span class="line">    data.packetno = <span class="number">1</span>;</span><br><span class="line">    data.b_o_s = <span class="number">0</span>;</span><br><span class="line">    data.e_o_s = <span class="number">0</span>;</span><br><span class="line">    data.granulepos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ogg<span class="constructor">_stream_packetin(&amp;<span class="params">m_oggEncoder</span>, &amp;<span class="params">data</span>)</span>;</span><br><span class="line">    result = ogg<span class="constructor">_stream_flush(&amp;<span class="params">m_oggEncoder</span>, &amp;<span class="params">page</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">    &#123;</span><br><span class="line">        oggString.append((<span class="built_in">char</span>*)page.header, (<span class="built_in">int</span>)page.header_len);</span><br><span class="line">        oggString.append((<span class="built_in">char</span>*)page.body, (<span class="built_in">int</span>)page.body_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fwrite(oggString.data(), oggString.size(), 1, m_fp);</span></span><br><span class="line">    <span class="comment">//fflush(m_fp);</span></span><br><span class="line"></span><br><span class="line">    m_oggFirstPageStr = oggString;</span><br><span class="line">    <span class="constructor">FUNLOG(Info, <span class="string">&quot;createOggFirstPage for uuid %s uid=%lu m_oggFirstPageStr size=%u&quot;</span>, <span class="params">m_uuid</span>.<span class="params">c_str</span>()</span>, m_uid, m_oggFirstPageStr.size<span class="literal">()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>audio</category>
      </categories>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>filesystem</title>
    <url>/2021/03/13/filesystem/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="文件系统："><a href="#文件系统：" class="headerlink" title="文件系统："></a>文件系统：</h2><h3 id="关于信息记载和存储的历史，现状和未来展望"><a href="#关于信息记载和存储的历史，现状和未来展望" class="headerlink" title="关于信息记载和存储的历史，现状和未来展望"></a>关于信息记载和存储的历史，现状和未来展望</h3><ul>
<li>本能信息存储：在原始时期，信息被基因记载，并向下传递，个体发生基因突变后，存活下来的个体，能将突变的基因信息保存下来，传递下来，从而进化；</li>
<li>口口相传：人类发明语言或者是类似的东西，然后将经验和信息一代代传递下来，通过人本身作为记录和存储；</li>
<li>文字的出现：直到文字和记载载体出现，比如帛书，纸等，文字以语句，文章，数字等被记录成竹简或书本，保存下来；</li>
<li>磁带记录：磁带的出现，提高了信息记载的便利性；<span id="more"></span></li>
<li>硬盘存储：硬盘的出现使得载体变多，而记录的形式也增强了，有文件系统，数据库等存储不同类型的媒介，而媒介也多种多样：文字，图片，视频等等；</li>
<li>现在出现了很多类型的文件系统，存储也不再是单机，有云，网络，使得存储的性能和效率得到进一步的提升；</li>
<li>未来：一方面随着信息的爆炸，往快，久，量大的方向继续进化；另一方面，针对不同的媒介有不同的存储支持；畅想，未来，存储可能会<br>变成像手机或其他智能硬件一样，成为人类通过外部工具进行进化的一种手段，而人类，可能也不再受限于记忆；</li>
<li>PS: 人类的意识存在，前世今生，和记忆存储关联密切，对失忆的人来讲，就像重新活过一样；</li>
</ul>
<h3 id="现代信息记载和存储分类：数据库和文件系统"><a href="#现代信息记载和存储分类：数据库和文件系统" class="headerlink" title="现代信息记载和存储分类：数据库和文件系统"></a>现代信息记载和存储分类：数据库和文件系统</h3><p>现代信息记载，效率高的主要是数据库和文件系统，前者提高了数据存储的效率，以及支持数据以某个形式方式组织，更有利于有效存取；<br>而后者，是比较原始的，支持的信息媒介更多，也支持各种系统，限制比较小，但是不利于数据的查阅；</p>
<h4 id="文件系统的分类："><a href="#文件系统的分类：" class="headerlink" title="文件系统的分类："></a>文件系统的分类：</h4><ul>
<li>单机文件系统</li>
<li>网络文件系统</li>
<li>分布式文件系统</li>
<li>并行文件系统等等；</li>
</ul>
<h3 id="文件系统的关注点：性能数据，IO，进程并发等；"><a href="#文件系统的关注点：性能数据，IO，进程并发等；" class="headerlink" title="文件系统的关注点：性能数据，IO，进程并发等；"></a>文件系统的关注点：性能数据，IO，进程并发等；</h3><ul>
<li>IO:</li>
<li>磁盘分配单位</li>
<li>碎片处理机制</li>
<li>带宽利用率</li>
<li>对多进程并发读写和交互式访问的性能，以及聚合读写带宽的能力；</li>
<li>文件的组织形式和访问方式：比如硬盘如何分区，文件如何组织等等，和存储硬件本身限制的关联，会影响硬件操作性能；<br>比如说<br>候选的磁盘分区方案：<br>  方案一： 255个盘面，C盘是0-100盘面， D盘是101-200个盘面,……<br>  方案二：3263个柱面，C盘0-1000个柱面，D盘1001-20001个柱面,……</li>
</ul>
<h3 id="硬盘的组成和读写机制"><a href="#硬盘的组成和读写机制" class="headerlink" title="硬盘的组成和读写机制"></a>硬盘的组成和读写机制</h3><h4 id="硬盘简介"><a href="#硬盘简介" class="headerlink" title="硬盘简介"></a>硬盘简介</h4><p>1、硬盘的物理结构一般由磁头与碟片、电动机、主控芯片与排线等部件组成；当主电动机带动碟片旋转时，副电动机带动一组（磁头）到相对应的碟片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与碟片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容。所有的盘片都固定在一个旋转轴上，这个轴即盘片主轴。而所有盘片之间是绝对平行的，在每个盘片的存储面上都有一个磁头，磁头与盘片之间的距离比头发 丝的直径还小。所有的磁头连在一个磁头控制器上，由磁头控制器负责各个磁头的运动。磁头可沿盘片的半径方向动作，而盘片以每分钟数千转到上万转的速度在高 速旋转，这样磁头就能对盘片上的指定位置进行数据的读写操作。</p>
<img src="/2021/03/13/filesystem/disk1.png" class="" title="disk1 about">

<h4 id="磁道（Track）"><a href="#磁道（Track）" class="headerlink" title="磁道（Track）"></a>磁道（Track）</h4><p>当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。信息以脉冲串的形式记录在这些轨迹中，这些同心圆不是连续记录数据，而是被划分成一段段的圆弧（扇区），这些圆弧 的角速度一样。</p>
<h4 id="柱面-（Cylinder）"><a href="#柱面-（Cylinder）" class="headerlink" title="柱面 （Cylinder）"></a>柱面 （Cylinder）</h4><p>在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。所有盘面上的同一磁道构成一个圆柱，通常称做柱面（Cylinder），每个圆柱上的磁头由上而下从“0”开始编号。数据的读&#x2F;写按柱面进行，即磁 头读&#x2F;写数据时首先在同一柱面内从“0”磁头开始进行操作，依次向下在同一柱面的不同盘面即磁头上进行操作，只在同一柱面所有的磁头全部读&#x2F;写完毕后磁头 才转移到下一柱面，因为选取磁头只需通过电子切换即可，而选取柱面则必须通过机械切换。电子切换相当快，比在机械上磁头向邻近磁道移动快得多，所以，数据 的读&#x2F;写按柱面进行，而不按盘面进行。也就是说，一个磁道写满数据后，就在同一柱面的下一个盘面来写，一个柱面写满后，才移到下一个磁道开始写数据。读数 据也按照这种方式进行，这样就提高了硬盘的读&#x2F;写效率。</p>
<h4 id="扇区（Sector）"><a href="#扇区（Sector）" class="headerlink" title="扇区（Sector）"></a>扇区（Sector）</h4><p>磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。<strong>硬盘的第一个扇区，叫做引导扇区</strong>。操作系统以扇区（Sector）形式将信息存储在硬盘上，每个扇区包括512个字节的数据和一些其他信息。注意扇区不是指的扇形那个区域，而是磁道的一段弧线；由下计算存储空间大小公式可知；</p>
<h4 id="磁头（Head）"><a href="#磁头（Head）" class="headerlink" title="磁头（Head）"></a>磁头（Head）</h4><p>在硬盘系 统中，硬盘的每一个盘片都有两个盘面（Side），即上、下盘面，一般每个盘面都会利 用，都可以存储数据。盘面号又叫磁头号，因为每一个有效盘面都有一个对应的读写磁头。</p>
<img src="/2021/03/13/filesystem/disk2.png" class="" title="disk2 about">

<h4 id="如何计算存储大小："><a href="#如何计算存储大小：" class="headerlink" title="如何计算存储大小："></a>如何计算存储大小：</h4><p>硬盘的大小是使用”磁头数 x 柱面数 x 扇区数 x 每个扇区的大小”这样的公式来计算的。其中，磁头数（Heads）表示硬盘共有几个磁头，也可以理解为硬盘有几个盘面，然后乘以 2；柱面数（Cylinders）表示硬盘每面盘片有几条磁道；扇区数（Sectors）表示每条磁道上有几个扇区；每个扇区的大小一般是 512Byte。<br>举个例子：在ubuntu上</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">root@ksance-ThinkPad-X201:~<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 320.1 GB,<span class="number"> 320072933376 </span>bytes</span><br><span class="line">255 heads,<span class="number"> 63 </span>sectors/track,<span class="number"> 38913 </span>cylinders, total<span class="number"> 625142448 </span>sectors</span><br><span class="line">Units = sectors of<span class="number"> 1 </span>*<span class="number"> 512 </span>=<span class="number"> 512 </span>bytes</span><br><span class="line">Sector size (logical/physical):<span class="number"> 512 </span>bytes /<span class="number"> 512 </span>bytes</span><br><span class="line">I/O size (minimum/optimal):<span class="number"> 512 </span>bytes /<span class="number"> 512 </span>bytes</span><br><span class="line">Disk identifier: 0x000e6df5</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *       <span class="number"> 2048 </span> <span class="number"> 617170943 </span> <span class="number"> 308584448 </span> <span class="number"> 83 </span> Linux</span><br><span class="line">/dev/sda2      <span class="number"> 617172990 </span> <span class="number"> 625141759 </span>   <span class="number"> 3984385 </span>  <span class="number"> 5 </span> Extended</span><br><span class="line">/dev/sda5      <span class="number"> 617172992 </span> <span class="number"> 625141759 </span>   <span class="number"> 3984384 </span> <span class="number"> 82 </span> Linux swap / Solaris</span><br><span class="line">该磁盘有255个heads，也就是说共有255个盘面。38913个柱面（cylinders），也就是说每个盘面上都有38913个磁道，<span class="number"> 63 </span>sectors/track说的是每个磁道上共有63个扇区。命令结果也给出了Sector size的值是512bytes。</span><br><span class="line">255盘面  * 38913柱面 * 63扇区 * 每个扇区512bytes = 320072933376bytes</span><br></pre></td></tr></table></figure>

<h4 id="磁盘的读写原理："><a href="#磁盘的读写原理：" class="headerlink" title="磁盘的读写原理："></a>磁盘的读写原理：</h4><p>系统将文件存储到磁盘上时，按柱面、磁头、扇区的方式进行，即最先是第1磁道的第一磁头下（也就是第1盘面的第一磁道）的所有扇区，然后，是同一柱面的下一磁头，……，一个柱面存储满后就推进到下一个柱面，直到把文件内容全部写入磁盘。  </p>
<p>系统也以相同的顺序读出数据。读出数据时通过告诉磁盘控制器要读出扇区所在的柱面号、磁头号和扇区号（物理地址的三个组成部分）进行。磁盘控制器则直接使磁头部件步进到相应的柱面，选通相应的磁头，等待要求的扇区移动到磁头下。在扇区到来时，磁盘控制器读出每个扇区的头标，把这些头标中的地址信息与 期待检出的磁头和柱面号做比较（即寻道），然后，寻找要求的扇区号。待磁盘控制器找到该扇区头标时，根据其任务是写扇区还是读扇区，来决定是转换写电路， 还是读出数据和尾部记录。找到扇区后，磁盘控制器必须在继续寻找下一个扇区之前对该扇区的信息进行后处理。如果是读数据，控制器计算此数据的ECC码，然 后，把ECC码与已记录的ECC码相比较。如果是写数据，控制器计算出此数据的ECC码，与数据一起存储。在控制器对此扇区中的数据进行必要处理期间，磁 盘继续旋转。其实我们的文件大多数的时候都是破碎的，在文件没有破碎的时候,摇臂只需要寻找1次磁道并由磁头进行读取,只需要1次就可以成功读取;但是如果文件破碎成11处,那么摇臂要来回寻找11次磁道磁头进行11次读取才能完整的读取这个文件,读取时间相对没有破碎的时候就变得冗长。   </p>
<p>因此，磁盘IO时的过程包括：</p>
<pre><code>第一步，首先是磁头径向移动来寻找数据所在的磁道。这部分时间叫寻道时间。  
第二步，找到目标磁道后通过盘面旋转，将目标扇区移动到磁头的正下方。  
第三步，向目标扇区读取或者写入数据。到此为止，一次磁盘IO完成，故：  
</code></pre>
<p>所以，单次磁盘IO时间 &#x3D; 寻道时间 + 旋转延迟 + 存取时间。   </p>
<pre><code>对于旋转延时，现在主流服务器上经常使用的是1W转/分钟的磁盘，每旋转一周所需的时间为60*1000/10000=6ms，故其旋转延迟为（0-6ms）。
对于存取时间，一般耗时较短，为零点几ms。
对于寻道时间，现代磁盘大概在3-15ms，其中寻道时间大小主要受磁头当前所在位置和目标磁道所在位置相对距离的影响。
</code></pre>
<h4 id="如何分区："><a href="#如何分区：" class="headerlink" title="如何分区："></a>如何分区：</h4><p>候选的磁盘分区方案：  </p>
<pre><code>方案一： 255个盘面，C盘是0-100盘面， D盘是101-200个盘面,……
方案二：3263个柱面，C盘0-1000个柱面，D盘1001-20001个柱面,……
</code></pre>
<p>其实采用哪一种，最主要看的是那种方式性能更快。因为同一分区下的数据经常会一起读取，假如采用第一种，那么这样磁头就需要在3000多个track间不停地跳来跳去，这样磁盘的寻道时间就会翻倍，磁盘性能就会下降。而对于方案二，假如对于磁盘C，只需要在磁头在1-1000个磁道间移动就可以了，大大降低了寻道时间。（实际上分区并不是从0开始的，磁盘的第一个磁道对应的柱面会被用来安装引导加载程序以及磁盘分区表）。所以，方案二的分区方式可以降低磁盘IO时间中的寻道时间部分，所以所有的操作系统采用的都是方案二，没有用方案一的。</p>
<h4 id="几类硬盘"><a href="#几类硬盘" class="headerlink" title="几类硬盘"></a>几类硬盘</h4><p>几类硬盘：<br>磁盘种类     最大IOPS     最大响应时间<br>ATA&#x2F;IDE     70     15ms<br>FC&#x2F;SAS     140~160     10ms<br>SSD&#x2F;EFD     2500     1ms<br>即IDE–&gt;SCSI即目前的机械硬盘-&gt;ssd即固态硬盘</p>
<h3 id="系统如何分区，格式化文件系统"><a href="#系统如何分区，格式化文件系统" class="headerlink" title="系统如何分区，格式化文件系统"></a>系统如何分区，格式化文件系统</h3><p>Linux 下磁盘命名和分区<br>在为主机添加硬盘前，首先要了解Linux系统下对硬盘和分区的命名方法。   </p>
<h4 id="1-磁盘命名"><a href="#1-磁盘命名" class="headerlink" title="1 磁盘命名"></a>1 磁盘命名</h4><p>在Linux下对 SCSI 和 SATA 设备是以 sd 命名的，第一个 scsi 设备是 sda，第二个是 sdb，依此类推。一般主板上有两个SCSI接口，因此一共可以安装四个SCSI设备。主 SCSI 上的两个设备分别对应 sda 和 sdb，第二个 SCSI 口上的两个设备对应 sdc 和 sdd。一般硬盘安装在主 SCSI 的主接口上，所以是 sda 或者 sdb，而光驱一般安装在第二个SCSI的主接口上，所以是 sdc。(IDE接口设备是用 hd 命名的，第一个设备是hda，第二个是hdb，依此类推。)</p>
<p>IDE 磁盘     描述    配置<br>&#x2F;dev&#x2F;hda     1st (Primary) IDE controller     Master<br>&#x2F;dev&#x2F;hdb     1st (Primary) IDE controller     Slave<br>&#x2F;dev&#x2F;hdc     2nd (Secondary) IDE controller     Master<br>&#x2F;dev&#x2F;hdd     2nd (Secondary) IDE controller     Slave  </p>
<h4 id="2磁盘分区"><a href="#2磁盘分区" class="headerlink" title="2磁盘分区"></a>2磁盘分区</h4><p>所谓的磁盘分区指的是告诉操作系统『我这颗磁盘在此分割槽可以存取的区域是由 A 磁柱到 B 磁柱之间的区块』， 如此一来操作系统就能够知道他可以在所指定的区块内进行文件数据的读&#x2F;写&#x2F;搜寻等动作了。 也就是说，磁盘分区意即指定分割槽的启始与结束磁柱就是了。  </p>
<p>分区表用于记录分区的信息<br>一个硬盘，有两种类型的分区表，一种传统流行的MBR，一种是GPT:<br>ref:<a href="http://www.newskj.org/kjxx/2017062994604.html">http://www.newskj.org/kjxx/2017062994604.html</a><br><strong>MBR</strong><br>（Master Boot Record，缩写：MBR），又叫做主引导扇区（主引导记录），是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。<br>MBR是由分区程序（如Fdisk，Parted）所产生的，它不依赖任何操作系统，而且硬盘引导程序也是可以改变的，从而能够实现多系统引导.<br>一个扇区是512字节，因此MBR的大小也是512字 节，其具体数据结构是：446个字节的引导代码、64个字节的分区表及2个字节的签名值”55AA”。<br>由于MBR的分区表只有64个字节，这决定了它只能 存储4个分区记录。这就是为什么一块硬盘最多只能有4个“主分区”的原因。  </p>
<p>我们已经知道了MBR中的分表区只能存放4个分区（即4个主分区），那系统是如何划分出4个以上的分区的呢？一种直白而简单的思路就是把其中一个主分区再进 行细分，衍生出一个二级分区表。对的，这个被用来二次分区的主分区就是“扩展分区”，它下面的二级分区就是“逻辑分区”  </p>
<h4 id="3linux和Windows"><a href="#3linux和Windows" class="headerlink" title="3linux和Windows:"></a>3linux和Windows:</h4><p>一个硬盘主分区至少有1个，最多4个，扩展分区可以没有，最多1个。且主分区+扩展分区总共不能超过4个。逻辑分区可以有若干个。<br>扩展分区是我们对逻辑分区的总称，只是一中称呼，通过分区助手等工具可以看到如E,F盘为逻辑分区；</p>
<p>在windows下激活的主分区是硬盘的启动分区，他是独立的，也是硬盘的第一个分区，正常分的话就是C区。<br> 在linux下主分区和逻辑分区都可以用来放系统，引导os开机，grub会兼容windows系统开机启动。<br>分出主分区后，其余的部分可以分成扩展分区，一般是剩下的部分全部分成扩展分区，也可以不全分，那剩的部分就浪费了。<br>但扩展分区是不能直接用的，他是以逻辑分区的方式来使用的，所以说扩展分区可分成若干逻辑分区。他们的关系是包含的关系，所有的逻辑分区都是扩展分区的一部分。<br>在linux中第一块硬盘分区为hda分区，主分区编号为hda1-4，逻辑分区从5开始。<br>硬盘的容量&#x3D;主分区的容量+扩展分区的容量<br>扩展分区的容量&#x3D;各个逻辑分区的容量之和，1个扩展分区-&gt;24个逻辑分区  </p>
<h4 id="4linux下进行分区的方法"><a href="#4linux下进行分区的方法" class="headerlink" title="4linux下进行分区的方法"></a>4linux下进行分区的方法</h4><p>当我们买到一块硬盘，里面空空如也，或者通过虚拟机进行创建虚拟硬盘时，如何进行分区？<br>当接入硬盘后：<br>1、通过ls &#x2F;dev&#x2F;sd* 查看所有硬盘  找到sdb或其他如hd等（根据硬盘类型来）<br>2、通过fdisk -l (root权限下) 查看未进行分区的硬盘<br>3、通过fdisk &#x2F;dev&#x2F;sdn(对应未分区的硬盘名）进行分区，依次选择后，完成；<br>4、格式化分区：mkfs.ext4 -L disk2 &#x2F;dev&#x2F;sdb 即对该分区创建文件系统；<br>5、挂载该分区 sudo mount -t ext4 &#x2F;dev&#x2F;sdb1&#x2F; &#x2F;mnt&#x2F;  </p>
<p>过程总结：<br>    创建：以某种方式格式化磁盘的过程就是在其之上建立一个文件系统的过程。创建文件系统时，会在磁盘的特定位置写入关于该文件系统的控制信息。<br>    注册：向内核报到，声明自己能被内核支持。一般在编译内核的时侯注册；也可以加载模块的方式手动注册。注册过程实 际上是将表示各实际文件系统的数据结构struct file_system_type 实例化。<br>    安装：也就是我们熟悉的mount操作，将文件系统加入到 Linux 的根文件系统的目录树结构上；这样文件系统才能被访问。<br>开机直接挂载<br>编辑 &#x2F;etc&#x2F;fstab 文件，添加：&#x2F;dev&#x2F;sda1 &#x2F;test ext3 defaults 1 1，重启则发选已经挂载上去。  </p>
<h4 id="5-linux和windows文件系统和分区关系"><a href="#5-linux和windows文件系统和分区关系" class="headerlink" title="5 linux和windows文件系统和分区关系"></a>5 linux和windows文件系统和分区关系</h4><p>每块硬盘都分为若干个分区，每个分区都有自己的文件系统。Windows为这些文件系统各自指定了一个字母。不过 GNU&#x2F;Linux 使用唯一的树形结构来管理文件，而每个文件系统都挂载于树形结构的某个位置。<br>正如 Windows 需要有 C: 驱动器一样，GNU&#x2F;Linux 必须能够将根文件系统挂载于文件树的根(&#x2F;)上。当根挂载完成之后，您就可以将其它文件系统挂载于树形结构各种挂载点上。根结构下的任何目录都可以作为挂载点，而您也可以将同一文件系统同时挂载于不同的挂载点上。挂载点实际上就是linux中的磁盘文件系统的入口目录：  </p>
<p>总结：从上面看，分区创建后需要格式化为某个类型的文件系统，所以分区和文件系统是一一对应的关系；</p>
<h3 id="linux文件系统架构："><a href="#linux文件系统架构：" class="headerlink" title="linux文件系统架构："></a>linux文件系统架构：</h3><h4 id="文件系统的概念和功能"><a href="#文件系统的概念和功能" class="headerlink" title="文件系统的概念和功能"></a>文件系统的概念和功能</h4><h5 id="wiki"><a href="#wiki" class="headerlink" title="wiki:"></a>wiki:</h5><p>计算机的文件系统是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易，文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。在写入新数据之前，用户不必关心硬盘上的那个块地址没有被使用，硬盘上的存储空间管理（分配和释放）功能由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中。<br>严格地说，文件系统是一套实现了数据的存储、分级组织、访问和获取等操作的抽象数据类型（Abstract data type）</p>
<h5 id="总结文件系统的功能："><a href="#总结文件系统的功能：" class="headerlink" title="总结文件系统的功能："></a>总结文件系统的功能：</h5><p>1、文件是放在硬盘中的，由物理作用写入的东西，而存放的东西需要管理，在使用时通过内存读入管理信息就能知道存放的内容，并进行进一步使用，<br>这个“管理” 就是文件系统；<br>2、文件系统提供：<br>     1) 硬盘文件的基本信息，文件基本信息，包括属性等；<br>     2) 提供管理文件接口，如删除，增加文件等等；  </p>
<p>3、从功能上可以这样分：从底层到用户层：  </p>
<ol>
<li>高速缓冲区的管理程序  –对硬盘等块设备的数据高速存取函数  driver层  </li>
<li>文件系统低层通用函数 –对文件索引节点的管理，磁盘数据块的分配和释放以及文件名和i节点的转换算法   </li>
<li>对文件中数据进行读写操作，包括对字符设备，管道，块读写文件中数据的访问  </li>
<li>文件系统调用接口的实现；–涉及文件打开，关闭，创建以及有关文件目录操作等的系统调用； VFS</li>
</ol>
<h5 id="查看："><a href="#查看：" class="headerlink" title="查看："></a>查看：</h5><p>我们在使用文件系统时，用到的大多是目录，文件，并不会去考虑实际的文件系统类型等，只有当比如插u盘的时候因为系统不支持u盘的文件系统显示不出来，才会去考虑这个问题；<br>那文件系统，和目录，文件是什么关系和区别？linux支持多种文件系统，比如ext系列，以及内存文件系统如procfs,它挂载在&#x2F;proc下，也就是说，&#x2F;proc这个路径和&#x2F;usr这个路径是不同的文件系统；<br>比如通过如下命令，可以知道路径对应的文件系统</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~$ mount | column -t</span><br><span class="line">/dev/sda1   on  /                         type  ext4             (rw,errors=remount-ro)</span><br><span class="line"><span class="keyword">proc</span><span class="title">        on</span>  /<span class="keyword">proc</span><span class="title">                     type</span> <span class="title"> proc</span>             (rw,noexec,nosuid,nodev)<span class="title"></span></span><br><span class="line"><span class="title">sysfs</span> <span class="title">      on</span>  /sys<span class="title">                      type</span> <span class="title"> sysfs</span>            (rw,noexec,nosuid,nodev)<span class="title"></span></span><br><span class="line"><span class="title">none</span> <span class="title">       on</span>  /sys/fs/cgroup<span class="title">            type</span> <span class="title"> tmpfs</span>            (rw)<span class="title"></span></span><br><span class="line"><span class="title">none</span> <span class="title">       on</span>  /sys/fs/fuse/connections<span class="title">  type</span> <span class="title"> fusectl</span>          (rw)<span class="title"></span></span><br><span class="line"><span class="title">none</span> <span class="title">       on</span>  /sys/kernel/debug<span class="title">         type</span> <span class="title"> debugfs</span>          (rw)<span class="title"></span></span><br><span class="line"><span class="title">none</span> <span class="title">       on</span>  /sys/kernel/security<span class="title">      type</span> <span class="title"> securityfs</span>       (rw)<span class="title"></span></span><br><span class="line"><span class="title">udev</span> <span class="title">       on</span>  /dev<span class="title">                      type</span> <span class="title"> devtmpfs</span>         (rw,mode=0755)<span class="title"></span></span><br><span class="line"><span class="title">devpts</span> <span class="title">     on</span>  /dev/pts<span class="title">                  type</span> <span class="title"> devpts</span>           (rw,noexec,nosuid,gid=5,mode=0620)<span class="title"></span></span><br><span class="line"><span class="title">tmpfs</span> <span class="title">      on</span>  /run<span class="title">                      type</span> <span class="title"> tmpfs</span>            (rw,noexec,nosuid,size=10%,mode=0755)<span class="title"></span></span><br><span class="line"><span class="title">none</span> <span class="title">       on</span>  /run/lock<span class="title">                 type</span> <span class="title"> tmpfs</span>            (rw,noexec,nosuid,nodev,size=5242880)<span class="title"></span></span><br><span class="line"><span class="title">none</span> <span class="title">       on</span>  /run/shm<span class="title">                  type</span> <span class="title"> tmpfs</span>            (rw,nosuid,nodev)<span class="title"></span></span><br><span class="line"><span class="title">none</span> <span class="title">       on</span>  /run/user<span class="title">                 type</span> <span class="title"> tmpfs</span>            (rw,noexec,nosuid,nodev,size=104857600,mode=0755)<span class="title"></span></span><br><span class="line"><span class="title">none</span> <span class="title">       on</span>  /sys/fs/pstore<span class="title">            type</span> <span class="title"> pstore</span>           (rw)<span class="title"></span></span><br><span class="line"><span class="title">systemd</span> <span class="title">    on</span>  /sys/fs/cgroup/systemd<span class="title">    type</span> <span class="title"> cgroup</span>           (rw,noexec,nosuid,nodev,none,name=systemd)<span class="title"></span></span><br><span class="line"><span class="title">gvfsd-fuse</span> <span class="title"> on</span>  /run/user/1000/gvfs<span class="title">       type</span> <span class="title"> fuse.gvfsd-fuse</span>  (rw,nosuid,nodev,user=think)</span><br><span class="line"></span><br><span class="line">以及：<span class="title"></span></span><br><span class="line"><span class="title">think@think-VirtualBox:~$</span> df -H<span class="title"></span></span><br><span class="line"><span class="title">Filesystem</span> <span class="title">     Size</span> <span class="title"> Used</span> Avail<span class="title"> Use%</span> Mounted<span class="title"> on</span></span><br><span class="line">udev            2.0G  4.1k  2.0G   1% /dev<span class="title"></span></span><br><span class="line"><span class="title">tmpfs</span>           415M  926k  414M   1% /run</span><br><span class="line">/dev/sda1        28G   25G  1.6G  95% /<span class="title"></span></span><br><span class="line"><span class="title">none</span>            4.1k     0  4.1k   0% /sys/fs/cgroup<span class="title"></span></span><br><span class="line"><span class="title">none</span>            5.3M     0  5.3M   0% /run/lock<span class="title"></span></span><br><span class="line"><span class="title">none</span>            2.1G   78k  2.1G   1% /run/shm<span class="title"></span></span><br><span class="line"><span class="title">none</span>            105M   66k  105M   1% /run/user</span><br></pre></td></tr></table></figure>


<h4 id="文件系统架构"><a href="#文件系统架构" class="headerlink" title="文件系统架构"></a>文件系统架构</h4><img src="/2021/03/13/filesystem/vfs0.png" class="" title="vfs0 about">

<p>VFS本质是什么？<br>linux为了支持各种文件系统，且在同时允许访问其他操作系统文件，linux内核在用户进程(或c库）和文件系统实现之间引入了一个抽象层，这个抽象层称为VFS;<br>VFS的任务：<br>一方面，提供一种操作文件，目录和其他对象的统一方法，另一方面，它必须能够与各种方法给出的具体文件系统达成妥协；<br>用户空间包含一些应用程序（例如，文件系统的使用者）和 GNU C 库（glibc），它们为文件系统调用（打开、读取、写和关闭）提供用户接口。系统调用接口的作用就像是交换器，它将系统调用从用户空间发送到内核空间中的适当端点。  </p>
<h4 id="文件系统的分类：-1"><a href="#文件系统的分类：-1" class="headerlink" title="文件系统的分类："></a>文件系统的分类：</h4><p>文件系统分3种：  </p>
<ol>
<li>基于磁盘的文件系统：如Ext2&#x2F;3&#x2F;4,Reiserfs,FAT,等，都是面向块的介质，需解决：如何将文件内容与结构信息存于目录层次结构上；从文件系统角度看，底层设备无非是存储块组成的一个列表，文件系统相当于对该列表实施一个适当的组织方案；  </li>
<li>虚拟文件系统：内核中生成，允许用户程序和内核信息通信的方法：&#x2F;proc等；是内核在内存上建立的一个层次化的文件结构，文件大小为0；  </li>
<li>网络文件系统；这种文件系统允许访问另一个计算机的数据；数据存储于其他计算机上，内核无须关注文件存取等细节，而是通过命令和特定的协议如FTP等，而由于VFS抽象层，所以用户进程体会不到区别；  <h4 id="文件系统的组成（通用文件模型）概述："><a href="#文件系统的组成（通用文件模型）概述：" class="headerlink" title="文件系统的组成（通用文件模型）概述："></a>文件系统的组成（通用文件模型）概述：</h4></li>
</ol>
<ul>
<li>概述：<br>VFS提供了一种结构模型，包含了一个强大文件系统所应具备的所有组件，该模型只存在于虚拟中，必须使用各种对象和函数指针与每种文件系统适配；</li>
<li>文件的概念：<br>在处理文件时，内核空间和用户空间使用的主要对象不同，用户程序而言，是一个fd,在所有关于文件操作中该整数作为标识文件的参数。文件描述符是在打开文件时由内核分配，只<br>在一个进程内部有效；两个不同的进程可以用同样的文件描述符，但是二者不是指向同一个文件。所以基于同一个fd来共享文件是不可能的；<br>对应到进程结构，是task_struct-&gt;file struct来表示一个文件结构的；</li>
<li>内核空间的文件：inode,每个文件(和目录)都有且只有一个对应的inode;inode包含很多文件信息除了文件名；<br>inode结构中的成员分类：<br>(1）描述文件状态的元数据，如访问权限或上次修改的日期<br>(2) 保存实际文件内容的数据段，用于保存文件<br>一个例子：&#x2F;usr&#x2F;bin&#x2F;emacs的inode查找：<br>(1)setp1：根目录的inode&#x2F;,其数据段不保存文件数据而是根目录下的各个目录项，表示文件或目录，每个目录项由inode编号(唯一）和文件或目录名称构成；<br>(2)step2: 查找子目录usr的inode,即在&#x2F;对应的inode的数据段查找各个目录项，匹配usr,找到后在usr重复此过程，不过查找的是bin<br>(3)step3: 查找bin的目录项(目录项可能对应的是文件或目录),直到匹配上emacs,到此结束，emacs的inode的数据段指向的是文件内容；</li>
</ul>
<img src="/2021/03/13/filesystem/inode1.png" class="" title="inode1 about">  

<ul>
<li>链接和编程接口<br>链接：软链接和硬链接：<br> 软链接：即符号链接，删除链接文件不会影响源文件，软链接文件用一个独立的inode，数据段保存一个字符串给出链接目标路径；<br> 硬链接：无法区分哪个文件先创建，因为创建的目录项使用了一个现存的ino de编号；假设A是B的硬链接文件，删除A时，会删除A和B共享的inode,导致B也不能用了，当然，在inode中加入一个计数器即可防止这种情况；++直到计数器为0才删除inode<br>编程接口：<br> open&#x2F;write<br> struct file和文件描述符  </li>
<li>万物皆文件：  <h4 id="VFS的结构组成："><a href="#VFS的结构组成：" class="headerlink" title="VFS的结构组成："></a>VFS的结构组成：</h4></li>
<li>结构概观：VFS由两个部分组成：文件和文件系统；<br>文件的表示和其他关联结构如下：包含结构和操作函数指针集合；<br>图：<img src="/2021/03/13/filesystem/vfs.png" class="" title="vfs1 about"></li>
</ul>
<p>结构分类：inode,超级块，目录，file</p>
<h5 id="inode-表示一个具体的文件"><a href="#inode-表示一个具体的文件" class="headerlink" title="inode:表示一个具体的文件"></a>inode:表示一个具体的文件</h5><p>inode操作：创建链接，文件重命名，目录中生存新文件，删除文件<br>前面有提到inode表示文件，即一个文件用一个inode表示，而文件关联的数据块信息，在inode中保存；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inode:</span><br><span class="line">    i_op:指向inode的操作函数</span><br><span class="line">    i_fop:指向inode对应的file的操作集合；</span><br><span class="line">    i_mapping:指向</span><br><span class="line">    i_sb:执行超级块</span><br><span class="line">    i_list:可以将inode存于一个链表中，总共<span class="number">3</span>种inode状态：</span><br><span class="line">                   <span class="number">1</span>-inode未关联到任何文件也为活动；对应inode_unuserd全局链表</span><br><span class="line">                   <span class="number">2</span>-inode所有使用但未改变得inode : inode_in_use全局链表</span><br><span class="line">                   <span class="number">3</span>-inode已经使用，且被改变，即与存储介质上的内容不同个，即脏inode:保存于一个特定于超级块的链表中；s_inodes;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>inode操作函数集合：<br>i_op: 即inode_operations:即用于负责管理结构性的操作，比如删除一个文件和文件相关的元数据，如属性；<br>i_fop: 和file结构，都是指向一个file_operations结构的指针，用于操作文件中包含的数据，比如读数据，写数据  </p>
</li>
<li><p>在VFS中，内核通过三个全局链表来管理所有的inode:<br>(1) 每个inode都有一个i_list成员，可以将inode存储在一个链表中，根据inode的状态，他可能有3种主要的情况：<br>inode存在于内存中，未关联到任何文件，也不处于活动使用状态；<br>inode结构在内存中，正在由一个或多个进程使用，通常表示一个文件，两个计数器(i_count和i_nlink)都必须大于0；即上次与存储介质同步后，该inode没有改变过；<br>inode处于活动状态，其数据内容已经改变，与介质内容不同，即是脏的；</p>
</li>
</ol>
<p>(2) 在fs&#x2F;inode.c中有两个全局变量做表头：<br>inode_unused,即上述第一类<br>inode_in_use:即第二类<br>而脏的第三类，在一个特定于超级块的链表中；  </p>
<p>(3) 还有一种情况就是，当移动介质改变时，此时所有的inode都无效了；无效的inode存在一个本地的链表中；  </p>
<p>(4) 除了上面的和状态有关的全局结构，还有一个散列表，用来支持根据inode编号和超级块快速访问inode; fs&#x2F;inode.c: inode_hashtable;<br>    另外在超级表中，还有一个s_inodes表头的，i_sb_list做链表元素的链表；</p>
<p>总结来讲，就是每个文件有个关联的inode,vfs内核将所有的inode通过链表和散列表管理起来；通过inode编号等可以找到对应的inode</p>
<h5 id="file：表示一个与进程相关联的已打开的文件，和inode区别在，不同进程共享一个inode-但是不同进程各自维护file对象"><a href="#file：表示一个与进程相关联的已打开的文件，和inode区别在，不同进程共享一个inode-但是不同进程各自维护file对象" class="headerlink" title="file：表示一个与进程相关联的已打开的文件，和inode区别在，不同进程共享一个inode;但是不同进程各自维护file对象"></a>file：表示一个与进程相关联的已打开的文件，和inode区别在，不同进程共享一个inode;但是不同进程各自维护file对象</h5><p>fd用于在一个进程内唯一表示打开的文件；而在进程结构中，包含了一个file结构，来对应这个fd;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* filesystem information */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fs_struct</span> *fs;</span><br><span class="line"><span class="comment">/* open file information */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">files_struct</span> *files;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Open file table structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">files_struct</span> &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * read mostly part</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fdtable</span> __rcu *fdt;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fdtable</span> fdtab;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * written part on a separate cache line in SMP</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="type">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">	<span class="type">int</span> next_fd; <span class="comment">//下一次打开新文件时使用的文件描述符</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> close_on_exec_init[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> open_fds_init[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file</span> __rcu * fd_array[NR_OPEN_DEFAULT];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">file</span> &#123;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">llist_node</span>	fu_llist;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rcu_head</span> 	fu_rcuhead;</span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">path</span>		f_path;<span class="comment">//封装了文件名和inode之间的关联，以及文件所在文件系统的信息</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inode</span>		*f_inode;	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span>	*f_op;<span class="comment">//指向了所有的文件操作接口，如打开文件，读写文件，其中的open用于打开一个文件，相当于将一个file对象关联到inode</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mutex</span>		f_pos_lock;</span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fown_struct</span>	f_owner;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span>	*f_cred;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file_ra_state</span>	f_ra;</span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	f_ep_links;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	f_tfile_llink;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">address_space</span>	*f_mapping;</span><br><span class="line">&#125; __attribute__((<span class="built_in">aligned</span>(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>files包含当前进程的各个文件描述符<br>file_operations    *f_op;&#x2F;&#x2F;指向了所有的文件操作接口，如打开文件，读写文件，其中的open用于打开一个文件，相当于将一个file对象关联到inode,<br>不同的文件系统，设备，用不同的操作函数更新如：<br>fs&#x2F;block_dev.c:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> def_blk_fops = &#123;</span><br><span class="line">	.open		= blkdev_open,</span><br><span class="line">	.release	= blkdev_close,</span><br><span class="line">	.llseek		= block_llseek,</span><br><span class="line">	.read_iter	= blkdev_read_iter,</span><br><span class="line">	.write_iter	= blkdev_write_iter,</span><br><span class="line">	.mmap		= generic_file_mmap,</span><br><span class="line">	.fsync		= blkdev_fsync,</span><br><span class="line">	.unlocked_ioctl	= block_ioctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	.compat_ioctl	= compat_blkdev_ioctl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.splice_read	= generic_file_splice_read,</span><br><span class="line">	.splice_write	= iter_file_splice_write,</span><br><span class="line">&#125;;</span><br><span class="line">fs/ext3/file.c:</span><br><span class="line">是不同的初始化函数，具体不赘述；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="关于超级块：superblock对象：-表示一个具体的可封装的文件系统，相当于书的封面"><a href="#关于超级块：superblock对象：-表示一个具体的可封装的文件系统，相当于书的封面" class="headerlink" title="关于超级块：superblock对象： 表示一个具体的可封装的文件系统，相当于书的封面"></a>关于超级块：superblock对象： 表示一个具体的可封装的文件系统，相当于书的封面</h5><p>整个文件系统的第一块空间，包含整个文件系统的基本信息，如块大小，指向空间的inode和数据块的指针等相关信息<br>VFS支持的文件系统类型通过一种特殊的内核对象连接进来，该对象提供了一种读取超级块的方法；<br>超级块信息：文件系统关键信息如块长度，最大文件长，读，写，操作inode的函数指针；<br>内核建立了一个链表，存储所有活动文件系统的超级块实例<br>超级块还有一个重要成员列表，包括相关文件系统中所有修改过的inode；  </p>
<h5 id="关于目录：目录信息，目录项缓存，命名空间，dentry-表示一个目录条目，或路径中的一个分量；"><a href="#关于目录：目录信息，目录项缓存，命名空间，dentry-表示一个目录条目，或路径中的一个分量；" class="headerlink" title="关于目录：目录信息，目录项缓存，命名空间，dentry: 表示一个目录条目，或路径中的一个分量；"></a>关于目录：目录信息，目录项缓存，命名空间，dentry: 表示一个目录条目，或路径中的一个分量；</h5><p>（1）在进程结构task_struct中，还有一个成员，用来维护和目录相关的信息：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fs_struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dentry</span> *root,pwd,altroot...<span class="comment">//指定了相关进程的根目录,当前工作目录和特性目录</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">vfsmount</span> *rootmnt，pwdmnt,.:<span class="comment">//指定了相关进程的文件系统；当前工作目录的文件系统的vfsmount结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）VFS命名空间：<br>是为容器实现提供了可能，即每个容器分别跟踪装载的文件系统。VFS命名空间是所有已装载，构成某个容器目录树的文件系统的集合<br>对应的struct task_struct中的nsproxy<br>(3) 目录项缓存；<br>因为在inode查找时，即使设备数据已经在页缓存中，仍然会每次都重复整个查找操作，所以用目录项缓存(dentry缓存)来快速访问此前的查找结果；<br>     创建：内核在读取一个目录项（文件或目录）的数据后，就会创建一个dentry实例，以缓存找到的数据；可以从上图看到，file结构和inode结构都有一个相关的指针指向此结构；<br>     dentry结构：<br>     dentry缓存的组织：一个散列表：dentry_hashtable包含了所有的dentry对象<br>     dentry的操作函数集合：dentry_operations;<br>     dentry的一些标准函数操作  </p>
<h5 id="文件系统中的文件操作，如何将上述结构关联："><a href="#文件系统中的文件操作，如何将上述结构关联：" class="headerlink" title="文件系统中的文件操作，如何将上述结构关联："></a>文件系统中的文件操作，如何将上述结构关联：</h5><ul>
<li>open文件： int open(const char *pathname, int flags, mode_t mode);<br>最重要的参数是pathname,而返回的fd是后续执行的关键：<br>在fs&#x2F;open.c:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE3</span>(open, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">int</span>, flags, <span class="type">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">		flags |= O_LARGEFILE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">do_sys_open</span>(AT_FDCWD, filename, flags, mode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">do_sys_open</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user *filename, <span class="type">int</span> flags, <span class="type">umode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">open_flags</span> op;</span><br><span class="line">	<span class="type">int</span> fd = <span class="built_in">build_open_flags</span>(flags, mode, &amp;op);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">filename</span> *tmp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd)</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">    <span class="comment">//使用相关函数从用户空间得到文件名</span></span><br><span class="line">	tmp = <span class="built_in">getname</span>(filename);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(tmp))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(tmp);</span><br><span class="line">    <span class="comment">//分配一个fd，并做相关初始化</span></span><br><span class="line">	fd = <span class="built_in">get_unused_fd_flags</span>(flags);</span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">file</span> *f = <span class="built_in">do_filp_open</span>(dfd, tmp, &amp;op);</span><br><span class="line">        <span class="comment">//1 获取分配struct file,</span></span><br><span class="line">        <span class="comment">//2 查找文件名对应的inode：path_lookup,link_path_walk,do_follow_link</span></span><br><span class="line">        <span class="comment">// 内核试图在dentry缓存中找inode，并检查缓存是否有效，主要是操作dentry;</span></span><br><span class="line">        <span class="comment">//3 调用f_op-&gt;open函数,从而执行到设备层面的打开</span></span><br><span class="line">        <span class="comment">//4 返回file结构</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(f)) &#123;</span><br><span class="line">			<span class="built_in">put_unused_fd</span>(fd);</span><br><span class="line">			fd = <span class="built_in">PTR_ERR</span>(f);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">fsnotify_open</span>(f);</span><br><span class="line">			<span class="built_in">fd_install</span>(fd, f);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putname</span>(tmp);</span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
中可以看到，open的基本过程<br>1 根据文件名查找inode, 若文件存在，则通过文件系统找到对应的inode，若文件不存在，则创建文件和关联；<br>2 初始化fd等结构，<br>3 执行底层的open函数；<br>注意：inode是初始化时就创建了，而创建文件，是将文件和inode关联起来；  <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode <span class="built_in">table</span>），存放inode所包含的信息。</span><br><span class="line">每个inode节点的大小，一般是<span class="number">128</span>字节或<span class="number">256</span>字节。inode节点的总数，在格式化时就给定，一般是每<span class="number">1</span>KB或每<span class="number">2</span>KB就设置一个inode。假定在一块<span class="number">1</span>GB的硬盘中，每个inode节点的大小为<span class="number">128</span>字节，每<span class="number">1</span>KB就设置一个inode，那么inode <span class="built_in">table</span>的大小就会达到<span class="number">128</span>MB，占整块硬盘的<span class="number">12.8</span><span class="comment">%。</span></span><br><span class="line">查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</span><br><span class="line">由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~$ df -i</span><br><span class="line">Filesystem      Inodes  IUsed   IFree IUse% Mounted on</span><br><span class="line">udev           <span class="number"> 482138 </span>  <span class="number"> 475 </span><span class="number"> 481663 </span>   1% /dev</span><br><span class="line">tmpfs          <span class="number"> 505829 </span>  <span class="number"> 437 </span><span class="number"> 505392 </span>   1% /run</span><br><span class="line">/dev/sda1     <span class="number"> 1703936 </span>481526<span class="number"> 1222410 </span>  29% /</span><br><span class="line">none           <span class="number"> 505829 </span>    <span class="number"> 2 </span><span class="number"> 505827 </span>   1% /sys/fs/cgroup</span><br><span class="line">none           <span class="number"> 505829 </span>    <span class="number"> 3 </span><span class="number"> 505826 </span>   1% /run/lock</span><br><span class="line">none           <span class="number"> 505829 </span>    <span class="number"> 4 </span><span class="number"> 505825 </span>   1% /run/shm</span><br><span class="line">none           <span class="number"> 505829 </span>   <span class="number"> 28 </span><span class="number"> 505801 </span>   1% /run/user</span><br></pre></td></tr></table></figure>
<ul>
<li>read文件</li>
<li>write文件：</li>
</ul>
<h5 id="VFS对象的操作：-即关于创建和操作文件系统，注册，挂载等"><a href="#VFS对象的操作：-即关于创建和操作文件系统，注册，挂载等" class="headerlink" title="VFS对象的操作： 即关于创建和操作文件系统，注册，挂载等"></a>VFS对象的操作： 即关于创建和操作文件系统，注册，挂载等</h5><p>在创建文件系统和挂在文件系统时，主要涉及以下结构和操作：</p>
<ul>
<li><p>结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file_system_type:用于描述文件系统的结构</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">file_system_type</span> &#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//文件系统名：eg: procfs</span></span><br><span class="line">	<span class="type">int</span> fs_flags;<span class="comment">//使用标志，如只读庄子，禁止setuid等</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_REQUIRES_DEV		1 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_BINARY_MOUNTDATA	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_HAS_SUBTYPE		4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_MOUNT		8	<span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_DEV_MOUNT	16 <span class="comment">/* A userns mount does not imply MNT_NODEV */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_VISIBLE	32	<span class="comment">/* FS must already be visible */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_RENAME_DOES_D_MOVE	32768	<span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dentry</span> *(*mount) (<span class="keyword">struct</span> file_system_type *, <span class="type">int</span>,</span><br><span class="line">		       <span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *);<span class="comment">//挂载时使用</span></span><br><span class="line">	<span class="built_in">void</span> (*kill_sb) (<span class="keyword">struct</span> super_block *);<span class="comment">//不再需要此文件系统时的清理</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">module</span> *owner;<span class="comment">//以模块加载时使用</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file_system_type</span> * next;<span class="comment">//各个可用的文件系统通过这个链接起来</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hlist_head</span> fs_supers;同一文件系统类型可能对应多个超级块结构，所以通过这个结构聚集在一个链表中；这个是表头</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> s_lock_key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> s_umount_key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> s_vfs_rename_key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> s_writers_key[SB_FREEZE_LEVELS];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> i_lock_key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> i_mutex_key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> i_mutex_dir_key;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>vfsmount: 维护挂载点相关信息等<br>super_block: 超级块以及它的操作函数集合，主要是对inode的管理，注意inode是fs层面的，和进程本身没有太大关系；  </p>
</li>
<li><p>操作：<br>注册文件系统: register_filesystem;<br>装载文件系统：mount<br>卸载文件系统：umount  </p>
</li>
<li><p>所以，若想创建一个新的文件系统类型，需要自己初始化上面结构的值，以及对应的操作函数集合ops,同时调用注册，装载，等函数；<br>这里新的是，如何管理和分配，读写inode的接口，新的超级块，挂载结构vfsmount和文件系统结构file_system_type 实例；<br>这里不变的，是inode，dentry等文件相关的结构及其设备相关的操作集合；若想变，需要做更大的支持和改动；</p>
</li>
</ul>
<h5 id="从inode到具体的设备操作函数："><a href="#从inode到具体的设备操作函数：" class="headerlink" title="从inode到具体的设备操作函数："></a>从inode到具体的设备操作函数：</h5><ul>
<li><p>块设备和硬盘，分区的对应关系：<br>将一个磁盘添加到系统中时，内核将读取并分析底层块设备上的分区信息，但并不会对各个分区创建block_device(块设备结构)实例。为此，内核使用以下数据结构，对已经分区的<br>硬盘提供了一种表示：<br>&lt;genhd.h&gt; struct gendisk{<br>  int major: 主设备号<br>}<br>块设备，通用硬盘和分区之间的关联,todo </p>
</li>
<li><p>块设备的操作和请求队列等相关结构<br>虚拟文件系统中的每个文件都关联到恰好一个inode,用于管理文件的属性等；inode结构有设备相关的成员，如i_rdev,i_mode,i_fops,i_bdev,i_cdev等；<br>inode中有f_ops结构，被初始化为设备对应的操作函数集合，不同的设备，有不同的ops；<br>而inode中也有设备相关的字段，主要是主设备号和从设备号，通过这两个可以确定操作的文件对应的设备，并通过这两个设备号<br>拿到对应的设备操作函数集合，从而正确的操作；<br>inode,cdev,file,ops之间的关系；  </p>
</li>
<li><p>向系统添加磁盘和分区–其实就是对上面gendisk及其关联结构的创建和操作等 TD</p>
</li>
</ul>
<h4 id="创建一个小的文件系统："><a href="#创建一个小的文件系统：" class="headerlink" title="创建一个小的文件系统："></a>创建一个小的文件系统：</h4><p>上面有提到，用户接口如何初始化一个分区格式为一个文件系统：<br>这里是介绍如何实现一个小的文件系统；<br><a href="https://github.com/accelazh/hellofs">https://github.com/accelazh/hellofs</a><br>这里有一个github上实现的简单的文件系统，但是和笔者想的不太一样，这个不免粗暴了些；而且有些重要的接口反而没有实现，比如alloc_inode等inode管理的<br>函数；<br>待有时间再实现；  </p>
<h4 id="文件系统的内核接口"><a href="#文件系统的内核接口" class="headerlink" title="文件系统的内核接口"></a>文件系统的内核接口</h4><p>参考：网络socketfs等等实现；<br><a href="http://reader.epubee.com/books/mobile/eb/eba6bf6a9f551ecdf3cf131e59937e41/text00037.html">http://reader.epubee.com/books/mobile/eb/eba6bf6a9f551ecdf3cf131e59937e41/text00037.html</a>  </p>
<h4 id="文件系统的用户接口"><a href="#文件系统的用户接口" class="headerlink" title="文件系统的用户接口"></a>文件系统的用户接口</h4><p>略，详细可以查相关资料；  </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>filesystem</tag>
      </tags>
  </entry>
  <entry>
    <title>interrupt</title>
    <url>/2021/04/18/interrupt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="中断概述"><a href="#中断概述" class="headerlink" title="中断概述"></a>中断概述</h3><p>除了系统调用外，中断也是一种内核活动；系统调用不是在用户态和系统状态之间切换的唯一途径<br>中断的处理往往会涉及到汇编等和硬件相关的代码，但是中断处理部分随着时间的演化，已经达到了这样一种状态：高层代码和底层的硬件交互代码，已经尽可能有效而干净<br>地分隔开了。<span id="more"></span></p>
<h3 id="中断框架："><a href="#中断框架：" class="headerlink" title="中断框架："></a>中断框架：</h3><p>老版本的linux，中断代码比较杂乱，新版本，因为其中引入了一个用于中断和IRQ的通用框架。各个平台现在只负责在最低层次上与硬件交互。所有其他功能都由通用代码提供</p>
<h4 id="中断类型："><a href="#中断类型：" class="headerlink" title="中断类型："></a>中断类型：</h4><p>同步中断和异步中断，两者都是通过中断服务程序（ISR中断处理程序）来处理的</p>
<h5 id="同步中断和异常"><a href="#同步中断和异常" class="headerlink" title="同步中断和异常"></a>同步中断和异常</h5><p>由cpu产生，针对当前执行的程序，比如除0，内核可能通过信号机制通知进程，进程做默认或注册行为比如输出错误信息，或者直接结束；<br>异常情况也可能是如缺页异常，这种由内核自动修复，进程往往无感知；</p>
<h5 id="异步中断"><a href="#异步中断" class="headerlink" title="异步中断"></a>异步中断</h5><p>经典的中断，由外部设备产生，可能发生在任意时间。不同于同步中断，<br>异步中断并不与特定进程关联。它们可能发生在任何时间，而不牵涉系统当前执行的活动。 ①<br>网卡通过发出一个相关的中断来报告新分组的到达。因为数据可能在任意时刻到达系统，所<br>以当前执行的很可能是与数据无关的某个进程或其他东西。为避免损害该进程，内核必须确<br>保中断能够尽快处理完毕（通过缓冲数据），使得CPU时间能够返还给当前进程。这也是内核<br>需要延期操作机制的原因</p>
<h5 id="中断的一些其他逻辑："><a href="#中断的一些其他逻辑：" class="headerlink" title="中断的一些其他逻辑："></a>中断的一些其他逻辑：</h5><ul>
<li>禁用中断，应尽量避免；</li>
<li>设备共享中断编号–中断共享</li>
</ul>
<h3 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h3><p>由系统自身和与之连接的外设自动产生。它们用于支持更高效地实现设备驱动程序，也用于引起处理器自身对异常或错误的关注，这些是需要与内核代码进行交互的。<br>中断不能由处理器外部的外设直接产生，而必须借助于一个称为中断控制器(interrupt controller)的标准组件来请求，该组件存在于每个系统中。<br>&#x2F;proc&#x2F;interrupts 这个文件可以查看系统的中断编号和对应中断；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~/c++/ptrace$ cat /proc/interrupts </span><br><span class="line">           CPU0       CPU1       </span><br><span class="line">  <span class="number">0</span>:         <span class="number">39</span>          <span class="number">0</span>   IO-APIC   <span class="number">2</span>-edge      timer</span><br><span class="line">  <span class="number">1</span>:       <span class="number">3038</span>          <span class="number">0</span>   IO-APIC   <span class="number">1</span>-edge      i8042</span><br><span class="line">  <span class="number">8</span>:          <span class="number">0</span>          <span class="number">0</span>   IO-APIC   <span class="number">8</span>-edge      rtc0</span><br><span class="line">  <span class="number">9</span>:          <span class="number">0</span>          <span class="number">0</span>   IO-APIC   <span class="number">9</span>-fasteoi   acpi</span><br><span class="line"> <span class="number">12</span>:       <span class="number">3144</span>          <span class="number">0</span>   IO-APIC  <span class="number">12</span>-edge      i8042</span><br><span class="line"> <span class="number">14</span>:          <span class="number">0</span>          <span class="number">0</span>   IO-APIC  <span class="number">14</span>-edge      ata_piix</span><br><span class="line"> <span class="number">15</span>:       <span class="number">9824</span>          <span class="number">0</span>   IO-APIC  <span class="number">15</span>-edge      ata_piix</span><br><span class="line"> <span class="number">18</span>:          <span class="number">0</span>          <span class="number">0</span>   IO-APIC  <span class="number">18</span>-fasteoi   vmwgfx</span><br><span class="line"> <span class="number">19</span>:        <span class="number">129</span>       <span class="number">7562</span>   IO-APIC  <span class="number">19</span>-fasteoi   eth0</span><br><span class="line"> <span class="number">20</span>:      <span class="number">18055</span>          <span class="number">0</span>   IO-APIC  <span class="number">20</span>-fasteoi   vboxguest</span><br><span class="line"> <span class="number">21</span>:      <span class="number">46875</span>          <span class="number">0</span>   IO-APIC  <span class="number">21</span>-fasteoi   <span class="number">0000</span>:<span class="number">00</span>:<span class="number">0</span>d<span class="number">.0</span>, snd_intel8x0</span><br><span class="line"> <span class="number">22</span>:         <span class="number">27</span>          <span class="number">0</span>   IO-APIC  <span class="number">22</span>-fasteoi   ohci_hcd:usb1</span><br><span class="line">NMI:          <span class="number">0</span>          <span class="number">0</span>   Non-maskable interrupts</span><br><span class="line">LOC:     <span class="number">257382</span>     <span class="number">487413</span>   Local timer interrupts</span><br><span class="line">SPU:          <span class="number">0</span>          <span class="number">0</span>   Spurious interrupts</span><br><span class="line">PMI:          <span class="number">0</span>          <span class="number">0</span>   Performance monitoring interrupts</span><br><span class="line">IWI:          <span class="number">0</span>          <span class="number">0</span>   IRQ work interrupts</span><br><span class="line">RTR:          <span class="number">0</span>          <span class="number">0</span>   APIC ICR read retries</span><br><span class="line">RES:     <span class="number">299362</span>     <span class="number">323826</span>   Rescheduling interrupts</span><br><span class="line">CAL:       <span class="number">2173</span>      <span class="number">26988</span>   Function call interrupts</span><br><span class="line">TLB:       <span class="number">1760</span>       <span class="number">1871</span>   TLB shootdowns</span><br><span class="line">TRM:          <span class="number">0</span>          <span class="number">0</span>   Thermal event interrupts</span><br><span class="line">THR:          <span class="number">0</span>          <span class="number">0</span>   Threshold APIC interrupts</span><br><span class="line">DFR:          <span class="number">0</span>          <span class="number">0</span>   Deferred Error APIC interrupts</span><br><span class="line">MCE:          <span class="number">0</span>          <span class="number">0</span>   Machine check exceptions</span><br><span class="line">MCP:         <span class="number">35</span>         <span class="number">35</span>   Machine check polls</span><br><span class="line">ERR:          <span class="number">0</span></span><br><span class="line">MIS:          <span class="number">0</span></span><br><span class="line">PIN:          <span class="number">0</span>          <span class="number">0</span>   Posted-interrupt notification event</span><br><span class="line">PIW:          <span class="number">0</span>          <span class="number">0</span>   Posted-interrupt wakeup event</span><br></pre></td></tr></table></figure>

<h4 id="硬件中断的处理"><a href="#硬件中断的处理" class="headerlink" title="硬件中断的处理"></a>硬件中断的处理</h4><h5 id="进入和退出任务："><a href="#进入和退出任务：" class="headerlink" title="进入和退出任务："></a>进入和退出任务：</h5><p>首先，必须建立一个适当的环境，使得处理程序函数能够在其中执行，接下来调用处理程序自身，最后将系统复原（在当前程序看来）到中断之前的状态。<br>进入是从用户态切到核心太，退出是从核心态到用户态，而且需要通过调度器是否选择新进程替代旧进程；中断到达时也可能处于核心态，所以这个时候需要判断；</p>
<h5 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h5><ul>
<li>特点：<br>可以禁用中断来防止被打断，但是只能短时间使用，处理过程短暂；<br>可以在其他ISR执行期间调用的中断处理程序，不能彼此干扰<br>可延期的处理，不用在中断处理程序中实现，可以放到类似下半部的软中断；或者tasklet</li>
</ul>
<h4 id="中断相关数据结构："><a href="#中断相关数据结构：" class="headerlink" title="中断相关数据结构："></a>中断相关数据结构：</h4><ul>
<li><p>总的数组：<br>在kernel&#x2F;irq&#x2F;handle.c,kernel&#x2F;irq&#x2F;irqdesc.c:可以看到初始化的中断处理数组；每个都被处理为handle_bad_irq;此时还没赋值；<br>赋值发生在驱动程序或模块初始化时调用request_irq等类似函数进行注册；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">irq_desc</span> irq_desc[NR_IRQS] __cacheline_aligned_in_smp = &#123;</span><br><span class="line">	[<span class="number">0</span> ... NR_IRQS<span class="number">-1</span>] = &#123;</span><br><span class="line">		.handle_irq	= handle_bad_irq,</span><br><span class="line">		.depth		= <span class="number">1</span>,</span><br><span class="line">		.lock		= __RAW_SPIN_LOCK_UNLOCKED(irq_desc-&gt;lock),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但IRQ的最大可能数目是通过一个平台相关的常数NR_IRQS指定的。大多数体系结构下，该常数定义在处理器相关的头文件include&#x2F;asm-generic&#x2F;irq.h中<br>不同处理器可能支持的不同；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NR_IRQS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_IRQS 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组每个元素：<br>看下中断处理数组中每个元素的结构：每个irq都可以由该结构完全描述</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct irq_desc - interrupt descriptor</span></span><br><span class="line"><span class="comment"> * @irq_common_data:	per irq and chip data passed down to chip functions</span></span><br><span class="line"><span class="comment"> * @kstat_irqs:		irq stats per cpu</span></span><br><span class="line"><span class="comment"> * @handle_irq:		highlevel irq-events handler</span></span><br><span class="line"><span class="comment"> 电流层ISR由handle_irq提供。 handler_data可以指向任意数据，该数据可以是特定于IRQ</span></span><br><span class="line"><span class="comment">或处理程序的。每当发生中断时，特定于体系结构的代码都会调用handle_irq。该函数负责</span></span><br><span class="line"><span class="comment">使用chip中提供的特定于控制器的方法，进行处理中断所必需的一些底层操作。用于不同中</span></span><br><span class="line"><span class="comment">断类型的默认函数由内核提供。 </span></span><br><span class="line"><span class="comment"> * @preflow_handler:	handler called before the flow handler (currently used by sparc)</span></span><br><span class="line"><span class="comment"> * @action:		the irq action chain    irq操作列表</span></span><br><span class="line"><span class="comment"> action提供了一个操作链，需要在中断发生时执行。由中断通知的设备驱动程序，可以将与</span></span><br><span class="line"><span class="comment">之相关的处理程序函数放置在此处。有一个专门的数据结构用于表示这些操作</span></span><br><span class="line"><span class="comment"> * @status:		status information      irq状态</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit masks for irq_common_data.state_use_accessors</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IRQD_TRIGGER_MASK		- Mask for the trigger type bits</span></span><br><span class="line"><span class="comment"> * IRQD_SETAFFINITY_PENDING	- Affinity setting is pending</span></span><br><span class="line"><span class="comment"> * IRQD_NO_BALANCING		- Balancing disabled for this IRQ</span></span><br><span class="line"><span class="comment"> * IRQD_PER_CPU			- Interrupt is per cpu</span></span><br><span class="line"><span class="comment"> * IRQD_AFFINITY_SET		- Interrupt affinity was set</span></span><br><span class="line"><span class="comment"> * IRQD_LEVEL			- Interrupt is level triggered</span></span><br><span class="line"><span class="comment"> * IRQD_WAKEUP_STATE		- Interrupt is configured for wakeup</span></span><br><span class="line"><span class="comment"> *				  from suspend</span></span><br><span class="line"><span class="comment"> * IRDQ_MOVE_PCNTXT		- Interrupt can be moved in process</span></span><br><span class="line"><span class="comment"> *				  context</span></span><br><span class="line"><span class="comment"> * IRQD_IRQ_DISABLED		- Disabled state of the interrupt</span></span><br><span class="line"><span class="comment"> * IRQD_IRQ_MASKED		- Masked state of the interrupt</span></span><br><span class="line"><span class="comment"> * IRQD_IRQ_INPROGRESS		- In progress state of the interrupt</span></span><br><span class="line"><span class="comment"> * IRQD_WAKEUP_ARMED		- Wakeup mode armed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">enum &#123;</span></span><br><span class="line"><span class="comment">	IRQD_TRIGGER_MASK		= 0xf,</span></span><br><span class="line"><span class="comment">	IRQD_SETAFFINITY_PENDING	= (1 &lt;&lt;  8),</span></span><br><span class="line"><span class="comment">	IRQD_NO_BALANCING		= (1 &lt;&lt; 10),</span></span><br><span class="line"><span class="comment">	IRQD_PER_CPU			= (1 &lt;&lt; 11),</span></span><br><span class="line"><span class="comment">	IRQD_AFFINITY_SET		= (1 &lt;&lt; 12),</span></span><br><span class="line"><span class="comment">	IRQD_LEVEL			= (1 &lt;&lt; 13),</span></span><br><span class="line"><span class="comment">	IRQD_WAKEUP_STATE		= (1 &lt;&lt; 14),</span></span><br><span class="line"><span class="comment">	IRQD_MOVE_PCNTXT		= (1 &lt;&lt; 15),</span></span><br><span class="line"><span class="comment">	IRQD_IRQ_DISABLED		= (1 &lt;&lt; 16),</span></span><br><span class="line"><span class="comment">	IRQD_IRQ_MASKED			= (1 &lt;&lt; 17),</span></span><br><span class="line"><span class="comment">	IRQD_IRQ_INPROGRESS		= (1 &lt;&lt; 18),</span></span><br><span class="line"><span class="comment">	IRQD_WAKEUP_ARMED		= (1 &lt;&lt; 19),</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* @core_internal_state__do_not_mess_with_it: core internal status information</span></span><br><span class="line"><span class="comment"> * @depth:		disable-depth, for nested irq_disable() calls</span></span><br><span class="line"><span class="comment"> * @wake_depth:		enable depth, for multiple irq_set_irq_wake() callers</span></span><br><span class="line"><span class="comment"> * @irq_count:		stats field to detect stalled irqs</span></span><br><span class="line"><span class="comment"> * @last_unhandled:	aging timer for unhandled count</span></span><br><span class="line"><span class="comment"> * @irqs_unhandled:	stats field for spurious unhandled interrupts</span></span><br><span class="line"><span class="comment"> * @threads_handled:	stats field for deferred spurious detection of threaded handlers</span></span><br><span class="line"><span class="comment"> * @threads_handled_last: comparator field for deferred spurious detection of theraded handlers</span></span><br><span class="line"><span class="comment"> * @lock:		locking for SMP</span></span><br><span class="line"><span class="comment"> * @affinity_hint:	hint to user space for preferred irq affinity</span></span><br><span class="line"><span class="comment"> * @affinity_notify:	context for notification of affinity changes</span></span><br><span class="line"><span class="comment"> * @pending_mask:	pending rebalanced interrupts</span></span><br><span class="line"><span class="comment"> * @threads_oneshot:	bitfield to handle shared oneshot threads</span></span><br><span class="line"><span class="comment"> * @threads_active:	number of irqaction threads currently running</span></span><br><span class="line"><span class="comment"> * @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers</span></span><br><span class="line"><span class="comment"> * @nr_actions:		number of installed actions on this descriptor</span></span><br><span class="line"><span class="comment"> * @no_suspend_depth:	number of irqactions on a irq descriptor with</span></span><br><span class="line"><span class="comment"> *			IRQF_NO_SUSPEND set</span></span><br><span class="line"><span class="comment"> * @force_resume_depth:	number of irqactions on a irq descriptor with</span></span><br><span class="line"><span class="comment"> *			IRQF_FORCE_RESUME set</span></span><br><span class="line"><span class="comment"> * @dir:		/proc/irq/ procfs entry</span></span><br><span class="line"><span class="comment"> * @name:		flow handler name for /proc/interrupts output</span></span><br><span class="line"><span class="comment">  name指定了电流层处理程序的名称，将显示在/proc/interrupts中。对边沿触发中断，通常</span></span><br><span class="line"><span class="comment">是“edge”，对电平触发中断，通常是“level”。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">irq_desc</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">irq_common_data</span>	irq_common_data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">irq_data</span>		irq_data; <span class="comment">//其中包含了irq_chip成员：用于表示一个IRQ控制器抽象的具体特征；</span></span><br><span class="line"><span class="comment">//通常在一个系统上只有一种类型的中断控制器会占据支配地位（当然，并没有什么约束条件阻止多个控制器并存），所有irq_desc的 irq_data的chip成员都指向irq_chip的同一实例</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __percpu	*kstat_irqs;</span><br><span class="line">	<span class="type">irq_flow_handler_t</span>	handle_irq;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IRQ_PREFLOW_FASTEOI</span></span><br><span class="line">	<span class="type">irq_preflow_handler_t</span>	preflow_handler;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">irqaction</span>	*action;	<span class="comment">/* IRQ action list */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		status_use_accessors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		core_internal_state__do_not_mess_with_it;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		depth;		<span class="comment">/* nested irq disables */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		wake_depth;	<span class="comment">/* nested wake enables */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_count;	<span class="comment">/* For detecting broken IRQs */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		last_unhandled;	<span class="comment">/* Aging timer for unhandled count */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irqs_unhandled;</span><br><span class="line">	<span class="type">atomic_t</span>		threads_handled;</span><br><span class="line">	<span class="type">int</span>			threads_handled_last;</span><br><span class="line">	<span class="type">raw_spinlock_t</span>		lock;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">cpumask</span>		*percpu_enabled;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cpumask</span>	*affinity_hint;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">irq_affinity_notify</span> *affinity_notify;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PENDING_IRQ</span></span><br><span class="line">	<span class="type">cpumask_var_t</span>		pending_mask;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		threads_oneshot;</span><br><span class="line">	<span class="type">atomic_t</span>		threads_active;</span><br><span class="line">	<span class="type">wait_queue_head_t</span>       wait_for_threads;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nr_actions;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		no_suspend_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		cond_suspend_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		force_resume_depth;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proc_dir_entry</span>	*dir;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span>			parent_irq;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">module</span>		*owner;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
<p>一些结构的解释：</p>
</li>
<li><pre><code>irq控制器抽象：
</code></pre>
<p>struct irq_data        irq_data; &#x2F;&#x2F;其中包含了irq_chip成员：用于表示一个IRQ控制器抽象的具体特征；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct irq_chip - hardware interrupt chip descriptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @name:		name for /proc/interrupts</span></span><br><span class="line"><span class="comment"> * @irq_startup:	start up the interrupt (defaults to -&gt;enable if NULL)</span></span><br><span class="line"><span class="comment"> * @irq_shutdown:	shut down the interrupt (defaults to -&gt;disable if NULL)</span></span><br><span class="line"><span class="comment"> * @irq_enable:		enable the interrupt (defaults to chip-&gt;unmask if NULL)</span></span><br><span class="line"><span class="comment"> * @irq_disable:	disable the interrupt</span></span><br><span class="line"><span class="comment"> * @irq_ack:		start of a new interrupt</span></span><br><span class="line"><span class="comment"> * @irq_mask:		mask an interrupt source</span></span><br><span class="line"><span class="comment"> * @irq_mask_ack:	ack and mask an interrupt source</span></span><br><span class="line"><span class="comment"> * @irq_unmask:		unmask an interrupt source</span></span><br><span class="line"><span class="comment"> * @irq_eoi:		end of interrupt</span></span><br><span class="line"><span class="comment"> * @irq_set_affinity:	set the CPU affinity on SMP machines</span></span><br><span class="line"><span class="comment"> * @irq_retrigger:	resend an IRQ to the CPU</span></span><br><span class="line"><span class="comment"> * @irq_set_type:	set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ</span></span><br><span class="line"><span class="comment"> * @irq_set_wake:	enable/disable power-management wake-on of an IRQ</span></span><br><span class="line"><span class="comment"> * @irq_bus_lock:	function to lock access to slow bus (i2c) chips</span></span><br><span class="line"><span class="comment"> * @irq_bus_sync_unlock:function to sync and unlock slow bus (i2c) chips</span></span><br><span class="line"><span class="comment"> * @irq_cpu_online:	configure an interrupt source for a secondary CPU</span></span><br><span class="line"><span class="comment"> * @irq_cpu_offline:	un-configure an interrupt source for a secondary CPU</span></span><br><span class="line"><span class="comment"> * @irq_suspend:	function called from core code on suspend once per chip</span></span><br><span class="line"><span class="comment"> * @irq_resume:		function called from core code on resume once per chip</span></span><br><span class="line"><span class="comment"> * @irq_pm_shutdown:	function called from core code on shutdown once per chip</span></span><br><span class="line"><span class="comment"> * @irq_calc_mask:	Optional function to set irq_data.mask for special cases</span></span><br><span class="line"><span class="comment"> * @irq_print_chip:	optional to print special chip info in show_interrupts</span></span><br><span class="line"><span class="comment"> * @irq_request_resources:	optional to request resources before calling</span></span><br><span class="line"><span class="comment"> *				any other callback related to this irq</span></span><br><span class="line"><span class="comment"> * @irq_release_resources:	optional to release resources acquired with</span></span><br><span class="line"><span class="comment"> *				irq_request_resources</span></span><br><span class="line"><span class="comment"> * @irq_compose_msi_msg:	optional to compose message content for MSI</span></span><br><span class="line"><span class="comment"> * @irq_write_msi_msg:	optional to write message content for MSI</span></span><br><span class="line"><span class="comment"> * @irq_get_irqchip_state:	return the internal state of an interrupt</span></span><br><span class="line"><span class="comment"> * @irq_set_irqchip_state:	set the internal state of a interrupt</span></span><br><span class="line"><span class="comment"> * @flags:		chip specific flags</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 结构需要考虑内核中出现的各个IRQ实现的所有特性。因而，一个该结构的特定实例，通常只</span><br><span class="line">定义所有可能方法的一个子集</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">irq_chip</span> &#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*name;<span class="comment">//表示硬件控制器，</span></span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="title">int</span>	<span class="params">(*irq_startup)</span><span class="params">(<span class="keyword">struct</span> irq_data *data)</span></span>;<span class="comment">//用于第一次初始化一个IRQ</span></span><br><span class="line">	<span class="built_in">void</span>		(*irq_shutdown)(<span class="keyword">struct</span> irq_data *data);<span class="comment">//完全关闭一个中断源</span></span><br><span class="line">	<span class="built_in">void</span>		(*irq_enable)(<span class="keyword">struct</span> irq_data *data);<span class="comment">//用于激活一个IRQ</span></span><br><span class="line">	<span class="built_in">void</span>		(*irq_disable)(<span class="keyword">struct</span> irq_data *data);<span class="comment">//禁用IRQ</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">void</span>		(*irq_ack)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">    <span class="comment">//在某些模型中， IRQ请求的到达（以及在处理器的对应中</span></span><br><span class="line">断）必须显式确认，后续的请求才能进行处理。如果芯片组没有这样的要求，该指针可以指</span><br><span class="line">向一个空函数，或<span class="literal">NULL</span>指针。 ack_and_mask确认一个中断，并在接下来屏蔽该中断。</span><br><span class="line">	<span class="built_in">void</span>		(*irq_mask)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="built_in">void</span>		(*irq_mask_ack)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="built_in">void</span>		(*irq_unmask)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="built_in">void</span>		(*irq_eoi)(<span class="keyword">struct</span> irq_data *data);<span class="comment">//eoi表示end of interrupt，即中断结束</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span>		(*irq_set_affinity)(<span class="keyword">struct</span> irq_data *data, <span class="type">const</span> <span class="keyword">struct</span> cpumask *dest, <span class="type">bool</span> force);</span><br><span class="line">	<span class="built_in">int</span>		(*irq_retrigger)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="built_in">int</span>		(*irq_set_type)(<span class="keyword">struct</span> irq_data *data, <span class="type">unsigned</span> <span class="type">int</span> flow_type);</span><br><span class="line">	<span class="built_in">int</span>		(*irq_set_wake)(<span class="keyword">struct</span> irq_data *data, <span class="type">unsigned</span> <span class="type">int</span> on);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">void</span>		(*irq_bus_lock)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="built_in">void</span>		(*irq_bus_sync_unlock)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">void</span>		(*irq_cpu_online)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="built_in">void</span>		(*irq_cpu_offline)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">void</span>		(*irq_suspend)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="built_in">void</span>		(*irq_resume)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="built_in">void</span>		(*irq_pm_shutdown)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">void</span>		(*irq_calc_mask)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">void</span>		(*irq_print_chip)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">struct</span> seq_file *p);</span><br><span class="line">	<span class="built_in">int</span>		(*irq_request_resources)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="built_in">void</span>		(*irq_release_resources)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">void</span>		(*irq_compose_msi_msg)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">struct</span> msi_msg *msg);</span><br><span class="line">	<span class="built_in">void</span>		(*irq_write_msi_msg)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">struct</span> msi_msg *msg);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span>		(*irq_get_irqchip_state)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="type">bool</span> *state);</span><br><span class="line">	<span class="built_in">int</span>		(*irq_set_irqchip_state)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="type">bool</span> state);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>找一个例子看看：&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;i8295.c:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">irq_chip</span> i8259A_chip = &#123;</span><br><span class="line">	.name		= <span class="string">&quot;XT-PIC&quot;</span>,</span><br><span class="line">	.irq_mask	= disable_8259A_irq,</span><br><span class="line">	.irq_disable	= disable_8259A_irq,</span><br><span class="line">	.irq_unmask	= enable_8259A_irq,</span><br><span class="line">	.irq_mask_ack	= mask_and_ack_8259A,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>处理程序函数的表示：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct irqaction - per interrupt action descriptor</span></span><br><span class="line"><span class="comment"> * @handler:	interrupt handler function</span></span><br><span class="line"><span class="comment"> * @name:	name of the device</span></span><br><span class="line"><span class="comment"> * @dev_id:	cookie to identify the device</span></span><br><span class="line"><span class="comment"> * @percpu_dev_id:	cookie to identify the device</span></span><br><span class="line"><span class="comment"> * @next:	pointer to the next irqaction for shared interrupts</span></span><br><span class="line"><span class="comment"> * @irq:	interrupt number</span></span><br><span class="line"><span class="comment"> * @flags:	flags (see IRQF_* above)</span></span><br><span class="line"><span class="comment"> * @thread_fn:	interrupt handler function for threaded interrupts</span></span><br><span class="line"><span class="comment"> * @thread:	thread pointer for threaded interrupts</span></span><br><span class="line"><span class="comment"> * @thread_flags:	flags related to @thread</span></span><br><span class="line"><span class="comment"> * @thread_mask:	bitmask for keeping track of @thread activity</span></span><br><span class="line"><span class="comment"> * @dir:	pointer to the proc/irq/NN/name entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">irqaction</span> &#123;</span><br><span class="line">	<span class="type">irq_handler_t</span>		handler;<span class="comment">//函数指针，指向中断处理程序</span></span><br><span class="line">	<span class="type">void</span>			*dev_id;</span><br><span class="line">	<span class="type">void</span> __percpu		*percpu_dev_id;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">irqaction</span>	*next;<span class="comment">//用于实现共享的IRQ处理程序，几个irqaction实例聚集到一个链表中。链表的所有元素都</span></span><br><span class="line"><span class="comment">//必须处理同一IRQ编号（处理不同编号的实例，位于irq_desc数组中不同的位置）,在发生一个共享中断时，内核扫描该链表找出中断实际上的来源设备。</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		thread_fn;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span>	*thread;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags;&lt;interrupt.h&gt;中定义了</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_mask;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proc_dir_entry</span>	*dir;</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
name和dev_id唯一地标识一个中断处理程序。 name是一个短字符串，用于标识设备（例如，<br>“e100”、“ncr53c8xx”，等等），而dev_id是一个指针，指向在所有内核数据结构中唯一标识了该设<br>备的数据结构实例，例如网卡的net_device实例。</li>
</ul>
<p>上面的flag:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These flags used only by the kernel as part of the</span></span><br><span class="line"><span class="comment"> * irq handling routines.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IRQF_SHARED - allow sharing the irq among several devices表示有多于一个设备使用该IRQ电路。</span></span><br><span class="line"><span class="comment"> * IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur</span></span><br><span class="line"><span class="comment"> * IRQF_TIMER - Flag to mark this interrupt as timer interrupt</span></span><br><span class="line"><span class="comment"> * IRQF_PERCPU - Interrupt is per cpu</span></span><br><span class="line"><span class="comment"> * IRQF_NOBALANCING - Flag to exclude this interrupt from irq balancing</span></span><br><span class="line"><span class="comment"> * IRQF_IRQPOLL - Interrupt is used for polling (only the interrupt that is</span></span><br><span class="line"><span class="comment"> *                registered first in an shared interrupt is considered for</span></span><br><span class="line"><span class="comment"> *                performance reasons)</span></span><br><span class="line"><span class="comment"> * IRQF_ONESHOT - Interrupt is not reenabled after the hardirq handler finished.</span></span><br><span class="line"><span class="comment"> *                Used by threaded interrupts which need to keep the</span></span><br><span class="line"><span class="comment"> *                irq line disabled until the threaded handler has been run.</span></span><br><span class="line"><span class="comment"> * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend.  Does not guarantee</span></span><br><span class="line"><span class="comment"> *                   that this interrupt will wake the system from a suspended</span></span><br><span class="line"><span class="comment"> *                   state.  See Documentation/power/suspend-and-interrupts.txt</span></span><br><span class="line"><span class="comment"> * IRQF_FORCE_RESUME - Force enable it on resume even if IRQF_NO_SUSPEND is set</span></span><br><span class="line"><span class="comment"> * IRQF_NO_THREAD - Interrupt cannot be threaded</span></span><br><span class="line"><span class="comment"> * IRQF_EARLY_RESUME - Resume IRQ early during syscore instead of at device</span></span><br><span class="line"><span class="comment"> *                resume time.</span></span><br><span class="line"><span class="comment"> * IRQF_COND_SUSPEND - If the IRQ is shared with a NO_SUSPEND user, execute this</span></span><br><span class="line"><span class="comment"> *                interrupt handler after suspending interrupts. For system</span></span><br><span class="line"><span class="comment"> *                wakeup devices users need to implement wakeup detection in</span></span><br><span class="line"><span class="comment"> *                their interrupt handlers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_SHARED		0x00000080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_PROBE_SHARED	0x00000100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IRQF_TIMER		0x00000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_PERCPU		0x00000400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_NOBALANCING	0x00000800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_IRQPOLL		0x00001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_ONESHOT		0x00002000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_NO_SUSPEND		0x00004000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_FORCE_RESUME	0x00008000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_NO_THREAD		0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_EARLY_RESUME	0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_COND_SUSPEND	0x00040000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_TIMER		(__IRQF_TIMER | IRQF_NO_SUSPEND | IRQF_NO_THREAD)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="中断处理的相关操作："><a href="#中断处理的相关操作：" class="headerlink" title="中断处理的相关操作："></a>中断处理的相关操作：</h4><ul>
<li>设置控制器硬件：<br>irq.h:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set/get chip/data for an IRQ: */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">irq_set_chip</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> irq_chip *chip)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">irq_set_handler_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">irq_set_chip_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">irq_set_irq_type</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">unsigned</span> <span class="type">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">irq_set_msi_desc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> msi_desc *entry)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">irq_set_msi_desc_off</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq_base, <span class="type">unsigned</span> <span class="type">int</span> irq_offset,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">struct</span> msi_desc *entry)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>初始化和分配irq:</li>
</ul>
<ol>
<li><p>注册irq：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kernel/irq/manage.<span class="function">c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">irqreturn_t</span> handler,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> irqflags, <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function">往往在设备驱动程序初始化时会做这个request_irq操作把处理程序注册进去；</span></span><br><span class="line"><span class="function">setup_irq</span></span><br></pre></td></tr></table></figure>
<p>2）释放irq:<br>free_irq</p>
</li>
<li><p>注册中断：</p>
</li>
</ol>
<ul>
<li><p>中断到达后：找到正确的中断处理程序的通用函数：do_IRQ,此时若处理器在用户态，需要切换到核心态；<br>linux中do_IRQ是和体系结构相关的函数：<br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AMD:</span><br><span class="line">irq.c:</span><br><span class="line">do_IRQ</span><br><span class="line">  --&gt; set_irq_regs</span><br><span class="line">  --&gt; irq_enter</span><br><span class="line">  --&gt; generic_handle_irq --&gt;.... handle_irq</span><br><span class="line">  --&gt; irq_exit</span><br><span class="line">  --&gt; set_irq_regs</span><br></pre></td></tr></table></figure>
<p>关键处理：<br>handle_irq_event</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">irqreturn_t</span> <span class="title">handle_irq_event</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">irqaction</span> *action = desc-&gt;action;</span><br><span class="line">	<span class="type">irqreturn_t</span> ret;</span><br><span class="line"></span><br><span class="line">	desc-&gt;istate &amp;= ~IRQS_PENDING;</span><br><span class="line">	<span class="built_in">irqd_set</span>(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line">	<span class="built_in">raw_spin_unlock</span>(&amp;desc-&gt;lock);</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">handle_irq_event_percpu</span>(desc, action);<span class="comment">//---&gt;res = action-&gt;handler(irq, action-&gt;dev_id);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">raw_spin_lock</span>(&amp;desc-&gt;lock);</span><br><span class="line">	<span class="built_in">irqd_clear</span>(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>IRQ栈：通过内核栈处理不够，所以又衍生了用于硬件IRQ处理的栈和用于软件IRQ处理的栈；<br>常规的内核栈对每个进程都会分配，而这两个额外的栈是针对各CPU分别分配的。在硬件中断发<br>生时（或处理软中断时），内核需要切换到适当的栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">下列数组提供了指向额外的栈的指针：</span><br><span class="line">arch/x86/kernel/irq_32.c</span><br><span class="line"><span class="type">static</span> <span class="keyword">union</span> <span class="title class_">irq_ctx</span> *hardirq_ctx[NR_CPUS] __read_mostly;</span><br><span class="line"><span class="type">static</span> <span class="keyword">union</span> <span class="title class_">irq_ctx</span> *softirq_ctx[NR_CPUS] __read_mostly;</span><br><span class="line"></span><br><span class="line">用作栈的数据结构并不复杂：</span><br><span class="line">arch/x86/kernel/irq_32.c</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">irq_ctx</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_info</span> tinfo;</span><br><span class="line">u32 stack[THREAD_SIZE/<span class="built_in">sizeof</span>(u32)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于中断处理程序：</p>
</li>
</ul>
<ol>
<li>中断是异步执行的。换句话说，它们可以在任何时间发生。</li>
<li>例如，对网络驱动程序来说，不能将接收的数据直接转发到等待的应用程序。毕竟，内核无法确定等待数据的应用程序此时是否在运行（事实上，这种可能性很低）。</li>
<li>中断上下文中不能调用调度器。因而不能自愿地放弃控制权。</li>
<li>处理程序例程不能进入睡眠状态。<br>中断处理程序类型：irqreturn_t (*handler)(int irq, void *dev_id, struct pt_regs *regs)<br>一个例子：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">一个例子：tg3.c这个有napi形式的，故用这个：</span><br><span class="line">```<span class="function">c</span></span><br><span class="line"><span class="function"><span class="title">module_init</span><span class="params">(tg3_init)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">tg3_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pci_module_init</span>(&amp;tg3_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">pci_driver</span> tg3_driver = &#123;</span><br><span class="line">	.name		= DRV_MODULE_NAME,</span><br><span class="line">	.id_table	= tg3_pci_tbl,</span><br><span class="line">	.probe		= tg3_init_one,</span><br><span class="line">	.remove		= __devexit_p(tg3_remove_one),</span><br><span class="line">	.suspend	= tg3_suspend,</span><br><span class="line">	.resume		= tg3_resume</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __devinit <span class="title">tg3_init_one</span><span class="params">(<span class="keyword">struct</span> pci_dev *pdev,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="type">const</span> <span class="keyword">struct</span> pci_device_id *ent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> tg3_version_printed = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tg3reg_base, tg3reg_len;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span> *dev;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tg3</span> *tp;</span><br><span class="line">	<span class="type">int</span> i, err, pci_using_dac, pm_cap;</span><br><span class="line">                    ...</span><br><span class="line"><span class="comment">//在init中没有申请中断，直到open时才申请：</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">tg3_open</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tg3</span> *tp = dev-&gt;priv;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">                    ...</span><br><span class="line">                    err = <span class="built_in">request_irq</span>(dev-&gt;irq, tg3_interrupt,</span><br><span class="line">			  SA_SHIRQ, dev-&gt;name, dev);</span><br><span class="line">                   </span><br><span class="line"><span class="comment">//来看中断处理程序：</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title">tg3_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id, <span class="keyword">struct</span> pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span> *dev = dev_id;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tg3</span> *tp = dev-&gt;priv;</span><br><span class="line">                    <span class="comment">//这里使用新式接口napi:</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">likely</span>(<span class="built_in">tg3_has_work</span>(dev, tp)))</span><br><span class="line">	       <span class="built_in">netif_rx_schedule</span>(dev);		<span class="comment">/* schedule NAPI poll */</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="重要的中断处理程序："><a href="#重要的中断处理程序：" class="headerlink" title="重要的中断处理程序："></a>重要的中断处理程序：</h4><ul>
<li><p>电流处理： typedef void fastcall (*irq_flow_handler_t)(unsigned int irq,<br>struct irq_desc *desc);</p>
</li>
<li><p>边沿触发中断<br>handle_edge_irq，chip.c</p>
</li>
<li><p>电平触发中断：<br>handle_level_irq,</p>
</li>
</ul>
<h3 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h3><p>用于有效实现内核中的延期操作。完全用软件来实现，但是运作方式和硬件中断类似；softIRQ;<br>不管是哪种体系结构的do_IRQ,其结尾都会去处理所有待决的软中断，确保软中断可以定期处理；</p>
<h4 id="软中断表"><a href="#软中断表" class="headerlink" title="软中断表"></a>软中断表</h4><p>一个包含也许是32个softirq_action类型的数据表；<br>interrupt.h:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">softirq_action</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">void</span>	(*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="软中断的流程："><a href="#软中断的流程：" class="headerlink" title="软中断的流程："></a>软中断的流程：</h4><ul>
<li><p>先注册，内核才能执行：<br>open_softirq函数用于注册： 就是往上述表中填入action<br>kernel&#x2F;softirq.c:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各个软中断都有一个唯一的编号，这表明软中断是相对稀缺的资源，使用其必须谨慎，不能由各种设备驱动程序和内核组件随意使用。<br>这个数组也是被定义在softirq.c中；<br>static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;<br>可以看枚举知道先有的以这种方式注册的软中断：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">	HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">	TIMER_SOFTIRQ,</span><br><span class="line">	NET_TX_SOFTIRQ, 网络的发送</span><br><span class="line">	NET_RX_SOFTIRQ, 网络接收</span><br><span class="line">	BLOCK_SOFTIRQ,块处理</span><br><span class="line">	BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">	TASKLET_SOFTIRQ,</span><br><span class="line">	SCHED_SOFTIRQ,调度器</span><br><span class="line">	HRTIMER_SOFTIRQ,</span><br><span class="line">	RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">	NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只有重要的情况才能用软中断，其他可以使用tasklet,工作队列或内核定时器的方式来达到延期处理的目的；</p>
</li>
<li><p>发起中断：<br>硬件中断需要通过硬件设备触发中断控制器向cpu发起中断，然后进入中断处理程序处理，软中断没有这个机制，需要通过软件的方式发起中断：<br>void raise_softirq(unsigned int nr) 用于引发一个软中断；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">local_irq_save</span>(flags);</span><br><span class="line">	<span class="built_in">raise_softirq_irqoff</span>(nr);</span><br><span class="line">	<span class="built_in">local_irq_restore</span>(flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function must run with irqs disabled!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">raise_softirq_irqoff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__raise_softirq_irqoff(nr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we&#x27;re in an interrupt or softirq, we&#x27;re done</span></span><br><span class="line"><span class="comment">	 * (this also catches softirq-disabled code). We will</span></span><br><span class="line"><span class="comment">	 * actually run the softirq once we return from</span></span><br><span class="line"><span class="comment">	 * the irq or softirq.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Otherwise we wake up ksoftirqd to make sure we</span></span><br><span class="line"><span class="comment">	 * schedule the softirq soon.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">in_interrupt</span>())</span><br><span class="line">		<span class="built_in">wakeup_softirqd</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不在中断上下文调用raise_softirq，则调用wakeup_softirqd来唤醒软中断守护进程，这</span></span><br><span class="line"><span class="comment">//是开启软中断处理的两个可选方法之一。 </span></span><br></pre></td></tr></table></figure>
<p>该函数设置各CPU变量irq_stat[smp_processor_id].__softirq_pending中的对应比特位。<br>该函数将相应的软中断标记为执行，但这个执行是延期执行。通过使用特定于处理器的位图，内核确<br>保几个软中断（甚至是相同的）可以同时在不同的CPU上执行。</p>
</li>
<li><p>流程：<br>在注册了软中断后，若引发软中断且处理软中断的handler时，就会匹配到对应的函数，进行处理；<br>软中断处理被归结到do_softirq函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">do_softirq</span><br><span class="line"> --&gt;local_softirq_pending</span><br><span class="line"> --&gt;__do_softirq</span><br><span class="line"> --&gt;h-&gt;action--循环处理</span><br><span class="line"> --&gt; local_softirq_pending且重启次数没有超过次数-&gt;重启软中断</span><br></pre></td></tr></table></figure>
<p>因为软中断大部分是用来延迟硬中断的后续处理，所以需要一个软中断守护进程来进行异步执行软中断，一方面不和硬中断冲突，另一方面确保软中断的及时执行；<br>系统为每个处理器都分配了自身的守护进程： ksoftirqd，为软中断守护进程；<br>所以实际上raise_softirq是为了唤醒这个守护进程，进行处理软件中断，进行及时处理；</p>
</li>
<li><p>软中断守护进程：ksoftirqd<br>软中断守护进程的任务是，与其余内核代码异步执行软中断。为此，系统中的每个处理器都分配了自身的守护进程，名为ksoftirqd<br>内核中有两处调用wakeup_softirqd唤醒了该守护进程。</p>
</li>
</ul>
<ol>
<li>在do_softirq中，如前所述。</li>
<li>在raise_softirq_irqoff末尾。该函数由raise_softirq在内部调用，如果内核当前停用了<br>中断，也可以直接使用。<br>唤醒函数本身只需要几行代码。首先，借助于一些宏，从一个各CPU变量读取指向当前CPU软中<br>断守护进程的task_struct的指针。如果该进程当前的状态不是TASK_RUNNING，则通过wake_up_<br>process将其放置到就绪进程的列表末尾（参见第2章）。尽管这并不会立即开始处理所有待决软中断，<br>但只要调度器没有更好的选择，就会选择该守护进程（优先级为19）来执行。<br>(1) 软中断守护进程的初始化和启动：<br>在系统启动时用initcall机制调用init后，就创建了系统的软中断守护进程，初始化后，各个守护进程进行无限循环：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kernel/softirq.<span class="function">c</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ksoftirqd</span><span class="params">(<span class="type">void</span> * __bind_cpu)</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">(!kthread_should_stop())</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">local_softirq_pending</span>()) &#123;</span><br><span class="line"><span class="built_in">schedule</span>();</span><br><span class="line">&#125;</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">local_softirq_pending</span>()) &#123;</span><br><span class="line"><span class="built_in">do_softirq</span>();</span><br><span class="line"><span class="built_in">cond_resched</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set_current_state</span>(TASK_INTERRUPTIBLE);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tasklet-另一种轻量的软中断"><a href="#tasklet-另一种轻量的软中断" class="headerlink" title="tasklet ,另一种轻量的软中断"></a>tasklet ,另一种轻量的软中断</h3>软中断是将操作推迟到未来时刻执行的最有效的方法。但该延期机制处理起来非常复杂。因为多<br>个处理器可以同时且独立地处理软中断，同一个软中断的处理程序例程可以在几个CPU上同时运行。<br>对软中断的效率来说，这是一个关键，多处理器系统上的网络实现显然受惠于此。</li>
</ol>
<p>但处理程序例程的设计必须是完全可重入且线程安全的。 另外， 临界区必须用自旋锁保护（或其他IPC机制），<br>而这需要大量审慎的考虑。</p>
<p>tasklet是“小进程”，执行一些迷你任务，对这些任务使用全功能进程可能比较浪费</p>
<h4 id="创建tasklet"><a href="#创建tasklet" class="headerlink" title="创建tasklet:"></a>创建tasklet:</h4><p>各个tasklet的中枢数据结构称作tasklet_struct，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">interrupt.h:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tasklet_struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tasklet_struct</span> *next;<span class="comment">//用于建立tasklet_struct实例的链表。这容许几个任务排队执行。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> state;<span class="comment">//state表示任务的当前状态，类似于真正的进程。但只有两个选项，分别由state中的一个比特</span></span><br><span class="line"><span class="comment">//位表示，这也是二者可以独立设置/清除的原因。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在tasklet注册到内核，等待调度执行时，将设置TASKLET_STATE_SCHED。</span></span><br><span class="line"><span class="comment">    TASKLET_STATE_RUN表示tasklet当前正在执行。</span></span><br><span class="line"><span class="comment">    第二个状态只在SMP系统上有用。用于保护tasklet在多个处理器上并行执行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="comment">//原子计数器count用于禁用已经调度的tasklet。如果其值不等于0，在接下来执行所有待决的tasklet时，将忽略对应的tasklet。</span></span><br><span class="line">	<span class="built_in">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);<span class="comment">//执行函数地址</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data;<span class="comment">//data用作该函数执行时的参数。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>tasklet_vec 是一个pcpu变量，也就是每一个cpu上上的tasklet组成一个list.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tasklet_head</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tasklet_struct</span> *head;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tasklet_struct</span> **tail;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_vec)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="注册tasklet"><a href="#注册tasklet" class="headerlink" title="注册tasklet"></a>注册tasklet</h4><p>要使用它，首先必须注册它；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t,</span></span></span><br><span class="line"><span class="params"><span class="function">		  <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	t-&gt;state = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">atomic_set</span>(&amp;t-&gt;count, <span class="number">0</span>);</span><br><span class="line">	t-&gt;func = func;</span><br><span class="line">	t-&gt;data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行："><a href="#执行：" class="headerlink" title="执行："></a>执行：</h4><p>tasklet基于软中断实现，它们总是在处理软中断时执行。<br>tasklet关联到TASKLET_SOFTIRQ软中断。因而，调用raise_softirq(TASKLET_SOFTIRQ)，即可<br>在下一个适当的时机执行当前处理器的tasklet。<br>interrupt.h:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">test_and_set_bit</span>(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">		__tasklet_schedule(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __tasklet_schedule(<span class="keyword">struct</span> tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">local_irq_save</span>(flags);</span><br><span class="line">	t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	*__this_cpu_read(tasklet_vec.tail) = t;</span><br><span class="line">	__this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next));</span><br><span class="line">	<span class="built_in">raise_softirq_irqoff</span>(TASKLET_SOFTIRQ);</span><br><span class="line">	<span class="built_in">local_irq_restore</span>(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核使用tasklet_action作为该软中断的action函数<br>该函数首先确定特定于CPU的链表，其中保存了标记为将要执行的各个tasklet。它接下来将表头<br>重定向到函数局部的一个数据项，相当于从外部公开的链表删除了所有表项。接下来，函数在以下循<br>环中逐一处理各个tasklet：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">tasklet_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tasklet_struct</span> *list;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">local_irq_disable</span>();</span><br><span class="line">	list = __this_cpu_read(tasklet_vec.head);</span><br><span class="line">	__this_cpu_write(tasklet_vec.head, <span class="literal">NULL</span>);</span><br><span class="line">	__this_cpu_write(tasklet_vec.tail, <span class="built_in">this_cpu_ptr</span>(&amp;tasklet_vec.head));</span><br><span class="line">	<span class="built_in">local_irq_enable</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (list) &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">tasklet_struct</span> *t = list;</span><br><span class="line"></span><br><span class="line">		list = list-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">tasklet_trylock</span>(t)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">atomic_read</span>(&amp;t-&gt;count)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">test_and_clear_bit</span>(TASKLET_STATE_SCHED,</span><br><span class="line">							&amp;t-&gt;state))</span><br><span class="line">					<span class="built_in">BUG</span>();</span><br><span class="line">				t-&gt;<span class="built_in">func</span>(t-&gt;data);</span><br><span class="line">				<span class="built_in">tasklet_unlock</span>(t);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">tasklet_unlock</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">local_irq_disable</span>();</span><br><span class="line">		t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		*__this_cpu_read(tasklet_vec.tail) = t;</span><br><span class="line">		__this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next));</span><br><span class="line">		__raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">		<span class="built_in">local_irq_enable</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在while循环中执行tasklet，类似于处理软中断使用的机制。<br>因为一个tasklet只能在一个处理器上执行一次，但其他的tasklet可以并行运行，所以需要特定于<br>tasklet 的 锁 。 state 状 态 用 作 锁 变 量 。 在 执 行 一 个 tasklet 的 处 理 程 序 函 数 之 前 ， 内 核 使 用<br>tasklet_trylock检查tasklet的状态是否为TASKLET_STATE_RUN。换句话说，它是否已经在系<br>统的另一个处理器上运行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;interrupt.h&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">tasklet_trylock</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">test_and_set_bit</span>(TASKLET_STATE_RUN, &amp;(t)-&gt;state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了普通的tasklet之外，内核还使用了另一种tasklet，它具有“较高”的优先级。除以下修改之<br>外，其实现与普通的tasklet完全相同。</p>
<ol>
<li>使用HI_SOFTIRQ作为软中断，而不是TASKLET_SOFTIRQ，相关的action函数是tasklet_<br>hi_action。</li>
<li>注册的tasklet在CPU相关的变量tasklet_hi_vec中排队。这是使用tasklet_hi_schedule完<br>成的。<br>在这里，“较高优先级”是指该软中断的处理程序HI_SOFTIRQ在所有其他处理程序之前执行，<br>尤其是在构成了软中断活动主体的网络处理程序之前执行。<br>当前，大部分声卡驱动程序都利用了这一选项，因为操作延迟时间太长可能损害音频输出的音质。<br>而用于高速传输的网卡也可以得益于该机制</li>
</ol>
<h3 id="等待队列和完成量；"><a href="#等待队列和完成量；" class="headerlink" title="等待队列和完成量；"></a>等待队列和完成量；</h3><p>等待队列（ wait queue）用于使进程等待某一特定事件发生，而无须频繁轮询。进程在等待期间<br>睡眠，在事件发生时由内核自动唤醒。 完成量（ completion）机制基于等待队列，内核利用该机制等<br>待某一操作结束。这两种机制使用得都比较频繁，主要用于设备驱动程序，</p>
<h4 id="等待队列："><a href="#等待队列：" class="headerlink" title="等待队列："></a>等待队列：</h4><h5 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h5><p>每个等待队列都有一个队列头：<br>wait.h:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__wait_queue_head</span> &#123;</span><br><span class="line">	<span class="type">spinlock_t</span>		lock;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	task_list;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__wait_queue_head</span> <span class="type">wait_queue_head_t</span>;</span><br></pre></td></tr></table></figure>
<p>因为等待队列也可以在中断时修改，在操作队列之前必须获得一个自旋锁lock。<br>task_list是一个双链表，用于实现双链表最擅长表示的结构，即队列。</p>
<p>队列中的成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__wait_queue</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags; <span class="comment">//表示等待进程想要被独占地唤醒：则用WQ_FLAG_EXCLUSIVE</span></span><br><span class="line">	<span class="type">void</span>			*<span class="keyword">private</span>;<span class="comment">//指向等待进程的task_struct实例；</span></span><br><span class="line">	<span class="type">wait_queue_func_t</span>	func;<span class="comment">//调用func，唤醒等待进程</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	task_list;<span class="comment">//用作链表元素，将wait_queue_t实例放入等待队列中；</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>等待队列的使用分为如下两部分。<br>(1) 为使当前进程在一个等待队列中睡眠，需要调用wait_event函数（或某个等价函数，在下文<br>讨论）。进程进入睡眠，将控制权释放给调度器。<br>内核通常会在向块设备发出传输数据的请求后，调用该函数。因为传输不会立即发生，而在此期<br>间又没有其他事情可做，所以进程可以睡眠，将CPU时间让给系统中的其他进程。<br>(2) 在内核中另一处，就我们的例子而言，是来自块设备的数据到达后，必须调用wake_up函数（或<br>某个等价函数，将在下文讨论）来唤醒等待队列中的睡眠进程。<br>在使用wait_event使进程睡眠之后，必须确保在内核中另一处有一个对应的wake_up调用</p>
<h5 id="使进程睡眠："><a href="#使进程睡眠：" class="headerlink" title="使进程睡眠："></a>使进程睡眠：</h5><p>add_wait_queue函数用于将一个进程增加到等待队列，该函数在获得必要的自旋锁后，将工作<br>委托给__add_wait_queue：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;wait.h&gt;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __add_wait_queue(<span class="type">wait_queue_head_t</span> *head, <span class="type">wait_queue_t</span> *<span class="keyword">new</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list_add</span>(&amp;<span class="keyword">new</span>-&gt;task_list, &amp;head-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在将新进程统计到等待队列时，除了使用标准的list_add链表函数，没有其他工作需要做。<br>内核还提供了add_wait_queue_exclusive函数。它的工作方式与add_wait_queue相同，但将<br>进程插入在队列尾部，并将其标志设置为WQ_EXCLUSIVE</p>
<p>另一种方法： prepare_to_wait也是用来使进程睡眠，比上述方法多一个参数，表示进程状态；</p>
<p>初始化一个动态分配的wait_queue_t实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_waitqueue_entry</span><span class="params">(<span class="type">wait_queue_t</span> *q, <span class="keyword">struct</span> task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q-&gt;flags	= <span class="number">0</span>;</span><br><span class="line">	q-&gt;<span class="keyword">private</span>	= p;</span><br><span class="line">	q-&gt;func		= default_wake_function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者DEFINE_WAIT创建wait_queue_t的静态实例，它可以自动初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_WAIT_BIT(name, word, bit)				\</span></span><br><span class="line"><span class="meta">	struct wait_bit_queue name = &#123;					\</span></span><br><span class="line"><span class="meta">		.key = __WAIT_BIT_KEY_INITIALIZER(word, bit),		\</span></span><br><span class="line"><span class="meta">		.wait	= &#123;						\</span></span><br><span class="line"><span class="meta">			.private	= current,			\</span></span><br><span class="line"><span class="meta">			.func		= wake_bit_function,		\</span></span><br><span class="line"><span class="meta">			.task_list	=				\</span></span><br><span class="line"><span class="meta">				LIST_HEAD_INIT((name).wait.task_list),	\</span></span><br><span class="line"><span class="meta">		&#125;,							\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br></pre></td></tr></table></figure>

<p>使进程睡眠，通常不直接调用add_wait_queue,而是调用wait_event；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __wait_event(wq, condition)					\</span></span><br><span class="line"><span class="meta">	(void)___wait_event(wq, condition, TASK_UNINTERRUPTIBLE, 0, 0,	\</span></span><br><span class="line"><span class="meta">			    schedule())#<span class="keyword">define</span> ___wait_event(wq, condition, state, exclusive, ret, cmd)	\</span></span><br><span class="line"><span class="meta">(&#123;									\</span></span><br><span class="line"><span class="meta">	__label__ __out;						\</span></span><br><span class="line"><span class="meta">	wait_queue_t __wait;						\</span></span><br><span class="line"><span class="meta">	long __ret = ret;	<span class="comment">/* explicit shadow */</span>			\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">	INIT_LIST_HEAD(&amp;__wait.task_list);				\</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (exclusive)							\</span></span><br><span class="line"><span class="meta">		__wait.flags = WQ_FLAG_EXCLUSIVE;			\</span></span><br><span class="line"><span class="meta">	<span class="keyword">else</span>								\</span></span><br><span class="line"><span class="meta">		__wait.flags = 0;					\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">	for (;;) &#123;							\</span></span><br><span class="line"><span class="meta">		long __int = prepare_to_wait_event(&amp;wq, &amp;__wait, state);\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span> (condition)						\</span></span><br><span class="line"><span class="meta">			break;						\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span> (___wait_is_interruptible(state) &amp;&amp; __int) &#123;		\</span></span><br><span class="line"><span class="meta">			__ret = __int;					\</span></span><br><span class="line"><span class="meta">			<span class="keyword">if</span> (exclusive) &#123;				\</span></span><br><span class="line"><span class="meta">				abort_exclusive_wait(&amp;wq, &amp;__wait,	\</span></span><br><span class="line"><span class="meta">						     state, NULL);	\</span></span><br><span class="line"><span class="meta">				goto __out;				\</span></span><br><span class="line"><span class="meta">			&#125;						\</span></span><br><span class="line"><span class="meta">			break;						\</span></span><br><span class="line"><span class="meta">		&#125;							\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">		cmd;							\</span></span><br><span class="line"><span class="meta">	&#125;								\</span></span><br><span class="line"><span class="meta">	finish_wait(&amp;wq, &amp;__wait);					\</span></span><br><span class="line"><span class="meta">__out:	__ret;								\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">每次进程被唤醒时，内核都会检查指定的条件是否满足，如果条件满足则</span><br><span class="line">退出无限循环。否则，将控制转交给调度器，进程再次睡眠。</span><br></pre></td></tr></table></figure>
<p>在条件满足时， finish_wait将进程状态设置回TASK_RUNNING，并从等待队列的链表移除对应的项。<br>除了wait_event之外，内核还定义了其他几个函数，可以将当前进程置于等待队列中。其实现实际上等同于sleep_on：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;wait.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wait_event_interruptible(wq, condition)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wait_event_timeout(wq, condition, timeout) &#123; ... &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wait_event_interruptible_timeout(wq, condition, timeout)</span></span><br></pre></td></tr></table></figure>
<ol>
<li>wait_event_interruptible使用的进程状态为TASK_INTERRUPTIBLE。因而睡眠进程可以通<br>过接收信号而唤醒。</li>
<li>wait_event_timeout等待满足指定的条件，但如果等待时间超过了指定的超时限制（按jiffies<br>指定）则停止。这防止了进程永远睡眠。</li>
<li>wait_event_interruptible_timeout使进程睡眠，但可以通过接收信号唤醒。它也注册了<br>一个超时限制。从内核采用的命名方式来看，一般不会有出人意料之处！</li>
</ol>
<h5 id="唤醒进程："><a href="#唤醒进程：" class="headerlink" title="唤醒进程："></a>唤醒进程：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;wait.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wake_up(x) __wake_up(x, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, 1, NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wake_up_nr(x, nr) __wake_up(x, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, nr, NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wake_up_all(x) __wake_up(x, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, 0, NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wake_up_interruptible(x) __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wake_up_interruptible_nr(x, nr) __wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wake_up_interruptible_all(x) __wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)</span></span><br><span class="line">在获得了用于保护等待队列首部的锁之后， _wake_up将工作委托给_wake_up_common。</span><br><span class="line"></span><br><span class="line">kernel/sched.c</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __wake_up_common(<span class="type">wait_queue_head_t</span> *q, <span class="type">unsigned</span> <span class="type">int</span> mode,</span><br><span class="line"><span class="type">int</span> nr_exclusive, <span class="type">int</span> sync, <span class="type">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">wait_queue_t</span> *curr, *next;</span><br><span class="line">...</span><br><span class="line">q用于选定等待队列，而mode指定进程的状态，用于控制唤醒进程的条件。 nr_exclusive表示</span><br><span class="line">将要唤醒的设置了WQ_FLAG_EXCLUSIVE标志的进程的数目。</span><br><span class="line">内核接下来遍历睡眠进程，并调用其唤醒函数func：</span><br><span class="line">kernel/sched.<span class="function">c</span></span><br><span class="line"><span class="function"><span class="title">list_for_each_safe</span><span class="params">(curr, next, &amp;q-&gt;task_list, task_list)</span> </span>&#123;</span><br><span class="line"><span class="type">unsigned</span> flags = curr-&gt;flags;</span><br><span class="line"><span class="keyword">if</span> (curr-&gt;<span class="built_in">func</span>(curr, mode, sync, key) &amp;&amp;</span><br><span class="line">(flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br></pre></td></tr></table></figure>

<p>这里会反复扫描链表，直至没有更多进程需要唤醒，或已经唤醒的独占进程的数目达到了<br>nr_exclusive。该限制用于避免所谓的惊群（ thundering herd）问题。如果几个进程在等待独占访问<br>某一资源，那么同时唤醒所有等待进程是没有意义的，因为除了其中一个之外，其他进程都会再次睡<br>眠。 nr_exclusive推广了这一限制。<br>最常使用的wake_up函数将nr_exclusive设置为1，确保只唤醒一个独占访问的进程</p>
<h4 id="完成量"><a href="#完成量" class="headerlink" title="完成量"></a>完成量</h4><p>完成量和信号量有相似之处，但是都是基于等待队列实现的；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;completion.h&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">completion</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> done;</span><br><span class="line"><span class="type">wait_queue_head_t</span> wait;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>init_completion初始化一个动态分配的completion实例，而DECLARE_COMPLETION宏用来建立<br>该数据结构的静态实例。<br>进程可以用wait_for_completion添加到等待队列，进程在其中等待（以独占睡眠状态），直至<br>请求被内核的某些部分处理。这函数需要一个completion实例作为参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;completion.h&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_for_completion</span><span class="params">(<span class="keyword">struct</span> completion *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wait_for_completion_interruptible</span><span class="params">(<span class="keyword">struct</span> completion *x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">wait_for_completion_timeout</span><span class="params">(<span class="keyword">struct</span> completion *x,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">wait_for_completion_interruptible_timeout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> completion *x, <span class="type">unsigned</span> <span class="type">long</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在请求由内核的另一部分处理之后，必须调用complete或complete_all来唤醒等待的进程。因<br>为每次调用只能从完成量的等待队列移除一个进程，对n个等待进程来说，必须调用该函数n次。 另一<br>方面， complete_all将唤醒所有等待该完成的进程。 complete_and_exit是一个小的包装器，首先<br>调用complete，接下来调用do_exit结束内核线程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;completion.h&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complete</span><span class="params">(<span class="keyword">struct</span> completion *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complete_all</span><span class="params">(<span class="keyword">struct</span> completion *)</span></span>;</span><br><span class="line">kernel/exit.<span class="function">c</span></span><br><span class="line"><span class="function">NORET_TYPE <span class="type">void</span> <span class="title">complete_and_exit</span><span class="params">(<span class="keyword">struct</span> completion *comp, <span class="type">long</span> code)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="工作队列："><a href="#工作队列：" class="headerlink" title="工作队列："></a>工作队列：</h4><p>工作队列是将操作延期执行的另一种手段：因为它们是通过守护进程在用户上下文执行，函数可<br>以睡眠任意长的时间，这与内核是无关的。在内核版本2.5开发期间，设计了工作队列，用以替换此前<br>使用的keventd机制。</p>
<p>每个工作队列都有一个数组，数组项的数目与系统中处理器的数目相同。每个数组项都列出了将<br>延期执行的任务。<br>对每个工作队列来说，内核都会创建一个新的内核守护进程，延期任务使用上文描述的等待队列<br>机制，在该守护进程的上下文中执行。</p>
<ul>
<li>创建新工作队列：<br>新的工作队列通过调用create_workqueue或create_workqueue_singlethread函数来创建。前<br>一个函数在所有CPU上都创建一个工作线程，而后者只在系统的第一个CPU上创建一个线程。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>interrupt</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_netdevicelayer</title>
    <url>/2021/05/22/linux-netdevicelayer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h3><h4 id="描述linux网络协议栈结构："><a href="#描述linux网络协议栈结构：" class="headerlink" title="描述linux网络协议栈结构："></a>描述linux网络协议栈结构：</h4><ol>
<li><p>常规的方式：传统的单机网络结构：<br>一个服务器(server)上，运行一个linux系统，linux系统之上运行一个协议栈，支持相关上层应用；<br>服务器的下方(硬件设备)，接一个或多个网卡，代表这个系统可能支持多个ip，多个出口等；每个网卡NIC接不同的交换机(路由器),来连接到可能不同的<br>运营商物理网络，如下图：在这种情况下一个服务器为一个单点的物理机；<span id="more"></span></p>
</li>
<li><p>虚拟机虚拟网络架构：<br>一个服务器，其实可能会是个多核比如32核的cpu,运算能力强，也配了一个或多个网卡，可以运行多个虚拟机(操作系统)，像vmware,virtualbox,kvm,qemu<br>等软件支持的虚拟机，可以运行多个不同操作系统的虚拟机，各个虚拟机之间相互隔离；<br>这个虚拟机架构需要网络架构上支持，称虚拟网络架构，每个虚拟机有各自的虚拟网卡，每个虚拟机之间的通信，通过将每个虚拟网卡连接到多个虚拟交换机上(虚拟交换机也是在这个服务器上),从而分成几个隔离的虚拟网络；最后需要经过物理网络出口入口时，由虚拟交换机接出；<br>虚拟机架构：Hypervisor: 一种模拟器，常见的实现有vmward,virtualbox,qemu,kvm,半虚拟化的virtio等等<br>虚拟交换机架构： open vSwitch<br>虚拟网卡： 有tap&#x2F;tun的实现例子<br>虚拟lan: VLANS, macvlan,ipvlan等<br>硬件加速：intel虚拟化技术： VT-d  </p>
</li>
<li><p>openstack：<br>可以说是云计算的开源架构吧，它可以实现为一套软件，如目前的laaS(Infrastructure as a Service基础设施即服务)&#x2F;Paas&#x2F;SaaS<br>基础设施资源，主要包括三个方面：计算、存储、网络。说通俗点，就是CPU，硬盘，网卡。<br>OpenStack对资源进行管理，并且以服务的形式提供给上层应用或者用户去使用。<br>laaS: 厂商管理网络，存储，服务器，虚拟化，即厂商提供docker或其他的类型的虚拟云主机(容器云等)，由使用者用户管理虚拟机上的操作系统，中间件，运行时环境，数据以及应用程序<br>PaaS: 厂商管理网络，存储，服务器，虚拟化，操作系统，中间件和运行时环境，而用户只需要部署其数据和应用程序就好了；<br>SaaS:全部都由厂商来管理；</p>
</li>
</ol>
<h4 id="这里先不讨论虚拟化的网络架构，先看传统的结构："><a href="#这里先不讨论虚拟化的网络架构，先看传统的结构：" class="headerlink" title="这里先不讨论虚拟化的网络架构，先看传统的结构："></a>这里先不讨论虚拟化的网络架构，先看传统的结构：</h4><h5 id="1-描述这一层的位置，具体含义。"><a href="#1-描述这一层的位置，具体含义。" class="headerlink" title="1 描述这一层的位置，具体含义。"></a>1 描述这一层的位置，具体含义。</h5><p>网络设备分为物理网络设备和虚拟网络设备，这里将网络设备都简化为只讨论网卡；</p>
<ul>
<li>对网卡而言：有它的特性：<br>带宽，速度： 即它是千兆网卡还是其他，这个可以通过指令拿到：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo ethtool eth0</span><br><span class="line">Settings <span class="keyword">for</span> eth0:</span><br><span class="line">	Supported ports: [ TP ]</span><br><span class="line">	Supported link modes:   <span class="number">10b</span>aseT/Half <span class="number">10b</span>aseT/Full </span><br><span class="line">	                        <span class="number">100b</span>aseT/Half <span class="number">100b</span>aseT/Full </span><br><span class="line">	                        <span class="number">1000b</span>aseT/Full </span><br><span class="line">	Supported pause frame use: Symmetric</span><br><span class="line">	Supports <span class="keyword">auto</span>-negotiation: Yes</span><br><span class="line">	Advertised link modes:  <span class="number">10b</span>aseT/Half <span class="number">10b</span>aseT/Full </span><br><span class="line">	                        <span class="number">100b</span>aseT/Half <span class="number">100b</span>aseT/Full </span><br><span class="line">	                        <span class="number">1000b</span>aseT/Full </span><br><span class="line">	Advertised pause frame use: Symmetric</span><br><span class="line">	Advertised <span class="keyword">auto</span>-negotiation: Yes</span><br><span class="line">	Speed: <span class="number">1000</span>Mb/s  千兆网卡</span><br><span class="line">	Duplex: Full</span><br><span class="line">	Port: Twisted Pair</span><br><span class="line">	PHYAD: <span class="number">1</span></span><br><span class="line">	Transceiver: internal</span><br><span class="line">	Auto-negotiation: on</span><br><span class="line">	MDI-X: on</span><br><span class="line">	Supports Wake-on: pumbg</span><br><span class="line">	Wake-on: g</span><br><span class="line">	Current message level: <span class="number">0x00000007</span> (<span class="number">7</span>)</span><br><span class="line">			       drv probe link</span><br><span class="line">	Link detected: yes</span><br></pre></td></tr></table></figure>

<p>其他特性： 网卡支持的工作模式，是否支持多队列等等；<br>其中多队列的特性比较重要，即意味着它支不支持RSS:</p>
<ul>
<li>关于RSS,RPS,RFS等：</li>
<li>RSS：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">支持多队列的NIC的驱动程序通常提供一个内核模块参数来指定要配置的硬件队列的数量。例如，在bnx2x驱动程序中，这个参数被称为num_queues。典型的RSS配置是，如果设备支持足够的队列，那么每个CPU都有一个接收队列，或者至少每个内存域有一个接收队列，其中内存域是一组共享特定内存级别(L1、L2、NUMA节点等)的CPU。</span><br><span class="line">RSS设备的间接表(通过屏蔽散列解析队列)通常是由驱动程序在初始化时编写的。默认的映射是将队列均匀地分布在表中，但是可以在运行时使用ethtool命令(——show-rxfh-indir和——<span class="built_in">set</span>-rxfh-indir)检索和修改间接表。可以通过修改间接表来为不同的队列指定不同的相对权重。</span><br><span class="line">RSS irq 配置</span><br><span class="line">每个接收队列都有一个与之相关联的独立IRQ。当新包到达给定队列时，NIC会触发此操作通知CPU。PCIe设备的信令路径使用消息信号中断(MSI-X)，它可以将每个中断路由到特定的CPU。队列到irq的活动映射可以从/proc/interrupts中确定。默认情况下，IRQ可以在任何CPU上处理。因为数据包处理中不可忽略的一部分发生在接收中断处理中，所以在cpu之间分散接收中断是有利的。手动调整每个interru的IRQ亲和力</span><br><span class="line"></span><br><span class="line">推荐配置，即中断打散：</span><br><span class="line">当考虑延迟或接收中断处理形成瓶颈时，应该启用RSS。在cpu之间分散负载会减少队列长度。对于低延迟网络，最佳设置是分配与系统中cpu数量相同的队列(如果更低，则为网卡最大值)。最有效的高速率配置可能是接收队列数量最少的配置，其中没有由于CPU饱和而导致的接收队列溢出，因为在启用中断合并的默认模式下，中断的聚合数量(因此工作)会随着每增加一个而增加</span><br><span class="line">可以使用mpstat实用程序观察每个CPU的负载，但是请注意，在具有超线程(HT)的处理器上，每个超线程都表示为一个单独的CPU。对于中断处理，HT在最初的测试中没有显示出任何好处，因此将队列的数量限制在系统中的CPU内核的数量。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>内核代码实现中，将支持此种特性时，用MSI-X来表示，可以看相关函数名；<br>查看网卡队列：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ethtool -l eth1</span><br><span class="line">Channel parameters <span class="keyword">for</span> eth1:</span><br><span class="line">Pre-<span class="built_in">set</span> maximums:</span><br><span class="line">RX:		<span class="number">0</span></span><br><span class="line">TX:		<span class="number">0</span></span><br><span class="line">Other:		<span class="number">1</span></span><br><span class="line">Combined:	<span class="number">32</span>  <span class="comment">//网卡支持的</span></span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:		<span class="number">0</span></span><br><span class="line">TX:		<span class="number">0</span></span><br><span class="line">Other:		<span class="number">1</span></span><br><span class="line">Combined:	<span class="number">20</span> <span class="comment">//当前配置的</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>RPS：<br>对于单队列网卡，可以通过RPS (receive packet steering)或RFS (receive flow steering)两种方式模拟多队列模式，但效果不如启用RSS的多队列网卡<br>接收包转向(Receive packet steering, RPS)在cpu之间平衡软中断的负载.  网卡驱动程序通过使用一个四联体(SIP、SPORT、DIP和DPORT)计算每个流的哈希ID，中断处理程序将哈希ID分配给相应的CPU，从而充分利用多核能力<br>RPS通常是通过软件来模拟多队列网卡的功能。当网卡支持多队列时，RPS无效。RPS主要用于多cpu环境中的单队列网卡。如果一个网卡支持多个队列，可以通过配置SMP IRQ亲和性直接将硬中断绑定到cpu。</p>
</li>
<li><p>RFS:<br>RPS只是将数据包分配到不同的cpu上。当使用不同的CPU运行应用程序和处理软中断时，这会大大降低CPU缓存的利用率。在这种情况下，RFS确保使用一个CPU来运行应用程序和处理软中断，以充分利用CPU缓存。RPS和RFS通常一起使用以获得最好的结果。它们主要用于多cpu环境中的单队列网卡。<br>即RFS和应用绑定一起，确保该cpu上收到的包，就是被该cpu上运行的应用处理的，仔细看下面两个图，前面是RPS，data3-&gt;app8了，无关联，但是后面的是RFS，data3-&gt;app3，都是3</p>
</li>
</ul>
<p>接收流导向(Receive flow steering, RFS)与RPS一起，将数据包插入指定CPU的backlog队列中，并唤醒CPU执行。<br>IRQbalance适用于大多数场景。但在对网络性能要求较高的场景下，建议手动绑定中断。<br>IRQbalance在运行过程中可能会出现以下问题:a)计算值有时不合适，无法实现cpu之间的负载均衡。(b)当系统处于空闲状态，irq处于省电模式时，IRQbalance将所有中断分配到第一个CPU，使其他空闲CPU休眠，降低能耗。当负载突然上升时，可能会由于调整滞后而导致性能下降。(c)指定处理中断的CPU频繁变化，导致更多的上下文切换。(d)启用IRQbalance但不生效，即没有指定处理中断的CPU。</p>
<p>more:<a href="https://01.org/linuxgraphics/gfx-docs/drm/networking/scaling.html">https://01.org/linuxgraphics/gfx-docs/drm/networking/scaling.html</a></p>
<h5 id="2-关于网络设备层：网络收发时的总体流程，以及这一层的流程；并贴上大致的函数调用接口"><a href="#2-关于网络设备层：网络收发时的总体流程，以及这一层的流程；并贴上大致的函数调用接口" class="headerlink" title="2 关于网络设备层：网络收发时的总体流程，以及这一层的流程；并贴上大致的函数调用接口"></a>2 关于网络设备层：网络收发时的总体流程，以及这一层的流程；并贴上大致的函数调用接口</h5><p>Linux内核中有一个网络设备管理层，处于网络设备驱动和协议栈之间，负责衔接它们之间的数据交互。驱动不需要了解协议栈的细节，协议栈也不需要了解设备驱动的细节。<br>对于一个网络设备来说，就像一个管道（pipe）一样，有两端，从其中任意一端收到的数据将从另一端发送出去。<br>比如一个物理网卡eth0，它的两端分别是内核协议栈（通过内核网络设备管理模块间接的通信）和外面的物理网络，从物理网络收到的数据，会转发给内核协议栈，而应用程序从协议栈发过来的数据将会通过物理网络发送出去。</p>
<ul>
<li>网络设备层收包流程：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">                   +-----+</span><br><span class="line">                   |     |                            Memroy</span><br><span class="line">+--------+   <span class="number">1</span>     |     |  <span class="number">2</span>  DMA     +--------+--------+--------+--------+</span><br><span class="line">| Packet |--------&gt;| NIC |------------&gt;| Packet | Packet | Packet | ...... |</span><br><span class="line">+--------+         |     |             +--------+--------+--------+--------+</span><br><span class="line">                   |     |&lt;--------+</span><br><span class="line">                   +-----+         |</span><br><span class="line">                      |            +---------------+</span><br><span class="line">                      |                            |</span><br><span class="line">                    <span class="number">3</span> | Raise IRQ                  | Disable IRQ</span><br><span class="line">                      |                          <span class="number">5</span> |</span><br><span class="line">                      |                            |</span><br><span class="line">                      ↓                            |</span><br><span class="line">                   +-----+                   +------------+</span><br><span class="line">                   |     |  Run IRQ handler  |            |</span><br><span class="line">                   | CPU |------------------&gt;| NIC Driver |</span><br><span class="line">                   |     |       <span class="number">4</span>           |            |</span><br><span class="line">                   +-----+                   +------------+</span><br><span class="line">                                                   |</span><br><span class="line">                                                <span class="number">6</span>  | Raise soft IRQ</span><br><span class="line">                                                   |</span><br><span class="line">                                                   ↓</span><br><span class="line"><span class="comment">//来源：https://segmentfault.com/a/1190000008836467</span></span><br></pre></td></tr></table></figure></li>
<li>具体步骤</li>
</ul>
<ol start="0">
<li><p>网卡初始化和启动：在开机时module_init初始化部分，然后在pci或其他总线发现设备时，调用probe进一步真正初始化；在类似ifconfig up的指令启动网卡后，<br>会调用到网卡的xxx_open函数，进行如中断注册，使能等操作；这个时候，设备就可以开始工作了；  </p>
</li>
<li><p>数据包从外面的网络进入物理网卡。这个时候网卡芯片自身的逻辑(固件),会判断如果目的mac地址不是该网卡的，且该网卡没有开启混杂模式，该包会被网卡丢弃，这里发生在网卡固件逻辑上，没在驱动做处理。先代网卡分以太网卡，和wifi网卡，又根据接口不同，有pci接口的，和usb接口的，比如常见的usbwifi网卡；<br>以太网的物理头和wifi物理头(802.11头)，不一样，或者说支持的协议不同，根源是物理环境不同；wifi的环境是空气；  </p>
</li>
<li><p>网卡将数据包通过DMA的方式写入到指定的内存地址，该地址由网卡驱动分配并初始化。注： 老的网卡可能不支持DMA，不过新的网卡一般都支持。  </p>
</li>
<li><p>网卡通过硬件中断（IRQ）通知CPU，告诉它有数据来了<br>4）CPU根据中断表，调用已经注册的中断函数，这个中断函数会调到驱动程序（NIC Driver）中相应的函数  </p>
</li>
<li><p>对NAPI模式： 驱动先禁用网卡的中断，表示驱动程序已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知CPU了，这样可以提高效率，避免CPU不停的被中断。  </p>
</li>
<li><p>对非NAPI的模式，驱动是每次中断处理接收数据，然后写到内存的；这里NAPI的N是new的意思；  </p>
</li>
<li><p>启动软中断。这步结束后，硬件中断处理函数就结束返回了。由于硬中断处理程序执行的过程中不能被中断，所以如果它执行时间过长，会导致CPU没法响应其它硬件的中断，于是内核引入软中断，这样可以将硬中断处理函数中耗时的部分移到软中断处理函数里面来慢慢处理。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                                            +-----+</span><br><span class="line">                                    <span class="number">17</span>      |     |</span><br><span class="line">                               +-----------&gt;| NIC |</span><br><span class="line">                               |            |     |</span><br><span class="line">                               |Enable IRQ  +-----+</span><br><span class="line">                               |</span><br><span class="line">                               |</span><br><span class="line">                         +------------+                                      Memroy</span><br><span class="line">                         |            |        Read           +--------+--------+--------+--------+</span><br><span class="line">        +---------------&gt;| NIC Driver |&lt;--------------------- | Packet | Packet | Packet | ...... |</span><br><span class="line">        |                |            |          <span class="number">9</span>            +--------+--------+--------+--------+</span><br><span class="line">        |                +------------+</span><br><span class="line">        |                      |    |        skb</span><br><span class="line">   Poll | <span class="number">8</span>      Raise softIRQ | <span class="number">6</span>  +-----------------+</span><br><span class="line">        |                      |             <span class="number">10</span>       |</span><br><span class="line">        |                      ↓                      ↓</span><br><span class="line">+---------------+  Call  +-----------+        +------------------+        +--------------------+  <span class="number">12</span>  +---------------------+</span><br><span class="line">| net_rx_action |&lt;-------| ksoftirqd |        | napi_gro_receive |-------&gt;| enqueue_to_backlog |-----&gt;| CPU input_pkt_queue |</span><br><span class="line">+---------------+   <span class="number">7</span>    +-----------+        +------------------+   <span class="number">11</span>   +--------------------+      +---------------------+</span><br><span class="line">                                                      |                                                      | <span class="number">13</span></span><br><span class="line">                                                   <span class="number">14</span> |        + - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">                                                      ↓        ↓</span><br><span class="line">                                           +--------------------------+    <span class="number">15</span>      +------------------------+</span><br><span class="line">                                           | __netif_receive_skb_core |-----------&gt;| packet <span class="title function_">taps</span><span class="params">(AF_PACKET)</span> |</span><br><span class="line">                                           +--------------------------+            +------------------------+</span><br><span class="line">                                                      |</span><br><span class="line">                                                      | 16</span><br><span class="line">                                                      ↓</span><br><span class="line">                                             +-----------------+</span><br><span class="line">                                             | protocol layers |</span><br><span class="line">                                             +-----------------+</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>内核中的ksoftirqd进程专门负责软中断的处理，当它收到软中断后，就会调用相应软中断所对应的处理函数，对于上面第7步中是网卡驱动模块抛出的软中断，ksoftirqd会调用网络模块的net_rx_action函数,这个函数是在初始化时，注册到指定的网络接收软中断上的；  </li>
<li>net_rx_action调用网卡驱动里的poll函数来一个一个的处理数据包  </li>
<li>在poll函数中，驱动会一个接一个的读取网卡写到内存中的数据包，内存中数据包的格式只有驱动知道  </li>
<li>驱动程序将内存中的数据包转换成内核网络模块能识别的skb格式，然后调用napi_gro_receive函数  </li>
<li>napi_gro_receive会处理GRO相关的内容，也就是将可以合并的数据包进行合并，这样就只需要调用一次协议栈。然后判断是否开启了RPS，如果开启了，将会调用enqueue_to_backlog  </li>
<li>在enqueue_to_backlog函数中，会将数据包放入CPU的softnet_data结构体的input_pkt_queue中，然后返回，如果input_pkt_queue满了的话，该数据包将会被丢弃，queue的大小可以通过net.core.netdev_max_backlog来配置  </li>
<li>CPU会接着在自己的软中断上下文中处理自己input_pkt_queue里的网络数据（调用__netif_receive_skb_core）<br>15） 如果没开启RPS，napi_gro_receive会直接调用__netif_receive_skb_core  </li>
<li>看是不是有AF_PACKET类型的socket（也就是我们常说的原始套接字），如果有的话，拷贝一份数据给它。tcpdump抓包就是抓的这里的包。  </li>
<li>调用协议栈相应的函数，将数据包交给协议栈处理。  </li>
<li>待内存中的所有数据包被处理完成后（即poll函数执行完成），启用网卡的硬中断，这样下次网卡再收到数据的时候就会通知CPU<br>接着传递给协议栈；</li>
</ol>
<ul>
<li>NAPI和非NAPI的区别：以下两篇写得不错，我就不重复写了；<br><a href="http://www.hyuuhit.com/2018/07/25/receive-packet/">http://www.hyuuhit.com/2018/07/25/receive-packet/</a><br><a href="http://cxd2014.github.io/2017/10/15/linux-napi/">http://cxd2014.github.io/2017/10/15/linux-napi/</a></li>
</ul>
<h5 id="网络设备层发包流程："><a href="#网络设备层发包流程：" class="headerlink" title="网络设备层发包流程："></a>网络设备层发包流程：</h5><p>网络数据包通过协议栈后，经过邻居子系统，接着都会调用dev_queue_xmit 进入网络设备层进行发包；<br>期间经过流量控制系统tc,再到发包软中断等，最后在合适的时机，通过设备对应的驱动的发送函数发送出去；<br>整体流程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                        |</span><br><span class="line">                        |</span><br><span class="line">                        ↓</span><br><span class="line">                 +----------------+</span><br><span class="line">+----------------| dev_queue_xmit |</span><br><span class="line">|                +----------------+</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">|                       ↓</span><br><span class="line">|              +-----------------+</span><br><span class="line">|              | Traffic Control |</span><br><span class="line">|              +-----------------+</span><br><span class="line">| loopback              |</span><br><span class="line">|   or                  +--------------------------------------------------------------+</span><br><span class="line">| IP tunnels            ↓                                                              |</span><br><span class="line">|                       ↓                                                              |</span><br><span class="line">|            +---------------------+  Failed   +----------------------+         +---------------+</span><br><span class="line">+-----------&gt;| dev_hard_start_xmit |----------&gt;| raise NET_TX_SOFTIRQ |- - - - &gt;| net_tx_action |</span><br><span class="line">             +---------------------+           +----------------------+         +---------------+</span><br><span class="line">                        |</span><br><span class="line">                        +----------------------------------+</span><br><span class="line">                        |                                  |</span><br><span class="line">                        ↓                                  ↓</span><br><span class="line">                +----------------+              +------------------------+</span><br><span class="line">                | ndo_start_xmit |              | packet <span class="title function_">taps</span><span class="params">(AF_PACKET)</span> |</span><br><span class="line">                +----------------+              +------------------------+</span><br></pre></td></tr></table></figure>
<p>explanation:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dev_queue_xmit： netdevice子系统的入口函数，在该函数中，会先获取设备对应的qdisc，如果没有的话（如loopback或者IP tunnels），就直接调用dev_hard_start_xmit，否则数据包将经过Traffic Control模块进行处理</span><br><span class="line">Traffic Control： 这里主要是进行一些过滤和优先级处理，在这里，如果队列满了的话，数据包会被丢掉，详情请参考文档，这步完成后也会走到dev_hard_start_xmit</span><br><span class="line"></span><br><span class="line">dev_hard_start_xmit： 该函数中，首先是拷贝一份skb给“packet taps”，tcpdump就是从这里得到数据的，然后调用ndo_start_xmit。如果dev_hard_start_xmit返回错误的话（大部分情况可能是NETDEV_TX_BUSY），调用它的函数会把skb放到一个地方，然后抛出软中断NET_TX_SOFTIRQ，交给软中断处理程序net_tx_action稍后重试（如果是loopback或者IP tunnels的话，失败后不会有重试的逻辑）</span><br><span class="line"></span><br><span class="line">ndo_start_xmit： 这是一个函数指针，会指向具体驱动发送数据的函数</span><br></pre></td></tr></table></figure>

<h5 id="ethernet网卡，e1000-igb-i350为例子解释"><a href="#ethernet网卡，e1000-igb-i350为例子解释" class="headerlink" title="ethernet网卡，e1000,igb i350为例子解释"></a>ethernet网卡，e1000,igb i350为例子解释</h5><p>以简单的只有单队列的千兆网卡e1000为例：e1000是<br>e1000_main.c</p>
<ul>
<li><p>pci_scan-&gt;probe: 网卡初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e1000_probe:</span><br><span class="line">    结构： </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span>;</span> <span class="comment">//每个网络设备都有</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_adapter</span> *<span class="title">adapter</span>;</span><span class="comment">//网卡适配器结构，每个网卡有自己的adapter结构，包括napi结构，是否为多队列结构，tx,rx相关属性等；</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_hw</span> *<span class="title">hw</span>;</span><span class="comment">//表示一些硬件属性</span></span><br><span class="line">    流程：主要是初始化以上三个结构</span><br><span class="line">    <span class="comment">/*e1000_probe initializes an adapter identified by a pci_dev structure.</span></span><br><span class="line"><span class="comment"> * The OS initialization, configuring of the adapter private structure,</span></span><br><span class="line"><span class="comment"> * and a hardware reset occur.*/</span></span><br><span class="line">    	netif_napi_add(netdev, &amp;adapter-&gt;napi, e1000_clean, <span class="number">64</span>); --初始化poll函数，为e1000_clean</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动网卡：ifconfig up&#x2F;call open func </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 启动设备，分配相关结构，向操作系统注册中断，看门狗启动，协议栈被通知接口已ready</span></span><br><span class="line"><span class="comment">The open entry point is called when a network interface is made</span></span><br><span class="line"><span class="comment">* active by the system (IFF_UP).  At this point all resources needed</span></span><br><span class="line"><span class="comment">* for transmit and receive operations are allocated, the interrupt</span></span><br><span class="line"><span class="comment">* handler is registered with the OS, the watchdog task is started,</span></span><br><span class="line"><span class="comment">* and the stack is notified that the interface is ready.</span></span><br><span class="line"><span class="comment">**/</span>/</span><br></pre></td></tr></table></figure></li>
</ul>
<p>函数不长，可以看看：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">e1000_open</span><span class="params">(<span class="keyword">struct</span> net_device *netdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">e1000_adapter</span> *adapter = <span class="built_in">netdev_priv</span>(netdev);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">e1000_hw</span> *hw = &amp;adapter-&gt;hw;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* disallow open during test */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">test_bit</span>(__E1000_TESTING, &amp;adapter-&gt;flags))</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">netif_carrier_off</span>(netdev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate transmit descriptors */</span></span><br><span class="line">	err = <span class="built_in">e1000_setup_all_tx_resources</span>(adapter);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_setup_tx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate receive descriptors */</span></span><br><span class="line">	err = <span class="built_in">e1000_setup_all_rx_resources</span>(adapter);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_setup_rx;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">e1000_power_up_phy</span>(adapter);</span><br><span class="line"></span><br><span class="line">	adapter-&gt;mng_vlan_id = E1000_MNG_VLAN_NONE;</span><br><span class="line">	<span class="keyword">if</span> ((hw-&gt;mng_cookie.status &amp;</span><br><span class="line">			  E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT)) &#123;</span><br><span class="line">		<span class="built_in">e1000_update_mng_vlan</span>(adapter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* before we allocate an interrupt, we must be ready to handle it.</span></span><br><span class="line"><span class="comment">	 * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt</span></span><br><span class="line"><span class="comment">	 * as soon as we call pci_request_irq, so we have to setup our</span></span><br><span class="line"><span class="comment">	 * clean_rx handler before we do so.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">e1000_configure</span>(adapter);</span><br><span class="line"></span><br><span class="line">	err = <span class="built_in">e1000_request_irq</span>(adapter);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_req_irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* From here on the code is the same as e1000_up() */</span></span><br><span class="line">	<span class="built_in">clear_bit</span>(__E1000_DOWN, &amp;adapter-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">napi_enable</span>(&amp;adapter-&gt;napi);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">e1000_irq_enable</span>(adapter);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">netif_start_queue</span>(netdev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fire a link status change interrupt to start the watchdog */</span></span><br><span class="line">	<span class="built_in">ew32</span>(ICS, E1000_ICS_LSC);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> E1000_SUCCESS;</span><br><span class="line"></span><br><span class="line">err_req_irq:</span><br><span class="line">	<span class="built_in">e1000_power_down_phy</span>(adapter);</span><br><span class="line">	<span class="built_in">e1000_free_all_rx_resources</span>(adapter);</span><br><span class="line">err_setup_rx:</span><br><span class="line">	<span class="built_in">e1000_free_all_tx_resources</span>(adapter);</span><br><span class="line">err_setup_tx:</span><br><span class="line">	<span class="built_in">e1000_reset</span>(adapter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从这里可以看到中断处理程序：e1000_intr</span></span><br><span class="line">	<span class="type">irq_handler_t</span> handler = e1000_intr;</span><br><span class="line">	<span class="type">int</span> irq_flags = IRQF_SHARED;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = <span class="built_in">request_irq</span>(adapter-&gt;pdev-&gt;irq, handler, irq_flags, netdev-&gt;name,</span><br><span class="line">			  netdev);</span><br></pre></td></tr></table></figure>
<ul>
<li>接收数据包的中断处理：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__napi_schedule(&amp;adapter-&gt;napi); <span class="comment">//这里是napi的，直接进入调度---&gt;__raise_softirq_irqoff(NET_RX_SOFTIRQ);</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">net_rx_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *h)</span></span><br><span class="line">--&gt;budget -= napi_poll(n, &amp;repoll);从设备拉数据</span><br><span class="line">  ---&gt;work = n-&gt;poll(n, weight);从设备拉数据</span><br><span class="line">    --&gt;从上面可以看到poll为e1000_clean</span><br><span class="line">	 --&gt;napi_complete_done   ---dev.c: 通用设备无关函数</span><br><span class="line">	  --&gt;napi_gro_flush==&gt;napi_gro_complete--&gt; 处理gro</span><br><span class="line">	   --&gt;netif_receive_skb_internal --如果打开了RPS,放到对应的cpu队列：enqueue_to_backlog</span><br><span class="line">	     --&gt;__netif_receive_skb --传递到协议栈</span><br></pre></td></tr></table></figure>

<ul>
<li>发送：<br>先看看定义的可供上层调用的函数接口：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">net_device_ops</span> e1000_netdev_ops = &#123;</span><br><span class="line">	.ndo_open		= e1000_open,</span><br><span class="line">	.ndo_stop		= e1000_close,</span><br><span class="line">	.ndo_start_xmit		= e1000_xmit_frame,</span><br><span class="line">	.ndo_get_stats		= e1000_get_stats,</span><br><span class="line">	.ndo_set_rx_mode	= e1000_set_rx_mode,<span class="comment">//设置接收模式，混杂模式或其他</span></span><br><span class="line">	.ndo_set_mac_address	= e1000_set_mac,<span class="comment">//设置mac地址</span></span><br><span class="line">	.ndo_tx_timeout		= e1000_tx_timeout,</span><br><span class="line">	.ndo_change_mtu		= e1000_change_mtu,</span><br><span class="line">	.ndo_do_ioctl		= e1000_ioctl,</span><br><span class="line">	.ndo_validate_addr	= eth_validate_addr,</span><br><span class="line">	.ndo_vlan_rx_add_vid	= e1000_vlan_rx_add_vid,</span><br><span class="line">	.ndo_vlan_rx_kill_vid	= e1000_vlan_rx_kill_vid,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span></span><br><span class="line">	.ndo_poll_controller	= e1000_netpoll,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.ndo_fix_features	= e1000_fix_features,</span><br><span class="line">	.ndo_set_features	= e1000_set_features,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到发送函数：e1000_xmit_frame<br>具体代码流程涉及较多设备相关的函数，暂不分析；</p>
<h6 id="wifi网卡-RTL8180解释"><a href="#wifi网卡-RTL8180解释" class="headerlink" title="wifi网卡 RTL8180解释"></a>wifi网卡 RTL8180解释</h6><p>wifi比较特殊，它有比较复杂的扫描和连接四次握手的流程，这块流程不属于数据包的处理，而是控制包的处理，linux内核将它交给了另一套流程，而上层应用用<br>wpa_supplicant来处理；</p>
<ol>
<li>rtl8187 网卡驱动，是一个usb设备的；<br>它的一些相关函数定义在 drivers&#x2F;…rtl8187&#x2F;dev.c下<br>看下它支持的操作函数ops<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">ieee80211_ops</span> rtl8187_ops = &#123;</span><br><span class="line">	.tx			= rtl8187_tx,</span><br><span class="line">	.start			= rtl8187_start,</span><br><span class="line">	.stop			= rtl8187_stop,</span><br><span class="line">	.add_interface		= rtl8187_add_interface,</span><br><span class="line">	.remove_interface	= rtl8187_remove_interface,</span><br><span class="line">	.config			= rtl8187_config,</span><br><span class="line">	.bss_info_changed	= rtl8187_bss_info_changed,</span><br><span class="line">	.prepare_multicast	= rtl8187_prepare_multicast,</span><br><span class="line">	.configure_filter	= rtl8187_configure_filter,</span><br><span class="line">	.conf_tx		= rtl8187_conf_tx,</span><br><span class="line">	.rfkill_poll		= rtl8187_rfkill_poll,</span><br><span class="line">	.get_tsf		= rtl8187_get_tsf,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
start函数初始化了usb驱动需要的东西，并设置了接收数据的回调函数，可以理解为类似接收中断处理函数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">rtl8187_start</span></span><br><span class="line"><span class="function">    <span class="title">rtl8187_init_urbs</span><span class="params">(dev)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">skb_queue_len</span>(&amp;priv-&gt;rx_queue) &lt; <span class="number">32</span>) &#123;</span><br><span class="line">		skb = __dev_alloc_skb(RTL8187_MAX_RX, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		entry = <span class="built_in">usb_alloc_urb</span>(<span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">usb_fill_bulk_urb</span>(entry, priv-&gt;udev,</span><br><span class="line">				  <span class="built_in">usb_rcvbulkpipe</span>(priv-&gt;udev,</span><br><span class="line">				  priv-&gt;is_rtl8187b ? <span class="number">3</span> : <span class="number">1</span>),</span><br><span class="line">				  <span class="built_in">skb_tail_pointer</span>(skb),</span><br><span class="line">				  RTL8187_MAX_RX, rtl8187_rx_cb, skb);<span class="comment">//接收的回调，这里接收到从usb输入的数据，可能是网络数据</span></span><br><span class="line">		info = (<span class="keyword">struct</span> rtl8187_rx_info *)skb-&gt;cb;</span><br><span class="line">		info-&gt;urb = entry;</span><br><span class="line">		info-&gt;dev = dev;</span><br><span class="line">		<span class="built_in">skb_queue_tail</span>(&amp;priv-&gt;rx_queue, skb);</span><br><span class="line">		<span class="built_in">usb_anchor_urb</span>(entry, &amp;priv-&gt;anchored);</span><br><span class="line">		ret = <span class="built_in">usb_submit_urb</span>(entry, GFP_KERNEL);<span class="comment">//提交后，usb设备核心在数据到达后，会调用回调函数，rx_cb</span></span><br><span class="line">		<span class="built_in">usb_put_urb</span>(entry);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="built_in">skb_unlink</span>(skb, &amp;priv-&gt;rx_queue);</span><br><span class="line">			<span class="built_in">usb_unanchor_urb</span>(entry);</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">接收数据：</span><br><span class="line"></span><br><span class="line">rtl8187_rx_cb 收到包后：</span><br><span class="line">          skb = <span class="built_in">dev_alloc_skb</span>(RTL8187_MAX_RX);<span class="comment">//分配skb</span></span><br><span class="line">          <span class="built_in">ieee80211_rx_irqsafe</span>(dev, skb);</span><br><span class="line">          <span class="built_in">tasklet_schedule</span>(&amp;local-&gt;tasklet);</span><br><span class="line">这里用的是tasklet来处理下半部：</span><br><span class="line">而这个是在ieee80211层处理的，在初始化这个模块时：</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ieee80211_hw</span> *<span class="built_in">ieee80211_alloc_hw_nm</span>(<span class="type">size_t</span> priv_data_len,</span><br><span class="line">    初始化：赋值软中断中半部</span><br><span class="line"><span class="built_in">tasklet_init</span>(&amp;local-&gt;tx_pending_tasklet, ieee80211_tx_pending,</span><br><span class="line">		     (<span class="type">unsigned</span> <span class="type">long</span>)local);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">tasklet_init</span>(&amp;local-&gt;tasklet,</span><br><span class="line">		     ieee80211_tasklet_handler,</span><br><span class="line">		     (<span class="type">unsigned</span> <span class="type">long</span>) local);<span class="comment">//初始化了tasklet的handler，这样在usb接收到数据后能进入tasklet任务</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">ieee80211_rx_irqsafe</span>(<span class="keyword">struct</span> ieee80211_hw *hw, <span class="keyword">struct</span> sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> ieee80211_local *local = <span class="built_in">hw_to_local</span>(hw);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BUILD_BUG_ON</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ieee80211_rx_status) &gt; <span class="built_in">sizeof</span>(skb-&gt;cb));</span><br><span class="line"></span><br><span class="line">	skb-&gt;pkt_type = IEEE80211_RX_MSG;</span><br><span class="line">	<span class="built_in">skb_queue_tail</span>(&amp;local-&gt;skb_queue, skb);</span><br><span class="line">	<span class="built_in">tasklet_schedule</span>(&amp;local-&gt;tasklet);<span class="comment">//这里会进入</span></span><br><span class="line">&#125;</span><br><span class="line">--&gt; 进入到这个处理的handler:</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="built_in">ieee80211_tasklet_handler</span>(<span class="type">unsigned</span> <span class="type">long</span> data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> ieee80211_local *local = (<span class="keyword">struct</span> ieee80211_local *) data;</span><br><span class="line">	<span class="keyword">struct</span> sk_buff *skb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((skb = <span class="built_in">skb_dequeue</span>(&amp;local-&gt;skb_queue)) ||</span><br><span class="line">	       (skb = <span class="built_in">skb_dequeue</span>(&amp;local-&gt;skb_queue_unreliable))) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (skb-&gt;pkt_type) &#123;</span><br><span class="line">		<span class="keyword">case</span> IEEE80211_RX_MSG:</span><br><span class="line">			<span class="comment">/* Clear skb-&gt;pkt_type in order to not confuse kernel</span></span><br><span class="line"><span class="comment">			 * netstack. */</span></span><br><span class="line">			skb-&gt;pkt_type = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">ieee80211_rx</span>(&amp;local-&gt;hw, skb);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> IEEE80211_TX_STATUS_MSG:</span><br><span class="line">			skb-&gt;pkt_type = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">ieee80211_tx_status</span>(&amp;local-&gt;hw, skb);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">WARN</span>(<span class="number">1</span>, <span class="string">&quot;mac80211: Packet is of unknown type %d\n&quot;</span>,</span><br><span class="line">			     skb-&gt;pkt_type);</span><br><span class="line">			<span class="built_in">dev_kfree_skb</span>(skb);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">调用流程：</span><br><span class="line">ieee80211_tasklet_handler</span><br><span class="line">    ieee80211_rx</span><br><span class="line">调用流程： </span><br><span class="line">ieee80211_rx</span><br><span class="line">ieee80211_rx_napi</span><br><span class="line">__ieee80211_rx_handle_packet</span><br><span class="line">ieee80211_prepare_and_rx_handle</span><br><span class="line">ieee80211_invoke_rx_handlers</span><br><span class="line">ieee80211_rx_handlers</span><br><span class="line">ieee80211_rx_handlers_result</span><br><span class="line">ieee80211_rx_cooked_monitor--&gt;<span class="built_in">netif_receive_skb</span>(skb);</span><br></pre></td></tr></table></figure>

<h5 id="rtl8180-pci接口的wifi网卡"><a href="#rtl8180-pci接口的wifi网卡" class="headerlink" title="rtl8180,pci接口的wifi网卡"></a>rtl8180,pci接口的wifi网卡</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8180</span>有中断处理：也一样；</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title">rtl8180_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"><span class="title">ieee80211_rx_irqsafe</span><span class="params">(dev, skb)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ref:<br>参考资料：<br><a href="http://landley.net/kdocs/Documentation/DocBook/xhtml-nochunks/80211.html">http://landley.net/kdocs/Documentation/DocBook/xhtml-nochunks/80211.html</a><br><a href="https://zhuanlan.zhihu.com/p/68425080">https://zhuanlan.zhihu.com/p/68425080</a><br><a href="https://www.zhihu.com/question/31878199">https://www.zhihu.com/question/31878199</a><br><a href="https://zhuanlan.zhihu.com/p/100616192">https://zhuanlan.zhihu.com/p/100616192</a></p>
<h4 id="虚拟网卡-tun例子"><a href="#虚拟网卡-tun例子" class="headerlink" title="虚拟网卡 tun例子"></a>虚拟网卡 tun例子</h4><p>ref:<br><a href="https://segmentfault.com/a/1190000009249039">https://segmentfault.com/a/1190000009249039</a><br>实现：<a href="http://vtun.sourceforge.net/">http://vtun.sourceforge.net/</a><br>ifb也是一个虚拟网卡<br>和tun一样，ifb也是在数据包来自的地方和去往的地方做文章。对于tun而言，数据包在xmit中发往字符设备，而从字符设备写下来的数据包则在tun网卡上模拟一个rx操作，对于ifb而言，情况和这类似。<br>       ifb驱动太简单，以至于很短的话就可以将其说清，然后上一幅全景图，最后留下一点如何使用它的技巧，本文就完了。<br>       ifb驱动模拟一块虚拟网卡，它可以被看作是一个只有TC过滤功能的虚拟网卡，说它只有过滤功能，是因为它并不改变数据包的方向，即对于往外发的数据包被重定向到ifb之后，经过ifb的TC过滤之后，依然是通过重定向之前的网卡发出去，对于一个网卡接收的数据包，被重定向到ifb之后，经过ifb的TC过滤之后，依然被重定向之前的网卡继续进行接收处理，不管是从一块网卡发送数据包还是从一块网卡接收数据包，重定向到ifb之后，都要经过一个经由ifb虚拟网卡的dev_queue_xmit操作。</p>
<h3 id="如何调试linux收发内核问题；"><a href="#如何调试linux收发内核问题；" class="headerlink" title="如何调试linux收发内核问题；"></a>如何调试linux收发内核问题；</h3><p>连通性：<br>step:  </p>
<ol>
<li>检查外部网络是否ok,比如其他机器是否正常等，本机物理网卡是否ok: 物理接口的连接，led灯,网线是否连接正常，wifi是否已完成扫描连接；  </li>
<li>检查基本的配置，ip,mac地址，网关等配置，这些影响数据的基本输入  </li>
<li>通过ping，上网工具如浏览器等，来判断整体网络连通情况，至此网络连通性检查基本完成，若不行，检查路由表，dns解析情况，尝试用纯ip进行访问；  </li>
<li>如果3)的检查不行，则尝试抓包，这个时候数据不经过协议栈，可以排除协议栈的影响，而考虑驱动，物理网络的影响；可以从相关设备驱动层的配置和特性如gro等考虑；</li>
</ol>
<p>收：以igb为例：在通过基本常规上层手段排除不出来问题时，可以从以下方面入手：<br>step: 介绍数据从设备-&gt;用户的基本流程等，并提供排查的基本手段；  </p>
<ol>
<li>检查驱动程序是否已加载，初始化，start&#x2F;open: 通过检查ifconfig，ethtool dev的状态，最极端的就是查日志；<br>2）检查硬件中断，软件中断是否运行正常，硬件中断查看cat &#x2F;proc&#x2F;interputs 软中断： &#x2F;proc&#x2F;softirqs</li>
<li>查看ksoftirqd守护进程是否运行正常，每个cpu上都会运行一个，用来进行软中断poll数据；</li>
<li>检查网卡多队列是否支持，若不支持，尽量提供RPS，RFS特性的启动；避免cpu高载导致网络收包延迟或丢包；尽量让收包处理分散在多个cpu上；<br>查看各网络接口的收发包情况：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cat /proc/net/dev</span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">  eth0: <span class="number">110346752214</span> <span class="number">597737500</span>    <span class="number">0</span>    <span class="number">2</span>    <span class="number">0</span>     <span class="number">0</span>          <span class="number">0</span>  <span class="number">20963860</span> <span class="number">990024805984</span> <span class="number">6066582604</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">    lo: <span class="number">428349463836</span> <span class="number">1579868535</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>          <span class="number">0</span>         <span class="number">0</span> <span class="number">428349463836</span> <span class="number">1579868535</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">查看网卡设备驱动和多队列配置等：</span><br><span class="line">ethtool -l eth0</span><br><span class="line">ethtool eth0</span><br><span class="line">ethtool -i eth0</span><br><span class="line">以及调整 具体man ethtool</span><br><span class="line">ethtool是设备驱动程序向上提供的接口，一般会有个单独的文件来实现，如e1000就有e1000_ethtool.c</span><br><span class="line">查硬中断是否为多队列多中断号：</span><br><span class="line">cat /proc/interrupts</span><br><span class="line">            CPU0       CPU1       CPU2       CPU3</span><br><span class="line">   <span class="number">0</span>:         <span class="number">46</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-IO-APIC-edge      timer</span><br><span class="line">   <span class="number">1</span>:          <span class="number">3</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-IO-APIC-edge      i8042</span><br><span class="line">  <span class="number">30</span>: <span class="number">3361234770</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-IO-APIC-fasteoi   aacraid</span><br><span class="line">  <span class="number">64</span>:          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> DMAR_MSI-edge      dmar0</span><br><span class="line">  <span class="number">65</span>:          <span class="number">1</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-PCI-MSI-edge      eth0</span><br><span class="line">  <span class="number">66</span>:  <span class="number">863649703</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-PCI-MSI-edge      eth0-TxRx<span class="number">-0</span></span><br><span class="line">  <span class="number">67</span>:  <span class="number">986285573</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-PCI-MSI-edge      eth0-TxRx<span class="number">-1</span></span><br><span class="line">  <span class="number">68</span>:         <span class="number">45</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-PCI-MSI-edge      eth0-TxRx<span class="number">-2</span></span><br><span class="line">  <span class="number">69</span>:        <span class="number">394</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span> IR-PCI-MSI-edge      eth0-TxRx<span class="number">-3</span></span><br><span class="line">查软中断收包情况：</span><br><span class="line">cat /proc/softirqs</span><br><span class="line">                    CPU0       CPU1       CPU2       CPU3</span><br><span class="line">          HI:          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">       TIMER: <span class="number">2831512516</span> <span class="number">1337085411</span> <span class="number">1103326083</span> <span class="number">1423923272</span></span><br><span class="line">      NET_TX:   <span class="number">15774435</span>     <span class="number">779806</span>     <span class="number">733217</span>     <span class="number">749512</span></span><br><span class="line">      NET_RX: <span class="number">1671622615</span> <span class="number">1257853535</span> <span class="number">2088429526</span> <span class="number">2674732223</span></span><br><span class="line">       BLOCK: <span class="number">1800253852</span>    <span class="number">1466177</span>    <span class="number">1791366</span>     <span class="number">634534</span></span><br><span class="line">设置cpu亲和性：</span><br><span class="line">eg:  sudo bash -c <span class="string">&#x27;echo 1 &gt; /proc/irq/8/smp_affinity&#x27;</span></span><br><span class="line">设置包到net_rx_action时的budget值，会影响一次从设备中poll包的最大值</span><br><span class="line">sudo sysctl -w net.core.netdev_budget=<span class="number">600</span></span><br><span class="line">检查和调整GRO</span><br><span class="line">ethtool -k eth0 | grep generic-receive-offload</span><br><span class="line">generic-receive-offload: on</span><br><span class="line"></span><br><span class="line">开启和关闭RPS/RFS/..</span><br></pre></td></tr></table></figure>


<ol start="5">
<li>包到达每个cpu的情况：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> /proc/net/softnet_stat:</span><br><span class="line"><span class="number">6</span>dcad223 <span class="number">00000000</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>参数解释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Each line of /proc/net/softnet_stat corresponds to a <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> <span class="title">structure</span>, <span class="title">of</span> <span class="title">which</span> <span class="title">there</span> <span class="title">is</span> 1 <span class="title">per</span> <span class="title">CPU</span>.</span></span><br><span class="line"><span class="class"><span class="title">The</span> <span class="title">values</span> <span class="title">are</span> <span class="title">separated</span> <span class="title">by</span> <span class="title">a</span> <span class="title">single</span> <span class="title">space</span> <span class="title">and</span> <span class="title">are</span> <span class="title">displayed</span> <span class="title">in</span> <span class="title">hexadecimal</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">The</span> <span class="title">first</span> <span class="title">value</span>, <span class="title">sd</span>-&gt;</span>processed, is the number of network frames processed. This can be more than the total number of network frames received <span class="keyword">if</span> you are using ethernet bonding. There are cases where the ethernet bonding driver will trigger network data to be re-processed, which would increment the sd-&gt;processed count more than once <span class="keyword">for</span> the same packet.</span><br><span class="line">第一列，是sd-&gt;processed,即处理的网络帧数；</span><br><span class="line"> __netif_receive_skb_core</span><br><span class="line">    __this_cpu_inc(softnet_data.processed);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The second value, sd-&gt;dropped, is the number of network frames dropped because there was no room on the processing <span class="built_in">queue</span>. More on this later.</span><br><span class="line"> enqueue_to_backlog(</span><br><span class="line">	  sd-&gt;dropped++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The third value, sd-&gt;time_squeeze, is (as we saw) the number of times the net_rx_action loop terminated because the budget was consumed or the time limit was reached, but more work could have been. Increasing the budget as explained earlier can help reduce this.</span><br><span class="line">The next <span class="number">5</span> values are always <span class="number">0.</span></span><br><span class="line">即在netif_rx_action过程中，异常中断的次数：</span><br><span class="line">		<span class="comment">/* If softirq window is exhausted then punt.</span></span><br><span class="line"><span class="comment">		 * Allow this to run for 2 jiffies since which will allow</span></span><br><span class="line"><span class="comment">		 * an average latency of 1.5/HZ.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(budget &lt;= <span class="number">0</span> ||</span><br><span class="line">			     time_after_eq(jiffies, time_limit))) &#123;</span><br><span class="line">			sd-&gt;time_squeeze++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The ninth value, sd-&gt;cpu_collision, is a count of the number of times a collision occurred when trying to obtain a device lock when transmitting packets. This article is about receive, so this statistic will not be seen below.</span><br><span class="line">发送的时候，cpu异常？ 这个目前都设置为<span class="number">0</span> 了，在最新的版本；</span><br><span class="line"></span><br><span class="line">The tenth value, sd-&gt;received_rps, is a count of the number of times this CPU has been woken up to process packets via an Inter-processor Interrupt</span><br><span class="line">通过rps方式，即软中断打散的次数：</span><br><span class="line"><span class="comment">/* Called from hardirq (IPI) context */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> rps_trigger_softirq(<span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> softnet_data *sd = data;</span><br><span class="line"></span><br><span class="line">	____napi_schedule(sd, &amp;sd-&gt;backlog);</span><br><span class="line">	sd-&gt;received_rps++;</span><br><span class="line">&#125;</span><br><span class="line">The last value, flow_limit_count, is a count of the number of times the flow limit has been reached. Flow limiting is an optional Receive Packet Steering feature that will be examined shortly.超过flow最大限制的次数</span><br></pre></td></tr></table></figure>



<ol start="6">
<li>数据包到达协议栈，会通过路由子系统，netfilter框架(防火墙)，或者用户自己开发的防火墙模块，包可能在这里被丢掉，需要检查；<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">$ cat /<span class="keyword">proc</span>/net/snmp<span class="title"></span></span><br><span class="line"><span class="title">Ip:</span> Forwarding<span class="title"> DefaultTTL</span> InReceives<span class="title"> InHdrErrors</span> InAddrErrors<span class="title"> ForwDatagrams</span> InUnknownProtos<span class="title"> InDiscards</span> InDelivers<span class="title"> OutRequests</span> OutDiscards<span class="title"> OutNoRoutes</span> ReasmTimeout<span class="title"> ReasmReqds</span> ReasmOKs<span class="title"> ReasmFails</span> FragOKs<span class="title"> FragFails</span> FragCreates<span class="title"></span></span><br><span class="line"><span class="title">Ip:</span> 1 64 25922988125 0 0 15771700 0 0 25898327616 22789396404 12987882 51 1 10129840 2196520 1 0 0 0</span><br><span class="line">统计了几个协议层的数据情况</span><br></pre></td></tr></table></figure></li>
<li>包顺利进入到ip层；<br>ref:<br><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/">https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/</a><br>收-图：<br><a href="https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/">https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/</a><br>发<br><a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/">https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/</a></li>
</ol>
<h3 id="关于TSO-GSO-GRO等"><a href="#关于TSO-GSO-GRO等" class="headerlink" title="关于TSO ,GSO ,GRO等"></a>关于TSO ,GSO ,GRO等</h3><p>需要网卡支持<br>TSO(TCP Segmentation Offload)，是利用网卡对TCP数据包分片，减轻CPU负荷的一种技术，也有人叫 LSO (Large segment offload) ，TSO是针对TCP的，UFO是针对UDP的。如果硬件支持 TSO功能，同时也需要硬件支持的TCP校验计算和分散&#x2F;聚集 (Scatter Gather) 功能。如果网卡支持TSO&#x2F;GSO，可以把最多64K大小的TCP payload直接往下传给协议栈，此时IP层也不会进行segmentation，网卡会生成TCP&#x2F;IP包头和帧头，这样可以offload很多协议栈上的内存操作，节省CPU资源，当然如果都是小包，那么功能基本就没啥用了。</p>
<p>GSO(Generic Segmentation Offload)，GSO是TSO的增强 ，GSO不只针对TCP，对任意协议。比TSO更通用，推迟数据分片直至发送到网卡驱动之前，此时会检查网卡是否支持分片功能（如TSO、UFO）,如果支持直接发送到网卡，如果不支持就进行分片后再发往网卡。</p>
<p>LRO(Large Receive Offload)，通过将接收到的多个TCP数据聚合成一个大的数据包，然后传递给网络协议栈处理，以减少上层协议栈处理 开销，提高系统接收TCP数据包的能力。</p>
<p>GRO(Generic Receive Offload)，跟LRO类似，克服了LRO的一些缺点，更通用。后续的驱动都使用GRO的接口，而不是LRO。<br>在系统中可以通过ethtool命令来进行查看，如下：</p>
<p>＃ethtool -k eth0</p>
<p>generic-segmentation-offload: on</p>
<p>generic-receive-offload: on</p>
<p>TSO、UFO、GSO是对应网络发送， LRO、GRO是在接收方向上</p>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_device</tag>
      </tags>
  </entry>
  <entry>
    <title>systemcall</title>
    <url>/2021/04/18/systemcall/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="系统调用概述"><a href="#系统调用概述" class="headerlink" title="系统调用概述"></a>系统调用概述</h3><p>内核对于用户进程来讲，是一个具备多功能的黑盒子，不仅管理设备，管理内存，管理进程等，还封装了提供进程调用的各种接口，比如打开文件，写入和读取文件等等，这些接口<span id="more"></span><br>不能在用户态运行，而需要由内核统一管理，在内核态运行；所以为了能让用户进程方便的调用，顺利的进入内核态处理，并适当的恢复用户进程运行和返回结果等等，系统调用因此而生；</p>
<p>系统调用的实现，主要是由内核提供各种内核函数，形成内核函数库，分散在各个功能目录；<br>而用户进程，一般是通过类似glibc等标准库来调用系统调用内核函数的，当然也可以不同过标准库而使用一些特殊的宏来调用，如_syscall;</p>
<p>因为用户态和内核态的不同，堆栈不同，虚拟地址空间等不同，控制权需要在用户进程和内核之间来回传递，而参数和返回值也需要，造成了一定的复杂度；<br>这里需要区分标准库和系统调用的区别，调用标准库函数不一定会触发调用系统调用，当调用标准库函数需要系统调用时，由标准库去进一步调用系统调用；</p>
<h3 id="linux系统调用的两种使用方式：c库函数和直接系统调用"><a href="#linux系统调用的两种使用方式：c库函数和直接系统调用" class="headerlink" title="linux系统调用的两种使用方式：c库函数和直接系统调用"></a>linux系统调用的两种使用方式：c库函数和直接系统调用</h3><h4 id="c库函数使用例子和追踪："><a href="#c库函数使用例子和追踪：" class="headerlink" title="c库函数使用例子和追踪："></a>c库函数使用例子和追踪：</h4><p>一个调用c库函数的典型例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的函数可以看到调用了标准c库的printf函数；<br>编译后进行系统调用跟踪：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strace  ./<span class="function">main</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">execve</span><span class="params">(<span class="string">&quot;./main&quot;</span>, [<span class="string">&quot;./main&quot;</span>], [<span class="comment">/* 70 vars */</span>])</span> </span>= <span class="number">0</span></span><br><span class="line"><span class="built_in">brk</span>(<span class="number">0</span>)                                  = <span class="number">0x2425000</span></span><br><span class="line"><span class="built_in">access</span>(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK)      = <span class="number">-1</span> <span class="built_in">ENOENT</span> (No such file <span class="keyword">or</span> directory)</span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7ff4be6f0000</span></span><br><span class="line"><span class="built_in">access</span>(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK)      = <span class="number">-1</span> <span class="built_in">ENOENT</span> (No such file <span class="keyword">or</span> directory)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line"><span class="built_in">fstat</span>(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">86757</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">86757</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x7ff4be6da000</span></span><br><span class="line"><span class="built_in">close</span>(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line"><span class="built_in">access</span>(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK)      = <span class="number">-1</span> <span class="built_in">ENOENT</span> (No such file <span class="keyword">or</span> directory)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">&quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P \2\0\0\0\0\0&quot;</span>..., <span class="number">832</span>) = <span class="number">832</span></span><br><span class="line"><span class="built_in">fstat</span>(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">1840928</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">3949248</span>, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x7ff4be10b000</span></span><br><span class="line"><span class="built_in">mprotect</span>(<span class="number">0x7ff4be2c5000</span>, <span class="number">2097152</span>, PROT_NONE) = <span class="number">0</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="number">0x7ff4be4c5000</span>, <span class="number">24576</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0x1ba000</span>) = <span class="number">0x7ff4be4c5000</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="number">0x7ff4be4cb000</span>, <span class="number">17088</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7ff4be4cb000</span></span><br><span class="line"><span class="built_in">close</span>(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7ff4be6d9000</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7ff4be6d7000</span></span><br><span class="line"><span class="built_in">arch_prctl</span>(ARCH_SET_FS, <span class="number">0x7ff4be6d7740</span>) = <span class="number">0</span></span><br><span class="line"><span class="built_in">mprotect</span>(<span class="number">0x7ff4be4c5000</span>, <span class="number">16384</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line"><span class="built_in">mprotect</span>(<span class="number">0x600000</span>, <span class="number">4096</span>, PROT_READ)     = <span class="number">0</span></span><br><span class="line"><span class="built_in">mprotect</span>(<span class="number">0x7ff4be6f2000</span>, <span class="number">4096</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line"><span class="built_in">munmap</span>(<span class="number">0x7ff4be6da000</span>, <span class="number">86757</span>)           = <span class="number">0</span></span><br><span class="line"><span class="built_in">fstat</span>(<span class="number">1</span>, &#123;st_mode=S_IFCHR|<span class="number">0620</span>, st_rdev=<span class="built_in">makedev</span>(<span class="number">136</span>, <span class="number">5</span>), ...&#125;) = <span class="number">0</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7ff4be6ef000</span></span><br><span class="line"><span class="built_in">write</span>(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>hello)                    = <span class="number">5</span></span><br><span class="line"><span class="built_in">exit_group</span>(<span class="number">0</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，除开前面的标准库调用的基本框架，最后是调用了系统调用write函数，来进行打印操作；<br>标准库执行的大体框架，需要加载so文件，并做内存映射，为可执行，然后调用系统调用；<br>而系统调用，就通过一种机制调用到内核函数了</p>

<h4 id="直接使用使用例子和追踪："><a href="#直接使用使用例子和追踪：" class="headerlink" title="直接使用使用例子和追踪："></a>直接使用使用例子和追踪：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#define_NR_testsyscall <span class="number">191</span></span><br><span class="line"></span><br><span class="line">_syscall0(<span class="type">int</span>,testsyscall)</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">testsyscall</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统调用的各种标准介绍："><a href="#系统调用的各种标准介绍：" class="headerlink" title="系统调用的各种标准介绍："></a>系统调用的各种标准介绍：</h3><p>posix标准<br>system V<br>BSD</p>
<h3 id="系统调用的分类和分布位置目录："><a href="#系统调用的分类和分布位置目录：" class="headerlink" title="系统调用的分类和分布位置目录："></a>系统调用的分类和分布位置目录：</h3><p>可以从内核源码中看到所有的系统调用函数接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">linux <span class="number">2.</span>x:</span><br><span class="line">arch/i386/kernel/entry.s中</span><br><span class="line">.data</span><br><span class="line"><span class="number">575</span> <span class="built_in">ENTRY</span>(sys_call_table)</span><br><span class="line"><span class="number">576</span>         .<span class="type">long</span> sys_restart_syscall       <span class="comment">/* 0 - old &quot;setup()&quot; system call, used for restarting */</span></span><br><span class="line"><span class="number">577</span>         .<span class="type">long</span> sys_exit</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>x之后：</span><br><span class="line">arch/x86/entry/syscalls/syscall_64.tbl</span><br><span class="line"># <span class="number">64</span>-bit system call numbers <span class="keyword">and</span> entry vectors</span><br><span class="line">#</span><br><span class="line"># The format is:</span><br><span class="line"># &lt;number&gt; &lt;abi&gt; &lt;name&gt; &lt;entry point&gt;</span><br><span class="line">#</span><br><span class="line"># The __x64_sys_*() stubs are created on-the-fly <span class="keyword">for</span> sys_*() system calls</span><br><span class="line">#</span><br><span class="line"># The abi is <span class="string">&quot;common&quot;</span>, <span class="string">&quot;64&quot;</span> <span class="keyword">or</span> <span class="string">&quot;x32&quot;</span> <span class="keyword">for</span> <span class="keyword">this</span> file.</span><br><span class="line">#</span><br><span class="line"><span class="number">0</span>	common	read			sys_read</span><br><span class="line"><span class="number">1</span>	common	write			sys_write</span><br><span class="line"><span class="number">2</span>	common	open			sys_open</span><br><span class="line"><span class="number">3</span>	common	close			sys_close</span><br><span class="line"><span class="number">4</span>	common	stat			sys_newstat</span><br><span class="line"><span class="number">5</span>	common	fstat			sys_newfstat</span><br><span class="line"><span class="number">6</span>	common	lstat			sys_newlstat</span><br><span class="line"><span class="number">7</span>	common	poll			sys_poll</span><br><span class="line"><span class="number">8</span>	common	lseek			sys_lseek</span><br><span class="line"><span class="number">9</span>	common	mmap			sys_mmap</span><br><span class="line"><span class="number">10</span>	common	mprotect		sys_mprotect</span><br><span class="line"><span class="number">11</span>	common	munmap			sys_munmap</span><br><span class="line"><span class="number">12</span>	common	brk			sys_brk</span><br><span class="line"><span class="number">13</span>	<span class="number">64</span>	rt_sigaction		sys_rt_sigaction</span><br><span class="line"><span class="number">14</span>	common	rt_sigprocmask		sys_rt_sigprocmask</span><br><span class="line"><span class="number">15</span>	<span class="number">64</span>	rt_sigreturn		sys_rt_sigreturn</span><br><span class="line"><span class="number">16</span>	<span class="number">64</span>	ioctl			sys_ioctl</span><br><span class="line"><span class="number">17</span>	common	pread64			sys_pread64</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><ul>
<li>创建进程：fork,vfork,clone</li>
<li>结束进程：exit</li>
<li>查询： getuid等</li>
<li>程序执行环境：personality </li>
<li>跟踪系统调用：ptrace</li>
<li>优先级设置：nice</li>
<li>设置一定的资源限制：setrlimit, getrlimit,getrusage<h4 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h4></li>
<li>读取和设置基于时间的内核变量：adjtimex</li>
<li>定时器： alarm,setitimer,getitimer</li>
<li>获取和设置系统当前时间：gettimeofday ,settimeofday</li>
<li>睡眠： sleep,nanosleep </li>
<li>返回时间戳： timer</li>
</ul>
<h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h4><ul>
<li><p>设置信号处理函数：signal,sigaction</p>
</li>
<li><p>检查进程当前是否有待决信号被阻塞：sigpending</p>
</li>
<li><p>将进程置于等待队列上，直至某个特定（一组信号中的一个）的信号到达 :sigsuspend</p>
</li>
<li><p>启用信号的阻塞机制，而getmask返回所有当前阻塞信号的列表:setmask</p>
</li>
<li><p>用于向一个进程发送任何信号:kill</p>
</li>
<li><p>还有一组处理实时信号的系统调用，但其对应的函数名带有前缀rt_。例如， rt_sigaction</p>
</li>
<li><p>设置一个实时信号处理程序，而rt_sigsuspend将进程置于等待状态，直至某个特定（一组</p>
</li>
<li><p>信号中的一个）信号到达</p>
<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4></li>
<li><p>setpriority和getpriority分别设置和获取进程的优先级，因而是用于调度目的的关键系统调用。</p>
</li>
<li><p>请注意， Linux不仅支持不同的进程优先级，还提供了多种调度类，以适应应用程序在时间方<br>面具体的行为和需求。 sched_setscheduler和sched_getscheduler分别设置和查询调度类。<br> sched_setparam和sched_getparam分别设置和查询进程的附加调度参数（当前，只使用了<br> 实时优先级的参数）。</p>
</li>
<li><p>sched_yield自愿释放CPU的控制权，即使进程当前仍然有CPU时间可用。</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4></li>
<li><p>init_module添加一个新模块。</p>
</li>
<li><p>delete_module从内核移除一个模块</p>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p> 一些系统调用被用作用户空间中同名实用程序的直接基础，用来创建和修改目录结构： chdir、<br>mkdir、 rmdir、 rename、 symlink、 getcwd、 chroot、 umask和mknod。</p>
</li>
<li><p>文件和目录属性可以用chown和chmod修改。</p>
</li>
<li><p>下列实用程序用于处理文件内容，其实现在标准库中，与对应的系统调用同名： open、 close、<br>read与readv、 write与writev、 truncate和llseek。</p>
</li>
<li><p>readdir和getdents读取目录结构。</p>
</li>
<li><p>link、 symlink和unlink创建和删除链接（或文件，如果该文件是某个硬链接的最后一个成<br>员）。 readlink读取链接的内容。</p>
</li>
<li><p>mount和umount用于文件系统的装载和卸载。</p>
</li>
<li><p>poll和select用于等待某些事件。</p>
</li>
<li><p>execve装载一个新进程，替换旧的进程。在与fork联合使用时，它会启动一个新的程序。</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4></li>
<li><p>就动态内存管理而言，最重要的调用是brk，它修改进程数据段的长度。调用了malloc或相似<br>函数的程序（几乎所有非平凡的代码，都符合这个条件）会频繁使用该系统调用。</p>
</li>
<li><p>mmap、 mmap2、 munmap和mremap执行内存映射、解除映射和重新映射操作，而mprotect控制<br>对虚拟内存中特定区域的访问， madvice提出对特定虚拟内存区域的使用建议。<br>mmap和mmap2的参数稍有不同，更多细节请参考手册页。默认情况下， GNU C库使用mmap2；<br>现在mmap只是一个用户层包装器函数。<br>根据malloc的实现，它在内部可以使用mmap或mmap2。这是可行的，因为匿名映射允许建立<br>没有文件作为后备存储的映射。与使用brk相比，该方法更加灵活。</p>
</li>
<li><p>swapon和swapoff分别启用和禁用外存储器设备上（附加）的交换区</p>
<h4 id="进程间通信和网络功能"><a href="#进程间通信和网络功能" class="headerlink" title="进程间通信和网络功能"></a>进程间通信和网络功能</h4></li>
<li><p>socketcall处理网络方面的问题，用于实现套接字抽象。它管理各种类型的连接和协议，总<br>共实现了17种功能， 通过SYS_ACCEPT、 SYS_SENDTO等常数来区分。参数必须以指针形式传递，<br>指向一个与函数类型相关的用户空间结构，其中保存了所需的数据。</p>
</li>
<li><p>ipc与socketcall相对应，用于处理计算机本地的连接，而不是通过网络建立的连接。因为<br>该系统调用“只”需要实现11种功能，它使用了固定数目的参数来从用户空间向内核空间传<br>递数据，总共是5个。</p>
<h4 id="系统信息和设置"><a href="#系统信息和设置" class="headerlink" title="系统信息和设置"></a>系统信息和设置</h4></li>
<li><p>syslog向系统日志写入消息，并允许设置不同的优先级（根据消息的优先级不同，用户空<br>间工具或者向持久性的日志文件发送消息，或者直接向控制台输出消息以通知用户某些关键<br>情况。</p>
</li>
<li><p>sysinfo返回有关系统状态的信息，特别有关内存使用的统计量（物理内存、缓冲区、交换区）。</p>
</li>
<li><p>sysctl用于“微调”内核参数。内核现在支持大量的动态可配置选项，可以使用proc文件系<br>统读取和修改</p>
</li>
</ul>
<h4 id="系统安全和能力"><a href="#系统安全和能力" class="headerlink" title="系统安全和能力"></a>系统安全和能力</h4><p>LSM（ Linux security modules， Linux安全模块）子系统提供了一个通用接口，支持内核在<br>各个位置通过挂钩调用模块函数来执行安全检查。</p>
<ul>
<li>capset和capget负责设置和查询进程的能力。</li>
<li>security是一个系统调用的多路分解器，用于实现LSM</li>
</ul>
<h3 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h3><h4 id="理论上"><a href="#理论上" class="headerlink" title="理论上"></a>理论上</h4><h5 id="系统调用的结构："><a href="#系统调用的结构：" class="headerlink" title="系统调用的结构："></a>系统调用的结构：</h5><ul>
<li>处理函数的实现：内核中实现：sys_<br>1） 每个函数的名称前缀都是sys_，将该函数唯一地标识为一个系统调用<br>2） 所有的处理程序函数都最多接受5个参数<br>3） 所有的系统调用都在核心态执行<br>在内核将控制权转移给处理程序例程后，控制流就进入了平台中立的代码，即不依赖于特定的CPU或体系结构。有少量处理程序函数是针对各个平台分别实现的</li>
<li>调用分派和参数传递：系统调用表<br>1）调用分派：<br>系统调用由内核分配的一个编号唯一标识，所有的系统调用都由一处中枢代码处理，根据调用编号和一个静态表，将调用<br>分派到具体的函数。传递的参数也由中枢代码处理，这样参数的传递独立于实际的系统调用。</li>
</ul>
<p>为容许用户态和核心态之间的切换，用户进程必须通过一条专用的机器指令，引起处理器&#x2F;内核<br>对该进程的关注，这需要C标准库的协助。<br>2）参数传递：<br>在所有平台上，系统调用参数都是通过寄存器直接传递的，对具体的处理程序函数而言，参数与寄存器之间的映射是精确定义的。还需要一<br>个寄存器来定义系统调用编号，将系统调用分派给匹配的处理程序函数。比如 x86:系统调用编号通过寄存器eax传递，<br>而参数通过寄存器ebx、 ecx、 edx、 esi和edi传递。<br>3）系统调用表：eg：sys_call_table<br>如果一个用户空间程序调用open系统调<br>用，传递的系统调用编号是5。 分配器例程将编号5加到sys_call_table的基地址，得到该数组的第6<br>项，其中保存了sys_open的地址，这是独立于处理器的处理程序函数。在将保存在寄存器中的参数值<br>复制到栈上之后，内核调用处理程序例程，并切换到系统调用处理中独立于处理器的部分<br>用户态和内核态是使用两个不同的栈</p>
<ul>
<li>返回用户态<br>返回值的语义<br>通常，系统调用的返回值有如下约定：负值表示错误，而正值（和0）表示成功结束<br>在include&#x2F;asm-generic&#x2F;errno-base.h和include&#x2F;asm-generic&#x2F;errno.h中定义的符号常数<h5 id="如何访问用户空间"><a href="#如何访问用户空间" class="headerlink" title="如何访问用户空间"></a>如何访问用户空间</h5>有些情况下，内核代码必须访问用户应用程序的虚拟内存。<br>内核忙于同步执行应用程序指派的任务。因为如下两种原因，内核必须访问应用程序的地址空间。<br> 如果一个系统调用需要超过6个不同的参数，它们只能借助进程内存空间中的C结构实例来传<br>递。系统调用将借助寄存器，将指向该结构实例的一个指针传递给内核。。。</li>
</ul>
<h4 id="实际实现：linux系统调用实现流程-基于linux3-x后"><a href="#实际实现：linux系统调用实现流程-基于linux3-x后" class="headerlink" title="实际实现：linux系统调用实现流程 基于linux3.x后"></a>实际实现：linux系统调用实现流程 基于linux3.x后</h4><h5 id="glibc标准库："><a href="#glibc标准库：" class="headerlink" title="glibc标准库："></a>glibc标准库：</h5><p>查询标准库：<br>think@think-VirtualBox:~&#x2F;source_linux&#x2F;linux-lts-xenial-4.4.0&#x2F;arch$ uname -a<br>Linux think-VirtualBox 4.4.177 #1 SMP Fri Sep 18 21:23:25 CST 2020 x86_64 x86_64 x86_64 GNU&#x2F;Linux<br>这样就是arch要选择x86相关的代码；<br>基于write系统调用，来跟踪：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glibc/sysdeps/unix/sysv/linux/write.c</span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="comment">/* Write NBYTES of BUF to FD.  Return the number written, or -1.  */</span></span><br><span class="line"><span class="type">ssize_t</span></span><br><span class="line">__libc_write (<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SYSCALL_CANCEL</span> (write, fd, buf, nbytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> </span><br><span class="line">跟着这个宏，最后是：这些宏定义在：sysdep.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_CANCEL(...) \</span></span><br><span class="line"><span class="meta">  (&#123;									     \</span></span><br><span class="line"><span class="meta">    long int sc_ret;							     \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (SINGLE_THREAD_P) 						     \</span></span><br><span class="line"><span class="meta">      sc_ret = INLINE_SYSCALL_CALL (__VA_ARGS__); 			     \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>								     \</span></span><br><span class="line"><span class="meta">      &#123;									     \</span></span><br><span class="line"><span class="meta">	int sc_cancel_oldtype = LIBC_CANCEL_ASYNC ();			     \</span></span><br><span class="line"><span class="meta">	sc_ret = INLINE_SYSCALL_CALL (__VA_ARGS__);			     \</span></span><br><span class="line"><span class="meta">        LIBC_CANCEL_RESET (sc_cancel_oldtype);				     \</span></span><br><span class="line"><span class="meta">      &#125;									     \</span></span><br><span class="line"><span class="meta">    sc_ret;								     \</span></span><br><span class="line"><span class="meta">  &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INLINE_SYSCALL_CALL(...) \</span></span><br><span class="line"><span class="meta">  __INLINE_SYSCALL_DISP (__INLINE_SYSCALL, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL_NARGS(...) \</span></span><br><span class="line"><span class="meta">  __INLINE_SYSCALL_NARGS_X (__VA_ARGS__,7,6,5,4,3,2,1,0,)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL_DISP(b,...) \</span></span><br><span class="line"><span class="meta">  __SYSCALL_CONCAT (b,__INLINE_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_CONCAT_X(a,b)     a##b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_CONCAT(a,b)       __SYSCALL_CONCAT_X (a, b)</span></span><br><span class="line">展开为：</span><br><span class="line">__INLINE_SYSCALL_N(xxxx);<span class="comment">//这里N是参数个数：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL0(name) \</span></span><br><span class="line"><span class="meta">  INLINE_SYSCALL (name, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL1(name, a1) \</span></span><br><span class="line"><span class="meta">  INLINE_SYSCALL (name, 1, a1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL2(name, a1, a2) \</span></span><br><span class="line"><span class="meta">  INLINE_SYSCALL (name, 2, a1, a2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL3(name, a1, a2, a3) \</span></span><br><span class="line"><span class="meta">  INLINE_SYSCALL (name, 3, a1, a2, a3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL4(name, a1, a2, a3, a4) \</span></span><br><span class="line"><span class="meta">  INLINE_SYSCALL (name, 4, a1, a2, a3, a4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL5(name, a1, a2, a3, a4, a5) \</span></span><br><span class="line"><span class="meta">  INLINE_SYSCALL (name, 5, a1, a2, a3, a4, a5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL6(name, a1, a2, a3, a4, a5, a6) \</span></span><br><span class="line"><span class="meta">  INLINE_SYSCALL (name, 6, a1, a2, a3, a4, a5, a6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL7(name, a1, a2, a3, a4, a5, a6, a7) \</span></span><br><span class="line"><span class="meta">  INLINE_SYSCALL (name, 7, a1, a2, a3, a4, a5, a6, a7)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line">进入平台相关函数：</span><br><span class="line">选x86_64: sysdeps/unix/sysv/linux/x86_64</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INLINE_SYSCALL(name, nr, args...) \</span></span><br><span class="line"><span class="meta">  (&#123;									      \</span></span><br><span class="line"><span class="meta">    unsigned long int resultvar = INTERNAL_SYSCALL (name, , nr, args);	      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (resultvar, )))	      \</span></span><br><span class="line"><span class="meta">      &#123;									      \</span></span><br><span class="line"><span class="meta">	__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		      \</span></span><br><span class="line"><span class="meta">	resultvar = (unsigned long int) -1;				      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">    (long int) resultvar; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_SYSCALL(name, err, nr, args...)			\</span></span><br><span class="line"><span class="meta">	internal_syscall##nr (SYS_ify (name), err, args)</span></span><br><span class="line">也是扩展为参数个数后：</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> internal_syscall0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> internal_syscall0(number, err, dummy...)			\</span></span><br><span class="line"><span class="meta">(&#123;									\</span></span><br><span class="line"><span class="meta">    unsigned long int resultvar;					\</span></span><br><span class="line"><span class="meta">    asm volatile (							\</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;syscall\n\t&quot;</span>							\</span></span><br><span class="line"><span class="meta">    : <span class="string">&quot;=a&quot;</span> (resultvar)							\</span></span><br><span class="line"><span class="meta">    : <span class="string">&quot;0&quot;</span> (number)							\</span></span><br><span class="line"><span class="meta">    : <span class="string">&quot;memory&quot;</span>, REGISTERS_CLOBBERED_BY_SYSCALL);			\</span></span><br><span class="line"><span class="meta">    (long int) resultvar;						\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> </span><br><span class="line">调用了syscall函数</span><br><span class="line">在syscall.S中： sysdeps/unix/sys/linux/x86_64</span><br><span class="line">	.<span class="function">text</span></span><br><span class="line"><span class="function"><span class="title">ENTRY</span> <span class="params">(syscall)</span></span></span><br><span class="line"><span class="function">	movq %rdi, %rax		<span class="comment">/* Syscall number -&gt; rax.  */</span></span></span><br><span class="line"><span class="function">	movq %rsi, %rdi		<span class="comment">/* shift arg1 - arg5.  */</span></span></span><br><span class="line"><span class="function">	movq %rdx, %rsi</span></span><br><span class="line"><span class="function">	movq %rcx, %rdx</span></span><br><span class="line"><span class="function">	movq %r8, %r10</span></span><br><span class="line"><span class="function">	movq %r9, %r8</span></span><br><span class="line"><span class="function">	movq 8<span class="params">(%rsp)</span>,%r9	<span class="comment">/* arg6 is on the stack.  */</span></span></span><br><span class="line"><span class="function">	syscall			<span class="comment">/* Do the system call.  */</span></span></span><br><span class="line"><span class="function">	cmpq $-4095, %rax	<span class="comment">/* Check %rax for error.  */</span></span></span><br><span class="line"><span class="function">	jae SYSCALL_ERROR_LABEL	<span class="comment">/* Jump to error handler if error.  */</span></span></span><br><span class="line"><span class="function">	ret			<span class="comment">/* Return to caller.  */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">PSEUDO_END</span> <span class="params">(syscall)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>


<h5 id="内核代码中的系统调用平台相关入口函数："><a href="#内核代码中的系统调用平台相关入口函数：" class="headerlink" title="内核代码中的系统调用平台相关入口函数："></a>内核代码中的系统调用平台相关入口函数：</h5><p>总之，上面的syscall指令跳转到存储在MSR_LSTAR模型特定寄存器(长系统目标地址寄存器)中的地址。内核负责提供自己的自定义函数来处理系统调用，并在系统启动时将这个处理函数的地址写入MSR_LSTAR寄存器。自定义函数是entry_SYSCALL_64，它在arch&#x2F;x86&#x2F;entry&#x2F;entry_64.S中定义。在arch&#x2F;x86&#x2F;kernel&#x2F;cpu&#x2F;common.c中，这个系统调用处理函数的地址在启动时被写入MSR_LSTAR寄存器。在这个文件可以看到：linux&#x2F;arch&#x2F;x86&#x2F;entry&#x2F;entry_64.S</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ENTRY</span>(entry_SYSCALL_64)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Interrupts are off on entry.</span></span><br><span class="line"><span class="comment">	 * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,</span></span><br><span class="line"><span class="comment">	 * it is too small to ever cause noticeable irq latency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SWAPGS_UNSAFE_STACK</span><br><span class="line">	SWITCH_KERNEL_CR3_NO_STACK</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A hypervisor implementation might want to use a label</span></span><br><span class="line"><span class="comment">	 * after the swapgs, so that it can do the swapgs</span></span><br><span class="line"><span class="comment">	 * for the guest and jump here on syscall.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="built_in">GLOBAL</span>(entry_SYSCALL_64_after_swapgs)</span><br><span class="line"></span><br><span class="line">	movq	%rsp, <span class="built_in">PER_CPU_VAR</span>(rsp_scratch)</span><br><span class="line">	<span class="function">movq	<span class="title">PER_CPU_VAR</span><span class="params">(cpu_current_top_of_stack)</span>, %rsp</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	<span class="comment">/* Construct struct pt_regs on stack */</span></span></span><br><span class="line"><span class="function">	pushq	$__USER_DS			<span class="comment">/* pt_regs-&gt;ss */</span></span></span><br><span class="line"><span class="function">	pushq	<span class="title">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>	<span class="comment">/* pt_regs-&gt;sp */</span></span></span><br><span class="line"><span class="function">	<span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">	 * Re-enable interrupts.</span></span></span><br><span class="line"><span class="comment"><span class="function">	 * We use &#x27;rsp_scratch&#x27; as a scratch space, hence irq-off block above</span></span></span><br><span class="line"><span class="comment"><span class="function">	 * must execute atomically in the face of possible interrupt-driven</span></span></span><br><span class="line"><span class="comment"><span class="function">	 * task preemption. We must enable interrupts only after we&#x27;re done</span></span></span><br><span class="line"><span class="comment"><span class="function">	 * with using rsp_scratch:</span></span></span><br><span class="line"><span class="comment"><span class="function">	 */</span></span></span><br><span class="line"><span class="function">	<span class="title">ENABLE_INTERRUPTS</span><span class="params">(CLBR_NONE)</span></span></span><br><span class="line"><span class="function">	pushq	%r11				<span class="comment">/* pt_regs-&gt;flags */</span></span></span><br><span class="line"><span class="function">	pushq	$__USER_CS			<span class="comment">/* pt_regs-&gt;cs */</span></span></span><br><span class="line"><span class="function">	pushq	%rcx				<span class="comment">/* pt_regs-&gt;ip */</span></span></span><br><span class="line"><span class="function">	pushq	%rax				<span class="comment">/* pt_regs-&gt;orig_ax */</span></span></span><br><span class="line"><span class="function">	pushq	%rdi				<span class="comment">/* pt_regs-&gt;di */</span></span></span><br><span class="line"><span class="function">	pushq	%rsi				<span class="comment">/* pt_regs-&gt;si */</span></span></span><br><span class="line"><span class="function">	pushq	%rdx				<span class="comment">/* pt_regs-&gt;dx */</span></span></span><br><span class="line"><span class="function">	pushq	%rcx				<span class="comment">/* pt_regs-&gt;cx */</span></span></span><br><span class="line"><span class="function">	pushq	$-ENOSYS			<span class="comment">/* pt_regs-&gt;ax */</span></span></span><br><span class="line"><span class="function">	pushq	%r8				<span class="comment">/* pt_regs-&gt;r8 */</span></span></span><br><span class="line"><span class="function">	pushq	%r9				<span class="comment">/* pt_regs-&gt;r9 */</span></span></span><br><span class="line"><span class="function">	pushq	%r10				<span class="comment">/* pt_regs-&gt;r10 */</span></span></span><br><span class="line"><span class="function">	pushq	%r11				<span class="comment">/* pt_regs-&gt;r11 */</span></span></span><br><span class="line"><span class="function">	sub	$<span class="params">(<span class="number">6</span>*<span class="number">8</span>)</span>, %rsp			<span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	ENABLE_IBRS</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	testl	$_TIF_WORK_SYSCALL_ENTRY, <span class="title">ASM_THREAD_INFO</span><span class="params">(TI_flags, %rsp, SIZEOF_PTREGS)</span></span></span><br><span class="line"><span class="function">	jnz	tracesys</span></span><br><span class="line"><span class="function">entry_SYSCALL_64_fastpath:</span></span><br><span class="line"><span class="function">#if __SYSCALL_MASK =</span>= ~<span class="number">0</span></span><br><span class="line">	cmpq	$NR_syscalls, %rax</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	andl	$__SYSCALL_MASK, %eax</span><br><span class="line">	cmpl	$NR_syscalls, %eax</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	jae	<span class="number">1f</span>				<span class="comment">/* return -ENOSYS (already in pt_regs-&gt;ax) */</span></span><br><span class="line">	sbb	%rcx, %rcx			<span class="comment">/* array_index_mask_nospec() */</span></span><br><span class="line">	<span class="keyword">and</span>	%rcx, %rax</span><br><span class="line">	movq	%r10, %rcx</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RETPOLINE</span></span><br><span class="line">	movq	<span class="built_in">sys_call_table</span>(, %rax, <span class="number">8</span>), %rax</span><br><span class="line">	call	__x86_indirect_thunk_rax</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	call	*<span class="built_in">sys_call_table</span>(, %rax, <span class="number">8</span>) <span class="comment">//这里选择到了系统调用表中的对应函数指针；</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	movq	%rax, <span class="built_in">RAX</span>(%rsp)</span><br></pre></td></tr></table></figure>
<p>调用了*sys_call_table(, %rax, 8)，传入了系统调用号；</p>
<h5 id="内核代码平台无关函数和数组初始化；"><a href="#内核代码平台无关函数和数组初始化；" class="headerlink" title="内核代码平台无关函数和数组初始化；"></a>内核代码平台无关函数和数组初始化；</h5><p>在linux3.x之后，系统调用由sys_call_table函数指针数组管理：<br>初始化如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">实际上是通过一个数组维护的，在：</span><br><span class="line">/arch/x86/entry/syscall_64.c sys_call_table array</span><br><span class="line">如何初始化这个表：</span><br><span class="line">asmlinkage <span class="type">const</span> <span class="type">sys_call_ptr_t</span> sys_call_table[__NR_syscall_max+<span class="number">1</span>] = &#123;</span><br><span class="line">    [<span class="number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall, 初始化的这个函数指针其实啥也没做：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/syscalls_64.h&gt;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">sys_call_ptr_t</span>)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="type">long</span> <span class="title">sys_ni_syscall</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -ENOSYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何赋值这个表：<br>We can do it with a GCC compiler extension called - Designated Initializers. This extension allows us to initialize elements in non-fixed order.<br>我们可以看到，在上面的初始化中，最后一行贴了#include&lt;asm&#x2F;syscalls_64.h&gt;<br>就可以看到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/arch/x86/include/generated/<span class="keyword">asm</span>$ vim syscalls_64.h</span><br><span class="line">__SYSCALL_COMMON(<span class="number">0</span>, sys_read, sys_read)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">1</span>, sys_write, sys_write)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">2</span>, sys_open, sys_open)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">3</span>, sys_close, sys_close)</span><br><span class="line">。。。</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_COMMON(nr, sym, compat) __SYSCALL_64(nr, sym, compat)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_64(nr, sym, compat) [nr] = sym,</span></span><br><span class="line">所以之后就初始化好了；</span><br><span class="line">asmlinkage <span class="type">const</span> <span class="type">sys_call_ptr_t</span> sys_call_table[__NR_syscall_max+<span class="number">1</span>] = &#123;</span><br><span class="line">    [<span class="number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall,</span><br><span class="line">    [<span class="number">0</span>] = sys_read,</span><br><span class="line">    [<span class="number">1</span>] = sys_write,</span><br><span class="line">    [<span class="number">2</span>] = sys_open,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而这个文件 asm&#x2F;syscalls_64.h:是在内核编译时根据syscalls目录中的脚本syscalltbl.sh和系统调用号定义文件syscall_64.tbl生成的。<br>syscallhdr.sh脚本用于生成unistd_64.h等文件</p>
<p>这里就可以看到，初始化和赋值了该系统调用数组，所以其实标准库就是最后找到了这个系统调用函数进行调用；</p>
<h5 id="syscall"><a href="#syscall" class="headerlink" title="_syscall"></a>_syscall</h5><p>&#x2F;arch&#x2F;parisc&#x2F;include&#x2F;asm&#x2F;unistd.h 不太确定<br>可以看到在这个文件下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall0(type,name)						\</span></span><br><span class="line"><span class="meta">type name(void)								\</span></span><br><span class="line"><span class="meta">&#123;									\</span></span><br><span class="line"><span class="meta">    return K_INLINE_SYSCALL(name, 0);	                                \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall1(type,name,type1,arg1)					\</span></span><br><span class="line"><span class="meta">type name(type1 arg1)							\</span></span><br><span class="line"><span class="meta">&#123;									\</span></span><br><span class="line"><span class="meta">    return K_INLINE_SYSCALL(name, 1, arg1);	                        \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> K_INLINE_SYSCALL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_INLINE_SYSCALL(name, nr, args...)	(&#123;			\</span></span><br><span class="line"><span class="meta">	long __sys_res;							\</span></span><br><span class="line"><span class="meta">	&#123;								\</span></span><br><span class="line"><span class="meta">		register unsigned long __res __asm__(<span class="string">&quot;r28&quot;</span>);		\</span></span><br><span class="line"><span class="meta">		K_LOAD_ARGS_##nr(args)					\</span></span><br><span class="line"><span class="meta">		<span class="comment">/* <span class="doctag">FIXME:</span> HACK stw/ldw r19 around syscall */</span>		\</span></span><br><span class="line"><span class="meta">		__asm__ volatile(					\</span></span><br><span class="line"><span class="meta">			K_STW_ASM_PIC					\</span></span><br><span class="line"><span class="meta">			<span class="string">&quot;	ble  0x100(%%sr2, %%r0)\n&quot;</span>		\</span></span><br><span class="line"><span class="meta">			<span class="string">&quot;	ldi %1, %%r20\n&quot;</span>			\</span></span><br><span class="line"><span class="meta">			K_LDW_ASM_PIC					\</span></span><br><span class="line"><span class="meta">			: <span class="string">&quot;=r&quot;</span> (__res)					\</span></span><br><span class="line"><span class="meta">			: <span class="string">&quot;i&quot;</span> (SYS_ify(name)) K_ASM_ARGS_##nr   	\</span></span><br><span class="line"><span class="meta">			: <span class="string">&quot;memory&quot;</span>, K_CALL_CLOB_REGS K_CLOB_ARGS_##nr	\</span></span><br><span class="line"><span class="meta">		);							\</span></span><br><span class="line"><span class="meta">		__sys_res = (long)__res;				\</span></span><br><span class="line"><span class="meta">	&#125;								\</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> ( (unsigned long)__sys_res &gt;= (unsigned long)-4095 )&#123;	\</span></span><br><span class="line"><span class="meta">		errno = -__sys_res;		        		\</span></span><br><span class="line"><span class="meta">		__sys_res = -1;						\</span></span><br><span class="line"><span class="meta">	&#125;								\</span></span><br><span class="line"><span class="meta">	__sys_res;							\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>经过这个系统调用接口，可以不用经过glibc等标准库：<br>eg:<br><a href="https://man7.org/linux/man-pages/man2/_syscall.2.html">https://man7.org/linux/man-pages/man2/_syscall.2.html</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">      <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">      <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line">      <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span>       <span class="comment">/* for _syscallX macros/related stuff */</span></span></span><br><span class="line">      <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>       <span class="comment">/* for struct sysinfo */</span></span></span><br><span class="line"></span><br><span class="line">      _syscall1(<span class="type">int</span>, sysinfo, <span class="keyword">struct</span> sysinfo *, info);</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function">      <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="keyword">struct</span> <span class="title class_">sysinfo</span> s_info;</span><br><span class="line">          <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">          error = <span class="built_in">sysinfo</span>(&amp;s_info);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;code error = %d\n&quot;</span>, error);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Uptime = %lds\nLoad: 1 min %lu / 5 min %lu / 15 min %lu\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;RAM: total %lu / free %lu / shared %lu\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;Memory in buffers = %lu\nSwap: total %lu / free %lu\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;Number of processes = %d\n&quot;</span>,</span><br><span class="line">                 s_info.uptime, s_info.loads[<span class="number">0</span>],</span><br><span class="line">                 s_info.loads[<span class="number">1</span>], s_info.loads[<span class="number">2</span>],</span><br><span class="line">                 s_info.totalram, s_info.freeram,</span><br><span class="line">                 s_info.sharedram, s_info.bufferram,</span><br><span class="line">                 s_info.totalswap, s_info.freeswap,</span><br><span class="line">                 s_info.procs);</span><br><span class="line">          <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  Sample output</span><br><span class="line">      code error = <span class="number">0</span></span><br><span class="line">      uptime = <span class="number">502034</span>s</span><br><span class="line">      Load: <span class="number">1</span> min <span class="number">13376</span> / <span class="number">5</span> min <span class="number">5504</span> / <span class="number">15</span> min <span class="number">1152</span></span><br><span class="line">      RAM: total <span class="number">15343616</span> / free <span class="number">827392</span> / shared <span class="number">8237056</span></span><br><span class="line">      Memory in buffers = <span class="number">5066752</span></span><br><span class="line">      Swap: total <span class="number">27881472</span> / free <span class="number">24698880</span></span><br><span class="line">      Number of processes = <span class="number">40</span></span><br></pre></td></tr></table></figure>

<h3 id="实现一个系统调用；"><a href="#实现一个系统调用；" class="headerlink" title="实现一个系统调用；"></a>实现一个系统调用；</h3><h4 id="定义一个内核系统调用函数：可以通过模块传入："><a href="#定义一个内核系统调用函数：可以通过模块传入：" class="headerlink" title="定义一个内核系统调用函数：可以通过模块传入："></a>定义一个内核系统调用函数：可以通过模块传入：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inculde(linux/kernel.h)</span></span><br><span class="line"><span class="meta">#inculde(linux/module.h)</span></span><br><span class="line"><span class="meta">#inculde(linux/modversions.h)</span></span><br><span class="line"><span class="meta">#inculde(linux/sched.h)</span></span><br><span class="line"><span class="meta">#inculde(asm/uaccess.h)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NR_testsyscall 191</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> viod *sys_call_table[];</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage <span class="type">int</span> <span class="title">testsyscall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    sys_call_table[_NR_tsetsyscall]=testsyscall;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system call testsyscall() loaded success\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里也把数组初始化好了，如果不经过glibc库的话，这里已经可以用了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line">#define_NR_testsyscall <span class="number">191</span></span><br><span class="line">_syscall0(<span class="type">int</span>,testsyscall)</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">testsyscall</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想通过glibc调用，可以通过增加glibc代码，编译后替换所使用的glibc库：<br>通过ldd main可以知道链接了哪个glibc</p>
<p>在网上找对应的版本，修改和编译后替换，具体修改，这里暂时不提供，有兴趣自己探索；</p>
<h3 id="追踪系统调用"><a href="#追踪系统调用" class="headerlink" title="追踪系统调用"></a>追踪系统调用</h3><h4 id="关于ptrace"><a href="#关于ptrace" class="headerlink" title="关于ptrace"></a>关于ptrace</h4><h4 id="如何用ptrace追踪指定的系统调用"><a href="#如何用ptrace追踪指定的系统调用" class="headerlink" title="如何用ptrace追踪指定的系统调用"></a>如何用ptrace追踪指定的系统调用</h4><p>ptrace是一个内核提供的一个可以用来追踪进程运行情况，甚至控制进程运行行为的系统调用，并提供了对应的接口，strace和gdb就是利用ptrace制成的；<br>ptrace本质上是一个用于读取和修改进程地址空间中的值的工具，不能用于直接跟踪系统调用。只有从正确的位置提取出所需的信息，才能跟踪进<br>程并就进行的系统调用得出结论。</p>
<p>ptrace的系统调用： sys_ptrace ,实现：arch&#x2F;arch&#x2F;kernel&#x2F;ptrace.c<br>内核源码中有四个参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;syscalls.h&gt;</span><br><span class="line"><span class="function">asmlinkage <span class="type">long</span> <span class="title">sys_ptrace</span><span class="params">(<span class="type">long</span> request, <span class="type">long</span> pid, <span class="type">long</span> addr, <span class="type">long</span> data)</span></span>;</span><br><span class="line">pid标识了要追踪的进程，可以在进程开始时或者运行中；</span><br><span class="line">addr,data则向内核传递了一个内存地址和附加信息；因选择的操作而不同；</span><br><span class="line"></span><br><span class="line">request用于选择一个操作，由ptrace执行；在ptrace.h中有列出：</span><br><span class="line">PTRACE_TRACEME：tracee表明自己想要被追踪，这会自动与父进程建立追踪关系，这也是唯一能被tracee使用的request，其他的request都由tracer指定。</span><br><span class="line">PTRACE_ATTACH：tracer用来附着一个进程tracee，以建立追踪关系，并向其发送`SIGSTOP`信号使其暂停。</span><br><span class="line">PTRACE_SEIZE：像PTRACE_ATTACH附着进程，但它不会让tracee暂停，addr参数须为<span class="number">0</span>，data参数指定一位ptrace选项。</span><br><span class="line">PTRACE_DETACH：解除追踪关系，tracee将继续运行。</span><br><span class="line">PEEKTEXT、 PEEKDATA和PEEKUSR从进程地址空间读取数据。 PEEKUSR读取普通的CPU寄存</span><br><span class="line">器和使用的任何其他调试寄存器①（当然，会根据标识符只读取一个寄存器的内容，而不是</span><br><span class="line">读取整个寄存器集合的内容）。 PEEKEXT和PEEKDATA从进程的代码段和数据段读取任意字，可以向对应区域写入值，从而操作进程空间的内容；</span><br><span class="line">PTRACE_SYSCALL，如果用该选项激活ptrace，那么内核将开始执行进程，直至调用一个系统调用。</span><br><span class="line">。。。。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/user.h&gt;</span>   <span class="comment">/* For constants</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                   ORIG_EAX etc */</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="type">pid_t</span> child;</span><br><span class="line">    <span class="type">long</span> orig_eax;</span><br><span class="line">    child = fork();</span><br><span class="line">    <span class="keyword">if</span>(child == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">        orig_eax = <span class="built_in">ptrace</span>(PTRACE_PEEKUSER,</span><br><span class="line">                          child, <span class="number">4</span> * ORIG_EAX,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child made a &quot;</span></span><br><span class="line">               <span class="string">&quot;system call %ld\n&quot;</span>, orig_eax);</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_CONT, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="其他：重启系统调用"><a href="#其他：重启系统调用" class="headerlink" title="其他：重启系统调用"></a>其他：重启系统调用</h3><p>当系统调用和信号发生冲突时，有问题：<br>以下内容，引用自 深入linux内核架构：</p>
<p>如果在一个进程执行系统调用时，向该进程发送一个信号，那么在处理时，二者的优先级如何分配呢？应该等到系统调用结束再处理信号，还是<br>中断系统调用，以便尽快将信号投递到该进程？第一种方案导致的问题显然比较少，也是比较简单的<br>方案。遗憾的是，只有在所有系统调用都能够快速结束、不会让进程等待太长时间的情况下，这个方<br>案才能正确运作（信号投递的时机，总是在进程处理完一个系统调用、返回到用户<br>态的时候）。情况不总是这样。系统调用不仅需要一定的执行时间，而且在最坏情况下，很可能使进<br>程睡眠（例如，没有数据可供读取时）。对同时发生的信号而言，这意味着信号投递的严重延迟。因<br>而，必须不惜任何代价防止这种情况</p>
<p>如果一个正在执行的系统调用被中断，内核应该向应用程序返回什么样的值？在通常的场景下，<br>只有两种情况：调用成功或者失败。在出错的情况下，将返回一个错误码，使用户进程能够确定错误<br>的原因，并适当地做出反应。倘若系统调用被中断，则发生了第三种情况：必须通知应用程序，如果<br>系统调用在执行期间没有被信号中断，那么系统调用已经成功结束。在这种情况下， Linux（和其他<br>System V变体）下将使用-EINTR常数</p>
<p>该过程的负面效应是很明显的。尽管该方案易于实现，但它迫使用户空间应用程序的程序员必须<br>明确检查所有系统调用的返回值，并在返回值为-EINTR的情况下，重新启动被中断的系统调用，直至<br>该调用不再被信号中断。用这种方法重启的系统调用称作可重启系统调用（ restartable system call），<br>该技术则称为重启（ restarting）。<br>该行为第一次引入是在System V UNIX中。该方案将新信号的快速投递和系统调用的中断组合起<br>来，但它并非是唯一的组合方式， BSD所采用的方法即可证实这一点。我们来考察BSD内核在系统调<br>用被信号中断时，会做出何种反应。<br>BSD内核将中断系统调用的执行并切换到用户态执行信号处理程序。在发生这种情况时，该系统<br>调用不会有返回值，内核在信号处理程序结束后将自动重启该调用。因为该行为对用户应用程序是透<br>明的，也不再需要重复实现对-EINTR返回值的检查和调用的重启，所以与System V方法相比，这种方<br>案更受程序员的欢迎。<br>Linux通过SA_RESTART标志支持BSD方案，可以在安装信号处理例程时按需对具体信号指定该标<br>志。 System V提议的机制用作默认方案，因为BSD机制偶尔会导致一些困难，如下列例子所示（取自<br>[ME02]第229页）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> signaled = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span> <span class="params">(<span class="type">int</span> signum)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;signaled called\n&quot;</span>);</span><br><span class="line">signaled = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> sigact;</span><br><span class="line">sigact.sa_handler = handler;</span><br><span class="line">sigact.sa_flags = SA_RESTART;</span><br><span class="line"><span class="built_in">sigaction</span>(SIGINT, &amp;sigact, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">read</span>(STDIN_FILENO, &amp;ch, <span class="number">1</span>) != <span class="number">1</span> &amp;&amp; !signaled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个简短的C程序在一个while循环中等待，直至用户通过标准输入键入了一个字符，或者程序<br>被SIGINT信号中断（可使用kill-INT发送该信号，也可以按键CTRL+C）。我们来考察其代码的控制<br>流。如果用户点了一个普通的按键，没有导致发送SIGINT，那么read将得到一个正的返回值，即读<br>取字符的数目。<br>要结束while循环，循环的控制条件必须在逻辑上为false。这里的控制条件是由逻辑与（ &amp;&amp;）<br>运算连接的两个表达式，要结束循环，需要二者之一为false，或全部为false，如下。<br>1 按下了一个键， read返回1，检查read返回不等于1的表达式，其值为false。<br>2 signaled变量设置为1，该变量的反（ !signaled）也将为false值。<br>这些条件意味着，程序要结束，或者需要等到键盘输入，或者需要SIGINT信号到达。<br>为在上述代码中应用Linux默认实现的System V行为，需要取消SA_RESTART标志的设置。换句话<br>说， sigact.sa_flags &#x3D; SA_RESTART一行需要删除或注释掉。在这样做之后，程序将按上面的描述<br>运行，在按下一个键或接收到SIGINT时结束。<br>如果激活了BSD行为模式，而read被SIGINT信号中断，那么示例程序的情况将更为有趣。在这<br>种情况下，将调用信号处理程序，将signaled设置为1，并输出一个消息表示接收到了SIGINT，但程<br>序不会结束。为什么?在运行处理程序之后， BSD机制将重启read调用，并再次等待输入一个字符。<br>这种情况使得while循环控制条件中的!signaled部分无法进行求值，导致循环不能结束。因而该程<br>序不能通过向其发送SIGNIT信号结束，尽管在表面上，代码的语义确实如此。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>systemcall</tag>
      </tags>
  </entry>
  <entry>
    <title>video_h264</title>
    <url>/2022/03/27/video-h264/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="AnnexB-AVCC-RBSP-等概念"><a href="#AnnexB-AVCC-RBSP-等概念" class="headerlink" title="AnnexB,AVCC,RBSP,等概念"></a>AnnexB,AVCC,RBSP,等概念</h4><p>1 AnnexB,AVCC,HVCC  <span id="more"></span><br>H.264码流分Annex-B和AVCC两种格式<br>H.265码流是Annex-B和HVCC格式。</p>
<ul>
<li>AVCC格式 也叫AVC1格式，MPEG-4格式，字节对齐，因此也叫Byte-Stream Format。用于mp4&#x2F;flv&#x2F;mkv, VideoToolbox。</li>
<li>Annex-B格式 也叫MPEG-2 transport stream format格式（ts格式）, ElementaryStream格式。<br>2 AnnexB和AVCC的区别：<br>区别有两点：一个是参数集(SPS, PPS)组织格式；一个是分隔。</li>
</ul>
<ul>
<li>Annex-B：使用start code分隔NAL(start code为三字节或四字节，0x000001或0x00000001，一般是四字节)；SPS和PPS按流的方式写在头部。</li>
<li>AVCC：使用NALU长度（固定字节，通常为4字节）分隔NAL；在头部包含extradata(或sequence header)的结构体。（extradata包含分隔的字节数、SPS和PPS，具体结构见下）</li>
</ul>
<ul>
<li>AnnexB:</li>
</ul>
<ol>
<li><p>AnnexB格式—-用于实时播放<br>处于H264文档附录B（Annex-B Byte stream format）中<br>开始前缀start code（00000001或000001）＋NALU数据　　绝大部分编码器的默认输出格式<br>　　一共有两种起始码start_code<br>　　　①3字节0x000001　　单帧多slice（即单帧多个NALU）之间间隔<br>　　　②4字节0x00000001　帧之间，或者SPS等之前<br>4字节类型的开始码在在连续的数据传输中非常有用，因为用字节来对齐、分割流数据，比如：用连续的31个bit0后接一个bit1来分割流数据，是很容易的。  </p>
</li>
<li><p>格式：<br>AnnexB格式每个NALU都包含起始码，且通常会周期性的在关键帧之前重复SPS和PPS，所以解码器可以从视频流随机点开始进行解码，实时的流格式<br>AnnexB format:  In annexb, [start code] may be 0x000001 or 0x00000001.<br>([start code] NALU) | ( [start code] NALU) |   more detail:  ([start code] SPS NALU) | ( [start code] PPS NALU)  ([start code] NALU) | ( [start code] NALU)</p>
</li>
<li><p>FLV可能封装形式：<br>对AnnexB:<br>AVCC头，塞两个NALU sps pps<br>AVC数据：起始码 nalu   </p>
</li>
<li><p>关于RBSP和AnnexB如何处理竞争码：<br>RBSP:是没有竞争码字节的NALU即RBSP:A NALU representation without emulation prevention bytes is called a Raw Byte Sequence Payload, or RBSP<br>为啥需要竞争码？<br>我们知道，AnnexB是通过start code(上述)来分割Nalu的，但如果Nalu数据中就有start_code，这个时候分割就会出现问题，如何处理？<br>spec这样处理，认为四字节序列0x00000000、0x00000001、0x00000002和0x00000003在非rbsp NALU中是非法的，因此进行字节填充：<br>为了将RBSP转换为具有开始代码的NALU，字节填充是通过在两个连续的0x00字节之后插入一个预防字节0x03(竞争码)来实现的。所以，要反转这种情况，在读取流时，删除两个连续的0x00字节之后的任何0x03。<br>才能还原原始的RBSP.<br>要确定NALU的长度，从一个字节流开始(它将有一个开始代码)，跳到下一个开始代码，并计算中间的字节数。</p>
</li>
</ol>
<ul>
<li>AVCC:</li>
</ul>
<ol>
<li>AVCC—用于存储<br>解码器配置参数在一开始就配置好了，系统可以很容易的识别NALU的边界，不需要额外的起始码，减少了资源的浪费，同时可以在播放时调到视频的中间位置。这种格式通常被用于可以被随机访问的多媒体数据，如存储在硬盘的文件。MP4、MKV通常用AVCC格式来存储。</li>
</ol>
<p>AVCC格式不使用起始码作为NALU的分界，这种格式在每个NALU前都加上一个大端格式的前缀（1、2、4字节，代表NALU长度）<br>所以在解析AVCC格式的时候需要将指定的前缀字节数的值保存在一个头部对象中，这个都通常称为extradata或者sequence header。同时，SPS和PPS数据也需要保存在extradata或者叫’sequence header’中。<br>H.264 extradata &#x2F; sequence header</p>
<ol start="2">
<li>AVCC format:<br>([extradata]) | ([length] NALU) | ([length] NALU) |</li>
</ol>
<p>In avcc, the bytes of [length] depends on NALULengthSizeMinusOne in avcc extradata, the value of [length] depends on the size of following NALU and in both annexb and avcc format, the NALUs are no different.</p>
<p>AVCC中的extradata格式：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">An AVCC stream always starts with a specific header</span><br><span class="line">     - <span class="number">8</span> bits = <span class="number">0x01</span> (this <span class="built_in">is</span> illegal <span class="keyword">in</span> Annex B)</span><br><span class="line">     - <span class="number">8</span> bits of avc profile (from sps[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">     - <span class="number">8</span> bits of avc compatibility (from sps[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line">     - <span class="number">8</span> bits of avc level (from sps[<span class="number">0</span>][<span class="number">3</span>])</span><br><span class="line">     - <span class="number">6</span> bits = <span class="number">0b111111</span></span><br><span class="line">     - <span class="number">2</span> bits of NALULengthSizeMinusOne (typically <span class="number">3</span>)</span><br><span class="line">     - <span class="number">3</span> bits of <span class="number">0b111</span></span><br><span class="line">     - <span class="number">5</span> bits of number of SPS NALU (usually <span class="number">1</span>)</span><br><span class="line">     - Repeated per SPS</span><br><span class="line">           - <span class="number">16</span> bits of SPS size - </span><br><span class="line">           - Variable SPS NALU data</span><br><span class="line">     - <span class="number">8</span> bits of number of PPS NALU (usually <span class="number">1</span>)</span><br><span class="line">     - Repeated once per PPS</span><br><span class="line">           - <span class="number">16</span> bits of PPS size</span><br><span class="line">           - Variable PPS NALU data</span><br><span class="line">           </span><br><span class="line">ref:http://neurocline.github.io/dev/<span class="number">2016</span>/<span class="number">07</span>/<span class="number">28</span>/video-<span class="keyword">and</span>-containers.html</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>FLV streams must be written as AVCC.<br>AVCC封装到flv:<br>对AVCC:<br>AVC 头： flvtag + flvvideotag + extradata + pretagsize<br>AVC 数据： flvtag + flvvideotag + 长度 + nalu  长度+nalu ,..+ pretagsize ,一个tag可能有多个nalu,但是不会跨</li>
</ol>
<p>RTP封装：转换为rtp:  去掉起始码，带nalu长度，头和数据，如果是IDR，需要在前面加sps pps nalu  </p>
<ul>
<li>H264的流，封装nalu的方式常见分为两种，Annex B和 AVCC ，其实还有Annex A。。。</li>
</ul>
<h4 id="nalu"><a href="#nalu" class="headerlink" title="nalu"></a>nalu</h4><h5 id="字段描述规定："><a href="#字段描述规定：" class="headerlink" title="字段描述规定："></a>字段描述规定：</h5><p>The following descriptors specify the parsing process of each syntax element. For some syntax elements, two descriptors, separated by a vertical bar, are used. In these cases, the left descriptors apply when entropy_coding_mode_flag is equal to 0 and the right descriptor applies when entropy_coding_mode_flag is equal to 1.以下描述符指定了每个语法元素的解析过程。对于某些语法元素，使用两个描述符，用竖线分隔。在这些情况下，当 entropy_coding_mode_flag 等于 0 时应用左描述符，当 entropy_coding_mode_flag 等于 1 时应用右描述符。<br>– ae(v): context-adaptive arithmetic entropy-coded syntax element. The parsing process for this descriptor is specified in clause 9.3.上下文自适应算术熵编码语法元素。该描述符的解析过程在第 9.3 节中规定<br>– b(8): byte having any pattern of bit string (8 bits). The parsing process for this descriptor is specified by the return value of the function read_bits( 8 ).具有任何位串模式（8 位）的字节。该描述符的解析过程由函数 read_bits(8) 的返回值指定。<br>– ce(v): context-adaptive variable-length entropy-coded syntax element with the left bit first. The parsing process for this descriptor is specified in clause 9.2.上下文自适应可变长度熵编码语法元素，左位在前。该描述符的解析过程在第 9.2 节中规定。<br>– f(n): fixed-pattern bit string using n bits written (from left to right) with the left bit first. The parsing process for this descriptor is specified by the return value of the function read_bits( n ).固定模式位串使用 n 位写入（从左到右），左位在前。该描述符的解析过程由函数 read_bits( n ) 的返回值指定。<br>– i(n): signed integer using n bits. When n is “v” in the syntax table, the number of bits varies in a manner dependent on the value of other syntax elements. The parsing process for this descriptor is specified by the return value of the function read_bits( n ) interpreted as a two’s complement integer representation with most significant bit written first.使用 n 位的有符号整数。当语法表中的n为“v”时，比特数以依赖于其他语法元素的值的方式变化。该描述符的解析过程由函数 read_bits( n ) 的返回值指定，解释为二进制补码整数表示，最高有效位首先写入。<br>– me(v): mapped Exp-Golomb-coded syntax element with the left bit first. The parsing process for this descriptor is specified in clause 9.1.映射 Exp-Golomb 编码的语法元素，左位在前。该描述符的解析过程在第 9.1 节中规定。<br>– se(v): signed integer Exp-Golomb-coded syntax element with the left bit first. The parsing process for this descriptor is specified in clause 9.1.左位在前的有符号整数 Exp-Golomb 编码语法元素。该描述符的解析过程在第 9.1 节中规定。<br>– te(v): truncated Exp-Golomb-coded syntax element with left bit first. The parsing process for this descriptor is specified in clause 9.1.截断的 Exp-Golomb 编码语法元素，左位在前。该描述符的解析过程在第 9.1 节中规定。<br>– u(n): unsigned integer using n bits. When n is “v” in the syntax table, the number of bits varies in a manner dependent on the value of other syntax elements. The parsing process for this descriptor is specified by the return value of the function read_bits( n ) interpreted as a binary representation of an unsigned integer with most significant bit written first.使用 n 位的无符号整数。当语法表中的n为“v”时，比特数以依赖于其他语法元素的值的方式变化。该描述符的解析过程由函数 read_bits( n ) 的返回值指定，该函数解释为无符号整数的二进制表示，最高有效位首先写入。<br>– ue(v): unsigned integer Exp-Golomb-coded syntax element with the left bit first. The parsing process for this descriptor is specified in clause 9.1.无符号整数 Exp-Golomb 编码的语法元素，左位在前。该描述符的解析过程在第 9.1 节中规定。 </p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="selector-tag">b</span>(<span class="number">8</span>),<span class="built_in">f</span>(n), 基于read_bits,讲究顺序性。后者可以读取多个bit,  </span><br><span class="line"><span class="number">2</span>. <span class="selector-tag">i</span>(n), <span class="built_in">u</span>(n)，两者的区别是一个是有符号的整数，一个是无符号的。 两个都是基于read_bits，但是支持可变的长度，长度由另一个字段决定；  </span><br><span class="line">在 <span class="built_in">seq_parameter_set_data</span>( ) 中获得的一对语法元素 log2_max_frame_num_minus4 <span class="selector-attr">[ue(v)]</span> 和在 <span class="built_in">slice_header</span>( ) 中获得的 frame_num <span class="selector-attr">[u(v)]</span> 就是一个很好的例子，其中 frame_num = log2_max_frame_num_minus4 + <span class="number">4</span>。</span><br><span class="line">假设 log2_max_frame_num_minus4 = <span class="number">4</span>（参考下一节关于解析 <span class="built_in">ue</span>(v)），那么 frame_num = <span class="number">4</span> + <span class="number">4</span> = <span class="number">8</span>。所以，为了得到 frame_num 的值，你可以用 <span class="built_in">u</span>(<span class="number">8</span>) = <span class="selector-tag">b</span>(<span class="number">8</span>)= <span class="built_in">f</span>(<span class="number">8</span>) = <span class="built_in">read_bits</span>( <span class="number">8</span> ) 解析比特流。</span><br><span class="line"><span class="number">3</span>. <span class="built_in">ue</span>(v), <span class="built_in">te</span>(v), <span class="built_in">se</span>(v), <span class="built_in">me</span>(v)  </span><br><span class="line">这些都是 Exp-Golomb 编码。要解码，您需要一个可以通过以下方式计算的 codeNum：  </span><br></pre></td></tr></table></figure>
<p>ref:<br><a href="https://yumichan.net/video-processing/video-compression/explanation-of-descriptors-in-itu-t-publication-on-h-264-coding-standardrecommendation-with-example/">https://yumichan.net/video-processing/video-compression/explanation-of-descriptors-in-itu-t-publication-on-h-264-coding-standardrecommendation-with-example/</a></p>
<p>rfc: file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;Administrator&#x2F;Downloads&#x2F;T-REC-H.264-200503-S!!PDF-E.pdf</p>
<h5 id="nalu-格式："><a href="#nalu-格式：" class="headerlink" title="nalu 格式："></a>nalu 格式：</h5><p>ref: <a href="https://yumichan.net/video-processing/video-compression/introduction-to-h264-2-sodb-vs-rbsp-vs-ebsp/">https://yumichan.net/video-processing/video-compression/introduction-to-h264-2-sodb-vs-rbsp-vs-ebsp/</a></p>
<ul>
<li>整体格式：<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">nalu <span class="keyword">header</span> <span class="keyword">format</span>:  F(<span class="number">1</span>) NRI(<span class="number">2</span>) <span class="keyword">TYPE</span>(<span class="number">5</span>)</span><br><span class="line">nal_unit( NumBytesInNALunit ) &#123; C Descriptor</span><br><span class="line">    // NAL Unit <span class="keyword">Header</span> <span class="number">1</span>Byte</span><br><span class="line">    forbidden_zero_bit <span class="keyword">All</span> f(<span class="number">1</span>)   第一位</span><br><span class="line">    nal_ref_idc <span class="keyword">All</span> u(<span class="number">2</span>)  <span class="number">2</span>bit</span><br><span class="line">    nal_unit_type <span class="keyword">All</span> u(<span class="number">5</span>)   <span class="number">5</span>bit</span><br><span class="line">    NumBytesInRBSP = <span class="number">0</span></span><br><span class="line">     //下面的过程是为了去掉 <span class="number">0x03</span> ,因为编码时会加入</span><br><span class="line">      <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; NumBytesInNALunit; i++ ) &#123;</span><br><span class="line">          <span class="keyword">if</span>( i + <span class="number">2</span> &lt; NumBytesInNALunit &amp;&amp; next_bits( <span class="number">24</span> ) = = <span class="number">0x000003</span> ) &#123;</span><br><span class="line">               rbsp_byte[ NumBytesInRBSP++ ] <span class="keyword">All</span> b(<span class="number">8</span>)</span><br><span class="line">               rbsp_byte[ NumBytesInRBSP++ ] <span class="keyword">All</span> b(<span class="number">8</span>)</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">           emulation_prevention_three_byte <span class="comment">/* equal to 0x03 */</span> <span class="keyword">All</span> f(<span class="number">8</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          rbsp_byte[ NumBytesInRBSP++ ] <span class="keyword">All</span> b(<span class="number">8</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">SODB + RBSP Stop <span class="type">bit</span> + <span class="number">0</span> <span class="type">bit</span>(s) =&gt; RBSP</span><br></pre></td></tr></table></figure>
对AnnexB:<br>RBSP part 1 + 0x03 + RBSP part 2 + 0x03 + … + RBSP part n &#x3D;&gt; EBSP<br>NALU Header + EBSP &#x3D;&gt; NALU</li>
</ul>
<p>In Byte Stream Format (Annex B),<br>Start Code + NALU + … + Start Code + NALU &#x3D;&gt; H.264 Byte Stream</p>
<p>对AVCC 略，参考上面</p>
<ul>
<li><p>example:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">eg</span>:</span><br><span class="line"><span class="attribute">Hex</span>	Binary</span><br><span class="line"><span class="attribute">0x67</span>	<span class="number">0110</span> <span class="number">0111</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">So</span>, for <span class="number">0</span>x67, we have:</span><br><span class="line"><span class="attribute">forbidden_zero_bit</span> = <span class="number">0</span>,</span><br><span class="line"><span class="attribute">nal_ref_idc</span> = <span class="number">3</span>,</span><br><span class="line"><span class="attribute">nal_unit_type</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字段解释：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">forbidden_zero_bit: <span class="number">1</span>bit</span><br><span class="line">The <span class="number">1</span>st bit <span class="keyword">is</span> forbidden_zero_bit which <span class="keyword">is</span> used <span class="keyword">to</span> check whether there <span class="keyword">is</span> any <span class="keyword">error</span> occurred during <span class="keyword">the</span> transmission. <span class="number">0</span> means <span class="keyword">that</span> <span class="keyword">it</span> <span class="keyword">is</span> normal <span class="keyword">while</span> <span class="number">1</span> indicates a syntax violation. So, we should always find <span class="keyword">that</span> forbidden_zero_bit <span class="keyword">equals</span> <span class="number">0.</span> 检查是否传输错误，<span class="number">0</span>表示没有，<span class="number">1</span>表示有错误。</span><br><span class="line"></span><br><span class="line">nal_ref_idc: <span class="number">2</span>bit</span><br><span class="line">nal_ref_idc <span class="keyword">not</span> <span class="keyword">equal</span> <span class="keyword">to</span> <span class="number">0</span> specifies <span class="keyword">that</span> <span class="keyword">the</span> content <span class="keyword">of</span> <span class="keyword">the</span> NAL unit <span class="keyword">contains</span> a sequence parameter <span class="keyword">set</span> <span class="keyword">or</span> a picture parameter <span class="keyword">set</span> <span class="keyword">or</span> a slice <span class="keyword">of</span> <span class="keyword">a reference</span> picture <span class="keyword">or</span> a slice data partition <span class="keyword">of</span> <span class="keyword">a reference</span> picture.  不为<span class="number">0</span>表示包含一个sps或pps，或一个参考帧slice或一个参考帧的一部分slice数据</span><br><span class="line">nal_ref_idc <span class="keyword">equal</span> <span class="keyword">to</span> <span class="number">0</span> <span class="keyword">for</span> a NAL unit containing a slice <span class="keyword">or</span> slice data partition indicates <span class="keyword">that</span> <span class="keyword">the</span> slice <span class="keyword">or</span> slice data partition <span class="keyword">is</span> part <span class="keyword">of</span> a non-<span class="keyword">reference</span> picture. 为<span class="number">0</span>表示，在NALU单元中，表示包含一个slice或slice data部分，不是参考帧</span><br><span class="line">nal_ref_idc shall <span class="keyword">not</span> be <span class="keyword">equal</span> <span class="keyword">to</span> <span class="number">0</span> <span class="keyword">for</span> sequence parameter <span class="keyword">set</span> <span class="keyword">or</span> sequence parameter <span class="keyword">set</span> extension <span class="keyword">or</span> picture parameter <span class="keyword">set</span> NAL units. When nal_ref_idc <span class="keyword">is</span> <span class="keyword">equal</span> <span class="keyword">to</span> <span class="number">0</span> <span class="keyword">for</span> one slice <span class="keyword">or</span> slice data partition NAL unit <span class="keyword">of</span> a particular picture, <span class="keyword">it</span> shall be <span class="keyword">equal</span> <span class="keyword">to</span> <span class="number">0</span> <span class="keyword">for</span> all slice <span class="keyword">and</span> slice data partition NAL units <span class="keyword">of</span> <span class="keyword">the</span> picture. </span><br><span class="line">nal_ref_idc shall <span class="keyword">not</span> be <span class="keyword">equal</span> <span class="keyword">to</span> <span class="number">0</span> <span class="keyword">for</span> IDR NAL units, i.e., NAL units <span class="keyword">with</span> nal_unit_type <span class="keyword">equal</span> <span class="keyword">to</span> <span class="number">5.</span> </span><br><span class="line">nal_ref_idc shall be <span class="keyword">equal</span> <span class="keyword">to</span> <span class="number">0</span> <span class="keyword">for</span> all NAL units having nal_unit_type <span class="keyword">equal</span> <span class="keyword">to</span> <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="keyword">or</span> <span class="number">12.</span> </span><br><span class="line">总结：</span><br><span class="line">nal_ref_idc indicating whether this NAL unit <span class="keyword">is</span> <span class="keyword">a reference</span> field / frame / picture. 是否是一个参考帧或图片</span><br><span class="line">On one hand, <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> <span class="keyword">a reference</span> field / frame / picture, nal_ref_idc <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">equal</span> <span class="keyword">to</span> <span class="number">0.</span> 若是，则不为<span class="number">0</span></span><br><span class="line">根据建议，非<span class="number">0</span>，则表示nalu单元的内容包含一个sps,一个sps扩展，一个sps子集，一个PPS,一个参考帧的slice,一个参考帧中的一个slice部分，或一个在参考图像的切片之前的一种前缀NAL单元。</span><br><span class="line">另一方面，若不是一个参考帧，则这个值是<span class="number">0</span> </span><br><span class="line">对任何非<span class="number">0</span> 的值，值越大，则越重要。 在这里 它是<span class="number">0x11</span>,实际上它是一个sps</span><br><span class="line"></span><br><span class="line">nal_unit_type</span><br><span class="line">nalu 单元类型：</span><br><span class="line">指定NAL单元中包含的RBSP数据结构的类型，如表所示。VCL NAL单位被指定为nal_unit_type等于<span class="number">1</span>到<span class="number">5</span>的NAL单位。所有剩余的NAL单位称为非vcl NAL单位。</span><br><span class="line"><span class="number">1</span> 非IDR slice</span><br><span class="line"><span class="number">2</span> <span class="number">-4</span>  parg <span class="keyword">of</span> slice</span><br><span class="line"><span class="number">5</span> IDR slice</span><br><span class="line"><span class="number">6</span> sei</span><br><span class="line"><span class="number">7</span> sps</span><br><span class="line"><span class="number">8</span> pps</span><br><span class="line"><span class="number">9</span>: access unit delimiter: 访问单元分隔符可用于指示主编码图像中出现的片的类型，并简化对访问单元之间边界的检测。没有与访问单元分隔符关联的规范解码过程</span><br><span class="line">&#123;</span><br><span class="line">       语法：</span><br><span class="line">       access_unit_delimiter_rbsp( ) &#123; C Descriptor</span><br><span class="line">            primary_pic_type <span class="number">6</span> u(<span class="number">3</span>) <span class="number">3</span>bit</span><br><span class="line">            rbsp_trailing_bits( ) <span class="number">6</span></span><br><span class="line">       &#125; </span><br><span class="line">       primary_pic_type表示主代码图片的所有切片的slice_type值都是给定primary_pic_type值的表<span class="number">7</span><span class="number">-5</span>中列出的集合的成员。</span><br><span class="line">       </span><br><span class="line">       primary_pic_type slice_type values <span class="keyword">that</span> may be present <span class="keyword">in</span> <span class="keyword">the</span> primary coded picture</span><br><span class="line">       <span class="number">0</span> I</span><br><span class="line">       <span class="number">1</span> I, P</span><br><span class="line">       <span class="number">2</span> I, P, B</span><br><span class="line">       <span class="number">3</span> SI</span><br><span class="line">       <span class="number">4</span> SI, SP</span><br><span class="line">       <span class="number">5</span> I, SI</span><br><span class="line">       <span class="number">6</span> I, SI, P, SP</span><br><span class="line">       <span class="number">7</span> I, SI, P, SP, B</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span> End <span class="keyword">of</span> sequence RBSP semantics;</span><br><span class="line">序列结束RBSP指定在解码顺序位流中(如果有)下一个后续访问单元为IDR访问单元。序列RBSP结尾的SODB和RBSP语法内容为空。没有为序列RBSP的结束指定规范的解码过程。</span><br><span class="line"></span><br><span class="line"><span class="number">11</span> End <span class="keyword">of</span> Stream:</span><br><span class="line">流RBSP结束表示在解码顺序上，流RBSP结束后的位流中不应出现任何额外的NAL单元。流RBSP结束时的SODB和RBSP语法内容为空。没有为流RBSP的结束指定标准解码过程。</span><br><span class="line">...</span><br><span class="line">more: spec:</span><br><span class="line">Table <span class="number">7</span><span class="number">-1</span> – NAL unit type codes, syntax element categories, <span class="keyword">and</span> NAL unit type classes</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/2022/03/27/video-h264/table7-1.png" class="" title="tes">
<p> 标记为C的列列出了NAL单元中可能存在的语法元素的类别。此外，还可能存在语法类别为All的语法元素，这是由RBSP数据结构的语法和语义决定的。具体列出的类别中是否存在任何语法元素，取决于相关RBSP数据结构的语法和语义。nal_unit_type不应该等于3或4，除非在RBSP数据结构中存在至少一个语法元素，其语法元素类别值等于nal_unit_type的值，而不是分类为All。<br>具有nal_unit_type等于13和19的NAL单元可能被解码器丢弃，而不影响对具有nal_unit_type不等于13或19的NAL单元的解码过程，且不影响符合此国际标准</p>
<p>对应的NRI 值</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Nal Unit Type                             Possible nal_ref_idc <span class="built_in">value</span></span><br><span class="line"><span class="number">1</span> – <span class="number">4</span>                                     If <span class="literal">one</span> <span class="keyword">of</span> <span class="keyword">the</span> NALU is <span class="number">0</span>, all NAL units <span class="keyword">with</span> Type <span class="keyword">in</span> <span class="keyword">the</span> tang <span class="keyword">of</span> <span class="number">1</span> – <span class="number">4</span>, inclusive, <span class="keyword">of</span> <span class="keyword">the</span> picture are <span class="number">0</span></span><br><span class="line"><span class="number">5</span> Coded slice <span class="keyword">of</span> <span class="keyword">an</span> IDR picture           non-<span class="literal">zero</span>   IDR picture</span><br><span class="line"><span class="number">7</span> Sequence parameter <span class="built_in">set</span>                  non-<span class="literal">zero</span>   sps</span><br><span class="line"><span class="number">8</span> Picture parameter <span class="built_in">set</span>                   non-<span class="literal">zero</span>   pps</span><br><span class="line"><span class="number">13</span> Sequence parameter <span class="built_in">set</span> <span class="built_in">extension</span>       non-<span class="literal">zero</span>   </span><br><span class="line"><span class="number">15</span> Subset sequence parameter <span class="built_in">set</span>          non-<span class="literal">zero</span></span><br><span class="line"><span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> <span class="keyword">or</span> <span class="number">12</span>                        <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>rbsp构成：<br>rbsp_trailing_bits( ) 5  即在nalu中提到的，用来做stop和align的bits: 如下</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">rbsp_stop_one_bit = <span class="number">1</span></span><br><span class="line">rbsp_alignment_zero_bit(s) = <span class="number">0</span>(s) <span class="string">[[Must make the SODB byte-aligned]]</span></span><br></pre></td></tr></table></figure>
<img src="/2022/03/27/video-h264/rbsp.png" class="" title="tes"></li>
<li><p>sps格式：</p>
<img src="/2022/03/27/video-h264/sps.png" class="" title="tes"></li>
<li><p>pps格式：</p>
<img src="/2022/03/27/video-h264/pps.png" class="" title="tes"></li>
<li><p>sei:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">sei_rbsp</span><span class="params">( )</span></span> &#123;                     C Descriptor</span><br><span class="line">do</span><br><span class="line"><span class="function"><span class="title">sei_message</span><span class="params">( )</span></span>                       <span class="number">5</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">( more_rbsp_data( )</span></span> )</span><br><span class="line"><span class="function"><span class="title">rbsp_trailing_bits</span><span class="params">( )</span></span>                <span class="number">5</span>  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sei_message</span><span class="params">( )</span></span> &#123; C Descriptor</span><br><span class="line">    payloadType = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">( next_bits( <span class="number">8</span> )</span></span> = = <span class="number">0</span>xFF ) &#123;</span><br><span class="line">    ff_byte <span class="comment">/* equal to 0xFF */</span> <span class="number">5</span> <span class="built_in">f</span>(<span class="number">8</span>)</span><br><span class="line">    payloadType += <span class="number">255</span></span><br><span class="line">&#125;</span><br><span class="line">last_payload_type_byte <span class="number">5</span> <span class="built_in">u</span>(<span class="number">8</span>)</span><br><span class="line">payloadType += last_payload_type_byte</span><br><span class="line">payloadSize = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">( next_bits( <span class="number">8</span> )</span></span> = = <span class="number">0</span>xFF ) &#123;</span><br><span class="line">    ff_byte <span class="comment">/* equal to 0xFF */</span> <span class="number">5</span> <span class="built_in">f</span>(<span class="number">8</span>)</span><br><span class="line">    payloadSize += <span class="number">255</span></span><br><span class="line">&#125;</span><br><span class="line">last_payload_size_byte <span class="number">5</span> <span class="built_in">u</span>(<span class="number">8</span>)</span><br><span class="line">payloadSize += last_payload_size_byte</span><br><span class="line"><span class="function"><span class="title">sei_payload</span><span class="params">( payloadType, payloadSize )</span></span> <span class="number">5</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>slice格式：一个Nalu一般是一个slice?</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title class_">Slice</span> <span class="variable">layer</span> <span class="variable">without</span> <span class="variable">partitioning</span> <span class="variable">RBSP</span> <span class="variable">syntax</span></span><br><span class="line">    <span class="title function_">slice_layer_without_partitioning_rbsp</span>( ) &#123;           <span class="variable">C</span> <span class="title class_">Descriptor</span></span><br><span class="line">    <span class="title function_">slice_header</span>( )                                              <span class="number">2</span></span><br><span class="line">    <span class="title function_">slice_data</span>( ) <span class="comment">/* all categories of slice_data( ) syntax */</span> <span class="number">2</span> <span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> <span class="number">4</span></span><br><span class="line">   <span class="title function_">rbsp_slice_trailing_bits</span>( )                                   <span class="number">2</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="title class_">Slice</span> <span class="variable">data</span> <span class="variable">partition</span> <span class="variable">RBSP</span> <span class="variable">syntax</span> </span><br><span class="line"><span class="number">1</span> <span class="title class_">Slice</span> <span class="variable">data</span> <span class="variable">partition</span> <span class="variable">A</span> <span class="variable">RBSP</span> <span class="variable">syntax</span></span><br><span class="line">     <span class="title function_">slice_data_partition_a_layer_rbsp</span>( ) &#123; <span class="variable">C</span> <span class="title class_">Descriptor</span></span><br><span class="line">     <span class="title function_">slice_header</span>( ) <span class="number">2</span></span><br><span class="line">     <span class="variable">slice_id</span> <span class="title class_">All</span> <span class="title function_">ue</span>(<span class="variable">v</span>)</span><br><span class="line">      <span class="title function_">slice_data</span>( ) <span class="comment">/* only category 2 parts of slice_data( ) syntax */</span> <span class="number">2</span></span><br><span class="line">      <span class="title function_">rbsp_slice_trailing_bits</span>( ) <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Slice</span> <span class="variable">data</span> <span class="variable">partition</span> <span class="variable">B</span> <span class="variable">RBSP</span> <span class="variable">syntax</span></span><br><span class="line"><span class="title function_">slice_data_partition_b_layer_rbsp</span>( ) &#123; <span class="variable">C</span> <span class="title class_">Descriptor</span></span><br><span class="line"><span class="variable">slice_id</span> <span class="title class_">All</span> <span class="title function_">ue</span>(<span class="variable">v</span>)</span><br><span class="line"> <span class="keyword">if</span>( <span class="variable">redundant_pic_cnt_present_flag</span> )</span><br><span class="line"> <span class="variable">redundant_pic_cnt</span> <span class="title class_">All</span> <span class="title function_">ue</span>(<span class="variable">v</span>)</span><br><span class="line"> <span class="title function_">slice_data</span>( ) <span class="comment">/* only category 3 parts of slice_data( ) syntax */</span> <span class="number">3</span></span><br><span class="line"> <span class="title function_">rbsp_slice_trailing_bits</span>( ) <span class="number">3</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="title class_">Slice</span> <span class="variable">data</span> <span class="variable">partition</span> <span class="variable">C</span> <span class="variable">RBSP</span> <span class="variable">syntax</span></span><br><span class="line"><span class="title function_">slice_data_partition_c_layer_rbsp</span>( ) &#123; <span class="variable">C</span> <span class="title class_">Descriptor</span></span><br><span class="line"><span class="variable">slice_id</span> <span class="title class_">All</span> <span class="title function_">ue</span>(<span class="variable">v</span>)</span><br><span class="line"> <span class="keyword">if</span>( <span class="variable">redundant_pic_cnt_present_flag</span> )</span><br><span class="line"> <span class="variable">redundant_pic_cnt</span> <span class="title class_">All</span> <span class="title function_">ue</span>(<span class="variable">v</span>)</span><br><span class="line"> <span class="title function_">slice_data</span>( ) <span class="comment">/* only category 4 parts of slice_data( ) syntax */</span> <span class="number">4</span></span><br><span class="line"> <span class="title function_">rbsp_slice_trailing_bits</span>( ) <span class="number">4</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line"><span class="variable">RBSP</span> <span class="variable">slice</span> <span class="variable">trailing</span> <span class="variable">bits</span> <span class="variable">syntax</span></span><br><span class="line"><span class="title function_">rbsp_slice_trailing_bits</span>( ) &#123; <span class="variable">C</span> <span class="title class_">Descriptor</span></span><br><span class="line"> <span class="title function_">rbsp_trailing_bits</span>( ) <span class="title class_">All</span></span><br><span class="line"> <span class="keyword">if</span>( <span class="variable">entropy_coding_mode_flag</span> )</span><br><span class="line"> <span class="keyword">while</span>( <span class="title function_">more_rbsp_trailing_data</span>( ) )</span><br><span class="line"> <span class="variable">cabac_zero_word</span> <span class="comment">/* equal to 0x0000 */</span> <span class="title class_">All</span> <span class="title function_">f</span>(<span class="number">16</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">RBSP</span> <span class="variable">trailing</span> <span class="variable">bits</span> <span class="variable">syntax</span></span><br><span class="line"><span class="title function_">rbsp_trailing_bits</span>( ) &#123; <span class="variable">C</span> <span class="title class_">Descriptor</span></span><br><span class="line"><span class="variable">rbsp_stop_one_bit</span> <span class="comment">/* equal to 1 */</span> <span class="title class_">All</span> <span class="title function_">f</span>(<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">while</span>( <span class="operator">!</span><span class="title function_">byte_aligned</span>( ) )</span><br><span class="line"> <span class="variable">rbsp_alignment_zero_bit</span> <span class="comment">/* equal to 0 */</span> <span class="title class_">All</span> <span class="title function_">f</span>(<span class="number">1</span>)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">slice_header</span>( ) &#123;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>
<h4 id="srs如何处理AnnexB和AVCC"><a href="#srs如何处理AnnexB和AVCC" class="headerlink" title="srs如何处理AnnexB和AVCC:"></a>srs如何处理AnnexB和AVCC:</h4><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 在收到rtmp包时，其实携带的是flv tag，所以会从flv tag入手解析：</span><br><span class="line">   若是avc header时，srs假定不管是avcc还是annexB都是把 sps,pps以 extradata形式放在avc header的，实际上annexB标准并不是extradata；</span><br><span class="line"></span><br><span class="line">   若不是avc header，srs解析 avcc和annexB的nalu ,这个时候前者通过长度来分离nalu到sample数组，后者通过起始码来分离nalu到数组；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码如下：</span><br><span class="line">srs_error_t SrsFormat::on_video(int64_t timestamp, char* <span class="keyword">data</span>, int size)</span><br><span class="line">&#123;</span><br><span class="line">    srs_error_t err = srs_success;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">data</span> || size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        srs_trace(<span class="string">&quot;no video present, ignore it.&quot;</span>);</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SrsBuffer* buffer = new SrsBuffer(<span class="keyword">data</span>, size);</span><br><span class="line">    SrsAutoFree(SrsBuffer, buffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We already checked the size is positive and data is not NULL.</span></span><br><span class="line">    <span class="function"><span class="title">srs_assert</span>(buffer-&gt;</span>require(<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @see: E.4.3 Video Tags, video_file_format_spec_v10_1.pdf, page 78</span></span><br><span class="line">    <span class="function"><span class="title">int8_t</span> frame_type = buffer-&gt;</span>read_1bytes();</span><br><span class="line">    SrsVideoCodecId codec_id = (SrsVideoCodecId)(frame_type &amp; <span class="number">0</span>x0f);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Support other codecs.</span></span><br><span class="line">    <span class="keyword">if</span> (codec_id != SrsVideoCodecIdAVC) &#123;</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!vcodec) &#123;</span><br><span class="line">        vcodec = new SrsVideoCodecConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!video) &#123;</span><br><span class="line">        video = new SrsVideoFrame();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">if</span> ((err = video-&gt;</span>initialize(vcodec)) != srs_success) &#123;</span><br><span class="line">        return srs_error_wrap(err, <span class="string">&quot;init video&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">buffer</span>-&gt;</span><span class="function"><span class="title">skip</span>(-1 * buffer-&gt;</span>pos());</span><br><span class="line">    return video_avc_demux(buffer, timestamp);</span><br><span class="line">&#125;</span><br><span class="line">srs_error_t SrsFormat::video_avc_demux(SrsBuffer* stream, int64_t timestamp)</span><br><span class="line">&#123;</span><br><span class="line">    srs_error_t err = srs_success;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @see: E.4.3 Video Tags, video_file_format_spec_v10_1.pdf, page 78</span></span><br><span class="line">    <span class="function"><span class="title">int8_t</span> frame_type = stream-&gt;</span>read_1bytes();</span><br><span class="line">    SrsVideoCodecId codec_id = (SrsVideoCodecId)(frame_type &amp; <span class="number">0</span>x0f);<span class="comment">//flvvideotagheader codecid: avc </span></span><br><span class="line">    frame_type = (frame_type &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0</span>x0f;<span class="comment">//frametype(UB[4]): avc  key frame or </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">video</span>-&gt;</span>frame_type = (SrsVideoAvcFrameType)frame_type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ignore info frame without error,</span></span><br><span class="line">    <span class="comment">// @see https://github.com/ossrs/srs/issues/288#issuecomment-69863909</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (video-&gt;</span>frame_type == SrsVideoAvcFrameTypeVideoInfoFrame) &#123;</span><br><span class="line">        srs_warn(<span class="string">&quot;avc igone the info frame&quot;</span>);</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// only support h.264/avc</span></span><br><span class="line">    <span class="keyword">if</span> (codec_id != SrsVideoCodecIdAVC) &#123;</span><br><span class="line">        return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;avc only support video h.264/avc, actual=%d&quot;</span>, codec_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">vcodec</span>-&gt;</span>id = codec_id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">if</span> (!stream-&gt;</span>require(<span class="number">4</span>)) &#123;</span><br><span class="line">        return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;avc decode avc_packet_type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">int8_t</span> avc_packet_type = stream-&gt;</span>read_1bytes();<span class="comment">//avc sequence header or avc nalu</span></span><br><span class="line">    <span class="function"><span class="title">int32_t</span> composition_time = stream-&gt;</span>read_3bytes();<span class="comment">//compostion time cts</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// pts = dts + cts.</span></span><br><span class="line">    <span class="function"><span class="title">video</span>-&gt;</span>dts = timestamp;</span><br><span class="line">    <span class="function"><span class="title">video</span>-&gt;</span>cts = composition_time;</span><br><span class="line">    <span class="function"><span class="title">video</span>-&gt;</span>avc_packet_type = (SrsVideoAvcFrameTrait)avc_packet_type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Update the RAW AVC data.</span></span><br><span class="line">    <span class="function"><span class="title">raw</span> = stream-&gt;</span><span class="function"><span class="title">data</span>() + stream-&gt;</span>pos();</span><br><span class="line">    <span class="function"><span class="title">nb_raw</span> = stream-&gt;</span><span class="function"><span class="title">size</span>() - stream-&gt;</span>pos();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (avc_packet_type == SrsVideoAvcFrameTraitSequenceHeader) &#123;<span class="comment">//如果是avc  头</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> <span class="doctag">FIXME:</span> Maybe we should ignore any error for parsing sps/pps.</span></span><br><span class="line">        <span class="keyword">if</span> ((err = avc_demux_sps_pps(stream)) != srs_success) &#123;<span class="comment">//提取sps pps，后面遇到idr时要用</span></span><br><span class="line">            return srs_error_wrap(err, <span class="string">&quot;demux SPS/PPS&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (avc_packet_type == SrsVideoAvcFrameTraitNALU)&#123;<span class="comment">//是nalu数据，</span></span><br><span class="line">        <span class="keyword">if</span> ((err = video_nalu_demux(stream)) != srs_success) &#123;</span><br><span class="line">            return srs_error_wrap(err, <span class="string">&quot;demux NALU&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ignored.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提取sps pps,以extradata方式来解析：</span></span><br><span class="line">srs_error_t SrsFormat::avc_demux_sps_pps(SrsBuffer* stream)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// AVCDecoderConfigurationRecord</span></span><br><span class="line">    <span class="comment">// 5.2.4.1.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 16</span></span><br><span class="line">    <span class="function"><span class="title">int</span> avc_extra_size = stream-&gt;</span><span class="function"><span class="title">size</span>() - stream-&gt;</span>pos();</span><br><span class="line">    <span class="keyword">if</span> (avc_extra_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">char</span> *copy_stream_from = stream-&gt;</span><span class="function"><span class="title">data</span>() + stream-&gt;</span>pos();</span><br><span class="line">        <span class="function"><span class="title">vcodec</span>-&gt;</span>avc_extra_data = std::vector&lt;char&gt;(copy_stream_from, copy_stream_from + avc_extra_size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">if</span> (!stream-&gt;</span>require(<span class="number">6</span>)) &#123;</span><br><span class="line">        return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;avc decode sequence header&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//int8_t configurationVersion = stream-&gt;read_1bytes();</span></span><br><span class="line">    <span class="function"><span class="title">uint8_t</span> confversion = stream-&gt;</span>read_1bytes();</span><br><span class="line">	<span class="keyword">if</span>(confversion == <span class="number">0</span>)<span class="comment">//avcc version == 1 ,annexb huya = 0 start code</span></span><br><span class="line">	&#123;</span><br><span class="line">	    annexb_demux_sps_pps(stream);  <span class="comment">//因为主播网是在avc header带两个nalu表示sps pps，所以这里加了代码；</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//int8_t AVCProfileIndication = stream-&gt;read_1bytes();</span></span><br><span class="line">    <span class="function"><span class="title">vcodec</span>-&gt;</span><span class="function"><span class="title">avc_profile</span> = (SrsAvcProfile)stream-&gt;</span>read_1bytes();</span><br><span class="line">    <span class="comment">//int8_t profile_compatibility = stream-&gt;read_1bytes();</span></span><br><span class="line">    <span class="function"><span class="title">stream</span>-&gt;</span>read_1bytes();</span><br><span class="line">    <span class="comment">//int8_t AVCLevelIndication = stream-&gt;read_1bytes();</span></span><br><span class="line">    <span class="function"><span class="title">vcodec</span>-&gt;</span><span class="function"><span class="title">avc_level</span> = (SrsAvcLevel)stream-&gt;</span>read_1bytes();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// parse the NALU size.</span></span><br><span class="line">    <span class="function"><span class="title">int8_t</span> lengthSizeMinusOne = stream-&gt;</span>read_1bytes();</span><br><span class="line">    lengthSizeMinusOne &amp;= <span class="number">0</span>x03;</span><br><span class="line">    <span class="function"><span class="title">vcodec</span>-&gt;</span>NAL_unit_length = lengthSizeMinusOne;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.3.4.2.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 16</span></span><br><span class="line">    <span class="comment">// 5.2.4.1 AVC decoder configuration record</span></span><br><span class="line">    <span class="comment">// 5.2.4.1.2 Semantics</span></span><br><span class="line">    <span class="comment">// The value of this field shall be one of 0, 1, or 3 corresponding to a</span></span><br><span class="line">    <span class="comment">// length encoded with 1, 2, or 4 bytes, respectively.</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (vcodec-&gt;</span>NAL_unit_length == <span class="number">2</span>) &#123;</span><br><span class="line">        return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;sps lengthSizeMinusOne should never be 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1 sps, 7.3.2.1 Sequence parameter set RBSP syntax</span></span><br><span class="line">    <span class="comment">// ISO_IEC_14496-10-AVC-2003.pdf, page 45.</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (!stream-&gt;</span>require(<span class="number">1</span>)) &#123;</span><br><span class="line">        return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;decode SPS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">int8_t</span> numOfSequenceParameterSets = stream-&gt;</span>read_1bytes();<span class="comment">//读取sps nalu数量，后5位</span></span><br><span class="line">    numOfSequenceParameterSets &amp;= <span class="number">0</span>x1f;</span><br><span class="line">    <span class="keyword">if</span> (numOfSequenceParameterSets != <span class="number">1</span>) &#123;<span class="comment">//只允许一个sps</span></span><br><span class="line">        return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;decode SPS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span> (!stream-&gt;</span>require(<span class="number">2</span>)) &#123;</span><br><span class="line">        return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;decode SPS size&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">uint16_t</span> sequenceParameterSetLength = stream-&gt;</span>read_2bytes();<span class="comment">//读取sps nalu长度</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (!stream-&gt;</span>require(sequenceParameterSetLength)) &#123;</span><br><span class="line">        return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;decode SPS data&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sequenceParameterSetLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">vcodec</span>-&gt;</span>sequenceParameterSetNALUnit.resize(sequenceParameterSetLength);<span class="comment">//将存放sps的数组设置长度</span></span><br><span class="line">        <span class="function"><span class="title">stream</span>-&gt;</span><span class="function"><span class="title">read_bytes</span>(&amp;vcodec-&gt;</span><span class="function"><span class="title">sequenceParameterSetNALUnit</span>[0], sequenceParameterSetLength);//将sps nalu长度的数据填充到vcodec-&gt;</span>se..结构中</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1 pps</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (!stream-&gt;</span>require(<span class="number">1</span>)) &#123;</span><br><span class="line">        return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;decode PPS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">int8_t</span> numOfPictureParameterSets = stream-&gt;</span>read_1bytes();<span class="comment">//读取pps数量</span></span><br><span class="line">    numOfPictureParameterSets &amp;= <span class="number">0</span>x1f;</span><br><span class="line">    <span class="keyword">if</span> (numOfPictureParameterSets != <span class="number">1</span>) &#123;<span class="comment">//只允许一个pps</span></span><br><span class="line">        return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;decode PPS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span> (!stream-&gt;</span>require(<span class="number">2</span>)) &#123;</span><br><span class="line">        return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;decode PPS size&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">uint16_t</span> pictureParameterSetLength = stream-&gt;</span>read_2bytes();<span class="comment">//读取pps nalu长度</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (!stream-&gt;</span>require(pictureParameterSetLength)) &#123;</span><br><span class="line">        return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;decode PPS data&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pictureParameterSetLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">vcodec</span>-&gt;</span>pictureParameterSetNALUnit.resize(pictureParameterSetLength);</span><br><span class="line">        <span class="function"><span class="title">stream</span>-&gt;</span><span class="function"><span class="title">read_bytes</span>(&amp;vcodec-&gt;</span>pictureParameterSetNALUnit[<span class="number">0</span>], pictureParameterSetLength);<span class="comment">//同样的填充</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return avc_demux_sps();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是对nalu的解析，分annexB和AVCC的：</span></span><br><span class="line">srs_error_t SrsFormat::video_nalu_demux(SrsBuffer* stream)</span><br><span class="line">&#123;</span><br><span class="line">    srs_error_t err = srs_success;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ensure the sequence header demuxed</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (!vcodec-&gt;</span>is_avc_codec_ok()) &#123;</span><br><span class="line">        srs_warn(<span class="string">&quot;avc ignore type=%d for no sequence header&quot;</span>, SrsVideoAvcFrameTraitNALU);</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// guess for the first time.</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (vcodec-&gt;</span>payload_format == SrsAvcPayloadFormatGuess) &#123;</span><br><span class="line">        <span class="comment">// One or more NALUs (Full frames are required)</span></span><br><span class="line">        <span class="comment">// try  &quot;AnnexB&quot; from ISO_IEC_14496-10-AVC-2003.pdf, page 211.</span></span><br><span class="line">        <span class="keyword">if</span> ((err = avc_demux_annexb_format(stream)) != srs_success) &#123;</span><br><span class="line">            <span class="comment">// stop try when system error.</span></span><br><span class="line">            <span class="keyword">if</span> (srs_error_code(err) != ERROR_HLS_AVC_TRY_OTHERS) &#123;</span><br><span class="line">                return srs_error_wrap(err, <span class="string">&quot;avc demux for annexb&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            srs_freep(err);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// try &quot;ISO Base Media File Format&quot; from ISO_IEC_14496-15-AVC-format-2012.pdf, page 20</span></span><br><span class="line">            <span class="keyword">if</span> ((err = avc_demux_ibmf_format(stream)) != srs_success) &#123;</span><br><span class="line">                return srs_error_wrap(err, <span class="string">&quot;avc demux ibmf&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">vcodec</span>-&gt;</span>payload_format = SrsAvcPayloadFormatIbmf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">vcodec</span>-&gt;</span>payload_format = SrsAvcPayloadFormatAnnexb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (vcodec-&gt;</span>payload_format == SrsAvcPayloadFormatIbmf) &#123;</span><br><span class="line">        <span class="comment">// try &quot;ISO Base Media File Format&quot; from ISO_IEC_14496-15-AVC-format-2012.pdf, page 20</span></span><br><span class="line">        <span class="keyword">if</span> ((err = avc_demux_ibmf_format(stream)) != srs_success) &#123;</span><br><span class="line">            return srs_error_wrap(err, <span class="string">&quot;avc demux ibmf&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// One or more NALUs (Full frames are required)</span></span><br><span class="line">        <span class="comment">// try  &quot;AnnexB&quot; from ISO_IEC_14496-10-AVC-2003.pdf, page 211.</span></span><br><span class="line">        <span class="keyword">if</span> ((err = avc_demux_annexb_format(stream)) != srs_success) &#123;</span><br><span class="line">            <span class="comment">// ok, we guess out the payload is annexb, but maybe changed to ibmf.</span></span><br><span class="line">            <span class="keyword">if</span> (srs_error_code(err) != ERROR_HLS_AVC_TRY_OTHERS) &#123;</span><br><span class="line">                return srs_error_wrap(err, <span class="string">&quot;avc demux annexb&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            srs_freep(err);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// try &quot;ISO Base Media File Format&quot; from ISO_IEC_14496-15-AVC-format-2012.pdf, page 20</span></span><br><span class="line">            <span class="keyword">if</span> ((err = avc_demux_ibmf_format(stream)) != srs_success) &#123;</span><br><span class="line">                return srs_error_wrap(err, <span class="string">&quot;avc demux ibmf&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">vcodec</span>-&gt;</span>payload_format = SrsAvcPayloadFormatIbmf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srs_error_t SrsFormat::avc_demux_annexb_format(SrsBuffer* stream)</span><br><span class="line">&#123;</span><br><span class="line">    srs_error_t err = srs_success;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// not annexb, try others</span></span><br><span class="line">    <span class="keyword">if</span> (!srs_avc_startswith_annexb(stream, NULL)) &#123;</span><br><span class="line">        return srs_error_new(ERROR_HLS_AVC_TRY_OTHERS, <span class="string">&quot;try others&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AnnexB</span></span><br><span class="line">    <span class="comment">// B.1.1 Byte stream NAL unit syntax,</span></span><br><span class="line">    <span class="comment">// ISO_IEC_14496-10-AVC-2003.pdf, page 211.</span></span><br><span class="line">    <span class="function"><span class="title">while</span> (!stream-&gt;</span>empty()) &#123;</span><br><span class="line">        <span class="comment">// find start code</span></span><br><span class="line">        int nb_start_code = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!srs_avc_startswith_annexb(stream, &amp;nb_start_code)) &#123;</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// skip the start code.</span></span><br><span class="line">        <span class="keyword">if</span> (nb_start_code &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="title">stream</span>-&gt;</span>skip(nb_start_code);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// the NALU start bytes.</span></span><br><span class="line">        <span class="function"><span class="title">char</span>* p = stream-&gt;</span><span class="function"><span class="title">data</span>() + stream-&gt;</span>pos();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get the last matched NALU</span></span><br><span class="line">        <span class="function"><span class="title">while</span> (!stream-&gt;</span>empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (srs_avc_startswith_annexb(stream, NULL)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="title">stream</span>-&gt;</span>skip(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">char</span>* pp = stream-&gt;</span><span class="function"><span class="title">data</span>() + stream-&gt;</span>pos();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// skip the empty.</span></span><br><span class="line">        <span class="keyword">if</span> (pp - p &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// got the NALU.</span></span><br><span class="line">        <span class="function"><span class="title">if</span> ((err = video-&gt;</span>add_sample(p, (int)(pp - p))) != srs_success) &#123;<span class="comment">//可能有多个nalu，这个区间可能包含多个</span></span><br><span class="line">            return srs_error_wrap(err, <span class="string">&quot;add video frame&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srs_error_t SrsFormat::avc_demux_ibmf_format(SrsBuffer* stream)</span><br><span class="line">&#123;</span><br><span class="line">    srs_error_t err = srs_success;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">int</span> PictureLength = stream-&gt;</span><span class="function"><span class="title">size</span>() - stream-&gt;</span>pos();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.3.4.2.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 16</span></span><br><span class="line">    <span class="comment">// 5.2.4.1 AVC decoder configuration record</span></span><br><span class="line">    <span class="comment">// 5.2.4.1.2 Semantics</span></span><br><span class="line">    <span class="comment">// The value of this field shall be one of 0, 1, or 3 corresponding to a</span></span><br><span class="line">    <span class="comment">// length encoded with 1, 2, or 4 bytes, respectively.</span></span><br><span class="line">    <span class="function"><span class="title">srs_assert</span>(vcodec-&gt;</span>NAL_unit_length != <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.3.4.2.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 20</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; PictureLength;) &#123;</span><br><span class="line">        <span class="comment">// unsigned int((NAL_unit_length+1)*8) NALUnitLength;</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (!stream-&gt;</span><span class="function"><span class="title">require</span>(vcodec-&gt;</span>NAL_unit_length + <span class="number">1</span>)) &#123;</span><br><span class="line">            return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;avc decode NALU size&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        int32_t NALUnitLength = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="title">if</span> (vcodec-&gt;</span>NAL_unit_length == <span class="number">3</span>) &#123;</span><br><span class="line">            NALU<span class="function"><span class="title">nitLength</span> = stream-&gt;</span>read_4bytes();</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (vcodec-&gt;</span>NAL_unit_length == <span class="number">1</span>) &#123;</span><br><span class="line">            NALU<span class="function"><span class="title">nitLength</span> = stream-&gt;</span>read_2bytes();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NALU<span class="function"><span class="title">nitLength</span> = stream-&gt;</span>read_1bytes();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// maybe stream is invalid format.</span></span><br><span class="line">        <span class="comment">// see: https://github.com/ossrs/srs/issues/183</span></span><br><span class="line">        <span class="keyword">if</span> (NALUnitLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;maybe stream is AnnexB format&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NALUnit</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (!stream-&gt;</span>require(NALUnitLength)) &#123;</span><br><span class="line">            return srs_error_new(ERROR_HLS_DECODE_ERROR, <span class="string">&quot;avc decode NALU data&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.3.1 NAL unit syntax, ISO_IEC_14496-10-AVC-2003.pdf, page 44.</span></span><br><span class="line">        <span class="function"><span class="title">if</span> ((err = video-&gt;</span><span class="function"><span class="title">add_sample</span>(stream-&gt;</span><span class="function"><span class="title">data</span>() + stream-&gt;</span>pos(), NALUnitLength)) != srs_success) &#123;</span><br><span class="line">            return srs_error_wrap(err, <span class="string">&quot;avc add video frame&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">stream</span>-&gt;</span>skip(NALUnitLength);</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">i</span> += vcodec-&gt;</span>NAL_unit_length + <span class="number">1</span> + NALUnitLength;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="其他debug"><a href="#其他debug" class="headerlink" title="其他debug:"></a>其他debug:</h5><p>1  可能是视频头和视频数据不匹配<br>2  出现一例： pts和dts对不上，导致将帧丢弃所以花<br>3 绿屏问题：一般是头错了，比如sps,pps错误导致解析不出来视频，全部都是0，绿色</p>
</li>
</ul>
<p>ref：T-REC-H.264.pdf</p>
]]></content>
      <categories>
        <category>video</category>
      </categories>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_type</title>
    <url>/2021/04/04/cpp-type/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>c++数据类型：</p>
<h3 id="数据类型概览"><a href="#数据类型概览" class="headerlink" title="数据类型概览"></a>数据类型概览</h3><ol>
<li>类型无处不在，注意表达式也有类型，一些语句本身也是某个类型的值，以下这些都有类型属性<br> 对象的类型和基本类型<br> 引用的类型<br> 函数的类型(返回值类型)<br> 函数模板特化<br> 表达式的值类型<span id="more"></span></li>
<li>类型如何分类以及复合类型<br> 内建类型：<br> void,<br> nullptr_t(c++),<br> arithmetic 类型(整数数值)<br> 浮点数<br> 整数：<br>bool<br>字符<br>有符号整数<br>无符号整数<br> 复合类型：引用，指针，类的成员指针，数组，函数，枚举，类类型  </li>
<li>关于类型的命名，类型在使用时，并不是严格的按照既定名称来的，比如vector<int> 也可以作为一个类型来使用（c++)<br> eg:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p;               <span class="comment">// declaration of a pointer to int</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(p); <span class="comment">// type-id is &quot;int*&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>];   <span class="comment">// declaration of an array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]; <span class="comment">// type-id is &quot;int[3]&quot; (called new-type-id)</span></span><br></pre></td></tr></table></figure></li>
<li>静态类型： 编译期确定，运行时无法改变； 动态类型：运行时动态指定，比如多态（c++）；</li>
<li>未完成的类型，一些本身就是未完成的类型如void，还有是类类型中没有定义所有的函数(c++)；</li>
</ol>
<h3 id="类型的分类："><a href="#类型的分类：" class="headerlink" title="类型的分类："></a>类型的分类：</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><h5 id="void"><a href="#void" class="headerlink" title="void:"></a>void:</h5><ul>
<li><ol>
<li>概念简介：void类型不能定义变量，因为是一种未完成的类型；同样不能定义数组，引用，但是可以定义void 指针以及函数返回类型也可以是void *；</li>
</ol>
</li>
<li><ol start="2">
<li>用法注意：<br>A: void 可以是指针类型，可以将void *类型的指针转换为任意类型的指针；<br>B: 既然void可以定义指针类型，也就说明这个指针是任意类型的指针，在内存中分配了8字节&#x2F;4字节的地址，但是没有指定类型，也就是说其可以访问的内存范围无法确定，也就是说不能对void指针做取值操作如void *a; *a&#x3D;3;&#x2F;printf(<em>a);<br>void</em> 类型只能在转型后才能访问指向的内存地址；  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">void</span> *a;</span><br><span class="line">        a=<span class="number">3</span>;<span class="comment">//这里对a赋值没问题</span></span><br><span class="line">        <span class="type">int</span> *b=<span class="number">0</span>;</span><br><span class="line">        a=b;<span class="comment">//这里是可以的；这样将a赋值为int 类型的</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> c=<span class="number">32</span>;</span><br><span class="line">        b=&amp;c;</span><br><span class="line">        a=b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//访问a就不需要转型，毕竟指针都是固</span></span><br><span class="line">定字节的；</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(<span class="type">int</span>*)a);<span class="comment">//访问*a就需要转型，即使前面</span></span><br><span class="line">赋值也没用；</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*b=3;</span></span><br><span class="line"><span class="comment">       *b=32;</span></span><br><span class="line"><span class="comment">       printf(&quot;%d\n&quot;,*b);</span></span><br><span class="line"><span class="comment">       */</span><span class="comment">//这么用回出现段错误</span></span><br><span class="line">        a = (<span class="type">char</span>*)a;</span><br><span class="line">        <span class="type">char</span> *p=<span class="string">&quot;aaaaa&quot;</span>;</span><br><span class="line">        a=p;</span><br><span class="line">        a=(<span class="type">void</span>*)a;</span><br><span class="line">        <span class="comment">//printf(&quot;%c&quot;,*a);//这里就不行，因为*操作不知道拿多</span></span><br><span class="line">少内存</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a);<span class="comment">//这种方式倒是可以成功输出,因为不是对void *做取值，而是取其指针值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>3)函数返回值void *意味着它可以接受任何类型的返回指针类型；毕竟只是返回一个指针值；</li>
<li>4)一些库函数，参数是void* 的，意味着可以不受限制传入任意的指定类型，但是实际上内部实现是需要做类型转换的，比如转为char* 除非只是对指针做透传；</li>
</ul>
<h5 id="nullptr-t"><a href="#nullptr-t" class="headerlink" title="nullptr_t"></a>nullptr_t</h5><p>std::nullptr_t (c++11)<br>Defined in header <cstddef><br>typedef decltype(nullptr) nullptr_t;<br>nullptr_t是空指针字面量nullptr的类型。它是一种特别的类型，本身不是指针类型或指向成员类型的指针。<br>nullptr_t is available in the global namespace when &lt;stddef.h&gt; is included, even if it is not a part of C.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Pointer to integer overload\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Pointer to double overload\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::<span class="type">nullptr_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;null pointer overload\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* pi &#123;&#125;; <span class="type">double</span>* pd &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">f</span>(pi);</span><br><span class="line">    <span class="built_in">f</span>(pd);</span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// would be ambiguous without void f(nullptr_t)</span></span><br><span class="line">    <span class="comment">// f(0);    // ambiguous call: all three functions are candidates</span></span><br><span class="line">    <span class="comment">// f(NULL); // ambiguous if NULL is an integral null pointer constant </span></span><br><span class="line">                <span class="comment">// (as is the case in most implementations)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数学类型：数值："><a href="#数学类型：数值：" class="headerlink" title="数学类型：数值："></a>数学类型：数值：</h4><h5 id="bool布尔类型："><a href="#bool布尔类型：" class="headerlink" title="bool布尔类型："></a>bool布尔类型：</h5><p>布尔类型只有两个值，true和false;<br>实际例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> bbo = (<span class="type">bool</span>)<span class="literal">true</span>;</span><br><span class="line">cout&lt;&lt; bbo &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> testnum = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; (<span class="type">bool</span>)testnum &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line"><span class="type">bool</span> tt = testnum;</span><br><span class="line">cout&lt;&lt; tt &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> tye = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; boolalpha &lt;&lt; tye &lt;&lt; endl;<span class="comment">//true   //noboolalpha 按数值打印 </span></span><br></pre></td></tr></table></figure>
<h5 id="字符类型-char-系列：char-signed-char-unsigned-char"><a href="#字符类型-char-系列：char-signed-char-unsigned-char" class="headerlink" title="字符类型:char 系列：char *,signed char,unsigned char"></a>字符类型:char 系列：char *,signed char,unsigned char</h5><ul>
<li><ol>
<li>char:char是八位一个字节的类型，<br>本身赋值可以容纳任何的八位二进制而不管符号；<br>但是输出时则对应输出ASCII码，当不匹配任何ASCII码时，则输出乱码；<br>内存中的值：8位值；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//实际存放的值，在小于等于2的八次方 255(全1）时，按补码方式存放，即正数时为原码，负数时为除符号位外取反加1；</span></span><br><span class="line">    <span class="type">char</span> a=<span class="number">-43</span>;<span class="comment">//实际存放：</span></span><br><span class="line">    <span class="type">char</span> b=<span class="number">0</span>;<span class="comment">//实际存放：00000000</span></span><br><span class="line">    <span class="type">char</span> c=<span class="number">0b11111111</span>;<span class="comment">//11111111//255</span></span><br><span class="line">    <span class="type">char</span> d=<span class="number">127</span>;<span class="comment">//0111 1111</span></span><br><span class="line">    <span class="type">char</span> e=<span class="number">0b10000000</span>;<span class="comment">//1000 0000//128</span></span><br><span class="line">    <span class="type">char</span> f=<span class="number">-128</span>;<span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n%c\n%c\n%c\n%c\n%c\n&quot;</span>,a,b,c,d,e,f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">//读取的时候，则按补码方式读，即如10000000，则判断符号位</span></span><br><span class="line"><span class="number">1</span>，则为负数，再取反加<span class="number">1</span>则为<span class="number">-128</span>；</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n%d\n%d\n%d\n%d\n&quot;</span>,a,b,c,d,e,f);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">-43</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">-128</span></span><br><span class="line"><span class="number">-128</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>signed和unsigned关键字含义：</p>
</li>
</ul>
<ol start="2">
<li>signed char:其实内部存储和读取同char,可用于表示单字节有符号数；</li>
<li>unsigned char:即存储时还是按照补码存储，但是读取时是原码无符号取；所以存负数时，读取为正数；可用于存储单字节的无符号数；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ua=<span class="number">-21</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ub=<span class="number">23</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc =<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ud = <span class="number">255</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ue = <span class="number">127</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uf = <span class="number">128</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n%d\n%d\n%d\n%d\n&quot;</span>,ua,ub,uc,ud,ue,uf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    输出：</span><br><span class="line">       <span class="number">235</span> (存补码：<span class="number">-23</span>-&gt;(<span class="number">1001</span> <span class="number">0101</span>-&gt;<span class="number">1110</span> <span class="number">1011</span>)-&gt;读出时按无符号：<span class="number">11101011</span>==<span class="number">235</span>）</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">255</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">128</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><ol start="4">
<li>char *:char指针若是初始化为字符串，则这个字符串是存放在常量数据区，不是在栈区，所以不能够改动，但是可以改动指针的值；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p =<span class="string">&quot;ddd&quot;</span>;</span><br><span class="line">*(p+<span class="number">1</span>)=<span class="string">&#x27;3&#x27;</span>;编译报错；</span><br><span class="line">      <span class="type">char</span> *p = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">      <span class="type">char</span> *p2 = p;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p2);</span><br><span class="line">      <span class="type">char</span> p3[]=<span class="string">&quot;dddd&quot;</span>;</span><br><span class="line">      p=p3;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p3);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>5）关于c++的 宽char类型： char16_t char32_t w_char</li>
</ul>
<h5 id="整数类型-short-int-long-等"><a href="#整数类型-short-int-long-等" class="headerlink" title="整数类型:short ,int ,long ,等"></a>整数类型:short ,int ,long ,等</h5><ul>
<li>short(short int)，short和short int是一样的类型，size也一样</li>
<li>short,int，long，long long 默认是有符号的，若想更清晰的使用，可以带unsigned这种；<br>不同的位数系统下，整数类型的size也不相同，有如下系统情况：<br>32 bit systems:<br>LP32 or 2&#x2F;4&#x2F;4 (int is 16-bit, long and pointer are 32-bit)<br>Win16 API<br>ILP32 or 4&#x2F;4&#x2F;4 (int, long, and pointer are 32-bit);<br>Win32 API<br>Unix and Unix-like systems (Linux, macOS)</li>
</ul>
<p>64 bit systems:<br>LLP64 or 4&#x2F;4&#x2F;8 (int and long are 32-bit, pointer is 64-bit)<br>Win64 API<br>LP64 or 4&#x2F;8&#x2F;8 (int is 32-bit, long and pointer are 64-bit)<br>Unix and Unix-like systems (Linux, macOS)  </p>
<p>Other models are very rare. For example, ILP64 (8&#x2F;8&#x2F;8: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. UNICOS on Cray).</p>
<img src="/2021/04/04/cpp-type/typeint.png" class="" title="type">

<h5 id="浮点数类型：float-double"><a href="#浮点数类型：float-double" class="headerlink" title="浮点数类型：float,double"></a>浮点数类型：float,double</h5><ul>
<li>float: 单精度浮点数</li>
<li>double :双精度浮点数</li>
<li>long double: 扩展精度的浮点数类型；<br>浮点数的一些特性：</li>
</ul>
<ol>
<li>正数负数的无穷数  </li>
<li>负0.0  </li>
<li>NaN not a number<br>数值范围表参考：</li>
</ol>
<img src="/2021/04/04/cpp-type/type1.png" class="" title="type">
<h4 id="复合类型："><a href="#复合类型：" class="headerlink" title="复合类型："></a>复合类型：</h4><h5 id="引用类型：一个已存在的对象或函数的别名"><a href="#引用类型：一个已存在的对象或函数的别名" class="headerlink" title="引用类型：一个已存在的对象或函数的别名"></a>引用类型：一个已存在的对象或函数的别名</h5><ul>
<li>初始化：一个引用要求被一个有效的对象或函数初始化；<br>引用的存储：引用不是对象，所以没必要性占用存储，尽管编译器在必要时可以分配存储空间来实现所需的语义(例如，引用类型的非静态数据成员通常会增加类的大小，以满足存储内存地址的需要)。<br>哪些没有引用：因为引用不是对象，所以没有void的引用，也没有引用的引用，没有指向引用的指针，也没有引用的数组；  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&amp; a[<span class="number">3</span>]; <span class="comment">// error</span></span><br><span class="line"><span class="type">int</span>&amp;* p;   <span class="comment">// error</span></span><br><span class="line"><span class="type">int</span>&amp; &amp;r;   <span class="comment">// error</span></span><br><span class="line">这些全错；</span><br></pre></td></tr></table></figure></li>
</ul>
<p>引用类型不能在最高级别上符合cv要求;在声明中没有这方面的语法，如果将限定符添加到typedef-name或decltype说明符或类型模板参数中，则会忽略它</p>
<ul>
<li><p>引用折叠(缩写)<br>允许通过模板或typedefs中的类型操作形成对引用的引用，这种情况下引用折叠规则适用:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp;  lref;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp;&amp; rref;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">lref&amp;  r1 = n; <span class="comment">// type of r1 is int&amp;</span></span><br><span class="line">lref&amp;&amp; r2 = n; <span class="comment">// type of r2 is int&amp;</span></span><br><span class="line">rref&amp;  r3 = n; <span class="comment">// type of r3 is int&amp;</span></span><br><span class="line">rref&amp;&amp; r4 = <span class="number">1</span>; <span class="comment">// type of r4 is int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>这一点，以及在函数模板中使用T&amp;&amp;时用于模板实参推导的特殊规则，形成了使std::forward成为可能的规则</p>
</li>
<li><p>左引用<br>1） 左引用可以使用在一个已存在的对象，可选不同的cv限定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;Ex&quot;</span>;</span><br><span class="line">    std::string&amp; r1 = s;</span><br><span class="line">    <span class="type">const</span> std::string&amp; r2 = s;</span><br><span class="line"> </span><br><span class="line">    r1 += <span class="string">&quot;ample&quot;</span>;           <span class="comment">// modifies s</span></span><br><span class="line"><span class="comment">//  r2 += &quot;!&quot;;               // error: cannot modify through reference to const</span></span><br><span class="line">    std::cout &lt;&lt; r2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints s, which now holds &quot;Example&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>2）它也可以使用在函数参数上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">double_string</span><span class="params">(std::string&amp; s)</span> </span>&#123;</span><br><span class="line">    s += s; <span class="comment">// &#x27;s&#x27; is the same object as main()&#x27;s &#x27;str&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">    <span class="built_in">double_string</span>(str);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）当函数的返回值是左引用时，则函数调用表达式也可以成为表达式的左值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">char_number</span><span class="params">(std::string&amp; s, std::<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">at</span>(n); <span class="comment">// string::at() returns a reference to char</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">    <span class="built_in">char_number</span>(str, <span class="number">1</span>) = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// the function call is lvalue, can be assigned to</span></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果： Tast</span></span><br></pre></td></tr></table></figure>
<ul>
<li>右引用</li>
</ul>
<ol>
<li>右值引用是用来扩展临时对象的生命周期的；而const类型的左值引用也可以扩展临时对象的声明周期，但是不能被改变；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s1 = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line"><span class="comment">//  std::string&amp;&amp; r1 = s1;           // error: can&#x27;t bind to lvalue</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> std::string&amp; r2 = s1 + s1; <span class="comment">// okay: lvalue reference to const extends lifetime</span></span><br><span class="line"><span class="comment">//  r2 += &quot;Test&quot;;                    // error: can&#x27;t modify through reference to const</span></span><br><span class="line"> </span><br><span class="line">    std::string&amp;&amp; r3 = s1 + s1;      <span class="comment">// okay: rvalue reference extends lifetime</span></span><br><span class="line">    r3 += <span class="string">&quot;Test&quot;</span>;                    <span class="comment">// okay: can modify through reference to non-const</span></span><br><span class="line">    std::cout &lt;&lt; r3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2)更重要的是，当一个函数同时具有右值引用和左值引用时，右值引用重载绑定到右值(包括prvalues和xvalues)，而左值引用重载绑定到左值:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue reference overload f(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue reference to const overload f(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue reference overload f(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">f</span>(i);  <span class="comment">// calls f(int&amp;)</span></span><br><span class="line">    <span class="built_in">f</span>(ci); <span class="comment">// calls f(const int&amp;)</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">3</span>);  <span class="comment">// calls f(int&amp;&amp;)</span></span><br><span class="line">           <span class="comment">// would call f(const int&amp;) if f(int&amp;&amp;) overload wasn&#x27;t provided</span></span><br><span class="line">    <span class="built_in">f</span>(std::<span class="built_in">move</span>(i)); <span class="comment">// calls f(int&amp;&amp;)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// rvalue reference variables are lvalues when used in expressions</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">f</span>(x);            <span class="comment">// calls f(int&amp; x)</span></span><br><span class="line">    <span class="built_in">f</span>(std::<span class="built_in">move</span>(x)); <span class="comment">// calls f(int&amp;&amp; x)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）这允许在合适的时候自动选择移动构造函数、移动赋值操作符和其他支持移动的函数(例如std::vector::push_back())。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(std::move(v))</span></span>; <span class="comment">// binds an rvalue reference to v</span></span><br><span class="line"><span class="built_in">assert</span>(v.<span class="built_in">empty</span>());</span><br></pre></td></tr></table></figure>
<ul>
<li>fowarding references<br>转发引用是一种特殊类型的引用，它保留了函数参数的值类别，使得可以通过std::forward转发它。转发引用可以是:</li>
</ul>
<p>1)函数模板的函数形参声明为对同一函数模板cv- qualified类型的右值引用:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(T&amp;&amp; x)</span> </span>&#123;                    <span class="comment">// x is a forwarding reference</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(std::forward&lt;T&gt;(x)); <span class="comment">// and so can be forwarded</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">f</span>(i); <span class="comment">// argument is lvalue, calls f&lt;int&amp;&gt;(int&amp;), std::forward&lt;int&amp;&gt;(x) is lvalue</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>); <span class="comment">// argument is rvalue, calls f&lt;int&gt;(int&amp;&amp;), std::forward&lt;int&gt;(x) is rvalue</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">const</span> T&amp;&amp; x)</span></span>; <span class="comment">// x is not a forwarding reference: const T is not cv-unqualified</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">A</span><span class="params">(T&amp;&amp; x, U&amp;&amp; y, <span class="type">int</span>* p)</span></span>; <span class="comment">// x is not a forwarding reference: T is not a</span></span><br><span class="line">                             <span class="comment">// type template parameter of the constructor,</span></span><br><span class="line">                             <span class="comment">// but y is a forwarding reference</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)<span class="keyword">auto</span>&amp;&amp; except when deduced from a brace-enclosed initializer list:</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; vec = <span class="built_in">foo</span>();       <span class="comment">// foo() may be lvalue or rvalue, vec is a forwarding reference</span></span><br><span class="line"><span class="keyword">auto</span> i = std::<span class="built_in">begin</span>(vec); <span class="comment">// works either way</span></span><br><span class="line">(*i)++;                   <span class="comment">// works either way</span></span><br><span class="line"><span class="built_in">g</span>(std::forward&lt;<span class="keyword">decltype</span>(vec)&gt;(vec)); <span class="comment">// forwards, preserving value category</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; x: <span class="built_in">f</span>()) &#123;</span><br><span class="line">  <span class="comment">// x is a forwarding reference; this is the safest way to use range for loops</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; z = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// *not* a forwarding reference (special case for initializer lists)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Dangling references 悬挂引用：<br>尽管引用一旦初始化，总是引用有效的对象或函数，但是可以创建一个被引用对象的生命周期结束但引用仍可访问的程序(悬空)。访问这样的引用是未定义的行为。一个常见的例子是函数返回对自动变量(局部)的引用:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;Example&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s; <span class="comment">// exits the scope of s:</span></span><br><span class="line">              <span class="comment">// its destructor is called and its storage deallocated</span></span><br><span class="line">&#125;</span><br><span class="line">std::string&amp; r = <span class="built_in">f</span>(); <span class="comment">// dangling reference</span></span><br><span class="line">std::cout &lt;&lt; r;       <span class="comment">// undefined behavior: reads from a dangling reference</span></span><br><span class="line">std::string s = <span class="built_in">f</span>();  <span class="comment">// undefined behavior: copy-initializes from a dangling reference</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="指针类型-32位操作系统为4字节，64位操作系统为8字节"><a href="#指针类型-32位操作系统为4字节，64位操作系统为8字节" class="headerlink" title="指针类型:32位操作系统为4字节，64位操作系统为8字节"></a>指针类型:32位操作系统为4字节，64位操作系统为8字节</h5><p>注意指针也是一个变量，那么也可以传值和返回值；<br>一个指针的值：指向对象或函数，或一个对象的结尾(即对象位置的下一个位置) ,或空指针，或一个无效指针；<br>对多字节的类型，指向它的指针，是指向它的第一个字节，即第一个字节的位置；而指向一个对象的结尾，是指指向这个对象结尾后的第一个字节；<br>Note that two pointers that represent the same address may nonetheless have different values.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span></span><br><span class="line">  <span class="number">6</span> &#123;</span><br><span class="line">  <span class="number">7</span>     <span class="type">int</span> x,y;</span><br><span class="line">  <span class="number">8</span> &#125; c;</span><br><span class="line">  <span class="number">9</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 10 </span>&#123;</span><br><span class="line"> <span class="number">11</span>     <span class="type">int</span> *px = &amp;c.x;</span><br><span class="line"> <span class="number">12</span>     <span class="type">int</span> *pxe = px+<span class="number">1</span>;</span><br><span class="line"> <span class="number">13</span>     <span class="type">int</span> *py = &amp;c.y;</span><br><span class="line"> <span class="number">14</span>     <span class="built_in">assert</span>(pxe == py);</span><br><span class="line"> <span class="number">15</span>     *pxe = <span class="number">1</span>;<span class="comment">//// undefined behavior even if the assertion does not fire 最好不要这么操作；</span></span><br><span class="line"> <span class="number">16</span>     cout&lt;&lt; *pxe&lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line"> <span class="number">17</span>     cout &lt;&lt; c.y &lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line"> <span class="number">18</span>     cout &lt;&lt; c.x &lt;&lt; endl;<span class="comment">//0</span></span><br><span class="line"> <span class="number">19</span>     cout &lt;&lt; *(px+<span class="number">1</span>) &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line"> <span class="number">20</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">21</span> &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><ol>
<li>指向普通对象的类型 ，和指针的引用：<br>(1) 语法: S* D;<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span>* np = &amp;n; <span class="comment">// pointer to int</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span>* npp = &amp;np; <span class="comment">// non-const pointer to const pointer to non-const int</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">int</span> (*ap)[<span class="number">2</span>] = &amp;a; <span class="comment">// pointer to array of int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123; <span class="type">int</span> n; &#125;;</span><br><span class="line">S s = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span>* sp = &amp;s.n; <span class="comment">// pointer to the int that is a member of s</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span>* p = &amp;n;     <span class="comment">// pointer to n</span></span><br><span class="line"><span class="type">int</span>&amp; r = *p;     <span class="comment">// reference is bound to the lvalue expression that identifies n ，注意这里是p指向的值的引用</span></span><br><span class="line">r = <span class="number">7</span>;           <span class="comment">// stores the int 7 in n</span></span><br><span class="line">std::cout &lt;&lt; *p; <span class="comment">// lvalue-to-rvalue implicit conversion reads the value from n 输出为7</span></span><br></pre></td></tr></table></figure>
(2) 指针的引用: int n;int *p &#x3D; &amp;n;int *&amp;r &#x3D; p; <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="type">int</span> m_value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = &amp;m_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以根据你的需求分配内存</span></span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *p = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;n;</span><br><span class="line">    <span class="type">int</span> *&amp;r = p;</span><br><span class="line">    r=<span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    std::cout&lt;&lt; *p &lt;&lt; endl;<span class="comment">//0 </span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> *pn = &amp;n;</span><br><span class="line">    cout &lt;&lt; *pn &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(pn);</span><br><span class="line">    cout &lt;&lt; *pn &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p>(3) 一些说明：<br>指向数组的第一个成员的指针可以是用数组初始化，含隐式转换；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span>* p1 = a; <span class="comment">// pointer to the first element a[0] (an int) of the array a</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> b[<span class="number">6</span>][<span class="number">3</span>][<span class="number">8</span>];</span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">3</span>][<span class="number">8</span>] = b; <span class="comment">// pointer to the first element b[0] of the array b,</span></span><br><span class="line">                     <span class="comment">// which is an array of 3 arrays of 8 ints</span></span><br><span class="line">同样的，基类和派生类也是：支持多态</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Derived d;</span><br><span class="line">Base* p = &amp;d;</span><br></pre></td></tr></table></figure>

<p>(4) 指向void的指针：<br>指向任何类型对象的指针都可以隐式转换为指向void的指针(可选cv限定);指针值没有改变。反向转换需要static_cast或显式类型转换，会产生原始指针值:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* p1 = &amp;n;</span><br><span class="line"><span class="type">void</span>* pv = p1;</span><br><span class="line"><span class="type">int</span>* p2 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(pv);</span><br><span class="line">std::cout &lt;&lt; *p2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints 1</span></span><br></pre></td></tr></table></figure>
<p>如果原始指针指向某个多态类型对象中的基类子对象，dynamic_cast可用于获得指向派生类型的完整对象的void<em>。<br>指向void的指针用于传递未知类型的对象，这在C接口中很常见:pthread_create期望用户提供的回调函数接受并返回void</em>。在所有情况下，调用者都有责任在使用之前将指针转换为正确的类型。</p>
<ul>
<li><ol start="2">
<li>指向函数的类型:<br>(1) 函数指针可以用非成员函数或静态成员函数的地址进行初始化。由于函数到指针的隐式转换，寻址操作符是可选的:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*p1)(<span class="type">int</span>) = &amp;f;</span><br><span class="line"><span class="built_in">void</span> (*p2)(<span class="type">int</span>) = f; <span class="comment">// same as &amp;f</span></span><br></pre></td></tr></table></figure>
不像函数和函数的引用，函数指针是对象，因此可以进行拷贝，存储在数组和分配等</li>
</ol>
</li>
</ul>
<p>(2)函数指针的一些例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Syntax	meaning</span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(* f)</span><span class="params">()</span>	f is a pointer to a function with prototype <span class="type">int</span> <span class="title">func</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(* f())</span><span class="params">()</span>	f is a function taking no inputs <span class="keyword">and</span> returning a pointer to a function with prototype <span class="type">int</span> <span class="title">func</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function"><span class="type">int</span> * <span class="title">f</span><span class="params">()</span>	f is a function returning a pointer-to-<span class="type">int</span>.</span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(* a[])</span><span class="params">()</span>	a is an array of pointers to functions each with prototype <span class="type">int</span> <span class="title">func</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(* f())</span>[]	f is a function returning a pointer to an array.</span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(f[])</span><span class="params">()</span>	Not allowed. Can&#x27;t have an array of functions.</span></span><br><span class="line"><span class="function"><span class="type">int</span> * <span class="type">const</span> *<span class="params">(*g)</span><span class="params">(<span class="type">float</span>)</span>	g is pointer to a function with prototype <span class="type">int</span> * <span class="type">const</span> * <span class="title">func</span><span class="params">(<span class="type">float</span>)</span> where its <span class="keyword">return</span> value <span class="type">int</span> * <span class="type">const</span> * is a pointer to a read-only pointer-to-<span class="type">int</span>.</span></span><br></pre></td></tr></table></figure>
<p>(3)模板和函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">f</span><span class="params">(T n)</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> n)</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">int</span>) = f; <span class="comment">// instantiates and selects f&lt;int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>指向类成员变量的类型<br>(1) 指向非静态成员对象m的指针是C类的成员，可以用表达式&amp;C::m进行初始化。像&amp;(C::m)或&amp;m这样的表达式在C的成员函数中不构成指向成员的指针。<br>这样的指针可以用作指针到成员访问操作符的右操作数。*操作符- &gt; *:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">语法：S C::* D; <span class="comment">//C是类类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="comment">//or struct ,same</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">    &#125; ;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> C::* p= &amp;C::m;<span class="comment">//按照对指针的理解，初看下，是指p是int C::m 这种类型的指针，但是在使用时需要赋值</span></span><br><span class="line">        C c = &#123;<span class="number">7</span>&#125;;</span><br><span class="line">        std::cout &lt;&lt; c.*p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//但是实际上不是，因为可以直接输出，而且可以用c.的形式，说明是它的成员；</span></span><br><span class="line">    </span><br><span class="line">        C b = &#123;<span class="number">9</span>&#125;;</span><br><span class="line">        std::cout&lt;&lt; b.*p &lt;&lt; endl;<span class="comment">//而不同对象输出不同，说明这个指针是对象持有</span></span><br><span class="line">    </span><br><span class="line">        C* cp = &amp;c;</span><br><span class="line">        cp-&gt;m= <span class="number">10</span> ;</span><br><span class="line">        std::cout &lt;&lt;cp-&gt;*p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">       <span class="comment">// std::cout &lt;&lt;sizeof(struct C) &lt;&lt; endl;//4 not include *p</span></span><br><span class="line">        std::cout &lt;&lt;<span class="built_in">sizeof</span>(c) &lt;&lt; endl;<span class="comment">//4 not include *p ,size的时候，还是4，说明这里的形式可能不是简单的塞在结构里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p>(2)指向可访问的无二义性非虚基类数据成员的指针可以隐式转换为指向派生类相同数据成员的指针:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">struct</span> <span class="title class_">Base</span> &#123; <span class="type">int</span> m; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Base::* bp = &amp;Base::m;<span class="comment">//先定义一个指向Base::m的指针，这个作为了Base的&quot;成员&quot;</span></span><br><span class="line">    <span class="type">int</span> Derived::* dp = bp;<span class="comment">//赋值后，Derived的&quot;成员&quot;指针，也指向了bp,Base::m</span></span><br><span class="line">    Derived d;</span><br><span class="line">    d.m = <span class="number">1</span>;<span class="comment">//对m赋值后</span></span><br><span class="line">    std::cout &lt;&lt; d.*dp &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d.*bp &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints 1 1 ,取出的两个都是实际值是m</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)在相反的方向转化,从一个指向派生类的数据成员指针明确非虚拟基类的数据成员,允许static_cast和显式类型转换,即使基类没有成员(但最终派生类,当指针用于访问):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123; <span class="type">int</span> m; &#125;;<span class="comment">//派生类有这个成员，但是基类没有</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Derived::* dp = &amp;Derived::m; <span class="comment">//派生类的指针</span></span><br><span class="line">    <span class="type">int</span> Base::* bp = <span class="built_in">static_cast</span>&lt;<span class="type">int</span> Base::*&gt;(dp);<span class="comment">//基类上要动态转换，但是即使这样</span></span><br><span class="line"> </span><br><span class="line">    Derived d;</span><br><span class="line">    d.m = <span class="number">7</span>;</span><br><span class="line">    std::cout &lt;&lt; d.*bp &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// okay: prints 7</span></span><br><span class="line"> </span><br><span class="line">    Base b;</span><br><span class="line">    std::cout &lt;&lt; b.*bp &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// undefined behavior，也无法访问到派生类&quot;成员指针&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4)指向成员的指针类型可以是指向成员的指针本身:指向成员的指针可以是多级的，在每一级都可以有不同的cv限定。也允许指针和指针到成员的混合多层次组合: 这代码看着贼恶心了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="comment">// const pointer to non-const member</span></span><br><span class="line">    <span class="type">int</span> A::* <span class="type">const</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// non-const pointer to data member which is a const pointer to non-const member</span></span><br><span class="line">    <span class="type">int</span> A::* <span class="type">const</span> A::* p1 = &amp;A::p;</span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> A a = &#123;<span class="number">1</span>, &amp;A::m&#125;;</span><br><span class="line">    std::cout &lt;&lt; a.*(a.*p1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints 1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// regular non-const pointer to a const pointer-to-member</span></span><br><span class="line">    <span class="type">int</span> A::* <span class="type">const</span>* p2 = &amp;a.p;</span><br><span class="line">    std::cout &lt;&lt; a.**p2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="4">
<li>指向类成员函数的类型：<br>指向非静态成员函数f的指针是类C的成员，可以完全用表达式&amp;C::f进行初始化。C成员函数中的&amp;(C::f)或&amp;f这样的表达式不构成指向成员函数的指针。<br>这样的指针可以用作指针到成员访问操作符的右操作数。- &gt; *和. *。结果表达式只能用作函数调用操作符的左操作数:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (C::* p)(<span class="type">int</span>) = &amp;C::f; <span class="comment">// pointer to member function f of class C</span></span><br><span class="line">    C c;</span><br><span class="line">    (c.*p)(<span class="number">1</span>);                  <span class="comment">// prints 1</span></span><br><span class="line">    C* cp = &amp;c;</span><br><span class="line">    (cp-&gt;*p)(<span class="number">2</span>);                <span class="comment">// prints 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
指向基类成员函数的指针可以隐式转换为指向派生类相同成员函数的指针:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (Base::* bp)(<span class="type">int</span>) = &amp;Base::f;</span><br><span class="line">    <span class="built_in">void</span> (Derived::* dp)(<span class="type">int</span>) = bp;</span><br><span class="line">    Derived d;</span><br><span class="line">    (d.*dp)(<span class="number">1</span>);</span><br><span class="line">    (d.*bp)(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在相反的方向转化,从一个指向派生类的成员函数指针明确非虚拟基类的成员函数,允许static_cast和显式类型转换,即使基类没有成员函数(但最终派生类,当指针用于访问):就是未定义行为：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (Derived::* dp)(<span class="type">int</span>) = &amp;Derived::f;</span><br><span class="line">    <span class="built_in">void</span> (Base::* bp)(<span class="type">int</span>) = <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (Base::*)(<span class="type">int</span>)&gt;(dp);</span><br><span class="line"> </span><br><span class="line">    Derived d;</span><br><span class="line">    (d.*bp)(<span class="number">1</span>); <span class="comment">// okay: prints 1</span></span><br><span class="line"> </span><br><span class="line">    Base b;</span><br><span class="line">    (b.*bp)(<span class="number">2</span>); <span class="comment">// undefined behavior</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
成员函数的指针可以用作回调函数或函数对象，通常在应用了std::mem_fn或std::bind之后使用。</li>
</ol>
</li>
<li><ol start="5">
<li>关于空指针的值和空指针的作用<br>(1) 值和初始化：每种类型的指针都有一个特殊的值，称为该类型的空指针值。值为null的指针不指向对象或函数(对空指针进行解引用是未定义的行为)，它与值为null的所有相同类型的指针进行比较。<br> 要初始化指向null的指针或将null值赋给现有指针，可以使用空指针字面量nullptr、空指针常量null或从整数值0的隐式转换。零初始化和值初始化也初始化指向空值的指针。<br>(2) 作用：空指针可以用来表示没有对象(例如function::target())，或者作为其他错误条件指示器(例如dynamic_cast)。通常，接收指针参数的函数几乎总是需要检查值是否为空，并以不同的方式处理这种情况(例如，当传递空指针时，delete表达式不做任何操作)。</li>
</ol>
</li>
<li><ol start="6">
<li>关于cv修饰指针：<br>If cv appears before * in the pointer declaration, it is part of decl-specifier-seq and applies to the pointed-to object. 在<em>前面，则为修饰变量<br>If cv appears after * in the pointer declaration, it is part of declarator and applies to the pointer that’s being declared. 在</em>后面，则为修饰指针</li>
</ol>
</li>
</ul>
<p>Syntax           meaning<br>const T*         pointer to constant object<br>T const*         pointer to constant object<br>T* const         constant pointer to object<br>const T* const   constant pointer to constant object<br>T const* const   constant pointer to constant object</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="comment">// pc is a non-const pointer to const int</span></span><br><span class="line"><span class="comment">// cpc is a const pointer to const int</span></span><br><span class="line"><span class="comment">// ppc is a non-const pointer to non-const pointer to const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">10</span>, *pc = &amp;ci, *<span class="type">const</span> cpc = pc, **ppc;</span><br><span class="line"><span class="comment">// p is a non-const pointer to non-const int</span></span><br><span class="line"><span class="comment">// cp is a const pointer to non-const int</span></span><br><span class="line"><span class="type">int</span> i, *p, *<span class="type">const</span> cp = &amp;i;</span><br><span class="line"> </span><br><span class="line">i = ci;    <span class="comment">// okay: value of const int copied into non-const int</span></span><br><span class="line">*cp = ci;  <span class="comment">// okay: non-const int (pointed-to by const pointer) can be changed</span></span><br><span class="line">pc++;      <span class="comment">// okay: non-const pointer (to const int) can be changed</span></span><br><span class="line">pc = cpc;  <span class="comment">// okay: non-const pointer (to const int) can be changed</span></span><br><span class="line">pc = p;    <span class="comment">// okay: non-const pointer (to const int) can be changed</span></span><br><span class="line">ppc = &amp;pc; <span class="comment">// okay: address of pointer to const int is pointer to pointer to const int</span></span><br><span class="line"> </span><br><span class="line">ci = <span class="number">1</span>;    <span class="comment">// error: const int cannot be changed</span></span><br><span class="line">ci++;      <span class="comment">// error: const int cannot be changed</span></span><br><span class="line">*pc = <span class="number">2</span>;   <span class="comment">// error: pointed-to const int cannot be changed</span></span><br><span class="line">cp = &amp;ci;  <span class="comment">// error: const pointer (to non-const int) cannot be changed</span></span><br><span class="line">cpc++;     <span class="comment">// error: const pointer (to const int) cannot be changed</span></span><br><span class="line">p = pc;    <span class="comment">// error: pointer to non-const int cannot point to const int</span></span><br><span class="line">ppc = &amp;p;  <span class="comment">// error: pointer to pointer to const int cannot point to</span></span><br><span class="line">           <span class="comment">// pointer to non-const int</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="7">
<li>关于智能指针</li>
</ol>
</li>
<li><ol start="8">
<li>关于stl中的迭代器，替代指针的方案；</li>
</ol>
</li>
<li><ol start="9">
<li>扩展：关于c++的cv概念：<a href="https://en.cppreference.com/w/cpp/language/cv">https://en.cppreference.com/w/cpp/language/cv</a> 即const 和volatile</li>
</ol>
</li>
<li>10）为了辅助指针的类型判断，提供了这类函数：std::is_member_pointer<br><a href="https://en.cppreference.com/w/cpp/types/is_member_pointer">https://en.cppreference.com/w/cpp/types/is_member_pointer</a></li>
</ul>
<h5 id="数组类型：-数组可以容纳所有内建类型，字符，指针，int等数字类型；"><a href="#数组类型：-数组可以容纳所有内建类型，字符，指针，int等数字类型；" class="headerlink" title="数组类型： 数组可以容纳所有内建类型，字符，指针，int等数字类型；"></a>数组类型： 数组可以容纳所有内建类型，字符，指针，int等数字类型；</h5><ul>
<li><p>1）数组索引，数组元素支持和不支持，cv限定，内存情况：存放内建类型，连续物理地址存放；访问时++索引或地址即可；<br>数组索引：声明的形式T [N];,声明一个数组对象,由连续N 个T类型的对象，分配一个数组的元素编号0,…,N - 1,和可能访问下标运算符[],在[0],…,(N - 1)。<br>数组元素类型：数组可以从任何基本类型(void除外)、指针、指向成员的指针、类、枚举，或者从其他已知边界的数组(在这种情况下，该数组被称为多维数组)构造。换句话说，<br>除了未知范围的数组类型之外，只有对象类型才能成为数组类型的元素类型。不完整元素类型的数组类型也是不完整类型。 不支持引用的数组和函数的数组；<br>cv限定：将cv限定符应用于数组类型(通过类型定义或模板类型操作)将限定符应用于元素类型，但是任何元素属于cv限定类型的数组类型都被认为具有相同的cv限定符  </p>
</li>
<li><ol start="2">
<li>数组的赋值：<br>数组类型的对象不能作为一个整体被修改:即使它们是左值(例如数组的地址可以被取走)，它们也不能出现在赋值操作符的左边<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, b[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">3</span>] = &amp;a; <span class="comment">// okay: address of a can be taken</span></span><br><span class="line">a = b;            <span class="comment">// error: a is an array</span></span><br><span class="line"><span class="keyword">struct</span> &#123; <span class="type">int</span> c[<span class="number">3</span>]; &#125; s1, s2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">s1 = s2; <span class="comment">// okay: implicity-defined copy assignment operator</span></span><br><span class="line">         <span class="comment">// can assign data members of array type</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>3）数组和指针之间的隐式转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> (&amp;a)[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; *p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* p = a;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span> a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>  <span class="comment">// prints size of array</span></span><br><span class="line">              &lt;&lt; <span class="keyword">sizeof</span> p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints size of a pointer</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// where arrays are acceptable, but pointers aren&#x27;t, only arrays may be used</span></span><br><span class="line">    <span class="built_in">g</span>(a); <span class="comment">// okay: function takes an array by reference</span></span><br><span class="line"><span class="comment">//  g(p); // error</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n: a)              <span class="comment">// okay: arrays can be used in range-for loops</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// prints elements of the array</span></span><br><span class="line"><span class="comment">//  for(int n: p)              // error</span></span><br><span class="line"><span class="comment">//      std::cout &lt;&lt; n &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">iota</span>(std::<span class="built_in">begin</span>(a), std::<span class="built_in">end</span>(a), <span class="number">7</span>); <span class="comment">// okay: begin and end take arrays</span></span><br><span class="line"><span class="comment">//  std::iota(std::begin(p), std::end(p), 7); // error</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// where pointers are acceptable, but arrays aren&#x27;t, both may be used:</span></span><br><span class="line">    <span class="built_in">f</span>(a); <span class="comment">// okay: function takes a pointer</span></span><br><span class="line">    <span class="built_in">f</span>(p); <span class="comment">// okay: function takes a pointer</span></span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; *a &lt;&lt; <span class="string">&#x27;\n&#x27;</span> <span class="comment">// prints the first element</span></span><br><span class="line">              &lt;&lt; *p &lt;&lt; <span class="string">&#x27;\n&#x27;</span> <span class="comment">// same</span></span><br><span class="line">              &lt;&lt; *(a + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>  <span class="comment">// prints the second element</span></span><br><span class="line">              &lt;&lt; *(p + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// same</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4）数组的数组，数组存放struct<br>数组的数组：多维数组其实在内存中的存放也是连续的，就是数组的每个元素是一个数组，这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dualarray[<span class="number">2</span>][<span class="number">5</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> *pp=&amp;dualarray[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//指向数组元素的指针</span></span><br><span class="line">    <span class="built_in">int</span> (*p)[<span class="number">5</span>]=dualarray; <span class="comment">//使用行指针，指向二维数组的行；</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">10</span>;n++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*pp);</span><br><span class="line">            pp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d \n&quot;,**p);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">数组存放的是<span class="keyword">struct</span>:在内存中实际上也是连续存储的，但是在取值的时候，往往因为类型不同而不能直接取；</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">cc</span> x[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cc</span> sa;</span><br><span class="line">    sa.a=<span class="number">1</span>;</span><br><span class="line">    sa.b=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cc</span> sb;</span><br><span class="line">    sb.a=<span class="number">3</span>;</span><br><span class="line">    sb.b=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cc</span> sc;</span><br><span class="line">    sc.a=<span class="number">5</span>;</span><br><span class="line">    sc.b=<span class="number">6</span>;</span><br><span class="line">    x[<span class="number">0</span>]=sa;</span><br><span class="line">    x[<span class="number">1</span>]=sb;</span><br><span class="line">    x[<span class="number">2</span>]=sc;</span><br><span class="line">    <span class="comment">//struct cc *sp = &amp;x[0];</span></span><br><span class="line">    <span class="type">int</span> *sp=&amp;x[<span class="number">0</span>].a;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">7</span>;n++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*sp);</span><br><span class="line">            sp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        输出：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> </span><br></pre></td></tr></table></figure>
</li>
<li><ol start="5">
<li>未知边界的数组：<br>如果在数组的声明中省略了维度值，则声明的类型为“未知维度T的数组”，这是一种不完全类型，除非在带有初始化式的声明中使用 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x[];      <span class="comment">// the type of x is &quot;array of unknown bound of int&quot;</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// the type of a is &quot;array of 3 int&quot;</span></span><br></pre></td></tr></table></figure>
因为数组元素不能是未知边界的数组，所以多维数组除了第一个维度之外，不能有未知边界:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a[][<span class="number">2</span>]; <span class="comment">// okay: array of unknown bound of arrays of 2 int</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b[<span class="number">2</span>][]; <span class="comment">// error: array has incomplete element type</span></span><br></pre></td></tr></table></figure>
指向未知边界数组的指针不能参与指针算术，也不能在下标操作符的左侧使用，但可以解引用。指向未知边界数组的指针和引用不能用于函数形参。<br>数组和指针，引用的隐式转换：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a1[];</span><br><span class="line"><span class="built_in">int</span> (&amp;r1)[] = a1;  <span class="comment">// okay</span></span><br><span class="line"><span class="built_in">int</span> (*p1)[] = &amp;a1; <span class="comment">// okay</span></span><br><span class="line"><span class="built_in">int</span> (*q)[<span class="number">2</span>] = &amp;a1; <span class="comment">// error (but okay in C)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a2[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (&amp;r2)[] = a2;  <span class="comment">// error</span></span><br><span class="line"><span class="built_in">int</span> (*p2)[] = &amp;a2; <span class="comment">// error (but okay in C)</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="6">
<li>指针数组：数组元素是指针</li>
</ol>
</li>
<li><ol start="7">
<li>数组和右值：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (&amp;&amp;x)[<span class="number">2</span>][<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span> x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">&#125; x;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> identity = T;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="function"><span class="keyword">sizeof</span> <span class="title">X</span><span class="params">()</span>.i &lt;&lt; &#x27;\n&#x27;</span>;           <span class="comment">// size of the array</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="built_in">X</span>().i);                                    <span class="comment">// okay: binds to xvalue</span></span><br><span class="line"><span class="comment">//  f(x.i);                                      // error: cannot bind to lvalue</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">f</span>(std::<span class="built_in">move</span>(a));                             <span class="comment">// okay: binds to xvalue</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">using</span> <span class="type">arr_t</span> = <span class="type">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">f</span>(<span class="type">arr_t</span>&#123;&#125;);                                  <span class="comment">// okay: binds to prvalue</span></span><br><span class="line">    <span class="built_in">f</span>(identity&lt;<span class="type">int</span>[][<span class="number">3</span>]&gt;&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;); <span class="comment">// okay: binds to prvalue</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h5 id="函数类型："><a href="#函数类型：" class="headerlink" title="函数类型："></a>函数类型：</h5><ul>
<li><ol>
<li>函数的声明语法<br>一个函数的声明是介绍函数的名字和类型；函数声明可能出现在任何的scope.在类中的声明是表明一个类成员函数(友元函数除外);<br>函数的类型由返回值类型表明；<br>c++或高版本的c在传统的函数声明上加了其他语法，所以对c++ 来说：<br>(1)传统的函数声明语法<br>(2)扩展的返回值声明：这个字段被放在最外面在这种情况下，decl-specifier-seq必须包含关键字auto</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">noptr-<span class="built_in">declarator</span> ( parameter-list ) <span class="built_in">cv</span>(optional) <span class="built_in">ref</span>(optional) <span class="built_in">except</span>(optional) <span class="built_in">attr</span>(optional)	(<span class="number">1</span>)	</span><br><span class="line">noptr-<span class="built_in">declarator</span> ( parameter-list ) <span class="built_in">cv</span>(optional) <span class="built_in">ref</span>(optional) <span class="built_in">except</span>(optional) <span class="built_in">attr</span>(optional) -&gt; <span class="built_in">trailing</span>	(<span class="number">2</span>)	(since C++<span class="number">11</span>)</span><br><span class="line">一个函数声明由以下几部分组成：</span><br><span class="line">noptr-declarator - 任何有效的声明，但是若开始于*,&amp;,或&amp;&amp; ,则必须用小括号括起来：<span class="type">int</span>（*pf)(<span class="type">double</span> x); /<span class="built_in">int</span> (*pf)(<span class="type">double</span>); --这里应该指的是函数指针的声明，因为其他带&amp;这几个符号的没见需要小括号的；TODO;</span><br><span class="line">parameter-list:  - 参数列表，可能为空；</span><br><span class="line"><span class="built_in">attr</span>(c++<span class="number">11</span>): 可选的属性列表，它作用于函数的类型而不是函数本身，它标识于函数声明的最后，和函数声明的开头相关联；</span><br><span class="line">cv: --<span class="type">const</span>/<span class="keyword">volatile</span>: 只作用于非静态成员函数的声明；</span><br><span class="line">ref:-- 引用声明，只作用于非静态成员函数的声明；</span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> &amp;</span>&#123; std::cout &lt;&lt; <span class="string">&quot;lvalue object\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> &amp;&amp;</span>&#123; std::cout &lt;&lt; <span class="string">&quot;rvalue object\n&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> &amp;&amp;</span>&#123;std::cout&lt;&lt; <span class="string">&quot;g rvalue  boject\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">except:不属于函数类型的一部分，是异常抛出相关字段；</span><br><span class="line"><span class="built_in">trailing</span>(c++<span class="number">11</span>): 扩展的返回类型：当返回类型依赖于参数名时很有用：eg:<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span>;</span><br><span class="line">(PS: c++<span class="number">20</span> 中还支持： <span class="keyword">requires</span> <span class="literal">true</span>在后面，具体见参考文档)</span><br></pre></td></tr></table></figure>

<p>用法：函数的声明可以和其他声明混合在一起如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// declares an int, an int*, a function, and a pointer to a function</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, *p = <span class="literal">NULL</span>, <span class="built_in">f</span>(), (*pf)(<span class="type">double</span>);</span><br><span class="line"><span class="comment">// decl-specifier-seq is int</span></span><br><span class="line"><span class="comment">// declarator f() declares (but doesn&#x27;t define)</span></span><br><span class="line"><span class="comment">//                a function taking no arguments and returning int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span>)</span> <span class="type">const</span>, <span class="title">g</span><span class="params">(<span class="type">int</span>)</span> &amp;&amp;</span>; <span class="comment">// declares two non-static member functions</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span>)</span>, x</span>; <span class="comment">// compile-time error: virtual (in decl-specifier-seq)</span></span><br><span class="line">                            <span class="comment">// is only allowed in declarations of non-static</span></span><br><span class="line">                            <span class="comment">// member functions</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="2">
<li>函数的返回值<br>函数的返回值不能是一个函数或者数组，但是可以是一个指针或者引用指向他们<br>(1) 使用auto c++11 类型推论<br>文档描述：<br>If the decl-specifier-seq of the function declaration contains the keyword auto, trailing return type may be omitted, and will be deduced by the compiler from the type of the expression used in the return statement. If the return type does not use decltype(auto), the deduction follows the rules of template argument deduction.<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;        <span class="comment">// return type is int</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="keyword">auto</span>&amp; <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125; <span class="comment">// return type is const int&amp;</span></span><br></pre></td></tr></table></figure>
当返回值类型有多种情况时，会被归结为一种类型：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(<span class="type">bool</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val) <span class="keyword">return</span> <span class="number">123</span>; <span class="comment">// deduces return type int</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3.14f</span>;   <span class="comment">// error: deduces return type float 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当返回值无类型，即为void时，则auto也可以用，decltype(auto)也可以用，但是注意以下情况：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;              <span class="comment">// returns void</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125; <span class="comment">// returns void</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span>* <span class="title">x</span><span class="params">()</span> </span>&#123;&#125;             <span class="comment">// error: cannot deduce auto* from void</span></span><br></pre></td></tr></table></figure>
当返回值能被推算是归结到相同类型，则允许：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> i;              <span class="comment">// sum’s return type is int</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(i - <span class="number">1</span>) + i; <span class="comment">// okay: sum’s return type is already known</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当返回值类型是初始化列表时，不允许：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125; <span class="comment">// error</span></span><br><span class="line">虚函数和协程不允许使用<span class="keyword">auto</span>推论( c++<span class="number">14</span>/c++<span class="number">20</span>)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">F</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125; <span class="comment">// error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
当一个函数已经使用auto 类型推论，则不能使用确定类型的声明和decltype，即使是相同类型：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span></span>;               <span class="comment">// declared, not yet defined</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125; <span class="comment">// defined, return type is int</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;                <span class="comment">// error: cannot use the deduced type</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f</span><span class="params">()</span></span>;     <span class="comment">// error: different kind of deduction</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span></span>;               <span class="comment">// okay: re-declared</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="function"><span class="keyword">friend</span> T <span class="title">frf</span><span class="params">(T)</span></span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">frf</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i; &#125; <span class="comment">// not a friend of A&lt;int&gt;</span></span><br><span class="line">                当函数模板使用时：</span><br><span class="line">                <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">auto</span> <span class="title">f</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(f(<span class="number">1</span>))</span> <span class="type">fint_t</span></span>;    <span class="comment">// instantiates f&lt;int&gt; to deduce return type</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">auto</span> <span class="title">f</span><span class="params">(T* t)</span> </span>&#123; <span class="keyword">return</span> *t; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">int</span> (*p)(<span class="type">int</span>*) = &amp;f; &#125; <span class="comment">// instantiates both fs to determine return types,</span></span><br><span class="line">                                  <span class="comment">// chooses second template overload</span></span><br></pre></td></tr></table></figure>
当函数模板的特化使用时，必须和返回值相同类型：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">auto</span> <span class="title">g</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">return</span> t; &#125; <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">g</span><span class="params">(<span class="type">int</span>)</span></span>;      <span class="comment">// okay: return type is int</span></span><br><span class="line"><span class="comment">//template char g(char);     // error: no matching template</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">(<span class="type">double</span>)</span></span>; <span class="comment">// okay: forward declaration with unknown return type</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">g</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">return</span> t; &#125; <span class="comment">// okay: not equivalent to #1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">char</span> <span class="title">g</span><span class="params">(<span class="type">char</span>)</span></span>;     <span class="comment">// okay: now there is a matching template</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">auto</span> <span class="title">g</span><span class="params">(<span class="type">float</span>)</span></span>;    <span class="comment">// still matches #1</span></span><br><span class="line"><span class="comment">//void h() &#123; return g(42); &#125; // error: ambiguous</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p>(2) 使用decltype c++11  用于从参数判断类型<br>int x &#x3D; 1;<br>decltype(auto) f() { return x; }  &#x2F;&#x2F; return type is int, same as decltype(x)<br>decltype(auto) f() { return(x); } &#x2F;&#x2F; return type is int&amp;, same as decltype((x))</p>
<ul>
<li><ol start="3">
<li>函数的参数列表<br>(1) 有如下5种语法情况：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">attr</span>(optional) decl-specifier-<span class="function">seq <span class="title">declarator</span>	<span class="params">(<span class="number">1</span>)</span>	<span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> *p, <span class="type">int</span> (*(*x)(<span class="type">double</span>))[<span class="number">3</span>])</span></span>;</span><br><span class="line"><span class="built_in">attr</span>(optional) decl-specifier-seq declarator = <span class="built_in">initializer</span>	(<span class="number">2</span>)	<span class="type">int</span> <span class="built_in">f</span>(<span class="type">int</span> a = <span class="number">7</span>, <span class="type">int</span> *p = <span class="literal">nullptr</span>, <span class="built_in">int</span> (*(*x)(<span class="type">double</span>))[<span class="number">3</span>] = <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">attr</span>(optional) decl-specifier-seq abstract-<span class="built_in">declarator</span>(optional)	(<span class="number">3</span>)	<span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> *, <span class="type">int</span> (*(*)(<span class="type">double</span>))[<span class="number">3</span>])</span></span>;</span><br><span class="line"><span class="built_in">attr</span>(optional) decl-specifier-seq abstract-<span class="built_in">declarator</span>(optional) = <span class="built_in">initializer</span>	(<span class="number">4</span>)	<span class="type">int</span> <span class="built_in">f</span>(<span class="type">int</span> = <span class="number">7</span>, <span class="type">int</span> * = <span class="literal">nullptr</span>, <span class="built_in">int</span> (*(*)(<span class="type">double</span>))[<span class="number">3</span>] = <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">void</span>	(<span class="number">5</span>)	空参数，<span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">void</span>)</span>和<span class="type">int</span> <span class="title">f</span><span class="params">()</span>一样，但是不能用cv描述，</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">void</span>, <span class="type">int</span>)</span></span>;(不应该只有<span class="type">int</span>吗) <span class="function"><span class="keyword">and</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">void</span>)</span></span>; 都是错误的,<span class="type">void</span>*则可以，在函数模板中，则不能被实例为T=<span class="type">void</span></span><br><span class="line">函数可选参数列表可以看：variadic function:手册有实例；</span><br></pre></td></tr></table></figure>
(2) 关于新特性<br>c++20：如果函数的任何形参使用了占位符(auto或概念类型)，则函数声明将改为缩写的函数模板声明:</li>
</ol>
</li>
</ul>
<p>(3) 关于函数参数名：仅仅是为了文档化，自我说明；参数被这样解析：<br>首先，类型确定：若是T数组或未只边界的T，则被指向T的指针替代，若是函数类型F，则被指向函数F的指针替代；而对于CV限定，则只会影响函数类型，不会影响参数类型(因为函数只是传递值)：<br>因此： int f(const int p,decltype(p)<em>);和int f(int,const int</em>);是相同的声明；<br>以下声明是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span> s[<span class="number">3</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span>* <span class="type">const</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span>* <span class="keyword">volatile</span> s)</span></span>;</span><br><span class="line">这两个也一样：</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span>())</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (*g)())</span></span>;</span><br></pre></td></tr></table></figure>
<p>形参类型不能是包含引用或指向未知绑定数组的指针(包括此类类型的多层次指针&#x2F;数组)的类型，也不能是指向形参为此类类型的函数的指针。</p>
<p>而指示可变参数的省略号不必在前面加逗号，即使它跟在指示参数包扩展的省略号后面，因此以下函数模板是完全相同的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(Args..., ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(Args... ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(Args......)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用这种声明的一个例子是std::is_function的实现</p>
<ul>
<li><ol start="4">
<li>函数的定义<br>非成员函数定义只能出现在命名空间作用域中(没有嵌套函数)。成员函数定义也可以出现在类定义体中。它们的语法如下:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">attr</span>(optional) decl-specifier-<span class="built_in">seq</span>(optional) declarator virt-specifier-<span class="built_in">seq</span>(optional) function-body</span><br><span class="line">where function-body is one of the following</span><br><span class="line"></span><br><span class="line">ctor-<span class="built_in">initializer</span>(optional) compound-<span class="built_in">statement</span>	(<span class="number">1</span>)(初始化式）	</span><br><span class="line">function-<span class="keyword">try</span>-<span class="built_in">block</span>	(<span class="number">2</span>)	</span><br><span class="line">= <span class="keyword">delete</span> ;	(<span class="number">3</span>)	(since C++<span class="number">11</span>)</span><br><span class="line">= <span class="keyword">default</span> ;	(<span class="number">4</span>)	(since C++<span class="number">11</span>)</span><br><span class="line">即：</span><br><span class="line"><span class="number">1</span>) regular function body</span><br><span class="line"><span class="number">2</span>) function-<span class="keyword">try</span>-<span class="built_in">block</span> (which is a regular function body wrapped in a <span class="keyword">try</span>/<span class="keyword">catch</span> block)</span><br><span class="line"><span class="number">3</span>) explicitly deleted function definition</span><br><span class="line"><span class="number">4</span>) explicitly defaulted function definition, <span class="function">only allowed <span class="keyword">for</span> special member functions <span class="keyword">and</span> comparison <span class="keyword">operator</span> <span class="title">functions</span> <span class="params">(since C++<span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">attr</span><span class="params">(C++<span class="number">11</span>)</span>	-	optional list of attributes. These attributes are combined with the attributes after the identifier in the <span class="title">declarator</span> <span class="params">(see top of <span class="keyword">this</span> page)</span>, <span class="keyword">if</span> any.</span></span><br><span class="line"><span class="function">decl-specifier-seq	-	the <span class="keyword">return</span> type with specifiers, as in the declaration grammar</span></span><br><span class="line"><span class="function">declarator	-	function declarator, same as in the function declaration grammar above. as with function declaration, it may be followed by a <span class="keyword">requires</span>-<span class="title">clause</span> <span class="params">(since C++<span class="number">20</span>)</span></span></span><br><span class="line"><span class="function">virt-specifier-<span class="title">seq</span><span class="params">(C++<span class="number">11</span>)</span>	-	<span class="keyword">override</span>, <span class="keyword">final</span>, <span class="keyword">or</span> their combination in any <span class="title">order</span> <span class="params">(only allowed <span class="keyword">for</span> non-<span class="type">static</span> member functions)</span>  notice</span></span><br><span class="line"><span class="function">ctor-initializer	-	member initializer list, only allowed in constructors</span></span><br><span class="line"><span class="function">compound-statement	-	the brace-enclosed sequence of statements that constututes the body of a function</span></span><br></pre></td></tr></table></figure>
eg:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = (a &gt; b)? a : b;</span><br><span class="line">    <span class="keyword">return</span> (m &gt; c)? m : c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// decl-specifier-seq is &quot;int&quot;</span></span><br><span class="line"><span class="comment">// declarator is &quot;max(int a, int b, int c)&quot;</span></span><br><span class="line"><span class="comment">// body is &#123; ... &#125;函数体是一个复合语句(由0条或多条语句组成的由一对花括号括起来的序列)，在进行函数调用时执行。</span></span><br><span class="line">说明：</span><br><span class="line">形参类型以及函数定义的返回类型不能是不完整的类类型，除非函数定义为<span class="built_in">deleted</span>(自c++ <span class="number">11</span>以来)。完整性检查是在函数体的上下文中进行的，这允许成员函数返回定义它们的类(或其外围类)，即使它在定义点是不完整的(在函数体中是完整的)。在函数定义的声明符中声明的参数在函数体的作用域中。如果在函数体中没有使用参数，则不需要对其命名(使用抽象声明符就足够了)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> <span class="comment">// second parameter is not used</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line">尽管形参上的顶级cv限定符在函数声明中被丢弃，但它们将形参的类型修改为函数体中可见的类型:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> <span class="comment">// declares function of type void(int)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// but in the body, the type of n is const int</span></span><br><span class="line">&#125;这样就防止一些函数体内的修改(主要是引用等时，定义者来根据这个判断)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="5">
<li>删除的函数：<br>If, instead of a function body, the special syntax &#x3D; delete ; is used, the function is defined as deleted. Any use of a deleted function is ill-formed (the program will not compile). This includes calls, both explicit (with a function call operator) and implicit (a call to deleted overloaded operator, special member function, allocation function etc), constructing a pointer or pointer-to-member to a deleted function, and even the use of a deleted function in an unevaluated expression. However, implicit ODR-use of a non-pure virtual member function that happens to be deleted is allowed.</li>
</ol>
</li>
</ul>
<p>If the function is overloaded, overload resolution takes place first, and the program is only ill-formed if the deleted function was selected.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sometype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line">sometype* p = <span class="keyword">new</span> sometype; <span class="comment">// error: attempts to call deleted sometype::operator new</span></span><br><span class="line"></span><br><span class="line">删除的函数定义必须是翻译单元中的第一个声明:之前声明的函数不能被重新声明为已删除:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sometype</span> &#123; <span class="built_in">sometype</span>(); &#125;;</span><br><span class="line">sometype::<span class="built_in">sometype</span>() = <span class="keyword">delete</span>; <span class="comment">// error: must be deleted on the first declaration</span></span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="6">
<li><strong>func</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Within the function body, the function-local predefined variable __func__ is defined as <span class="keyword">if</span> by</span><br><span class="line">k@VM<span class="number">-180</span><span class="number">-38</span>-ubuntu:~$ g++ -o test test.cpp </span><br><span class="line">test.cpp:<span class="number">8</span>:<span class="number">22</span>: warning: ‘__func__’ is <span class="keyword">not</span> defined outside of function scope</span><br><span class="line">    <span class="number">8</span> | <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s=__func__)</span></span>;</span><br><span class="line">      |                      ^~~~~~~~</span><br><span class="line">k@VM<span class="number">-180</span><span class="number">-38</span>-ubuntu:~$ ./test </span><br><span class="line">s:top level</span><br><span class="line">k@VM<span class="number">-180</span><span class="number">-38</span>-ubuntu:~$ cat test.cpp </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static const char __func__[]=&quot;functime name&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s=__func__)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;s:%s\n&quot;</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h5 id="枚举类型："><a href="#枚举类型：" class="headerlink" title="枚举类型："></a>枚举类型：</h5><p>枚举类型是一种特殊的类型，他的值被限定在一个范围内，可能会包含几个显示的命名常量表，常量的值是整数的类型<br>定义语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span>-<span class="function">key <span class="title">attr</span><span class="params">(optional)</span> <span class="keyword">enum</span>-<span class="title">name</span><span class="params">(optional)</span> <span class="keyword">enum</span>-<span class="title">base</span><span class="params">(optional)</span><span class="params">(C++<span class="number">11</span>)</span> </span>&#123; enumerator-<span class="built_in">list</span>(optional) &#125;</span><br><span class="line"><span class="keyword">enum</span>-<span class="function">key <span class="title">attr</span><span class="params">(optional)</span> <span class="keyword">enum</span>-name <span class="keyword">enum</span>-<span class="title">base</span><span class="params">(optional)</span> </span>; since c++<span class="number">11</span></span><br><span class="line"><span class="keyword">enum</span>-key: 枚举关键字： <span class="keyword">enum</span> ,<span class="keyword">enum</span> <span class="title class_">class</span> 或 <span class="keyword">enum</span> <span class="title class_">struct</span>其中的一个，后两者since c++<span class="number">11</span></span><br><span class="line"><span class="built_in">attr</span>(c++<span class="number">11</span>) : 可选，任意数量属性的序列号</span><br><span class="line"><span class="keyword">enum</span>-name: 枚举名称，</span><br><span class="line"></span><br><span class="line">+ 大类型<span class="number">1</span>：unscoped <span class="keyword">enum</span>: 即是<span class="keyword">enum</span>修饰的<span class="keyword">enum</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>1）语法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> <span class="title">name</span><span class="params">(optional)</span> </span>&#123; enumerator = <span class="keyword">constexpr</span> , enumerator = <span class="keyword">constexpr</span> , ... &#125;	(<span class="number">1</span>)	</span><br><span class="line"><span class="keyword">enum</span> <span class="built_in">name</span>(optional) : type &#123; enumerator = <span class="keyword">constexpr</span> , enumerator = <span class="keyword">constexpr</span> , ... &#125;	(<span class="number">2</span>)	(since C++<span class="number">11</span>)</span><br><span class="line"><span class="keyword">enum</span> name : type ;	(<span class="number">3</span>)	(since C++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; red, green, blue &#125;;</span><br><span class="line">Color r = red;</span><br><span class="line"><span class="keyword">switch</span>(r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> red  : std::cout &lt;&lt; <span class="string">&quot;red\n&quot;</span>;   <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> green: std::cout &lt;&lt; <span class="string">&quot;green\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> blue : std::cout &lt;&lt; <span class="string">&quot;blue\n&quot;</span>;  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><ol start="2">
<li>枚举中的值，隐式和显式指定<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123; a, b, c = <span class="number">10</span>, d, e = <span class="number">1</span>, f, g = f + c &#125;;</span><br><span class="line"><span class="comment">//a = 0, b = 1, c = 10, d = 11, e = 1, f = 2, g = 12</span></span><br><span class="line">而且名字可以省略：</span><br><span class="line"><span class="keyword">enum</span> &#123; a, b, c = <span class="number">0</span>, d = a + <span class="number">2</span> &#125;; <span class="comment">// defines a = 0, b = 1, c = 0, d = 2</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="3">
<li>和int的隐试转换<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, yellow, green = <span class="number">20</span>, blue &#125;;</span><br><span class="line">color col = red;</span><br><span class="line"><span class="type">int</span> n = blue; <span class="comment">// n == 21</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>4）枚举和其他类型的显示转换：<br>整型、浮点型和枚举类型的值可以通过static_cast或显式cast转换为任何枚举类型。如果基础类型不是固定的，并且源值超出范围，则结果是未指定的(直到c++ 17)undefined(因为c++ 17)。(如果源值能够容纳足够容纳目标枚举的所有枚举数的最小位字段，则源值在范围内，如果源值为浮点数则转换为枚举的基础类型。)否则，其结果与隐式转换到底层类型的结果相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">access_t</span> &#123; read = <span class="number">1</span>, write = <span class="number">2</span>, exec = <span class="number">4</span> &#125;; <span class="comment">// enumerators: 1, 2, 4 range: 0..7</span></span><br><span class="line"><span class="type">access_t</span> rwe = <span class="built_in">static_cast</span>&lt;<span class="type">access_t</span>&gt;(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">assert</span>((rwe &amp; read) &amp;&amp; (rwe &amp; write) &amp;&amp; (rwe &amp; exec));</span><br><span class="line"> </span><br><span class="line"><span class="type">access_t</span> x = <span class="built_in">static_cast</span>&lt;<span class="type">access_t</span>&gt;(<span class="number">8.0</span>); <span class="comment">// undefined behavior since C++17</span></span><br><span class="line"><span class="type">access_t</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">access_t</span>&gt;(<span class="number">8</span>); <span class="comment">// undefined behavior since C++17</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">foo</span> &#123; a = <span class="number">0</span>, b = UINT_MAX &#125;; <span class="comment">// range: [0, UINT_MAX]</span></span><br><span class="line">foo x= <span class="built_in">foo</span>(<span class="number">-1</span>); <span class="comment">// undefined behavior since C++17, even if foo&#x27;s underlying type is unsigned int</span></span><br></pre></td></tr></table></figure></li>
<li><ol start="5">
<li>类中枚举的使用：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">direction</span> &#123; left = <span class="string">&#x27;l&#x27;</span>, right = <span class="string">&#x27;r&#x27;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line">X* p = &amp;x;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a = X::direction::left; <span class="comment">// allowed only in C++11 and later</span></span><br><span class="line"><span class="type">int</span> b = X::left;</span><br><span class="line"><span class="type">int</span> c = x.left;</span><br><span class="line"><span class="type">int</span> d = p-&gt;left;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>大类型2：scoped enum:即是enum class 或enum struct修饰的enum<br>和unscoped enum的区别在于，修饰符号不同+不能和int做隐试转换+可以使用类的一些用法：</p>
</li>
<li><ol>
<li>语法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">struct</span>|<span class="keyword">class</span> <span class="title class_">name</span> &#123; enumerator = <span class="keyword">constexpr</span> , enumerator = <span class="keyword">constexpr</span> , ... &#125;	(<span class="number">1</span>)	</span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">struct</span>|<span class="keyword">class</span> name : type &#123; enumerator = <span class="keyword">constexpr</span> , enumerator = <span class="keyword">constexpr</span> , ... &#125;	(<span class="number">2</span>)	</span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">struct</span>|<span class="keyword">class</span> name ;	(<span class="number">3</span>)	</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">struct</span>|<span class="keyword">class</span> <span class="title class_">name</span> : type ;	(<span class="number">4</span>)	</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>不能和int做隐式转换<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; red, green = <span class="number">20</span>, blue &#125;;</span><br><span class="line">Color r = Color::blue;</span><br><span class="line"><span class="keyword">switch</span>(r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> Color::red  : std::cout &lt;&lt; <span class="string">&quot;red\n&quot;</span>;   <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Color::green: std::cout &lt;&lt; <span class="string">&quot;green\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Color::blue : std::cout &lt;&lt; <span class="string">&quot;blue\n&quot;</span>;  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int n = r; // error: no scoped enum to int conversion</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(r); <span class="comment">// OK, n = 21</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="3">
<li>如果满足以下条件，则unscoped和scoped都可以用以下初始化式：<br>初始化是直接列表初始化，<br>初始化器列表只有一个元素，<br>unscoped或scoped的枚举是固定的基础类型，<br>转换是非缩小的  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">byte</span> : <span class="type">unsigned</span> <span class="type">char</span> &#123;&#125;; <span class="comment">// byte is a new integer type</span></span><br><span class="line">byte b &#123; <span class="number">42</span> &#125;; <span class="comment">// OK as of C++17 (direct-list-initialization)</span></span><br><span class="line">byte c = &#123; <span class="number">42</span> &#125;; <span class="comment">// error</span></span><br><span class="line">byte d = byte&#123; <span class="number">42</span> &#125;; <span class="comment">// OK as of C++17; same value as b</span></span><br><span class="line">byte e &#123; <span class="number">-1</span> &#125;; <span class="comment">// error</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; byte b; &#125;;</span><br><span class="line">A a1 = &#123; &#123; <span class="number">42</span> &#125; &#125;; <span class="comment">// error (copy-list-initialization of a constructor parameter)</span></span><br><span class="line">A a2 = &#123; byte&#123; <span class="number">42</span> &#125; &#125;; <span class="comment">// OK as of C++17</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(byte)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">42</span> &#125;); <span class="comment">// error (copy-list-initialization of a function parameter)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Handle</span> : std::<span class="type">uint32_t</span> &#123; Invalid = <span class="number">0</span> &#125;;</span><br><span class="line">Handle h &#123; <span class="number">42</span> &#125;; <span class="comment">// OK as of C++17</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="4">
<li>作为一种类型，它也可以这样使用：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Direction&amp; rhs) &#123;</span><br><span class="line">  std::string dir;</span><br><span class="line">  <span class="keyword">switch</span> (rhs) &#123;</span><br><span class="line">    <span class="keyword">case</span> Direction::NORTH: dir = <span class="string">&quot;NORTH&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Direction::EAST:  dir = <span class="string">&quot;EAST&quot;</span>;  <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Direction::SOUTH: dir = <span class="string">&quot;SOUTH&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Direction::WEST:  dir = <span class="string">&quot;WEST&quot;</span>;  <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>c++20开始，可以用using-enum-declaration:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">enum</span> <span class="title class_">nested</span>-name-<span class="built_in">specifier</span>(optional) name ;</span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">fruit</span> &#123; orange, apple &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">enum</span> <span class="title class_">fruit</span>; <span class="comment">// OK: introduces orange and apple into S</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    s.orange;  <span class="comment">// OK: names fruit::orange</span></span><br><span class="line">    S::orange; <span class="comment">// OK: names fruit::orange</span></span><br><span class="line">&#125;</span><br><span class="line">名字冲突导致无法使用：</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">fruit</span> &#123; orange, apple &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">color</span> &#123; red, orange &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">enum</span> <span class="title class_">fruit</span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// using enum color; // error: color::orange and fruit::orange conflict</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="联合："><a href="#联合：" class="headerlink" title="联合："></a>联合：</h5><p>共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。<br>eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">    std::<span class="type">int32_t</span> n;     <span class="comment">// occupies 4 bytes</span></span><br><span class="line">    std::<span class="type">uint16_t</span> s[<span class="number">2</span>]; <span class="comment">// occupies 4 bytes</span></span><br><span class="line">    std::<span class="type">uint8_t</span> c;     <span class="comment">// occupies 1 byte</span></span><br><span class="line">&#125;;                      <span class="comment">// the whole union occupies 4 bytes</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s = &#123;<span class="number">0x12345678</span>&#125;; <span class="comment">// initializes the first member, s.n is now the active member</span></span><br><span class="line">    <span class="comment">// at this point, reading from s.s or s.c is undefined behavior</span></span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;s.n = &quot;</span> &lt;&lt; s.n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    s.s[<span class="number">0</span>] = <span class="number">0x0011</span>; <span class="comment">// s.s is now the active member</span></span><br><span class="line">    <span class="comment">// at this point, reading from n or c is UB but most compilers define it</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s.c is now &quot;</span> &lt;&lt; +s.c &lt;&lt; <span class="string">&#x27;\n&#x27;</span> <span class="comment">// 11 or 00, depending on platform</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;s.n is now &quot;</span> &lt;&lt; s.n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 12340011 or 00115678</span></span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">s.n = <span class="number">12345678</span></span><br><span class="line">s.c is now <span class="number">0</span></span><br><span class="line">s.n is now <span class="number">115678</span></span><br></pre></td></tr></table></figure>
<p>类和结构类型struct：和类相关，初始化，位运算</p>
<h4 id="更多类型："><a href="#更多类型：" class="headerlink" title="更多类型："></a>更多类型：</h4><p>c++的类型远不止这些，c++可以允许用户定义自己的类型；以及一些声明中出现的临时类型，总的来说：<br>c++允许这样定义类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">declaration</span>;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">declaration</span>;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">declaration</span>;</span><br><span class="line"><span class="keyword">typedef</span> declaration;</span><br><span class="line">type alias declaration.</span><br><span class="line">还有一些在声明中出现的，c++把它们称为type-id:</span><br><span class="line">在c++程序中，通常需要引用没有名称的类型;其语法称为type-id。id类型名称类型T的语法就是声明一个变量或函数的语法类型的T,标识符中,除了decl-specifier-seq type-specifier-seq声明语法的限制,并且可以定义新类型只有在id类型出现在右边non-<span class="keyword">template</span>类型别名声明。</span><br><span class="line"><span class="type">int</span>* p;               <span class="comment">// declaration of a pointer to int</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(p); <span class="comment">// type-id is &quot;int*&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>];   <span class="comment">// declaration of an array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]; <span class="comment">// type-id is &quot;int[3]&quot; (called new-type-id)</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> (*(*x[<span class="number">2</span>])())[<span class="number">3</span>];      <span class="comment">// declaration of an array of 2 pointers to functions</span></span><br><span class="line">                          <span class="comment">// returning pointer to array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> (<span class="built_in">int</span> (*(*[<span class="number">2</span>])())[<span class="number">3</span>]); <span class="comment">// type-id is &quot;int (*(*[2])())[3]&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;                    <span class="comment">// declaration of a function taking int and returning void</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; x = f; <span class="comment">// type template parameter is a type-id &quot;void(int)&quot;</span></span><br><span class="line">std::function&lt;<span class="keyword">auto</span>(<span class="type">int</span>) -&gt; <span class="type">void</span>&gt; y = f; <span class="comment">// same</span></span><br><span class="line"> </span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;       <span class="comment">// declaration of a vector of int</span></span><br><span class="line"><span class="built_in">sizeof</span>(std::vector&lt;<span class="type">int</span>&gt;); <span class="comment">// type-id is &quot;std::vector&lt;int&gt;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> &#123; <span class="type">int</span> x; &#125; b;         <span class="comment">// creates a new type and declares an object b of that type</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="keyword">struct</span>&#123; <span class="type">int</span> x; &#125;);    <span class="comment">// error: cannot define new types in a sizeof expression</span></span><br><span class="line"><span class="keyword">using</span> t = <span class="keyword">struct</span> &#123; <span class="type">int</span> x; &#125;; <span class="comment">// creates a new type and declares t as an alias of that type</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">static</span> <span class="type">int</span>); <span class="comment">// error: storage class specifiers not part of type-specifier-seq</span></span><br><span class="line">std::function&lt;<span class="keyword">inline</span> <span class="type">void</span>(<span class="type">int</span>)&gt; f; <span class="comment">// error: neither are function specifiers</span></span><br><span class="line">声明语法中删除名称的声明器部分被称为抽象声明器。</span><br><span class="line">Type-id可用于以下情况:</span><br><span class="line">to specify the target type in cast expressions;</span><br><span class="line">as arguments to <span class="keyword">sizeof</span>, <span class="keyword">alignof</span>, <span class="keyword">alignas</span>, <span class="keyword">new</span>, <span class="keyword">and</span> <span class="keyword">typeid</span>;</span><br><span class="line">on the right-hand side of a type alias declaration;</span><br><span class="line">as the trailing <span class="keyword">return</span> type of a function declaration;</span><br><span class="line">as the <span class="keyword">default</span> argument of a <span class="keyword">template</span> type parameter;</span><br><span class="line">as the <span class="keyword">template</span> argument <span class="keyword">for</span> a <span class="keyword">template</span> type parameter;</span><br><span class="line">in dynamic exception specification.</span><br></pre></td></tr></table></figure>
<p>其他： 关于静态类型，动态类型和未完成的类型；</p>
<h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><p>c位段结构：<br>位段结构中位段的定义格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> &lt;成员名&gt;:&lt;二进制位数&gt;</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bytedata</span></span><br><span class="line">&#123;<span class="type">unsigned</span> a:<span class="number">2</span>;   <span class="comment">/*位段a，占2位*/</span></span><br><span class="line"> <span class="type">unsigned</span>:<span class="number">6</span>;  <span class="comment">/*无名位段，占6位，但不能访问*/</span></span><br><span class="line"> <span class="type">unsigned</span>:<span class="number">0</span>;     <span class="comment">/*无名位段，占0位，表下一位段从下一字边界开始*/</span></span><br><span class="line"> <span class="type">unsigned</span> b:<span class="number">10</span>;  <span class="comment">/*位段b，占10位*/</span></span><br><span class="line"> <span class="type">int</span> i;          <span class="comment">/*成员i，从下一字边界开始*/</span></span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure>
<p>位段数据的引用:<br>同结构体成员中的数据引用一样，但应注意位段的最大取值范围不要超出二进制位数定的范围，否则超出部分会丢弃。<br>例如：data.a&#x3D;2;   但  data.a&#x3D;10;就超出范围（a占2位，最大3）<br>应用：tcpip头等的应用 </p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_type</tag>
      </tags>
  </entry>
  <entry>
    <title>cprogram_generate</title>
    <url>/2021/02/21/cprogram-generate/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="关于编译链接执行，编译器和cpu相关"><a href="#关于编译链接执行，编译器和cpu相关" class="headerlink" title="关于编译链接执行，编译器和cpu相关"></a>关于编译链接执行，编译器和cpu相关</h3><p>目标： 学完这个部分的知识和调试方法后，一方面可以在写程序时，减少编译错误等，在遇到编译和运行时错误，可以更快的解决或者知道怎么解决，用什么工具可以<br>更快的解决，另一方面，在处理cpu高载，dump问题时，能知道怎么处理和更好的处理； <span id="more"></span></p>
<h3 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h3><p>说明linux下程序的预处理，编译，链接，运行的整个过程；<br>三个文件如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">main.cpp                               |func.cpp                               |func.h</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>                      |#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span>                      |int funcc(int a1);</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>                     |int g_m = 3;                           |</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>                     |extern int g_n ;                       |~                                      </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span>                      |int funcc(int a1)                      |~                                      </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_m;                        |&#123;                                      |~                                      </span><br><span class="line"><span class="type">int</span> g_n = <span class="number">3</span>;                           |    <span class="type">int</span> res = a1+<span class="number">3</span>+g_n;                |~                                      </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>                             |    <span class="keyword">return</span> res</span>;                        |~                                      </span><br><span class="line">&#123;                                      |&#125;                                      |~                                      </span><br><span class="line">    <span class="type">int</span> g_x = <span class="number">3</span>;                       |                                       |~                                      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);                   |~                                      |~                                      </span><br><span class="line">    <span class="built_in">setuid</span>(<span class="number">234323</span>);                    |~                                      |~                                      </span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">funcc</span>(g_x+<span class="number">2</span>);              |~                                      |~                                      </span><br><span class="line">    <span class="type">int</span> *i = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) *|~                                      |~                                      </span><br><span class="line"><span class="number">2</span>);                                    |~                                      |~                                      </span><br><span class="line">    *i = <span class="number">2</span>;                            |~                                      |~                                      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  %lx\n&quot;</span>,*i,i);          |~                                      |~                                      </span><br><span class="line">    <span class="built_in">free</span>(i);                           |~                                      |~                                      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                          |~                                      |~                                      </span><br><span class="line">&#125;                                      |~                                      |~               </span><br></pre></td></tr></table></figure>
<h4 id="各自预处理后："><a href="#各自预处理后：" class="headerlink" title="各自预处理后："></a>各自预处理后：</h4><p>gcc -E test.c -o test.i 或 gcc -E test.c</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">func.i:</span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;func.cpp&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;func.cpp&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;func.h&quot;</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">funcc</span><span class="params">(<span class="type">int</span> a1)</span></span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;func.cpp&quot;</span> <span class="number">2</span></span><br><span class="line"><span class="type">int</span> g_m = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_n ;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">funcc</span><span class="params">(<span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = a1+<span class="number">3</span>+g_n;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.i:</span><br><span class="line">前面展开太多，不贴了：</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">swab</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *__restrict __from, <span class="type">void</span> *__restrict __to,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">ssize_t</span> __n)</span> <span class="title">throw</span> <span class="params">()</span> __<span class="title">attribute__</span> <span class="params">((__nonnull__ (<span class="number">1</span>, <span class="number">2</span>)))</span></span>;</span><br><span class="line"># <span class="number">1151</span> <span class="string">&quot;/usr/include/unistd.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"># <span class="number">3</span> <span class="string">&quot;main.cpp&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;func.h&quot;</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">funcc</span><span class="params">(<span class="type">int</span> a1)</span></span>;</span><br><span class="line"># <span class="number">4</span> <span class="string">&quot;main.cpp&quot;</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_m;</span><br><span class="line"><span class="type">int</span> g_n = <span class="number">3</span>;                           </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>                             </span></span><br><span class="line"><span class="function"></span>&#123;                                      </span><br><span class="line">    <span class="type">int</span> g_x = <span class="number">3</span>;                       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);                   </span><br><span class="line">    <span class="built_in">setuid</span>(<span class="number">234323</span>);                    </span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">funcc</span>(g_x+<span class="number">2</span>);              </span><br><span class="line">    <span class="type">int</span> *i = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) *<span class="number">2</span>);                                    </span><br><span class="line">    *i = <span class="number">2</span>;                            </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  %lx\n&quot;</span>,*i,i);          </span><br><span class="line">    <span class="built_in">free</span>(i);                           </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                          </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="接着编译为汇编文件："><a href="#接着编译为汇编文件：" class="headerlink" title="接着编译为汇编文件："></a>接着编译为汇编文件：</h4><p>gcc -S main.cpp<br>gcc -S func.cpp<br>从下面可以看到，已经对程序进行基本分段了，有数据段，代码段等，对全局变量，有专门的段来存取，对未确定的符号，用类型和等标识；<br>汇编语言和特定的cpu有关；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        .file   <span class="string">&quot;main.cpp&quot;</span>                                                |        .file   <span class="string">&quot;func.cpp&quot;</span></span><br><span class="line">        .globl  g_n                                                       |        .globl  g_m</span><br><span class="line">        .data                                                             |        .data</span><br><span class="line">        .align <span class="number">4</span>                                                          |        .align <span class="number">4</span></span><br><span class="line">        .type   g_n, @object                                              |        .type   g_m, @object</span><br><span class="line">        .size   g_n, <span class="number">4</span>                                                    |        .size   g_m, <span class="number">4</span></span><br><span class="line">g_n:                                                                      |g_m:</span><br><span class="line">        .<span class="type">long</span>   <span class="number">3</span>                                                         |        .<span class="type">long</span>   <span class="number">3</span></span><br><span class="line">        .section        .rodata                                           |        .text</span><br><span class="line">.LC0:                                                                     |        .globl  _Z5funcci</span><br><span class="line">        .string <span class="string">&quot;hello&quot;</span>                                                   |        .type   _Z5funcci, @function</span><br><span class="line">.LC1:                                                                     |_Z5funcci:</span><br><span class="line">        .string <span class="string">&quot;%d  %lx\n&quot;</span>                                               |.LFB0:</span><br><span class="line">        .text                                                             |        .cfi_startproc</span><br><span class="line">        .globl  main                                                      |        pushq   %rbp</span><br><span class="line">        .type   main, @function                                           |        .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">main:                                                                     |        .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">.LFB2:                                                                    |        movq    %rsp, %rbp</span><br><span class="line">        .cfi_startproc                                                    |        .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">        pushq   %rbp                                                      |        movl    %edi, <span class="number">-20</span>(%rbp)</span><br><span class="line">        .cfi_def_cfa_offset <span class="number">16</span>                                            |        movl    <span class="number">-20</span>(%rbp), %eax</span><br><span class="line">        .cfi_offset <span class="number">6</span>, <span class="number">-16</span>                                                |        leal    <span class="number">3</span>(%rax), %edx</span><br><span class="line">        movq    %rsp, %rbp                                                |        <span class="function">movl    <span class="title">g_n</span><span class="params">(%rip)</span>, %eax</span></span><br><span class="line"><span class="function">        .cfi_def_cfa_register 6                                           |        addl    %edx, %eax</span></span><br><span class="line"><span class="function">        subq    $16, %rsp                                                 |        movl    %eax, -4<span class="params">(%rbp)</span></span></span><br><span class="line"><span class="function">        movl    $3, -16<span class="params">(%rbp)</span>                                             |        movl    -4<span class="params">(%rbp)</span>, %eax</span></span><br><span class="line"><span class="function">        movl    $.LC0, %edi                                               |        popq    %rbp</span></span><br><span class="line"><span class="function">        movl    $0, %eax                                                  |        .cfi_def_cfa 7, 8</span></span><br><span class="line"><span class="function">        call    printf                                                    |        ret</span></span><br><span class="line"><span class="function">        movl    $234323, %edi                                             |        .cfi_endproc</span></span><br><span class="line"><span class="function">        call    setuid                                                    |.LFE0:</span></span><br><span class="line"><span class="function">        movl    <span class="number">-16</span>(%rbp), %eax                                           |        .size   _Z5funcci, .-_Z5funcci</span></span><br><span class="line"><span class="function">        addl    $<span class="number">2</span>, %eax                                                  |        .ident  <span class="string">&quot;GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4&quot;</span></span></span><br><span class="line"><span class="function">        movl    %eax, %edi                                                |        .section        .note.GNU-stack,<span class="string">&quot;&quot;</span>,@progbits</span></span><br><span class="line"><span class="function">        call    _Z5funcci                                                  </span></span><br><span class="line"><span class="function">        movl    %eax, <span class="number">-12</span>(%rbp)                                           </span></span><br><span class="line"><span class="function">        movl    $<span class="number">8</span>, %eax</span></span><br><span class="line"><span class="function">        movq    %rax, %rdi                                                </span></span><br><span class="line"><span class="function">        call    malloc</span></span><br><span class="line"><span class="function">        movq    %rax, <span class="number">-8</span>(%rbp)                                            </span></span><br><span class="line"><span class="function">        movq    <span class="number">-8</span>(%rbp), %rax                                            </span></span><br><span class="line"><span class="function">        movl    $<span class="number">2</span>, (%rax)</span></span><br><span class="line"><span class="function">        movq    <span class="number">-8</span>(%rbp), %rax                                            </span></span><br><span class="line"><span class="function">        movl    (%rax), %eax</span></span><br><span class="line"><span class="function">        movq    <span class="number">-8</span>(%rbp), %rdx                                            </span></span><br><span class="line"><span class="function">        movl    %eax, %esi</span></span><br><span class="line"><span class="function">        movl    $.LC1, %edi                                               </span></span><br><span class="line"><span class="function">        movl    $<span class="number">0</span>, %eax                                                  </span></span><br><span class="line"><span class="function">        call    printf</span></span><br><span class="line"><span class="function">        movq    <span class="number">-8</span>(%rbp), %rax                                            </span></span><br><span class="line"><span class="function">        movq    %rax, %rdi                                                </span></span><br><span class="line"><span class="function">        call    free</span></span><br><span class="line"><span class="function">        movl    $<span class="number">0</span>, %eax                                                  </span></span><br><span class="line"><span class="function">        leave</span></span><br><span class="line"><span class="function">        .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span>                                                 </span></span><br><span class="line"><span class="function">        ret</span></span><br><span class="line"><span class="function">        .cfi_endproc                                                      </span></span><br><span class="line"><span class="function">.LFE2:  </span></span><br><span class="line"><span class="function">        .size   main, .-main</span></span><br><span class="line"><span class="function">        .ident  <span class="string">&quot;GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4&quot;</span>              </span></span><br><span class="line"><span class="function">        .section        .note.GNU-stack,<span class="string">&quot;&quot;</span>,@progbits</span></span><br><span class="line"><span class="function">                                                       </span></span><br></pre></td></tr></table></figure>
<h4 id="编译为目标文件："><a href="#编译为目标文件：" class="headerlink" title="编译为目标文件："></a>编译为目标文件：</h4><p>gcc -c main.cpp<br>gcc -c func.cpp<br>objdump -x func.o</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> file func.o</span><br><span class="line">func.o: ELF <span class="number">64</span>-bit LSB  relocatable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), <span class="keyword">not</span> stripped</span><br><span class="line">为relocatable可重定向文件</span><br><span class="line">objdump  -x func.o</span><br><span class="line"></span><br><span class="line">func.o:     file format elf64-x86<span class="number">-64</span> 文件格式</span><br><span class="line">func.o</span><br><span class="line">architecture: i386:x86<span class="number">-64</span>, flags <span class="number">0x00000011</span>: 系统架构</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address <span class="number">0x0000000000000000</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">0000001</span>d  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000060</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000064</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000064</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">4</span> .note.GNU-stack <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000090</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000090</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">SYMBOL TABLE:符号表，每个编译后的目标文件都有</span><br><span class="line"><span class="number">0000000000000000</span> l    df *ABS*	<span class="number">0000000000000000</span> func.cpp</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .text	<span class="number">0000000000000000</span> .text</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .data	<span class="number">0000000000000000</span> .data</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .bss	<span class="number">0000000000000000</span> .bss</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .note.GNU-stack	<span class="number">0000000000000000</span> .note.GNU-stack</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .eh_frame	<span class="number">0000000000000000</span> .eh_frame</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .comment	<span class="number">0000000000000000</span> .comment</span><br><span class="line"><span class="number">0000000000000000</span> g     O .data	<span class="number">0000000000000004</span> g_m</span><br><span class="line"><span class="number">0000000000000000</span> g     F .text	<span class="number">000000000000001</span>d _Z5funcci</span><br><span class="line"><span class="number">0000000000000000</span>         *UND*	<span class="number">0000000000000000</span> g_n  <span class="comment">//依赖的外部，未定义的符号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">000000000000000f</span> R_X86_64_PC32     g_n<span class="number">-0x0000000000000004</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000000020</span> R_X86_64_PC32     .text</span><br><span class="line"></span><br><span class="line">  file main.o</span><br><span class="line">main.o: ELF <span class="number">64</span>-bit LSB  relocatable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), <span class="keyword">not</span> stripped</span><br><span class="line"> objdump  -x main.o</span><br><span class="line"></span><br><span class="line">main.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line">main.o</span><br><span class="line">architecture: i386:x86<span class="number">-64</span>, flags <span class="number">0x00000011</span>:</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address <span class="number">0x0000000000000000</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00000081</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c4  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c8  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .rodata       <span class="number">0000000f</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>c8  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">4</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>d7  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.GNU-stack <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000103</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">6</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000108</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">SYMBOL TABLE: 这个是符号表，即这个文件导出或者依赖的符号，用于模块间调用使用；</span><br><span class="line"><span class="number">0000000000000000</span> l    df *ABS*	<span class="number">0000000000000000</span> main.cpp</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .text	<span class="number">0000000000000000</span> .text</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .data	<span class="number">0000000000000000</span> .data</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .bss	<span class="number">0000000000000000</span> .bss</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .rodata	<span class="number">0000000000000000</span> .rodata</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .note.GNU-stack	<span class="number">0000000000000000</span> .note.GNU-stack</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .eh_frame	<span class="number">0000000000000000</span> .eh_frame</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .comment	<span class="number">0000000000000000</span> .comment</span><br><span class="line"><span class="number">0000000000000000</span> g     O .data	<span class="number">0000000000000004</span> g_n</span><br><span class="line"><span class="number">0000000000000000</span> g     F .text	<span class="number">0000000000000081</span> main <span class="comment">//下面为依赖的外部符号，有点多，可以看到，因为这里没有使用g_m，所以不依赖；</span></span><br><span class="line"><span class="number">0000000000000000</span>         *UND*	<span class="number">0000000000000000</span> printf</span><br><span class="line"><span class="number">0000000000000000</span>         *UND*	<span class="number">0000000000000000</span> setuid</span><br><span class="line"><span class="number">0000000000000000</span>         *UND*	<span class="number">0000000000000000</span> _Z5funcci</span><br><span class="line"><span class="number">0000000000000000</span>         *UND*	<span class="number">0000000000000000</span> malloc</span><br><span class="line"><span class="number">0000000000000000</span>         *UND*	<span class="number">0000000000000000</span> free</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000000010</span> R_X86_64_32       .rodata</span><br><span class="line"><span class="number">000000000000001</span>a R_X86_64_PC32     printf<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000024</span> R_X86_64_PC32     setuid<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000031</span> R_X86_64_PC32     _Z5funcci<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000041</span> R_X86_64_PC32     malloc<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000060</span> R_X86_64_32       .rodata+<span class="number">0x0000000000000006</span></span><br><span class="line"><span class="number">000000000000006</span>a R_X86_64_PC32     printf<span class="number">-0x0000000000000004</span></span><br><span class="line"><span class="number">0000000000000076</span> R_X86_64_PC32     free<span class="number">-0x0000000000000004</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000000020</span> R_X86_64_PC32     .text</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="接下来链接："><a href="#接下来链接：" class="headerlink" title="接下来链接："></a>接下来链接：</h4><p>gcc -o main main.cpp  func.cpp<br>也可以用ld命令链接，但是需要指定更多依赖；而gcc会自己去寻找一些默认的库等；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> file main</span><br><span class="line">main: ELF <span class="number">64</span>-bit LSB  executable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), <span class="function">dynamically <span class="title">linked</span> <span class="params">(uses shared libs)</span>, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]</span>=<span class="number">2110927</span>a3d6ecf4dd0f70085d18bc49c3b61ba41, <span class="keyword">not</span> stripped</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到这个文件为可执行文件类型；<br>通过elf工具看整个可执行程序的结构：上面的main.o func.o也是elf文件类型之一 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> readelf -a main</span><br><span class="line"> elf文件头：各个字段</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              <span class="number">2&#x27;</span>s complement, little endian</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       <span class="number">0</span></span><br><span class="line">  Type:                              <span class="built_in">EXEC</span> (Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  Version:                           <span class="number">0x1</span></span><br><span class="line">  Entry point address:               <span class="number">0x400520</span></span><br><span class="line">  Start of program headers:          <span class="number">64</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">4544</span> (bytes into file)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  Size of <span class="keyword">this</span> header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">56</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">9</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">30</span></span><br><span class="line">  Section header string table index: <span class="number">27</span></span><br><span class="line"></span><br><span class="line">各个sections</span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .interp           PROGBITS         <span class="number">0000000000400238</span>  <span class="number">00000238</span></span><br><span class="line">       <span class="number">000000000000001</span>c  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .note.ABI-tag     NOTE             <span class="number">0000000000400254</span>  <span class="number">00000254</span></span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">3</span>] .note.gnu.build-i NOTE             <span class="number">0000000000400274</span>  <span class="number">00000274</span></span><br><span class="line">       <span class="number">0000000000000024</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .gnu.hash         GNU_HASH         <span class="number">0000000000400298</span>  <span class="number">00000298</span></span><br><span class="line">       <span class="number">000000000000001</span>c  <span class="number">0000000000000000</span>   A       <span class="number">5</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">5</span>] .dynsym           DYNSYM           <span class="number">00000000004002b</span>8  <span class="number">000002b</span>8</span><br><span class="line">       <span class="number">00000000000000</span>a8  <span class="number">0000000000000018</span>   A       <span class="number">6</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">6</span>] .dynstr           STRTAB           <span class="number">0000000000400360</span>  <span class="number">00000360</span></span><br><span class="line">       <span class="number">0000000000000052</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .gnu.version      VERSYM           <span class="number">00000000004003b</span>2  <span class="number">000003b</span>2</span><br><span class="line">       <span class="number">000000000000000</span>e  <span class="number">0000000000000002</span>   A       <span class="number">5</span>     <span class="number">0</span>     <span class="number">2</span></span><br><span class="line">  [ <span class="number">8</span>] .gnu.version_r    VERNEED          <span class="number">00000000004003</span>c0  <span class="number">000003</span>c0</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">6</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">9</span>] .rela.dyn         RELA             <span class="number">00000000004003e0</span>  <span class="number">000003e0</span></span><br><span class="line">       <span class="number">0000000000000018</span>  <span class="number">0000000000000018</span>   A       <span class="number">5</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .rela.plt         RELA             <span class="number">00000000004003f</span>8  <span class="number">000003f</span>8</span><br><span class="line">       <span class="number">0000000000000090</span>  <span class="number">0000000000000018</span>   A       <span class="number">5</span>    <span class="number">12</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .init             PROGBITS         <span class="number">0000000000400488</span>  <span class="number">00000488</span></span><br><span class="line">       <span class="number">000000000000001</span>a  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">12</span>] .plt              PROGBITS         <span class="number">00000000004004b</span>0  <span class="number">000004b</span>0</span><br><span class="line">       <span class="number">0000000000000070</span>  <span class="number">0000000000000010</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">13</span>] .text             PROGBITS         <span class="number">0000000000400520</span>  <span class="number">00000520</span></span><br><span class="line">       <span class="number">0000000000000202</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">16</span></span><br><span class="line">  [<span class="number">14</span>] .fini             PROGBITS         <span class="number">0000000000400724</span>  <span class="number">00000724</span></span><br><span class="line">       <span class="number">0000000000000009</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">15</span>] .rodata           PROGBITS         <span class="number">0000000000400730</span>  <span class="number">00000730</span></span><br><span class="line">       <span class="number">0000000000000013</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">16</span>] .eh_frame_hdr     PROGBITS         <span class="number">0000000000400744</span>  <span class="number">00000744</span></span><br><span class="line">       <span class="number">000000000000003</span>c  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [<span class="number">17</span>] .eh_frame         PROGBITS         <span class="number">0000000000400780</span>  <span class="number">00000780</span></span><br><span class="line">       <span class="number">0000000000000114</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">18</span>] .init_array       INIT_ARRAY       <span class="number">0000000000600e10</span>  <span class="number">00000e10</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">19</span>] .fini_array       FINI_ARRAY       <span class="number">0000000000600e18</span>  <span class="number">00000e18</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">20</span>] .jcr              PROGBITS         <span class="number">0000000000600e20</span>  <span class="number">00000e20</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">21</span>] .dynamic          DYNAMIC          <span class="number">0000000000600e28</span>  <span class="number">00000e28</span></span><br><span class="line">       <span class="number">00000000000001</span>d0  <span class="number">0000000000000010</span>  WA       <span class="number">6</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">22</span>] .got              PROGBITS         <span class="number">0000000000600f</span>f8  <span class="number">00000f</span>f8</span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">23</span>] .got.plt          PROGBITS         <span class="number">0000000000601000</span>  <span class="number">00001000</span></span><br><span class="line">       <span class="number">0000000000000048</span>  <span class="number">0000000000000008</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">24</span>] .data             PROGBITS         <span class="number">0000000000601048</span>  <span class="number">00001048</span></span><br><span class="line">       <span class="number">0000000000000018</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">25</span>] .bss              NOBITS           <span class="number">0000000000601060</span>  <span class="number">00001060</span></span><br><span class="line">       <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">26</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00001060</span></span><br><span class="line">       <span class="number">0000000000000056</span>  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">27</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">000010b</span>6</span><br><span class="line">       <span class="number">0000000000000108</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">28</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00001940</span></span><br><span class="line">       <span class="number">00000000000006</span>c0  <span class="number">0000000000000018</span>          <span class="number">29</span>    <span class="number">46</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">29</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">00002000</span></span><br><span class="line">       <span class="number">000000000000028f</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  <span class="built_in">W</span> (write), <span class="built_in">A</span> (alloc), <span class="built_in">X</span> (execute), <span class="built_in">M</span> (merge), <span class="built_in">S</span> (strings), <span class="built_in">l</span> (large)</span><br><span class="line">  <span class="built_in">I</span> (info), <span class="built_in">L</span> (link order), <span class="built_in">G</span> (group), <span class="built_in">T</span> (TLS), <span class="built_in">E</span> (exclude), <span class="built_in">x</span> (unknown)</span><br><span class="line">  <span class="built_in">O</span> (extra OS processing required) <span class="built_in">o</span> (OS specific), <span class="built_in">p</span> (processor specific)</span><br><span class="line"></span><br><span class="line">There are no section groups in <span class="keyword">this</span> file.</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           <span class="number">0x0000000000000040</span> <span class="number">0x0000000000400040</span> <span class="number">0x0000000000400040</span></span><br><span class="line">                 <span class="number">0x00000000000001f8</span> <span class="number">0x00000000000001f8</span>  R E    <span class="number">8</span></span><br><span class="line">  INTERP         <span class="number">0x0000000000000238</span> <span class="number">0x0000000000400238</span> <span class="number">0x0000000000400238</span></span><br><span class="line">                 <span class="number">0x000000000000001c</span> <span class="number">0x000000000000001c</span>  R      <span class="number">1</span></span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>]</span><br><span class="line">  LOAD           <span class="number">0x0000000000000000</span> <span class="number">0x0000000000400000</span> <span class="number">0x0000000000400000</span></span><br><span class="line">                 <span class="number">0x0000000000000894</span> <span class="number">0x0000000000000894</span>  R E    <span class="number">200000</span></span><br><span class="line">  LOAD           <span class="number">0x0000000000000e10</span> <span class="number">0x0000000000600e10</span> <span class="number">0x0000000000600e10</span></span><br><span class="line">                 <span class="number">0x0000000000000250</span> <span class="number">0x0000000000000258</span>  RW     <span class="number">200000</span></span><br><span class="line">  DYNAMIC        <span class="number">0x0000000000000e28</span> <span class="number">0x0000000000600e28</span> <span class="number">0x0000000000600e28</span></span><br><span class="line">                 <span class="number">0x00000000000001d0</span> <span class="number">0x00000000000001d0</span>  RW     <span class="number">8</span></span><br><span class="line">  NOTE           <span class="number">0x0000000000000254</span> <span class="number">0x0000000000400254</span> <span class="number">0x0000000000400254</span></span><br><span class="line">                 <span class="number">0x0000000000000044</span> <span class="number">0x0000000000000044</span>  R      <span class="number">4</span></span><br><span class="line">  GNU_EH_FRAME   <span class="number">0x0000000000000744</span> <span class="number">0x0000000000400744</span> <span class="number">0x0000000000400744</span></span><br><span class="line">                 <span class="number">0x000000000000003c</span> <span class="number">0x000000000000003c</span>  R      <span class="number">4</span></span><br><span class="line">  GNU_STACK      <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span></span><br><span class="line">                 <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span>  RW     <span class="number">10</span></span><br><span class="line">  GNU_RELRO      <span class="number">0x0000000000000e10</span> <span class="number">0x0000000000600e10</span> <span class="number">0x0000000000600e10</span></span><br><span class="line">                 <span class="number">0x00000000000001f0</span> <span class="number">0x00000000000001f0</span>  R      <span class="number">1</span></span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   <span class="number">00</span>     </span><br><span class="line">   <span class="number">01</span>     .interp </span><br><span class="line">   <span class="number">02</span>     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   <span class="number">03</span>     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss </span><br><span class="line">   <span class="number">04</span>     .dynamic </span><br><span class="line">   <span class="number">05</span>     .note.ABI-tag .note.gnu.build-id </span><br><span class="line">   <span class="number">06</span>     .eh_frame_hdr </span><br><span class="line">   <span class="number">07</span>     </span><br><span class="line">   <span class="number">08</span>     .init_array .fini_array .jcr .dynamic .got </span><br><span class="line"></span><br><span class="line">Dynamic section at offset <span class="number">0xe28</span> contains <span class="number">24</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x0000000000000001</span> (NEEDED)             Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x000000000000000c</span> (INIT)               <span class="number">0x400488</span></span><br><span class="line"> <span class="number">0x000000000000000d</span> (FINI)               <span class="number">0x400724</span></span><br><span class="line"> <span class="number">0x0000000000000019</span> (INIT_ARRAY)         <span class="number">0x600e10</span></span><br><span class="line"> <span class="number">0x000000000000001b</span> (INIT_ARRAYSZ)       <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000001a</span> (FINI_ARRAY)         <span class="number">0x600e18</span></span><br><span class="line"> <span class="number">0x000000000000001c</span> (FINI_ARRAYSZ)       <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x000000006ffffef5</span> (GNU_HASH)           <span class="number">0x400298</span></span><br><span class="line"> <span class="number">0x0000000000000005</span> (STRTAB)             <span class="number">0x400360</span></span><br><span class="line"> <span class="number">0x0000000000000006</span> (SYMTAB)             <span class="number">0x4002b8</span></span><br><span class="line"> <span class="number">0x000000000000000a</span> (STRSZ)              <span class="number">82</span> (bytes)</span><br><span class="line"> <span class="number">0x000000000000000b</span> (SYMENT)             <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000015</span> (DEBUG)              <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x0000000000000003</span> (PLTGOT)             <span class="number">0x601000</span></span><br><span class="line"> <span class="number">0x0000000000000002</span> (PLTRELSZ)           <span class="number">144</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000014</span> (PLTREL)             RELA</span><br><span class="line"> <span class="number">0x0000000000000017</span> (JMPREL)             <span class="number">0x4003f8</span></span><br><span class="line"> <span class="number">0x0000000000000007</span> (RELA)               <span class="number">0x4003e0</span></span><br><span class="line"> <span class="number">0x0000000000000008</span> (RELASZ)             <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000000000009</span> (RELAENT)            <span class="number">24</span> (bytes)</span><br><span class="line"> <span class="number">0x000000006ffffffe</span> (VERNEED)            <span class="number">0x4003c0</span></span><br><span class="line"> <span class="number">0x000000006fffffff</span> (VERNEEDNUM)         <span class="number">1</span></span><br><span class="line"> <span class="number">0x000000006ffffff0</span> (VERSYM)             <span class="number">0x4003b2</span></span><br><span class="line"> <span class="number">0x0000000000000000</span> (<span class="literal">NULL</span>)               <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.dyn&#x27;</span> at offset <span class="number">0x3e0</span> contains <span class="number">1</span> entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line"><span class="number">000000600f</span>f8  <span class="number">000400000006</span> R_X86_64_GLOB_DAT <span class="number">0000000000000000</span> __gmon_start__ + <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.plt&#x27;</span> at offset <span class="number">0x3f8</span> contains <span class="number">6</span> entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line"><span class="number">000000601018</span>  <span class="number">000100000007</span> R_X86_64_JUMP_SLO <span class="number">0000000000000000</span> free + <span class="number">0</span></span><br><span class="line"><span class="number">000000601020</span>  <span class="number">000200000007</span> R_X86_64_JUMP_SLO <span class="number">0000000000000000</span> printf + <span class="number">0</span></span><br><span class="line"><span class="number">000000601028</span>  <span class="number">000300000007</span> R_X86_64_JUMP_SLO <span class="number">0000000000000000</span> __libc_start_main + <span class="number">0</span></span><br><span class="line"><span class="number">000000601030</span>  <span class="number">000400000007</span> R_X86_64_JUMP_SLO <span class="number">0000000000000000</span> __gmon_start__ + <span class="number">0</span></span><br><span class="line"><span class="number">000000601038</span>  <span class="number">000500000007</span> R_X86_64_JUMP_SLO <span class="number">0000000000000000</span> malloc + <span class="number">0</span></span><br><span class="line"><span class="number">000000601040</span>  <span class="number">000600000007</span> R_X86_64_JUMP_SLO <span class="number">0000000000000000</span> setuid + <span class="number">0</span></span><br><span class="line"></span><br><span class="line">The decoding of unwind sections <span class="keyword">for</span> machine type Advanced Micro Devices X86<span class="number">-64</span> is <span class="keyword">not</span> currently supported.</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.dynsym&#x27;</span> contains <span class="number">7</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND free@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND malloc@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND setuid@GLIBC_2<span class="number">.2</span><span class="number">.5</span> (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">72</span> entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000400238</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> </span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000400254</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">2</span> </span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000400274</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">3</span> </span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000400298</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">4</span> </span><br><span class="line">     <span class="number">5</span>: <span class="number">00000000004002b</span>8     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span> </span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000400360</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">6</span> </span><br><span class="line">     <span class="number">7</span>: <span class="number">00000000004003b</span>2     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">7</span> </span><br><span class="line">     <span class="number">8</span>: <span class="number">00000000004003</span>c0     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">8</span> </span><br><span class="line">     <span class="number">9</span>: <span class="number">00000000004003e0</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">9</span> </span><br><span class="line">    <span class="number">10</span>: <span class="number">00000000004003f</span>8     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">10</span> </span><br><span class="line">    <span class="number">11</span>: <span class="number">0000000000400488</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">11</span> </span><br><span class="line">    <span class="number">12</span>: <span class="number">00000000004004b</span>0     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">12</span> </span><br><span class="line">    <span class="number">13</span>: <span class="number">0000000000400520</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">13</span> </span><br><span class="line">    <span class="number">14</span>: <span class="number">0000000000400724</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">14</span> </span><br><span class="line">    <span class="number">15</span>: <span class="number">0000000000400730</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">15</span> </span><br><span class="line">    <span class="number">16</span>: <span class="number">0000000000400744</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">16</span> </span><br><span class="line">    <span class="number">17</span>: <span class="number">0000000000400780</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">17</span> </span><br><span class="line">    <span class="number">18</span>: <span class="number">0000000000600e10</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">18</span> </span><br><span class="line">    <span class="number">19</span>: <span class="number">0000000000600e18</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">19</span> </span><br><span class="line">    <span class="number">20</span>: <span class="number">0000000000600e20</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">20</span> </span><br><span class="line">    <span class="number">21</span>: <span class="number">0000000000600e28</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">21</span> </span><br><span class="line">    <span class="number">22</span>: <span class="number">0000000000600f</span>f8     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">22</span> </span><br><span class="line">    <span class="number">23</span>: <span class="number">0000000000601000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">23</span> </span><br><span class="line">    <span class="number">24</span>: <span class="number">0000000000601048</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">24</span> </span><br><span class="line">    <span class="number">25</span>: <span class="number">0000000000601060</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">25</span> </span><br><span class="line">    <span class="number">26</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">26</span> </span><br><span class="line">    <span class="number">27</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    <span class="number">28</span>: <span class="number">0000000000600e20</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">20</span> __JCR_LIST__</span><br><span class="line">    <span class="number">29</span>: <span class="number">0000000000400550</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">13</span> deregister_tm_clones</span><br><span class="line">    <span class="number">30</span>: <span class="number">0000000000400580</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">13</span> register_tm_clones</span><br><span class="line">    <span class="number">31</span>: <span class="number">00000000004005</span>c0     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">13</span> __do_global_dtors_aux</span><br><span class="line">    <span class="number">32</span>: <span class="number">0000000000601060</span>     <span class="number">1</span> OBJECT  LOCAL  DEFAULT   <span class="number">25</span> completed<span class="number">.6982</span></span><br><span class="line">    <span class="number">33</span>: <span class="number">0000000000600e18</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">19</span> __do_global_dtors_aux_fin</span><br><span class="line">    <span class="number">34</span>: <span class="number">00000000004005e0</span>     <span class="number">0</span> FUNC    LOCAL  DEFAULT   <span class="number">13</span> frame_dummy</span><br><span class="line">    <span class="number">35</span>: <span class="number">0000000000600e10</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">18</span> __frame_dummy_init_array_</span><br><span class="line">    <span class="number">36</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS main.cpp</span><br><span class="line">    <span class="number">37</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS func.cpp</span><br><span class="line">    <span class="number">38</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    <span class="number">39</span>: <span class="number">0000000000400890</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">17</span> __FRAME_END__</span><br><span class="line">    <span class="number">40</span>: <span class="number">0000000000600e20</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">20</span> __JCR_END__</span><br><span class="line">    <span class="number">41</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS </span><br><span class="line">    <span class="number">42</span>: <span class="number">0000000000600e18</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT   <span class="number">18</span> __init_array_end</span><br><span class="line">    <span class="number">43</span>: <span class="number">0000000000600e28</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">21</span> _DYNAMIC</span><br><span class="line">    <span class="number">44</span>: <span class="number">0000000000600e10</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT   <span class="number">18</span> __init_array_start</span><br><span class="line">    <span class="number">45</span>: <span class="number">0000000000601000</span>     <span class="number">0</span> OBJECT  LOCAL  DEFAULT   <span class="number">23</span> _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    <span class="number">46</span>: <span class="number">0000000000400720</span>     <span class="number">2</span> FUNC    GLOBAL DEFAULT   <span class="number">13</span> __libc_csu_fini</span><br><span class="line">    <span class="number">47</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND free@@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">    <span class="number">48</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab</span><br><span class="line">    <span class="number">49</span>: <span class="number">0000000000601048</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT   <span class="number">24</span> data_start</span><br><span class="line">    <span class="number">50</span>: <span class="number">000000000040068</span>e    <span class="number">29</span> FUNC    GLOBAL DEFAULT   <span class="number">13</span> _Z5funcci</span><br><span class="line">    <span class="number">51</span>: <span class="number">0000000000601060</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">24</span> _edata</span><br><span class="line">    <span class="number">52</span>: <span class="number">0000000000400724</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT   <span class="number">14</span> _fini</span><br><span class="line">    <span class="number">53</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">    <span class="number">54</span>: <span class="number">0000000000601058</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">24</span> g_n</span><br><span class="line">    <span class="number">55</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_</span><br><span class="line">    <span class="number">56</span>: <span class="number">0000000000601048</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">24</span> __data_start</span><br><span class="line">    <span class="number">57</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">    <span class="number">58</span>: <span class="number">0000000000601050</span>     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">24</span> __dso_handle</span><br><span class="line">    <span class="number">59</span>: <span class="number">0000000000400730</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">15</span> _IO_stdin_used</span><br><span class="line">    <span class="number">60</span>: <span class="number">00000000004006b</span>0   <span class="number">101</span> FUNC    GLOBAL DEFAULT   <span class="number">13</span> __libc_csu_init</span><br><span class="line">    <span class="number">61</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND malloc@@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">    <span class="number">62</span>: <span class="number">0000000000601068</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">25</span> _end</span><br><span class="line">    <span class="number">63</span>: <span class="number">0000000000400520</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT   <span class="number">13</span> _start</span><br><span class="line">    <span class="number">64</span>: <span class="number">0000000000601060</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">25</span> __bss_start</span><br><span class="line">    <span class="number">65</span>: <span class="number">000000000040060</span>d   <span class="number">129</span> FUNC    GLOBAL DEFAULT   <span class="number">13</span> main</span><br><span class="line">    <span class="number">66</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses</span><br><span class="line">    <span class="number">67</span>: <span class="number">000000000060105</span>c     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">24</span> g_m</span><br><span class="line">    <span class="number">68</span>: <span class="number">0000000000601060</span>     <span class="number">0</span> OBJECT  GLOBAL HIDDEN    <span class="number">24</span> __TMC_END__</span><br><span class="line">    <span class="number">69</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable</span><br><span class="line">    <span class="number">70</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND setuid@@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">    <span class="number">71</span>: <span class="number">0000000000400488</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT   <span class="number">11</span> _init</span><br><span class="line"></span><br><span class="line">Version symbols section <span class="string">&#x27;.gnu.version&#x27;</span> contains <span class="number">7</span> entries:</span><br><span class="line"> Addr: <span class="number">00000000004003b</span>2  Offset: <span class="number">0x0003b2</span>  Link: <span class="number">5</span> (.dynsym)</span><br><span class="line">  <span class="number">000</span>:   <span class="number">0</span> (*local*)       <span class="number">2</span> (GLIBC_2<span class="number">.2</span><span class="number">.5</span>)   <span class="number">2</span> (GLIBC_2<span class="number">.2</span><span class="number">.5</span>)   <span class="number">2</span> (GLIBC_2<span class="number">.2</span><span class="number">.5</span>)</span><br><span class="line">  <span class="number">004</span>:   <span class="number">0</span> (*local*)       <span class="number">2</span> (GLIBC_2<span class="number">.2</span><span class="number">.5</span>)   <span class="number">2</span> (GLIBC_2<span class="number">.2</span><span class="number">.5</span>)</span><br><span class="line"></span><br><span class="line">Version needs section <span class="string">&#x27;.gnu.version_r&#x27;</span> contains <span class="number">1</span> entries:</span><br><span class="line"> Addr: <span class="number">0x00000000004003c0</span>  Offset: <span class="number">0x0003c0</span>  Link: <span class="number">6</span> (.dynstr)</span><br><span class="line">  <span class="number">000000</span>: Version: <span class="number">1</span>  File: libc.so<span class="number">.6</span>  Cnt: <span class="number">1</span></span><br><span class="line">  <span class="number">0x0010</span>:   Name: GLIBC_2<span class="number">.2</span><span class="number">.5</span>  Flags: none  Version: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Displaying notes found at file offset <span class="number">0x00000254</span> with length <span class="number">0x00000020</span>:</span><br><span class="line">  Owner                 Data size	Description</span><br><span class="line">  GNU                  <span class="number">0x00000010</span>	<span class="built_in">NT_GNU_ABI_TAG</span> (ABI version tag)</span><br><span class="line">    OS: Linux, ABI: <span class="number">2.6</span><span class="number">.24</span></span><br><span class="line"></span><br><span class="line">Displaying notes found at file offset <span class="number">0x00000274</span> with length <span class="number">0x00000024</span>:</span><br><span class="line">  Owner                 Data size	Description</span><br><span class="line">  GNU                  <span class="number">0x00000014</span>	<span class="built_in">NT_GNU_BUILD_ID</span> (unique build ID bitstring)</span><br><span class="line">    Build ID: <span class="number">2110927</span>a3d6ecf4dd0f70085d18bc49c3b61ba41</span><br></pre></td></tr></table></figure>
<h4 id="接着来追踪下程序的运行："><a href="#接着来追踪下程序的运行：" class="headerlink" title="接着来追踪下程序的运行："></a>接着来追踪下程序的运行：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> ./main </span><br><span class="line">hello2  a61010</span><br><span class="line">think@think-VirtualBox:~/c++/testld$ strace ./<span class="function">main </span></span><br><span class="line"><span class="function"><span class="title">execve</span><span class="params">(<span class="string">&quot;./main&quot;</span>, [<span class="string">&quot;./main&quot;</span>], [<span class="comment">/* 74 vars */</span>])</span> </span>= <span class="number">0</span></span><br><span class="line"><span class="built_in">brk</span>(<span class="number">0</span>)                                  = <span class="number">0x9ba000</span></span><br><span class="line"><span class="built_in">access</span>(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK)      = <span class="number">-1</span> <span class="built_in">ENOENT</span> (No such file <span class="keyword">or</span> directory)</span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fc78575f000</span></span><br><span class="line"><span class="built_in">access</span>(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK)      = <span class="number">-1</span> <span class="built_in">ENOENT</span> (No such file <span class="keyword">or</span> directory)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line"><span class="built_in">fstat</span>(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">86757</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">86757</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x7fc785749000</span></span><br><span class="line"><span class="built_in">close</span>(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line"><span class="built_in">access</span>(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK)      = <span class="number">-1</span> <span class="built_in">ENOENT</span> (No such file <span class="keyword">or</span> directory)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></span><br><span class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">&quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P \2\0\0\0\0\0&quot;</span>..., <span class="number">832</span>) = <span class="number">832</span></span><br><span class="line"><span class="built_in">fstat</span>(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">1840928</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">3949248</span>, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x7fc78517a000</span></span><br><span class="line"><span class="built_in">mprotect</span>(<span class="number">0x7fc785334000</span>, <span class="number">2097152</span>, PROT_NONE) = <span class="number">0</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="number">0x7fc785534000</span>, <span class="number">24576</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0x1ba000</span>) = <span class="number">0x7fc785534000</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="number">0x7fc78553a000</span>, <span class="number">17088</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fc78553a000</span></span><br><span class="line"><span class="built_in">close</span>(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fc785748000</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fc785746000</span></span><br><span class="line"><span class="built_in">arch_prctl</span>(ARCH_SET_FS, <span class="number">0x7fc785746740</span>) = <span class="number">0</span></span><br><span class="line"><span class="built_in">mprotect</span>(<span class="number">0x7fc785534000</span>, <span class="number">16384</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line"><span class="built_in">mprotect</span>(<span class="number">0x600000</span>, <span class="number">4096</span>, PROT_READ)     = <span class="number">0</span></span><br><span class="line"><span class="built_in">mprotect</span>(<span class="number">0x7fc785761000</span>, <span class="number">4096</span>, PROT_READ) = <span class="number">0</span></span><br><span class="line"><span class="built_in">munmap</span>(<span class="number">0x7fc785749000</span>, <span class="number">86757</span>)           = <span class="number">0</span></span><br><span class="line"><span class="built_in">fstat</span>(<span class="number">1</span>, &#123;st_mode=S_IFCHR|<span class="number">0620</span>, st_rdev=<span class="built_in">makedev</span>(<span class="number">136</span>, <span class="number">4</span>), ...&#125;) = <span class="number">0</span></span><br><span class="line"><span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fc78575e000</span></span><br><span class="line"><span class="built_in">setuid</span>(<span class="number">234323</span>)                          = <span class="number">-1</span> <span class="built_in">EPERM</span> (Operation <span class="keyword">not</span> permitted)</span><br><span class="line"><span class="built_in">brk</span>(<span class="number">0</span>)                                  = <span class="number">0x9ba000</span></span><br><span class="line"><span class="built_in">brk</span>(<span class="number">0x9db000</span>)                           = <span class="number">0x9db000</span></span><br><span class="line"><span class="built_in">write</span>(<span class="number">1</span>, <span class="string">&quot;hello2  9ba010\n&quot;</span>, <span class="number">15</span>hello2  <span class="number">9b</span>a010</span><br><span class="line">)        = <span class="number">15</span></span><br><span class="line"><span class="built_in">exit_group</span>(<span class="number">0</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br></pre></td></tr></table></figure>
<p>其实这里比较好的方式是gdb,单步调试，这个有兴趣再做吧；<br>运行的时候，是执行execve系列函数，将可执行文件加载后，转换为进程运行，这个时候，做的事情很多，需要创建新进程，需要将可执行文件映射到进程对应的内存区，并建立各个vma区域，对依赖的符号做库加载和映射，然后进程实例结构建立好后，根据进程需要的资源和当前运行状态，加入对应的进程相关队列，等待执行；</p>
<ul>
<li>至此，一个程序，从源文件，到可执行文件，到链接，转换为进程，运行结束，一个周期完结；</li>
</ul>
<h3 id="具体解释：预处理"><a href="#具体解释：预处理" class="headerlink" title="具体解释：预处理"></a>具体解释：预处理</h3><ol>
<li>预处理阶段<br>c&#x2F;c++是编译类型的语言，即c&#x2F;c++源文件，是比较符合人类语言的文本文件，需要将这个文件翻译为机器能直接执行的可执行文件，这个翻译成可执行文件的过程，就是编译的过程；<br>程序在编译的过程中，需要经过几个阶段，第一个阶段是预处理阶段：<br>在正式的编译阶段之前进行。预处理阶段将根据已放置在文件中的预处理指令来修改源文件的内容。<br>如#include指令就是一个预处理指令，它把头文件的内容添加到.cpp文件中。<br>预处理指令，不是真正的程序语句，而是给预处理器的命令；</li>
<li>预处理的指令：<br>预处理指令不止于#include,还有：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span></span></span><br><span class="line"><span class="meta">#end</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span></span></span><br><span class="line">一些已定义好的宏：</span><br><span class="line">__LINE__	整数值，表示当前正在编译的行在源文件中的行数。</span><br><span class="line">__FILE__	字符串，表示被编译的源文件的文件名。</span><br><span class="line">__DATE__	一个格式为 <span class="string">&quot;Mmm dd yyyy&quot;</span> 的字符串，存储编译开始的日期。</span><br><span class="line">__TIME__	一个格式为 <span class="string">&quot;hh:mm:ss&quot;</span> 的字符串，存储编译开始的时间。</span><br><span class="line">__cplusplus	整数值，所有C++编译器都定义了这个常量为某个值。如果这个编译器是完全遵守C++标准的，它的值应该等于或大于<span class="number">199711L</span>，具体值取决于它遵守的是哪个版本的标准。</span><br><span class="line">ref: 见手册；</span><br></pre></td></tr></table></figure></li>
</ol>
<p>预处理阶段，是预处理器对预处理指令的解析，并将解析后的内容输出出来或者到下个阶段的输入；<br>实践：<br>3) 例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">gcc -E test.c -o test.i 或 gcc -E test.c  或用cpp</span><br><span class="line">将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件：</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;simplest.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;simplest.c&quot;</span></span><br><span class="line">stdio.h的内容在这里铺开;</span><br><span class="line">包含了各种函数的声明；</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其他c&#x2F;cpp文件也是一样，但是一个程序(进程)只能有一个main函数<br>PS:关于g++和gcc的不同： g++ 比gcc 多了一些库的链接功能，当使用了c++的标准库的时候，必须用g++;</p>
<ol start="4">
<li>说明：<br>预处理中的#include指令，在编译器处理后，会将对应的头文件展开，这样，其中的函数声明就能展开在引用头文件的源码文件中，当之后编译程序时，用到的符号，<br>声明就能被找到；</li>
</ol>
<h3 id="具体解释：编译"><a href="#具体解释：编译" class="headerlink" title="具体解释：编译"></a>具体解释：编译</h3><h4 id="编译阶段概述："><a href="#编译阶段概述：" class="headerlink" title="编译阶段概述："></a>编译阶段概述：</h4><p>这个阶段，编译器会把每个实现文件，结合头文件编译成中间文件(其实编译过程是不需要头文件的，原因是一些文件中会引用头文件中的函数等符号，所以需要，而也可以引用.c文件，但是会出现重复定义，而声明是可以重复)，一般是一个二进制.o文件，并进行相关的编译器优化，即将一些语句顺序进行调节等；<br>先把源文件翻译成汇编文件，再通过汇编器将汇编文件翻译为二进制文件；</p>
<h4 id="一个例子："><a href="#一个例子：" class="headerlink" title="一个例子："></a>一个例子：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">m</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gcc -S hh.cpp<br>生成hh.s:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	.file	<span class="string">&quot;hh.cpp&quot;</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	_Z1mv</span><br><span class="line">	.type	_Z1mv, @function</span><br><span class="line">_Z1mv:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">	movl	$<span class="number">3</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">	movl	<span class="number">-4</span>(%rbp), %eax</span><br><span class="line">	popq	%rbp</span><br><span class="line">	.cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	_Z1mv, .-_Z1mv</span><br><span class="line">	.ident	<span class="string">&quot;GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4&quot;</span></span><br><span class="line">	.section	.note.GNU-stack,<span class="string">&quot;&quot;</span>,@progbits</span><br></pre></td></tr></table></figure>
<p>暂时不解析</p>
<h4 id="编译时不需要依赖的调用的实现"><a href="#编译时不需要依赖的调用的实现" class="headerlink" title="编译时不需要依赖的调用的实现"></a>编译时不需要依赖的调用的实现</h4><p>编译期间，都是用的-c生成各种.o文件，进而是静态库或动态库，或者单纯的有main函数的中间文件；<br>这个时候不需要在编译时提供依赖的实现文件，比如依赖的函数实现文件，只需要头文件即可生成；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">dep.h:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">def</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">hello.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dep.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">def</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello.<span class="function">h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：<br>gcc -c hello.cpp</p>
<p>gcc -c main.cpp</p>
<p>生成可执行时才需要链接：这个时候需要所有的实现接口对应点的实现文件：或以库的形式，或以动态库的形式，或者实现文件.o&#x2F;.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">keshixing@ubuntu:~/testld$ g++ -o main main.cpp hello.o</span><br><span class="line">/usr/bin/ld: hello.o: in function `<span class="built_in">hello</span>()<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">hello.cpp:(.text+0x9): undefined reference to `def()&#x27;</span></span><br><span class="line">collect2: error: ld returned <span class="number">1</span> exit status</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里没有实现def()所以报错了；</p>
<p>编译过程中汇编器将汇编文件翻译为.o中间文件，这里汇编器其实已经包含到gcc中了，也可以自己下载一个特定平台的比如：NASM<br>输出可执行程序时，必须实现入口函数，比如main;<br>gcc -o main main.s</p>
<h4 id="编译过程总结："><a href="#编译过程总结：" class="headerlink" title="编译过程总结："></a>编译过程总结：</h4><p>关于编译过程涉及如何将源程序转换为汇编程序，主要是编译器的部分工作，具体是词法分析，语法分析等，有著名的lex,yacc工具，也有<br>对应的状态机等逻辑，内容很多，有兴趣可以看编译原理 龙书；</p>
<p>这里，记录下：对编译后的程序单元，得到的是什么：是一种elf格式的文件，对linux来说；<br>elf文件，有以下几种类型：<br>可重定位文件： relocatable file .o文件<br>可执行文件：executable file<br>共享目标文件：shared object file ，通常是so动态库<br>dump文件： core-dump file </p>
<p>所以编译的结果，是生成第一种elf目标文件；<br>而主要的内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> elf格式头</span><br><span class="line"><span class="number">2</span> elf格式的各个段</span><br><span class="line"><span class="number">3</span> elf各个段的内容，比如代码段，里面包括了编译后的代码等；</span><br><span class="line"><span class="number">4</span> 符号表；</span><br><span class="line"><span class="number">5</span> 。。。</span><br><span class="line"></span><br><span class="line">其中最重要的，就是代码段和数据段，符号表等；</span><br><span class="line">代码段，展示了这个目标文件的功能了流程，数据段，表示了存放的全局数据等，符号表，展示了这个目标文件提供了哪些可以被外部使用的符号，以及</span><br><span class="line">依赖的哪些符号；以便链接使用</span><br></pre></td></tr></table></figure>
<h3 id="具体解释：链接"><a href="#具体解释：链接" class="headerlink" title="具体解释：链接"></a>具体解释：链接</h3><h4 id="基本概述："><a href="#基本概述：" class="headerlink" title="基本概述："></a>基本概述：</h4><ul>
<li>链接的来源：<br>写一个程序，需要定义各种函数，当只有一个源文件，编译为一个可执行程序时，这个时候，调用函数的地方直接填上函数的地址，看起来没什么问题；<br>但是当调整函数的定义时，不考虑其他因素，则函数的基地址在代码段中的位置，又会发生变化，这个时候，调用的位置有需要修改，这个是一个繁琐的工作；</li>
</ul>
<p>于是这里提供了符号的方式，调用函数的地方，转换为符号，根据符号寻找对应的地址，这样，即使修改函数，也不用改调用的地方；</p>
<p>当程序越来越大，拆分为多个目标文件模块，这个时候，对外部符号的链接 ，有两种形式：<br>一种是在产生可执行程序，链接时，将外部符号对应的定义模块，结合<br>到调用的文件中，程序通过符号表和重定位等，转换为正确的地址；程序包含符号对应函数的定义，执行时可以直接运行，不依赖外部库；<br>这种形式是静态链接</p>
<p>另一种形式，在链接时，并不是将实现的代码结合进去，只是带符号，而在运行时，依赖对应的系统上的动态库；执行时再根据调用的符号，到对应<br>的系统上寻找动态库，加载到内存中，来执行；</p>
<ul>
<li>链接的进一步解释和相关命令：<br>关于编译时的链接：<br>我们在编译一个完整的程序时，除了指定含有main函数的程序文件外，这个文件还可能依赖定义在其他源程序中的函数，这个时候，编译时需要指定如：<br>gcc -o main main.cpp func.cpp …<br>有时候这些源文件以编译好的.o的形式呈现，也可以进行：gcc -o main main.cpp func.o<br>而当许多.o需要指定比较麻烦，所以库出现了，用来将.o文件汇总，分为两种形式，一种是静态库，一种是动态库；<br>静态库，就是在编译时将文件的执行代码都聚合到可执行文件中，包括调用的功能函数等，执行时不需要额外的库支持；编译出来的可执行文件会比较大；<br>动态库，即在编译时只是将调用的函数符号指定到符号表中，在执行时才去系统默认库路径(头文件指定的)寻找库,并链接该函数执行；</li>
</ul>
<p>静态链接：在编译时，要指定链接的静态库，包括位置等；<br>eg:<br>gcc -o main main.cpp func.a &#x2F;home&#x2F;zhangsan&#x2F;lib&#x2F;funall.a local&#x2F;local.a<br>动态链接：编译时，需要指定链接的动态库，包括位置等；默认会找默认位置的动态库<br>gcc -o main main.cpp -L.&#x2F;xxx   -lcurl -lpthread<br>-L.&#x2F;xx 为指定了目录下有动态链接库，也可以链接成功；<br>注意形式为：libxxx.so 链接为 -lxxx<br>在运行的时候：<br>ldd a.out这种可以得到可执行文件希望在哪里找到库；而一般要设置export LD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;think&#x2F;c++&#x2F; 或者放在<br>系统默认搜索路径下，或者修改系统文件&#x2F;etc&#x2F;ld.so.conf，添加路径，运行ldconfig命令<br>默认搜索路径：<br>&#x2F;lib<br>&#x2F;usr&#x2F;lib<br>&#x2F;usr&#x2F;local&#x2F;lib </p>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>静态链接用到的技术：</p>
<ul>
<li><p>如何将模块.o文件合并到输出的可执行文件：地址和空间分配<br>需要考虑字节对齐等，每个模块文件的格式都是类似，有各个对应的段，这样可以将相似的段进行合并；<br>比如.text -&gt;.text</p>
</li>
<li><p>符号解析和重定位：<br>在将段合并后，各个符号对应的函数等(相对位置)已经确定了，这样可以进行符号解析，调整代码中的地址等；</p>
</li>
</ul>
<ol>
<li>可以通过objdump -h xx.o 和可执行文件的对比，看到text段等段的相对偏移位置已经确定了；</li>
<li>可以通过objdump -d xx.o 和objdump -d xxmain来对比链接前后，对外部符号如全局变量和函数的汇编语句中的地址数值，是不是<br>从0-&gt;真正的位置；<br>在elf文件中，有个 结构叫重定位表（relocation table),具体见elf格式解析，专门存放和重定位相关的信息；<br>.rel.xxx</li>
<li>链接器会在链接时，去重定位表中找到对应符号的地址，然后进行符号解析，将符号改为正在的相对地址；</li>
</ol>
<ul>
<li>相关命令：<br>1）链接的符号查看： nm xxx.o可以看到提供的符号和依赖的符号；<br>2） ld main.o func.o -e main -o abc -lc</li>
</ul>
<ol start="3">
<li>ar -t libc.a 查看a文件中有哪些o文件；<br>4） gcc -static  –verbose -fno-builtin xx.c 输出详细信息，编译时；</li>
</ol>
<ul>
<li>链接过程控制–链接脚本：<br>链接器提供了多种控制整个链接过程的方法：</li>
</ul>
<ol>
<li>提供命令行来给链接器指定参数；</li>
<li>将链接指令存放在目标文件中；比如vc中经常使用</li>
<li>使用链接脚本：在使用ld时，使用ld -T xxx.script</li>
</ol>
<p>一个例子说明链接脚本是做什么的：<br><a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html">https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html</a></p>
<h3 id="具体解释：装载和动态链接"><a href="#具体解释：装载和动态链接" class="headerlink" title="具体解释：装载和动态链接"></a>具体解释：装载和动态链接</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>进程和程序有什么不同？</p>
<h4 id="进程的虚拟地址空间"><a href="#进程的虚拟地址空间" class="headerlink" title="进程的虚拟地址空间"></a>进程的虚拟地址空间</h4><h4 id="程序装载是什么，装载有什么方式？"><a href="#程序装载是什么，装载有什么方式？" class="headerlink" title="程序装载是什么，装载有什么方式？"></a>程序装载是什么，装载有什么方式？</h4><p>装载其实，就是将磁盘中的程序文件，按一定的格式，载入到内存中；这其中会用到页映射等操作系统对文件和内存管理的部分功能；<br>装载，只是程序转换为进程的其中一个步骤，一个程序，如何转换为一个进程？</p>
<ol>
<li>通过execvl系列函数，建立进程；创建一个独立的虚拟地址空间；</li>
<li>读取可执行文件，将可执行文件映射到进程虚拟地址空间中，并建立各个段-vma 区域，一个vma由多个段组成；</li>
<li>当调度器调度到此进程，将cpu指令寄存器设置为进程中可执行段的入口，启动运行<br>这之后，其实可执行程序并未全部都载入到内存中，在执行过程中，会出现缺页错误，然后操作系统进行处理，但是用户无感知；</li>
</ol>
<h4 id="动态链接："><a href="#动态链接：" class="headerlink" title="动态链接："></a>动态链接：</h4><ul>
<li>为什么要动态链接：<br>如果用静态链接，可执行程序过大，副本多，占用磁盘大，不好传输，模块更新困难等等；<br>动态链接，是在执行程序的过程中发生的：具体来讲，发生在装载的时候；</li>
<li>动态链接如何实现？<br>在linux中，elf动态链接文件叫共享对象 dynamic shared obj<br>动态链接的程序，在程序被装载时，系统的动态链接器会将程序需要的所有动态链接库装载到进程的地址空间，并将所有未决议的符号<br>绑定到相应的动态链接库中，并进行重定位； 注意动态链接器和静态链接器不同；</li>
</ul>
<p>动态链接，会将链接和重定位的工作放到了运行时，这样会导致程序性能下降，但动态链接器也做了一些优化，比如延迟绑定等；</p>
<ul>
<li><p>如何生成动态库：<br>gcc -fPIC -shared -o xx.so xx.c</p>
</li>
<li><p>运行时查看进程的各个段映射：<br>cat &#x2F;proc&#x2F;pid&#x2F;maps</p>
</li>
<li><p>动态链接库中的代码可以被多个程序共享，由此带来重定位的问题：</p>
</li>
</ul>
<ol>
<li><p>原因：<br>动态库被装载时，共享对象，如何确定它在进程虚拟地址空间中的位置？ 装载时重定位，即类似静态链接，在模块装载地址确定时，系统对<br>程序中所有的绝对地址引用进行重定位。但是这个对不同进程来说，会产生不同的地址；所以同一份指令在被多个进程共享时会出现问题。无法做到共享省内存<br>的目的；这种方法其实就是-shared;</p>
</li>
<li><p>进阶：使用-fPIC: 地址无关代码： position-independent-code<br>可以解决以上办法，但是只能有部分可以达到目的：部分指令在多个进程间是无法共享的，所以需要将这部分抽离处理和数据段放在一起；<br>对数据，函数引用来说有以下四种，只有两种可以：<br>(1) 模块内部的函数调用，跳转  相对位置固定，不需要重定位<br>(2) 模块内部的数据访问，比如模块中定义的全局变量，静态变量 相对位置固定，不需要重定位<br>(3) 模块外部函数的调用，跳转   依赖外部符号，需要将其放到数据段，使用全局偏移表 GOT<br>(4) 模块外的数据访问，比如用到了其他模块中定义的全局变量；需要用GOT表<br>使用-fPIC就是用来产生地址无关代码的</p>
</li>
</ol>
<ul>
<li><p>延迟绑定</p>
</li>
<li><p>动态链接相关结构：<br>1）.interp段</p>
</li>
</ul>
<ol start="2">
<li>.dynamic段</li>
<li>动态链接符号表等；<br>4）动态链接重定位表</li>
</ol>
<h3 id="关于编译，链接形成的目标文件；"><a href="#关于编译，链接形成的目标文件；" class="headerlink" title="关于编译，链接形成的目标文件；"></a>关于编译，链接形成的目标文件；</h3><h4 id="关于目标文件："><a href="#关于目标文件：" class="headerlink" title="关于目标文件："></a>关于目标文件：</h4><p>在编译时除了可以生成可执行文件，还可以生产静态库，动态库，中间文件，汇编文件等，这里看静态库和动态库的生成规则<br>生成静态库文件：<br>ar rvs libfunc.a func.o func2.o<br>man ar 查看更多<br>生成动态库文件:<br>gcc func.cpp  -fPIC -shared -o libfunc.so<br>-shared 该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接<br>Produce a shared object which can then be linked with other objects to form an executable.  Not all systems support this option.  For predictable results, you must also specify the same</p>
<p>-fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。<br>更多见man gcc<br>5) 总：<br>一个完整的gcc&#x2F;g++编译命令，除了指定上面的内容，还需要指定头文件的位置，默认目录有哪些？，优化选项，-c&#x2F;-o&#x2F;-S&#x2F;-E其他选项等，这里把这些汇总下，并给上参考地址方便查阅；man gcc<br>-c:  -c  Compile or assemble the source files, but do not link.  The linking stage simply is not done.  The ultimate output is in the form of an object file for each source file.<br>-I: 指定头文件的路径<br>gcc -I. -I &#x2F;home&#x2F;include&#x2F; ..<br>指定了头文件路径后，在#include时可以省略路径；</p>
<h4 id="elf格式"><a href="#elf格式" class="headerlink" title="elf格式"></a>elf格式</h4><p>&#x2F;usr&#x2F;include&#x2F;elf.h中包含了elf文件结构的各个字段格式；<br><a href="https://refspecs.linuxfoundation.org/elf/elf.pdf">https://refspecs.linuxfoundation.org/elf/elf.pdf</a><br>或者书籍： 程序员的自我修养等可以查阅到具体信息；</p>
<h3 id="关于入口函数和运行时库CRT："><a href="#关于入口函数和运行时库CRT：" class="headerlink" title="关于入口函数和运行时库CRT："></a>关于入口函数和运行时库CRT：</h3><p>入口函数不一定是main，在main调用之前，为了程序能顺利运行，需要初始化程序的执行环节，如堆分配初始化等，以及c++中的<br>全局对象构造函数，都在main之前执行，而全局对象的析构函数在main之后被执行；<br>这个依赖于elf中的两种特殊的段： .init .finit<br>所以在链接后，程序最开始运行的，不是main，而是.init中指定的入口函数，它可能包括各种初始化，如运行时库的入口函数，c++全局对象的构造函数，等等；</p>
<ul>
<li>运行时库：<br>一个c运行时库大概包括如下功能：</li>
</ul>
<ol>
<li>启动和退出，包括入口函数及其依赖</li>
<li>标准库函数集合</li>
<li>IO的封装</li>
<li>堆的分配等封装</li>
<li>语言中一些特殊功能实现</li>
<li>调试功能；</li>
</ol>
<p>另外，链接脚本或参数也可以指定不是main作为主函数，而是用别的名字，如ld -e nomain</p>
<h3 id="关键词："><a href="#关键词：" class="headerlink" title="关键词："></a>关键词：</h3><p>ABI： 指的是不同的cpu架构，操作系统，编译器类型甚至版本带来的目标文件差异；<br>BFD库： 为了解决多种cpu，大小端下，可执行程序兼容性问题，提供了统一的格式；</p>
<h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><h5 id="c-x2F-c-的反汇编，二进制查看，可执行文件格式等；"><a href="#c-x2F-c-的反汇编，二进制查看，可执行文件格式等；" class="headerlink" title="c&#x2F;c++的反汇编，二进制查看，可执行文件格式等；"></a>c&#x2F;c++的反汇编，二进制查看，可执行文件格式等；</h5><ol>
<li>可执行文件的结构：<br>think@think-VirtualBox:~&#x2F;c++$ size hh.o<br>text       data        bss        dec        hex    filename<br>  72          0          0         72         48    hh.o<br>代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x&#x3D;3;中的3及const 声明的常量和字符串常量;还有就是代码本身的0101机器码<br>数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）<br>bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null</li>
</ol>
<p>2）如何反汇编；<br>objdump 工具，除了可以反汇编，还可以查看二进制文件等：<br>objdump -s hh.o : 查看十六进制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~/c++$ objdump -s  hh.o</span><br><span class="line"></span><br><span class="line">hh.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> <span class="number">0000</span> <span class="number">554889e5</span> c745fc03 <span class="number">0000008b</span> <span class="number">45f</span>c5dc3  UH...E......E.].</span><br><span class="line">Contents of section .comment:</span><br><span class="line"> <span class="number">0000</span> <span class="number">00474343</span> <span class="number">3</span>a202855 <span class="number">62756e74</span> <span class="number">7520342</span>e  .GCC: (Ubuntu <span class="number">4.</span></span><br><span class="line"> <span class="number">0010</span> <span class="number">382e342</span>d <span class="number">32756275</span> <span class="number">6e747531</span> <span class="number">7e31342</span>e  <span class="number">8.4</span><span class="number">-2u</span>buntu1~<span class="number">14.</span></span><br><span class="line"> <span class="number">0020</span> <span class="number">30342e34</span> <span class="number">2920342</span>e <span class="number">382e3400</span>           <span class="number">04.4</span>) <span class="number">4.8</span><span class="number">.4</span>.    </span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> <span class="number">0000</span> <span class="number">14000000</span> <span class="number">00000000</span> <span class="number">017</span>a5200 <span class="number">01781001</span>  .........zR..x..</span><br><span class="line"> <span class="number">0010</span> <span class="number">1b</span>0c0708 <span class="number">90010000</span> <span class="number">1</span>c000000 <span class="number">1</span>c000000  ................</span><br><span class="line"> <span class="number">0020</span> <span class="number">00000000</span> <span class="number">10000000</span> <span class="number">00410e10</span> <span class="number">8602430</span>d  .........A....C.</span><br><span class="line"> <span class="number">0030</span> <span class="number">064b</span>0c07 <span class="number">08000000</span>                    .K......        </span><br></pre></td></tr></table></figure>

<p> objdump -d hh.o: 反汇编：</p>
<h3 id="运行时："><a href="#运行时：" class="headerlink" title="运行时："></a>运行时：</h3><h5 id="c-x2F-c-文件如何执行，动态链接如何进行；"><a href="#c-x2F-c-文件如何执行，动态链接如何进行；" class="headerlink" title="c&#x2F;c++文件如何执行，动态链接如何进行；"></a>c&#x2F;c++文件如何执行，动态链接如何进行；</h5><p>c&#x2F;c++可执行文件如何执行呢？<br>可执行文件分为完整的非动态链接的可执行文件和完整的静态链接的可执行文件<br>1）静态链接：在.&#x2F;a.out的时候，会通过触发起一个execl系列函数，起一个进程，并开始执行，执行过程即会创建进程空间，内核管理，内核分时间片运行；<br>即作为一个进程来运行，而进程有自己的生命周期：就绪，运行，阻塞等等，也有各种进程上下文，当前的资源等等；<br>总的来讲： 生命周期，进程管理的私有结构，进程的动态空间：堆，栈，虚拟地址空间，各种阻塞队列等等；<br>2）动态链接：动态链接的可执行文件，需要搜索路径下有依赖的动态库，否则无法运行，在运行时会通过链接的符号等去寻找对应的动态库函数实现，加载调用运行；<br>之后的运行和静态链接基本一致；</p>
<h5 id="gdb基础和gdb常用，手册等；"><a href="#gdb基础和gdb常用，手册等；" class="headerlink" title="gdb基础和gdb常用，手册等；"></a>gdb基础和gdb常用，手册等；</h5><p>当编译时带上-g后即带debug信息，运行时即可以进行gdb 运行；<br>gdb main<br>gdb attach 挂的是线程还是进程？<br>见gdb文章</p>
<h4 id="c-程序执行过程调试例子，注意执行语句先后，编译器优化前后不同"><a href="#c-程序执行过程调试例子，注意执行语句先后，编译器优化前后不同" class="headerlink" title="c++程序执行过程调试例子，注意执行语句先后，编译器优化前后不同"></a>c++程序执行过程调试例子，注意执行语句先后，编译器优化前后不同</h4><h4 id="堆栈空间表现例子"><a href="#堆栈空间表现例子" class="headerlink" title="堆栈空间表现例子"></a>堆栈空间表现例子</h4><p>堆栈空间如何增长呢？<br>跟cpu系统有关，暂时不深究；要知道new&#x2F;malloc是在堆上分配空间，普通定义数组，变量是在栈上分配空间；<br>struct class这种的，定义一个非指针变量，是放栈还是堆？</p>
<h4 id="多线程相关调试例子；"><a href="#多线程相关调试例子；" class="headerlink" title="多线程相关调试例子；"></a>多线程相关调试例子；</h4><p>1）查看多线程pid: top -Hp pid<br>2) 多线程是系统层面的，多线程的实现可以是用系统的接口，比如posix的pthread,fork进程等，或者用语言的thread ,这种最后也是调用的pthread系列函数；<br>这里默认都是unix系统；<br>3）使用linux系统工具调试多线程程序；</p>
<h4 id="linux-core-dump机制和相关工具"><a href="#linux-core-dump机制和相关工具" class="headerlink" title="linux core-dump机制和相关工具"></a>linux core-dump机制和相关工具</h4><ol>
<li>core-dump是什么？<br>2）core-dump如何触发？</li>
</ol>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>compilelink</tag>
      </tags>
  </entry>
  <entry>
    <title>memory_overiew</title>
    <url>/2021/03/07/memory-overiew/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="linux内存系统概述"><a href="#linux内存系统概述" class="headerlink" title="linux内存系统概述"></a>linux内存系统概述</h3><p>linux的内存系统是一个很复杂的系统，需要从几个角度去分析，里面包含多种机制，比如虚拟地址和物理地址的转换等等；本文是一个系统性的大局观来从几个方面分析内存系统的记录：<span id="more"></span><br>1 linux内存系统的地址空间：主要解释虚拟内存空间的机制和地址转换关系；<br>2 liunx内存系统的物理内存相关结构和虚拟内存相关结构：主要解释内核用什么样的数据结构来管理内存<br>3 linux内存初始化<br>4 linux内存系统的分配路线：从kernel和用户进程两路分配出发，最后都用到伙伴系统分配内存页；<br>5 linux内存的回收机制简单分析；<br>6 linux下内存的查看等：<br>其中涉及的调试方法和模块代码例子等等，包含在各个子节中；  </p>
<h3 id="linux内存系统的地址空间："><a href="#linux内存系统的地址空间：" class="headerlink" title="linux内存系统的地址空间："></a>linux内存系统的地址空间：</h3><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>一般来说，linux系统在使用时，只要一块物理内存，或者说，即使外部插入多个内存，最后再使用时，也是一个物理内存的地址空间;最开始的系统，使用内存都是直接通过取物理地址写入读取的;<br>而演变为采用虚拟地址空间，并通过MMU地址转换为物理地址，再访问真正的物理内存，其作用，一方面是进一步保护内存防止滥用和增加控制，另一方面，也对每个进程之间起到隔离作用，加强保护；<br>另外，还可以避免因为直接操作物理内存的情况下，不同进程操作时地址的不连续性带来更高的复杂度，更多作用，我想通过进一步学习，可以加深理解；</p>
<h4 id="虚拟地址空间："><a href="#虚拟地址空间：" class="headerlink" title="虚拟地址空间："></a>虚拟地址空间：</h4><ul>
<li>简介：<br>一般来说，linux内核把处理器的虚拟地址空间分为两个部分，底部比较大的部分用于用户进程，顶部则是专用于内核；所以在两个用户进程上下文切换的时候，只会改变下半部分；<br>而内核部分总是不变；所以不同的用户进程，有不同的虚拟地址空间，也就是说，两个不同的进程中的两个变量可以有相同的虚拟地址，但是实际物理内存确是不同的；<br>划分比如4G的内存，1G给到内核，3G给到用户空间；当然可以通过配置修改这种比例；  </li>
<li>举例<br>   内核和用户进程，在操作时，变量等结构，函数等打印出来的指针(地址)，是虚拟地址，而实际写入和读取的数据是放在物理内存的，是有唯一的物理内存地址的，那虚拟地址是如何对应到物理内存地址的呢？<br>   这个涉及到虚拟地址到物理地址的转换–MMU,借助MMU，linux可以把虚拟地址通过某种映射转换为物理地址；</li>
<li>MMU(内存管理单元):<br>   是计算机系统的一个物理部件，通常是CPU的一部分(但不一定)， linux的MMU是一个很复杂的模块，本文暂时不会进行详细的分析，等后面有时间再深入研究：<br>  关于MMU是如何将虚拟地址转换为物理地址的过程，可以参考下图：<img src="/2021/03/07/memory-overiew/MMU.png" class="" title="MMU about"></li>
</ul>
<h3 id="linux内存系统的相关结构："><a href="#linux内存系统的相关结构：" class="headerlink" title="linux内存系统的相关结构："></a>linux内存系统的相关结构：</h3><p>主要分为这几个部分：</p>
<ul>
<li><p>基础的，物理内存：</p>
</li>
<li><p>和MMU相关的</p>
</li>
<li><p>和虚拟内存相关的：和内核相关的，和用户进程相关的；</p>
<h4 id="基础的，物理内存："><a href="#基础的，物理内存：" class="headerlink" title="基础的，物理内存："></a>基础的，物理内存：</h4></li>
<li><p>NUMA概念：VM中流行的第一个主要概念是非均匀内存访问(NUMA)。在大型机器中，内存可能被根据与处理器的“距离”而产生不同的存取成本，划分为多个部分(结点)。例如，可能有一个内存库分配给每个CPU或一个内存库非常适合DMA近设备卡。每个部分称为一个node,由挂在同一个CPU下的一片连续的物理内存组成，在内核中使用pg_data_t进行抽象.<br>可以从linux&#x2F;mmzone.h来找到相关结构：</p>
<img src="/2021/03/07/memory-overiew/NUMA.png" class="" title="NUMA about">

</li>
<li><p>NUMA的结点node和相关的结构：zone:  </p>
<img src="/2021/03/07/memory-overiew/numa_zone.png" class="" title="numa_zone about">
<p>由于一些特殊的应用场景，导致只能分配特定地址范围内的内存（比如老式的ISA设备DMA时只能使用前16M内存；比如kmalloc只能分配低端内存，而不能分配高端内存），因此在node中又将内存细分为zone。<br>zone 有以下几种类型，由zone结构中的flags标识；  </p>
<ol>
<li>ZONE_DMA：定义适合DMA的内存域，该区域的长度依赖于处理器类型。比如ARM所有地址都可以进行DMA，所以该值可以很大，或者干脆不定义DMA类型的内存域。而在IA-32的处理器上，一般定义为16M。  </li>
<li>ZONE_DMA32：只在64位系统上有效，为一些32位外设DMA时分配内存。如果物理内存大于4G，该值为4G，否则与实际的物理内存大小相同。  </li>
<li>ZONE_NORMAL：定义可直接映射到内核空间的普通内存域。在64位系统上，如果物理内存小于4G，该内存域为空。而在32位系统上，该值最大为896M。  </li>
<li>ZONE_HIGHMEM：只在32位系统上有效，标记超过896M范围的内存。在64位系统上，由于地址空间巨大，超过4G的内存都分布在ZONE_NORMA内存域。     </li>
<li>ZONE_MOVABLE：伪内存域，为了实现减小内存碎片的机制。</li>
</ol>
</li>
<li><p>zone结构下的free_area,free_list和伙伴系统：<br>简单的说，就是zone下维护的free_area,是维护2^n个page的内存块的链表的数据结构，用来方便分配指定大小的内存页以及进行合并，拆分等，解决页外碎片的机制：<br>更详细可以参考：<a href="http://blog.chinaunix.net/uid-30282771-id-5185451.html">http://blog.chinaunix.net/uid-30282771-id-5185451.html</a><br>或者翻阅资料；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cat /proc/buddyinfo </span><br><span class="line">Node <span class="number">0</span>, zone      DMA      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">3</span> </span><br><span class="line">Node <span class="number">0</span>, zone    DMA32      <span class="number">4</span>      <span class="number">2</span>      <span class="number">3</span>     <span class="number">28</span>    <span class="number">149</span>     <span class="number">21</span>     <span class="number">13</span>      <span class="number">8</span>      <span class="number">1</span>      <span class="number">2</span>    <span class="number">178</span> </span><br><span class="line">Node <span class="number">0</span>, zone   Normal      <span class="number">2</span>     <span class="number">84</span>     <span class="number">46</span>     <span class="number">23</span>     <span class="number">13</span>     <span class="number">13</span>     <span class="number">15</span>     <span class="number">21</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span> </span><br></pre></td></tr></table></figure></li>
<li><p>page：即物理页，物理内存是按页为单元进行分配管理的，一页通常是4k</p>
</li>
<li><p>以下是在linux4.8中以上各个数据结构的定义：<br>linux&#x2F;mmzone.h pg_data_t:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">pglist_data</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">zone</span> node_zones[MAX_NR_ZONES];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">zonelist</span> node_zonelists[MAX_ZONELISTS];</span><br><span class="line">	<span class="type">int</span> nr_zones;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP	<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">page</span> *node_mem_map;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">page_ext</span> *node_page_ext;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_NO_BOOTMEM</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">bootmem_data</span> *bdata;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must be held any time you expect node_start_pfn, node_present_pages</span></span><br><span class="line"><span class="comment">	 * or node_spanned_pages stay constant.  Holding this will also</span></span><br><span class="line"><span class="comment">	 * guarantee that any pfn_valid() stays that way.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment">	 * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_start_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages; <span class="comment">/* total size of physical page</span></span><br><span class="line"><span class="comment">					     range, including holes */</span></span><br><span class="line">	<span class="type">int</span> node_id;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span> *kswapd;	<span class="comment">/* Protected by</span></span><br><span class="line"><span class="comment">					   mem_hotplug_begin/end() */</span></span><br><span class="line">	<span class="type">int</span> kswapd_order;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">zone_type</span> kswapd_classzone_idx;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="type">int</span> kcompactd_max_order;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">zone_type</span> kcompactd_classzone_idx;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span> *kcompactd;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">	<span class="comment">/* Lock serializing the migrate rate limiting window */</span></span><br><span class="line">	<span class="type">spinlock_t</span> numabalancing_migrate_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Rate limiting time interval */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> numabalancing_migrate_next_window;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of pages migrated during the rate limiting time interval */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> numabalancing_migrate_nr_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a per-node reserve of pages that are not available</span></span><br><span class="line"><span class="comment">	 * to userspace allocations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">	<span class="built_in">ZONE_PADDING</span>(_pad1_)</span><br><span class="line">	<span class="type">spinlock_t</span>		lru_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">	 * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">	<span class="type">spinlock_t</span> split_queue_lock;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> split_queue;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> split_queue_len;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lruvec</span>		lruvec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on</span></span><br><span class="line"><span class="comment">	 * this node&#x27;s LRU.  Maintained by the pageout code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inactive_ratio;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ZONE_PADDING</span>(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-node vmstats */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">per_cpu_nodestat</span> __percpu *per_cpu_nodestats;</span><br><span class="line">	<span class="type">atomic_long_t</span>		vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br><span class="line"><span class="type">pg_data_t</span>中描述了node的所有基本元素：</span><br><span class="line">    <span class="number">1</span>) node_zones: 该node包含的内存域zone</span><br><span class="line">    <span class="number">2</span>) node_zonelists：该node的备选节点及内存域列表，后面会详细说明。</span><br><span class="line">    <span class="number">3</span>) node_mem_map：linux为每个物理页分配了一个<span class="keyword">struct</span> <span class="title class_">page</span>的管理结构体，并形成了一个结构体数组，node_mem_map即为数组的指针；pfn_to_page和page_to_pfn都借助该数组实现。</span><br><span class="line">    <span class="number">4</span>) node_start_pfn：该node中内存的起始页帧号</span><br><span class="line">    <span class="number">5</span>) node_present_pages：该node中所有的物理page页数</span><br><span class="line">    <span class="number">6</span>) node_spanned_pages：该node地址范围内的所有page页数，包括空洞；目前还不清楚什么情况导致与node_present_pages不同。</span><br><span class="line">    <span class="number">7</span>) kswapd：负责回收该node内存的内核线程，每个node对应一个内核线程kswapd。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>zone:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">zone</span> &#123;</span><br><span class="line">	<span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> watermark[NR_WMARK];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We don&#x27;t know if the memory that we&#x27;re going to allocate will be freeable</span></span><br><span class="line"><span class="comment">	 * or/and it will be released eventually, so to avoid totally wasting several</span></span><br><span class="line"><span class="comment">	 * GB of ram we must reserve some of the lower zone memory (otherwise we risk</span></span><br><span class="line"><span class="comment">	 * to run OOM on the lower zones despite there&#x27;s tons of freeable ram</span></span><br><span class="line"><span class="comment">	 * on the higher zones). This array is recalculated at runtime if the</span></span><br><span class="line"><span class="comment">	 * sysctl_lowmem_reserve_ratio sysctl changes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on</span></span><br><span class="line"><span class="comment">	 * this zone&#x27;s LRU.  Maintained by the pageout code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inactive_ratio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">pglist_data</span>	*zone_pgdat;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">per_cpu_pageset</span> __percpu *pageset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a per-zone reserve of pages that should not be</span></span><br><span class="line"><span class="comment">	 * considered dirtyable memory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		dirty_balance_reserve;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment">	 * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		zone_start_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">	 * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">	 * 	spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">	 * is calculated as:</span></span><br><span class="line"><span class="comment">	 *	present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">	 * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">	 * bootmem allocator):</span></span><br><span class="line"><span class="comment">	 *	managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">	 * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">	 * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">	 * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">	 * and thresholds.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Locking rules:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">	 * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">	 * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">	 * quite infrequently.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">	 * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment">	 * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">	 * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment">	 * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Read access to managed_pages should be safe because it&#x27;s unsigned</span></span><br><span class="line"><span class="comment">	 * long. Write access to zone-&gt;managed_pages and totalram_pages are</span></span><br><span class="line"><span class="comment">	 * protected by managed_page_count_lock at runtime. Idealy only</span></span><br><span class="line"><span class="comment">	 * adjust_managed_page_count() should be used instead of directly</span></span><br><span class="line"><span class="comment">	 * touching zone-&gt;managed_pages and totalram_pages.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		managed_pages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		spanned_pages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		present_pages;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of MIGRATE_RESERVE page block. To maintain for just</span></span><br><span class="line"><span class="comment">	 * optimization. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span>			nr_migrate_reserve_block;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment">	 * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment">	 * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">	<span class="type">seqlock_t</span>		span_seqlock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * wait_table		-- the array holding the hash table</span></span><br><span class="line"><span class="comment">	 * wait_table_hash_nr_entries	-- the size of the hash table array</span></span><br><span class="line"><span class="comment">	 * wait_table_bits	-- wait_table_size == (1 &lt;&lt; wait_table_bits)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The purpose of all these is to keep track of the people</span></span><br><span class="line"><span class="comment">	 * waiting for a page to become available and make them</span></span><br><span class="line"><span class="comment">	 * runnable again when possible. The trouble is that this</span></span><br><span class="line"><span class="comment">	 * consumes a lot of space, especially when so few things</span></span><br><span class="line"><span class="comment">	 * wait on pages at a given time. So instead of using</span></span><br><span class="line"><span class="comment">	 * per-page waitqueues, we use a waitqueue hash table.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The bucket discipline is to sleep on the same queue when</span></span><br><span class="line"><span class="comment">	 * colliding and wake all in that wait queue when removing.</span></span><br><span class="line"><span class="comment">	 * When something wakes, it must check to be sure its page is</span></span><br><span class="line"><span class="comment">	 * truly available, a la thundering herd. The cost of a</span></span><br><span class="line"><span class="comment">	 * collision is great, but given the expected load of the</span></span><br><span class="line"><span class="comment">	 * table, they should be so rare as to be outweighed by the</span></span><br><span class="line"><span class="comment">	 * benefits from the saved space.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __wait_on_page_locked() and unlock_page() in mm/filemap.c, are the</span></span><br><span class="line"><span class="comment">	 * primary users of these fields, and in mm/page_alloc.c</span></span><br><span class="line"><span class="comment">	 * free_area_init_core() performs the initialization of them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span>	*wait_table;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		wait_table_hash_nr_entries;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		wait_table_bits;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ZONE_PADDING</span>(_pad1_)</span><br><span class="line">	<span class="comment">/* free areas of different sizes */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">free_area</span>	free_area[MAX_ORDER];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone flags, see below */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ZONE_PADDING</span>(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		lru_lock;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lruvec</span>		lruvec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Evictions &amp; activations on the inactive file list */</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		inactive_age;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">	 * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">	 * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		compact_cached_free_pfn;</span><br><span class="line">	<span class="comment">/* pfn where async and sync compaction migration scanner should start */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		compact_cached_migrate_pfn[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">	 * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">	 * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		compact_considered;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		compact_defer_shift;</span><br><span class="line">	<span class="type">int</span>			compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">	<span class="type">bool</span>			compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ZONE_PADDING</span>(_pad3_)</span><br><span class="line">	<span class="comment">/* Zone statistics */</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
<p>free_area:注意在zone定义中数组大小只有11，意味着是只支持到2^10个页大小的内存块</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">free_area</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	free_list[MIGRATE_TYPES];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">/include/linux/mm_types.h</span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each physical page in the system has a struct page associated with</span></span><br><span class="line"><span class="comment"> * it to keep track of whatever it is we are using the page for at the</span></span><br><span class="line"><span class="comment"> * moment. Note that we have no way to track which tasks are using</span></span><br><span class="line"><span class="comment"> * a page, though if it is a pagecache page, rmap structures can tell us</span></span><br><span class="line"><span class="comment"> * who is mapping it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The objects in struct page are organized in double word blocks in</span></span><br><span class="line"><span class="comment"> * order to allows us to use atomic double word operations on portions</span></span><br><span class="line"><span class="comment"> * of struct page. That is currently only used by slub but the arrangement</span></span><br><span class="line"><span class="comment"> * allows the use of atomic double word operations on the flags/mapping</span></span><br><span class="line"><span class="comment"> * and lru list pointers also.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">page</span> &#123;</span><br><span class="line">	<span class="comment">/* First double word block */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;		<span class="comment">/* Atomic flags, some possibly</span></span><br><span class="line"><span class="comment">					 * updated asynchronously */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">address_space</span> *mapping;	<span class="comment">/* If low bit clear, points to</span></span><br><span class="line"><span class="comment">						 * inode address_space, or NULL.</span></span><br><span class="line"><span class="comment">						 * If page mapped as anonymous</span></span><br><span class="line"><span class="comment">						 * memory, low bit is set, and</span></span><br><span class="line"><span class="comment">						 * it points to anon_vma object:</span></span><br><span class="line"><span class="comment">						 * see PAGE_MAPPING_ANON below.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">		<span class="type">void</span> *s_mem;			<span class="comment">/* slab first object */</span></span><br><span class="line">		<span class="type">atomic_t</span> compound_mapcount;	<span class="comment">/* first tail page */</span></span><br><span class="line">		<span class="comment">/* page_deferred_list().next	 -- second tail page */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Second double word */</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="keyword">union</span> &#123;</span><br><span class="line">			<span class="type">pgoff_t</span> index;		<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">			<span class="type">void</span> *freelist;		<span class="comment">/* sl[aou]b first free object */</span></span><br><span class="line">			<span class="comment">/* page_deferred_list().prev	-- second tail page */</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line"><span class="meta">	defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span></span><br><span class="line">			<span class="comment">/* Used for cmpxchg_double in slub */</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Keep _count separate from slub cmpxchg_double data.</span></span><br><span class="line"><span class="comment">			 * As the rest of the double word is protected by</span></span><br><span class="line"><span class="comment">			 * slab_lock but _count is not.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="type">unsigned</span> counters;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">union</span> &#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * Count of ptes mapped in mms, to show</span></span><br><span class="line"><span class="comment">					 * when page is mapped &amp; limit reverse</span></span><br><span class="line"><span class="comment">					 * map searches.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					<span class="type">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">struct</span> &#123; <span class="comment">/* SLUB */</span></span><br><span class="line">						<span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">						<span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">						<span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">					&#125;;</span><br><span class="line">					<span class="type">int</span> units;	<span class="comment">/* SLOB */</span></span><br><span class="line">				&#125;;</span><br><span class="line">				<span class="type">atomic_t</span> _count;		<span class="comment">/* Usage count, see below. */</span></span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> active;	<span class="comment">/* SLAB */</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Third double word block</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * WARNING: bit 0 of the first word encode PageTail(). That means</span></span><br><span class="line"><span class="comment">	 * the rest users of the storage space MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">	 * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">list_head</span> lru;	<span class="comment">/* Pageout list, eg. active_list</span></span><br><span class="line"><span class="comment">					 * protected by zone-&gt;lru_lock !</span></span><br><span class="line"><span class="comment">					 * Can be used as a generic list</span></span><br><span class="line"><span class="comment">					 * by the page owner.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">dev_pagemap</span> *pgmap; <span class="comment">/* ZONE_DEVICE pages are never on an</span></span><br><span class="line"><span class="comment">					    * lru or handled by a slab</span></span><br><span class="line"><span class="comment">					    * allocator, this points to the</span></span><br><span class="line"><span class="comment">					    * hosting device page map.</span></span><br><span class="line"><span class="comment">					    */</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;		<span class="comment">/* slub per cpu partial pages */</span></span><br><span class="line">			<span class="keyword">struct</span> <span class="title class_">page</span> *next;	<span class="comment">/* Next partial slab */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">			<span class="type">int</span> pages;	<span class="comment">/* Nr of partial slabs left */</span></span><br><span class="line">			<span class="type">int</span> pobjects;	<span class="comment">/* Approximate # of objects */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="type">short</span> <span class="type">int</span> pages;</span><br><span class="line">			<span class="type">short</span> <span class="type">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rcu_head</span> rcu_head;	<span class="comment">/* Used by SLAB</span></span><br><span class="line"><span class="comment">						 * when destroying via RCU</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">		<span class="comment">/* Tail pages of compound page */</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> compound_head; <span class="comment">/* If bit zero is set */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* First tail page only */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * On 64 bit system we have enough space in struct page</span></span><br><span class="line"><span class="comment">			 * to encode compound_dtor and compound_order with</span></span><br><span class="line"><span class="comment">			 * unsigned int. It can help compiler generate better or</span></span><br><span class="line"><span class="comment">			 * smaller code on some archtectures.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> compound_dtor;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> compound_dtor;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> __pad;	<span class="comment">/* do not overlay pmd_huge_pte</span></span><br><span class="line"><span class="comment">						 * with compound_head to avoid</span></span><br><span class="line"><span class="comment">						 * possible bit 0 collision.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">			<span class="type">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">		&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remainder is not double word aligned */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">private</span>;		<span class="comment">/* Mapping-private opaque data:</span></span><br><span class="line"><span class="comment">					 	 * usually used for buffer_heads</span></span><br><span class="line"><span class="comment">						 * if PagePrivate set; used for</span></span><br><span class="line"><span class="comment">						 * swp_entry_t if PageSwapCache;</span></span><br><span class="line"><span class="comment">						 * indicates order in the buddy</span></span><br><span class="line"><span class="comment">						 * system if PG_buddy is set.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_SPLIT_PTE_PTLOCKS</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">		<span class="type">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="type">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">kmem_cache</span> *slab_cache;	<span class="comment">/* SL[AU]B: Pointer to slab */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mem_cgroup</span> *mem_cgroup;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment">	 * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment">	 * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment">	 * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment">	 * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment">	 * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">	<span class="type">void</span> *<span class="keyword">virtual</span>;			<span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">					   not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * kmemcheck wants to track the status of each byte in a page; this</span></span><br><span class="line"><span class="comment">	 * is a pointer to such a status block. NULL if not tracked.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">	<span class="type">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The struct page can be forced to be double word aligned so that atomic ops</span></span><br><span class="line"><span class="comment"> * on double words work. The SLUB allocator can make use of such a feature.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_ALIGNED_STRUCT_PAGE</span></span><br><span class="line">	__aligned(<span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<h5 id="实践：操作zone等："><a href="#实践：操作zone等：" class="headerlink" title="实践：操作zone等："></a>实践：操作zone等：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">  * Author: ksx</span></span><br><span class="line"><span class="comment">  * File name: sysctl_example.c</span></span><br><span class="line"><span class="comment">  * Description: sysctl example</span></span><br><span class="line"><span class="comment">  * Date: 2021-02-26</span></span><br><span class="line"><span class="comment">  *********************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sysctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/swap.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/topology.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/mm_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">page</span> *pages = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">sysctl_example_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    pages = <span class="built_in">alloc_pages</span>(GFP_KERNEL,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(!pages) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;alloc_pages Successfully!\n&quot;</span>); </span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;page_address(pages) = 0x%lx\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">long</span>)<span class="built_in">page_address</span>(pages));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zone</span> *arr = <span class="built_in">NODE_DATA</span>(<span class="built_in">numa_node_id</span>())-&gt;node_zones;</span><br><span class="line">   <span class="comment">// printk(KERN_INFO,&quot;zone: some:%ld\n&quot;,z1.managed_pages);</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zonelist</span> *zoneli = <span class="built_in">node_zonelist</span>(<span class="built_in">numa_node_id</span>(),GFP_KERNEL);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> free_areasize = <span class="built_in">sizeof</span>(arr-&gt;free_area)/<span class="built_in">sizeof</span>(arr-&gt;free_area[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">free_area</span> *fa = arr-&gt;free_area;</span><br><span class="line">    <span class="type">int</span> freearea0_nrfree = arr-&gt;free_area[<span class="number">0</span>].nr_free;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;sysctl registercess %ld num_node_id:%d freeareasize :%u freelist:: %ld nr_free:%d\n&quot;</span>,<span class="built_in">nr_free_buffer_pages</span>(),<span class="built_in">numa_node_id</span>(),free_areasize,<span class="built_in">sizeof</span>(fa-&gt;free_list)/<span class="built_in">sizeof</span>(fa-&gt;free_list[<span class="number">0</span>]),freearea0_nrfree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">sysctl_example_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;sysctl unregister success.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pages) </span><br><span class="line">    &#123;</span><br><span class="line">        __free_pages(pages,<span class="number">8</span>);   <span class="comment">// 释放所分配的</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;__free_pages ok!\n&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module_init</span>(sysctl_example_init);</span><br><span class="line"><span class="built_in">module_exit</span>(sysctl_example_exit);</span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="和MMU相关的："><a href="#和MMU相关的：" class="headerlink" title="和MMU相关的："></a>和MMU相关的：</h4><ul>
<li>TLB:<br>地址转换需要几次内存访问，内存访问相对CPU速度较慢。为了避免在地址转换上花费宝贵的处理器周期，cpu维护了一个名为翻译后备缓冲区(translation Lookaside Buffer, TLB)的此类转换缓存。</li>
<li>Huge Pages:Linux中有两种机制支持将物理内存映射到大页面。第一个是HugeTLB文件系统，或hugetlbfs。它是一个使用RAM作为后备存储的伪文件系统。对于在该文件系统中创建的文件，数据驻留在内存中，并使用大页进行映射。</li>
<li>page tables:页表,页表是用来建立用户进程虚拟地址空间和系统物理内存(页帧等)之间的关联：即通过上述图1可以看到线性(虚拟)地址和页表的关系，linux用三级甚至4级页表来管理内存页<br>通过页表，每个进程提供一致的虚拟地址空间，应用程序看到的地址空间是一个连续的内存区，该表也将虚拟内存页映射到物理内存，进而支持共享内存的实现，即几个进程共享的内存；<br>相关结构： &#x2F;asm-arch&#x2F;page.h  asm-arch&#x2F;pgtable.h和具体的体系架构相关；</li>
</ul>
<p>每个进程都有一个指针(mm_struct→pgd)指向它自己的页全局目录(pgd)， pgd是一个物理页帧。这个框架包含一个类型为pgd_t的数组，pgd_t是在&lt;asm&#x2F;page.h&gt;中定义的架构特定类型。根据架构的不同，页表的加载方式也不同。在x86上，通过将mm_struct→pgd复制到cr3寄存器来加载进程页表，这有冲洗TLB的副作用。事实上，这就是函数__flush_tlb()在依赖于体系结构的代码中实现的方式。<br>PGD表中的每个活动条目指向一个包含pmd_t类型的页中间目录(PMD)项数组的页框架，该页框架又指向一个包含pte_t类型的页表项(PTE)的页框架，pte_t类型的页表项最终指向包含实际用户数据的页框架。如果页面被交换到后备存储，交换项将存储在PTE中，并在页面故障期间由do_swap_page()使用，以查找包含页面数据的交换项。  </p>
<p>页表项的一些操作函数:pgd_alloc(如 &#x2F;arch&#x2F;arm64&#x2F;mm&#x2F;pgd.c),pte_page,pud_alloc等等  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">页表：层次化的页表用于支持对大地址空间的快速，高效管理；</span><br><span class="line">用于建立用户进程的虚拟地址空间和系统物理内存（内存，页帧）之间的关联</span><br><span class="line">页表也用于向每个进程提供一致的虚拟地址空间，应用程序看到的地址空间是一个连续的内存区，该表也将虚拟内存页映射到物理内存，因而支持共享内存的实现；</span><br><span class="line">内核内存管理使用四级页表，不管底层处理器，一个页表有<span class="number">1024</span>项，每项对应一个页(<span class="number">4</span>K)</span><br><span class="line">内存虚拟地址的分解：</span><br><span class="line">页表格式：   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * These are used to make use of C type-checking..</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="type">unsigned</span> <span class="type">long</span> pte; &#125; <span class="type">pte_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="type">unsigned</span> <span class="type">long</span> pmd; &#125; <span class="type">pmd_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS == 4</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="type">unsigned</span> <span class="type">long</span> pud; &#125; <span class="type">pud_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="type">unsigned</span> <span class="type">long</span> pgd; &#125; <span class="type">pgd_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="type">unsigned</span> <span class="type">long</span> pgprot; &#125; <span class="type">pgprot_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">page</span> *<span class="type">pgtable_t</span>;</span><br><span class="line"></span><br><span class="line">用于处理内存页的体系结构相关状态的函数以及页表项操作函数</span><br></pre></td></tr></table></figure>
<img src="/2021/03/07/memory-overiew/pgtable.png" class="" title="pgtable about">
<img src="/2021/03/07/memory-overiew/pgtable2.png" class="" title="pgtable about">
<p>更多参考：<a href="https://www.kernel.org/doc/gorman/html/understand/understand006.html">https://www.kernel.org/doc/gorman/html/understand/understand006.html</a></p>
<ul>
<li>和虚拟内存相关的：<br>内核相关：<br>内核内存分配器：slab&#x2F;slub&#x2F;slob,具体使用场景和机制见下 内核的内存分配<br>eg:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">slab</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> list;		<span class="comment">//slab描述符的三个双向循环链表中的一个</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> colouroff;	<span class="comment">//slab中第一个对象</span></span><br><span class="line">	<span class="type">void</span> *s_mem;			<span class="comment">//slab中第一个对象的地址</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inuse;		<span class="comment">//当前正在使用的slab中的对象的个数</span></span><br><span class="line">	<span class="type">kmem_bufctl_t</span> free;		<span class="comment">//slab中第一个空闲对象的下标。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> nodeid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>用户进程相关：具体怎么用见下 用户进程的内存分配<br>&#x2F;include&#x2F;linux&#x2F;mm_types.h vm_area_struct<br>在 task_struct-&gt;mm_struct-&gt;vm_area_struct* 链表  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct defines a memory VMM memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task.  A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vm_area_struct</span> &#123;</span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vm_area_struct</span> *vm_next, *vm_prev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rb_node</span> vm_rb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mm_struct</span> *vm_mm;	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="type">pgprot_t</span> vm_page_prot;		<span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">	 * linkage into the address_space-&gt;i_mmap interval tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rb_node</span> rb;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> rb_subtree_last;</span><br><span class="line">	&#125; shared;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">	 * list, after a COW of one of the file pages.	A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">	 * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> anon_vma_chain; <span class="comment">/* Serialized by mmap_sem &amp;</span></span><br><span class="line"><span class="comment">					  * page_table_lock */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">anon_vma</span> *anon_vma;	<span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">vm_operations_struct</span> *vm_ops;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Information about our backing store: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">					   units */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file</span> * vm_file;		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">	<span class="type">void</span> * vm_private_data;		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vm_region</span> *vm_region;	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mempolicy</span> *vm_policy;	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vm_userfaultfd_ctx</span> vm_userfaultfd_ctx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="linux内存初始化简介："><a href="#linux内存初始化简介：" class="headerlink" title="linux内存初始化简介："></a>linux内存初始化简介：</h3><ul>
<li><p>概述：<br>初始化大都是建立全局数据结构并做初始化，设置系统状态，寄存器等等，linux内存也是大致如此；<br>linux内存初始化有个过程比较特别，就是在建立起这个内存管理之前，也要内存，但是此时是不能用内存管理接口的，那在这期间，是使用了一个额外的简化形式的内存管理模块(bootmem)<br>在初始化完成内存管理后，再丢弃掉；<br>linux内存初始化主要是体系架构相关的初始化和机器无关的初始化：前者主要是统计系统可用内存总数，以及cpu模型，结点node数量和内存域之间的分配情况，后者主要是建立起前面介绍的各个必要结构，比如pg_data_t;前者完成后，才能完成后者；<br>我们可以通过一个宏 mmzone.h: #define NODE_DATA(nid)        (&amp;contig_page_data) 来获取到对应node编号的 pg_data_t实例，进而进行操作；  </p>
</li>
<li><p>系统启动时内存的的初始化流程：<br>在初始化过程中主要包含以下几个步骤，在如下源文件中：<br>依然是从：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> arch/ia64/kernel/head.S, line <span class="number">413</span></span><br><span class="line">    arch/arm64/kernel/head.S, line <span class="number">453</span></span><br><span class="line">    等都能找到其调用start_kernel，这个函数就是用来启动内核；</span><br><span class="line">    注意这个头文件：include/linux/start_kernel.h, line <span class="number">11</span> (as a prototype)</span><br><span class="line">    和这个实现文件：init/main.c, line <span class="number">849</span> (as a function)</span><br><span class="line">```c</span><br><span class="line">    head.S -&gt;<span class="built_in">start_kernel</span>(init/main.c)</span><br><span class="line">      <span class="built_in">lock_kernel</span>();<span class="comment">//首先让lock_depth变量自增，然后判断结果是否为0，如果是，则进行对信号量的自减操作，类似于PV操作</span></span><br><span class="line">   <span class="built_in">start_kernel</span>()函数会做很多init初始化，里面自然也有内存相关的初始化：</span><br><span class="line">       setup_arch 体系结构相关的初始化</span><br><span class="line">       setup_per_cpu_areas 每个cpu的初始化</span><br><span class="line">       build_all_zonelists 初始化建立结点和内存区域</span><br><span class="line">       mem_init  特定于体系结构的，用于停用bootmem分配器并迁移到内存管理函数</span><br><span class="line">       kmem_cache_init:初始化内核内部小块内存区的分配器</span><br><span class="line">       setup_per_cpu_pageset：zone下为pageset数组的第一个数组元素分配内存，分配第一个数组元素；</span><br><span class="line">关于结点和内存域初始化：</span><br><span class="line">```cpp</span><br><span class="line">在page_alloc.c 中</span><br><span class="line"><span class="function"><span class="type">void</span> __init <span class="title">build_all_zonelists</span><span class="params">(<span class="type">void</span>)</span>遍历所有结点进行初始化</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; numnodes ; i++)</span><br><span class="line">		<span class="built_in">build_zonelists</span>(<span class="built_in">NODE_DATA</span>(i));<span class="comment">//通过这个结构可以拿到所有的node_data[] pg_data_t</span></span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;Built %i zonelists\n&quot;</span>, numnodes);</span><br><span class="line">&#125;</span><br><span class="line">free_area: mmzone.h </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">free_area</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	free_list[MIGRATE_TYPES];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过模块类似的获取机制，来获取当前系统的页详情，以及分配时的动态变化；<br>build_zonelists：这个函数任务为：在当前处理的结点的内存域和其他结点的内存域之间建立一个等级次序，并下来按这种次序分配内存；<br>等级次序例子：内存要分配高端内存，则首先企图在当前结点的高端内存中找一个大小合适的空闲段，若失败，则查看该结点的普通内存域，若还是失败，则看<br>该结点的DMA内存域进行分配，还失败就去找其他结点；备选结点要尽量靠近主结点；<br>层次结构：<br>首先分配高端内存：廉价，在于内核没有任何部分依赖该内存域分配的内存；<br>接着普通内存：许多内核数据结构必须保存在该区域，而不能放置在高端内存域；普通内存用尽就紧急；<br>最后是DMA内存域，它用于外设和系统的数据传输；<br>没有再考虑其他内存结点 ；备选结点也有一个等级次序；</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">在初始化后，物理内存大致是这样分布的：</span><br><span class="line">&#123;% asset_img memlayout.png memlayout %&#125;</span><br><span class="line">我们也可以在procfs中查看：</span><br><span class="line">```cpp</span><br><span class="line">sudo cat /<span class="keyword">proc</span>/iomem</span><br><span class="line">00000000-00000fff :<span class="title"> reserved</span></span><br><span class="line">00001000-0009fbff :<span class="title"> System</span> RAM</span><br><span class="line">0009fc00-0009ffff :<span class="title"> reserved</span></span><br><span class="line">000a0000-000bffff :<span class="title"> PCI</span> Bus 0000:00</span><br><span class="line">000c0000-000c7fff :<span class="title"> Video</span> ROM</span><br><span class="line">000e2000-000ef3ff :<span class="title"> Adapter</span> ROM</span><br><span class="line">000f0000-000fffff :<span class="title"> reserved</span></span><br><span class="line">  000f0000-000fffff :<span class="title"> System</span> ROM</span><br><span class="line">00100000-dffeffff :<span class="title"> System</span> RAM</span><br><span class="line">  01000000-0182e000 :<span class="title"> Kernel</span> code</span><br><span class="line">  0182e001-01f4dfff :<span class="title"> Kernel</span> data</span><br><span class="line">  020cd000-02207fff :<span class="title"> Kernel</span> bss<span class="title"></span></span><br><span class="line"><span class="title">dfff0000-dfffffff</span> :<span class="title"> ACPI</span> Tables<span class="title"></span></span><br><span class="line"><span class="title">e0000000-fdffffff</span> :<span class="title"> PCI</span> Bus 0000:00<span class="title"></span></span><br><span class="line"><span class="title">  e0000000-e0ffffff</span> : 0000:00:02.0<span class="title"></span></span><br><span class="line"><span class="title">    e0000000-e0ffffff</span> :<span class="title"> vmwgfx</span> probe<span class="title"></span></span><br><span class="line"><span class="title">  f0000000-f01fffff</span> : 0000:00:02.0<span class="title"></span></span><br><span class="line"><span class="title">    f0000000-f01fffff</span> :<span class="title"> vmwgfx</span> probe<span class="title"></span></span><br><span class="line"><span class="title">  f0200000-f021ffff</span> : 0000:00:03.0<span class="title"></span></span><br><span class="line"><span class="title">    f0200000-f021ffff</span> :<span class="title"> e1000</span></span><br><span class="line"><span class="title">  f0400000-f07fffff</span> : 0000:00:04.0<span class="title"></span></span><br><span class="line"><span class="title">    f0400000-f07fffff</span> :<span class="title"> vboxguest</span></span><br><span class="line"><span class="title">  f0800000-f0803fff</span> : 0000:00:04.0<span class="title"></span></span><br><span class="line"><span class="title">  f0804000-f0804fff</span> : 0000:00:06.0<span class="title"></span></span><br><span class="line"><span class="title">    f0804000-f0804fff</span> :<span class="title"> ohci_hcd</span></span><br><span class="line"><span class="title">  f0806000-f0807fff</span> : 0000:00:0d.0<span class="title"></span></span><br><span class="line"><span class="title">    f0806000-f0807fff</span> :<span class="title"> ahci</span></span><br><span class="line">fec00000-fec00fff :<span class="title"> reserved</span></span><br><span class="line"><span class="title">  fec00000-fec003ff</span> :<span class="title"> IOAPIC</span> 0<span class="title"></span></span><br><span class="line"><span class="title">fee00000-fee00fff</span> :<span class="title"> Local</span> APIC<span class="title"></span></span><br><span class="line"><span class="title">  fee00000-fee00fff</span> :<span class="title"> reserved</span></span><br><span class="line">fffc0000-ffffffff :<span class="title"> reserved</span></span><br><span class="line">100000000-11fffffff :<span class="title"> System</span> RAM</span><br><span class="line"></span><br><span class="line">如果想看BIOS等占用的物理内存情况，也可以<span class="title"></span></span><br><span class="line"><span class="title"> dmesg|</span> grep<span class="title"> BIOS</span></span><br><span class="line">[    0.000000]<span class="title"> e820:</span> BIOS-provided<span class="title"> physical</span> RAM<span class="title"> map:</span></span><br><span class="line">[    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x0000000000000000-0x000000000009fbff]<span class="title"> usable</span></span><br><span class="line">[    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x000000000009fc00-0x000000000009ffff]<span class="title"> reserved</span></span><br><span class="line">[    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000000f0000-0x00000000000fffff]<span class="title"> reserved</span></span><br><span class="line">[    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x0000000000100000-0x00000000dffeffff]<span class="title"> usable</span></span><br><span class="line">[    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000dfff0000-0x00000000dfffffff]<span class="title"> ACPI</span> data</span><br><span class="line">[    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000fec00000-0x00000000fec00fff]<span class="title"> reserved</span></span><br><span class="line">[    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000fee00000-0x00000000fee00fff]<span class="title"> reserved</span></span><br><span class="line">[    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x00000000fffc0000-0x00000000ffffffff]<span class="title"> reserved</span></span><br><span class="line">[    0.000000]<span class="title"> BIOS-e820:</span> [mem 0x0000000100000000-0x000000011fffffff]<span class="title"> usable</span></span><br><span class="line">[    0.000000]<span class="title"> SMBIOS</span> 2.5<span class="title"> present.</span></span><br><span class="line">[    0.000000]<span class="title"> DMI:</span> innotek<span class="title"> GmbH</span> VirtualBox/VirtualBox,<span class="title"> BIOS</span> VirtualBox 12/01/2006</span><br><span class="line">[    0.000000]<span class="title"> ACPI:</span> DSDT 0x00000000DFFF0470 002325 (v02<span class="title"> VBOX</span> <span class="title">  VBOXBIOS</span> 00000002<span class="title"> INTL</span> 20100528)</span><br><span class="line">[    0.000000]<span class="title"> Calgary:</span> detecting<span class="title"> Calgary</span> via<span class="title"> BIOS</span> EBDA<span class="title"> area</span></span><br><span class="line">[    5.020947]<span class="title"> BIOS</span> EDD<span class="title"> facility</span> v0.16 2004-Jun-25, 0<span class="title"> devices</span> found</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多见源码和其他文章参考：eg: <a href="https://www.kernel.org/doc/gorman/html/understand/understand008.html">https://www.kernel.org/doc/gorman/html/understand/understand008.html</a></p>
</li>
</ul>
<h3 id="linux内存分配："><a href="#linux内存分配：" class="headerlink" title="linux内存分配："></a>linux内存分配：</h3><h4 id="linux内存分配图谱："><a href="#linux内存分配图谱：" class="headerlink" title="linux内存分配图谱："></a>linux内存分配图谱：</h4><img src="/2021/03/07/memory-overiew/allalloc.png" class="" title="allalloc">

<h4 id="linux内存用户进程分配"><a href="#linux内存用户进程分配" class="headerlink" title="linux内存用户进程分配:"></a>linux内存用户进程分配:</h4><h5 id="用于进程内存相关机制："><a href="#用于进程内存相关机制：" class="headerlink" title="用于进程内存相关机制："></a>用于进程内存相关机制：</h5><p> A:简介：</p>
<ul>
<li>进程的虚拟地址空间技术使得不同进程可以同时运行，而不会干扰到其他进程的内存；而所有进程的关联，在于物理内存中的页帧和所有进程虚拟地址空间中的页之间的关联：逆向映射，从虚拟内存页追踪物理页，缺页处理：从块设备读取数据填充虚拟地址空间；</li>
<li>在巨大的线性地址空间中有很少的段可以用于各个用户空间进程，这些段需要被内核管理</li>
<li>内核信任自身，不信任用户进程，所以用户进程在操作地址时需要接受权限等的检查</li>
<li>fork-exec模型：写时复制</li>
</ul>
<p>B:进程虚拟地址空间</p>
<ul>
<li>用户进程：0–TASK_SIZE-1 ,其上是内核地址 (虚拟地址：内核1G,进程3G：32位）<br>进程地址空间布局：text段，动态库代码,全局变量和动态产生数据的堆，局部变量和实现函数的栈，环境变量和命令行参数的段，将文件内容映射到虚拟地址空间中的内存映射；（mm_type.h: 见mm_struct的定义)</li>
<li>建立内存空间布局：<br>(1) 输入.&#x2F;xxx文件运行时，由exec系统调用执行，并通过load_elf_binary函数装载一个ELF二进制文件，elf装载涉及太复杂流程，只看重要的；<br>(2) randomsize_via_space设置，用于启动地址随机化，可能会拖慢cpu速度<br>(3) 布局工作由arch_pick_mmap_layout完成，和体系结构相关；用户通过&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;legacy_va_layout输出得到指示，是执行新布局还是旧布局，无非是栈的上界确定和mmap的上下界确定等，最后确定栈的开始位置，mmap开始位置和堆的开始位置等等，这样便完成了布局<br>到这个时候，就会建立在task结构中的mm结构中，初始化各个段的位置，比如text段，堆栈段开始结束等；也会建立起vm_area_struct;<br>这里可能会有个疑问，就是vm_area_struct和进程中的数据段，代码段和堆栈段的关系：可能会认为一个vm_area_struct就是一个段，可能是代码段和数据段，但是实际实践发现不是；<br>vm_area_struct是进程中的内存区域，或者说是内存单元：其本身结构中的字段决定了它的大小，通常是页的整数倍，而数据段代码段等，mm_struct中已经有字段来表明边界；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/pid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">sysctl_example_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pid</span> *tpid = <span class="built_in">find_get_pid</span>(<span class="number">12473</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *task = <span class="built_in">pid_task</span>(tpid,PIDTYPE_PID);</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;the state of the task is:%d\n&quot;</span>,task-&gt;state);     <span class="comment">// 显示任务当前所处的状态</span></span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;the pid of the task is:%d\n&quot;</span>,task-&gt;pid);         <span class="comment">// 显示任务的进程号</span></span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;the pid of current thread is:%d\n&quot;</span>,current-&gt;pid);<span class="comment">// 显示当前进程的进程号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mm_struct</span> * mm_task=<span class="built_in">get_task_mm</span>(task);             <span class="comment">// 获取任务的内存描述符   </span></span><br><span class="line">     <span class="built_in">printk</span>(<span class="string">&quot;the mm_users of the mm_struct is:%d\n&quot;</span>,mm_task-&gt;mm_users);</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;the mm_count of the mm_struct is:%d\n total vm :%ld exec_vm:%ld&quot;</span>,mm_task-&gt;mm_count,mm_task-&gt;total_vm,mm_task-&gt;exec_vm); </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">vm_area_struct</span> *vm= mm_task-&gt;mmap;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;mmap base:%016x ,task_size:%016x,start_code:%016x,end_code:%016x,start_data:%016x, end_data:%016x,start_brk:%016x,endbrk:%016x, start_stack:%016x\n&quot;</span>,mm_task-&gt;mmap_base,mm_task-&gt;task_size,mm_task-&gt;start_code,mm_task-&gt;end_code,mm_task-&gt;start_data,mm_task-&gt;end_data,mm_task-&gt;start_brk,mm_task-&gt;brk,mm_task-&gt;start_stack);</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;the first vmarea:start:%016x ,end:%016x\n&quot;</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;the  vmarea:start:%016x ,end:%016x\n&quot;</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;the first vmarea:start:%016x ,end:%016x\n&quot;</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;the first vmarea:start:%016x ,end:%016x\n&quot;</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;the first vmarea:start:%016x ,end:%016x\n&quot;</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    vm++;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;the first vmarea:start:%016x ,end:%016x\n&quot;</span>,vm-&gt;vm_start,vm-&gt;vm_end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">sysctl_example_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;sysctl unregister success.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module_init</span>(sysctl_example_init);</span><br><span class="line"><span class="built_in">module_exit</span>(sysctl_example_exit);</span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">结果举例：dmesg</span><br><span class="line">[<span class="number">41928.340021</span>] the state of the task is:<span class="number">0</span></span><br><span class="line">[<span class="number">41928.340023</span>] the pid of the task is:<span class="number">12473</span></span><br><span class="line">[<span class="number">41928.340024</span>] the pid of current thread is:<span class="number">14907</span></span><br><span class="line">[<span class="number">41928.340025</span>] the mm_users of the mm_struct is:<span class="number">6</span></span><br><span class="line">[<span class="number">41928.340026</span>] the mm_count of the mm_struct is:<span class="number">1</span></span><br><span class="line">[<span class="number">41928.340026</span>]  total vm :<span class="number">1083</span> exec_vm:<span class="number">478</span>mmap base:<span class="number">00000000007</span>de000 ,task_size:<span class="number">00000000f</span>ffff000,start_code:<span class="number">0000000000400000</span>,end_code:<span class="number">0000000000400</span>af4,start_data:<span class="number">0000000000600e10</span>, end_data:<span class="number">0000000000601054</span>,start_brk:<span class="number">00000000014b</span>2000,endbrk:<span class="number">00000000014</span>d3000, start_stack:<span class="number">000000005</span>a04e590</span><br><span class="line">[<span class="number">41928.340029</span>] the first vmarea:start:<span class="number">0000000000400000</span> ,end:<span class="number">0000000000401000</span></span><br><span class="line">[<span class="number">41928.340030</span>] the  vmarea:start:<span class="number">00000000005b</span>2000 ,end:<span class="number">00000000005b</span>4000</span><br><span class="line">[<span class="number">41928.340031</span>] the first vmarea:start:<span class="number">0000000000600000</span> ,end:<span class="number">0000000000601000</span></span><br><span class="line">[<span class="number">41928.340033</span>] the first vmarea:start:<span class="number">00000000005b</span>4000 ,end:<span class="number">00000000005b</span>9000</span><br><span class="line">[<span class="number">41928.340034</span>] the first vmarea:start:<span class="number">000000005</span>a061000 ,end:<span class="number">000000005</span>a063000</span><br><span class="line">[<span class="number">41928.340035</span>] the first vmarea:start:<span class="number">00000000007</span>db000 ,end:<span class="number">00000000007</span>dc000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
C:内存映射原理：</li>
<li>前言：实际上进程此时用的还是虚拟内存，那么怎么和物理页关联？实际上物理页有限，虚拟空间大，所以，只有最常用的部分才和物理页关联；大多程序也只占一小部分内存；</li>
<li>进程经常要从文件中读取数据，文件存放于磁盘上，于是，将磁盘上的文件映射到内存则很关键，涉及文件读写和磁盘文件的更新；而实际的映射过程，只是用了几页来存储文件结尾的数据，而文件开始处，则内核只需在地址空间保存相关信息如：数据位置，数据如何读取即可(PS:这些不是保存在进程中的结构吗？ ),text段也类似，只有在需要时才加载；</li>
<li>用户进程访问一个内存地址的过程：<br>虚拟地址–&gt;页表–&gt;确定物理页(有则读取)–&gt;无，出发缺页异常发送到内核-&gt;内核检查进程并找到适当的后备存储器(和文件系统相关),分配物理页并填充来自后备存储器的数据–&gt;借助页表将物理页并入用户进程地址空间，进程恢复执行；</li>
</ul>
<p>– &gt;     malloc-&gt;do_brk–&gt;写时复制，缺页异常—&gt;到vm_area_struct找，vma_fault–&gt;page—&gt;没有做alloc_page ，这样的流程；</p>
<p>D:详细阐述：数据结构mm_struct：vmarea_struct mmap虚拟内存区域列表 ; rb_root mm_rb;  vm_area_struct *mmap_cache上一个find_vma结果(上次处理的区域）<br>树和链表：每个区域都通过一个vmarea_struct实例描述，进程的各区域(如text段等)按两种方式排序：在一个单链表上(开始于mm_struct-&gt;mmap)&#x2F;在一个红黑树中，根位于mm_rb; (task_struct-&gt;mm)即一个进程只有一个mm;</p>
<img src="/2021/03/07/memory-overiew/vmareatree.png" class="" title="vmareatree">
<p>而其实多个mm会连接起来形成全局链表：</p>
<img src="/2021/03/07/memory-overiew/moremm.png" class="" title="moremm">

<p>虚拟内存区域 vmarea_struct详解：<br>优先查找树结构：一个文件往往关联了多个进程：为了建立一个文件中的一个区域与该区域映射到的所有虚拟地址空间的关联，使用了优先查找树；</p>
<ol>
<li>struct file: 每个打开的文件(和每个块设备，因为也可以和内存映射)都会表示为struct file的一个实例，该结构包含了一个指向地址空间对象struct address_space的指针(和后备存储器相关),关联是优先查找树的基础；其文件区间与其映射到的地址空间之间的关联即通过优先树建立；stuct file 和struct address_space见源码</li>
<li>另外，每个文件和块设备都表示为struct inode的一个实例，struct file是通过open调用时打开的文件抽象，而inode 则是文件系统自身中的对象；<br>struct inode: address_space *i_mapping; 注意每个file是特定于给定进程的，也就是每个进程都有其file成员；<img src="/2021/03/07/memory-overiew/mm_file.png" class="" title="moremm">
E 对区域的操作：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">将虚拟地址关联到区域:通过虚拟地址，借助find_vma函数可以查找用户地址空间中结束地址在给定地址后的第一个区域；</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vm_area_struct</span> * <span class="built_in">find_vma</span>(<span class="keyword">struct</span> mm_struct * mm, <span class="type">unsigned</span> <span class="type">long</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vm_area_struct</span> *vma = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mm) &#123;</span><br><span class="line">		<span class="comment">/* Check the cache first. */</span> <span class="comment">//先检查缓存，也就是上次使用的内存；</span></span><br><span class="line">		<span class="comment">/* (Cache hit rate is typically around 35%.) */</span></span><br><span class="line">		vma = mm-&gt;mmap_cache;</span><br><span class="line">		<span class="keyword">if</span> (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123;<span class="comment">//不行再查找区域红黑树；</span></span><br><span class="line">			<span class="keyword">struct</span> <span class="title class_">rb_node</span> * rb_node;</span><br><span class="line"></span><br><span class="line">			rb_node = mm-&gt;mm_rb.rb_node;</span><br><span class="line">			vma = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (rb_node) &#123;</span><br><span class="line">				<span class="keyword">struct</span> <span class="title class_">vm_area_struct</span> * vma_tmp;</span><br><span class="line"></span><br><span class="line">				vma_tmp = <span class="built_in">rb_entry</span>(rb_node,</span><br><span class="line">						<span class="keyword">struct</span> vm_area_struct, vm_rb);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;</span><br><span class="line">					vma = vma_tmp;</span><br><span class="line">					<span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					rb_node = rb_node-&gt;rb_left;</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					rb_node = rb_node-&gt;rb_right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (vma)</span><br><span class="line">				mm-&gt;mmap_cache = vma;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
区域合并：当新区域被加到进程的地址空间时，内核会检查它是否可以与一个或多个现存区域合并：无非检查地址是否相邻等等<br>插入区域： insert_vm_struct函数，实际工作：将区域插入红黑树；<br>创建区域：需要检查虚拟地址空间中是否还有足够的空闲空间来插入新区域；get_unmapped_area</li>
</ol>
<p>F:地址空间：文件和进程的内存映射：可以看是文件系统对于的地址空间和用户进程虚拟地址空间的关联映射；<br>vm_operations_struct结构：用于建立两个地址空间的关联和通信；</p>
<h5 id="用户进程内存分配的流程："><a href="#用户进程内存分配的流程：" class="headerlink" title="用户进程内存分配的流程："></a>用户进程内存分配的流程：</h5><p>malloc–&gt; chunks<br>  __brk:&#x2F;__map–&gt;<br>    sys_brk&#x2F;sys_mmap_pgoff: 找vm_area_struct<br>       无：缺页异常 ，操作vm_area_struct:-&gt;ops-&gt;vm_fault-&gt;page<br>         –伙伴系统 alloc_page</p>
<img src="/2021/03/07/memory-overiew/malloc.png" class="" title="malloc">

<h4 id="linux内存内核分配："><a href="#linux内存内核分配：" class="headerlink" title="linux内存内核分配："></a>linux内存内核分配：</h4><p>总的来说，有如下几种分配：</p>
<ul>
<li>kmalloc&#x2F;kzmalloc: 小内存的分配</li>
<li>kmem_cache_alloc: 特定内存大小的内存分配</li>
<li>vmalloc:不连续的大内存分配，多个页</li>
<li>alloc_page:底层分配，分配多个页；<h5 id="slab机制"><a href="#slab机制" class="headerlink" title="slab机制"></a>slab机制</h5></li>
</ul>
<p>针对页内碎片的slab分配技术：将页拆分，分配小单元内存<br>slab分配器：分配比4K更小的内存；提供要经常分配的缓存结构如struct fs_struct;slab着色；slab分配器命名由来<br>PS：slab分配器负责完成与伙伴系统的交互，来分配所需的页</p>
<p>备选分配器：slob分配器；slub分配器</p>
<p>slab分配的原理：<br>下图：缓存即高速缓存kmem_cache 结构，也叫slab缓存由两部分组成：保存管理性数据的缓存对象(kmem_cache)和保存被管理对象的各个slab<br>(1)每个缓存只负责一种对象类型(如struct unix_sock实例，通过&#x2F;proc&#x2F;slabinfo可看到),或提供一般性缓冲区(kmalloc分配时用);各个缓存中slab数目各有不同<br>(2)各个缓存都保持在一个双向链表中cache_chain,内核有机会遍历他们</p>
<img src="/2021/03/07/memory-overiew/slab.png" class="" title="slab">


<ul>
<li>详细缓存结构(kmem_cache)<br>下图：重要成员1：<br>   array_cache :保存了各个cpu最后释放的对象：在分配和释放这些对象时，采用后进先出原理，内核假定刚释放的对象仍然处于CPU高速缓存中，会尽快再次分配它<br>                      仅当per-CPU缓存为空时，才会用slab中的空闲对象重新填充它们<br>   由此形成三级的分配体系：按照分配成本和操作对CPU高速缓存和TLB的负面影响逐级升高：<br>   (1) 仍然处于CPU高速缓存中的per-CPU对象<br>   (2) 现存于slab中的未使用对象<br>   (3)刚使用伙伴系统分配的新slab中未使用的对象<br>  重要成员2：kmem_list3:每个内存结点都对应3个表头，用于组织slab链表；完全用尽的slab,部分空闲的slab和空闲的slab<img src="/2021/03/07/memory-overiew/slaball.png" class="" title="slaball"></li>
<li>slab结构解释：<br> (1)对象在slab中非连续排列，用于每个对象的长度非确切大小，舍入和对齐了；<br> (2)slab创建时有两种方案对齐：1可使用标志SLAB_HWCACHE_ALIGN，slab用户可以按照要求按硬件缓存行对齐，cache_line_size返回值进行；2 不按照硬件对齐<br> (3)填充字节情况；链接了第一个对象，所以slab首部可以不用和slab对象在一起<br> (4)另外 page结构包含了一个链表元素，用于管理各种链表中的页，但是slab缓存不用，用于：<br> page-&gt;lru.next指向页驻留的缓存的管理结构  kmem_cache<br> page-&gt;lru.prev指向保存该页的slab的管理结构 slab<br> 设置或读取slab信息分别由set_page_slab和get_page_slab函数完成，带有__cache后缀的函数则处理缓存信息的设置和读取：<br>mm&#x2F;slab.c:2.6版本：<br>page_set_cache</li>
</ul>
<p>*page_get_cache<br>page_set_slab<br>*page_get_slab<br>此外，内核还对分配给slab分配器的各个物理页都设置标志PG_SLAB</p>
<img src="/2021/03/07/memory-overiew/slablist.png" class="" title="slablist">

<ul>
<li>kmem_cache_系列实现：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)数据结构详情：主要是对slab中涉及的kmem_cache,slab,kmem_list3等中的成员做详细的介绍；略</span><br><span class="line">(<span class="number">2</span>)初始化slab系统：</span><br><span class="line">    一个问题：为初始化slab数据结构，内核需要若干远小于一页的内存块（slab中的<span class="selector-tag">object</span>要分配内存，不然为空指针), 这些由kmalloc分配，但是kmaloc需要在slab启动后才能用；</span><br><span class="line">   解决：涉及kmalloc中的per-CPU缓存的初始化：需要一些技巧：</span><br><span class="line">       <span class="selector-tag">A</span>: kmem_cache_init初始化slab分配器：在伙伴系统启动后调用：</span><br><span class="line">           创建系统中第一个slab缓存，以便为kmem_cache的实例提供内存，内核此时使用的主要是在编译时创建的静态数据，一个静态数据结构(initarray_cache)用作per-CPU数组，缓存名为cache_cache;</span><br><span class="line">           接着，初始化一般性缓存，用于kmalloc内存来源：调用kmem_cache_create，存在cache_cache需要借助kmalloc，但是kmalloc又需要借助它的问题：</span><br><span class="line">                     内核使用g_cpucache_up变量解决，类似状态机；在合适的时候才用更大的缓存</span><br><span class="line">           最后，将kmalloc动态分配的版本替换为slab对象的数据结构</span><br><span class="line">(<span class="number">3</span>)创建缓存：创建新的slab缓存必须调用kmem_cache_create；调用后可读的name会出现在/proc/slabinfo中；</span><br><span class="line">(<span class="number">4</span>)分配对象：kmem_cache_alloc:用于从特定的高速缓存kmem_cache获取对象，类似于所有的malloc函数；</span><br><span class="line">(<span class="number">5</span>)释放对象：kmem_cache_free</span><br><span class="line">(<span class="number">6</span>)销毁缓存：kmem_cache_destroy</span><br></pre></td></tr></table></figure></li>
<li>通用缓存:kamlloc:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">通用缓存：若不涉及特殊对象如<span class="keyword">struct</span> <span class="title class_">unix_sock</span>,而是传统的分配/释放内存，则必须调用kmalloc和kfree函数，这两个函数相当于c的malloc和free</span><br><span class="line">          需要注意的是：这里的内存分配采用的所有可用的长度：<span class="number">2</span>的幂次：</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cache_sizes</span> malloc_sizes[] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE(x) &#123;.cs_size = (x) &#125;,</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#if (PAGE_SIZE == 4096)</span></span><br><span class="line"><span class="comment">	CACHE(32)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">	CACHE(64)</span></span><br><span class="line"><span class="comment">#if L1_CACHE_BYTES &lt; 64	// L1_CACHE_BYTES = 128</span></span><br><span class="line"><span class="comment">	CACHE(96)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">	CACHE(128)</span></span><br><span class="line"><span class="comment">#if L1_CACHE_BYTES &lt; 128</span></span><br><span class="line"><span class="comment">	CACHE(192)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">	CACHE(256)</span></span><br><span class="line"><span class="comment">	CACHE(512)</span></span><br><span class="line"><span class="comment">	CACHE(1024)</span></span><br><span class="line"><span class="comment">	CACHE(2048)</span></span><br><span class="line"><span class="comment">	CACHE(4096)</span></span><br><span class="line"><span class="comment">	CACHE(8192)</span></span><br><span class="line"><span class="comment">	CACHE(16384)</span></span><br><span class="line"><span class="comment">	CACHE(32768)</span></span><br><span class="line"><span class="comment">	CACHE(65536)</span></span><br><span class="line"><span class="comment">	CACHE(131072)</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 262144</span></span><br><span class="line"><span class="comment">	CACHE(262144)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 524288</span></span><br><span class="line"><span class="comment">	CACHE(524288)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 1048576</span></span><br><span class="line"><span class="comment">	CACHE(1048576)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 2097152</span></span><br><span class="line"><span class="comment">	CACHE(2097152)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 4194304</span></span><br><span class="line"><span class="comment">	CACHE(4194304)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 8388608</span></span><br><span class="line"><span class="comment">	CACHE(8388608)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 16777216</span></span><br><span class="line"><span class="comment">	CACHE(16777216)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if KMALLOC_MAX_SIZE &gt;= 33554432</span></span><br><span class="line"><span class="comment">	CACHE(33554432)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="built_in">CACHE</span>(ULONG_MAX);</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CACHE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="linux内存内核分配的选择："><a href="#linux内存内核分配的选择：" class="headerlink" title="linux内存内核分配的选择："></a>linux内存内核分配的选择：</h5></li>
<li>概述：<br>分配小的chunks 使用 kmalloc或kmem_cache_alloc 家族函数<br>分配大的虚拟的连续区域，使用vmalloc和它的变种函数，或者你可以直接请求页，从页的分配器 with alloc_pages;分配器也可能使用的是更专业的比如 cma_alloc或 zs_malloc</li>
</ul>
<p>许多内存分配器都使用GFP flags来表达内存应该怎么被分配。 这个GFP标志是给到get free pages的，是底层的分配函数<br>分配api的多样性和众多的GFP标志使得“我应该如何分配内存?”这并不容易回答，尽管你很可能会用<br>kzalloc(<size>, GFP_KERNEL);</p>
<ul>
<li>关于Get Free Page FLags:<br>GFP(get free page)标志，控制分配器的行为，他们告知什么内存zones被使用，分配器应该如何努力寻找空闲内存，内存是否可以被用户空间访问等<br>内存管理api提供了GFP标志及其组合的参考文档，这里我们简要概述了它们的推荐用法:</li>
</ul>
<ol>
<li>大多数情况下，GFP_KERNEL正是您所需要的。用于内核数据结构的内存、DMAable内存、索引节点缓存，所有这些以及许多其他分配类型都可以使用GFP_KERNEL。注意，使用GFP_KERNEL意味着GFP_RECLAIM，这意味着直接回收可能会在内存压力下触发;必须允许调用上下文休眠。</li>
</ol>
<p>2)如果分配从一个原子上下文执行，例如中断处理程序，使用GFP_NOWAIT。这个标志防止直接回收IO或文件系统操作。因此，在内存压力下，GFP_NOWAIT分配很可能失败。有合理回退的分配应该使用GFP_NOWARN。</p>
<p>3)如果你认为你访问的内存储备是合理的，且除非内核分配成功，否则会给内核带来压力的话，可以用GFP_ATOMIC;</p>
<p>4)从用户空间触发的不受信任的分配，应该被当成一个分配统计对象，并且有__GFP_ACCOUNT这个标志被设置；即GFP_KERNEL_ACCOUNT;</p>
<p>5)用户空间分配应该使用GFP_USER、GFP_HIGHUSER或 GFP_HIGHUSER_MOVABLE  ;标志名越长，限制越小；<br>GFP_HIGHUSER_MOVABLE不要求内核可以直接访问已分配的内存，这意味着数据是可移动的。<br>GFP_HIGHUSER表示所分配的内存是不可移动的，但是内核不需要直接访问它。一个例子可能是硬件分配，它将数据直接映射到用户空间，但没有寻址限制。<br>GFP_USER表示所分配的内存是不可移动的，必须由内核直接访问。</p>
<p>6)您可能注意到，现有代码中有相当多的分配指定了GFP_NOIO或GFP_NOFS。历史上，它们被用来防止由于直接内存回收调用FS或IO路径和阻塞已经占用的资源而引起的递归死锁。从4.12开始，解决这个问题的首选方法是使用FS&#x2F;IO上下文中使用的GFP掩码中描述的新的作用域api。<br>7)其他遗留的GFP标志是GFP_DMA和GFP_DMA32。它们用于确保具有有限寻址能力的硬件可以访问所分配的内存。所以，除非你正在为一个有这样限制的设备编写驱动程序，否则不要使用这些标志。即使是有限制的硬件，使用dma_alloc* api也是可取的。</p>
<ul>
<li>GFP flags和它的回收内存行为，即多个和一起：</li>
</ul>
<p>1)GFP_KERNEL &amp; ~__GFP_RECLAIM -乐观分配，根本没有尝试释放内存。最轻的重量模式，甚至不触发后台回收。应该谨慎使用，因为它可能会耗尽内存，下一个用户可能会更主动地回收内存。<br>2)GFP_KERNEL &amp; ~__GFP_DIRECT_RECLAIM(或GFP_NOWAIT)-乐观分配，不尝试从当前上下文释放内存，但可以唤醒kswapd回收内存，如果该区域低于低水位。可以在原子上下文中使用，也可以在请求进行性能优化时使用，对于慢路径有另一种退路。<br>3)(GFP_KERNEL|__GFP_HIGH) &amp; ~__GFP_DIRECT_RECLAIM(又名GFP_ATOMIC) -非睡眠分配，具有昂贵的回退，因此它可以访问部分内存储备。通常从中断&#x2F;下半部分上下文使用一个昂贵的慢路径回退。</p>
<p>4)GFP_KERNEL -允许后台和直接回收，并使用默认的页面分配器行为。这意味着不昂贵的分配请求基本上是不会失败的，但没有这种行为的保证，所以失败必须由调用者正确地检查(例如，OOM killer 异常是<br>允许失败的）<br>5)GFP_KERNEL | __GFP_NORETRY -覆盖默认的分配器行为，所有的分配请求在早期失败，而不是导致中断回收(在这个实现中是一轮回收)。OOM杀手没有被调用。<br>6)GFP_KERNEL | __GFP_RETRY_MAYFAIL -覆盖默认的分配器行为和所有的分配请求尝试真正努力。如果回收不能取得任何进展，请求将失败。OOM杀手不会被触发。</p>
<p>7)GFP_KERNEL | __GFP_NOFAIL -覆盖默认的分配器行为，所有的分配请求将不断循环，直到它们成功。这可能真的很危险，特别是对大订单来说。</p>
<ul>
<li>如何选择正确的内存分配器：<br> 1 最直接的方式就是用 kmalloc，当然，安全的是初始化内存为0，如kzalloc(),若想分配给一个数组，则有kmalloc_array(),和kcalloc() ;辅助函数：struct_size(),array_size(),array3_size();用来防止溢出；<br>不过，用kmalloc分配的chunk的最大长度是被限制的，实际限制依赖于硬件和内核配置，但是好的实践是，分配的对象比页的大小小；用kmalloc分配的块的地址至少对齐到ARCH_KMALLOC_MINALIGN字节<br>对于2的幂次大小，对齐也保证至少是各自的大小。用kmalloc()分配的块可以用krealloc()调整大小。与kmalloc_array()类似:以krealloc_array()的形式提供了调整数组大小的帮助器。</li>
</ul>
<p>2 对于大的分配来说，可以用vmalloc和vzalloc，或直接用页分配器；用vmalloc和相关联的函数分配可能不是物理上连续的内存；<br>如果您不确定分配大小对于kmalloc来说是否太大，则可以使用kvmalloc()及其衍生物。它将尝试使用kmalloc分配内存，如果分配失败，它将使用vmalloc重试。对于哪些GFP标志可以用于kvmalloc有一些限制;请参阅kvmalloc_node()参考文档。注意，kvmalloc可能返回的内存不是物理上连续的。</p>
<p>3 如果你需要分配许多相同的对象，你可以使用slab缓存分配器。在使用缓存之前，应该使用kmem_cache_create()或kmem_cache_create_usercopy()来设置缓存。如果缓存的一部分可能被复制到用户空间，则应该使用第二个函数。创建缓存之后，kmem_cache_alloc()及其方便的包装器可以从缓存中分配内存。<br>当分配的内存不再需要时，必须释放它。可以对kmalloc、vmalloc和kvmalloc分配的内存使用kvfree()。slab缓存应该使用kmem_cache_free()来释放。不要忘记使用kmem_cache_destroy()来销毁缓存。</p>
<h5 id="kmalloc和kmem-cache-系列的区别："><a href="#kmalloc和kmem-cache-系列的区别：" class="headerlink" title="kmalloc和kmem_cache_系列的区别："></a>kmalloc和kmem_cache_系列的区别：</h5><p>来源于网上比较好的回答：<br>Here is the brief description about how kernel manages memory.<br>In order to manage small sized physical memory allocation, kernel uses slab<br>allocator. Slab allocator maintains two types of caches</p>
<ol>
<li>Generalized Caches of memory pools</li>
<li>Specialized caches of memory pools.</li>
</ol>
<p>Generalized caches contains small memory objects of sizes 8, 16, 32,<br>64,….512, 1024, 2048, 4096, 8192 bytes. These are named as kmalloc’ed<br>caches because kernel allocates memory from these caches when kmalloc is<br>used to to allocate memory.<br>These caches are created at the boot initialization phase. Ref<br>&#x2F;proc&#x2F;slabinfo for the list of kmalloc-ed caches.</p>
<p>Not always the user of the kernel will use the objects of the size<br>maintained by the generalized cache. For Eg. In case of Ethernet driver, the<br>driver has to allocate memory for the size 1500 bytes.<br>In this case, if the driver has to allocate memory using kmalloc, it has to<br>allocate a minimum of 2048 bytes per packet, thus wasting almost 550 bytes<br>for every allocation of memory per packet.<br>Hence kernel allows for the driver to create a specialized cache which<br>contains the memory objects of the size specified by user.<br>i.e. In the above example the driver can create his own cache of memory<br>objects of size 1500 bytes by using following KPIs</p>
<ol>
<li>kmem_cache_create - Creates a specialized cache</li>
<li>kmem_cache_alloc - allocates memory from a specialized cache</li>
<li>kmem_cache_free - frees memory to the speicialized cache</li>
<li>kmem_cache_destroy - destroys the specialized cache.</li>
</ol>
<p>Hence kmem_cache_alloc is used when the user of the kernel needs to allocate<br>memory from the specialized cache and kmalloc is used to allocate memory<br>from the generalized caches.</p>
<p>不过看实现，貌似后来的版本，这两个函数都基于slab&#x2F;slub&#x2F;slob:具体用哪个分配器，需要根据内核的默认配置； 只是前者kmalloc是可能两个模块共用一个cache，而后者则不是；<br>关于kmalloc和kmem_cache_alloc的区别：<br>kmalloc: It uses the generic slab caches available to any kernel code. so your module will share slab cache with other components in kernel.</p>
<p>kmem_cache_alloc: It will allocate objects from a dedicated slab cache created by kmem_cache_create. If you specifically want a better slab cache management dedicated to your module only, that too for a specific type of objects, use kmem_cache_create followed by kmem_cache_alloc. USB&#x2F;SCSI drivers use this. kmem_cache_create takes sizeof your object you want to create slab of, a name which appears in &#x2F;proc&#x2F;slabinfo and flags to govern behavior of your slab cache.</p>
<h3 id="linux下内存的查看和几个问题："><a href="#linux下内存的查看和几个问题：" class="headerlink" title="linux下内存的查看和几个问题："></a>linux下内存的查看和几个问题：</h3><h4 id="linux下物理内存统计等"><a href="#linux下物理内存统计等" class="headerlink" title="linux下物理内存统计等"></a>linux下物理内存统计等</h4><p>ref:<a href="http://linuxperf.com/?cat=7">http://linuxperf.com/?cat=7</a><br>系统当前的内存情况：<br>物理内存总数：和可用的物理内存数：<br> dmesg | grep Memory<br>[    0.000000] Memory: 3857076K&#x2F;4193848K available (8375K kernel code, 1336K rwdata, 3944K rodata, 1492K init, 1260K bss, 336772K reserved, 0K cma-reserved)<br>4193848K 表示此系统物理内存大小<br>3857076K 表示在初始化时，可供kernel分配的free memory的大小，注意这个值在初始化后，实际可用会变大，因为之后还会释放一些bootmem等用完的内存；<br>后面括号的是内核的代码大小占用等等；<br>所以：一个物理内存划分：BIOS|kernel code|initdata| totalavail<br>系统启动后，totalavail为：注意是物理内存<br>$ free  执行结果的total<br>             total       used       free     shared    buffers     cached<br>Mem:       4046636    2568888    1477748      17884      70888    1764708<br>-&#x2F;+ buffers&#x2F;cache:     733292    3313344<br>Swap:      4191228          0    4191228<br>或：下面指令的memtotal<br>$ cat &#x2F;proc&#x2F;meminfo<br>MemTotal:        4046636 kB<br>MemFree:         1477676 kB<br>MemAvailable:    3113840 kB<br>Buffers:           70896 kB<br>Cached:          1764708 kB<br>SwapCached:            0 kB<br>Active:           827164 kB<br>Inactive:        1596816 kB<br>Active(anon):     589152 kB<br>Inactive(anon):    17104 kB<br>Active(file):     238012 kB<br>Inactive(file):  1579712 kB<br>Unevictable:          16 kB<br>Mlocked:              16 kB<br>SwapTotal:       4191228 kB<br>SwapFree:        4191228 kB<br>Dirty:                 0 kB<br>Writeback:             0 kB<br>AnonPages:        588396 kB<br>Mapped:           163956 kB<br>Shmem:             17884 kB<br>Slab:              61964 kB<br>SReclaimable:      42112 kB<br>SUnreclaim:        19852 kB<br>KernelStack:        5888 kB<br>PageTables:        24916 kB<br>NFS_Unstable:          0 kB<br>Bounce:                0 kB<br>WritebackTmp:          0 kB<br>CommitLimit:     6214544 kB<br>Committed_AS:    2746044 kB<br>VmallocTotal:   34359738367 kB<br>VmallocUsed:           0 kB<br>VmallocChunk:          0 kB<br>HardwareCorrupted:     0 kB<br>AnonHugePages:    407552 kB<br>CmaTotal:              0 kB<br>CmaFree:               0 kB<br>HugePages_Total:       0<br>HugePages_Free:        0<br>HugePages_Rsvd:        0<br>HugePages_Surp:        0<br>Hugepagesize:       2048 kB<br>DirectMap4k:       96192 kB<br>DirectMap2M:     4098048 kB</p>
<p>更多内核内存的查看，见ref<br>进程的物理内存使用：<br>cat &#x2F;proc&#x2F;{pid}&#x2F;status<br>VmRSS 或 VmHWM<br>这个怎么来的：追了下，它定义在：task_mem in task_mmu.c (fs\proc) :         “VmRSS:\t%8lu kB\n”<br> get_mm_rss(mm);其实就是task_struct-&gt;&amp;mm-&gt;rss_stat.count[member]<br> 看下这个结构的解释：（看了下代码，就是在缺页等实际分配的时候做累加）<br> struct mm_rss_stat rss_stat - A set of statistics contained in struct mm_rss_stat relating to Resident Set Size (RSS), i.e. memory that has been faulted in. The structure is simply an array of atomic_long_t counts for each of: MM_FILEPAGES - number of resident pages mapping files, MM_ANONPAGES - number of resident anonymous pages, MM_SWAPENTS - number of resident swap entries, and MM_SHMEMPAGES - number of resident shared pages. Note that in the usual case where the SPLIT_RSS_COUNTING constant is set, these statistics are only updated every TASK_RSS_EVENTS_THRESH page faults (hardcoded to 64.)</p>
<p>进程的虚拟内存大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ sudo cat /proc/<span class="number">12473</span>/status</span><br><span class="line">Name:	task_test2</span><br><span class="line">State:	<span class="built_in">R</span> (running)</span><br><span class="line">Tgid:	<span class="number">12473</span></span><br><span class="line">Ngid:	<span class="number">0</span></span><br><span class="line">Pid:	<span class="number">12473</span></span><br><span class="line">PPid:	<span class="number">10096</span></span><br><span class="line">TracerPid:	<span class="number">0</span></span><br><span class="line">Uid:	<span class="number">1000</span>	<span class="number">1000</span>	<span class="number">1000</span>	<span class="number">1000</span></span><br><span class="line">Gid:	<span class="number">1000</span>	<span class="number">1000</span>	<span class="number">1000</span>	<span class="number">1000</span></span><br><span class="line">FDSize:	<span class="number">256</span></span><br><span class="line">Groups:	<span class="number">4</span> <span class="number">24</span> <span class="number">27</span> <span class="number">30</span> <span class="number">46</span> <span class="number">108</span> <span class="number">124</span> <span class="number">1000</span> </span><br><span class="line">NStgid:	<span class="number">12473</span></span><br><span class="line">NSpid:	<span class="number">12473</span></span><br><span class="line">NSpgid:	<span class="number">12473</span></span><br><span class="line">NSsid:	<span class="number">10096</span></span><br><span class="line">VmPeak:	    <span class="number">4332</span> kB</span><br><span class="line">VmSize:	    <span class="number">4332</span> kB  是虚拟内存的大小，即task_struct-&gt;mm-&gt;total_vm个页，一个页是<span class="number">4</span>k;</span><br><span class="line">VmLck:	       <span class="number">0</span> kB</span><br><span class="line">VmPin:	       <span class="number">0</span> kB</span><br><span class="line">VmHWM:	     <span class="number">660</span> kB</span><br><span class="line">VmRSS:	     <span class="number">660</span> kB </span><br><span class="line">VmData:	     <span class="number">200</span> kB</span><br><span class="line">VmStk:	     <span class="number">132</span> kB</span><br><span class="line">VmExe:	       <span class="number">4</span> kB</span><br><span class="line">VmLib:	    <span class="number">1908</span> kB</span><br><span class="line">VmPTE:	      <span class="number">32</span> kB</span><br><span class="line">VmPMD:	      <span class="number">12</span> kB</span><br><span class="line">VmSwap:	       <span class="number">0</span> kB</span><br><span class="line">HugetlbPages:	       <span class="number">0</span> kB</span><br><span class="line">Threads:	<span class="number">1</span></span><br><span class="line">SigQ:	<span class="number">0</span>/<span class="number">15066</span></span><br><span class="line">SigPnd:	<span class="number">0000000000000000</span></span><br><span class="line">ShdPnd:	<span class="number">0000000000000000</span></span><br><span class="line">SigBlk:	<span class="number">0000000000000000</span></span><br><span class="line">SigIgn:	<span class="number">0000000000000000</span></span><br><span class="line">SigCgt:	<span class="number">0000000000000000</span></span><br><span class="line">CapInh:	<span class="number">0000000000000000</span></span><br><span class="line">CapPrm:	<span class="number">0000000000000000</span></span><br><span class="line">CapEff:	<span class="number">0000000000000000</span></span><br><span class="line">CapBnd:	<span class="number">0000003f</span>ffffffff</span><br><span class="line">CapAmb:	<span class="number">0000000000000000</span></span><br><span class="line">Seccomp:	<span class="number">0</span></span><br><span class="line">Speculation_Store_Bypass:	vulnerable</span><br><span class="line">Cpus_allowed:	<span class="number">3</span></span><br><span class="line">Cpus_allowed_list:	<span class="number">0</span><span class="number">-1</span></span><br><span class="line">Mems_allowed:	<span class="number">00000000</span>,<span class="number">00000001</span></span><br><span class="line">Mems_allowed_list:	<span class="number">0</span></span><br><span class="line">voluntary_ctxt_switches:	<span class="number">0</span></span><br><span class="line">nonvoluntary_ctxt_switches:	<span class="number">167165</span></span><br></pre></td></tr></table></figure>
<h4 id="几个问题："><a href="#几个问题：" class="headerlink" title="几个问题："></a>几个问题：</h4><ul>
<li>通过malloc分配的最小物理内存单位是页吗，就是最小的话，一定会分配一个页，那这个页是不是这个进程独占，还是可以和其他进程共享？</li>
<li>内存映射和普通的内存分配操作有什么区别？</li>
<li>通过alloc_page分配内存页的时候，是不是就是即分配物理页，而不会再通过写入才分配？<br>是，即分配物理页，可以通过模块中alloc_page接口的调用，观察free指令下内存的变化；模块例子可以在本文中搜 alloc_page,在insmod模块后观察free下的值，最好指定分配的页多些，因为free下的空闲内存在一个范围变动；</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p>深入linux内核架构等</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_init</title>
    <url>/2021/03/21/tcpip-init/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="linux内核网络子系统的初始化介绍"><a href="#linux内核网络子系统的初始化介绍" class="headerlink" title="linux内核网络子系统的初始化介绍"></a>linux内核网络子系统的初始化介绍</h3><p>基于linux4.8,版本其实现在已经是5.12了，但是因为我装的linux源码版本是4.8，为方便调试，都在这个版本分析，差别不会很大；<br>以下的内核都指的这个linux4.8的内核；环境都在这个上的；<span id="more"></span><br>相关地址：<br>源码查阅：<a href="https://elixir.bootlin.com/linux/latest/source">https://elixir.bootlin.com/linux/latest/source</a></p>
<h4 id="linux内核网络子系统初始化组成"><a href="#linux内核网络子系统初始化组成" class="headerlink" title="linux内核网络子系统初始化组成"></a>linux内核网络子系统初始化组成</h4><ul>
<li>内核的初始化和各种init函数集合</li>
<li>网络文件系统等初始化：sock_init</li>
<li>协议栈及相关函数结构初始化：inet_init</li>
<li>设备相关初始化</li>
</ul>
<h4 id="内核的初始化过程整体和init函数集合"><a href="#内核的初始化过程整体和init函数集合" class="headerlink" title="内核的初始化过程整体和init函数集合"></a>内核的初始化过程整体和init函数集合</h4><p>内核的初始化，其实就是对应的启动linux的时候，各种数据结构，设备等等初始化的过程；更具体的涉及更多复杂细节，这里只展示关键部分；<br>内核启动时，会进入到head.S&#x2F;head.c,这个和架构有关，每种linux支持的架构都会有对应的实现文件：<br>在源码查阅中可以看到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/arch/alpha/kernel/head.S</span><br><span class="line">/arch/arm/kernel/head.S</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在这些文件中，都能找到其调用start_kernel，这个函数就是用来启动内核；<br>arch&#x2F;x86&#x2F;kernel&#x2F;head64.c, line 195为例：<br>可以看到调用启动内核的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">start_kernel</span>();</span><br><span class="line">进而找到：</span><br><span class="line">    init/main.c</span><br><span class="line">    简单分析start_kernel函数：截取其中的片段，可以看到其调用各种关键系统的初始化函数：</span><br><span class="line">    <span class="built_in">setup_log_buf</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">pidhash_init</span>();</span><br><span class="line">	<span class="built_in">vfs_caches_init_early</span>();</span><br><span class="line">	<span class="built_in">sort_main_extable</span>();</span><br><span class="line">	<span class="built_in">trap_init</span>();</span><br><span class="line">	<span class="built_in">mm_init</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">cred_init</span>();</span><br><span class="line">	fork_init();</span><br><span class="line">	<span class="built_in">proc_caches_init</span>();</span><br><span class="line">	<span class="built_in">buffer_init</span>();</span><br><span class="line">	<span class="built_in">key_init</span>();</span><br><span class="line">	<span class="built_in">security_init</span>();</span><br><span class="line">	<span class="built_in">dbg_late_init</span>();</span><br><span class="line">	<span class="built_in">vfs_caches_init</span>(totalram_pages);</span><br><span class="line">	<span class="built_in">signals_init</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">rest_init</span>();</span><br><span class="line">    从名字大概可以知道是初始化哪部分内容，这里每部分深入进去都是很长的内容，这里只去找网络相关的，看起来在rest_init部分了；</span><br><span class="line">    rest_init:</span><br><span class="line">    &#123;</span><br><span class="line">        .... <span class="comment">//可以看到转门新建了一个内核线程来初始化；</span></span><br><span class="line">        <span class="built_in">kernel_thread</span>(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">	    <span class="built_in">numa_default_policy</span>();</span><br><span class="line">	    pid = <span class="built_in">kernel_thread</span>(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">	    <span class="built_in">rcu_read_lock</span>();</span><br><span class="line"></span><br><span class="line">        kernel_init</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化各种init函数</span></span><br><span class="line">            <span class="built_in">kernel_init_freeable</span>();</span><br><span class="line">               -&gt;do_basic_setup</span><br><span class="line">                 -&gt;<span class="built_in">driver_init</span>();</span><br><span class="line">                  --&gt;<span class="built_in">do_initcalls</span>(); <span class="comment">//这里会通过依赖编译器的方式，寻找到内核中所有的_init 表识的函数，如sock_init,inet_init函数等</span></span><br><span class="line">                  ‘<span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">sock_init</span><span class="params">(<span class="type">void</span>)</span>’ </span></span><br><span class="line"><span class="function">                     从而能初始化各种init函数，这种机制，涉及到ld链接脚本，gcc编译器本身的机制，以及elf文件结构，内容较多，等有机会再具体写写</span></span><br><span class="line"><span class="function">                    这里截取一段：通过objdump vmlinux后看到的能找到的init函数</span></span><br><span class="line"><span class="function">                    ffffffff820a48e8 l     O .init.data	0000000000000008 __initcall_sock_init1 关键函数1</span></span><br><span class="line"><span class="function">                    ffffffff820a4e18 l     O .init.data	0000000000000008 __initcall_proto_init4</span></span><br><span class="line"><span class="function">                    ffffffff820a48f0 l     O .init.data	0000000000000008 __initcall_net_inuse_init1</span></span><br><span class="line"><span class="function">                    ffffffff820a4788 l     O .init.data	0000000000000008 __initcall_net_ns_init0</span></span><br><span class="line"><span class="function">                    ffffffff820a48f8 l     O .init.data	0000000000000008 __initcall_net_defaults_init1</span></span><br><span class="line"><span class="function">                    ffffffff820a4900 l     O .init.data	0000000000000008 __initcall_init_default_flow_dissectors1</span></span><br><span class="line"><span class="function">                    ffffffff820a5020 l     O .init.data	0000000000000008 __initcall_sysctl_core_init5</span></span><br><span class="line"><span class="function">                    ffffffff820a4e20 l     O .init.data	0000000000000008 __initcall_net_dev_init4 关键函数2</span></span><br><span class="line"><span class="function">                    ffffffff820a4e28 l     O .init.data	0000000000000008 __initcall_neigh_init4</span></span><br><span class="line"><span class="function">                    ffffffff820a5030 l     O .init.data	0000000000000008 __initcall_inet_init5 关键函数3</span></span><br><span class="line"><span class="function">            <span class="comment">//拉取init进程</span></span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(execute_command)</span> </span>&#123;</span><br><span class="line">		    ret = <span class="built_in">run_init_process</span>(execute_command);</span><br><span class="line">		    <span class="keyword">if</span> (!ret)</span><br><span class="line">		    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		    <span class="built_in">panic</span>(<span class="string">&quot;Requested init %s failed (error %d).&quot;</span>,</span><br><span class="line">		          execute_command, ret);</span><br><span class="line">	        &#125;</span><br><span class="line">	    <span class="keyword">if</span> (!<span class="built_in">try_to_run_init_process</span>(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">	        !<span class="built_in">try_to_run_init_process</span>(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">	        !<span class="built_in">try_to_run_init_process</span>(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">	        !<span class="built_in">try_to_run_init_process</span>(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line">	    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="网络文件系统等初始化：sock-init"><a href="#网络文件系统等初始化：sock-init" class="headerlink" title="网络文件系统等初始化：sock_init"></a>网络文件系统等初始化：sock_init</h4><h5 id="代码流程分析"><a href="#代码流程分析" class="headerlink" title="代码流程分析"></a>代码流程分析</h5><h6 id="整体代码："><a href="#整体代码：" class="headerlink" title="整体代码："></a>整体代码：</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">sock_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *      Initialize the network sysctl infrastructure.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	err = <span class="built_in">net_sysctl_init</span>();</span><br><span class="line">    <span class="comment">//初始化网络相关的/proc/sys/下的目录：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    /* Avoid limitations in the sysctl implementation by</span></span><br><span class="line"><span class="comment">	 * registering &quot;/proc/sys/net&quot; as an empty directory not in a</span></span><br><span class="line"><span class="comment">	 * network namespace.</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">	net_header = register_sysctl(&quot;net&quot;, empty);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//初始化网络空间相关操作等，网络空间用于docker时，每个docker容器之间的网络隔离，类似的还有文件系统隔离等带来的文件系统空间等等；</span></span><br><span class="line">    <span class="comment">//ret = register_pernet_subsys(&amp;sysctl_pernet_ops);</span></span><br><span class="line">    <span class="comment">//register_sysctl_root(&amp;net_sysctl_root);</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *      Initialize skbuff SLAB cache</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">skb_init</span>();</span><br><span class="line">    <span class="comment">//其实就是调用了kmem_cache_create初始化了skbuff,方便之后直接用kmem_cache_alloc分配skbuff</span></span><br><span class="line">    <span class="comment">//关于kmem_cache_create使用：https://docs.oracle.com/cd/E36784_01/html/E36886/kmem-cache-alloc-9f.html</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *      Initialize the protocols module.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    </span><br><span class="line">	<span class="built_in">init_inodecache</span>();</span><br><span class="line">    <span class="comment">//初始化：kmem_cache_create: socket_alloc:</span></span><br><span class="line">    <span class="comment">/*sock_inode_cachep = kmem_cache_create(&quot;sock_inode_cache&quot;,</span></span><br><span class="line"><span class="comment">					      sizeof(struct socket_alloc),</span></span><br><span class="line"><span class="comment">					      0,</span></span><br><span class="line"><span class="comment">					      (SLAB_HWCACHE_ALIGN |</span></span><br><span class="line"><span class="comment">					       SLAB_RECLAIM_ACCOUNT |</span></span><br><span class="line"><span class="comment">					       SLAB_MEM_SPREAD | SLAB_ACCOUNT),</span></span><br><span class="line"><span class="comment">					      init_once);</span></span><br><span class="line"><span class="comment">    可以看到这个结构体，是包含了 socket和inode:所有操作网络的接口fd可以通过write等文件系统的函数和socket的特定函数send等</span></span><br><span class="line"><span class="comment">    struct socket_alloc &#123;</span></span><br><span class="line"><span class="comment">	struct socket socket;</span></span><br><span class="line"><span class="comment">	struct inode vfs_inode;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	err = <span class="built_in">register_filesystem</span>(&amp;sock_fs_type);<span class="comment">//注册socketfs网络文件系统</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_fs;</span><br><span class="line">	sock_mnt = <span class="built_in">kern_mount</span>(&amp;sock_fs_type);<span class="comment">//挂载网络文件系统，主要调用了通用的接口：vfs_kern_mount(type, MS_KERNMOUNT, type-&gt;name, data);</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(sock_mnt)) &#123;</span><br><span class="line">		err = <span class="built_in">PTR_ERR</span>(sock_mnt);</span><br><span class="line">		<span class="keyword">goto</span> out_mount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The real protocol initialization is performed in later initcalls.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETFILTER</span></span><br><span class="line">	err = <span class="built_in">netfilter_init</span>();<span class="comment">//若配置了netfilter，需要进一步初始化</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ptp_classifier_init</span>();</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">out_mount:</span><br><span class="line">	<span class="built_in">unregister_filesystem</span>(&amp;sock_fs_type);</span><br><span class="line">out_fs:</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要真正理解上面的代码，需要了解：<br>1 内存管理相关的，理解kmem_cache高速缓存  –已独立文章分析<br>2 文件系统相关的，理解socketfs是什么存在，以及如何管理sockinode; –有独立文章分析文件系统，待分析socketfs<br>这里简单分析：socketfs是一种特殊的文件系统<br>特殊文件系统：通常是Linux为了方便计算机管理或者提供某些服务而编写。典型的有proc、tmpfs、pipefs、sockfs等。<br>所以sockfs就是为了套接字而设计的伪文件系统，在socket.c中  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">sock_fs_type</span> =</span> &#123;</span><br><span class="line">         .name    =  <span class="string">&quot;sockfs&quot;</span>,</span><br><span class="line">         .mount   =  sockfs_mount,</span><br><span class="line">         .kill_sb =  kill_anon_super,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从平常对套接字的使用，如可以用协议栈相关函数connect,bind accept,还可以用read,write进行发送和接收等，很明显后者是读写文件的函数；<br>从这里可以看到socket套接字兼顾两种特性；  sockfs是一个文件系统，自然支持inode，同时socket本身的结构支持协议栈函数；  </p>
<p>使用socket函数创建socket时：<br>socket结构初始化：从alloc_inode -&gt;调用sock_alloc_inode:创建如下结构体：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_alloc</span> &#123;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> <span class="title">socket</span>;</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到包含socket,和inode,同时socket结构包含file结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">        …</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">        …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>socket 成员面向的是协议栈，而 vfs_inode 成员面向的是文件系统，这体现了套接字的双重属性。struct file 则是将两者联系起来的枢纽，其面向的是进程。这样就把内核中的套接字，抽象成为一个简单的文件描述符，提供给用户空间使用。  </p>
<p>struct inode由于代表了文件系统中一个实际的文件在内存中的反映，已经不属于进程的范畴，所以 struct inode 不会有上面所谓的共享问题。但是 struct inode 只会在必要的时候创建，在允许的情况下销毁。  </p>
<p>3 sysctl相关的，如何 &#x2F;proc&#x2F;net&#x2F;目录 </p>
<h5 id="数据结构图"><a href="#数据结构图" class="headerlink" title="数据结构图"></a>数据结构图</h5><p>这部分涉及到几个数据结构：<br>1 skbuff: kmem_cache_create后产生的两个头：skbuff_head_cache，skbuff_fclone_cache<br>为后面分配skbuff做准备；<br>2 sysctl:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">proc_sysctl.c</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ctl_table_root</span> sysctl_table_root = &#123;</span><br><span class="line">	.default_set.dir.header = &#123;</span><br><span class="line">		&#123;&#123;.count = <span class="number">1</span>,</span><br><span class="line">		  .nreg = <span class="number">1</span>,</span><br><span class="line">		  .ctl_table = root_table &#125;&#125;,</span><br><span class="line">		.ctl_table_arg = root_table,</span><br><span class="line">		.root = &amp;sysctl_table_root,</span><br><span class="line">		.set = &amp;sysctl_table_root.default_set,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3 socketfs相关：<br>sock_fs_type</p>
<h4 id="协议栈及相关函数结构初始化：inet-init"><a href="#协议栈及相关函数结构初始化：inet-init" class="headerlink" title="协议栈及相关函数结构初始化：inet_init"></a>协议栈及相关函数结构初始化：inet_init</h4><p>用户层通过socket函数创建socket,会传入三个参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line">domain:</span><br><span class="line">指定协议簇，ipv4/ipv6..</span><br><span class="line">AF_INET      IPv4 Internet protocols </span><br><span class="line"></span><br><span class="line">type: </span><br><span class="line">指定udp/tcp</span><br><span class="line">SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based byte streams.  </span><br><span class="line">                An out-of-band data transmission mechanism may be supported.</span><br><span class="line"><span class="function">SOCK_DGRAM      Supports <span class="title">datagrams</span> <span class="params">(connectionless, unreliable messages of a fixed maximum length)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">protocol:</span></span><br><span class="line"><span class="function">通常只存在一个协议来支持 给定协议族中的特定套接字类型，在这种情况下，protocol可以指定为<span class="number">0</span>。</span></span><br></pre></td></tr></table></figure>
<p>然后会返回一个fd来唯一标识这个socket，那内核如何根据传入的三个参数，来选择正确的匹配协议和传输协议类型的相关函数呢？<br>在收到包后，如何根据收到的包，找到匹配的协议相关函数呢？<br>在下面的inet_init初始化后，就搭建好了这个基本的协议栈函数；  </p>
<h5 id="代码结构分析"><a href="#代码结构分析" class="headerlink" title="代码结构分析"></a>代码结构分析</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">inet_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inet_protosw</span> *q;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> *r;</span><br><span class="line">	<span class="type">int</span> rc = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sock_skb_cb_check_size</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> inet_skb_parm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将tcp_prot,udp_prot，注册到(添加到)prot_list链表中；</span></span><br><span class="line">    <span class="comment">//list_add(&amp;prot-&gt;node, &amp;proto_list); 将prot结构挂到链表上；</span></span><br><span class="line">	rc = <span class="built_in">proto_register</span>(&amp;tcp_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	rc = <span class="built_in">proto_register</span>(&amp;udp_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_tcp_proto;</span><br><span class="line"></span><br><span class="line">	rc = <span class="built_in">proto_register</span>(&amp;raw_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_udp_proto;</span><br><span class="line"></span><br><span class="line">	rc = <span class="built_in">proto_register</span>(&amp;ping_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_raw_proto;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Tell SOCKET that we are alive...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     </span><br><span class="line">	(<span class="type">void</span>)<span class="built_in">sock_register</span>(&amp;inet_family_ops);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //将inet_family_ops注册到地址簇列表中</span></span><br><span class="line"><span class="comment">	(void)sock_register(&amp;inet_family_ops);</span></span><br><span class="line"><span class="comment">    rcu_assign_pointer(net_families[ops-&gt;family], ops); //其实就是把ops放到对应的表net_family中，这个是全局变量，下面会解释</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSCTL</span></span><br><span class="line">	<span class="built_in">ip_static_sysctl_init</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Add all the base protocols.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//下面填充 inet_protos[protocol]=struct net_protocol结构；</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">inet_add_protocol</span>(&amp;icmp_protocol, IPPROTO_ICMP) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">pr_crit</span>(<span class="string">&quot;%s: Cannot add ICMP protocol\n&quot;</span>, __func__);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">inet_add_protocol</span>(&amp;udp_protocol, IPPROTO_UDP) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">pr_crit</span>(<span class="string">&quot;%s: Cannot add UDP protocol\n&quot;</span>, __func__);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">inet_add_protocol</span>(&amp;tcp_protocol, IPPROTO_TCP) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">pr_crit</span>(<span class="string">&quot;%s: Cannot add TCP protocol\n&quot;</span>, __func__);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IP_MULTICAST</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">inet_add_protocol</span>(&amp;igmp_protocol, IPPROTO_IGMP) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">pr_crit</span>(<span class="string">&quot;%s: Cannot add IGMP protocol\n&quot;</span>, __func__);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//初始化和注册 inetsw[]</span></span><br><span class="line">	<span class="comment">/* Register the socket-side information for inet_create. */</span></span><br><span class="line">	<span class="keyword">for</span> (r = &amp;inetsw[<span class="number">0</span>]; r &lt; &amp;inetsw[SOCK_MAX]; ++r)</span><br><span class="line">		<span class="built_in">INIT_LIST_HEAD</span>(r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</span><br><span class="line">		<span class="built_in">inet_register_protosw</span>(q);</span><br><span class="line">    /# 这个函数展开看看,主要是将inetws_array中的元素添加到全局静态链表中inetsw，注意linux特殊的链表连接方式，是结构中的成员为一个结点；</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inet_register_protosw</span><span class="params">(<span class="keyword">struct</span> inet_protosw *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	    <span class="keyword">struct</span> <span class="title class_">list_head</span> *lh;</span><br><span class="line">	    <span class="keyword">struct</span> <span class="title class_">inet_protosw</span> *answer;</span><br><span class="line">	    <span class="type">int</span> protocol = p-&gt;protocol;</span><br><span class="line">	    <span class="keyword">struct</span> <span class="title class_">list_head</span> *last_perm;</span><br><span class="line">    </span><br><span class="line">	    <span class="built_in">spin_lock_bh</span>(&amp;inetsw_lock);</span><br><span class="line">    </span><br><span class="line">	    <span class="keyword">if</span> (p-&gt;type &gt;= SOCK_MAX)</span><br><span class="line">	    	<span class="keyword">goto</span> out_illegal;</span><br><span class="line">    </span><br><span class="line">	    <span class="comment">/* If we are trying to override a permanent protocol, bail. */</span></span><br><span class="line">	    last_perm = &amp;inetsw[p-&gt;type];<span class="comment">//取出结构</span></span><br><span class="line">	    <span class="built_in">list_for_each</span>(lh, &amp;inetsw[p-&gt;type]) &#123;</span><br><span class="line">	    	answer = <span class="built_in">list_entry</span>(lh, <span class="keyword">struct</span> inet_protosw, list);</span><br><span class="line">	    	<span class="comment">/* Check only the non-wild match. */</span></span><br><span class="line">	    	<span class="keyword">if</span> ((INET_PROTOSW_PERMANENT &amp; answer-&gt;flags) == <span class="number">0</span>)</span><br><span class="line">	    		<span class="keyword">break</span>;</span><br><span class="line">	    	<span class="keyword">if</span> (protocol == answer-&gt;protocol)</span><br><span class="line">	    		<span class="keyword">goto</span> out_permanent;</span><br><span class="line">	    	last_perm = lh;</span><br><span class="line">	    &#125;</span><br><span class="line">    </span><br><span class="line">	    <span class="comment">/* Add the new entry after the last permanent entry if any, so that</span></span><br><span class="line"><span class="comment">	     * the new entry does not override a permanent entry when matched with</span></span><br><span class="line"><span class="comment">	     * a wild-card protocol. But it is allowed to override any existing</span></span><br><span class="line"><span class="comment">	     * non-permanent entry.  This means that when we remove this entry, the</span></span><br><span class="line"><span class="comment">	     * system automatically returns to the old behavior.</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="built_in">list_add_rcu</span>(&amp;p-&gt;list, last_perm);<span class="comment">//将p-&gt;list加到取出的结构中</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    #/</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Set the ARP module up</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//初始化arp和arp_packet_type注册：dev_add_pack(&amp;arp_packet_type);</span></span><br><span class="line">	<span class="built_in">arp_init</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Set the IP module up</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//ip路由表初始化</span></span><br><span class="line">	<span class="built_in">ip_init</span>();</span><br><span class="line">    <span class="comment">//tcp hashinfo相关初始化</span></span><br><span class="line">	<span class="built_in">tcp_v4_init</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup TCP slab cache for open requests. */</span></span><br><span class="line">	<span class="built_in">tcp_init</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup UDP memory threshold */</span></span><br><span class="line">	<span class="built_in">udp_init</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add UDP-Lite (RFC 3828) */</span></span><br><span class="line">	<span class="built_in">udplite4_register</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ping_table相关初始化</span></span><br><span class="line">	<span class="built_in">ping_init</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Set the ICMP layer up</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">icmp_init</span>() &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;Failed to create the ICMP control socket.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Initialise the multicast router</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IP_MROUTE)</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ip_mr_init</span>())</span><br><span class="line">		<span class="built_in">pr_crit</span>(<span class="string">&quot;%s: Cannot init ipv4 mroute\n&quot;</span>, __func__);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">init_inet_pernet_ops</span>())</span><br><span class="line">		<span class="built_in">pr_crit</span>(<span class="string">&quot;%s: Cannot init ipv4 inet pernet ops\n&quot;</span>, __func__);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Initialise per-cpu ipv4 mibs</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">init_ipv4_mibs</span>())</span><br><span class="line">		<span class="built_in">pr_crit</span>(<span class="string">&quot;%s: Cannot init ipv4 mibs\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ipv4_proc_init</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ipfrag_init</span>();</span><br><span class="line">    <span class="comment">//注册ip_packet_type</span></span><br><span class="line">	<span class="built_in">dev_add_pack</span>(&amp;ip_packet_type);</span><br><span class="line"></span><br><span class="line">	rc = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">out_unregister_raw_proto:</span><br><span class="line">	<span class="built_in">proto_unregister</span>(&amp;raw_prot);</span><br><span class="line">out_unregister_udp_proto:</span><br><span class="line">	<span class="built_in">proto_unregister</span>(&amp;udp_prot);</span><br><span class="line">out_unregister_tcp_proto:</span><br><span class="line">	<span class="built_in">proto_unregister</span>(&amp;tcp_prot);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数据结构图-1"><a href="#数据结构图-1" class="headerlink" title="数据结构图"></a>数据结构图</h5><p>int socket(int domain, int type, int protocol);&#x2F;&#x2F;先放着参考 协议簇，协议类型，协议号<br>上述涉及几个结构，从发送和接收的方向来解释：<br>发送方向：</p>
<ul>
<li>net_families[]:<br>net_families[PF_INET]&#x3D;inet_family_ops 上面主要初始化了这个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">net_proto_family</span> inet_family_ops = &#123;</span><br><span class="line">	.family = PF_INET,</span><br><span class="line">	.create = inet_create,</span><br><span class="line">	.owner	= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  但是其实还有如：<br>  &#x2F;* Protocol families, same as address families. *&#x2F;<br>    #define PF_UNSPEC    AF_UNSPEC<br>    #define PF_UNIX        AF_UNIX<br>    #define PF_LOCAL    AF_LOCAL<br>    #define PF_INET        AF_INET<br>    #define PF_AX25        AF_AX25<br>    #define PF_IPX        AF_IPX<br>    int socket(int domain, int type, int protocol);<br>    …<br>    还有这些协议簇，其实对应了上面socket函数传入的参数1；<br>    当我们调用socket创建socket套接字时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __sock_create(<span class="keyword">struct</span> net *net, <span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol,</span><br><span class="line"><span class="keyword">struct</span> socket **res, <span class="type">int</span> kern)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line">     ...</span><br><span class="line">     pf = <span class="built_in">rcu_dereference</span>(net_families[family]);<span class="comment">//通过传入的第一个参数找到对应的ops</span></span><br><span class="line">     err = pf-&gt;<span class="built_in">create</span>(net, sock, protocol, kern);<span class="comment">//调用ops的create函数来创建socket</span></span><br><span class="line">     进而调用到套接口层的create函数创建套接口；</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>inetsw，inetsw_array:<br>定义：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">list_head</span> inetsw[SOCK_MAX];</span><br><span class="line"><span class="comment">/* This is used to register socket interfaces for IP protocols.  */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inet_protosw</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> list;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* These two fields form the lookup key.  */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	 type;	   <span class="comment">/* This is the 2nd argument to socket(2). */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	 protocol; <span class="comment">/* This is the L4 protocol number.  */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proto</span>	 *prot;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">proto_ops</span> *ops;</span><br><span class="line">  </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	 flags;      <span class="comment">/* See INET_PROTOSW_* below.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>后者初始化了一个静态的写死的表：<br>af_inet.c:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Upon startup we insert all the elements in inetsw_array[] into</span></span><br><span class="line"><span class="comment"> * the linked list inetsw.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">inet_protosw</span> inetsw_array[] =</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.type =       SOCK_STREAM,</span><br><span class="line">		.protocol =   IPPROTO_TCP,</span><br><span class="line">		.prot =       &amp;tcp_prot,</span><br><span class="line">		.ops =        &amp;inet_stream_ops,</span><br><span class="line">		.flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">			      INET_PROTOSW_ICSK,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		.type =       SOCK_DGRAM,</span><br><span class="line">		.protocol =   IPPROTO_UDP,</span><br><span class="line">		.prot =       &amp;udp_prot,</span><br><span class="line">		.ops =        &amp;inet_dgram_ops,</span><br><span class="line">		.flags =      INET_PROTOSW_PERMANENT,</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">		.type =       SOCK_DGRAM,</span><br><span class="line">		.protocol =   IPPROTO_ICMP,</span><br><span class="line">		.prot =       &amp;ping_prot,</span><br><span class="line">		.ops =        &amp;inet_dgram_ops,</span><br><span class="line">		.flags =      INET_PROTOSW_REUSE,</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">	       .type =       SOCK_RAW,</span><br><span class="line">	       .protocol =   IPPROTO_IP,	<span class="comment">/* wild card */</span></span><br><span class="line">	       .prot =       &amp;raw_prot,</span><br><span class="line">	       .ops =        &amp;inet_sockraw_ops,</span><br><span class="line">	       .flags =      INET_PROTOSW_REUSE,</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line">以udp为例：</span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">proto_ops</span> inet_dgram_ops = &#123;</span><br><span class="line">	.family		   = PF_INET,</span><br><span class="line">	.owner		   = THIS_MODULE,</span><br><span class="line">	.release	   = inet_release,</span><br><span class="line">	.bind		   = inet_bind,</span><br><span class="line">	.connect	   = inet_dgram_connect,</span><br><span class="line">	.socketpair	   = sock_no_socketpair,</span><br><span class="line">	.accept		   = sock_no_accept,</span><br><span class="line">	.getname	   = inet_getname,</span><br><span class="line">	.poll		   = udp_poll,</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> proto udp_prot = &#123;</span><br><span class="line">	.name		   = <span class="string">&quot;UDP&quot;</span>,</span><br><span class="line">	.owner		   = THIS_MODULE,</span><br><span class="line">	.close		   = udp_lib_close,</span><br><span class="line">	.connect	   = ip4_datagram_connect,</span><br><span class="line">	.disconnect	   = udp_disconnect,</span><br><span class="line">	.ioctl		   = udp_ioctl,</span><br><span class="line">	.destroy	   = udp_destroy_sock,</span><br><span class="line">	.setsockopt	   = udp_setsockopt,</span><br><span class="line">	.getsockopt	   = udp_getsockopt,</span><br><span class="line">	.sendmsg	   = udp_sendmsg,</span><br><span class="line">	.recvmsg	   = udp_recvmsg,</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结构的作用，是对传入的参数2： type 协议类型进行函数匹配：<br>继续上面的，调用到create，其实是：inet_create函数；<br>这个函数会创建sock结构，并将从 inetsw_array匹配到的 SOCK_DGRAM&#x2F;SOCK_STREAM&#x2F;..对应的ops，进行赋值等；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">inet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="type">int</span> kern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sock</span> *sk;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inet_protosw</span> *answer;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inet_sock</span> *inet;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proto</span> *answer_prot;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> answer_flags;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">list_for_each_entry_rcu</span>(answer, &amp;inetsw[sock-&gt;type], list) &#123;</span><br><span class="line"></span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* Check the non-wild match. */</span></span><br><span class="line">		<span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line">			<span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Check for the two wild cases. */</span></span><br><span class="line">			<span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">				protocol = answer-&gt;protocol;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		err = -EPROTONOSUPPORT;</span><br><span class="line">	&#125;</span><br><span class="line">    sock-&gt;ops = answer-&gt;ops;<span class="comment">//关键步骤，所以之后的函数，可以通过ops找到</span></span><br><span class="line">	answer_prot = answer-&gt;prot;<span class="comment">//关键步骤，所以之后的函数，可以通过prot找到</span></span><br><span class="line">	answer_flags = answer-&gt;flags;</span><br><span class="line">    sk = <span class="built_in">sk_alloc</span>(net, PF_INET, GFP_KERNEL, answer_prot);</span><br></pre></td></tr></table></figure>

<p>接收方向：</p>
<ul>
<li><p>ptype_base,ptype_all,arp_packet_type,ip_packet_type<br>在接收到skbuff后确定是哪种三层包，ip还是arp;,从而找到对应的接收函数；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">packet_type</span> arp_packet_type __read_mostly = &#123;</span><br><span class="line">	.type =	<span class="built_in">cpu_to_be16</span>(ETH_P_ARP),</span><br><span class="line">	.func =	arp_rcv,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dev_add_pack</span>(&amp;ip_packet_type);</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">packet_type</span> ip_packet_type __read_mostly = &#123;</span><br><span class="line">	.type = <span class="built_in">cpu_to_be16</span>(ETH_P_IP),</span><br><span class="line">	.func = ip_rcv,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要是：全局变量：<br>static struct list_head ptype_base[16];    &#x2F;* 16 way hashed list *&#x2F;  dev.c<br>是以下十六个三层协议的列表，每种协议都由，packet_type数据结构表示，列表中的每个元素指向这个结构，<br>形成一个hash表，在dev_add_pack函数时添加到列表中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *		0800	IP</span></span><br><span class="line"><span class="comment"> *		8100    802.1Q VLAN</span></span><br><span class="line"><span class="comment"> *		0001	802.3</span></span><br><span class="line"><span class="comment"> *		0002	AX.25</span></span><br><span class="line"><span class="comment"> *		0004	802.2</span></span><br><span class="line"><span class="comment"> *		8035	RARP</span></span><br><span class="line"><span class="comment"> *		0005	SNAP</span></span><br><span class="line"><span class="comment"> *		0805	X.25</span></span><br><span class="line"><span class="comment"> *		0806	ARP</span></span><br><span class="line"><span class="comment"> *		8137	IPX</span></span><br><span class="line"><span class="comment"> *		0009	Localtalk</span></span><br><span class="line"><span class="comment"> *		86DD	IPv6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">而  <span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">list_head</span> ptype_all;		<span class="comment">/* Taps */</span> 对应了ETH_P_ALL</span><br><span class="line">在skbuff向上传递时；</span><br><span class="line">dev.c</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __netif_receive_skb_core(<span class="keyword">struct</span> sk_buff *skb, <span class="type">bool</span> pfmemalloc)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">type = skb-&gt;protocol;</span><br><span class="line"><span class="comment">/* deliver only exact match when indicated */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">likely</span>(!deliver_exact)) &#123;</span><br><span class="line">		<span class="built_in">deliver_ptype_list_skb</span>(skb, &amp;pt_prev, orig_dev, type,</span><br><span class="line">				       &amp;ptype_base[<span class="built_in">ntohs</span>(type) &amp;</span><br><span class="line">						   PTYPE_HASH_MASK]);</span><br><span class="line">....</span><br><span class="line">基于此能传递到正确的三层处理函数；  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>inet_protos<br>extern const struct net_protocol __rcu *inet_protos[MAX_INET_PROTOS];<br>inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &#x2F;&#x2F;通过类似函数添加；<br>inet_protos[IPPROTO_UDP]&#x3D;udp_protocol</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">net_protocol</span> udp_protocol = &#123;</span><br><span class="line">	.early_demux =	udp_v4_early_demux,</span><br><span class="line">	.handler =	udp_rcv,</span><br><span class="line">	.err_handler =	udp_err,</span><br><span class="line">	.no_policy =	<span class="number">1</span>,</span><br><span class="line">	.netns_ok =	<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进而能找到对应的四层函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ip_local_deliver_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__skb_pull(skb, <span class="built_in">skb_network_header_len</span>(skb));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">rcu_read_lock</span>();</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> protocol = <span class="built_in">ip_hdr</span>(skb)-&gt;protocol;</span><br><span class="line">		<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">net_protocol</span> *ipprot;</span><br><span class="line">		<span class="type">int</span> raw;</span><br><span class="line"></span><br><span class="line">	resubmit:</span><br><span class="line">		raw = <span class="built_in">raw_local_deliver</span>(skb, protocol);</span><br><span class="line"></span><br><span class="line">		ipprot = <span class="built_in">rcu_dereference</span>(inet_protos[protocol]);<span class="comment">//这里去找；</span></span><br><span class="line">		<span class="keyword">if</span> (ipprot) &#123;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其他：</p>
<ul>
<li>prot_list:<br>这个结构原先以为会也是类似net_family的作用，但是查了下引用的位置，这个全局的静态链表，inet域支持的所有协议全部在这个链表中，它只是用于在&#x2F;proc&#x2F;net&#x2F;protocols文件中输出当前系统所支持的所有协议。没有其他功能；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sock.c</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">下面是proc相关的函数；</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">proto_seq_start</span><span class="params">(<span class="keyword">struct</span> seq_file *seq, <span class="type">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function">	__<span class="title">acquires</span><span class="params">(proto_list_mutex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;proto_list_mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">seq_list_start_head</span>(&amp;proto_list, *pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">proto_seq_next</span><span class="params">(<span class="keyword">struct</span> seq_file *seq, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">seq_list_next</span>(v, &amp;proto_list, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
一个问题抛出来：<br>接收方向skbuff如何准确传递到正确的socket进而传递数据给对应的用户？<br>关于路由表相关和具体协议相关的结构，等到时候再分析；</li>
</ul>
<h4 id="设备相关初始化"><a href="#设备相关初始化" class="headerlink" title="设备相关初始化"></a>设备相关初始化</h4><p>设备相关的初始化，是比较复杂的内容，linux很大一部分代码就是各种设备驱动程序代码；在2.6后，采用了通用设备模型来管理设备；<br>网络设备时比较特殊的设备之一；<br>涉及以下几个方面：<br>1 网络设备的表示，一个网络设备通过net_device结构实例来表示，内核通过net_device管理和控制，连接到实际网络设备驱动程序，进而控制设备；<br>2 网络设备的驱动程序；网络设备多种多样，有wifi网卡，有线网卡等，而且跟具体芯片型号等有关，不同种类的设备驱动程序不同；而发送和接收都需要通过驱动程序<br>  处理，并进而交互到设备的固件firmware，从而发送和接收；网络设备驱动程序本质上就是分配和初始化net_device的过程，并提供了各种操作设备的函数；<br>3 网络设备初始化的基本过程：<br>  （1）注册：一个网络设备可用，就必须被内核认可，并且关联正确的驱动程序；驱动程序把驱动设备所需要的所有信息存储在私有数据结构中，然后与其他需要此设备的内核组件交互；<br>  （2）网络设备驱动程序如何分配 设备与内核通信的资源<br>  网络设备驱动程序如何分配 建立设备&#x2F;内核通信所需要的资源：<br>    即主要是包括：<br>    1) IRQ线初始化，虚拟设备不需要<br>        网络设备NIC必须被分配一个IRQ:然后再必要时如rx,提醒内核； –涉及请求和释放irq线，从&#x2F;proc&#x2F;interrupts文件可知当前分配状态；<br>    2)IO端口和内存注册：设备程序将其设备的一个内存区域如其配置寄存器映射到系统内存，这样驱动程序的读写可以通过系统内存进行；<br>        映射函数：request_region,release_region<br>    3)关键知识：<br>      内核和设备之间的交互：<br>      中断或轮询<br>硬件中断：<br>       每一个中断都会运行一个中断处理程序，这些中断响应程序都是设备驱动为设备量身定做的。一般而言，当设备注册一个NIC时，它首先会请求并分配一个IRQ，然后要为IRQ注册（如果设备被卸载了，则需要注销）一个IRQ响应程序。相应的内核代码在kernel&#x2F;irq&#x2F;manage.c和arch&#x2F;XXX&#x2F;kernel&#x2F;irq.c。（其中XXX为处理器架构）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,                                            </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function">    注意：irq的注册和释放函数都带有参数dev_id。因为IRQ是可以共享的，因此需要IRQ number和dev_id共同来唯一表示中断。</span></span><br><span class="line"><span class="function">    另，在注册IRQ时，必须保证IRQ还未有设备请求，除非所有设备都支持IRQ共享。</span></span><br><span class="line"><span class="function">    内核接收到一个中断信号时，会通过IRQ number调用关联的中断响应程序。IRQ number与中断响应程序以表的形式保存。由于多个设备可能共享IRQ的关系，IRQ number与中断响应程序的关系可能是一对多的。</span></span><br><span class="line"><span class="function">    中断类型：接收到数据帧、帧传输失败、DMA传输已成功完成、设备已经有足够内存来创建新的传输会话（可用NIC可用内存达到一定数值&lt;一般为设备MTU&gt;时产生一个中断）</span></span><br><span class="line"><span class="function">    为了防止内核在设备内存不足时多次提交传输请求，设备驱动可以关闭内核出口队列，待到资源足够是才重启。下面是一个范例：</span></span><br><span class="line"><span class="function">   <span class="type">static</span> <span class="type">netdev_tx_t</span></span></span><br><span class="line"><span class="function"><span class="title">el3_start_xmit</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="built_in">netif_stop_queue</span> (dev);</span><br><span class="line">    ……</span><br><span class="line">    dev-&gt;trans_start = jiffies;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">inw</span>(ioaddr + TX_FREE) &gt; <span class="number">1536</span>)</span><br><span class="line">        <span class="built_in">netif_start_queue</span>(dev);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* Interrupt us when the FIFO has room for max-sized packet. */</span></span><br><span class="line">        <span class="built_in">outw</span>(SetTxThreshold + <span class="number">1536</span>, ioaddr + EL3_CMD);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"> IRQ共享：IRQ线是很有限的资源，为了让一个系统能支持更多的设备，只能让多个设备共享IRQ线。IRQ共享的机制是这样的，内核收到中断请求，然后调用所有与该中断相关联的响应例程，然后有各个响应例程自行判断过滤是否对这个中断进行处理。（注意，IRQ与响应程序是一对多的，发生一个IRQ，哪些响应程序要处理，哪些不需要不是有内核去判断，而是各个中断响应程序自己判断，内核则是调用所有的响应程序。）</span><br><span class="line">IRQ与IRQ响应程序的组织：用全局的vector：irq_desc来组织，irq_desc包含所有IRQ，每个IRQ对应自己的链表，链表中是该IRQ关联的所有响应程序。只有IRQ共享时，IRQ链表的节点才会超过一个。</span><br></pre></td></tr></table></figure>

<p>  （3）网络设备结构net_device的分配和初始化<br>      module_init和probe<br>     注册和初始化任务的一部分由内核负责（module_init)，其他部分则由设备驱动程序负责(pci扫描到的具体的probe函数)；<br>     部分由内核完成，部分由驱动程序完成（决定如何分配建立设备&#x2F;内核通信所需资源：irq,IO端口）<br>           1) 通过一组函数指针和驱动设备函数交互<br>           2) 这个结构的初始化部分由内核完成，部分由设备驱动函数完成</p>
<p>4 网络设备相关的初始化相关重要函数：<br>  (1)subsys_init(net_dev_init) 对应抽象设备层(核心模块)<br>  下面的(2)(3)对应特定设备驱动程序<br>  (2)device_init(module_init)<br>  (3)pci_scan(probe) 真正的和真实设备挂钩的初始化，设备模型 kobject pci，这样管理所有设备，并调用xxx_probe–&gt;xxx_setup初始化net_device或其他设备实例；  </p>
<p>  关于抽象设备层解释：<br>  这一层主要提供一些设备无关的处理流程，也提供一些公用的函数给底层的 device driver 调用。<br>它为网络协议提供统一的发送、接收接口。这主要是通过 net_device 结构。是上层的、与设备无关的，<br>这部分根据输入输出请求，通过特定设备驱动程序接口，来与设备进行通信。<br>subsys_initcall(net_dev_init);<br>这个宏定义请参见前面说的 init.h，它被定义为： define_initcall(“4”,fn)<br>所以它是在 core_initcall 和 fs_initcall 之后被调用的。 </p>
<p>  关于特定设备驱动程序解释：<br> 是一种下层的、与设备有关的，常称为设备驱动程序，它直接与相应设备打<br>交道，并且向上层提供一组访问接口； 当一个网络设备的初始化程序被调用时，它返回一个状态指<br>示它所驱动的控制器是否有一个实例。<br>主要包括module_init和probe函数，即最终都是对net_deivce结构的初始化  </p>
<h5 id="代码结构分析-net-dev-init"><a href="#代码结构分析-net-dev-init" class="headerlink" title="代码结构分析 -net_dev_init"></a>代码结构分析 -net_dev_init</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *       This is called single threaded during boot, so no need</span></span><br><span class="line"><span class="comment"> *       to take the rtnl semaphore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">net_dev_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, rc = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BUG_ON</span>(!dev_boot_phase);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">dev_proc_init</span>())<span class="comment">//在/proc/net目录下创建四个proc条目（分别为dev、softnet_stat、ptype和wireless） </span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">netdev_kobject_init</span>())<span class="comment">//暂时不太清除</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;ptype_all);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PTYPE_HASH_SIZE; i++)</span><br><span class="line">		<span class="built_in">INIT_LIST_HEAD</span>(&amp;ptype_base[i]);<span class="comment">//前面有提到，不赘述</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;offload_base);()</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">register_pernet_subsys</span>(&amp;netdev_net_ops))<span class="comment">//将全局变量netdev_net_ops注册到链表(static struct list_head *first_device = &amp;pernet_list;)上</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Initialise the packet receive queues.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//对于多CPU的系统来说，每个CPU都有一个各自的接收队列，并且使用各自的softnet_data结构体变量*sd来管理网络数据包的收发流量（通过per_cpu函数）。</span></span><br><span class="line">	<span class="comment">//初始化两个sk_buff_head结构体变量process_queue和input_pkt_queue。</span></span><br><span class="line">    for_each_possible_cpu(i) &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">softnet_data</span> *sd = &amp;<span class="built_in">per_cpu</span>(softnet_data, i);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">skb_queue_head_init</span>(&amp;sd-&gt;input_pkt_queue);</span><br><span class="line">		<span class="built_in">skb_queue_head_init</span>(&amp;sd-&gt;process_queue);</span><br><span class="line">		<span class="built_in">INIT_LIST_HEAD</span>(&amp;sd-&gt;poll_list);</span><br><span class="line">		sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line">		sd-&gt;csd.func = rps_trigger_softirq;</span><br><span class="line">		sd-&gt;csd.info = sd;</span><br><span class="line">		sd-&gt;cpu = i;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		sd-&gt;backlog.poll = process_backlog;</span><br><span class="line">		sd-&gt;backlog.weight = weight_p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev_boot_phase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The loopback device is special if any other network devices</span></span><br><span class="line"><span class="comment">	 * is present in a network namespace the loopback device must</span></span><br><span class="line"><span class="comment">	 * be present. Since we now dynamically allocate and free the</span></span><br><span class="line"><span class="comment">	 * loopback device ensure this invariant is maintained by</span></span><br><span class="line"><span class="comment">	 * keeping the loopback device as the first device on the</span></span><br><span class="line"><span class="comment">	 * list of network devices.  Ensuring the loopback devices</span></span><br><span class="line"><span class="comment">	 * is the first device that appears and the last network device</span></span><br><span class="line"><span class="comment">	 * that disappears.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">//注册网络命令空间设备，确保loopback设备在所有网络设备中最先出现和最后消失</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">register_pernet_device</span>(&amp;loopback_net_ops))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">register_pernet_device</span>(&amp;default_device_ops))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">//分别注册网络设备数据包接收和发送的软中断处理程序 </span></span><br><span class="line">	<span class="built_in">open_softirq</span>(NET_TX_SOFTIRQ, net_tx_action);</span><br><span class="line">	<span class="built_in">open_softirq</span>(NET_RX_SOFTIRQ, net_rx_action);</span><br><span class="line">    <span class="comment">//注册回调处理函数dev_cpu_callback </span></span><br><span class="line">	<span class="built_in">hotcpu_notifier</span>(dev_cpu_callback, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dst_init</span>();<span class="comment">//和通知链相关的初始化</span></span><br><span class="line">	rc = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先备知识：  </p>
<ol>
<li>中断相关，软中断和硬中断  </li>
<li>通知链相关  </li>
<li>设备模型  </li>
<li>softnet_data相关，这里先不解释；  </li>
<li>other:用户空间辅助程序：<br> &#x2F;sbin&#x2F;modprobe 在内核需要加载某个模块时调用，判断内核传递的模块是不是&#x2F;etc&#x2F;modprobe.conf文件中定义的别名<br> &#x2F;sbin&#x2F;hotplug 在内核检测到一个新设备插入或拔出系统时调用，它的任务是根据设备标识加载正确的驱动  <h5 id="代码结构分析-module-init"><a href="#代码结构分析-module-init" class="headerlink" title="代码结构分析 -module_init:"></a>代码结构分析 -module_init:</h5>module_init是一大类的函数，几乎所有的设备都有实现这个函数：xxx_init_module为module_init类型；<br>凡是被 module_init()“修饰”过的函数只能在两种 情况下被调用：一种是被 do_initcalls 调用，一种是<br>在模块插入到系统中时被调用（如果它是模块方式）。每个模块只有一个被 module_init 修饰的函数入口<br>eg: 78. #define module_init(x) __initcall(x);<br>对第一种情况：<br>开机流程初始化有init_call机制，会做几乎所有的init,会包含一个初始化所有设备的module_init,自然就包括了net_device在module_init中的初始化；<br>eg:对回环设备：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~/source_linux/linux-lts-xenial<span class="number">-4.4</span><span class="number">.0</span>$ objdump  -t vmlinux| grep loopback</span><br><span class="line"><span class="number">0000000000000000</span> l    df *ABS*	<span class="number">0000000000000000</span> loopback.c</span><br><span class="line">ffffffff815ec3a0 l     F .text	<span class="number">00000000000000</span>a8 loopback_setup</span><br><span class="line">ffffffff81aa91c0 l     O .rodata	<span class="number">0000000000000198</span> loopback_ethtool_ops</span><br><span class="line">ffffffff81aa8f80 l     O .rodata	<span class="number">0000000000000238</span> loopback_ops</span><br><span class="line">ffffffff815ec450 l     F .text	<span class="number">0000000000000036</span> loopback_dev_free</span><br><span class="line">ffffffff815ec490 l     F .text	<span class="number">0000000000000081</span> loopback_get_stats64</span><br><span class="line">ffffffff815ec520 l     F .text	<span class="number">000000000000009</span>e loopback_xmit</span><br><span class="line">ffffffff815ec5c0 l     F .text	<span class="number">000000000000007</span>d loopback_dev_init</span><br><span class="line">ffffffff815ec640 l     F .text	<span class="number">000000000000009</span>d loopback_net_init <span class="comment">//这个函数</span></span><br></pre></td></tr></table></figure>
module_init只是对设备结构等做一个基本的初始化，这个时候还不能使用；或者说linux支持很多种设备，在开机初始化时做的module_init只是一个对支持的设备的初始化，对这个机器是否插入这个硬件设备不依赖，也不代表就可以用了；而要等到pci扫描设备后，对真正存在的设备调用对应的probe函数，读取和初始化真正设备，之后才能使用；<br>具体过程如下：<h5 id="代码结构分析-module-init-1"><a href="#代码结构分析-module-init-1" class="headerlink" title="代码结构分析 -module_init:"></a>代码结构分析 -module_init:</h5></li>
</ol>
<ul>
<li>pci子系统的基本介绍：<br>内核中的PCI子系统（PCI层）提供各种PCI设备驱动程序共同的所有通用功能；PCI电源管理和网络唤醒<br>1、几个数据结构：&#x2F;include&#x2F;linux&#x2F;mod_devicetable.h<br>A:pci_device_id 设备标示符；<br>B:pci_dev 每个pci上的设备都会分配一个pci_dev实例，如同网络设备会被分配net_device一样，这个结构由内核使用，以引用一个PCi设备；<br>C:pci_driver:定义pci层和设备驱动程序之间的接口；由函数指针构成， 所有pci上的设备都会使用这个结构；<br>D:char *name:驱动程序名称；总线上的；<br>E:const struct pci_deivce_id *id_table:Id向量，内核用于把一些设备关联到此驱动程序；<br>F:int (*probe)当pci层发现他正在搜寻驱动程序设备id和前面的id_table匹配，就会调用此函数。来做类似开启硬件，分配net_deivce结构，初始化并注册新设备；<br> void (*remove)和上面相反；<br>G: suspend resume函数和电源管理有关；</li>
</ul>
<p>2、PCI NIC 设备驱动程序的注册；  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pci_device_id</span> &#123;</span><br><span class="line">	__u32 vendor, device;		<span class="comment">/* Vendor and device ID or PCI_ANY_ID*/</span></span><br><span class="line">	__u32 subvendor, subdevice;	<span class="comment">/* Subsystem ID&#x27;s or PCI_ANY_ID */</span></span><br><span class="line">	__u32 <span class="keyword">class</span>, class_mask;	<span class="comment">/* (class,subclass,prog-if) triplet */</span></span><br><span class="line">	<span class="type">kernel_ulong_t</span> driver_data;	<span class="comment">/* Data private to the driver */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用于独一无二识别pci设备；<br> 每个设备驱动程序都会把一个pci_device_id实例的向量注册到内核；这个实例向量列出了其所能处理的设备ID<br>3、pci设备本身的注册等；<br>4、pci的探测分静态和动态  </p>
<ul>
<li>pci总线系统在开机引导期间：<br>例如linux现在支持PCI域，每个PCI域可以占用多大256个总线，每个总线占用32个设备；</li>
</ul>
<ol>
<li>系统引导时会建立一种数据库，把每个总线都关联到一份已侦测到而使用该总线的设备列表；如一个总线上挂了多个设备；</li>
</ol>
<p>2)总线上的设备如何注册<br>   当设备驱动程序A（对应总线上的设备A）被加载时，会调用pci_register_driver并提供pci_driver实例而与pci层注册。<br>   pci_driver结构中内含一个此驱动程序能驱动的pci设备id的向量（ *id_table),。<br>   接着，pci层使用这个表去查看已侦测到的pci上设备列表中与哪些设备匹配；于是就会建立该驱动程序的设备列表；<br>   接着，对每个匹配的设备，pci层会调用相匹配的驱动程序中的pci_driver结构中提供的probe函数；<br>  接着，probe函数会建立并注册相关联的网络设备；接着调用到xx_setup函数；<br>3) 总线上设备除名：<br>  当驱动程序稍后卸载时，该模块的module_exit函数会调用pci_unregister_driver，接着由于其数据库，使得pci能遍历所有与该驱动程序相关联的设备；并<br>   启动该设备的remove函数；从网络设备除名；  </p>
<h5 id="几个问题："><a href="#几个问题：" class="headerlink" title="几个问题："></a>几个问题：</h5><p>0、module_init和probe函数中都会对net_device结果做更新和初始化，他们怎么调用的？<br>   开机流程初始化有init_call机制，会做几乎所有的init,会包含一个初始化所有设备的module_init,自然就包括了net_device在module_init中的初始化；<br>而开机会做pci扫描，这个时候配置好设备后，会调用对应的probe,过程太过复杂，待研究，只学习较理论方面，见 linux设备模型中的设备驱动模型例子_PCI总线为例，通过扫描pci，接着注册后会调用到各个pci设备的probe函数，进而也调用到了网络设备的probe函数  </p>
<p>1、module_init修饰的函数什么时候调用？<br>凡是被 module_init()“修饰”过的函数只能在两种 情况下被调用：一种是被 do_initcalls 调用，一种是<br>在模块插入到系统中时被调用（如果它是模块方式）。每个模块只有一个被 module_init 修饰的函数入口<br>78. #define module_init(x) __initcall(x);  </p>
<p>所以真正的初始化是 probe函数调用时；  </p>
<h5 id="数据结构图-2"><a href="#数据结构图-2" class="headerlink" title="数据结构图"></a>数据结构图</h5><p>略<br>net_device结构介绍：ref 深入理解linux网络内幕<br>1、介绍：<br>net_device数据结构存储着特定网络设备的所有信息，每个网络设备对应一个net_device结构实例，无论是真实设备(如NIC)或者是虚拟设备(Bonding或VLAN)，并由驱动程序调用相关内核函数进行分配和注册，内核做一些初始化；<br>驱动程序，对这个设备的ops函数做初始化，并定义了相关函数赋值，这样内核通过统一的函数接口就可以掉用到对应的驱动函数；<br>可以说net_device是内核和驱动的桥梁；<br>所有设备的net_device结构放在一个全局变量 dev_base所指的全局列表中，在include&#x2F;linux&#x2F;netdevice.h中定义<br>网络设备可以分成几种类型，如Ethernet卡和Token Ring卡；对同一类型的所有设备，会设置某些字段为相同的值，有些则根据设备模型做不同的设置；<br>为了改善性能，驱动程序还可以改写一些已由内核初始化过的字段；<br>1_2: 结构组成：<br>net_device结构的字段可以分成以下几种类型：<br>标识符：net_device有三个标识符，不能搞混：<br>    int ifindex: 独一无二的ID,当设备以dev_new_index注册时分派给每个设备；<br>    int iflink: 这个字段主要是由(虚拟)隧道设备使用，可用于标识抵达隧道另一端的真实设备；<br>    unsigned short dev_id: 目前在zSeries OSA NIC上由IPv6使用，此字段用于区别可由不同OS同时共享的同一种设备的诸多设虚拟实例；见net&#x2F;ipv6&#x2F;addrconf.c的注释；  </p>
<p>配置<br>统计数据<br>设备状态<br>列表管理<br>流量管理<br>功能专用<br>通用<br>函数指针  </p>
<p>2、ref 深入理解linux网络内幕：设备注册和初始化：net_device<br>(1) 网络设备何时以及如何在内核注册：静态，热插拔<br>(2) 网络设备如何利用网络设备数据库注册，并指派一个net_device结构的实例<br>(3) net_device结构如何组织到hash表和列表，以便于做各种查询；<br>(4) net_device实例如何初始化，一部分由内核核心函数完成，一部分由其设备驱动程序完成，如ops结构中的函数指针；<br>(5）就注册而言，虚拟设备和真实设备有和区别；  </p>
<p>3、正文：<br>nic（网卡）可用之前，其相关联的net_deivce数据结构必须先初始化，添加到内核网络设备数据库，配置并开启；<br>注册&#x2F;除名 和开启&#x2F;关闭 是不同的，前者可以理解为注册和加载驱动&#x2F;卸载驱动，后者可以理解为开启和关闭网络设备，即关闭相关进程；<br>(1)网络设备注册之时：<br>   A:开机时，加载nic设备驱动程序，insmod类似动作或者调用module_init这种；或者在运行时进行insmod动态加载；<br>           这种情况下，可能会是通过总线设备驱动程序进行pci_driver-&gt;probe的调用，来负责设备注册；<br>  <strong>这里详细说明下：通过pci检测设备并调用probe函数，这个函数是由驱动提供，通过.probe&#x3D;xxx_probe来实现，并做与module_init相同的事情；</strong><br>  <strong>那么什么时候会用probe函数什么时候用module_init函数？前者是自动检测是用的，后者是运行时动态加载时使用的；</strong>–这个是查询的，需要再确认；<br>** 可以看到 若调用probe函数，则为XX_probe–&gt;alloc_dev–&gt;xxx_setup**<br>例子：net&#x2F;wireless&#x2F;airo.c<br>   B:插入热插拔设备；此时内核会通知其驱动程序，驱动程序再注册该设备；<br>  网络设备除名之时：pci_driver-&gt;remove<br>   1:关机时或者运行时做rmmod，即卸载设备驱动<br>   2:拔出热插拔设备，此时做删除等动作；  </p>
<p>(2)分配net_deivce结构：<br>使用在net&#x2F;core&#x2F;dev.c中的alloc_netdev分配，而一般由设备驱动程序进行调用；<br>这个函数的三个参数：由驱动程序提供实参<br>  私有数据结构大小:是驱动程序会使用的私有结构大小<br> ，设备名称，一个字符串，类似于eth0,eth1<br>设置函数：初始化函数指针，用来设置net_device结构的剩余部分；<br>返回值是指向已分配的net_device结构指针；<br>此外，内核也提供一组内含alloc_netdev的包裹函数，可用于为一组通用设备类型提供正确参数给alloc_netdev<br>好几个  </p>
<p>(3)Nic注册和除名的架构（设备驱动程序加载和卸载相关联）<br>依赖于总线；<br>其余部分则是网络设备驱动程序的架构；<br>    结构：私有数据结构+net_deivce+ops<br>    初始化：alloc_dev+register net_device and ops中的函数集合+setup函数以及其他初始化函数；<br>    卸载清理函数；<br>    module_init,module_exit;&#x2F;xxx_probe xxx_remove_one<br>例子见上；注意一下几点：<br>A:驱动程序可能会使用包裹函数，并只提供其私有数据区大小；<br>B:包裹函数会使用驱动程序提供的参数（包括设备名加初始化函数）来调用alloc_netdev<br>C:alloc_netdev所分配的内存块大小包括net_device结构和驱动程序私有数据块以及强制对齐所补的空白空间；<br>D:有些驱动程序会调用netdev_boot_setup_check函数减产加载内核时用户是否提供了任何引导期间参数；<br>E:新的net_device实例会利用register_netdevice来插入设备数据库；  </p>
<p>(4)设备初始化，包含xxx_setup函数，驱动程序传入的指针对于的函数，会对net_device等做一些初始化；<br>设备初始化包含以下三类：<br>   设备驱动程序的初始化，包括但不止xxx_setup（init函数里面可能也会做一些初始化)，<br>   设备类型：由xxx_setup函数负责;<br>   各种功能：可选和强制功能也必须初始化如队列规则；  </p>
<p>注意：xxx_setup是设备驱动程序传给内核的，但会被设备模型（总线）通过xxx_probe调用到<br>xxx_setup也会做类似于设置mtu,macaddr,hard_head_len,等值；</p>
<p>(5) net_deivce 结构组织介绍：仅说明一些点；<br> 览:net_device数据结构插在一个全局列表和两张hash表中；这些结构可以让内核按需求浏览和查询net_deivce数据库；<br> A: dev_base是一个指针，指向net_deivce链表的头，net_device中的next结果将整个全部设备串起来，这样内核通过这个结构可以轻易浏览设备；取得关键数据等；<br> B: dev_name_head:是一张hash表，以设备名为索引，可以让类似ioctl进行操作；<br> C:dev_index_head:是一张hash表，以设备ID:dev-&gt;ifindex为索引，指向net_device结构指针；如ip,netlink时就是通过dev-&gt;ifindex来索引的；<br>上面两张表，就可以提供获取设备的接口如：dev_get_by_name()和dev_get_by_index; 也可能根据设备类型和mac地址搜寻net_device，此时用的是dev_base<br>    上述三个结构通过dev_base_lock锁保护，所有查询函数在net&#x2F;core&#x2F;dev.c中  </p>
<p>(6)设备状态：<br>net_device中有各种字段可以定义设备当前状态；<br>如： flags:开启或关闭,reg_state:注册状态；state:用于队列规则；<br>队列规则状态：<br>每个网络设备都会分配一种队列规则，流量控制并以此来实现其Qos机制；<br>state就是用于这个，是位域，在include&#x2F;linux&#x2F;netdeivce.h中；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">netdev_state_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__LINK_STATE_XOFF=<span class="number">0</span>,</span><br><span class="line">	__LINK_STATE_START, 设备开启，此标示可以由netif_running检查</span><br><span class="line">	__LINK_STATE_PRESENT,</span><br><span class="line">	__LINK_STATE_SCHED,</span><br><span class="line">	__LINK_STATE_NOCARRIER,</span><br><span class="line">	__LINK_STATE_RX_SCHED,</span><br><span class="line">	__LINK_STATE_LINKWATCH_PENDING</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注册状态：<br>reg_state:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* register/unregister state machine */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> NETREG_UNINITIALIZED=<span class="number">0</span>,</span><br><span class="line">       NETREG_REGISTERING,	<span class="comment">/* called register_netdevice */</span></span><br><span class="line">       NETREG_REGISTERED,	<span class="comment">/* completed register todo */</span></span><br><span class="line">       NETREG_UNREGISTERING,	<span class="comment">/* called unregister_netdevice */</span></span><br><span class="line">       NETREG_UNREGISTERED,	<span class="comment">/* completed unregister todo */</span></span><br><span class="line">       NETREG_RELEASED,		<span class="comment">/* called free_netdev */</span></span><br><span class="line">&#125; reg_state;</span><br></pre></td></tr></table></figure>

<p>(7)注册函数和除名函数过程：<br>net&#x2F;core&#x2F;dev.c中：<br>调用netdev_run_todo处理；书里面将的调用情况，先忽略<br>A:注册详情：即注册时做了什么<br>  注册不仅仅是将net_device插入上述三个结构中，而还有其他动作：如一般有；  </p>
<ol>
<li>net_device的一些字段初始化；  </li>
<li>内核支持divert功能时，分配配置；  </li>
<li>执行xxx_setup函数</li>
</ol>
<p>   4)执行dev_new_index分配一个独一无二的标识码给设备；<br>   5)将net_device加入上面三个结构中；<br>   6)检查，设置状态和标识，初始化队列规则等；<br>   7)调用通知链相关函数；  </p>
<p>B:除名详情，即反注册时做了什么：<br>上面的反过程</p>
<p>(8)设备注册状态的通知：<br>内核组件和用户空间应用程序可能都想知道何时发生网络设备注册，除名，关闭或者开启之事，这类事件的通知通过两种通道传送：<br>  A:netdev_chain:注册通知链；<br>  B:Netlink的RTMGRP_LINK多播群组；<br>A:所有的netdev_chain报告的NETDEV_XXX事件都列在include&#x2F;linux&#x2F;notifier.h中；通知链怎么用见前文<br>   如对上面NETDEV_XXX事件感兴趣的可以通过register_netdevice_notifier和unregister_netdevice_notifier注册和反注册，就可以监听到消息；<br>   目前如：路由，防火墙，协议代码，虚拟设备等内核组件都在netdev_chain注册了；</p>
<p>(9) 引用计数：<br>net_device结构无法释放除非所有的引用都已释放；dev-&gt;refcnt中；<br>netdev_wait_allrefs;  </p>
<p>(10)开启和关闭网络设备；<br>设备一旦注册就可以用，但是除非用户或用户应用程序明确开启，否则还是无法传输接收数据<br>net&#x2F;core&#x2F;dev.c中dev_open负责；<br>开启设备：<br>   A：dev-&gt;open;<br>  B:设置dev-&gt;state<br>  C:设置flag<br>  D:初始化流量控制队列规则等；<br>  E:通知链调用；<br>关闭设备：<br>相反</p>
<p>(11)和电源管理之间的交互：<br>  当内核支持电源管理时，若进入挂起模式，则NIC设备驱动程序会接到通知，通过pci pci_driver结构的suspend,resume；<br>会影响到网络设备，如net-&gt;state,并调用相关函数挂起设备或重新继续；netif_device_detach&#x2F;netif_device_attach<br>其他：  </p>
<p>(12)链路状态变更检测：<br>A：驱动程序检测载波或者信号是否存在；  netif_carrier_on&#x2F;netif_carrier_off;<br>B:  调度并处理链路状态变更事件；<br>C:链接监看标示  </p>
<p>(13)从用户空间配置设备相关信息；<br>ifconfig,ethool,ip link;通过ioctl或netlink下去；<br>媒介独立接口：MII<br>(14)虚拟设备注意<br>(15)上锁  </p>
<h5 id="probe等函数例子："><a href="#probe等函数例子：" class="headerlink" title="probe等函数例子："></a>probe等函数例子：</h5><p>driver&#x2F;net&#x2F;xxx&#x2F;xxx 具体设备相关文件；  </p>
<h5 id="以wifi芯片举例："><a href="#以wifi芯片举例：" class="headerlink" title="以wifi芯片举例："></a>以wifi芯片举例：</h5><pre><code>   (data数据网络：ap侧：手机cpu modem侧：modem芯片)  
   (wifi网络：ap侧：固件wifi芯片  host端：手机cpu）  
   网卡NIC如无线网卡，内部是由程序在运行，在网卡中运行的程序叫做固件，对wifi而言也称为AP侧，而在PC端运行的用于控制和相应网卡中断的称为driver（驱动）或host侧；  
  驱动程序往往以ko的形式，被内核加载和运行  
  固件以bin或其他形式(mtk:bin,qcom:mpb)，被push到设备指定目录中，并最后push到设备内存中运行；  
</code></pre>
<h6 id="ldd3上一个虚拟设备的例子：贴过来仅供参考；"><a href="#ldd3上一个虚拟设备的例子：贴过来仅供参考；" class="headerlink" title="ldd3上一个虚拟设备的例子：贴过来仅供参考；"></a>ldd3上一个虚拟设备的例子：贴过来仅供参考；</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * snull.c --  the Simple Network Utility</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2001 O&#x27;Reilly &amp; Associates</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The source code in this file can be freely used, adapted,</span></span><br><span class="line"><span class="comment"> * and redistributed in source or binary form, so long as an</span></span><br><span class="line"><span class="comment"> * acknowledgment appears in derived source files.  The citation</span></span><br><span class="line"><span class="comment"> * should list that the code comes from the book &quot;Linux Device</span></span><br><span class="line"><span class="comment"> * Drivers&quot; by Alessandro Rubini and Jonathan Corbet, published</span></span><br><span class="line"><span class="comment"> * by O&#x27;Reilly &amp; Associates.   No warranty is attached;</span></span><br><span class="line"><span class="comment"> * we cannot take responsibility for errors or fitness for use.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * $Id: snull.c,v 1.21 2004/11/05 02:36:03 rubini Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* printk() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span> <span class="comment">/* kmalloc() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span>  <span class="comment">/* error codes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span>  <span class="comment">/* size_t */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span> <span class="comment">/* mark_bh */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span>   <span class="comment">/* struct device, and other headers */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/etherdevice.h&gt;</span> <span class="comment">/* eth_type_trans */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ip.h&gt;</span>          <span class="comment">/* struct iphdr */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tcp.h&gt;</span>         <span class="comment">/* struct tcphdr */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;snull.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/in6.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/checksum.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_AUTHOR</span>(<span class="string">&quot;Alessandro Rubini, Jonathan Corbet&quot;</span>);</span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Transmitter lockup simulation, normally disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lockup = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">module_param</span>(lockup, <span class="type">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> timeout = SNULL_TIMEOUT;</span><br><span class="line"><span class="built_in">module_param</span>(timeout, <span class="type">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do we run in NAPI mode?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> use_napi = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">module_param</span>(use_napi, <span class="type">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A structure representing an in-flight packet.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">snull_packet</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_packet</span> *next;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span> *dev;</span><br><span class="line">	<span class="type">int</span>	datalen;</span><br><span class="line">	u8 data[ETH_DATA_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pool_size = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">module_param</span>(pool_size, <span class="type">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is private to each device. It is used to pass</span></span><br><span class="line"><span class="comment"> * packets in and out, so there is place for a packet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">snull_priv</span> &#123;<span class="comment">//这个网络设备的私有数据结构</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device_stats</span> stats;</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_packet</span> *ppool;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_packet</span> *rx_queue;  <span class="comment">/* List of incoming packets */</span></span><br><span class="line">	<span class="type">int</span> rx_int_enabled;</span><br><span class="line">	<span class="type">int</span> tx_packetlen;</span><br><span class="line">	u8 *tx_packetdata;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span> *skb;</span><br><span class="line">	<span class="type">spinlock_t</span> lock;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一些net_deivce需要的函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">snull_tx_timeout</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(*snull_interrupt)</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> *, <span class="keyword">struct</span> pt_regs *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up a device&#x27;s packet pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">snull_setup_pool</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_packet</span> *pkt;</span><br><span class="line"></span><br><span class="line">	priv-&gt;ppool = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool_size; i++) &#123;</span><br><span class="line">		pkt = <span class="built_in">kmalloc</span> (<span class="built_in">sizeof</span> (<span class="keyword">struct</span> snull_packet), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (pkt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printk</span> (KERN_NOTICE <span class="string">&quot;Ran out of memory allocating packet pool\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pkt-&gt;dev = dev;</span><br><span class="line">		pkt-&gt;next = priv-&gt;ppool;</span><br><span class="line">		priv-&gt;ppool = pkt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">snull_teardown_pool</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_packet</span> *pkt;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> ((pkt = priv-&gt;ppool)) &#123;</span><br><span class="line">		priv-&gt;ppool = pkt-&gt;next;</span><br><span class="line">		<span class="built_in">kfree</span> (pkt);</span><br><span class="line">		<span class="comment">/* FIXME - in-flight packets ? */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Buffer/pool management.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">snull_packet</span> *<span class="built_in">snull_get_tx_buffer</span>(<span class="keyword">struct</span> net_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_packet</span> *pkt;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">spin_lock_irqsave</span>(&amp;priv-&gt;lock, flags);</span><br><span class="line">	pkt = priv-&gt;ppool;</span><br><span class="line">	priv-&gt;ppool = pkt-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;ppool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printk</span> (KERN_INFO <span class="string">&quot;Pool empty\n&quot;</span>);</span><br><span class="line">		<span class="built_in">netif_stop_queue</span>(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">spin_unlock_irqrestore</span>(&amp;priv-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> pkt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">snull_release_buffer</span><span class="params">(<span class="keyword">struct</span> snull_packet *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(pkt-&gt;dev);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">spin_lock_irqsave</span>(&amp;priv-&gt;lock, flags);</span><br><span class="line">	pkt-&gt;next = priv-&gt;ppool;</span><br><span class="line">	priv-&gt;ppool = pkt;</span><br><span class="line">	<span class="built_in">spin_unlock_irqrestore</span>(&amp;priv-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">netif_queue_stopped</span>(pkt-&gt;dev) &amp;&amp; pkt-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">netif_wake_queue</span>(pkt-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">snull_enqueue_buf</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> snull_packet *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">spin_lock_irqsave</span>(&amp;priv-&gt;lock, flags);</span><br><span class="line">	pkt-&gt;next = priv-&gt;rx_queue;  <span class="comment">/* FIXME - misorders packets */</span></span><br><span class="line">	priv-&gt;rx_queue = pkt;</span><br><span class="line">	<span class="built_in">spin_unlock_irqrestore</span>(&amp;priv-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">snull_packet</span> *<span class="built_in">snull_dequeue_buf</span>(<span class="keyword">struct</span> net_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_packet</span> *pkt;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">spin_lock_irqsave</span>(&amp;priv-&gt;lock, flags);</span><br><span class="line">	pkt = priv-&gt;rx_queue;</span><br><span class="line">	<span class="keyword">if</span> (pkt != <span class="literal">NULL</span>)</span><br><span class="line">		priv-&gt;rx_queue = pkt-&gt;next;</span><br><span class="line">	<span class="built_in">spin_unlock_irqrestore</span>(&amp;priv-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> pkt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Enable and disable receive interrupts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">snull_rx_ints</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="type">int</span> enable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	priv-&gt;rx_int_enabled = enable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Open and close</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snull_open</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* request_region(), request_irq(), ....  (like fops-&gt;open) */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Assign the hardware address of the board: use &quot;\0SNULx&quot;, where</span></span><br><span class="line"><span class="comment">	 * x is 0 or 1. The first byte is &#x27;\0&#x27; to avoid being a multicast</span></span><br><span class="line"><span class="comment">	 * address (the first byte of multicast addrs is odd).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(dev-&gt;dev_addr, <span class="string">&quot;\0SNUL0&quot;</span>, ETH_ALEN);</span><br><span class="line">	<span class="keyword">if</span> (dev == snull_devs[<span class="number">1</span>])</span><br><span class="line">		dev-&gt;dev_addr[ETH_ALEN<span class="number">-1</span>]++; <span class="comment">/* \0SNUL1 */</span></span><br><span class="line">	<span class="built_in">netif_start_queue</span>(dev);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snull_release</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* release ports, irq and such -- like fops-&gt;close */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">netif_stop_queue</span>(dev); <span class="comment">/* can&#x27;t transmit any more */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Configuration changes (passed on by ifconfig)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snull_config</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> ifmap *map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;flags &amp; IFF_UP) <span class="comment">/* can&#x27;t act on a running interface */</span></span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don&#x27;t allow changing the I/O address */</span></span><br><span class="line">	<span class="keyword">if</span> (map-&gt;base_addr != dev-&gt;base_addr) &#123;</span><br><span class="line">		<span class="built_in">printk</span>(KERN_WARNING <span class="string">&quot;snull: Can&#x27;t change I/O address\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow changing the IRQ */</span></span><br><span class="line">	<span class="keyword">if</span> (map-&gt;irq != dev-&gt;irq) &#123;</span><br><span class="line">		dev-&gt;irq = map-&gt;irq;</span><br><span class="line">        	<span class="comment">/* request_irq() is delayed to open-time */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ignore other fields */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Receive a packet: retrieve, encapsulate and pass over to upper levels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">snull_rx</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> snull_packet *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span> *skb;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The packet has been retrieved from the transmission</span></span><br><span class="line"><span class="comment">	 * medium. Build an skb around it, so upper layers can handle it</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	skb = <span class="built_in">dev_alloc_skb</span>(pkt-&gt;datalen + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">printk_ratelimit</span>())</span><br><span class="line">			<span class="built_in">printk</span>(KERN_NOTICE <span class="string">&quot;snull rx: low on mem - packet dropped\n&quot;</span>);</span><br><span class="line">		priv-&gt;stats.rx_dropped++;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">skb_reserve</span>(skb, <span class="number">2</span>); <span class="comment">/* align IP on 16B boundary */</span>  </span><br><span class="line">	<span class="built_in">memcpy</span>(<span class="built_in">skb_put</span>(skb, pkt-&gt;datalen), pkt-&gt;data, pkt-&gt;datalen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write metadata, and then pass to the receive level */</span></span><br><span class="line">	skb-&gt;dev = dev;</span><br><span class="line">	skb-&gt;protocol = <span class="built_in">eth_type_trans</span>(skb, dev);</span><br><span class="line">	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; <span class="comment">/* don&#x27;t check it */</span></span><br><span class="line">	priv-&gt;stats.rx_packets++;</span><br><span class="line">	priv-&gt;stats.rx_bytes += pkt-&gt;datalen;</span><br><span class="line">	<span class="built_in">netif_rx</span>(skb);</span><br><span class="line">  out:</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The poll implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">snull_poll</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="type">int</span> *budget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> npackets = <span class="number">0</span>, quota = <span class="built_in">min</span>(dev-&gt;quota, *budget);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span> *skb;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_packet</span> *pkt;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (npackets &lt; quota &amp;&amp; priv-&gt;rx_queue) &#123;</span><br><span class="line">		pkt = <span class="built_in">snull_dequeue_buf</span>(dev);</span><br><span class="line">		skb = <span class="built_in">dev_alloc_skb</span>(pkt-&gt;datalen + <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (! skb) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">printk_ratelimit</span>())</span><br><span class="line">				<span class="built_in">printk</span>(KERN_NOTICE <span class="string">&quot;snull: packet dropped\n&quot;</span>);</span><br><span class="line">			priv-&gt;stats.rx_dropped++;</span><br><span class="line">			<span class="built_in">snull_release_buffer</span>(pkt);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">skb_reserve</span>(skb, <span class="number">2</span>); <span class="comment">/* align IP on 16B boundary */</span>  </span><br><span class="line">		<span class="built_in">memcpy</span>(<span class="built_in">skb_put</span>(skb, pkt-&gt;datalen), pkt-&gt;data, pkt-&gt;datalen);</span><br><span class="line">		skb-&gt;dev = dev;</span><br><span class="line">		skb-&gt;protocol = <span class="built_in">eth_type_trans</span>(skb, dev);</span><br><span class="line">		skb-&gt;ip_summed = CHECKSUM_UNNECESSARY; <span class="comment">/* don&#x27;t check it */</span></span><br><span class="line">		<span class="built_in">netif_receive_skb</span>(skb);</span><br><span class="line">		</span><br><span class="line">        	<span class="comment">/* Maintain stats */</span></span><br><span class="line">		npackets++;</span><br><span class="line">		priv-&gt;stats.rx_packets++;</span><br><span class="line">		priv-&gt;stats.rx_bytes += pkt-&gt;datalen;</span><br><span class="line">		<span class="built_in">snull_release_buffer</span>(pkt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* If we processed all packets, we&#x27;re done; tell the kernel and reenable ints */</span></span><br><span class="line">	*budget -= npackets;</span><br><span class="line">	dev-&gt;quota -= npackets;</span><br><span class="line">	<span class="keyword">if</span> (! priv-&gt;rx_queue) &#123;</span><br><span class="line">		<span class="built_in">netif_rx_complete</span>(dev);</span><br><span class="line">		<span class="built_in">snull_rx_ints</span>(dev, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* We couldn&#x27;t process everything. */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">	    </span><br><span class="line">        </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The typical interrupt entry point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">snull_regular_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id, <span class="keyword">struct</span> pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> statusword;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_packet</span> *pkt = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * As usual, check the &quot;device&quot; pointer to be sure it is</span></span><br><span class="line"><span class="comment">	 * really interrupting.</span></span><br><span class="line"><span class="comment">	 * Then assign &quot;struct device *dev&quot;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span> *dev = (<span class="keyword">struct</span> net_device *)dev_id;</span><br><span class="line">	<span class="comment">/* ... and check with hw if it&#x27;s really ours */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* paranoid */</span></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lock the device */</span></span><br><span class="line">	priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	<span class="built_in">spin_lock</span>(&amp;priv-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* retrieve statusword: real netdevices use I/O instructions */</span></span><br><span class="line">	statusword = priv-&gt;status;</span><br><span class="line">	priv-&gt;status = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (statusword &amp; SNULL_RX_INTR) &#123;</span><br><span class="line">		<span class="comment">/* send it to snull_rx for handling */</span></span><br><span class="line">		pkt = priv-&gt;rx_queue;</span><br><span class="line">		<span class="keyword">if</span> (pkt) &#123;</span><br><span class="line">			priv-&gt;rx_queue = pkt-&gt;next;</span><br><span class="line">			<span class="built_in">snull_rx</span>(dev, pkt);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (statusword &amp; SNULL_TX_INTR) &#123;</span><br><span class="line">		<span class="comment">/* a transmission is over: free the skb */</span></span><br><span class="line">		priv-&gt;stats.tx_packets++;</span><br><span class="line">		priv-&gt;stats.tx_bytes += priv-&gt;tx_packetlen;</span><br><span class="line">		<span class="built_in">dev_kfree_skb</span>(priv-&gt;skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unlock the device and we are done */</span></span><br><span class="line">	<span class="built_in">spin_unlock</span>(&amp;priv-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (pkt) <span class="built_in">snull_release_buffer</span>(pkt); <span class="comment">/* Do this outside the lock! */</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A NAPI interrupt handler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">snull_napi_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id, <span class="keyword">struct</span> pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> statusword;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * As usual, check the &quot;device&quot; pointer for shared handlers.</span></span><br><span class="line"><span class="comment">	 * Then assign &quot;struct device *dev&quot;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span> *dev = (<span class="keyword">struct</span> net_device *)dev_id;</span><br><span class="line">	<span class="comment">/* ... and check with hw if it&#x27;s really ours */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* paranoid */</span></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lock the device */</span></span><br><span class="line">	priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	<span class="built_in">spin_lock</span>(&amp;priv-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* retrieve statusword: real netdevices use I/O instructions */</span></span><br><span class="line">	statusword = priv-&gt;status;</span><br><span class="line">	priv-&gt;status = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (statusword &amp; SNULL_RX_INTR) &#123;</span><br><span class="line">		<span class="built_in">snull_rx_ints</span>(dev, <span class="number">0</span>);  <span class="comment">/* Disable further interrupts */</span></span><br><span class="line">		<span class="built_in">netif_rx_schedule</span>(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (statusword &amp; SNULL_TX_INTR) &#123;</span><br><span class="line">        	<span class="comment">/* a transmission is over: free the skb */</span></span><br><span class="line">		priv-&gt;stats.tx_packets++;</span><br><span class="line">		priv-&gt;stats.tx_bytes += priv-&gt;tx_packetlen;</span><br><span class="line">		<span class="built_in">dev_kfree_skb</span>(priv-&gt;skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unlock the device and we are done */</span></span><br><span class="line">	<span class="built_in">spin_unlock</span>(&amp;priv-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Transmit a packet (low level interface)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">snull_hw_tx</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> len, <span class="keyword">struct</span> net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This function deals with hw details. This interface loops</span></span><br><span class="line"><span class="comment">	 * back the packet to the other snull interface (if any).</span></span><br><span class="line"><span class="comment">	 * In other words, this function implements the snull behaviour,</span></span><br><span class="line"><span class="comment">	 * while all other procedures are rather device-independent</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">iphdr</span> *ih;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span> *dest;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv;</span><br><span class="line">	u32 *saddr, *daddr;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_packet</span> *tx_buffer;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* I am paranoid. Ain&#x27;t I? */</span></span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ethhdr) + <span class="built_in">sizeof</span>(<span class="keyword">struct</span> iphdr)) &#123;</span><br><span class="line">		<span class="built_in">printk</span>(<span class="string">&quot;snull: Hmm... packet too short (%i octets)\n&quot;</span>,</span><br><span class="line">				len);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="comment">/* enable this conditional to look at the data */</span></span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="built_in">PDEBUG</span>(<span class="string">&quot;len is %i\n&quot;</span> KERN_DEBUG <span class="string">&quot;data:&quot;</span>,len);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">14</span> ; i&lt;len; i++)</span><br><span class="line">			<span class="built_in">printk</span>(<span class="string">&quot; %02x&quot;</span>,buf[i]&amp;<span class="number">0xff</span>);</span><br><span class="line">		<span class="built_in">printk</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ethhdr is 14 bytes, but the kernel arranges for iphdr</span></span><br><span class="line"><span class="comment">	 * to be aligned (i.e., ethhdr is unaligned)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ih = (<span class="keyword">struct</span> iphdr *)(buf+<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ethhdr));</span><br><span class="line">	saddr = &amp;ih-&gt;saddr;</span><br><span class="line">	daddr = &amp;ih-&gt;daddr;</span><br><span class="line"></span><br><span class="line">	((u8 *)saddr)[<span class="number">2</span>] ^= <span class="number">1</span>; <span class="comment">/* change the third octet (class C) */</span></span><br><span class="line">	((u8 *)daddr)[<span class="number">2</span>] ^= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	ih-&gt;check = <span class="number">0</span>;         <span class="comment">/* and rebuild the checksum (ip needs it) */</span></span><br><span class="line">	ih-&gt;check = <span class="built_in">ip_fast_csum</span>((<span class="type">unsigned</span> <span class="type">char</span> *)ih,ih-&gt;ihl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev == snull_devs[<span class="number">0</span>])</span><br><span class="line">		<span class="built_in">PDEBUGG</span>(<span class="string">&quot;%08x:%05i --&gt; %08x:%05i\n&quot;</span>,</span><br><span class="line">				<span class="built_in">ntohl</span>(ih-&gt;saddr),<span class="built_in">ntohs</span>(((<span class="keyword">struct</span> tcphdr *)(ih+<span class="number">1</span>))-&gt;source),</span><br><span class="line">				<span class="built_in">ntohl</span>(ih-&gt;daddr),<span class="built_in">ntohs</span>(((<span class="keyword">struct</span> tcphdr *)(ih+<span class="number">1</span>))-&gt;dest));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">PDEBUGG</span>(<span class="string">&quot;%08x:%05i &lt;-- %08x:%05i\n&quot;</span>,</span><br><span class="line">				<span class="built_in">ntohl</span>(ih-&gt;daddr),<span class="built_in">ntohs</span>(((<span class="keyword">struct</span> tcphdr *)(ih+<span class="number">1</span>))-&gt;dest),</span><br><span class="line">				<span class="built_in">ntohl</span>(ih-&gt;saddr),<span class="built_in">ntohs</span>(((<span class="keyword">struct</span> tcphdr *)(ih+<span class="number">1</span>))-&gt;source));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ok, now the packet is ready for transmission: first simulate a</span></span><br><span class="line"><span class="comment">	 * receive interrupt on the twin device, then  a</span></span><br><span class="line"><span class="comment">	 * transmission-done on the transmitting device</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dest = snull_devs[dev == snull_devs[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>];</span><br><span class="line">	priv = <span class="built_in">netdev_priv</span>(dest);</span><br><span class="line">	tx_buffer = <span class="built_in">snull_get_tx_buffer</span>(dev);</span><br><span class="line">	tx_buffer-&gt;datalen = len;</span><br><span class="line">	<span class="built_in">memcpy</span>(tx_buffer-&gt;data, buf, len);</span><br><span class="line">	<span class="built_in">snull_enqueue_buf</span>(dest, tx_buffer);</span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;rx_int_enabled) &#123;</span><br><span class="line">		priv-&gt;status |= SNULL_RX_INTR;</span><br><span class="line">		<span class="built_in">snull_interrupt</span>(<span class="number">0</span>, dest, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	priv-&gt;tx_packetlen = len;</span><br><span class="line">	priv-&gt;tx_packetdata = buf;</span><br><span class="line">	priv-&gt;status |= SNULL_TX_INTR;</span><br><span class="line">	<span class="keyword">if</span> (lockup &amp;&amp; ((priv-&gt;stats.tx_packets + <span class="number">1</span>) % lockup) == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">/* Simulate a dropped transmit interrupt */</span></span><br><span class="line">		<span class="built_in">netif_stop_queue</span>(dev);</span><br><span class="line">		<span class="built_in">PDEBUG</span>(<span class="string">&quot;Simulate lockup at %ld, txp %ld\n&quot;</span>, jiffies,</span><br><span class="line">				(<span class="type">unsigned</span> <span class="type">long</span>) priv-&gt;stats.tx_packets);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">snull_interrupt</span>(<span class="number">0</span>, dev, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Transmit a packet (called by the kernel)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snull_tx</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">char</span> *data, shortpkt[ETH_ZLEN];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	</span><br><span class="line">	data = skb-&gt;data;</span><br><span class="line">	len = skb-&gt;len;</span><br><span class="line">	<span class="keyword">if</span> (len &lt; ETH_ZLEN) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(shortpkt, <span class="number">0</span>, ETH_ZLEN);</span><br><span class="line">		<span class="built_in">memcpy</span>(shortpkt, skb-&gt;data, skb-&gt;len);</span><br><span class="line">		len = ETH_ZLEN;</span><br><span class="line">		data = shortpkt;</span><br><span class="line">	&#125;</span><br><span class="line">	dev-&gt;trans_start = jiffies; <span class="comment">/* save the timestamp */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remember the skb, so we can free it at interrupt time */</span></span><br><span class="line">	priv-&gt;skb = skb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* actual deliver of data is device-specific, and not shown here */</span></span><br><span class="line">	<span class="built_in">snull_hw_tx</span>(data, len, dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Our simple device can not fail */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Deal with a transmit timeout.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">snull_tx_timeout</span> <span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">PDEBUG</span>(<span class="string">&quot;Transmit timeout at %ld, latency %ld\n&quot;</span>, jiffies,</span><br><span class="line">			jiffies - dev-&gt;trans_start);</span><br><span class="line">        <span class="comment">/* Simulate a transmission interrupt to get things moving */</span></span><br><span class="line">	priv-&gt;status = SNULL_TX_INTR;</span><br><span class="line">	<span class="built_in">snull_interrupt</span>(<span class="number">0</span>, dev, <span class="literal">NULL</span>);</span><br><span class="line">	priv-&gt;stats.tx_errors++;</span><br><span class="line">	<span class="built_in">netif_wake_queue</span>(dev);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ioctl commands </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snull_ioctl</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> ifreq *rq, <span class="type">int</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PDEBUG</span>(<span class="string">&quot;ioctl\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return statistics to the caller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">net_device_stats</span> *<span class="built_in">snull_stats</span>(<span class="keyword">struct</span> net_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	<span class="keyword">return</span> &amp;priv-&gt;stats;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called to fill up an eth header, since arp is not</span></span><br><span class="line"><span class="comment"> * available on the interface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snull_rebuild_header</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ethhdr</span> *eth = (<span class="keyword">struct</span> ethhdr *) skb-&gt;data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net_device</span> *dev = skb-&gt;dev;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">memcpy</span>(eth-&gt;h_source, dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">	<span class="built_in">memcpy</span>(eth-&gt;h_dest, dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">	eth-&gt;h_dest[ETH_ALEN<span class="number">-1</span>]   ^= <span class="number">0x01</span>;   <span class="comment">/* dest is us xor 1 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snull_header</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">short</span> type, <span class="type">void</span> *daddr, <span class="type">void</span> *saddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">unsigned</span> <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ethhdr</span> *eth = (<span class="keyword">struct</span> ethhdr *)<span class="built_in">skb_push</span>(skb,ETH_HLEN);</span><br><span class="line"></span><br><span class="line">	eth-&gt;h_proto = <span class="built_in">htons</span>(type);</span><br><span class="line">	<span class="built_in">memcpy</span>(eth-&gt;h_source, saddr ? saddr : dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">	<span class="built_in">memcpy</span>(eth-&gt;h_dest,   daddr ? daddr : dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">	eth-&gt;h_dest[ETH_ALEN<span class="number">-1</span>]   ^= <span class="number">0x01</span>;   <span class="comment">/* dest is us xor 1 */</span></span><br><span class="line">	<span class="keyword">return</span> (dev-&gt;hard_header_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The &quot;change_mtu&quot; method is usually not needed.</span></span><br><span class="line"><span class="comment"> * If you need it, it must be like this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snull_change_mtu</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="type">int</span> new_mtu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	<span class="type">spinlock_t</span> *lock = &amp;priv-&gt;lock;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* check ranges */</span></span><br><span class="line">	<span class="keyword">if</span> ((new_mtu &lt; <span class="number">68</span>) || (new_mtu &gt; <span class="number">1500</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do anything you need, and the accept the value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">spin_lock_irqsave</span>(lock, flags);</span><br><span class="line">	dev-&gt;mtu = new_mtu;</span><br><span class="line">	<span class="built_in">spin_unlock_irqrestore</span>(lock, flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* success */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The init function (sometimes called probe).</span></span><br><span class="line"><span class="comment"> * It is invoked by register_netdev()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这个是setup函数，用于初始化net_device部分结构，并作为alloc_netdev的第三个参数传入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">snull_init</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">snull_priv</span> *priv;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make the usual checks: check_region(), probe irq, ...  -ENODEV</span></span><br><span class="line"><span class="comment">	 * should be returned if no device found.  No resource should be</span></span><br><span class="line"><span class="comment">	 * grabbed: this is done on open(). </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Then, assign other fields in dev, using ether_setup() and some</span></span><br><span class="line"><span class="comment">	 * hand assignments</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">ether_setup</span>(dev); <span class="comment">/* assign some of the fields */</span></span><br><span class="line"></span><br><span class="line">	dev-&gt;open            = snull_open;</span><br><span class="line">	dev-&gt;stop            = snull_release;</span><br><span class="line">	dev-&gt;set_config      = snull_config;</span><br><span class="line">	dev-&gt;hard_start_xmit = snull_tx;</span><br><span class="line">	dev-&gt;do_ioctl        = snull_ioctl;</span><br><span class="line">	dev-&gt;get_stats       = snull_stats;</span><br><span class="line">	dev-&gt;change_mtu      = snull_change_mtu;  </span><br><span class="line">	dev-&gt;rebuild_header  = snull_rebuild_header;</span><br><span class="line">	dev-&gt;hard_header     = snull_header;</span><br><span class="line">	dev-&gt;tx_timeout      = snull_tx_timeout;</span><br><span class="line">	dev-&gt;watchdog_timeo = timeout;</span><br><span class="line">	<span class="keyword">if</span> (use_napi) &#123;</span><br><span class="line">		dev-&gt;poll        = snull_poll;</span><br><span class="line">		dev-&gt;weight      = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* keep the default flags, just add NOARP */</span></span><br><span class="line">	dev-&gt;flags           |= IFF_NOARP;</span><br><span class="line">	dev-&gt;features        |= NETIF_F_NO_CSUM;</span><br><span class="line">	dev-&gt;hard_header_cache = <span class="literal">NULL</span>;      <span class="comment">/* Disable caching */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Then, initialize the priv field. This encloses the statistics</span></span><br><span class="line"><span class="comment">	 * and a few private fields.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	priv = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">	<span class="built_in">memset</span>(priv, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> snull_priv));</span><br><span class="line">	<span class="built_in">spin_lock_init</span>(&amp;priv-&gt;lock);</span><br><span class="line">	<span class="built_in">snull_rx_ints</span>(dev, <span class="number">1</span>);		<span class="comment">/* enable receive interrupts */</span></span><br><span class="line">	<span class="built_in">snull_setup_pool</span>(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The devices</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">net_device</span> *snull_devs[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Finally, the module stuff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//驱动卸载时调用的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">snull_cleanup</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>;  i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (snull_devs[i]) &#123;</span><br><span class="line">			<span class="built_in">unregister_netdev</span>(snull_devs[i]);<span class="comment">//反注册net_deivce</span></span><br><span class="line">			<span class="built_in">snull_teardown_pool</span>(snull_devs[i]);</span><br><span class="line">			<span class="built_in">free_netdev</span>(snull_devs[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动加载时的初始化函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snull_init_module</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> result, i, ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	snull_interrupt = use_napi ? snull_napi_interrupt : snull_regular_interrupt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate the devices */</span></span><br><span class="line">	snull_devs[<span class="number">0</span>] = <span class="built_in">alloc_netdev</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> snull_priv), <span class="string">&quot;sn%d&quot;</span>,<span class="comment">//调用的分配net_deivce函数</span></span><br><span class="line">			snull_init);</span><br><span class="line">	snull_devs[<span class="number">1</span>] = <span class="built_in">alloc_netdev</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> snull_priv), <span class="string">&quot;sn%d&quot;</span>,<span class="comment">//这里&quot;sn%d&quot;内核会使用dev_alloc_name以完成该名字，次函数会把%d换成该设备类型中头一个未分配的数字</span></span><br><span class="line">			snull_init);</span><br><span class="line">	<span class="keyword">if</span> (snull_devs[<span class="number">0</span>] == <span class="literal">NULL</span> || snull_devs[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	ret = -ENODEV;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>;  i++)</span><br><span class="line">		<span class="keyword">if</span> ((result = <span class="built_in">register_netdev</span>(snull_devs[i])))<span class="comment">//注册net_device</span></span><br><span class="line">			<span class="built_in">printk</span>(<span class="string">&quot;snull: error %i registering device \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">					result, snull_devs[i]-&gt;name);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line">   out:</span><br><span class="line">	<span class="keyword">if</span> (ret) </span><br><span class="line">		<span class="built_in">snull_cleanup</span>();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(snull_init_module);</span><br><span class="line"><span class="built_in">module_exit</span>(snull_cleanup);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="其他部分，如子系统的初始化，等分析到了再写"><a href="#其他部分，如子系统的初始化，等分析到了再写" class="headerlink" title="其他部分，如子系统的初始化，等分析到了再写"></a>其他部分，如子系统的初始化，等分析到了再写</h4>]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_init</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile_use</title>
    <url>/2021/04/04/makefile-use/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>以下文档参考：<br><a href="https://www.gnu.org/software/make/manual/make.html#toc-Overview-of-make">https://www.gnu.org/software/make/manual/make.html#toc-Overview-of-make</a><br><a href="https://seisman.github.io/how-to-write-makefile/introduction.html">https://seisman.github.io/how-to-write-makefile/introduction.html</a></p>
<p>这个文件记录了GNU make实用程序，它自动地确定一个大型程序的哪些部分需要重新编译，并发出重新编译它们的命令<br>适用版本：<br>This is Edition 0.75, last updated 17 January 2020, of The GNU Make Manual, for GNU make version 4.3.</p>
<h3 id="make的基本功能和使用简介："><a href="#make的基本功能和使用简介：" class="headerlink" title="make的基本功能和使用简介："></a>make的基本功能和使用简介：<span id="more"></span></h3><p>make实用程序自动确定大型程序的哪些部分需要重新编译，并发出命令重新编译它们。本手册描述了由Richard Stallman和Roland McGrath实现的GNU make。从3.76版本开始的开发由Paul D. Smith负责</p>
<p>GNU make符合IEEE标准1003.2-1992 (POSIX.2)第6.2节。<br>我们的例子展示了C程序，因为它们是最常见的，但是您可以使用make与任何可以用shell命令运行编译器的编程语言一起使用。事实上，make并不局限于程序。您可以使用它来描述任何任务，其中一些文件必须在其他文件发生更改时自动更新其他文件。</p>
<h4 id="makefile是什么样的文件："><a href="#makefile是什么样的文件：" class="headerlink" title="makefile是什么样的文件："></a>makefile是什么样的文件：</h4><p>make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。</p>
<p>要准备使用make，您必须编写一个名为makefile的文件，该文件描述程序中文件之间的关系，并提供用于更新每个文件的命令。通常，在一个程序中，可执行文件从目标文件中更新，而目标文件又通过编译源文件而生成。</p>
<p>一旦有了合适的makefile，每次你修改一些源文件时，这个简单的shell命令: make<br>足够执行所有必要的重新编译。make程序使用makefile数据库和文件的最后修改时间来决定哪些文件需要更新。对于这些文件中的每一个，它都会发出在数据库中记录的recipes</p>
<h4 id="makefiles介绍："><a href="#makefiles介绍：" class="headerlink" title="makefiles介绍："></a>makefiles介绍：</h4><p>您需要一个名为makefile的文件来告诉make做什么。通常，makefile告诉make如何编译和链接程序。<br>1  若一个头文件变了，那每个包含该头文件的c源文件必须被重新编译<br>2  当make开始重新编译时，每个改变过的c源文件必须被重新编译；<br>3  每个编译过程产生一个目标文件关联源文件；<br>4  最后，若任一源文件发生重编，全部目标文件，必须重新连接产生新的可执行目标程序，不管这个时候是新产生还是覆盖之前的编译保存的；  </p>
<h4 id="makefile中的规则："><a href="#makefile中的规则：" class="headerlink" title="makefile中的规则："></a>makefile中的规则：</h4><p>每个规则由以下三部分组成：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">target … : prerequisites …</span><br><span class="line">        recipe</span><br><span class="line">        …</span><br><span class="line">        …</span><br><span class="line">目标：</span><br><span class="line">A target is usually <span class="keyword">the</span> name <span class="keyword">of</span> <span class="keyword">a</span> <span class="built_in">file</span> that is generated <span class="keyword">by</span> <span class="keyword">a</span> program;examples <span class="keyword">of</span> targets are executable <span class="keyword">or</span> object <span class="built_in">files</span>.</span><br><span class="line">A target can also be <span class="keyword">the</span> name <span class="keyword">of</span> <span class="keyword">an</span> action <span class="built_in">to</span> carry out, such <span class="keyword">as</span> ‘clean’ (see Phony Targets).</span><br><span class="line">A target depends <span class="keyword">on</span> <span class="title">several</span> <span class="title">files</span>.</span><br><span class="line">命令：</span><br><span class="line">A recipe may have more than <span class="literal">one</span> <span class="keyword">command</span>, <span class="title">either</span> <span class="title">on</span> <span class="title">the</span> <span class="title">same</span> <span class="title">line</span> <span class="title">or</span> <span class="title">each</span> <span class="title">on</span> <span class="title">its</span> <span class="title">own</span> <span class="title">line</span>.</span><br><span class="line"><span class="built_in">put</span> <span class="keyword">a</span> <span class="literal">tab</span> <span class="keyword">character</span> <span class="keyword">at</span> <span class="keyword">the</span> beginning <span class="keyword">of</span> every recipe <span class="built_in">line</span>!</span><br><span class="line">RECIPEPREFIX 用于设置不用<span class="literal">tab</span>而用别的字符</span><br><span class="line">依赖文件：</span><br><span class="line">prerequisites:是依赖的文件，它存在是为了在文件更新时，重新执行recipe以重新生成目标的作用；</span><br><span class="line"> 因为若是不需要：则直接类似clean， </span><br><span class="line"> clean： </span><br><span class="line">    rm -rf main 类似这样的写法； </span><br><span class="line">main: </span><br><span class="line">    gcc -o main main.cpp 就可以，</span><br><span class="line">    但是这样main.cpp更新的时候，make不会重新生成 </span><br><span class="line">main: main.cpp </span><br><span class="line">    gcc -o main main.cpp hh.cpp </span><br><span class="line">    这样hh.cpp变更的时候，make也是不会更新的，必须也把hh.cpp写到prerequisites 中</span><br><span class="line"></span><br><span class="line">clean’ does <span class="keyword">not</span> have prerequisites.</span><br><span class="line">总的来讲，规则：</span><br><span class="line">A rule, <span class="keyword">then</span>,  explains how <span class="keyword">and</span> when <span class="built_in">to</span> remake certain <span class="built_in">files</span> which are <span class="keyword">the</span> targets <span class="keyword">of</span> <span class="keyword">the</span> particular rule</span><br><span class="line">A rule can also explain how <span class="keyword">and</span> when <span class="built_in">to</span> carry out <span class="keyword">an</span> action.</span><br><span class="line">A makefile may contain other <span class="keyword">text</span> besides rules</span><br></pre></td></tr></table></figure>


<h4 id="一个简单的例子："><a href="#一个简单的例子：" class="headerlink" title="一个简单的例子："></a>一个简单的例子：</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">edit</span> : main.<span class="keyword">o</span> kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">display</span>.<span class="keyword">o</span> \</span><br><span class="line">       <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> utils.<span class="keyword">o</span></span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">o</span> <span class="keyword">edit</span> main.<span class="keyword">o</span> kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">display</span>.<span class="keyword">o</span> \</span><br><span class="line">                   <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> utils.<span class="keyword">o</span></span><br><span class="line"></span><br><span class="line">main.<span class="keyword">o</span> : main.<span class="keyword">c</span> defs.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> main.<span class="keyword">c</span></span><br><span class="line">kbd.<span class="keyword">o</span> : kbd.<span class="keyword">c</span> defs.h <span class="keyword">command</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> kbd.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">command</span>.<span class="keyword">o</span> : <span class="keyword">command</span>.<span class="keyword">c</span> defs.h <span class="keyword">command</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">command</span>.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">display</span>.<span class="keyword">o</span> : <span class="keyword">display</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">display</span>.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">insert</span>.<span class="keyword">o</span> : <span class="keyword">insert</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">insert</span>.<span class="keyword">c</span></span><br><span class="line"><span class="built_in">search</span>.<span class="keyword">o</span> : <span class="built_in">search</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="built_in">search</span>.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">files</span>.<span class="keyword">o</span> : <span class="keyword">files</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h <span class="keyword">command</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">files</span>.<span class="keyword">c</span></span><br><span class="line">utils.<span class="keyword">o</span> : utils.<span class="keyword">c</span> defs.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> utils.<span class="keyword">c</span></span><br><span class="line">clean :</span><br><span class="line">        rm <span class="keyword">edit</span> main.<span class="keyword">o</span> kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">display</span>.<span class="keyword">o</span> \</span><br><span class="line">           <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> utils.<span class="keyword">o</span></span><br></pre></td></tr></table></figure>

<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>In fact, each ‘.o’ file is both a target and a prerequisite.<br>Recipes include ‘cc -c main.c’ and ‘cc -c kbd.c’.<br>main.o 也可以通过make main.o生成<br>什么时候会真的重编译链接：注意当一个目标是文件时，若任何它的依赖改变，它需要被重新编译或链接；<br>并且：任何依赖自身也应该先被自动更新再生成；<br>When a target is a file, it needs to be recompiled or relinked if any of its prerequisites change<br>In addition, any prerequisites that are themselves automatically generated should be updated first.  </p>
<p>生成规则是由使用者定的，make会执行给定的规则中的每一行：<br>比如下面给了两行，当main.o发生改变时，make的时候就会执行下面两个gcc   </p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>: <span class="selector-tag">main</span><span class="selector-class">.o</span> </span><br><span class="line">    gcc -c <span class="selector-tag">main</span><span class="selector-class">.cpp</span> </span><br><span class="line">    gcc -o <span class="selector-tag">main</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> </span><br></pre></td></tr></table></figure>

<p>phony targets<br>虚假目标的概念，不依赖其他文件，执行时需要明确指出目标如： make clean </p>
<p>default goal.<br>make会把第一个目标当成默认目标，则 注意位置：  </p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">hh<span class="selector-class">.o</span>: hh<span class="selector-class">.cpp</span> hh<span class="selector-class">.h</span> </span><br><span class="line">    gcc -c hh<span class="selector-class">.cpp</span> </span><br><span class="line"><span class="selector-tag">main</span>: <span class="selector-tag">main</span><span class="selector-class">.cpp</span> hh<span class="selector-class">.cpp</span> </span><br><span class="line">    gcc -o <span class="selector-tag">main</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span> hh<span class="selector-class">.cpp</span> </span><br></pre></td></tr></table></figure>

<p>这样make的时候，是只会执行gcc -c hh.cpp 注意这里hh.o不依赖main </p>
<ul>
<li>规则的递归依赖重生成 解释下：makefile如下 重要！！！<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~/c++$ cat makefile </span><br><span class="line"><span class="selector-tag">main</span>: hh<span class="selector-class">.o</span> <span class="selector-tag">main</span><span class="selector-class">.o</span></span><br><span class="line">	gcc -o <span class="selector-tag">main</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> hh<span class="selector-class">.o</span></span><br><span class="line">hh<span class="selector-class">.o</span>: hh<span class="selector-class">.cpp</span> hh<span class="selector-class">.h</span></span><br><span class="line">	gcc -c hh<span class="selector-class">.cpp</span></span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.o</span>: <span class="selector-tag">main</span><span class="selector-class">.cpp</span></span><br><span class="line">	gcc -c <span class="selector-tag">main</span><span class="selector-class">.cpp</span></span><br><span class="line">首次make</span><br><span class="line">think@think-VirtualBox:~/c++$ make </span><br><span class="line">gcc -c <span class="selector-tag">main</span><span class="selector-class">.cpp</span></span><br><span class="line">gcc -o <span class="selector-tag">main</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> hh<span class="selector-class">.o</span></span><br><span class="line">改变hh<span class="selector-class">.h</span>,重新生成hh.o和<span class="selector-tag">main</span></span><br><span class="line">think@think-VirtualBox:~/c++$ vim hh<span class="selector-class">.h</span></span><br><span class="line">think@think-VirtualBox:~/c++$ make </span><br><span class="line">gcc -c hh<span class="selector-class">.cpp</span></span><br><span class="line">gcc -o <span class="selector-tag">main</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> hh<span class="selector-class">.o</span></span><br><span class="line">删除<span class="selector-tag">main</span><span class="selector-class">.o</span> make重新生成<span class="selector-tag">main</span>.o和main，不改变hh<span class="selector-class">.o</span></span><br><span class="line">think@think-VirtualBox:~/c++$ rm -rf <span class="selector-tag">main</span><span class="selector-class">.o</span></span><br><span class="line">think@think-VirtualBox:~/c++$ make </span><br><span class="line">gcc -c <span class="selector-tag">main</span><span class="selector-class">.cpp</span></span><br><span class="line">gcc -o <span class="selector-tag">main</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> hh<span class="selector-class">.o</span></span><br><span class="line">修改<span class="selector-tag">main</span>.cpp，重新生成<span class="selector-tag">main</span>.o和<span class="selector-tag">main</span></span><br><span class="line">think@think-VirtualBox:~/c++$ vim <span class="selector-tag">main</span><span class="selector-class">.cpp</span> </span><br><span class="line">think@think-VirtualBox:~/c++$ make </span><br><span class="line">gcc -c <span class="selector-tag">main</span><span class="selector-class">.cpp</span></span><br><span class="line">gcc -o <span class="selector-tag">main</span> <span class="selector-tag">main</span><span class="selector-class">.o</span> hh<span class="selector-class">.o</span></span><br><span class="line">think@think-VirtualBox:~/c++$</span><br></pre></td></tr></table></figure></li>
</ul>
<p>But make would update automatically generated C programs, such as those made by Bison or Yacc, by their own rules at this time.<br>特例，暂时没用上<br>Thus, if we change the file insert.c and run make, make will compile that file to update insert.o, and then link edit. If we change the file<br>command.h and run make, make will recompile the object files kbd.o, command.o and files.o and then link the file edit.</p>
<h4 id="makefile中的变量使用："><a href="#makefile中的变量使用：" class="headerlink" title="makefile中的变量使用："></a>makefile中的变量使用：</h4><p>We would define such a variable objects with a line like this in the makefile:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">objects = main.<span class="keyword">o</span> kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">display</span>.<span class="keyword">o</span> \</span><br><span class="line">          <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> utils.<span class="keyword">o</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">edit</span> : $(objects)</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">o</span> <span class="keyword">edit</span> $(objects)</span><br><span class="line">main.<span class="keyword">o</span> : main.<span class="keyword">c</span> defs.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> main.<span class="keyword">c</span></span><br><span class="line">kbd.<span class="keyword">o</span> : kbd.<span class="keyword">c</span> defs.h <span class="keyword">command</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> kbd.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">command</span>.<span class="keyword">o</span> : <span class="keyword">command</span>.<span class="keyword">c</span> defs.h <span class="keyword">command</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">command</span>.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">display</span>.<span class="keyword">o</span> : <span class="keyword">display</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">display</span>.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">insert</span>.<span class="keyword">o</span> : <span class="keyword">insert</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">insert</span>.<span class="keyword">c</span></span><br><span class="line"><span class="built_in">search</span>.<span class="keyword">o</span> : <span class="built_in">search</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="built_in">search</span>.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">files</span>.<span class="keyword">o</span> : <span class="keyword">files</span>.<span class="keyword">c</span> defs.h <span class="keyword">buffer</span>.h <span class="keyword">command</span>.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">files</span>.<span class="keyword">c</span></span><br><span class="line">utils.<span class="keyword">o</span> : utils.<span class="keyword">c</span> defs.h</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> utils.<span class="keyword">c</span></span><br><span class="line">clean :</span><br><span class="line">        rm <span class="keyword">edit</span> $(objects)</span><br></pre></td></tr></table></figure>


<ul>
<li><p>makefile中的隐式规则：<br>上述的可以简化为：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">implicit rule <span class="keyword">for</span> updating <span class="keyword">a</span> ‘.<span class="keyword">o</span>’ <span class="keyword">file</span> from <span class="keyword">a</span> correspondingly named ‘.<span class="keyword">c</span>’ <span class="keyword">file</span> using <span class="keyword">a</span> ‘<span class="keyword">cc</span> -<span class="keyword">c</span>’ <span class="keyword">command</span>.</span><br><span class="line">objects = main.<span class="keyword">o</span> kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">display</span>.<span class="keyword">o</span> \</span><br><span class="line">          <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> utils.<span class="keyword">o</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">edit</span> : $(objects)</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">o</span> <span class="keyword">edit</span> $(objects)</span><br><span class="line"></span><br><span class="line">main.<span class="keyword">o</span> : defs.h</span><br><span class="line">kbd.<span class="keyword">o</span> : defs.h <span class="keyword">command</span>.h</span><br><span class="line"><span class="keyword">command</span>.<span class="keyword">o</span> : defs.h <span class="keyword">command</span>.h</span><br><span class="line"><span class="keyword">display</span>.<span class="keyword">o</span> : defs.h <span class="keyword">buffer</span>.h</span><br><span class="line"><span class="keyword">insert</span>.<span class="keyword">o</span> : defs.h <span class="keyword">buffer</span>.h</span><br><span class="line"><span class="built_in">search</span>.<span class="keyword">o</span> : defs.h <span class="keyword">buffer</span>.h</span><br><span class="line"><span class="keyword">files</span>.<span class="keyword">o</span> : defs.h <span class="keyword">buffer</span>.h <span class="keyword">command</span>.h</span><br><span class="line">utils.<span class="keyword">o</span> : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">        rm <span class="keyword">edit</span> $(objects)</span><br></pre></td></tr></table></figure>
</li>
<li><p>继续简化：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">objects = main.<span class="keyword">o</span> kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">display</span>.<span class="keyword">o</span> \</span><br><span class="line">          <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> utils.<span class="keyword">o</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">edit</span> : $(objects)</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">o</span> <span class="keyword">edit</span> $(objects)</span><br><span class="line"></span><br><span class="line">$(objects) : defs.h</span><br><span class="line">kbd.<span class="keyword">o</span> <span class="keyword">command</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> : <span class="keyword">command</span>.h</span><br><span class="line"><span class="keyword">display</span>.<span class="keyword">o</span> <span class="keyword">insert</span>.<span class="keyword">o</span> <span class="built_in">search</span>.<span class="keyword">o</span> <span class="keyword">files</span>.<span class="keyword">o</span> : <span class="keyword">buffer</span>.h</span><br></pre></td></tr></table></figure>
</li>
<li><p>伪目标的意义：<br>.PHONY : clean<br>声明clean是伪目标<br>This prevents make from getting confused by an actual file called clean and causes it to continue in spite of errors from rm.<br>(See Phony Targets, and Errors in Recipes.)</p>
</li>
</ul>
<h3 id="如何写makefile？"><a href="#如何写makefile？" class="headerlink" title="如何写makefile？"></a>如何写makefile？</h3><p>make依赖读取一个叫makefile的数据库中的信息来知道怎么重新编译一个系统</p>
<h4 id="makefile文件包含什么："><a href="#makefile文件包含什么：" class="headerlink" title="makefile文件包含什么："></a>makefile文件包含什么：</h4><ul>
<li><p>组成：显示规则，隐式规则，变量定义，指令和注释<br>显示规则：说明什么时候和怎么去重新make一个或多个称为目标的文件；它列出了目标依赖的所有文件，即prerequisites，它也给出怎么创建和更新目标的指令如gcc<br>隐式规则：说明什么时候和怎么去重新make一类文件基于他们的名字，它描述了目标如何依赖于名称与目标类似的文件，并给出了创建或更新这样一个目标的方法。<br>变量：是为以后可以替换到文本中的变量指定文本字符串值的一行。<br>指令是哪些呢？  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">读取另一个makefile  </span><br><span class="line">类似条件判断，忽略一部分逻辑  </span><br><span class="line">从包含多行的逐字字符串定义变量  </span><br></pre></td></tr></table></figure>
<p>关于注释： # 开头，\ 可以跨行注释，不能在变量中用#，# 可以起到在字符中转义的作用；</p>
</li>
<li><p>makefile对行的处理：<br>makefile使用一种“基于行”的语法，其中换行符是特殊的，并标记语句的结束。GNU make对语句行的长度没有限制，直到您计算机中的内存大小。<br>通过\反斜杠转义内部的换行符，从而延长一个行；以换行符结束(不管是否转义)作为物理行，以完整语句直到非转义换行符作为逻辑行；<br>eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    main: edit.o main.o \  物理行</span><br><span class="line">        k.o   # 逻辑行</span><br><span class="line">        gcc -o main main.o k.o edit.o</span><br><span class="line"></span><br><span class="line">注意：指令行：recipe行可能处理有点不同，对非指令行来讲，换行时多个连续的空格会被压缩成一个；</span><br><span class="line">一个小技巧：</span><br><span class="line">若你不想在通过\续行后，出现空格，比如：</span><br><span class="line">var := one\</span><br><span class="line">       word</span><br><span class="line">后解析为：</span><br><span class="line">var := one word</span><br><span class="line">则可以写成这样：</span><br><span class="line">var := one$\</span><br><span class="line">       word</span><br><span class="line">这样会得到：</span><br><span class="line">var := oneword</span><br><span class="line">原因：美元符号加\ 在make将\和前面的空格压缩为一个空格后为： one$ word， 而之后，<span class="string">&#x27;$ &#x27;</span>会被make识别为<span class="string">&#x27; &#x27;</span>为名的变量，而这个变量不存在，就会用空字符串替代</span><br><span class="line">变成 var := oneword</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="makefile文件的命名；"><a href="#makefile文件的命名；" class="headerlink" title="makefile文件的命名；"></a>makefile文件的命名；</h4><p>makefile文件可以命名为：makefile&#x2F;Makefile&#x2F;GNUmakefile,推荐第二种；不推荐第三种，因为其他make程序不认；<br>如果不想用默认的，即make时会默认找上面的三种文件，找不到又没有指定，则无法make，可以通过-f &#x2F;–file 来指定make的文件；<br>如make -f mymakefile;还可以指定多个： make -f mymakefile -f yourmakefile;  </p>
<h4 id="一个makefile文件如何使用其他makefile文件"><a href="#一个makefile文件如何使用其他makefile文件" class="headerlink" title="一个makefile文件如何使用其他makefile文件"></a>一个makefile文件如何使用其他makefile文件</h4><p>语法：<br>include filename…  </p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line"><span class="keyword">include</span> foo *.mk $(bar)</span><br><span class="line"><span class="keyword">include</span> aa.mk bish bash</span><br><span class="line"><span class="keyword">include</span> aa.mk bb.mk</span><br><span class="line"><span class="keyword">include</span> <span class="regexp">/user/</span>local/m.mk</span><br></pre></td></tr></table></figure>
<p>如果指定的名称不以斜杠开头，并且在当前目录中找不到该文件，则会搜索其他几个目录。<br>首先，搜索使用’ -I ‘或’——include-dir ‘选项指定的任何目录。<br>然后搜索以下目录(如果它们存在的话)，顺序如下:prefix&#x2F;include(通常是&#x2F;usr&#x2F;local&#x2F;include 1) &#x2F;usr&#x2F;gnu&#x2F;include， &#x2F;usr&#x2F;local&#x2F;include， 找不到则警告，若不想要警告信息，可以用这个语法：<br>-include filenames…  </p>
<h4 id="MAKEFILES变量；类似于include"><a href="#MAKEFILES变量；类似于include" class="headerlink" title="MAKEFILES变量；类似于include"></a>MAKEFILES变量；类似于include</h4><p>如果你的当前环境中定义了环境变量 MAKEFILES ，那么，make会把这个变量中的值做一个类似于 include 的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和 include 不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>
<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。<br>在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<h4 id="overrding-makefiles"><a href="#overrding-makefiles" class="headerlink" title="overrding makefiles"></a>overrding makefiles</h4><p>有时，拥有一个与另一个makefile基本相同的makefile是很有用的。<br>你可以经常使用’ include ‘指令将一个包含到另一个中，并添加更多的目标或变量定义。但是，两个makefile为同一个目标提供不同的recipes(指令)是无效的。但还有另一种方法。</p>
<h4 id="make如何读取makefile"><a href="#make如何读取makefile" class="headerlink" title="make如何读取makefile"></a>make如何读取makefile</h4><p>GNU的make工作时的执行步骤如下：（想来其它的make也是类似）  </p>
<p>1 读入所有的Makefile。<br>2 读入被include的其它Makefile。<br>3 初始化文件中的变量。<br>4 推导隐晦规则，并分析所有规则。<br>5 为所有的目标文件创建依赖关系链。<br>6 根据依赖关系，决定哪些目标要重新生成。<br>7 执行生成命令。<br>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。  </p>
<p>当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>
<h4 id="make如何解析makefile"><a href="#make如何解析makefile" class="headerlink" title="make如何解析makefile"></a>make如何解析makefile</h4><h4 id="How-and-when-secondary-expansion-is-performed"><a href="#How-and-when-secondary-expansion-is-performed" class="headerlink" title="How and when secondary expansion is performed."></a>How and when secondary expansion is performed.</h4><h3 id="makefile的规则书写"><a href="#makefile的规则书写" class="headerlink" title="makefile的规则书写"></a>makefile的规则书写</h3><p>如果默认目标没有指定，则默认第一个规则的第一个目标为默认目标，有两个例外，以句号开头的目标除非包含&#x2F; ;<br>所以我们经常用第一个规则来编整个程序或者以all: 描述整个程序；</p>
<h4 id="Rule的例子"><a href="#Rule的例子" class="headerlink" title="Rule的例子"></a>Rule的例子</h4><p>一个例子和解释：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">foo.o : foo.<span class="keyword">c</span> defs.h       # <span class="keyword">module</span> for twiddling the frobs</span><br><span class="line">        <span class="keyword">cc</span> -<span class="keyword">c</span> -g foo.<span class="keyword">c</span></span><br></pre></td></tr></table></figure>
<p>这个规则说明：</p>
<ol>
<li>如何确定foo.o过期了： 它不存在或者foo.c&#x2F;defs.h 比它更新  </li>
<li>如何更新foo.o: 通过运行cc，这个规则没有显示指定defs.h,但是c文件肯定包含，需要加到依赖；</li>
</ol>
<h4 id="Rule语法"><a href="#Rule语法" class="headerlink" title="Rule语法"></a>Rule语法</h4><figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">targets</span><span class="punctuation"> :</span> <span class="string">prerequisites</span></span><br><span class="line">        <span class="attribute">recipe</span></span><br><span class="line"><span class="attribute">        …</span></span><br><span class="line"><span class="attribute">or like</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">targets</span><span class="punctuation"> :</span> <span class="string">prerequisites ; recipe</span></span><br><span class="line">        recipe</span><br><span class="line">        …</span><br></pre></td></tr></table></figure>
<ul>
<li>目标: 一般是文件名，由空格分割，可以使用通配符，并且a(m)代表归档文件中a中的成员m,通常一个规则一个目标，也可能有多个；  </li>
<li>规则: 以tab开头，可以是上面的两种方式，注意分号；  </li>
<li>变量：因为变量是以美元符号$开头的，所以若要在目标和依赖中写$,则必须用两个$,如$$.若已经使用了二次扩展，且想在其中放$,则要用四个$  </li>
<li>反斜杠用来延长行；  </li>
<li>指令其实不止是gcc,还可以是其他shell指令</li>
</ul>
<h4 id="依赖文件的类型"><a href="#依赖文件的类型" class="headerlink" title="依赖文件的类型"></a>依赖文件的类型</h4><p>一般的任何依赖更新了，目标都要更新；</p>
<h4 id="Wildcards-通配符-用法"><a href="#Wildcards-通配符-用法" class="headerlink" title="Wildcards(通配符)用法"></a>Wildcards(通配符)用法</h4><p>单个文件名可以使用通配符匹配多个文件,在make中，通配符有：*,?,[…]等，和shell相同，如*.c表示所有.c结尾的文件；<br>文件名开头的“<del>”字符也具有特殊意义，</del>&#x2F;bin表示主目录下的bin,~joh&#x2F;bin表示&#x2F;home&#x2F;joh&#x2F;bin，即主目录名为joh<br>通配符扩展由make在目标和先决条件中自动执行。在recipes中，shell负责通配符扩展。在其他情况下，通配符扩展只有在使用通配符函数显式请求时才会发生<br>可以通过反斜杠来转义通配符；<br>这里用的是os中的shell所支持的通配符；</p>
<h5 id="通配符的例子："><a href="#通配符的例子：" class="headerlink" title="通配符的例子："></a>通配符的例子：</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">在指令中使用，由shell扩展：</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -f *.o</span><br><span class="line">在依赖中：</span><br><span class="line"><span class="section">print: *.c</span></span><br><span class="line">        lpr -p <span class="variable">$?</span>  </span><br><span class="line">        touch print</span><br><span class="line">定义变量，变量中使用比较特殊：</span><br><span class="line">objects = *.o 这个是错误的，需要用：objects := <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；"><a href="#通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；" class="headerlink" title="通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；"></a>通配符的陷阱，比如变量中的通配符需要加wildcard，往往忘记；</h5><h5 id="通配符函数："><a href="#通配符函数：" class="headerlink" title="通配符函数："></a>通配符函数：</h5><p>通配符扩展在规则中自动发生。但是，当设置了变量或函数的参数时，通配符展开通常不会发生。如果你想在这些地方进行通配符扩展，你需要使用通配符函数，像这样:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">$(<span class="params">wildcard</span> <span class="params">pattern</span>…)</span></span><br></pre></td></tr></table></figure>
<p>一般我们可以使用“$(wildcard *.c)”来获取工作目录下的所有的.c文件列表。复杂一些用法；可以使用“$(patsubst %.c,%.o,$(wildcard *.c))”，<br>首先使用“wildcard”函数获取工作目录下的.c文件列表；之后将列表中所有文件名的后缀.c替换为.o。这样我们就可以得到在当前目录可生成的.o文件列表。<br>因此在一个目录下可以使用如下内容的Makefile来将工作目录下的所有的.c文件进行编译并最后连接成为一个可执行文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line"> </span><br><span class="line">foo : <span class="variable">$(objects)</span></span><br><span class="line">cc -o foo <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<h4 id="目录搜索，为源文件搜索其他路径"><a href="#目录搜索，为源文件搜索其他路径" class="headerlink" title="目录搜索，为源文件搜索其他路径"></a>目录搜索，为源文件搜索其他路径</h4><p>对一些大型系统，常常将源文件放在各种分离的目录下，则目录搜索作为make的一个有用特性，可以轻易搜索一些目录，自动找到依赖；当在这些目录中重新分配文件时，不需要改规则，只需要改搜索路径；<br>需要注意的是，make的搜索，和指令中的编译器等搜索不同，虽然你在make中指定了，但是如果头文件在不同的目录，使用gcc时，<br>或者通过#include的时候，协商所有路径，否则，需要指定-I gcc -I dir  </p>
<p>make这里的搜索，更多的体现在依赖文件，指令中指定的文件等</p>
<h5 id="整体搜索"><a href="#整体搜索" class="headerlink" title="整体搜索"></a>整体搜索</h5><p>具体化一个搜索路径应用到所有依赖；<br>make uses VPATH as a search list for both prerequisites and targets of rules.<br>所以，如果列在目标或依赖中的文件不在当前的目录，make会在VPATH定义的目录里面找文件名，找到就算；仿佛它们存在当前的目录一样；<br>VPATH定义的目录，由空格或冒号隔开：<br>eg: VPATH &#x3D; src:..&#x2F;headers<br>所以假设没有在当前目录找到，在src中找到，则：这样的规则：<br> foo.o:foo.c &#x3D;&#x3D;&#x3D;&gt; foo.o:src&#x2F;foo.c<br>注意顺序，即会先从本地找，没有再src找，没有再..&#x2F;headers中找；</p>
<h5 id="选择性搜索"><a href="#选择性搜索" class="headerlink" title="选择性搜索"></a>选择性搜索</h5><p>为一类名字具体化一个搜索路径<br>使用vpath，注意是小写，允许你具体化一类文件名，只要匹配上具体的模式；因此你可以指定一类名字匹配这个目录，其他名字匹配其他目录：<br>有三种组成：</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) vpath pattern directories : 具体化搜索目录为那些匹配上这个pattern的文件名；注意目录间隔是冒号</span><br><span class="line"><span class="number">2</span>) vpath pattern : 清除这个pattern的搜索路径关联</span><br><span class="line"><span class="number">3</span>) vpath :清除所有的vpath 指定</span><br><span class="line">一个vpath是一个包含<span class="comment">%的字符串，字符串必须匹配正在搜索的先决条件的文件名，&#x27; % &#x27;字符匹配任何0个或多个字符的序列(如模式规则;参见定义和重新定义模式规则)</span></span><br><span class="line">例如，<span class="comment">%.h匹配以.h结尾的文件。(如果没有&#x27; % &#x27;，则模式必须完全匹配先决条件，这通常是不太有用的</span></span><br><span class="line">作用： 当一个依赖中的文件在当前目录不存在时，并且文件名匹配上面的模式时，就会去搜索被vpath指定的目录；</span><br><span class="line">eg:</span><br><span class="line">    vpath <span class="comment">%.h ../headers</span></span><br><span class="line">如果有多个目录，则一个接一个进行搜索：</span><br><span class="line">vpath <span class="comment">%.c foo</span></span><br><span class="line">vpath <span class="comment">%   blish</span></span><br><span class="line">vpath <span class="comment">%.c bar</span></span><br><span class="line">先foo，再blish，再bar</span><br><span class="line">vpath <span class="comment">%.c foo:bar</span></span><br><span class="line">vpath <span class="comment">%   blish</span></span><br><span class="line">先foo,再bar,再blish</span><br></pre></td></tr></table></figure>

<h5 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h5><p>搜索路径什么时候，如何被应用；<br>当通过目录搜索找到先决条件时，不管类型是什么(通用的还是选择性的)，所找到的路径名可能不是make在先决条件列表中实际提供给您的路径名。有时，通过目录搜索发现的路径被丢弃。<br>make通过如下的信息来决定是否保持和丢弃一个路径：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)如果在makefile中指定的路径上不存在目标文件，则执行目录搜索。</span><br><span class="line"><span class="number">2</span>)如果目录搜索成功，则保留该路径，并暂时将该文件存储为目标。</span><br><span class="line"><span class="number">3</span>)使用相同的方法检查此目标的所有先决条件。</span><br><span class="line"><span class="number">4</span>)处理完先决条件后，可能需要也可能不需要重建目标</span><br><span class="line">   <span class="selector-tag">a</span> 如果不需要重新构建目标，在目录搜索期间找到的文件的路径将用于包含该目标的任何先决条件列表。简而言之，如果make不需要重新构建目标，那么您可以使用通过目录搜索找到的路径。</span><br><span class="line">   <span class="selector-tag">b</span> 如果目标确实需要重新构建(已过期)，则丢弃在目录搜索期间找到的路径名，并使用makefile中指定的文件名重新构建目标。简而言之，如果make必须重新生成，则在本地重新生成目标，而不是在通过目录搜索找到的目录中。</span><br></pre></td></tr></table></figure>

<p>对其他版本的make也是类似的，如果想要做到在搜索到的路径下生成目标：如：<br>如果文件不存在，并且通过目录搜索找到了它，那么无论是否需要构建目标，都会使用该路径名。因此，如果重新构建目标，则在目录搜索期间发现的路径名处创建目标。<br>则使用GPATH:<br>具有与VPATH相同的语法和格式(即以空格或冒号分隔的路径名列表)。如果通过目录搜索在GPATH中也出现的目录中找到一个过期的目标，那么该路径名不会被丢弃。使用扩展的路径重新生成目标。  </p>
<h5 id="指令搜索：-如何写一个指令能和搜索路径一起工作"><a href="#指令搜索：-如何写一个指令能和搜索路径一起工作" class="headerlink" title="指令搜索： 如何写一个指令能和搜索路径一起工作"></a>指令搜索： 如何写一个指令能和搜索路径一起工作</h5><p>比如：你的依赖通过目录搜索在其他路径中被找到，但是在指令中，写的依赖文件的路径还是原来的，那么如何改变使得make可以在指令执行时找到正确的依赖呢？<br>这是通过自动变量完成的，比如’ $^ ‘(参见自动变量)。例如，’ $^ ‘的值是规则的所有先决条件的列表，包括在其中找到它们的目录名，’ $@ ‘的值是目标</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">        cc -c $(CFLAGS) $^ -o $@</span><br></pre></td></tr></table></figure>
<p>如果你只想要依赖中的第一个文件，比如下面的不要依赖头文件，则：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">VPATH = src:../headers</span><br><span class="line">foo.o : foo.c defs.h hack.h</span><br><span class="line">        cc -c $(CFLAGS) $&lt; -o $@</span><br></pre></td></tr></table></figure>

<h5 id="隐式规则索索；"><a href="#隐式规则索索；" class="headerlink" title="隐式规则索索；"></a>隐式规则索索；</h5><p>搜索路径如何影响隐式规则，如果没有声明显示规则，那make会使用隐式规则，若在当前目录找不到，则会去VPATH&#x2F;vpath指定的路径搜索，找到则会被应用；</p>
<h5 id="链接库搜索；"><a href="#链接库搜索；" class="headerlink" title="链接库搜索；"></a>链接库搜索；</h5><p>链接库的目录搜索，当依赖中有库文件时，可以使用-lname的方式来指定依赖：<br>当依赖中的名字有类似 ‘-lname’,则make会在特别的在当前目录搜索文件libname.so,如果找不到，就在当前目录找libname.a；然后找不到继续在VPATH&#x2F;vpath&#x2F; &#x2F;usr&#x2F;lib等找；<br>比如：有文件&#x2F;usr&#x2F;lib&#x2F;libcurses.a ，但是没有so则</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">foo : foo.c -lcurses</span><br><span class="line">        cc $^ -o $@</span><br></pre></td></tr></table></figure>
<p>会找到.a ,执行‘cc foo.c &#x2F;usr&#x2F;lib&#x2F;libcurses.a -o foo’<br>解释下：尽管要搜索的默认文件集是libname。所以,库名.a，这是通过. libpatterns变量定制的。这个变量值中的每个单词都是一个模式字符串。<br>当看到像’ -lname ‘这样的先决条件时，make将用name替换列表中每个模式中的百分比，并使用每个库文件名执行上述目录搜索。<br>.LIBPATTERNS is ‘lib%.so lib%.a’</p>
<h4 id="伪目标，强制目标-空目标-特殊目标，多目标"><a href="#伪目标，强制目标-空目标-特殊目标，多目标" class="headerlink" title="伪目标，强制目标 空目标 特殊目标，多目标"></a>伪目标，强制目标 空目标 特殊目标，多目标</h4><h5 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h5><p>虚假目标不是真正的文件名;相反，它只是在发出显式请求时要执行的配方的名称。使用假目标有两个原因:避免与同名文件的冲突，以及提高性能。<br>因为rm命令不会创建一个名为clean的文件，所以可能永远不会存在这样的文件。因此，每当您说“make clean”时，rm命令将被执行。</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">clean:</span></span><br><span class="line">        rm *.o temp</span><br></pre></td></tr></table></figure>
<p>在本例中，如果在此目录中创建了一个名为clean的文件，则clean目标将不能正常工作。因为它没有先决条件，<br>所以clean总是被认为是最新的，它的指令不会被执行。为了避免这个问题，您可以显式地声明目标为假的，方法是将它作为特殊目标.PHONY的依赖，如下所示:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm *.o temp</span><br></pre></td></tr></table></figure>
<p>一旦完成，’ make clean ‘将运行指令，而不管是否有一个名为clean的文件<br>假目标在与make的递归调用结合使用时也很有用(请参阅make的递归使用)。在这种情况下，<br>makefile通常会包含一个变量，其中列出了许多要构建的子目录。用一个循环来处理，像这样:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SUBDIRS </span>= foo <span class="keyword">bar </span><span class="keyword">baz</span></span><br><span class="line"><span class="keyword"></span><span class="symbol"></span></span><br><span class="line"><span class="symbol">subdirs:</span></span><br><span class="line">        for <span class="keyword">dir </span>in $(<span class="keyword">SUBDIRS); </span>do \</span><br><span class="line">          $(MAKE) -C $$<span class="keyword">dir; </span>\</span><br><span class="line">        done</span><br></pre></td></tr></table></figure>
<p>然而，这种方法存在一些问题。首先，在子make中检测到的任何错误都会被该规则忽略，所以即使有一个失败了，它也会继续构建其余的目录。这可以通过添加shell命令来注意错误和退出来克服，<br>但是即使使用-k选项调用make，它也会这样做，这是不幸的。其次，也许是更重要的一点，您不能利用make的能力并行构建目标(请参阅并行执行)，因为只有一条规则。<br>通过声明子目录为.PHONY目标(你必须这样做，因为子目录显然总是存在的;否则它不会被建立)你可以移除上述问题:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SUBDIRS = foo bar baz</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: subdirs $(SUBDIRS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">subdirs: <span class="variable">$(SUBDIRS)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(SUBDIRS)</span>:</span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: baz</span></span><br></pre></td></tr></table></figure>
<p>这样的话，就需要baz先完成，才能完成foo;<br>以上也可以用伪目标来实现：<br>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，<br>但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">all : prog1 prog2 prog3</span><br><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">    cc -o prog1 prog1.o utils.o</span><br><span class="line"></span><br><span class="line">prog2 : prog2.o</span><br><span class="line">    cc -o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">    cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>
<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于默认目标的特性是，总是被执行的，但由于“all”又是一个伪目标，<br>伪目标只是一个标签不会生成文件，所以不会有“all”文件产生。于是，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。 .PHONY :<br>all 声明了“all”这个目标为“伪目标”。（注：这里的显式“.PHONY : all” 不写的话一般情况也可以正确的执行，这样make可通过隐式规则推导出， “all” 是一个伪目标，<br>执行make不会生成“all”文件，而执行后面的多个目标。建议：显式写出是一个好习惯。）</p>
<p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.PHONY : cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">    rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">    rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">    rm *.diff</span><br></pre></td></tr></table></figure>
<p>“make cleanall”将清除所有要被清除的文件。<br>“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。</p>
<h5 id="强制目标：没有依赖或规则的目标："><a href="#强制目标：没有依赖或规则的目标：" class="headerlink" title="强制目标：没有依赖或规则的目标："></a>强制目标：没有依赖或规则的目标：</h5><p>如果一个规则没有依赖或指令，并且规则的目标是一个不存在的文件，那么make就假设这个目标在其规则运行时已被更新。这意味着依赖于此的所有目标都将始终运行它们的指令。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean: FORCE</span></span><br><span class="line">        rm <span class="variable">$(objects)</span></span><br><span class="line"><span class="section">FORCE:</span></span><br></pre></td></tr></table></figure>

<p>在这里，目标“FORCE”满足了特殊条件，所以依赖于它的目标clean将被迫运行其指令。“FORCE”这个名称并没有什么特别之处，但这是一个常用的名称。</p>
<h5 id="空目标文件用来记录事件"><a href="#空目标文件用来记录事件" class="headerlink" title="空目标文件用来记录事件"></a>空目标文件用来记录事件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>: foo.c bar.c</span><br><span class="line">        lpr -p $?</span><br><span class="line">        <span class="built_in">touch</span> <span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<p>有了这个规则，如果任何一个源文件在上次’ make print ‘之后发生了变化，’ make print ‘将执行lpr命令。自动变量’ $?’仅用于打印那些已更改的文件</p>
<h5 id="具体的内建目标名"><a href="#具体的内建目标名" class="headerlink" title="具体的内建目标名"></a>具体的内建目标名</h5><p>.PHONY&#x2F;.SUFFIXES&#x2F;.DEFAULT&#x2F;.PRECIOUS&#x2F;.INTERMEDIATE&#x2F;.SECONDARY&#x2F;.SECONDEXPANSION&#x2F;…</p>
<h5 id="一个规则中的多个目标"><a href="#一个规则中的多个目标" class="headerlink" title="一个规则中的多个目标"></a>一个规则中的多个目标</h5><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">eg：</span><br><span class="line">bigoutput littleoutput : text<span class="variable">.g</span></span><br><span class="line">        <span class="keyword">generate</span> text<span class="variable">.g</span> -$(subst <span class="keyword">output</span>,,$@) &gt; $@</span><br><span class="line">和下面的相同</span><br><span class="line">bigoutput : text<span class="variable">.g</span></span><br><span class="line">        <span class="keyword">generate</span> text<span class="variable">.g</span> -big &gt; bigoutput</span><br><span class="line">littleoutput : text<span class="variable">.g</span></span><br><span class="line">        <span class="keyword">generate</span> text<span class="variable">.g</span> -little &gt; littleoutput </span><br></pre></td></tr></table></figure>
<h4 id="多个规则"><a href="#多个规则" class="headerlink" title="多个规则"></a>多个规则</h4><p>一个目标，多个规则；<br>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，<br>多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个自动化变量 $@ （关于自动化变量，将在后面讲述），<br>这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">bigoutput littleoutput : text<span class="variable">.g</span></span><br><span class="line">    <span class="keyword">generate</span> text<span class="variable">.g</span> -$(subst <span class="keyword">output</span>,,$@) &gt; $@</span><br><span class="line">上述规则等价于：</span><br><span class="line"></span><br><span class="line">bigoutput : text<span class="variable">.g</span></span><br><span class="line">    <span class="keyword">generate</span> text<span class="variable">.g</span> -big &gt; bigoutput</span><br><span class="line">littleoutput : text<span class="variable">.g</span></span><br><span class="line">    <span class="keyword">generate</span> text<span class="variable">.g</span> -little &gt; littleoutput</span><br><span class="line"></span><br><span class="line">其中， -$(subst <span class="keyword">output</span>,,$@) 中的 $ 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思，</span><br><span class="line"> $@ 表示目标的集合，就像一个数组， $@ 依次取出目标，并执于命令。</span><br></pre></td></tr></table></figure>
<h4 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h4><h5 id="静态模式规则的语法："><a href="#静态模式规则的语法：" class="headerlink" title="静态模式规则的语法："></a>静态模式规则的语法：</h5><p>当需要定义多个目标规则，且他们都类似时，可以用静态模式避免写很多规则，就像正则表达式一样;<br>它的语法：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">&lt;targets ...&gt; : &lt;<span class="keyword">target</span>-pattern&gt; : &lt;prereq-patterns ...&gt;</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line">    ...</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">targets:</span> 定义了一系列的目标文件，可以有通配符。是目标的一个集合。</span><br><span class="line"><span class="keyword">target</span>-pattern: 是指明了targets的模式，也就是的目标集模式。</span><br><span class="line">prereq-patterns : 是目标的依赖模式，它对<span class="keyword">target</span>-pattern形成的模式再进行一次依赖目标的定义。</span><br><span class="line">解释下：如果我们的&lt;<span class="keyword">target</span>-pattern&gt;定义成 <span class="variable">%.o</span> ，意思是我们的&lt;<span class="keyword">target</span>&gt;<span class="comment">;集合中都是以 .o 结尾的，而如果我们的&lt;prereq-patterns&gt;定义成 %.c ，</span></span><br><span class="line">意思是对&lt;<span class="keyword">target</span>-pattern&gt;所形成的目标集进行二次定义，其计算方法是，取&lt;<span class="keyword">target</span>-pattern&gt;模式中的 % （也就是去掉了 .o 这个结尾），并为其加上 .<span class="keyword">c</span> 这个结尾，形成的新集合。</span><br><span class="line">所以，我们的“目标模式”或是“依赖模式”中都应该有 % 这个字符，如果你的文件名中有 % 那么你可以使用反斜杠 \ 进行转义，来标明真实的 % 字符。</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，指明了我们的目标从$object中获取， %.o 表明要所有以 .o 结尾的目标，也就是 foo.o bar.o ，也就是变量 $object 集合的模式，而依赖模式 %.c 则取模式 %.o 的 % ，<br>也就是 foo bar ，并为其加下 .c 的后缀，于是，我们的依赖目标就是 foo.c bar.c 。而命令中的 $&lt; 和 $@ 则是自动化变量， $&lt; 表示第一个依赖文件， $@ 表示目标集（也就是“foo.o bar.o”）。<br>于是，上面的规则展开后等价于下面的规则：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">foo<span class="selector-class">.o</span> : foo<span class="selector-class">.c</span></span><br><span class="line">    $(CC) -c $(CFLAGS) foo<span class="selector-class">.c</span> -o foo<span class="selector-class">.o</span></span><br><span class="line">bar<span class="selector-class">.o</span> : bar<span class="selector-class">.c</span></span><br><span class="line">    $(CC) -c $(CFLAGS) bar<span class="selector-class">.c</span> -o bar.o</span><br></pre></td></tr></table></figure>
<p>所以对于很多需要这样生成的，可以省去很多，提高效率<br>另一个例子：eg:</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line">$(<span class="keyword">filter</span> %.o,$(files)): %.o: %.c</span><br><span class="line">    $(CC) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line">$(<span class="keyword">filter</span> %.elc,$(files)): %.elc: %.el</span><br><span class="line">    emacs -f batch-byte-compile $&lt;</span><br></pre></td></tr></table></figure>
<p>$(filter %.o,$(files))表示调用Makefile的filter函数，过滤“$files”集，只要其中模式为“%.o”的内容。</p>
<h4 id="自动化生成先决条件：How-to-automatically-generate-rules-giving-prerequisites-from-source-files-themselves"><a href="#自动化生成先决条件：How-to-automatically-generate-rules-giving-prerequisites-from-source-files-themselves" class="headerlink" title="自动化生成先决条件：How to automatically generate rules giving prerequisites from source files themselves."></a>自动化生成先决条件：How to automatically generate rules giving prerequisites from source files themselves.</h4><p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句 #include “defs.h” ，那么我们的依赖关系应该是：<br>main.o : main.c defs.h<br>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。<br>为了避免这种繁重而又容易出错的事情，我们可以使用C&#x2F;C++编译的一个功能。大多数的C&#x2F;C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。<br>例如，如果我们执行下面的命令:<br>cc -M main.c<br>输出：<br>main.o : main.c defs.h<br>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C&#x2F;C++编译器，你得用 -MM 参数，不然，<br> -M 参数会把一些标准库的头文件也包含进来。<br>gcc -M main.c的输出是:  </p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">main.o: main.c defs.h <span class="regexp">/usr/i</span>nclude<span class="regexp">/stdio.h /u</span>sr<span class="regexp">/include/</span>features.h \</span><br><span class="line">    <span class="regexp">/usr/i</span>nclude<span class="regexp">/sys/</span>cdefs.h <span class="regexp">/usr/i</span>nclude<span class="regexp">/gnu/</span>stubs.h \</span><br><span class="line">    <span class="regexp">/usr/</span>lib<span class="regexp">/gcc-lib/i</span>486-suse-linux<span class="regexp">/2.95.3/i</span>nclude/stddef.h \</span><br><span class="line">    <span class="regexp">/usr/i</span>nclude<span class="regexp">/bits/</span>types.h <span class="regexp">/usr/i</span>nclude<span class="regexp">/bits/</span>pthreadtypes.h \</span><br><span class="line">    <span class="regexp">/usr/i</span>nclude<span class="regexp">/bits/</span>sched.h <span class="regexp">/usr/i</span>nclude/libio.h \</span><br><span class="line">    <span class="regexp">/usr/i</span>nclude<span class="regexp">/_G_config.h /u</span>sr<span class="regexp">/include/</span>wchar.h \</span><br><span class="line">    <span class="regexp">/usr/i</span>nclude<span class="regexp">/bits/</span>wchar.h <span class="regexp">/usr/i</span>nclude/gconv.h \</span><br><span class="line">    <span class="regexp">/usr/</span>lib<span class="regexp">/gcc-lib/i</span>486-suse-linux<span class="regexp">/2.95.3/i</span>nclude/stdarg.h \</span><br><span class="line">    <span class="regexp">/usr/i</span>nclude<span class="regexp">/bits/</span>stdio_lim.h</span><br></pre></td></tr></table></figure>
<p>gcc -MM main.c的输出则是:main.o: main.c defs.h<br>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让 Makefile自已依赖于源文件？这个功能并不现实，<br>不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 name.c 的文件都生成一个 name.d 的Makefile文件，<br>.d 文件中就存放对应 .c 文件的依赖关系。</p>
<p>于是，我们可以写出 .c 文件和 .d 文件的依赖关系，并让make自动更新或生成 .d 文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。<br>这里，我们给出了一个模式规则来产生 .d 文件：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">%.d: %.c</span><br><span class="line">    @<span class="built_in">set</span> <span class="literal">-e</span>; <span class="built_in">rm</span> <span class="operator">-f</span> <span class="variable">$</span><span class="selector-tag">@</span>; \</span><br><span class="line">    <span class="variable">$</span>(CC) <span class="literal">-M</span> <span class="variable">$</span>(CPPFLAGS) <span class="variable">$</span>&lt; &gt; <span class="variable">$</span><span class="selector-tag">@</span>.<span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span>; \</span><br><span class="line">    sed <span class="string">&#x27;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#x27;</span> &lt; <span class="variable">$</span><span class="selector-tag">@</span>.<span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span> &gt; <span class="variable">$</span><span class="selector-tag">@</span>; \</span><br><span class="line">    <span class="built_in">rm</span> <span class="operator">-f</span> <span class="variable">$</span><span class="selector-tag">@</span>.<span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span></span><br></pre></td></tr></table></figure>
<p>这个规则的意思是，所有的 .d 文件依赖于 .c 文件， rm -f $@ 的意思是删除所有的目标，也就是 .d 文件，第二行的意思是，为每个依赖文件 $&lt; ，也就是 .c 文件生成依赖文件，<br>$@ 表示模式 %.d 文件，如果有一个C文件是name.c，那么 % 就是 name ， $$$$ 意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，<br>关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。<br>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入 .d 文件的依赖，即把依赖关系：<br>main.o : main.c defs.h<br>转成<br>main.o main.d : main.c defs.h<br>于是，我们的 .d 文件也会自动更新了，并会自动生成了，当然，你还可以在这个 .d 文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 .d 文件都包含一个完赖的规则。<br>一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="constructor">$(<span class="params">sources</span>:.<span class="params">c</span>=.<span class="params">d</span>)</span></span><br></pre></td></tr></table></figure>
<p>上述语句中的 $(sources:.c&#x3D;.d) 中的 .c&#x3D;.d 的意思是做一个替换，把变量 $(sources) 所有 .c 的字串都替换成 .d ，关于这个“替换”的内容，在后面我会有更为详细的讲述。<br>当然，你得注意次序，因为include是按次序来载入文件，最先载入的 .d 文件中的目标会成为默认目标。</p>
<p>一个综合的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#VPATH =</span></span><br><span class="line"><span class="keyword">vpath</span> %.h .:../commonlib/huyacommon:../commonlib/log4cplus/<span class="keyword">include</span>:srt/<span class="keyword">include</span>/srt/</span><br><span class="line"><span class="keyword">vpath</span> %.cpp .:../commonlib/huyacommon</span><br><span class="line"><span class="keyword">vpath</span> %.c .:../commonlib/huyacommon</span><br><span class="line"></span><br><span class="line">INCLUDE_DIR	+= -I . -I ../commonlib/huyacommon/ -I ../commonlib/log4cplus/<span class="keyword">include</span>/ -I srt/<span class="keyword">include</span>/srt/</span><br><span class="line">LIB_DIR += ../commonlib/json/libjson.a ../commonlib/huyacommon/common.a</span><br><span class="line"></span><br><span class="line">CC	= gcc</span><br><span class="line">CPP = g++</span><br><span class="line">CFLAGS = -g -Wall -fPIC -c</span><br><span class="line">CPPFLAGS = -g -Wall -fPIC  -c -std=c++0x -Wno-invalid-offsetof -Wextra -Wno-reorder -Wno-strict-aliasing -std=c++0x -Wno-sign-compare </span><br><span class="line"></span><br><span class="line">SOURCES += <span class="variable">$(<span class="built_in">wildcard</span> ./*.cpp)</span></span><br><span class="line"><span class="comment">#SOURCES += $(wildcard ../commonlib/*.cpp)</span></span><br><span class="line"><span class="comment">#SOURCES += $(wildcard ../netlayer/*.cpp)</span></span><br><span class="line"><span class="comment">#SOURCES += $(wildcard yyprotocol/*.cpp)</span></span><br><span class="line"></span><br><span class="line">objects = <span class="variable">$(<span class="built_in">patsubst</span> ./%.cpp,%.o,<span class="variable">$(SOURCES)</span>)</span></span><br><span class="line">objectsd = <span class="variable">$(<span class="built_in">patsubst</span> ./%.cpp,%.d,<span class="variable">$(SOURCES)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:dfiles afiles</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="comment">#先更新d文件，即可能依赖改变了</span></span><br><span class="line">dfiles : <span class="variable">$(objectsd)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成.d文件,到.d的目录下</span></span><br><span class="line"><span class="variable">$(objectsd)</span>:%.d:%.cpp</span><br><span class="line">	<span class="variable">$(CPP)</span> -MM -w --std=c++0x  -fpermissive  <span class="variable">$&lt;</span> <span class="variable">$(INCLUDE_DIR)</span>  &gt; dfile/<span class="variable">$@</span></span><br><span class="line">	@echo <span class="variable">$(objectsd)</span></span><br><span class="line">	@echo <span class="string">&quot;	<span class="variable">$(CPP)</span> -c <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(INCLUDE_DIR)</span> <span class="variable">$&lt;</span>&quot;</span> &gt;&gt; dfile/<span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行依赖文件指令，这样保证依赖的头文件和实现文件只要改变，就能重新生成</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(<span class="built_in">patsubst</span> %.d,dfile/%.d,<span class="variable">$(objectsd)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后在生成o最新文件的基础上封装为a库</span></span><br><span class="line">afiles : netlayer.a</span><br><span class="line"></span><br><span class="line"><span class="section">netlayer.a:<span class="variable">$(objects)</span></span></span><br><span class="line">	ar rvs netlayer.a <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf netlayer.a *.o</span><br></pre></td></tr></table></figure>


<h3 id="规则中指令如何写？"><a href="#规则中指令如何写？" class="headerlink" title="规则中指令如何写？"></a>规则中指令如何写？</h3><p>指令是一个或多个可以执行的shell命令行组成，按顺序执行。而执行的结果，一般就是更新目标文件；<br>使用者使用很多不同的shell指令，但在makefile中总是被&#x2F;bin&#x2F;sh解释，除非被配置其他；</p>
<h4 id="指令语法–指令语法特性和陷阱"><a href="#指令语法–指令语法特性和陷阱" class="headerlink" title="指令语法–指令语法特性和陷阱"></a>指令语法–指令语法特性和陷阱</h4><p>tab开头(或者由.RECIPEPREFIX 定义的字符，#开头为注释<br>makefiles中其实有两个不同的语法，一个是make自己的，一个是shell,其实只会在解释指令时，make做很小的解释后，交给shell</p>
<ul>
<li>有几个个共同的特性：<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 空格开头的空白行，不是一个空行，是一个空指令</span><br><span class="line"><span class="number">2</span>) 一个注释不是<span class="built_in">make</span>的注释，是<span class="built_in">make</span>传递给<span class="built_in">shell</span>，<span class="built_in">shell</span>会根据自己的语法，来判断它是不是注释</span><br><span class="line"><span class="number">3</span>) 在指令中(rule context)中定义的变量，不是<span class="built_in">make</span>的变量，是被当做rule的一部分，被传递到<span class="built_in">shell</span>中；</span><br><span class="line"><span class="number">4</span>) 条件表达式表现也和<span class="number">3</span>)一样</span><br></pre></td></tr></table></figure></li>
<li>如何换行(同个逻辑行物理行换行)<br>在makefile中，反斜杠也可以在指令中使用，但是是传递给shell去判断的，所以支持与否取决于你的shell工具<br>一个例子：<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">ksance0<span class="variable">@ubuntu</span><span class="symbol">:~/makefiletest</span><span class="variable">$ </span>make </span><br><span class="line">no hspace</span><br><span class="line">notother</span><br><span class="line">ksance0<span class="variable">@ubuntu</span><span class="symbol">:~/makefiletest</span><span class="variable">$ </span>cat makefile </span><br><span class="line"><span class="symbol">all:</span></span><br><span class="line">	<span class="variable">@echo</span> no h\</span><br><span class="line">space</span><br><span class="line">	<span class="variable">@echo</span> <span class="keyword">not</span>\</span><br><span class="line">other</span><br><span class="line">ksance0<span class="variable">@ubuntu</span><span class="symbol">:~/makefiletest</span><span class="variable">$ </span></span><br></pre></td></tr></table></figure>
注意如果反斜杠在字符串中，则可能会被忽略；</li>
<li>如何在指令中使用变量：<br>指令中的变量和函数引用与makefile中其他地方的引用具有相同的语法和语义。他们也有相同的引用规则，如果你想在指令中使用$符号，你需要使用双$如下，<br>因为在make中引用要用$,在传递给shell前剥离$，但在shell中引用也需要$,所以这里要用双$<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">LIST = <span class="literal">one</span> <span class="literal">two</span> <span class="literal">three</span></span><br><span class="line">all:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> $(LIST); <span class="built_in">do</span> \</span><br><span class="line">            echo $$i; \</span><br><span class="line">        done</span><br><span class="line">解释后；</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="literal">one</span> <span class="literal">two</span> <span class="literal">three</span>; <span class="built_in">do</span> \</span><br><span class="line">    echo $i; \</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"><span class="literal">one</span></span><br><span class="line"><span class="literal">two</span></span><br><span class="line"><span class="literal">three</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="如何控制什么时候指令回显"><a href="#如何控制什么时候指令回显" class="headerlink" title="如何控制什么时候指令回显"></a>如何控制什么时候指令回显</h4><ul>
<li>make中可以使用echo指令，默认情况下，make会把要执行的指令打印到屏幕上，但当使用@echo时，只会显示echo后面的字符如：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@echo</span> xxxx</span><br><span class="line">make执行时： 输出：xxxx</span><br><span class="line">而当去掉<span class="variable">@echo</span>时，则输出：</span><br><span class="line">echo xxxx</span><br><span class="line">xxxx</span><br></pre></td></tr></table></figure></li>
<li>-n和–just-print参数：使用时不会执行命令而是只显示命令</li>
<li>-s或–silent或–quiet，则是全面禁止指令的显示；</li>
</ul>
<h4 id="指令是如何执行的"><a href="#指令是如何执行的" class="headerlink" title="指令是如何执行的"></a>指令是如何执行的</h4><p>当更新目标时，会执行指令，指令是由shell指令构成的，会执行指令中的每个子shell;.ONESHELL会影响具体的目标;<br>而一个注意的是： cd ,会影响指令的运行环境，比如cd到别的目录执行；不过若想要cd影响到下个指令，需要将下个指令和cd放在同一行;</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">foo: bar/lose</span><br><span class="line">        <span class="built_in">cd</span>  <span class="variable">$</span>(&lt;D) &amp;&amp; gobble <span class="variable">$</span>(&lt;F) &gt; ../<span class="variable">$</span><span class="selector-tag">@</span></span><br></pre></td></tr></table></figure>

<p>这里使用的&amp;&amp; ，所以当cd失败时，整个指令会失败；注意不会执行&amp;&amp;后面的指令；<br>关于.ONESHELL：<br>声明这个后，指令中的多行指令会按单行指令执行，会有以上cd的影响；同时 特殊字符只会在第一行被去掉；比如 @,这可能造成影响，详细见文档；<br>eg:</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">.ONESHELL:</span><br><span class="line">SHELL = <span class="regexp">/usr/</span>bin/perl</span><br><span class="line">.SHELLFLAGS = -e</span><br><span class="line">show :</span><br><span class="line">        <span class="keyword">my</span> @f = <span class="string">qw(a b c)</span>;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;@f\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>关于Choosing the Shell选择shell:<br>默认使用&#x2F;bin&#x2F;sh ，如果.SHELL没被设置的话；<br>而.SHELLFLAGS默认是-c或-ec<br>这个在DOS和win下比较常见；  </p>
<h4 id="指令如何同时执行"><a href="#指令如何同时执行" class="headerlink" title="指令如何同时执行"></a>指令如何同时执行</h4><p>通常make是顺序执行一条一条指令的，当make -j时，会同时并行执行多个指令；所以为了make更快，可以采用这种形式；若-j后是一个整数，则按整数个同时执行的job来运行，<br>否是是1，串行执行；  </p>
<p>如果一个指令失败(被一个信号杀死或以非零状态退出)，并且不会忽略该指令的错误(请参阅配方中的错误)，那么重新构建同一目标的剩余配方行将不会运行。<br>如果指令失败，并且没有给出’ -k ‘或’——keep-going ‘选项(参见选项摘要)，则make aborts执行。如果make由于任何原因(包括信号)终止了子进程，它会在实际退出之前等待子进程结束。  </p>
<p>当系统负载较重时，您可能希望比负载较轻时运行更少的作业。您可以使用’ -l ‘选项告诉make根据平均负载限制一次运行的作业数量。选项’ -l ‘或’——max-load ‘后面跟着一个浮点数。例如, -l 2.5  </p>
<p>如果平均负载超过2.5，将不会让make启动一个以上的作业。-l后面无数字指定则无效<br>更准确地说，当make启动一个作业时，并且它已经有至少一个作业在运行时，它会检查当前的平均负载;如果它不低于’ -l ‘所给出的极限，则make等待，直到平均负载低于该极限，或直到所有其他作业完成。</p>
<p>默认的，是没有负载限制的；</p>
<ul>
<li>关于并行执行的输出<br>当并行执行的时候，输出信息很难读；为了避免这个，可以用–output-sync选项；该选项指示make保存它调用的命令的输出，并在命令完成后全部打印输出。<br>此外，如果有多个递归make调用并行运行，它们将进行通信，以便每次只生成其中一个输出。</li>
</ul>
<p>如果启用了工作目录打印(参见’——print-directory ‘选项)，enter&#x2F;leave消息将围绕每个输出分组打印。如果不希望看到这些消息，可以在MAKEFLAGS中添加’——no-print-directory ‘选项。  </p>
<p>在同步输出时，有四种级别的粒度，通过给选项一个参数来指定(例如，’ -Oline ‘或’——output-sync&#x3D;recurse ‘)。  </p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">none:</span>默认的，不同步直接输出  </span><br><span class="line"><span class="symbol">line:</span>每行指令单独分组和打印，当这行指令完成；若一个指令包含多行，可能混合；</span><br><span class="line"><span class="symbol">target:</span>按照每个目标分组打印，和--output-sync/-O效果相同</span><br><span class="line"><span class="symbol">recurse:</span>每次递归调用make的输出都会分组并在递归调用完成后打印</span><br></pre></td></tr></table></figure>

<ul>
<li>关于并行执行的输入<br>两个进程不能同时从同一设备获取输入。为了确保一次只有一个配方尝试从终端获取输入，make将使所有正在运行的配方的标准输入流失效。如果另一个配方试图从标准输入读取，它通常会导致一个致命的错误(“断管道”信号)。</li>
</ul>
<h4 id="指令执行失败后会怎么样；"><a href="#指令执行失败后会怎么样；" class="headerlink" title="指令执行失败后会怎么样；"></a>指令执行失败后会怎么样；</h4><p>每行指令会返回成功与否的状态值，成功为0 ，成功时会自动执行下一行，直到规则结束；，若碰到异常，非0值，则make会放弃当前的规则，或者可能所有的规则；<br>有时候指令的失败不代表是一个问题，例如mkdir;目录已存在；为了忽略这行指令的错误，则使用-，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clean： </span><br><span class="line">        -<span class="built_in">rm</span> -f *.o</span><br></pre></td></tr></table></figure>
<p>这样即使这行rm失败也能继续执行；<br>如果执行make的时候指定-i,或者–ignore-errors,则会忽略全部的异常，和在makefile中声明.IGNORE效果类似；当用在无依赖的规则下比较有用；<br>上述情况下，虽然返回成功，但它会打印出一条消息，告诉您shell退出时使用的状态代码，并告诉您该错误已被忽略。<br>当错误发生时，make没有被告知要忽略它，这意味着当前目标不能被正确地重新创建，任何直接或间接依赖于它的其他目标也不能正确地重新创建。不会对这些目标执行进一步的配方，因为它们的先决条件还没有实现。<br>通常make在这种情况下立即放弃，返回一个非零状态。但是，如果指定了’ -k ‘或’——keep-going ‘标志，make将继续考虑挂起目标的其他先决条件，并在必要时重新生成它们，然后放弃并返回非零状态。<br>例如，在编译一个目标文件时出现错误后，’ make -k ‘将继续编译其他目标文件，即使它已经知道不可能链接它们。  </p>
<h4 id="指令被中断会怎么样"><a href="#指令被中断会怎么样" class="headerlink" title="指令被中断会怎么样"></a>指令被中断会怎么样</h4><p>如果make在shell执行时获得一个致命信号，它可能会删除配方要更新的目标文件。如果目标文件的最后一次修改时间在第一次检查之后发生了改变，就会这样做。</p>
<ul>
<li><p>为什么呢：<br>删除目标的目的是确保在下一次运行make时从头重新创建目标。这是为什么呢?假设您在编译器运行时输入Ctrl-c，并且编译器已经开始编写一个对象文件foo.o。Ctrl-c杀死编译器，导致一个不完整的文件，<br>它的最后修改时间比源文件foo.c更新。但是make也会接收Ctrl-c信号并删除这个不完整的文件。如果make没有这样做，下一次调用make时会认为foo.o不需要更新—当链接器试图链接一个文件时，会产生一个奇怪的错误消息  </p>
</li>
<li><p>如何设置例外？<br>您可以通过使特殊的目标.PRECIOUS 依赖于它来防止以这种方式删除目标文件。在重新创建目标之前，检查它是否在. precious的先决条件下出现，从而决定在信号发生时是否应该删除目标。<br>这样做的一些原因是，目标是以某种原子方式更新的，或者目标的存在只是为了记录修改时间(其内容并不重要)，或者目标必须一直存在以防止其他类型的麻烦</p>
</li>
<li><p>无法覆盖全部：<br>尽管make尽力清理，但在某些情况下，清理是不可能的。例如，make可能会被一个无法捕获的信号杀死。或者，某个程序make调用可能被杀死或崩溃，留下一个最新的但已损坏的目标文件:make不会意识到这个故障需要清除目标文件。或者使自己可能遇到bug而崩溃。</p>
</li>
<li><p>防御：<br>由于这些原因，最好编写防御性指令，这样即使失败了，也不会留下损坏的目标。通常，这些指令会创建临时文件，而不是直接更新目标，然后将临时文件重命名为最终的目标名称。有些编译器已经采用了这种方式，因此您不需要编写防御性指令。</p>
</li>
</ul>
<h4 id="递归；指令中调用makefiles-通过make"><a href="#递归；指令中调用makefiles-通过make" class="headerlink" title="递归；指令中调用makefiles 通过make"></a>递归；指令中调用makefiles 通过make</h4><p>有时候，我们在一个makefile中，编译后，想接着编译其他目录的内容，但是又不想退出重新make，这个时候可以利用makefile中调用make的功能；也叫递归<br>make的递归使用意味着将make作为makefile中的命令使用。当您需要为组成较大系统的各种子系统单独生成文件时，这种技术非常有用。<br>例如，假设您有一个子目录subdir，它有自己的makefile，并且您希望包含目录的makefile在子目录上运行make。你可以这样写</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">        cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br><span class="line">等同于：</span><br><span class="line"><span class="section">subsystem:</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>
<p>结合将目标声明为.PHONY会更有效；<br>为方便起见，当GNU make启动时(在它处理了任何-C选项之后)，它将变量CURDIR设置为当前工作目录的路径名。make不会再碰这个值:<br>特别要注意，如果包含其他目录的文件，CURDIR的值不会改变。<br>这个值与在makefile中设置的值具有相同的优先级(默认情况下，环境变量CURDIR不会覆盖这个值)。注意，设置这个变量对make的操作没有影响(例如，它不会导致make更改其工作目录)。</p>
<ul>
<li>make指令变量如何工作<br>递归的make命令应该总是使用变量make，而不是显式的命令名’ make ‘，如下所示<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">        cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br></pre></td></tr></table></figure>
该变量的值是调用make时使用的文件名，如果这个文件名是&#x2F;bin&#x2F;make，那么执行的配方是’ cd subdir &amp;&amp; &#x2F;bin&#x2F;make ‘。如果使用make的特殊版本来运行顶级makefile，则对于递归调用将执行相同的特殊版本。<br>作为一个特殊特性，在规则的指令中使用变量MAKE会改变’ -t ‘(‘——touch ‘)、’ -n ‘(‘——just-print ‘)或’ -q ‘(‘——question ‘)选项的效果。<br>使用MAKE变量的效果与在recipe行开头使用“+”字符的效果相同<br>只有当MAKE变量直接出现在指令中时才启用此特殊特性:如果通过展开另一个变量引用MAKE变量，则不适用此特性。在后一种情况下，您必须使用“+”标记来获得这些特殊效果。</li>
</ul>
<p>考虑上面示例中的命令’ make -t ‘。(“-t”选项将目标标记为最新，无需实际运行任何指令;看，而不是执行。)遵循’ -t ‘的通常定义，<br>示例中的’ make -t ‘命令将创建一个名为subsystem的文件，不做其他事情。你真正想要做的是运行’ cd subdir &amp;&amp; make -t ‘;但这需要执行指令，而“-t”表示不执行指令。</p>
<p>所以在这种情况下，make做了特殊处理，即在指令中若存在MAKE变量，则，当外部make时传入 -t&#x2F; -n&#x2F;-q时，不传到这里的make ,这样对指令中的make可以正常运行；<br>而其实通常情况下，外部的make带的参数是会传递到这里的；</p>
<ul>
<li>子make之间如何交互 export unexport<br>顶级make的变量值可以通过显式请求通过环境传递给子make，这些变量在子make中定义为默认值，但它们不会覆盖子make使用的makefile中定义的变量，除非你使用’ -e ‘开关。<br>为了传递或导出变量，make将变量及其值添加到环境中，以便运行指令的每一行。子make依次使用环境来初始化其变量值表。<br>除非是通过显式请求，否则只有在环境中初始定义或在命令行中设置了导出变量，并且它的名称仅由字母、数字和下划线组成时，才可以将导出设置为变量。有些shell不能处理由字母、数字和下划线以外的字符组成的环境变量名。</li>
</ul>
<p>不导出make变量SHELL的值。相反，调用环境中的SHELL变量的值被传递给子make。您可以使用下面描述的export指令强制make为SHELL导出它的值。<br>特殊变量MAKEFLAGS总是被导出(除非您反导出它)。如果您将其设置为任何内容，则会导出MAKEFILES。<br>make通过将在命令行中定义的变量值放入MAKEFLAGS变量中，自动传递这些值。</p>
<p>如果变量是由make默认创建的，那么它们通常不会被传递(参见隐式规则使用的变量)。子make将为自己定义这些。<br>如果你想导出特定的变量到子make中，使用export指令，像这样:<br>export variable …<br>如果你想阻止一个变量被导出，使用unexport指令，像这样<br>unexport variable …<br>在这两种形式中，export和unexport的参数都是展开的，因此可以是展开为要(un)导出的变量名(列表)的变量或函数。<br>为了方便，你可以定义一个变量并同时导出它，方法如下:</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">export <span class="keyword">variable</span> = value</span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">variable</span> <span class="comment">= value</span></span><br><span class="line">export <span class="comment">variable</span></span><br><span class="line">相当于</span><br><span class="line">export <span class="comment">variable := value</span></span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">variable</span> <span class="comment">:= value</span></span><br><span class="line">export <span class="comment">variable</span></span><br><span class="line">相当于</span><br><span class="line">export <span class="comment">variable += value</span></span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">variable</span> <span class="comment">+= value</span></span><br><span class="line">export <span class="comment">variable</span></span><br></pre></td></tr></table></figure>
<p>您可能会注意到，export和unexport指令在make中的工作方式与它们在shell sh中的工作方式相同。<br>如果你想在默认情况下导出所有变量，你可以单独使用export:<br>export<br>unexport也是类似的效果</p>
<p>关于MAKELEVEL变量:<br>作为一个特殊的特性，变量MAKELEVEL在从一个级别传递到另一个级别时发生了变化。这个变量的值是一个字符串，它以十进制数字表示级别的深度。<br>顶级make的值是’ 0 ‘;sub-make是’ 1 ‘，sub-sub-make是’ 2 ‘，以此类推。当make为配方设置环境时发生增量<br>MAKELEVEL的主要用途是在一个条件指令中测试它(参见Makefiles的条件部分);通过这种方式，您可以编写一个makefile，递归运行时采用一种方式，直接运行时采用另一种方式。</p>
<p>关于MAKEFILES变量<br>您可以使用变量MAKEFILES使所有子make命令使用额外的makefile。MAKEFILES的值是一个以空格分隔的文件名列表。这个变量，如果定义在外部的makefile中，将通过环境传递;然后，它作为额外makefile的列表，供子make在通常的或指定的makefile之前读取。</p>
<ul>
<li>将选项传递给子make<br>像-s,-k这种会直接通过变量MAKEFLAGS传递给子make. 这个变量由make自动设置，以包含make received的标志字母。因此，如果您使用’ make -ks ‘，那么MAKEFLAGS将获得值’ ks ‘。<br>因此，每个子make在它的环境中都会得到MAKEFLAGS的值。作为响应，它从该值中获取标记并处理它们，就像它们被作为参数给出一样。</li>
</ul>
<p>同样，在命令行中定义的变量也通过MAKEFLAGS传递给子make。包含’ &#x3D; ‘的MAKEFLAGS值中的单词，将处理作为变量定义，就像它们出现在命令行中一样。<br>选项’ -C ‘， ‘ -f ‘， ‘ -o ‘和’ -W ‘不会被放入MAKEFLAGS中;这些选项没有传递下去。<br>‘ -j ‘选项是一种特殊情况(参见并行执行)。如果你将它设置为一些数值’ N ‘并且你的操作系统支持它(大多数UNIX系统都会支持;其他的通常不会)，父make和所有子make将进行通信，以确保它们之间只有“N”个作业同时运行。</p>
<p>如果您的操作系统不支持上述通信，那么没有’ -j ‘添加到MAKEFLAGS，以便子make运行在非并行模式<br>如果你不想传递其他标志，你必须改变MAKEFLAGS的值，像这样:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">        cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> MAKEFLAGS=</span><br></pre></td></tr></table></figure>
<p>命令行变量定义实际出现在变量MAKEOVERRIDES中，并且MAKEFLAGS包含对该变量的引用。如果你想正常传递标志，但不想传递命令行变量定义，你可以重置MAKEOVERRIDES为空，像这样:<br>MAKEOVERRIDES &#x3D;<br>这样做通常是没有用的。然而，一些系统对环境的大小有一个很小的固定限制，将如此多的信息放入MAKEFLAGS的值中可能会超过这个限制。</p>
<p>为了历史兼容性，也存在一个类似的变量MFLAGS。它有相同的值作为MAKEFLAGS除了它不包含命令行变量定义,它总是开始于一个连字符,除非它是空的(MAKEFLAGS以连字符开始只有当它开始于一个选项,<br>没有单字符版本,如“——warn-undefined-variables”)。MFLAGS传统上是在递归的make命令中显式使用的，像这样:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">        cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> <span class="variable">$(MFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>如果您希望拥有某些选项，比如在每次运行make时设置’ -k ‘(请参阅选项摘要)，那么MAKEFLAGS变量也很有用。您只需将MAKEFLAGS的值放入您的环境中。您还可以在makefile中设置MAKEFLAGS，<br>以指定对该makefile也有效的附加标志。(注意你不能这样使用MFLAGS。设置该变量只是为了兼容;make不会以任何方式解释你为它设置的值。)<br>…</p>
<ul>
<li>打印目录的指令<br>如果您使用多个层次的递归make调用，则’ -w ‘或’——print-directory ‘选项可以使输出更容易理解，<br>因为它将每个目录显示为make开始处理它和make完成处理它。例如，如果’ make -w ‘在目录&#x2F;u&#x2F;gnu&#x2F;make中运行，make将打印下面的一行:<br>make: Entering directory &#96;&#x2F;u&#x2F;gnu&#x2F;make’.<br>before doing anything else, and a line of the form:</li>
</ul>
<p>make: Leaving directory &#96;&#x2F;u&#x2F;gnu&#x2F;make’.<br>when processing is completed.<br>通常，你不需要指定这个选项，因为’ make ‘会替你指定:当你使用’ -C ‘选项时，’ -w ‘会自动打开，在子make中也是如此。make不会自动打开’ -w ‘，如果你也使用’ -s ‘，它表示静默，或者如果你使用’——no-print-directory ‘来显式禁用它。</p>
<h4 id="定义指令集"><a href="#定义指令集" class="headerlink" title="定义指令集"></a>定义指令集</h4><p>当相同的命令序列在创建各种目标时有用时，可以使用define指令将其定义为固定序列，并从这些目标的配方中引用固定序列。这个固定序列实际上是一个变量，所以这个名称不能与其他变量名称冲突。<br>例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc =</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>

<p>这里，run-yacc是被定义的变量的名称;endef表示定义的结束;中间的行是命令。define指令不会以固定的顺序展开变量引用和函数调用;’ $ ‘字符、圆括号、变量名等等都成为要定义的变量值的一部分。<br>要使用固定序列，请将变量替换到规则的指令中。您可以像替换其他变量一样替换它(。因为define定义的变量是递归展开的变量，所以在define中编写的所有变量引用现在都展开了。例如:<br>foo.c : foo.y<br>        $(run-yacc)<br>当变量“ $ ^”以run-yacc的值出现时，“ foo.y”将被替换，变量“ $ @”将被“ foo.c”替换。</p>
<h4 id="定义有用的没，没做任何事的指令；"><a href="#定义有用的没，没做任何事的指令；" class="headerlink" title="定义有用的没，没做任何事的指令；"></a>定义有用的没，没做任何事的指令；</h4><p>有时定义不做任何事情的指令是很有用的。这可以通过提供一个只包含空格的指令来实现。例如:<br>target: ;<br>这样做的一个原因是防止目标获取隐式指令规则<br>空的指令也可以用来避免错误为目标创建另一个指令的副作用:如果目标不存在空配方确保让不会抱怨不知道如何建立目标,并使假设目标是过时了。</p>
<h3 id="如何使用变量"><a href="#如何使用变量" class="headerlink" title="如何使用变量"></a>如何使用变量</h3><p>一个变量是一个定义在makefile中用来表示一个文本中的字符串的名字，这个字符串是变量的值；<br>这些变量是可以被显示替换目标，依赖和指令，以及makefile中的其他部分；在其他版本的makefile中也叫宏；<br>makefile中所有部分的变量和函数在读取时都是展开的，除了在recipes中，变量定义的右边使用’ &#x3D; ‘，变量定义的主体使用define指令。<br>变量可以表示文件名列表、传递给编译器的选项、要运行的程序、要查找源文件的目录、要写入输出的目录，或者您可以想象的任何其他内容。</p>
<p>变量名可以是不包含’:’、’ # ‘、’ &#x3D; ‘或空格的任意字符序列。然而，包含字母、数字和下划线以外的字符的变量名应该仔细考虑，因为在某些shell中，它们不能通过环境传递给子make(请参阅通信变量到子make)。<br>变量名以&#96;开头。在未来的make版本中，大写字母可能会被赋予特殊的含义。<br>变量名区分大小写。名字’ foo ‘， ‘ foo ‘和’ foo ‘都指不同的变量。<br>传统使用大写字母的变量名,但我们建议使用小写字母的变量名内部用途的makefile,并保留大写参数控制隐性规则或命令选项的参数,用户应该覆盖(见最重要的变量)。<br>一些变量的名称可以是单个标点字符，也可以是几个字符。这些是自动变量，它们有特殊的用途。看到自动变量。</p>
<h4 id="如何使用变量的值"><a href="#如何使用变量的值" class="headerlink" title="如何使用变量的值"></a>如何使用变量的值</h4><p>通过$符号可以引用变量的值，用两种方式： $(foo)或${foo},如果要用包含$字符，需要用两个$;</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">objects = program.o foo.o utils.o</span><br><span class="line">program : <span class="constructor">$(<span class="params">objects</span>)</span></span><br><span class="line">        cc -o program <span class="constructor">$(<span class="params">objects</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="constructor">$(<span class="params">objects</span>)</span> : defs.h</span><br></pre></td></tr></table></figure>
<p>变量按严格的文本替换：  </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">foo = c</span><br><span class="line">prog.o : prog.<span class="constructor">$(<span class="params">foo</span>)</span></span><br><span class="line">        <span class="constructor">$(<span class="params">foo</span>)</span><span class="constructor">$(<span class="params">foo</span>)</span> -<span class="constructor">$(<span class="params">foo</span>)</span> prog.<span class="constructor">$(<span class="params">foo</span>)</span></span><br><span class="line">可以用来编译一个C程序。因为在变量赋值时变量值前面的空格会被忽略，所以foo的值就是&#x27; c &#x27;。(不要这样写你的makefile !)</span><br></pre></td></tr></table></figure>
<p>一个美元符号后面跟着一个不是美元符号、开括号或开括号的字符作为变量名。因此，你可以用’ $x ‘引用变量x。然而，这种做法可能会导致混淆(例如，’ $foo ‘指的是变量f后面跟着字符串oo)，所以我们建议在所有变量周围使用圆括号或大括号，<br>即使是单字母的变量，除非省略它们可以显著提高可读性。可读性经常得到提高的一个地方是自动变量(参见自动变量)。</p>
<h4 id="两种赋值变量的方式：-x3D-x2F-x3D"><a href="#两种赋值变量的方式：-x3D-x2F-x3D" class="headerlink" title="两种赋值变量的方式： &#x3D; &#x2F;:&#x3D;"></a>两种赋值变量的方式： &#x3D; &#x2F;:&#x3D;</h4><p>&#x3D; 原封不动的拷贝，可以进行递归赋值，如：  </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:;echo <span class="variable">$(foo)</span></span></span><br></pre></td></tr></table></figure>
<p>所以可以这样使用：这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = <span class="variable">$(include_dirs)</span> -O</span><br><span class="line">include_dirs = -Ifoo -Ibar</span><br><span class="line">但是一下这种方式会导致无穷递归：</span><br><span class="line">CFLAGS = <span class="variable">$(CFLAGS)</span> -O </span><br><span class="line">make会上报错误</span><br><span class="line">另一个缺点是，另一个缺点是，定义中引用的任何函数都将在每次扩展变量时执行。</span><br><span class="line">这使得make跑得更慢;更糟糕的是，它会导致通配符和shell函数给出不可预知的结果，因为您无法轻松控制何时调用它们，甚至调用多少次。所以不要这么做；</span><br></pre></td></tr></table></figure>
<ul>
<li>另一种：”:&#x3D;”<br>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是 :&#x3D; 操作符，如：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br><span class="line">其等价于：</span><br><span class="line"></span><br><span class="line">y := foo bar</span><br><span class="line">x := later</span><br><span class="line">值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：</span><br><span class="line"></span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := foo</span><br><span class="line">那么，y的值是“bar”，而不是“foo bar”。</span><br><span class="line">下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</span><br><span class="line"></span><br><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br><span class="line">nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“<span class="comment">#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</span></span><br><span class="line"></span><br><span class="line">dir := /foo/bar    <span class="comment"># directory to put the frobs in</span></span><br><span class="line">dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“<span class="variable">$(dir)</span>/file”那么就完蛋了。</span><br><span class="line"></span><br><span class="line">还有一个比较有用的操作符是 ?= ，先看示例：</span><br><span class="line"></span><br><span class="line">FOO ?= bar</span><br><span class="line">其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> FOO)</span>, undefined)</span><br><span class="line">    FOO = bar</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="引用一个变量的高级特性"><a href="#引用一个变量的高级特性" class="headerlink" title="引用一个变量的高级特性"></a>引用一个变量的高级特性</h4><h5 id="变量值的替换"><a href="#变量值的替换" class="headerlink" title="变量值的替换"></a>变量值的替换</h5><p>们可以替换变量中的共有的部分，其格式是 $(var:a&#x3D;b) 或是 ${var:a&#x3D;b} ，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</p>
<p>还是看一个示例吧：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">foo :<span class="operator">=</span> a.o b.o <span class="keyword">c</span>.o</span><br><span class="line">bar :<span class="operator">=</span> $(foo:.o<span class="operator">=</span>.<span class="keyword">c</span>)</span><br><span class="line">这个示例中，我们先定义了一个 $(foo) 变量，而第二行的意思是把 $(foo) 中所有以 .o 字串“结尾”全部替换成 .<span class="keyword">c</span> ，所以我们的 $(bar) 的值就是“a.<span class="keyword">c</span> b.<span class="keyword">c</span> <span class="keyword">c</span>.<span class="keyword">c</span>”。</span><br><span class="line"></span><br><span class="line">另外一种变量替换的技术是以“静态模式”，如：</span><br><span class="line"></span><br><span class="line">foo :<span class="operator">=</span> a.o b.o <span class="keyword">c</span>.o</span><br><span class="line">bar :<span class="operator">=</span> $(foo:<span class="variable">%.o</span><span class="operator">=</span><span class="variable">%.c</span>)</span><br><span class="line">这依赖于被替换字串中的有相同的模式，模式中必须包含一个 % 字符，这个例子同样让 $(bar) 变量的值为“a.<span class="keyword">c</span> b.<span class="keyword">c</span> <span class="keyword">c</span>.<span class="keyword">c</span>”。</span><br></pre></td></tr></table></figure>

<h5 id="把变量的值再当成变量"><a href="#把变量的值再当成变量" class="headerlink" title="把变量的值再当成变量"></a>把变量的值再当成变量</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br><span class="line">在这个例子中，<span class="variable">$(x)</span>的值是“y”，所以$(<span class="variable">$(x)</span>)就是<span class="variable">$(y)</span>，于是<span class="variable">$(a)</span>的值就是“z”。（注意，是“x=y”，而不是“x=<span class="variable">$(y)</span>”）</span><br><span class="line"></span><br><span class="line">我们还可以使用更多的层次：</span><br><span class="line"></span><br><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">z = u</span><br><span class="line">a := $($(<span class="variable">$(x)</span>))</span><br><span class="line">这里的 <span class="variable">$(a)</span> 的值是“u”，相关的推导留给读者自己去做吧。</span><br><span class="line"></span><br><span class="line">让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：</span><br><span class="line"></span><br><span class="line">x = <span class="variable">$(y)</span></span><br><span class="line">y = z</span><br><span class="line">z = Hello</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br><span class="line">这里的 $(<span class="variable">$(x)</span>) 被替换成了 $(<span class="variable">$(y)</span>) ，因为 <span class="variable">$(y)</span> 值是“z”，所以，最终结果是： a:=<span class="variable">$(z)</span> ，也就是“Hello”。</span><br><span class="line"></span><br><span class="line">再复杂一点，我们再加上函数：</span><br><span class="line"></span><br><span class="line">x = variable1</span><br><span class="line">variable2 := Hello</span><br><span class="line">y = <span class="variable">$(<span class="built_in">subst</span> 1,2,<span class="variable">$(x)</span>)</span></span><br><span class="line">z = y</span><br><span class="line">a := $($(<span class="variable">$(z)</span>))</span><br><span class="line">这个例子中， $($(<span class="variable">$(z)</span>)) 扩展为 $(<span class="variable">$(y)</span>) ，而其再次被扩展为 $(<span class="variable">$(<span class="built_in">subst</span> 1,2,<span class="variable">$(x)</span>)</span>) 。 <span class="variable">$(x)</span> 的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成 “variable2”，再取其值，所以，最终， <span class="variable">$(a)</span> 的值就是 <span class="variable">$(variable2)</span> 的值——“Hello”。（喔，好不容易）</span><br><span class="line"></span><br><span class="line">在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：</span><br><span class="line"></span><br><span class="line">first_second = Hello</span><br><span class="line">a = first</span><br><span class="line">b = second</span><br><span class="line">all = $($a_$b)</span><br><span class="line">这里的 $a_$b 组成了“first_second”，于是， <span class="variable">$(all)</span> 的值就是“Hello”。</span><br><span class="line"></span><br><span class="line">再来看看结合第一种技术的例子：</span><br><span class="line"></span><br><span class="line">a_objects := a.o b.o c.o</span><br><span class="line">1_objects := 1.o 2.o 3.o</span><br><span class="line"></span><br><span class="line">sources := $(<span class="variable">$(a1)</span>_objects:.o=.c)</span><br><span class="line">这个例子中，如果 <span class="variable">$(a1)</span> 的值是“a”的话，那么， <span class="variable">$(sources)</span> 的值就是“a.c b.c c.c”；如果 <span class="variable">$(a1)</span> 的值是“1”，那么 <span class="variable">$(sources)</span> 的值是“1.c 2.c 3.c”。</span><br><span class="line"></span><br><span class="line">再来看一个这种技术和“函数”与“条件语句”一同使用的例子：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> do_sort</span><br><span class="line">    func := sort</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    func := strip</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">bar := a d b g q c</span><br><span class="line"></span><br><span class="line">foo := $(<span class="variable">$(func)</span> <span class="variable">$(bar)</span>)</span><br><span class="line">这个示例中，如果定义了“do_sort”，那么： foo := <span class="variable">$(<span class="built_in">sort</span> a d b g q c)</span> ，于是 <span class="variable">$(foo)</span> 的值就是 “a b c d g q”，而如果没有定义“do_sort”，那么： foo := <span class="variable">$(<span class="built_in">strip</span> a d b g q c)</span> ，调用的就是strip函数。</span><br><span class="line"></span><br><span class="line"><span class="section">当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边:</span></span><br><span class="line"></span><br><span class="line">dir = foo</span><br><span class="line"><span class="variable">$(dir)</span>_sources := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span></span><br><span class="line"><span class="keyword">define</span> <span class="variable">$(dir)</span>_print</span><br><span class="line">lpr $(<span class="variable">$(dir)</span>_sources)</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line">这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="如何在一个变量中基于旧值添加更多内容–追加"><a href="#如何在一个变量中基于旧值添加更多内容–追加" class="headerlink" title="如何在一个变量中基于旧值添加更多内容–追加"></a>如何在一个变量中基于旧值添加更多内容–追加</h4><p>+&#x3D;</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">objects += another<span class="selector-class">.o</span></span><br><span class="line">一个例子： </span><br><span class="line">objects = <span class="selector-tag">main</span><span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span> utils<span class="selector-class">.o</span></span><br><span class="line">objects += another<span class="selector-class">.o</span></span><br><span class="line">则objects为：</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span> utils<span class="selector-class">.o</span> another<span class="selector-class">.o</span></span><br><span class="line">效果相当于：</span><br><span class="line">objects = <span class="selector-tag">main</span><span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span> utils<span class="selector-class">.o</span></span><br><span class="line">objects := $(objects) another<span class="selector-class">.o</span></span><br><span class="line">如果变量之前没有定义过，那么， += 会自动变成 = ，如果前面有变量定义，那么 += 会继承于前次操作的赋值符。如果前一次的是 := ，那么 += 会以 := 作为其赋值符，如：</span><br><span class="line"></span><br><span class="line">variable := value</span><br><span class="line">variable += more</span><br><span class="line">等价于：</span><br><span class="line"></span><br><span class="line">variable := value</span><br><span class="line">variable := $(variable) more</span><br><span class="line">但如果是这种情况：</span><br><span class="line"></span><br><span class="line">variable = value</span><br><span class="line">variable += more</span><br><span class="line">由于前次的赋值符是 = ，所以 += 也会以 = 来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</span><br></pre></td></tr></table></figure>

<h4 id="如何在makefile中设置一个变量，即使之前已经被设置；"><a href="#如何在makefile中设置一个变量，即使之前已经被设置；" class="headerlink" title="如何在makefile中设置一个变量，即使之前已经被设置；"></a>如何在makefile中设置一个变量，即使之前已经被设置；</h4><p>如果有变量是通过make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">override <span class="tag">&lt;<span class="name">variable</span>&gt;</span>; = <span class="tag">&lt;<span class="name">value</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line">override <span class="tag">&lt;<span class="name">variable</span>&gt;</span>; := <span class="tag">&lt;<span class="name">value</span>&gt;</span>;</span><br></pre></td></tr></table></figure>
<p>当然，你还可以追加:</p>
<p>override <variable>; +&#x3D; <more text>;<br>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用override指示符，如:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">define</span> foo</span><br><span class="line">bar</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<h4 id="一个设置多行字符串变量的可选方式"><a href="#一个设置多行字符串变量的可选方式" class="headerlink" title="一个设置多行字符串变量的可选方式"></a>一个设置多行字符串变量的可选方式</h4><p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。</p>
<p>define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束。其工作方式和“&#x3D;”操作符一样。<br>变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以 Tab 键开头，那么make 就不会把其认为是命令。</p>
<p>下面的这个示例展示了define的用法:</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">define <span class="literal">two</span>-<span class="keyword">lines</span></span><br><span class="line">echo foo</span><br><span class="line">echo $(bar)</span><br><span class="line">endef</span><br><span class="line">When used <span class="keyword">in</span> <span class="keyword">a</span> recipe, <span class="keyword">the</span> previous example is functionally equivalent <span class="built_in">to</span> this:</span><br><span class="line"></span><br><span class="line"><span class="literal">two</span>-<span class="keyword">lines</span> = echo foo; echo $(bar)</span><br></pre></td></tr></table></figure>

<h4 id="如何去定义一个变量，使它未被赋值"><a href="#如何去定义一个变量，使它未被赋值" class="headerlink" title="如何去定义一个变量，使它未被赋值"></a>如何去定义一个变量，使它未被赋值</h4><p>如果要清除一个变量，通常将其值设置为空就足够了。展开这样的变量将产生相同的结果(空字符串)，而不管它是否被设置。但是，如果您正在使用flavor(参见flavor函数)和origin(参见origin函数)函数，<br>则从未设置的变量和空值的变量之间存在差异。在这种情况下，你可能想要使用undefine指令使一个变量看起来像从未设置过一样。例如:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo := foo</span><br><span class="line">bar = bar</span><br><span class="line"></span><br><span class="line"><span class="keyword">undefine</span> foo</span><br><span class="line"><span class="keyword">undefine</span> bar</span><br><span class="line"></span><br><span class="line"><span class="variable">$(info $(<span class="built_in">origin</span> foo)</span>)</span><br><span class="line"><span class="variable">$(info $(<span class="built_in">flavor</span> bar)</span>)</span><br><span class="line">This example will print “undefined” for both variables.</span><br><span class="line">如果你想取消命令行变量定义，你可以使用<span class="keyword">override</span>指令和<span class="keyword">undefine</span>，类似于变量定义</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">undefine</span> CFLAGS</span><br></pre></td></tr></table></figure>

<h4 id="来自环境的变量值；"><a href="#来自环境的变量值；" class="headerlink" title="来自环境的变量值；"></a>来自环境的变量值；</h4><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了 CFLAGS 环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。</p>
<p>当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p>
<p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>
<h4 id="变量值可以在每个目标的基础上定义"><a href="#变量值可以在每个目标的基础上定义" class="headerlink" title="变量值可以在每个目标的基础上定义"></a>变量值可以在每个目标的基础上定义</h4><p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如 $&lt; 等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我也同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">&lt;target <span class="params">...</span>&gt; : &lt;<span class="built_in">variable</span><span class="params">-assignment</span>&gt;;</span><br><span class="line"></span><br><span class="line">&lt;target <span class="params">...</span>&gt; : overide &lt;<span class="built_in">variable</span><span class="params">-assignment</span>&gt;</span><br><span class="line">&lt;<span class="built_in">variable</span><span class="params">-assignment</span>&gt;;可以是前面讲过的各种赋值表达式，如 = 、 := 、 += <span class="string">``</span> 或是 <span class="string">``</span>?= 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</span><br></pre></td></tr></table></figure>
<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span></span><br><span class="line">    $(CC) $(CFLAGS) prog<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span></span><br><span class="line"></span><br><span class="line">prog<span class="selector-class">.o</span> : prog<span class="selector-class">.c</span></span><br><span class="line">    $(CC) $(CFLAGS) prog<span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line">foo<span class="selector-class">.o</span> : foo<span class="selector-class">.c</span></span><br><span class="line">    $(CC) $(CFLAGS) foo<span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line">bar<span class="selector-class">.o</span> : bar<span class="selector-class">.c</span></span><br><span class="line">    $(CC) $(CFLAGS) bar<span class="selector-class">.c</span></span><br><span class="line">在这个示例中，不管全局的 $(CFLAGS) 的值是什么，在prog目标，以及其所引发的所有规则中（prog<span class="selector-class">.o</span> foo<span class="selector-class">.o</span> bar.o的规则）， $(CFLAGS) 的值都是 -g</span><br></pre></td></tr></table></figure>

<h4 id="特定于目标的变量值可以应用于匹配模式的一组目标。"><a href="#特定于目标的变量值可以应用于匹配模式的一组目标。" class="headerlink" title="特定于目标的变量值可以应用于匹配模式的一组目标。"></a>特定于目标的变量值可以应用于匹配模式的一组目标。</h4><p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的“模式”一般是至少含有一个 % 的，所以，我们可以以如下方式给所有以 .o 结尾的目标定义目标变量：<br>%.o : CFLAGS &#x3D; -O<br>同样，模式变量的语法和“目标变量”一样：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pattern</span> <span class="attr">...</span>&gt;</span>; : <span class="tag">&lt;<span class="name">variable-assignment</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span> <span class="attr">...</span>&gt;</span>; : override <span class="tag">&lt;<span class="name">variable-assignment</span>&gt;</span>;</span><br><span class="line">override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</span><br></pre></td></tr></table></figure>
<h4 id="抑制变量的继承"><a href="#抑制变量的继承" class="headerlink" title="抑制变量的继承"></a>抑制变量的继承</h4><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">EXTRA_CFLAGS =</span><br><span class="line"></span><br><span class="line"><span class="symbol">prog:</span> <span class="keyword">private</span> EXTRA_CFLAGS = -L/usr/local/<span class="keyword">lib</span></span><br><span class="line"><span class="symbol">prog:</span> a.o b.o</span><br></pre></td></tr></table></figure>
<p>由于private修饰符，a.o和b.o不会从prog目标继承EXTRA_CFLAGS变量赋值。</p>
<h4 id="具有特殊意义或行为的变量。"><a href="#具有特殊意义或行为的变量。" class="headerlink" title="具有特殊意义或行为的变量。"></a>具有特殊意义或行为的变量。</h4><p>.VARIABLES<br>。。。</p>
<h3 id="如何使用条件语句"><a href="#如何使用条件语句" class="headerlink" title="如何使用条件语句"></a>如何使用条件语句</h3><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h4 id="条件例子"><a href="#条件例子" class="headerlink" title="条件例子"></a>条件例子</h4><p>下面的例子，判断 $(CC) 变量是否 gcc ，如果是的话，则使用GNU函数编译目标。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>可见，在上面示例的这个规则中，目标 foo 可以根据变量 $(CC) 值来选取不同的函数库来编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字： ifeq 、 else 和 endif 。 ifeq 的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。 else 表示条件表达式为假的情况。 endif 表示一个条件语句的结束，任何一个条件表达式都应该以 endif 结束。</p>
<p>当我们的变量 $(CC) 值是 gcc 时，目标 foo 的规则是：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">foo: <span class="constructor">$(<span class="params">objects</span>)</span></span><br><span class="line">    <span class="constructor">$(CC)</span> -o foo <span class="constructor">$(<span class="params">objects</span>)</span> <span class="constructor">$(<span class="params">libs_for_gcc</span>)</span></span><br><span class="line">而当我们的变量 <span class="constructor">$(CC)</span> 值不是 gcc 时（比如 cc ），目标 foo 的规则是：</span><br><span class="line"></span><br><span class="line">foo: <span class="constructor">$(<span class="params">objects</span>)</span></span><br><span class="line">    <span class="constructor">$(CC)</span> -o foo <span class="constructor">$(<span class="params">objects</span>)</span> <span class="constructor">$(<span class="params">normal_libs</span>)</span></span><br><span class="line">当然，我们还可以把上面的那个例子写得更简洁一些：</span><br><span class="line"></span><br><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line">ifeq (<span class="constructor">$(CC)</span>,gcc)</span><br><span class="line">    libs=<span class="constructor">$(<span class="params">libs_for_gcc</span>)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    libs=<span class="constructor">$(<span class="params">normal_libs</span>)</span></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">foo: <span class="constructor">$(<span class="params">objects</span>)</span></span><br><span class="line">    <span class="constructor">$(CC)</span> -o foo <span class="constructor">$(<span class="params">objects</span>)</span> <span class="constructor">$(<span class="params">libs</span>)</span></span><br></pre></td></tr></table></figure>
<h4 id="条件的语法"><a href="#条件的语法" class="headerlink" title="条件的语法"></a>条件的语法</h4><p>条件表达式的语法为:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;conditional-directive&gt;</span></span><br><span class="line"><span class="symbol">&lt;text-if-true&gt;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">以及:</span><br><span class="line"></span><br><span class="line"><span class="symbol">&lt;conditional-directive&gt;</span></span><br><span class="line"><span class="symbol">&lt;text-if-true&gt;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="symbol">&lt;text-if-false&gt;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">其中 <span class="symbol">&lt;conditional-directive&gt;</span> 表示条件关键字，如 ifeq 。这个关键字有四个。</span><br></pre></td></tr></table></figure>
<p>第一个是我们前面所见过的 ifeq</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">ife<span class="string">q (&lt;arg1&gt;, &lt;arg2&gt;)</span></span><br><span class="line">ifeq <span class="string">&#x27;&lt;arg1&gt;&#x27;</span> <span class="string">&#x27;&lt;arg2&gt;&#x27;</span></span><br><span class="line">ifeq <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line">ifeq <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&#x27;&lt;arg2&gt;&#x27;</span></span><br><span class="line">ifeq <span class="string">&#x27;&lt;arg1&gt;&#x27;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line">比较参数 arg1 和 arg2 的值是否相同。当然，参数中我们还可以使用make的函数。如:</span><br><span class="line"></span><br><span class="line">ife<span class="string">q ($(strip $(foo)</span>),)</span><br><span class="line">&lt;text-<span class="keyword">if</span>-empty&gt;</span><br><span class="line">endif</span><br><span class="line">这个示例中使用了 strip 函数，如果这个函数的返回值是空（Empty），那么 &lt;text-<span class="keyword">if</span>-empty&gt; 就生效。</span><br></pre></td></tr></table></figure>
<p>第二个条件关键字是 ifneq 。语法是：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">ifne<span class="string">q (&lt;arg1&gt;, &lt;arg2&gt;)</span></span><br><span class="line">ifneq <span class="string">&#x27;&lt;arg1&gt;&#x27;</span> <span class="string">&#x27;&lt;arg2&gt;&#x27;</span></span><br><span class="line">ifneq <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line">ifneq <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&#x27;&lt;arg2&gt;&#x27;</span></span><br><span class="line">ifneq <span class="string">&#x27;&lt;arg1&gt;&#x27;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line">其比较参数 arg1 和 arg2 的值是否相同，如果不同，则为真。和 ifeq 类似。</span><br></pre></td></tr></table></figure>
<p>第三个条件关键字是 ifdef 。语法是：</p>
<p>ifdef <variable-name><br>如果变量 <variable-name> 的值非空，那到表达式为真。否则，表达式为假。当然， <variable-name> 同样可以是一个函数的返回值。注意， ifdef 只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</p>
<p>示例一：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">示例二：</span><br><span class="line"></span><br><span class="line">foo =</span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>第一个例子中， $(frobozz) 值是 yes ，第二个则是 no。</p>
<p>第四个条件关键字是 ifndef 。其语法是：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">ifndef &lt;variable-name&gt;</span><br><span class="line">这个我就不多说了，和 ifdef 是相反的意思。</span><br><span class="line"></span><br><span class="line">在 &lt;conditional-directive&gt; 这一行上，多余的空格是被允许的，但是不能以 <span class="built_in">Tab</span> 键作为开始（不然就被认为是命令）。而注释符 <span class="meta"># 同样也是安全的。 <span class="keyword">else</span> 和 <span class="keyword">endif</span> 也一样，只要不是以 Tab 键开始就行了。</span></span><br></pre></td></tr></table></figure>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如 $@ 等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<p>而且为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h4 id="测试标志"><a href="#测试标志" class="headerlink" title="测试标志"></a>测试标志</h4><p>TODO</p>
<h3 id="如何使用函数"><a href="#如何使用函数" class="headerlink" title="如何使用函数"></a>如何使用函数</h3><p>函数允许您在makefile中进行文本处理，以计算要操作的文件或在指令中使用的命令。<br>在函数调用中使用函数，其中提供函数的名称和一些文本(参数)供函数操作。函数处理的结果在调用时被替换到makefile中，就像变量可能被替换一样。</p>
<h4 id="函数的语法，如何写一个函数调用"><a href="#函数的语法，如何写一个函数调用" class="headerlink" title="函数的语法，如何写一个函数调用"></a>函数的语法，如何写一个函数调用</h4><p>函数调用类似于变量引用。它可以出现在变量引用可能出现的任何地方，并且使用与变量引用相同的规则展开它。函数调用是这样的:<br>$(function arguments)<br>或<br>${function arguments}<br>这里的function是指一个函数名，一部分是make中的，你也可以通过call关键字自己创建函数，<arguments> 为函数的参数，参数间以逗号 , 分隔，而函数名和参数之间以“空格”分隔。<br>函数调用以 $ 开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？<br>函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用 $(subst a,b,$(x)) 这样的形式，而不是 $(subst a,b, ${x}) 的形式。</p>
<p>通过替换变量和函数调用来处理为每个参数编写的文本，以生成参数值，该参数值是函数作用的文本。替换按参数出现的顺序进行。<br>逗号和不匹配的括号或大括号不能像所写的那样出现在参数的文本中;前导空格不能像所写的那样出现在第一个参数的文本中。可以通过变量替换将这些字符放入参数值中。<br>首先定义变量逗号和空格，它们的值是孤立的逗号和空格字符，然后在需要这些字符的地方替换这些变量，像这样:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br><span class="line"><span class="comment"># bar is now ‘a,b,c’.</span></span><br></pre></td></tr></table></figure>

<p>这里，subst函数通过foo的值用逗号替换每个空格，并替换结果</p>
<h4 id="Functions-for-String-Substitution-and-Analysis-字符串操作函数列表"><a href="#Functions-for-String-Substitution-and-Analysis-字符串操作函数列表" class="headerlink" title="Functions for String Substitution and Analysis  字符串操作函数列表"></a>Functions for String Substitution and Analysis  字符串操作函数列表</h4><p>字符串处理函数<br>subst<br>$(subst <from>,<to>,<text>)<br>名称：字符串替换函数<br>功能：把字串 <text> 中的 <from> 字符串替换成 <to> 。<br>返回：函数返回被替换过后的字符串。<br>示例：<br>$(subst ee,EE,feet on the street)<br>把 feet on the street 中的 ee 替换成 EE ，返回结果是 fEEt on the strEEt 。</p>
<p>patsubst<br>$(patsubst <pattern>,<replacement>,<text>)<br>名称：模式字符串替换函数。<br>功能：查找 <text> 中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式 <pattern> ，如果匹配的话，则以 <replacement> 替换。这里， <pattern> 可以包括通配符 % ，表示任意长度的字串。如果 <replacement> 中也包含 % ，那么， <replacement> 中的这个 % 将是 <pattern> 中的那个 % 所代表的字串。（可以用 \ 来转义，以 % 来表示真实含义的 % 字符）<br>返回：函数返回被替换过后的字符串。<br>示例：<br>$(patsubst %.c,%.o,x.c.c bar.c)<br>把字串 x.c.c bar.c 符合模式 %.c 的单词替换成 %.o ，返回结果是 x.c.o bar.o<br>备注：这和我们前面“变量章节”说过的相关知识有点相似。如 $(var:<pattern>&#x3D;<replacement>;) 相当于 $(patsubst <pattern>,<replacement>,$(var)) ，而 $(var: <suffix>&#x3D;<replacement>) 则相当于 $(patsubst %<suffix>,%<replacement>,$(var)) 。<br>例如有:<br>objects &#x3D; foo.o bar.o baz.o，<br>那么， $(objects:.o&#x3D;.c) 和 $(patsubst %.o,%.c,$(objects)) 是一样的。</p>
<p>strip<br>$(strip <string>)<br>名称：去空格函数。<br>功能：去掉 <string> 字串中开头和结尾的空字符。<br>返回：返回被去掉空格的字符串值。<br>示例：<br>$(strip a b c )<br>把字串 a b c <code>去到开头和结尾的空格，结果是</code>a b c 。</p>
<p>findstring<br>$(findstring <find>,<in>)<br>名称：查找字符串函数<br>功能：在字串 <in> 中查找 <find> 字串。<br>返回：如果找到，那么返回 <find> ，否则返回空字符串。<br>示例：<br>$(findstring a,a b c)<br>$(findstring a,b c)<br>第一个函数返回 a 字符串，第二个返回空字符串</p>
<p>filter<br>$(filter &lt;pattern…&gt;,<text>)<br>名称：过滤函数<br>功能：以 <pattern> 模式过滤 <text> 字符串中的单词，保留符合模式 <pattern> 的单词。可以有多个模式。<br>返回：返回符合模式 <pattern> 的字串。<br>示例：<br>sources :&#x3D; foo.c bar.c baz.s ugh.h<br>foo: $(sources)<br>    cc $(filter %.c %.s,$(sources)) -o foo<br>$(filter %.c %.s,$(sources)) 返回的值是 foo.c bar.c baz.s 。</p>
<p>filter-out<br>$(filter-out &lt;pattern…&gt;,<text>)<br>名称：反过滤函数<br>功能：以 <pattern> 模式过滤 <text> 字符串中的单词，去除符合模式 <pattern> 的单词。可以有多个模式。<br>返回：返回不符合模式 <pattern> 的字串。<br>示例：<br>objects&#x3D;main1.o foo.o main2.o bar.o<br>mains&#x3D;main1.o main2.o<br>$(filter-out $(mains),$(objects)) 返回值是 foo.o bar.o 。</p>
<p>sort<br>$(sort <list>)<br>名称：排序函数<br>功能：给字符串 <list> 中的单词排序（升序）。<br>返回：返回排序后的字符串。<br>示例： $(sort foo bar lose) 返回 bar foo lose 。<br>备注： sort 函数会去掉 <list> 中相同的单词。</p>
<p>word<br>$(word <n>,<text>)<br>名称：取单词函数<br>功能：取字符串 <text> 中第 <n> 个单词。（从一开始）<br>返回：返回字符串 <text> 中第 <n> 个单词。如果 <n> 比 <text> 中的单词数要大，那么返回空字符串。<br>示例： $(word 2, foo bar baz) 返回值是 bar 。</p>
<p>wordlist<br>$(wordlist <ss>,<e>,<text>)<br>名称：取单词串函数<br>功能：从字符串 <text> 中取从 <ss> 开始到 <e> 的单词串。 <ss> 和 <e> 是一个数字。<br>返回：返回字符串 <text> 中从 <ss> 到 <e> 的单词字串。如果 <ss> 比 <text> 中的单词数要大，那么返回空字符串。如果 <e> 大于 <text> 的单词数，那么返回从 <ss> 开始，到 <text> 结束的单词串。<br>示例： $(wordlist 2, 3, foo bar baz) 返回值是 bar baz 。</p>
<p>words<br>$(words <text>)<br>名称：单词个数统计函数<br>功能：统计 <text> 中字符串中的单词个数。<br>返回：返回 <text> 中的单词数。<br>示例： $(words, foo bar baz) 返回值是 3 。<br>备注：如果我们要取 <text> 中最后的一个单词，我们可以这样： $(word $(words <text>),<text>) 。</p>
<p>firstword<br>$(firstword <text>)<br>名称：首单词函数——firstword。<br>功能：取字符串 <text> 中的第一个单词。<br>返回：返回字符串 <text> 的第一个单词。<br>示例： $(firstword foo bar) 返回值是 foo。<br>备注：这个函数可以用 word 函数来实现： $(word 1,<text>) 。<br>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用 VPATH 变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 CFLAGS ，如：</p>
<p>override CFLAGS +&#x3D; $(patsubst %,-I%,$(subst :, ,$(VPATH)))<br>如果我们的 $(VPATH) 值是 src:..&#x2F;headers ，那么 $(patsubst %,-I%,$(subst :, ,$(VPATH))) 将返回 -Isrc -I..&#x2F;headers ，这正是cc或gcc搜索头文件路径的参数。</p>
<h4 id="如何用函数操作文件名"><a href="#如何用函数操作文件名" class="headerlink" title="如何用函数操作文件名"></a>如何用函数操作文件名</h4><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p>
<p>dir<br>$(dir &lt;names…&gt;)<br>名称：取目录函数——dir。<br>功能：从文件名序列 <names> 中取出目录部分。目录部分是指最后一个反斜杠（ &#x2F; ）之前的部分。如果没有反斜杠，那么返回 .&#x2F; 。<br>返回：返回文件名序列 <names> 的目录部分。<br>示例： $(dir src&#x2F;foo.c hacks) 返回值是 src&#x2F; .&#x2F; 。</p>
<p>notdir<br>$(notdir &lt;names…&gt;)<br>名称：取文件函数——notdir。<br>功能：从文件名序列 <names> 中取出非目录部分。非目录部分是指最後一个反斜杠（ &#x2F; ）之后的部分。<br>返回：返回文件名序列 <names> 的非目录部分。<br>示例: $(notdir src&#x2F;foo.c hacks) 返回值是 foo.c hacks 。</p>
<p>suffix<br>$(suffix &lt;names…&gt;)<br>名称：取後缀函数——suffix。<br>功能：从文件名序列 <names> 中取出各个文件名的后缀。<br>返回：返回文件名序列 <names> 的后缀序列，如果文件没有后缀，则返回空字串。<br>示例： $(suffix src&#x2F;foo.c src-1.0&#x2F;bar.c hacks) 返回值是 .c .c。</p>
<p>basename<br>$(basename &lt;names…&gt;)<br>名称：取前缀函数——basename。<br>功能：从文件名序列 <names> 中取出各个文件名的前缀部分。<br>返回：返回文件名序列 <names> 的前缀序列，如果文件没有前缀，则返回空字串。<br>示例： $(basename src&#x2F;foo.c src-1.0&#x2F;bar.c hacks) 返回值是 src&#x2F;foo src-1.0&#x2F;bar hacks 。</p>
<p>addsuffix<br>$(addsuffix <suffix>,&lt;names…&gt;)<br>名称：加后缀函数——addsuffix。<br>功能：把后缀 <suffix> 加到 <names> 中的每个单词后面。<br>返回：返回加过后缀的文件名序列。<br>示例： $(addsuffix .c,foo bar) 返回值是 foo.c bar.c 。</p>
<p>addprefix<br>$(addprefix <prefix>,&lt;names…&gt;)<br>名称：加前缀函数——addprefix。<br>功能：把前缀 <prefix> 加到 <names> 中的每个单词后面。<br>返回：返回加过前缀的文件名序列。<br>示例： $(addprefix src&#x2F;,foo bar) 返回值是 src&#x2F;foo src&#x2F;bar 。</p>
<p>join<br>$(join <list1>,<list2>)<br>名称：连接函数——join。<br>功能：把 <list2> 中的单词对应地加到 <list1> 的单词后面。如果 <list1> 的单词个数要比 <list2> 的多，那么， <list1> 中的多出来的单词将保持原样。如果 <list2> 的单词个数要比 <list1> 多，那么， <list2> 多出来的单词将被复制到 <list1> 中。<br>返回：返回连接过后的字符串。<br>示例： $(join aaa bbb , 111 222 333) 返回值是 aaa111 bbb222 333 。</p>
<p>wildcard<br>$(wildcard pattern)<br>参数模式是一个文件名模式，通常包含通配符(如shell文件名模式)。通配符的结果是一个与模式匹配的现有文件名称的以空格分隔的列表。<br>eg:<br>objects :&#x3D; $(wildcard *.o)</p>
<p>realpath<br>$(realpath names…)<br>对于names中的每个文件名，返回规范的绝对名称。规范名称不包含任何内容。或. .组件，或任何重复路径分隔符(&#x2F;)或符号链接。如果失败，则返回空字符串。</p>
<p>abspath<br>$(abspath names…)<br>对于names中的每个文件名，返回一个不包含任何内容的绝对名称。或. .组件，或任何重复路径分隔符(&#x2F;)。<br>注意，与realpath函数不同，abspath不解析符号链接，也不要求文件名引用现有的文件或目录。使用通配符函数来测试是否存在。</p>
<h4 id="实现条件的函数"><a href="#实现条件的函数" class="headerlink" title="实现条件的函数"></a>实现条件的函数</h4><p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">$(<span class="params">if</span> &lt;<span class="params">condition</span>&gt;,&lt;<span class="params">then</span>-<span class="params">part</span>&gt;)</span></span><br><span class="line">或是</span><br><span class="line"></span><br><span class="line"><span class="constructor">$(<span class="params">if</span> &lt;<span class="params">condition</span>&gt;,&lt;<span class="params">then</span>-<span class="params">part</span>&gt;,&lt;<span class="params">else</span>-<span class="params">part</span>&gt;)</span></span><br><span class="line">可见，<span class="keyword">if</span>函数可以包含“<span class="keyword">else</span>”部分，或是不含。即<span class="keyword">if</span>函数的参数可以是两个，也可以是三个。 &lt;condition&gt; 参数是<span class="keyword">if</span>的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是， &lt;<span class="keyword">then</span>-part&gt; 会被计算，否则 &lt;<span class="keyword">else</span>-part&gt; 会被计算。</span><br></pre></td></tr></table></figure>
<p>而if函数的返回值是，如果 <condition> 为真（非空字符串），那个 <then-part> 会是整个函数的返回值，如果 <condition> 为假（空字符串），那么 <else-part> 会是整个函数的返回值，此时如果 <else-part> 没有被定义，那么，整个函数返回空字串。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">所以， &lt;<span class="keyword">then</span>-part&gt; 和 &lt;<span class="keyword">else</span>-part&gt; 只会有一个被计算。</span><br><span class="line">此外，还有两种形式，少用</span><br><span class="line"><span class="constructor">$(<span class="params">or</span> <span class="params">condition1</span>[,<span class="params">condition2</span>[,<span class="params">condition3</span>…]])</span></span><br><span class="line"></span><br><span class="line"><span class="constructor">$(<span class="params">and</span> <span class="params">condition1</span>[,<span class="params">condition2</span>[,<span class="params">condition3</span>…]])</span></span><br></pre></td></tr></table></figure>
<h4 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h4><p>foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（&#x2F;bin&#x2F;sh）中的for语句，或是C-Shell（&#x2F;bin&#x2F;csh）中的foreach语句而构建的。它的语法是：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$(foreach &lt;<span class="keyword">var</span>&gt;,&lt;list&gt;,&lt;<span class="built_in">text</span>&gt;)</span><br><span class="line">这个函数的意思是，把参数 &lt;list&gt; 中的单词逐一取出放到参数 &lt;<span class="keyword">var</span>&gt; 所指定的变量中，然后再执行 &lt;<span class="built_in">text</span>&gt; 所包含的表达式。每一次 &lt;<span class="built_in">text</span>&gt; 会返回一个字符串，循环过程中， &lt;<span class="built_in">text</span>&gt; 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， &lt;<span class="built_in">text</span>&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</span><br><span class="line"></span><br><span class="line">所以， &lt;<span class="keyword">var</span>&gt; 最好是一个变量名， &lt;list&gt; 可以是一个表达式，而 &lt;<span class="built_in">text</span>&gt; 中一般会使用 &lt;<span class="keyword">var</span>&gt; 这个参数来依次枚举 &lt;list&gt; 中的单词。举个例子：</span><br><span class="line"></span><br><span class="line">names := a b c d</span><br><span class="line">files := $(foreach n,$(names),$(n).o)</span><br><span class="line">上面的例子中， $(name) 中的单词会被挨个取出，并存到变量 n 中， $(n).o 每次根据 $(n) 计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以， $(files) 的值是 a.o b.o c.o d.o 。</span><br></pre></td></tr></table></figure>
<p>注意，foreach中的 <var> 参数是一个临时的局部变量，foreach函数执行完后，参数 <var> 的变量将不在作用，其作用域只在foreach函数当中。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">eg2:</span></span><br><span class="line"></span><br><span class="line">find_files = <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*)</span></span><br><span class="line">dirs := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(dirs)</span>,<span class="variable">$(find_files)</span>)</span></span><br><span class="line">这里我们以这种方式使用变量find_files。我们使用普通的&#x27; = &#x27;来定义递归展开变量，这样它的值就包含了一个实际的函数调用，在foreach的控制下重新展开;简单展开的变量是不行的，因为通配符只在定义find_files时被调用一次。</span><br><span class="line"></span><br><span class="line">eg3：</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> Esta-escrito-en-espanol!,b c ch,<span class="variable">$(find_files)</span>)</span></span><br></pre></td></tr></table></figure>

<h4 id="文件相关函数：写文本到一个文件中"><a href="#文件相关函数：写文本到一个文件中" class="headerlink" title="文件相关函数：写文本到一个文件中"></a>文件相关函数：写文本到一个文件中</h4><p>file函数允许makefile写出到文件或从文件读取；支持两种模式的写入： 覆盖写，从文件的开始写，覆盖存在的内容；追加，即追加到存在文件的末尾；<br>两种模式都是文件不存在就创建，有一个致命错误就是当文件不能打开去写时，或者写操作失败；当写入文件时，file函数展开为空字符串。<br>从文件中读取时，file函数展开为文件的逐字内容，但最后的换行(如果有的话)将被删除。试图从不存在的文件中读取将展开为空字符串。<br>语法：<br>$(file op filename[,text])<br>当对文件函数求值时，首先展开它的所有参数，然后将以op描述的模式打开由filename指定的文件。<br>运算符op可以是&gt;，表示文件将被新的内容覆盖，&gt;&gt;表示文件的当前内容将被追加，或者&lt;表示文件的内容将被读入。文件名指定要写入或读取的文件。在操作符和文件名之间可以有空格。<br>读取文件时，提供text的值是错误的。<br>当写入文件时，文本text将写入文件。如果文本text还没有以换行符结束，则将写入最后的换行符(即使文本是空字符串)。如果根本没有给出text参数，则不会写入任何内容。<br>eg:</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">例如，如果构建系统的命令行大小有限，并且指令运行的命令也可以接受文件中的参数，那么<span class="keyword">file</span>函数就很有用。</span><br><span class="line">许多命令都使用了这样的约定:以@作为参数前缀的参数指定一个包含更多参数的文件。那么你可以这样写你的指令:</span><br><span class="line">program: $(OBJECTS)</span><br><span class="line">        $(<span class="keyword">file</span> &gt;$@.<span class="keyword">in</span>,$^)</span><br><span class="line">        $(CMD) $(CMDFLAGS) @$@.<span class="keyword">in</span></span><br><span class="line">        @rm $@.<span class="keyword">in</span></span><br><span class="line">如果命令要求每个参数在输入文件的单独一行上，您可以这样写您的指令:</span><br><span class="line">program: $(OBJECTS)</span><br><span class="line">        $(<span class="keyword">file</span> &gt;$@.<span class="keyword">in</span>) $(foreach O,$^,$(<span class="keyword">file</span> &gt;&gt;$@.<span class="keyword">in</span>,$O))</span><br><span class="line">        $(CMD) $(CMDFLAGS) @$@.<span class="keyword">in</span></span><br><span class="line">        @rm $@.<span class="keyword">in</span></span><br></pre></td></tr></table></figure>

<h4 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h4><p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以call函数来向这个表达式传递参数。其语法是：</p>
<p>$(call <expression>,<parm1>,<parm2>,…,<parmn>)<br>当make执行这个函数时， <expression> 参数中的变量，如 $(1) 、 $(2) 等，会被参数 <parm1> 、 <parm2> 、 <parm3> 依次取代。而 <expression> 的返回值就是 call 函数的返回值。例如：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">reverse =  <span class="constructor">$(1)</span> <span class="constructor">$(2)</span></span><br><span class="line"></span><br><span class="line">foo = <span class="constructor">$(<span class="params">call</span> <span class="params">reverse</span>,<span class="params">a</span>,<span class="params">b</span>)</span></span><br><span class="line">那么， foo 的值就是 a b 。当然，参数的次序是可以自定义的，不一定是顺序的，如：</span><br><span class="line"></span><br><span class="line">reverse =  <span class="constructor">$(2)</span> <span class="constructor">$(1)</span></span><br><span class="line"></span><br><span class="line">foo = <span class="constructor">$(<span class="params">call</span> <span class="params">reverse</span>,<span class="params">a</span>,<span class="params">b</span>)</span></span><br><span class="line">此时的 foo 的值就是 b a 。</span><br></pre></td></tr></table></figure>
<p>需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向call函数提供参数时，最安全的做法是去除所有多余的空格。</p>
<h4 id="value函数"><a href="#value函数" class="headerlink" title="value函数"></a>value函数</h4><p>alue函数提供了一种方法，可以使用变量的值，而不必将其展开。请注意，这不会撤销已经发生的展开;<br>例如，如果您创建了一个简单展开的变量，它的值会在定义过程中展开;在这种情况下，value函数将返回与直接使用变量相同的结果。<br>语法：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">$(value variable)</span><br><span class="line">variables是变量名，不是变量的引用；因此，在写它的时候，你通常不会使用<span class="string">&#x27; $ &#x27;</span>或圆括号。</span><br><span class="line">（但是，如果你不希望名字是常量，你可以在名字中使用变量引用。）</span><br><span class="line">这个函数的结果是一个包含variable值的字符串，不会发生任何展开。例如，在这个makefile中:</span><br><span class="line">FOO = $PATH</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        @echo $(FOO)</span><br><span class="line">        @echo $(value FOO)</span><br><span class="line">第一行输出将是ATH，因为“$P”将被展开为make变量(假设有)，而第二行输出将是$PATH环境变量的当前值，因为value函数避免了展开。</span><br><span class="line">value函数最常与<span class="keyword">eval</span>函数一起使用(请参阅<span class="keyword">eval</span>函数)。</span><br></pre></td></tr></table></figure>

<h4 id="eval函数：Evaluate-the-arguments-as-makefile-syntax"><a href="#eval函数：Evaluate-the-arguments-as-makefile-syntax" class="headerlink" title="eval函数：Evaluate the arguments as makefile syntax"></a>eval函数：Evaluate the arguments as makefile syntax</h4><p>eval函数非常特别，它允许你定义一个新的makefile构造非常规的；<br>这是对其他变量和函数求值的结果。eval函数的参数被展开，然后将展开的结果作为makefile语法进行解析。扩展的结果可以定义新的make变量、目标、隐式或显式规则等。<br>eval函数的结果总是空字符串;因此，它可以放在makefile中的任何位置，而不会导致语法错误。<br>重要的是要意识到eval参数被展开了两次;首先是eval函数，然后在作为makefile语法解析时再次展开该展开的结果。<br>这意味着在使用eval时，可能需要为“$”字符提供额外级别的转义。值value函数有时在这些情况下很有用，可以避免不必要的展开。</p>
<p>下面是如何使用eval的示例;这个示例结合了许多概念和其他函数。尽管在本例中使用eval似乎过于复杂，而不只是写出规则，但要考虑两件事:<br>首先，模板定义(PROGRAM_template中)可能需要比这里复杂得多;<br>其次，您可以将这个示例中复杂的“通用”部分放入另一个makefile中，然后将其包含在所有单独的makefile中。现在，您的单个makefile非常简单。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PROGRAMS    = server client</span><br><span class="line"></span><br><span class="line">server_OBJS = server.o server_priv.o server_access.o</span><br><span class="line">server_LIBS = priv protocol</span><br><span class="line"></span><br><span class="line">client_OBJS = client.o client_api.o client_mem.o</span><br><span class="line">client_LIBS = protocol</span><br><span class="line"></span><br><span class="line"><span class="comment"># Everything after this is generic</span></span><br><span class="line"></span><br><span class="line">.PHONY: all</span><br><span class="line">all: <span class="variable">$</span>(PROGRAMS)</span><br><span class="line"></span><br><span class="line">define PROGRAM_template =</span><br><span class="line"> <span class="variable">$</span>(<span class="number">1</span>): <span class="variable">$</span><span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)_OBJS) <span class="variable">$</span><span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)_LIBS:%=<span class="literal">-l</span>%)</span><br><span class="line"> ALL_OBJS   += <span class="variable">$</span><span class="variable">$</span>(<span class="variable">$</span>(<span class="number">1</span>)_OBJS)</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span>(<span class="keyword">foreach</span> prog,<span class="variable">$</span>(PROGRAMS),<span class="variable">$</span>(eval <span class="variable">$</span>(call PROGRAM_template,<span class="variable">$</span>(prog))))</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span>(PROGRAMS):</span><br><span class="line">        <span class="variable">$</span>(LINK.o) <span class="variable">$</span>^ <span class="variable">$</span>(LDLIBS) <span class="literal">-o</span> <span class="variable">$</span><span class="selector-tag">@</span></span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        <span class="built_in">rm</span> <span class="operator">-f</span> <span class="variable">$</span>(ALL_OBJS) <span class="variable">$</span>(PROGRAMS)</span><br></pre></td></tr></table></figure>
<h4 id="origin函数：寻找一个变量并拿它的值"><a href="#origin函数：寻找一个变量并拿它的值" class="headerlink" title="origin函数：寻找一个变量并拿它的值"></a>origin函数：寻找一个变量并拿它的值</h4><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$(origin <span class="symbol">&lt;variable&gt;</span>)</span><br><span class="line">注意， <span class="symbol">&lt;variable&gt;</span> 是变量的名字，不应该是引用。所以你最好不要在 <span class="symbol">&lt;variable&gt;</span> 中使用</span><br><span class="line">$ 字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</span><br><span class="line">undefined</span><br><span class="line">如果 <span class="symbol">&lt;variable&gt;</span> 从来没有定义过，origin函数返回这个值 undefined</span><br><span class="line">default</span><br><span class="line">如果 <span class="symbol">&lt;variable&gt;</span> 是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</span><br><span class="line">environment</span><br><span class="line">如果 <span class="symbol">&lt;variable&gt;</span> 是一个环境变量，并且当Makefile被执行时， -<span class="keyword">e</span> 参数没有被打开。</span><br><span class="line"><span class="keyword">file</span></span><br><span class="line">如果 <span class="symbol">&lt;variable&gt;</span> 这个变量被定义在Makefile中。</span><br><span class="line"><span class="keyword">command</span> <span class="built_in">line</span></span><br><span class="line">如果 <span class="symbol">&lt;variable&gt;</span> 这个变量是被命令行定义的。</span><br><span class="line">override</span><br><span class="line">如果 <span class="symbol">&lt;variable&gt;</span> 是被override指示符重新定义的。</span><br><span class="line">automatic</span><br><span class="line">如果 <span class="symbol">&lt;variable&gt;</span> 是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</span><br><span class="line">这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件 Make.def，在 Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</span><br><span class="line"></span><br><span class="line">ifdef bletch</span><br><span class="line">    ifeq <span class="string">&quot;$(origin bletch)&quot;</span> <span class="string">&quot;environment&quot;</span></span><br><span class="line">        bletch = barf, gag, etc.</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>当然，你也许会说，使用 override 关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用 override 是可以达到这样的效果，可是 override 过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的</p>
<h4 id="flavor函数"><a href="#flavor函数" class="headerlink" title="flavor函数"></a>flavor函数</h4><p>flavor函数，像origin函数一样，不作用于变量的值而是告诉你关于变量的一些东西。具体来说，它告诉您变量的特性(<br>语法：<br>$(flavor variable)<br>注意，variable是要查询的变量的名称，而不是对该变量的引用。因此，在写它的时候，你通常不会使用’ $ ‘或圆括号。(不过，如果希望名称不是常量，也可以在名称中使用变量引用。)<br>结果是以下的形式：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">‘undefined’</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">variable</span> was never defined.</span><br><span class="line"></span><br><span class="line">‘recursive’</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">variable</span> <span class="keyword">is</span> a recursively expanded <span class="keyword">variable</span>.</span><br><span class="line"></span><br><span class="line">‘simple’</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">variable</span> <span class="keyword">is</span> a simply expanded <span class="keyword">variable</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="控制make运行的函数"><a href="#控制make运行的函数" class="headerlink" title="控制make运行的函数"></a>控制make运行的函数</h4><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> &lt;text ...&gt;)</span></span><br><span class="line">产生一个致命的错误， &lt;text ...&gt; 是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</span><br><span class="line"></span><br><span class="line">示例一：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> ERROR_001</span><br><span class="line">    <span class="variable">$(<span class="built_in">error</span> <span class="built_in">error</span> is <span class="variable">$(ERROR_001)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">示例二：</span><br><span class="line"></span><br><span class="line">ERR = <span class="variable">$(<span class="built_in">error</span> found an <span class="built_in">error</span>!)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: err</span></span><br><span class="line"></span><br><span class="line"><span class="section">err: <span class="variable">$(ERR)</span></span></span><br><span class="line">示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> &lt;text ...&gt;)</span></span><br><span class="line">这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</span><br></pre></td></tr></table></figure>
<h4 id="shelll函数"><a href="#shelll函数" class="headerlink" title="shelll函数"></a>shelll函数</h4><p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“&#96;”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br><span class="line">files := <span class="variable">$(<span class="built_in">shell</span> echo *.c)</span></span><br></pre></td></tr></table></figure>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<h4 id="guile函数"><a href="#guile函数" class="headerlink" title="guile函数"></a>guile函数</h4><p>如果GNU make在构建时支持将GNU Guile作为嵌入式扩展语言，那么Guile函数将可用。guile函数接受一个参数，这个参数首先由make以正常方式展开，然后传递给GNU guile计算器。求值器的结果被转换成一个字符串，并在makefile中用作guile函数的展开。关于在Guile中编写扩展的详细信息，请参阅GNU Guile Integration。<br>你可以通过检查Guile这个词的. .FEATURES变量来决定是否支持GNU Guile。</p>
<h3 id="如何运行make"><a href="#如何运行make" class="headerlink" title="如何运行make"></a>如何运行make</h3><p>makefile的执行，一般是直接make就可以了；make会针对过期的文件重新编译，但是你可能想去只更新部分文件；你可能想使用不同的编译器或者<br>编译器选项；你可能只想找出过期文件而不想更新改变它们；<br>通过运行make的时候给定参数，你可以做下这些事以及许多其他：<br>make的退出状态值总是这三个：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">The <span class="keyword">exit</span> status is zero <span class="keyword">if</span> make is successful.</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line">The <span class="keyword">exit</span> status is two <span class="keyword">if</span> make encounters any errors. It will print messages describing the particular errors.</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line">The <span class="keyword">exit</span> status is one <span class="keyword">if</span> you use the ‘-q’ flag and make determines that some target is not already up to date. </span><br><span class="line">See Instead of Executing Recipes.</span><br></pre></td></tr></table></figure>
<h4 id="如何具体化哪个makefile被使用"><a href="#如何具体化哪个makefile被使用" class="headerlink" title="如何具体化哪个makefile被使用"></a>如何具体化哪个makefile被使用</h4><p>使用-f&#x2F;–file参数：<br>make -f almake &#x2F; make  –file almake<br>即以almake文件来执行make；<br>如果不指定，则使用默认的文件：GNUmakefile, makefile, and Makefile</p>
<h4 id="Golas"><a href="#Golas" class="headerlink" title="Golas"></a>Golas</h4><p>如何指定生成的目标：默认的，目标是makefile文件中的第一个目标；因此一般makefile文件总是以第一个目标来生成整个程序；<br>如果第一个规则由几个目标，只有第一个目标会是默认目标，而不是整个列表；当然你也可以使用.DEFAULT_GOAL来改变默认目标；<br>也可以通过显性指定make的目标来生成对应的目标：若你指定多个模板，则make会按序执行生成他们；<br>makefile中的任何目标都可以指定为目标(除非它以’ - ‘开头或包含’ &#x3D; ‘，在这种情况下，它将分别被解析为switch或变量定义)。<br>即使目标不在makefile中也可以指定，如果make可以找到规定如何创建它们的隐式规则的话。<br>Make将特殊变量MAKECMDGOALS设置为您在命令行上指定的目标列表。如果在命令行上没有给出目标，则此变量为空。注意，这个变量应该只在特殊情况下使用。<br>一个合适的例子是，为了避免在clean的时候删除.d 文件；所以make不会仅仅为了立即删除它们而创建它们</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"></span><br><span class="line">ifneq (<span class="constructor">$(MAKECMDGOALS)</span>,clean)</span><br><span class="line"><span class="keyword">include</span> <span class="constructor">$(<span class="params">sources</span>:.<span class="params">c</span>=.<span class="params">d</span>)</span></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>指定目标的一种用法是只编译程序的一部分，或者只编译几个程序中的一个。将希望重制的每个文件指定为目标。<br>例如，考虑一个包含几个程序的目录，其makefile开头是这样的:<br>.PHONY: all<br>all: size nm ld ar as<br>若你只想生成size，你可以执行make size<br>指定目标的另一种用法可能是，不是常规的生成文件，而是一个文件用于调试信息的输出，或者一个测试版本的生成；<br>指定目标的另一种用法可能是，指定假的目标，比如make clean ;<br>有以下几种类型，直接贴原文：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">all</span><br><span class="line">Make all <span class="keyword">the</span> top-level targets <span class="keyword">the</span> makefile knows about.</span><br><span class="line"></span><br><span class="line">clean</span><br><span class="line">Delete all <span class="built_in">files</span> that are normally created <span class="keyword">by</span> running make.</span><br><span class="line"></span><br><span class="line">mostlyclean</span><br><span class="line">Like ‘clean’, but may refrain <span class="built_in">from</span> deleting <span class="keyword">a</span> few <span class="built_in">files</span> that people normally don’t want <span class="built_in">to</span> recompile. For example, <span class="keyword">the</span> ‘mostlyclean’ target <span class="keyword">for</span> GCC does <span class="keyword">not</span> <span class="built_in">delete</span> libgcc.<span class="keyword">a</span>, because recompiling <span class="keyword">it</span> is rarely necessary <span class="keyword">and</span> takes <span class="keyword">a</span> lot <span class="keyword">of</span> <span class="built_in">time</span>.</span><br><span class="line"></span><br><span class="line">distclean</span><br><span class="line">realclean</span><br><span class="line">clobber</span><br><span class="line">Any <span class="keyword">of</span> these targets might be defined <span class="built_in">to</span> <span class="built_in">delete</span> more <span class="built_in">files</span> than ‘clean’ does. For example, this would <span class="built_in">delete</span> configuration <span class="built_in">files</span> <span class="keyword">or</span> links that you would normally <span class="built_in">create</span> <span class="keyword">as</span> preparation <span class="keyword">for</span> compilation, even <span class="keyword">if</span> <span class="keyword">the</span> makefile itself cannot <span class="built_in">create</span> these <span class="built_in">files</span>.</span><br><span class="line"></span><br><span class="line">install</span><br><span class="line">Copy <span class="keyword">the</span> executable <span class="built_in">file</span> <span class="keyword">into</span> <span class="keyword">a</span> <span class="built_in">directory</span> that users typically search <span class="keyword">for</span> commands; copy <span class="keyword">any</span> auxiliary <span class="built_in">files</span> that <span class="keyword">the</span> executable uses <span class="keyword">into</span> <span class="keyword">the</span> <span class="built_in">directories</span> where <span class="keyword">it</span> will look <span class="keyword">for</span> them.</span><br><span class="line"></span><br><span class="line">print</span><br><span class="line">Print listings <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">files</span> that have changed.</span><br><span class="line"></span><br><span class="line">tar</span><br><span class="line">Create <span class="keyword">a</span> tar <span class="built_in">file</span> <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">files</span>.</span><br><span class="line"></span><br><span class="line">shar</span><br><span class="line">Create <span class="keyword">a</span> <span class="built_in">shell</span> archive (shar <span class="built_in">file</span>) <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">files</span>.</span><br><span class="line"></span><br><span class="line">dist</span><br><span class="line">Create <span class="keyword">a</span> distribution <span class="built_in">file</span> <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">files</span>. This might be <span class="keyword">a</span> tar <span class="built_in">file</span>, <span class="keyword">or</span> <span class="keyword">a</span> shar <span class="built_in">file</span>, <span class="keyword">or</span> <span class="keyword">a</span> compressed <span class="built_in">version</span> <span class="keyword">of</span> <span class="literal">one</span> <span class="keyword">of</span> <span class="keyword">the</span> above, <span class="keyword">or</span> even more than <span class="literal">one</span> <span class="keyword">of</span> <span class="keyword">the</span> above.</span><br><span class="line"></span><br><span class="line">TAGS</span><br><span class="line">Update <span class="keyword">a</span> tags table <span class="keyword">for</span> this program.</span><br><span class="line"></span><br><span class="line">check</span><br><span class="line">test</span><br><span class="line">Perform self tests <span class="keyword">on</span> <span class="title">the</span> <span class="title">program</span> <span class="title">this</span> <span class="title">makefile</span> <span class="title">builds</span>.</span><br></pre></td></tr></table></figure>
<h4 id="除了执行"><a href="#除了执行" class="headerlink" title="除了执行"></a>除了执行</h4><p>除了生成，更新目标文件之外，还可以有别的活动，比如打印等：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">‘-n’</span><br><span class="line">‘<span class="comment">--just-print’</span></span><br><span class="line">‘<span class="comment">--dry-run’</span></span><br><span class="line">‘<span class="comment">--recon’</span></span><br><span class="line">“<span class="keyword">No</span>-op”. Causes make <span class="keyword">to</span> print the recipes that are needed <span class="keyword">to</span> make the targets up <span class="keyword">to</span> <span class="type">date</span>, but <span class="keyword">not</span> actually <span class="keyword">execute</span> them. </span><br><span class="line">Note that <span class="keyword">some</span> recipes are still executed, even <span class="keyword">with</span> this flag (see How the MAKE Variable Works).</span><br><span class="line"><span class="keyword">Also</span> <span class="keyword">any</span> recipes needed <span class="keyword">to</span> <span class="keyword">update</span> included makefiles are still executed (see How Makefiles Are Remade).</span><br><span class="line"></span><br><span class="line">‘-t’</span><br><span class="line">‘<span class="comment">--touch’</span></span><br><span class="line">“Touch”. Marks targets <span class="keyword">as</span> up <span class="keyword">to</span> <span class="type">date</span> <span class="keyword">without</span> actually changing them.</span><br><span class="line"> <span class="keyword">In</span> other words, make pretends <span class="keyword">to</span> <span class="keyword">update</span> the targets but does <span class="keyword">not</span> really change their contents;</span><br><span class="line">  <span class="keyword">instead</span> <span class="keyword">only</span> their modified times are updated.</span><br><span class="line"></span><br><span class="line">‘-q’</span><br><span class="line">‘<span class="comment">--question’</span></span><br><span class="line">“Question”. Silently <span class="keyword">check</span> whether the targets are up <span class="keyword">to</span> <span class="type">date</span>, but <span class="keyword">do</span> <span class="keyword">not</span> <span class="keyword">execute</span> recipes;</span><br><span class="line"> the <span class="keyword">exit</span> code shows whether <span class="keyword">any</span> updates are needed.</span><br><span class="line"></span><br><span class="line">‘-W file’</span><br><span class="line">‘<span class="comment">--what-if=file’</span></span><br><span class="line">‘<span class="comment">--assume-new=file’</span></span><br><span class="line">‘<span class="comment">--new-file=file’</span></span><br><span class="line">&quot;what if&quot; .每个<span class="string">&#x27; -W &#x27;</span>标志后面都跟着一个文件名。</span><br><span class="line">make将给定文件的修改时间记录为当前时间，但实际的修改时间保持不变。您可以将<span class="string">&#x27; -W &#x27;</span>标志与<span class="string">&#x27; -n &#x27;</span>标志结合使用，看看如果要修改特定的文件会发生什么。</span><br></pre></td></tr></table></figure>
<h4 id="避免重编译指定的文件"><a href="#避免重编译指定的文件" class="headerlink" title="避免重编译指定的文件"></a>避免重编译指定的文件</h4><p>有时候你可能已经改变了一些源文件，但是你不想重新编译依赖它的全部文件；例如：假设你添加了一个宏或者一个声明在一个头文件中，很多<br>其他文件依赖这个头文件；保守的，make假设头文件的任何改变都需要重新编译所有的依赖它的文件，但你知道他们不需要重新编译，你可能不想浪费时间等待他们的编译；</p>
<p>如果你期望上面的文件得到解决，你可以使用-t ,make -t,这个flag告诉make不要运行规则中的指令；但是改变目标文件的最后修改时间；<br>为了避免异常，你最好按一下步骤进行：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 先<span class="keyword">make</span>执行重编译你需要重编译的文件；</span><br><span class="line"><span class="number">2</span> 改变头文件</span><br><span class="line"><span class="number">3</span> 对依赖头文件的文件，你不想重编译它，就用<span class="keyword">make</span> -t</span><br><span class="line">但是如果来不及了，即你已经改了头文件，但是有部分文件需要重新编译； 这种情况下，你可以使用-<span class="keyword">o</span> <span class="keyword">file</span> ，即它会标记一个具体的文件为旧的；</span><br><span class="line">这意味着这个文件本身不会被重生成，其他任何依赖它的文件也不会被重新生成；遵循以下步骤：</span><br><span class="line"><span class="number">1</span> 使用<span class="string">&#x27; make -o headerfile &#x27;</span>重新编译那些因特定头文件之外的原因而需要编译的源文件。如果涉及多个头文件，则对每个头文件使用单独的<span class="string">&#x27; -o &#x27;</span>选项。</span><br><span class="line"><span class="number">2</span> 对所有目标文件使用<span class="keyword">make</span> -t </span><br></pre></td></tr></table></figure>
<h4 id="覆盖变量："><a href="#覆盖变量：" class="headerlink" title="覆盖变量："></a>覆盖变量：</h4><p>一个包含&#x3D;的参数，具体化一个变量的值： v&#x3D;x ,设置变量v的值是x,如果你具体化一个值，按照这种方式，makefile中相同变量的所有普通赋值都会被忽略;我们说它们已经被命令行参数覆盖了<br>最常见的方式就是传递额外的flag给编译器：例如：<br>CFLAGS<br>cc -c $(CFLAGS) foo.c<br>这个变量被包含在每个指令中，被C编译器运行采纳；因此，为CFLAGS设置的任何值都会影响每次发生的编译。makefile可能会指定常用的CFLAGS值，如下所示:<br>CFLAGS&#x3D;-g<br>每次运行make时，如果愿意，可以重写这个值。例如，如果你说’ make CFLAGS&#x3D;’-g -O’ “，每一次C编译都将使用’ cc -c -g -O’来完成。<br>(这也说明了在覆盖变量时，如何在shell中使用引号将空格和其他特殊字符括在变量值中。)<br>变量CFLAGS只是众多标准变量中的一个，您可以通过这种方式更改它们。请参阅隐式规则使用的变量的完整列表<br>您还可以对makefile进行编程，以查看您自己的附加变量，从而使用户能够通过更改变量来控制makefile工作方式的其他方面<br>当使用命令行参数覆盖变量时，可以定义递归展开的变量或简单展开的变量。上面的例子是递归展开的变量;要创建一个简单展开的变量，可以使用’:&#x3D; ‘或’::&#x3D; ‘来代替’ &#x3D; ‘。<br>但是，除非您希望在指定的值中包含变量引用或函数调用，否则创建哪种类型的变量没有区别。<br>makefile有一种方法可以更改已覆盖的变量。这是使用override指令，它是这样一行:’ override variable &#x3D; value ‘</p>
<h4 id="测试标志-测试一个程序的编译"><a href="#测试标志-测试一个程序的编译" class="headerlink" title="测试标志,测试一个程序的编译"></a>测试标志,测试一个程序的编译</h4><p>通常，当一个错误反生在执行shell指令时，make会立即放弃，并返回一个非0值；不会继续执行来生成任何目标；<br>这个错误，暗示着目标无法正确重新生成，make会报告它；<br>当你正在编译一个你刚刚改变过的程序时，上面的结果可能不是你想要的；相反，你可能想要make 去尝试编译每个可以尝试的文件不中断，然后尽可能多的生成编译错误；</p>
<p>在这些场景下，你应该使用-k or –keep-going 标志，这告诉make在放弃并返回非零状态之前继续考虑目标的其他先决条件，并在必要时重新生成它们<br>例如，在编译一个目标文件时出现错误后，’ make -k ‘将继续编译其他目标文件，即使它已经知道不可能链接它们。</p>
<p>除了在shell命令失败后继续执行之外，在发现不知道如何创建目标文件或先决文件时，’ make -k ‘还将尽可能地继续执行。这将总是导致一个错误消息，但如果没有’ -k ‘，它将是一个致命错误<br>make的通常行为是假定你的目的是更新目标;一旦make知道这是不可能的，它不妨立即报告失败。’ -k ‘标志表示，真正的目的是尽可能多地测试程序中所做的更改，<br>可能是找到几个独立的问题，以便在下一次尝试编译之前纠正它们。这就是Emacs的M-x编译命令在默认情况下传递’ -k ‘标志的原因。</p>
<h4 id="选项总结；"><a href="#选项总结；" class="headerlink" title="选项总结；"></a>选项总结；</h4><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">-B / <span class="params">--always-make</span>: 不管先决条件是否过期，目标是否过期，总是重新生成目标；</span><br><span class="line">-c dir / <span class="params">--directory=dir</span> 改变make的工作目录；</span><br><span class="line">-d / <span class="params">--debug</span>[=options] （a/b/v/i/j/m/n<span class="function">:all</span>/basic/verbose/implicit/jobs/makefile/none):<span class="params">(全部类型的/基本的/基本之上/包括隐式规则/包括子命令/..)</span></span><br><span class="line">    打印除正常处理外的调试信息。调试信息表明哪些文件正在考虑重做，哪些文件时间正在比较，以及与什么结果相比较，哪些文件实际上需要重做，考虑了哪些隐式规则，哪些应用了——关于make如何决定做什么的所有有趣的事情。</span><br><span class="line">    -d选项等价于&#x27;——debug=a &#x27;</span><br><span class="line">-e / ‘<span class="params">--environment-overrides</span>’: 让取自环境的变量优先于makefile中的变量</span><br><span class="line">-E string / &#x27;<span class="params">--eval=string</span>’:将字符串作为makefile语法计算。这是eval函数的命令行版本<span class="params">(请参阅eval函数)</span>。计算是在定义了默认规则和变量之后，但在读取任何makefile之前执行的。</span><br><span class="line">-f file <span class="string">/--file=file</span>’/ ‘<span class="params">--makefile=file</span>’: 指定makefile文件</span><br><span class="line">-h <span class="string">/--help</span>: 打印帮助</span><br><span class="line">-i <span class="string">/--ignore-errors</span>: 忽略重编时指令中的所有错误</span><br><span class="line">‘-I dir’/‘<span class="params">--include-dir=dir</span>’:指定一个目录dir来搜索所包含的makefile。参见包含其他makefile。如果使用多个&#x27; -I &#x27;选项指定多个目录，则按照指定的顺序搜索目录。</span><br><span class="line">‘-j [jobs]’/‘<span class="params">--jobs</span>[=jobs]’ 多少个线程多线程执行</span><br><span class="line">-k / <span class="params">--keep-going</span> :继续执行，即使发生错误</span><br><span class="line">‘-l [load]’/‘<span class="params">--load-average</span>[=load]’/‘<span class="params">--max-load</span>[=load]’: 指定若有其他指令在执行，且加载的平均值至少为load，则不应启动新指令，用于控制make的多线程负载</span><br><span class="line">‘-L’/‘<span class="params">--check-symlink-times</span>’:</span><br><span class="line">在支持符号链接的系统上，除了这些链接引用的文件上的时间戳之外，这个选项还会导致make考虑任何符号链接上的时间戳。当提供此选项时，文件和符号链接中最近的时间戳将作为此目标文件的修改时间。</span><br><span class="line">‘-n’/‘<span class="params">--just-print</span>’/‘<span class="params">--dry-run</span>’/‘<span class="params">--recon</span>’: 打印要执行的指令，但是不要执行它，即只是查看它；</span><br><span class="line">‘-o file’/‘<span class="params">--old-file=file</span>’/‘<span class="params">--assume-old=file</span>’</span><br><span class="line">不要重做文件文件，即使它比它的先决条件旧，也不要重做任何文件中的变化。本质上，该文件被视为非常老的文件，其规则被忽略。</span><br><span class="line">‘-O[type]’/‘<span class="params">--output-sync</span>[=type]’:指示多线程执行的时候怎么打印信息，上文有，不赘述</span><br><span class="line">‘-p’/‘<span class="params">--print-data-base</span>’: </span><br><span class="line">打印从makefile读取的数据库：然后按照常规方式执行，要打印数据库而不重新创建任何文件，请使用&#x27; make -qp &#x27;。要打印预定义规则和变量的数据库，</span><br><span class="line">请使用&#x27; make -p -f <span class="string">/dev/null</span> &#x27;。数据库输出包含指令和变量定义的文件名和行号信息，因此它在复杂环境中是一个有用的调试工具。</span><br><span class="line">‘-q’/‘<span class="params">--question</span>’:</span><br><span class="line">不要运行任何指令，或打印任何东西;如果指定的目标已经是最新的，则只返回一个退出状态为0;如果需要重新制作，则返回一个;如果遇到错误，则返回两个</span><br><span class="line">‘-r’/‘<span class="params">--no-builtin-rules</span>’:避免使用内置的隐式规则</span><br><span class="line">“- r”/“——no-builtin-variables”:避免使用内置的特定于规则的变量</span><br><span class="line">‘-s’/‘<span class="params">--silent</span>’/‘<span class="params">--quiet</span>’: 静默模式，不输出任何信息，在执行的过程中；</span><br><span class="line">‘-S’/‘<span class="params">--no-keep-going</span>’/‘<span class="params">--stop</span>’:</span><br><span class="line">取消&#x27; -k &#x27;选项的效果。这从来没有必要，除非在递归make中，&#x27; -k &#x27;可能从顶级make中继承通过MAKEFLAGS<span class="params">(参见递归使用make)</span>，或者如果你在你的环境中的MAKEFLAGS中设置了&#x27; -k &#x27;。</span><br><span class="line">‘-t’/‘<span class="params">--touch</span>’:只是标记文件为最新，而不是真的生成目标文件</span><br><span class="line">‘<span class="params">--trace</span>’ ：显示make执行的跟踪信息。</span><br><span class="line">‘-v’/‘<span class="params">--version</span>’: 打印版本号</span><br><span class="line">‘-w’/‘<span class="params">--print-directory</span>’: 打印工作目录</span><br><span class="line">‘-W file’</span><br><span class="line">‘<span class="params">--what-if=file</span>’</span><br><span class="line">‘<span class="params">--new-file=file</span>’</span><br><span class="line">‘<span class="params">--assume-new=file</span>’</span><br><span class="line">假设目标文件刚刚被修改。当与&#x27; -n &#x27;标志一起使用时，这将显示如果要修改该文件会发生什么。如果没有&#x27; -n &#x27;，在运行make之前在给定的文件上运行touch命令几乎是一样的，除了修改时间只是在make的想象中改变。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="如何使用隐式规则"><a href="#如何使用隐式规则" class="headerlink" title="如何使用隐式规则"></a>如何使用隐式规则</h3><p>remake目标文件的确定的标准方法经常被使用。例如，一种make目标文件的习惯方法是使用C编译器cc从C源文件中获取目标文件。<br>隐式规则，告诉make如何使用习惯的技术，以便于你不用具体化他们的细节，当你想要用他们的时候；例如：<br>这是一个为C编译使用的隐式规则：文件名决定了哪种隐式规则被运行；例如，c编译典型就是用.c文件生成.o文件; 所以make为此应用了隐式规则，当他看到这种字符结尾的文件；<br>一系列的隐式规则可以按顺序应用;例如，make将通过.c文件从.y文件重制一个.o文件。<br>内置的隐式规则在其方法中使用几个变量，因此，通过更改变量的值，可以更改隐式规则的工作方式。例如，变量CFLAGS控制C编译的隐式规则给C编译器的标志。<br>您可以通过编写模式规则来定义自己的隐式规则。</p>
<p>后缀规则是定义隐式规则的一种更有限的方式。模式规则更加通用和清晰，但后缀规则保留以保持兼容性</p>
<h4 id="使用隐式规则"><a href="#使用隐式规则" class="headerlink" title="使用隐式规则"></a>使用隐式规则</h4><p>为了让make找到更新目标文件的常用方法，您所需要做的就是避免自己指定指令。<br>要么写一个没有指令的规则，要么根本不写规则。然后，make将根据存在或可以创建哪种源文件来确定使用哪种隐式规则<br>例如，有个makefile如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">foo : foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span></span><br><span class="line">        cc -o foo foo<span class="selector-class">.o</span> bar<span class="selector-class">.o</span> $(CFLAGS) $(LDFLAGS)</span><br></pre></td></tr></table></figure>
<p>这里因为你提到了foo.o,但是却没有给一个规则，所以make自动的寻找一个隐式规则来告知如何更新它；这个事情的发生不管当前是否有foo.o存在；</p>
<p>如果一个隐式规则被找到，它能应用到一个指令和一个或多个依赖(源文件)。如果你需要具体化格外的依赖文件比如头文件，你可以写一个只包含依赖文件的，不包含指令的<br>规则；</p>
<p>每个隐式规则由一个目标模板和一个依赖模板。可能有许多隐式规则用相同的目标模板；例如： 生成.o的，可以是.c,.p,等等，对应的c和pascal编译器。<br>这个规则实际上应用在依赖存在的目标上，或者能被生成；所以如果你有一个foo.c文件，make将运行c编译器，否则，如果有foo.p，make可能会运行pascal编译器来生成<br>;以此类推；</p>
<p>当然，当你写makefile,你得知道哪些隐式规则你想让make使用，并且你知道它会选择哪些依赖文件，那些依赖文件存在等等；<br>上面，我们说过，如果必要的先决条件“存在或可以建立”，就应用隐式规则。如果在makefile中显式地提到文件作为目标或先决条件，<br>或者可以递归地找到创建文件的隐式规则，则“可以创建”文件。当一个隐式前提是另一个隐式规则的结果时，我们说链接正在发生。</p>
<p>一般而言，make会为每个目标，每个只有冒号但是没有指令的目标寻找隐式规则；一个文件只在依赖中被提到也会被当做目标，这个时候它也没有具体化目标；<br>所以隐式规则寻找这里也会发生；</p>
<p>要注意显示规则不会影响到隐式规则的寻找：如<br>foo.o:foo.p<br>注意这里，依赖是foo.p,并不意味着make会依据隐式规则来从foo.p生成foo.o,例如，如果foo.c存在，则会从foo.c生成foo.o ,因为在<br>隐式规则列表中，c这个存在于p之前；</p>
<p>如果您不希望隐式规则用于没有指令的目标，可以通过编写分号为该目标提供一个空配方</p>
<h4 id="内建规则清单"><a href="#内建规则清单" class="headerlink" title="内建规则清单"></a>内建规则清单</h4><p>下面是一组预定义的隐式规则，它们总是可用的，除非makefile显式地覆盖或取消它们。<br>有关取消或重写隐式规则的信息，请参阅取消隐式规则。选项’ -r ‘或’——no-built -rules ‘取消所有预定义的规则。</p>
<p>本手册仅记录基于posix的操作系统上可用的默认规则。其他操作系统，如VMS、Windows、OS&#x2F;2等可能有不同的默认规则集。<br>要查看您版本的GNU make中可用的默认规则和变量的完整列表，请在一个没有makefile的目录中运行’ make -p ‘。</p>
<p>当然，即使是我们指定了 -r 参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有 “后缀列表”（也就一系统定义在目标 .SUFFIXES 的依赖目标），<br>那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<p>编译C程序的隐含规则。<br><n>.o 的目标的依赖目标会自动推导为 <n>.c ，并且其生成命令是 $(CC) –c $(CPPFLAGS) $(CFLAGS)</p>
<p>编译C++程序的隐含规则。<br><n>.o 的目标的依赖目标会自动推导为 <n>.cc 或是 <n>.C ，并且其生成命令是 $(CXX) –c $(CPPFLAGS) $(CFLAGS) 。（建议使用 .cc 作为C++源文件的后缀，而不是 .C ）</p>
<p>编译Pascal程序的隐含规则。<br><n>.o 的目标的依赖目标会自动推导为 <n>.p ，并且其生成命令是 $(PC) –c  $(PFLAGS) 。</p>
<p>编译Fortran&#x2F;Ratfor程序的隐含规则。<br><n>.o 的目标的依赖目标会自动推导为 <n>.r 或 <n>.F 或 <n>.f ，并且其生成命令是:<br>.f $(FC) –c  $(FFLAGS)<br>.F $(FC) –c  $(FFLAGS) $(CPPFLAGS)<br>.f $(FC) –c  $(FFLAGS) $(RFLAGS)<br>预处理Fortran&#x2F;Ratfor程序的隐含规则。<br><n>.f 的目标的依赖目标会自动推导为 <n>.r 或 <n>.F 。这个规则只是转换Ratfor 或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：<br>.F $(FC) –F $(CPPFLAGS) $(FFLAGS)<br>.r $(FC) –F $(FFLAGS) $(RFLAGS)<br>编译Modula-2程序的隐含规则。<br><n>.sym 的目标的依赖目标会自动推导为 <n>.def ，并且其生成命令是： $(M2C) $(M2FLAGS) $(DEFFLAGS) 。 <n>.o 的目标的依赖目标会自动推导为 <n>.mod ，并且其生成命令是： $(M2C) $(M2FLAGS) $(MODFLAGS) 。</p>
<p>汇编和汇编预处理的隐含规则。<br><n>.o 的目标的依赖目标会自动推导为 <n>.s ，默认使用编译器 as ，并且其生成命令是： $ (AS) $(ASFLAGS) 。 <n>.s 的目标的依赖目标会自动推导为 <n>.S ，默认使用C预编译器 cpp ，并且其生成命令是： $(AS) $(ASFLAGS) 。</p>
<p>链接Object文件的隐含规则。<br><n> 目标依赖于 <n>.o ，通过运行C的编译器来运行链接程序生成（一般是 ld ），其生成命令是： $(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS) 。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:</p>
<p>x : y.o z.o<br>并且 x.c 、 y.c 和 z.c 都存在时，隐含规则将执行如下命令:</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cc</span> -<span class="keyword">c</span> <span class="keyword">x</span>.<span class="keyword">c</span> -o <span class="keyword">x</span>.o</span><br><span class="line"><span class="keyword">cc</span> -<span class="keyword">c</span> y.<span class="keyword">c</span> -o y.o</span><br><span class="line"><span class="keyword">cc</span> -<span class="keyword">c</span> z.<span class="keyword">c</span> -o z.o</span><br><span class="line"><span class="keyword">cc</span> <span class="keyword">x</span>.o y.o z.o -o <span class="keyword">x</span></span><br><span class="line">rm -f <span class="keyword">x</span>.o</span><br><span class="line">rm -f y.o</span><br><span class="line">rm -f z.o</span><br></pre></td></tr></table></figure>
<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<p>Yacc C程序时的隐含规则。<br><n>.c 的依赖文件被自动推导为 n.y （Yacc生成的文件），其生成命令是： $(YACC) $(YFALGS) 。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</p>
<p>Lex C程序时的隐含规则。<br><n>.c 的依赖文件被自动推导为 n.l （Lex生成的文件），其生成命令是： $(LEX) $(LFALGS) 。（关于“Lex”的细节请查看相关资料）</p>
<p>Lex Ratfor程序时的隐含规则。<br><n>.r 的依赖文件被自动推导为 n.l （Lex生成的文件），其生成命令是： $(LEX) $(LFALGS) 。</p>
<p>从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。<br><n>.ln （lint生成的文件）的依赖文件被自动推导为 n.c ，其生成命令是： $(LINT) $(LINTFALGS) $(CPPFLAGS) -i 。对于 <n>.y 和 <n>.l 也是同样的规则。</p>
<p>更多参考文档</p>
<h4 id="隐式规则中变量的使用："><a href="#隐式规则中变量的使用：" class="headerlink" title="隐式规则中变量的使用："></a>隐式规则中变量的使用：</h4><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的 -R 或 –no–builtin-variables 参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是 $(CC) –c $(CFLAGS) $(CPPFLAGS) 。Make默认的编译命令是 cc ，如果你把变量 $(CC) 重定义成 gcc ，把变量 $(CFLAGS) 重定义成 -g ，那么，隐含规则中的命令全部会以 gcc –c -g $(CPPFLAGS) 的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如 CC ；一种是参数相的关，如 CFLAGS 。下面是所有隐含规则中会用到的变量：</p>
<p>关于命令的变量。<br>AR : 函数库打包程序。默认命令是 ar<br>AS : 汇编语言编译程序。默认命令是 as<br>CC : C语言编译程序。默认命令是 cc<br>CXX : C++语言编译程序。默认命令是 g++<br>CO : 从 RCS文件中扩展文件程序。默认命令是 co<br>CPP : C程序的预处理器（输出是标准输出设备）。默认命令是 $(CC) –E<br>FC : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 f77<br>GET : 从SCCS文件中扩展文件的程序。默认命令是 get<br>LEX : Lex方法分析器程序（针对于C或Ratfor）。默认命令是 lex<br>PC : Pascal语言编译程序。默认命令是 pc<br>YACC : Yacc文法分析器（针对于C程序）。默认命令是 yacc<br>YACCR : Yacc文法分析器（针对于Ratfor程序）。默认命令是 yacc –r<br>MAKEINFO : 转换Texinfo源文件（.texi）到Info文件程序。默认命令是 makeinfo<br>TEX : 从TeX源文件创建TeX DVI文件的程序。默认命令是 tex<br>TEXI2DVI : 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是 texi2dvi<br>WEAVE : 转换Web到TeX的程序。默认命令是 weave<br>CWEAVE : 转换C Web 到 TeX的程序。默认命令是 cweave<br>TANGLE : 转换Web到Pascal语言的程序。默认命令是 tangle<br>CTANGLE : 转换C Web 到 C。默认命令是 ctangle<br>RM : 删除文件命令。默认命令是 rm –f<br>关于命令参数的变量<br>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<p>ARFLAGS : 函数库打包程序AR命令的参数。默认值是 rv<br>ASFLAGS : 汇编语言编译器参数。（当明显地调用 .s 或 .S 文件时）<br>CFLAGS : C语言编译器参数。<br>CXXFLAGS : C++语言编译器参数。<br>COFLAGS : RCS命令参数。<br>CPPFLAGS : C预处理器参数。（ C 和 Fortran 编译器也会用到）。<br>FFLAGS : Fortran语言编译器参数。<br>GFLAGS : SCCS “get”程序参数。<br>LDFLAGS : 链接器参数。（如： ld ）<br>LFLAGS : Lex文法分析器参数。<br>PFLAGS : Pascal语言编译器参数。<br>RFLAGS : Ratfor 程序的Fortran 编译器参数。<br>YFLAGS : Yacc文法分析器参数。</p>
<h4 id="隐式规则链："><a href="#隐式规则链：" class="headerlink" title="隐式规则链："></a>隐式规则链：</h4><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个 .o 的文件生成，可能会是先被 Yacc的[.y]文件先成 .c ，然后再被C的编译器生成。<br>我们把这一系列的隐含规则叫做“隐含规则链”。</p>
<p>在上面的例子中，如果文件 .c 存在，那么就直接调用C的编译器的隐含规则，如果没有 .c 文件，但有一个 .y 文件，那么Yacc的隐含规则会被调用，生成 .c 文件，<br>然后，再调用C编译的隐含规则最终由 .c 生成 .o 文件，达到目标。</p>
<p>我们把这种 .c 的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，<br>其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的 makefile发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，<br>那么，产生最终目标过程中，所产生的中间目标文件会被以 rm -f 删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标 .INTERMEDIATE 来强制声明。<br>（如： .INTERMEDIATE : mid ）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标 .SECONDARY 来强制声明（如： .SECONDARY : sec ）。你还可以把你的目标，<br>以模式的方式来指定（如： %.o ）成伪目标 .PRECIOUS 的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件 foo.c 生成目标程序 foo ，按道理，make会编译生成中间文件 foo.o ，然后链接成 foo ，<br>但在实际情况下，这一动作可以被一条 cc 的命令完成（ cc –o foo foo.c ），于是优化过的规则就不会生成中间文件。</p>
<h4 id="如何定义新的隐式规则"><a href="#如何定义新的隐式规则" class="headerlink" title="如何定义新的隐式规则"></a>如何定义新的隐式规则</h4><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有 % 字符。 % 的意思是表示一个或多个任意字符。<br>在依赖目标中同样可以使用 % ，只是依赖目标中的 % 的取值，取决于其目标。</p>
<p>有一点需要注意的是， % 的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入 Makefile时，而模式规则中的 % 则发生在运行时。</p>
<p>模式规则介绍<br>模式规则中，至少在规则的目标定义中要包含 % ，否则，就是一般的规则。目标中的 % 定义表示对文件名的匹配， % 表示长度任意的非空字符串。<br>例如： %.c 表示以 .c 结尾的文件名（文件名的长度至少为3），而 s.%.c 则表示以 s. 开头， .c 结尾的文件名（文件名的长度至少为5）。</p>
<p>如果 % 定义在目标中，那么，目标中的 % 的值决定了依赖目标中的 % 的值，也就是说，目标中的模式的 % 决定了依赖目标中 % 的样子。例如有一个模式规则如下：</p>
<p>%.o : %.c ; &lt;command ……&gt;;<br>其含义是，指出了怎么从所有的 .c 文件生成相应的 .o 文件的规则。如果要生成的目标是 a.o b.o ，那么 %c 就是 a.c b.c 。</p>
<p>一旦依赖目标中的 % 模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，<br>目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>
<h5 id="模式规则示例"><a href="#模式规则示例" class="headerlink" title="模式规则示例"></a>模式规则示例</h5><p>下面这个例子表示了,把所有的 .c 文件都编译成 .o 文件.</p>
<p>%.o : %.c<br>    $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@<br>其中， $@ 表示所有的目标的挨个值， $&lt; 表示了所有依赖目标的挨个值。这些奇怪的变量我们叫“自动化变量”，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的：</p>
<p>%.tab.c %.tab.h: %.y<br>    bison -d $&lt;<br>这条规则告诉make把所有的 .y 文件都以 bison -d <n>.y 执行，然后生成 <n>.tab.c 和 <n>.tab.h 文件。（其中， <n> 表示一个任意字符串）。如果我们的执行程序 foo 依赖于文件 parse.tab.o 和 scan.o ，并且文件 scan.o 依赖于文件 parse.tab.h ，如果 parse.y 文件被更新了，那么根据上述的规则， bison -d parse.y 就会被执行一次，于是， parse.tab.o 和 scan.o 的依赖文件就齐了。（假设， parse.tab.o 由 parse.tab.c 生成，和 scan.o 由 scan.c 生成，而 foo 由 parse.tab.o 和 scan.o 链接生成，而且 foo 和其 .o 文件的依赖关系也写好，那么，所有的目标都会得到满足）</p>
<h5 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h5><p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span><span class="selector-tag">@</span> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， <span class="variable">$</span><span class="selector-tag">@</span> 就是匹配于目标中模式定义的集合。</span><br><span class="line"><span class="variable">$</span>% : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 foo.a(bar.o) ，那么， <span class="variable">$</span>% 就是 bar.o ， <span class="variable">$</span><span class="selector-tag">@</span> 就是 foo.a 。如果目标不是函数库文件（Unix下是 .a ，Windows下是 .lib ），那么，其值为空。</span><br><span class="line"><span class="variable">$</span>&lt; : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 <span class="variable">$</span>&lt; 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</span><br><span class="line"><span class="variable">$</span>? : 所有比目标新的依赖目标的集合。以空格分隔。</span><br><span class="line"><span class="variable">$</span>^ : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</span><br><span class="line"><span class="variable">$</span>+ : 这个变量很像 <span class="variable">$</span>^ ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</span><br><span class="line"><span class="variable">$</span>* : 这个变量表示目标模式中 % 及其之前的部分。如果目标是 <span class="built_in">dir</span>/a.foo.b ，并且目标的模式是 a.%.b ，那么， <span class="variable">$</span>* 的值就是 <span class="built_in">dir</span>/a.foo 。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么 <span class="variable">$</span>* 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 <span class="variable">$</span>* 就是除了后缀的那一部分。例如：如果目标是 foo.c ，因为 .c 是make所能识别的后缀名，所以， <span class="variable">$</span>* 的值就是 foo 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 <span class="variable">$</span>* ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 <span class="variable">$</span>* 就是空值。</span><br><span class="line">当你希望只对更新过的依赖文件进行操作时， <span class="variable">$</span>? 在显式规则中很有用，例如，假设有一个函数库文件叫 lib ，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：</span><br><span class="line"></span><br><span class="line">lib : foo.o bar.o lose.o win.o</span><br><span class="line">    ar <span class="built_in">r</span> lib <span class="variable">$</span>?</span><br><span class="line">在上述所列出来的自动量变量中。四个变量（ <span class="variable">$</span><span class="selector-tag">@</span> 、 <span class="variable">$</span>&lt; 、 <span class="variable">$</span>% 、 <span class="variable">$</span>* ）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上 D 或 F 字样。这是GNU make中老版本的特性，在新版本中，我们使用函数 <span class="built_in">dir</span> 或 notdir 就可以做到了。 D 的含义就是Directory，就是目录， F 的含义就是File，就是文件。</span><br></pre></td></tr></table></figure>
<p>下面是对于上面的七个变量分别加上 D 或是 F 的含义：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="variable">@D</span>)</span><br><span class="line">表示 <span class="variable">$@</span> 的目录部分（不以斜杠作为结尾），如果 <span class="variable">$@</span> 值是 dir/foo.o ，那么 <span class="variable">$(</span><span class="variable">@D</span>) 就是 dir ，而如果 <span class="variable">$@</span> 中没有包含斜杠的话，其值就是 . （当前目录）。</span><br><span class="line"><span class="variable">$(</span><span class="variable">@F</span>)</span><br><span class="line">表示 <span class="variable">$@</span> 的文件部分，如果 <span class="variable">$@</span> 值是 dir/foo.o ，那么 <span class="variable">$(</span><span class="variable">@F</span>) 就是 foo.o ， <span class="variable">$(</span><span class="variable">@F</span>) 相当于函数 <span class="variable">$(</span>notdir <span class="variable">$@</span>) 。</span><br><span class="line"><span class="variable">$(</span>*D), <span class="variable">$(</span>*F)</span><br><span class="line">和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， <span class="variable">$(</span>*D) 返回 dir ，而 <span class="variable">$(</span>*F) 返回 foo</span><br><span class="line"><span class="variable">$(</span>%D), <span class="variable">$(</span>%F)</span><br><span class="line">分别表示了函数包文件成员的目录部分和文件部分。这对于形同 archive(member) 形式的目标中的 member 中包含了不同的目录很有用。</span><br><span class="line"><span class="variable">$(</span>&lt;D), <span class="variable">$(</span>&lt;F)</span><br><span class="line">分别表示依赖文件的目录部分和文件部分。</span><br><span class="line"><span class="variable">$(</span>^D), <span class="variable">$(</span>^F)</span><br><span class="line">分别表示所有依赖文件的目录部分和文件部分。（无相同的）</span><br><span class="line"><span class="variable">$(</span>+D), <span class="variable">$(</span>+F)</span><br><span class="line">分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</span><br><span class="line"><span class="variable">$(</span><span class="string">?D</span>), <span class="variable">$(</span><span class="string">?F</span>)</span><br><span class="line">分别表示被更新的依赖文件的目录部分和文件部分。</span><br><span class="line">最后想提醒一下的是，对于 <span class="variable">$&lt;</span> ，为了避免产生不必要的麻烦，我们最好给 <span class="variable">$ </span>后面的那个特定字符都加上圆括号，比如， <span class="variable">$(</span>&lt;) 就要比 <span class="variable">$&lt;</span> 要好一些。</span><br></pre></td></tr></table></figure>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是“显式规则”和“静态模式规则”（参见前面“书写规则”一章）。其在隐含规则中并没有意义。</p>
<h5 id="模式的匹配"><a href="#模式的匹配" class="headerlink" title="模式的匹配"></a>模式的匹配</h5><p>一般来说，一个目标的模式有一个有前缀或是后缀的 % ，或是没有前后缀，直接就是一个 % 。因为 % 代表一个或多个字符，所以在定义好了的模式中，我们把 % 所匹配的内容叫做“茎”，例如 %.c 所匹配的文件“test.c”中“test”就是“茎”。因为在目标和依赖目标中同时有 % 时，依赖目标的“茎”会传给目标，当做目标中的“茎”。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式 e%t ，文件 src&#x2F;eat 匹配于该模式，于是 src&#x2F;a 就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式 c%r ，那么，目标就是 src&#x2F;car 。（“茎”被传递）</p>
<h5 id="重载内建隐含规则"><a href="#重载内建隐含规则" class="headerlink" title="重载内建隐含规则"></a>重载内建隐含规则</h5><p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">    $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(<span class="keyword">date</span>)</span><br></pre></td></tr></table></figure>
<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>
<p>%.o : %.s<br>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h4 id="老式风格的隐式规则"><a href="#老式风格的隐式规则" class="headerlink" title="老式风格的隐式规则"></a>老式风格的隐式规则</h4><p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。<br>为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：“双后缀”和“单后缀”。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如 .c.o 相当于 %o : %c 。单后缀规则只定义一个后缀，也就是源文件的后缀。<br>如 .c 相当于 % : %.c 。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。<br>例如： .c 和 .o 都是make所知道。因而，如果你定义了一个规则是 .c.o 那么其就是双后缀规则，意义就是 .c 是源文件的后缀， .o 是目标文件的后缀。如下示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.c.o:</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</span><br><span class="line"></span><br><span class="line"><span class="section">.c.o: foo.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">这个例子，就是说，文件 .c.o 依赖于文件 foo.h ，而不是我们想要的这样：</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c foo.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</span><br><span class="line"></span><br><span class="line">而要让make知道一些特定的后缀，我们可以使用伪目标 .SUFFIXES 来定义或是删除，如：</span><br><span class="line"></span><br><span class="line"><span class="section">.SUFFIXES: .hack .win</span></span><br><span class="line">把后缀 .hack 和 .win 加入后缀列表中的末尾。</span><br><span class="line"></span><br><span class="line"><span class="section">.SUFFIXES:              # 删除默认的后缀</span></span><br><span class="line"><span class="section">.SUFFIXES: .c .o .h   # 定义自己的后缀</span></span><br><span class="line">先清除默认后缀，后定义自己的后缀列表。</span><br></pre></td></tr></table></figure>
<p>make的参数 -r 或 -no-builtin-rules 也会使用得默认的后缀列表为空。而变量 SUFFIXE 被用来定义默认的后缀列表，你可以用 .SUFFIXES 来改变后缀列表，<br>但请不要改变变量 SUFFIXE 的值。</p>
<h4 id="隐式规则的搜索算法"><a href="#隐式规则的搜索算法" class="headerlink" title="隐式规则的搜索算法"></a>隐式规则的搜索算法</h4><p>比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，<br>原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是 archive(member) 的函数库文件模式，那么这个算法会被运行两次，<br>第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把 member 当作T来搜索。</p>
<p>1 把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是 src&#x2F;foo.o ，那么，D就是 src&#x2F; ，N就是 foo.o ）<br>2 创建所有匹配于T或是N的模式规则列表。<br>3 如果在模式规则列表中有匹配所有文件的模式，如 % ，那么从列表中移除其它的模式。<br>4 移除列表中没有命令的规则。<br>5 对于第一个在列表中的模式规则：  </p>
<ol>
<li>推导其“茎”S，S应该是T或是N匹配于模式中 % 非空的部分。  </li>
<li>计算依赖文件。把依赖文件中的 % 都替换成“茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。  </li>
<li>测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）  </li>
<li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。<br>6 如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：  </li>
<li>如果规则是终止规则，那就忽略它，继续下一条模式规则。  </li>
<li>计算依赖文件。（同第5步）  </li>
<li>测试所有的依赖文件是否存在或是理当存在。  </li>
<li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。  </li>
<li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。  </li>
<li>如果没有隐含规则可以使用，查看 .DEFAULT 规则，如果有，采用，把 .DEFAULT 的命令给T使用。<br>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</li>
</ol>
<h3 id="使用make更新archive文件"><a href="#使用make更新archive文件" class="headerlink" title="使用make更新archive文件"></a>使用make更新archive文件</h3><p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令 ar 来完成打包工作。<br>Archive files are files containing named sub-files called members; they are maintained with the program ar and their main use is as subroutine libraries for linking.</p>
<h4 id="archive-members"><a href="#archive-members" class="headerlink" title="archive members"></a>archive members</h4><p>一个函数库文件由多个文件组成。你可以用如下格式指定函数库文件及其组成:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">archive</span><span class="params">(member)</span></span></span><br><span class="line">这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了 ar 命令来服务的。如:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foolib</span><span class="params">(hack.o)</span></span> : hack<span class="selector-class">.o</span></span><br><span class="line">    ar cr foolib hack<span class="selector-class">.o</span></span><br><span class="line">如果要指定多个member，那就以空格分开，如:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foolib</span><span class="params">(hack.o kludge.o)</span></span></span><br><span class="line">其等价于:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foolib</span><span class="params">(hack.o)</span></span> <span class="built_in">foolib</span>(kludge.o)</span><br><span class="line">你还可以使用Shell的文件通配符来定义，如:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foolib</span><span class="params">(*.o)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="archive后缀规则"><a href="#archive后缀规则" class="headerlink" title="archive后缀规则"></a>archive后缀规则</h4><p>函数库成员的隐含规则<br>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是 a(m) 形式的，其会把目标变成 (m) 。于是，如果我们的成员是 %.o 的模式定义，并且如果我们使用 make foo.a(bar.o) 的形式调用Makefile时，隐含规则会去找 bar.o 的规则，如果没有定义 bar.o 的规则，那么内建隐含规则生效，make会去找 bar.c 文件来生成 bar.o ，如果找得到的话，make执行的命令大致如下:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">cc -c <span class="keyword">bar.c </span>-o <span class="keyword">bar.o</span></span><br><span class="line"><span class="keyword"></span>ar r foo.a <span class="keyword">bar.o</span></span><br><span class="line"><span class="keyword"></span>rm -f <span class="keyword">bar.o</span></span><br><span class="line"><span class="keyword"></span>还有一个变量要注意的是 $% ，这是专属函数库文件的自动化变量，有关其说明请参见“自动化变量”一节。</span><br></pre></td></tr></table></figure>
<p>函数库文件的后缀规则<br>你可以使用“后缀规则”和“隐含规则”来生成函数库打包文件，如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.c.a:</span><br><span class="line">    <span class="variable">$</span>(CC) <span class="variable">$</span>(CFLAGS) <span class="variable">$</span>(CPPFLAGS) <span class="literal">-c</span> <span class="variable">$</span>&lt; <span class="literal">-o</span> <span class="variable">$</span>*.o</span><br><span class="line">    <span class="variable">$</span>(AR) <span class="built_in">r</span> <span class="variable">$</span><span class="selector-tag">@</span> <span class="variable">$</span>*.o</span><br><span class="line">    <span class="variable">$</span>(<span class="built_in">RM</span>) <span class="variable">$</span>*.o</span><br><span class="line">其等效于：</span><br><span class="line"></span><br><span class="line">(%.o) : %.c</span><br><span class="line">    <span class="variable">$</span>(CC) <span class="variable">$</span>(CFLAGS) <span class="variable">$</span>(CPPFLAGS) <span class="literal">-c</span> <span class="variable">$</span>&lt; <span class="literal">-o</span> <span class="variable">$</span>*.o</span><br><span class="line">    <span class="variable">$</span>(AR) <span class="built_in">r</span> <span class="variable">$</span><span class="selector-tag">@</span> <span class="variable">$</span>*.o</span><br><span class="line">    <span class="variable">$</span>(<span class="built_in">RM</span>) <span class="variable">$</span>*.o</span><br></pre></td></tr></table></figure>
<h4 id="陷阱："><a href="#陷阱：" class="headerlink" title="陷阱："></a>陷阱：</h4><p>在进行函数库打包文件生成时，请小心使用make的并行机制（ -j 参数）。如果多个 ar 命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。<br>所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。<br>但就目前而言，你还是应该不要尽量不要使用 -j 参数  </p>
<h3 id="如何扩展gnu-make-这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；"><a href="#如何扩展gnu-make-这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；" class="headerlink" title="如何扩展gnu make 这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；"></a>如何扩展gnu make 这部分属于高级内容，有兴趣可以直接看文档，暂时不需要；</h3><h4 id="Guile-Integration"><a href="#Guile-Integration" class="headerlink" title="Guile Integration"></a>Guile Integration</h4><h4 id="Loading-Objects"><a href="#Loading-Objects" class="headerlink" title="Loading Objects"></a>Loading Objects</h4><h3 id="更多参考ref"><a href="#更多参考ref" class="headerlink" title="更多参考ref"></a>更多参考ref</h3>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>protocol_hls</title>
    <url>/2022/03/27/protocol-hls/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="hls简介"><a href="#hls简介" class="headerlink" title="hls简介"></a>hls简介</h4><ul>
<li>hls是http live stream的简称，是通过http拉流的协议，由苹果开发。<span id="more"></span></li>
<li>hls，client通过web http拉流指定m3u8文件，该文件包含ts列表，ts为实际的媒体文件，而对直播，client需要实时获取动态更新的m3u8文件。<br><a href="https://zhuanlan.zhihu.com/p/355136397">https://zhuanlan.zhihu.com/p/355136397</a></li>
</ul>
<p>rfc:</p>
<h4 id="hls的优势："><a href="#hls的优势：" class="headerlink" title="hls的优势："></a>hls的优势：</h4><p>   It allows a receiver to adapt the bit rate of the media to the current<br>   network conditions in order to maintain uninterrupted playback at the<br>   best possible quality.  It supports interstitial content boundaries.<br>   It provides a flexible framework for media encryption.  It can<br>   efficiently offer multiple renditions of the same content, such as<br>   audio translations.  It offers compatibility with large-scale HTTP<br>   caching infrastructure to support delivery to large audiences.<br>概述,playlist相关：<br>一个多媒体介绍被具体化，通过一个指定到一个playlist的uri<br>如：<a href="http://dlhls.cdn.zhanqi.tv/zqlive/30647_JIjP2.m3u8">http://dlhls.cdn.zhanqi.tv/zqlive/30647_JIjP2.m3u8</a><br>该拉取到的m3u8文件就是一个playlist.<br>播放列表的编码： A Playlist is either a Media Playlist or a Master Playlist.  Both are<br>   UTF-8 text files containing URIs and descriptive tags.</p>
<h4 id="一个示例和解释："><a href="#一个示例和解释：" class="headerlink" title="一个示例和解释："></a>一个示例和解释：</h4><p>Here is an example of a Media Playlist:</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#EXTM3U</span></span><br><span class="line"> <span class="comment">#EXT-X-TARGETDURATION:10</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#EXTINF:9.009,</span></span><br><span class="line"> <span class="keyword">http</span>://media.example.com/<span class="keyword">first</span>.ts</span><br><span class="line"> <span class="comment">#EXTINF:9.009,</span></span><br><span class="line"> <span class="keyword">http</span>://media.example.com/<span class="keyword">second</span>.ts</span><br><span class="line"> <span class="comment">#EXTINF:3.003,</span></span><br><span class="line"> <span class="keyword">http</span>://media.example.com/<span class="keyword">third</span>.ts</span><br><span class="line"></span><br><span class="line"> The <span class="keyword">first</span> <span class="built_in">line</span> is <span class="keyword">the</span> <span class="built_in">format</span> identifier tag <span class="comment">#EXTM3U.  The line</span></span><br><span class="line"> containing <span class="comment">#EXT-X-TARGETDURATION says that all Media Segments will be</span></span><br><span class="line"> <span class="number">10</span> <span class="built_in">seconds</span> <span class="keyword">long</span> <span class="keyword">or</span> less.  </span><br><span class="line"> Then, <span class="literal">three</span> Media Segments are declared.</span><br><span class="line"> The <span class="keyword">first</span> <span class="keyword">and</span> <span class="keyword">second</span> are <span class="number">9.009</span> <span class="built_in">seconds</span> <span class="keyword">long</span>; <span class="keyword">the</span> <span class="keyword">third</span> is <span class="number">3.003</span></span><br><span class="line"> <span class="built_in">seconds</span>.</span><br><span class="line"></span><br><span class="line"> To play this Playlist, <span class="keyword">the</span> client <span class="keyword">first</span> downloads <span class="keyword">it</span> <span class="keyword">and</span> <span class="keyword">then</span></span><br><span class="line"> downloads <span class="keyword">and</span> plays <span class="keyword">each</span> Media Segment declared <span class="keyword">within</span> <span class="keyword">it</span>. </span><br><span class="line"></span><br><span class="line"> The client reloads <span class="keyword">the</span> Playlist <span class="keyword">as</span> described <span class="keyword">in</span> this document <span class="built_in">to</span> discover</span><br><span class="line"> <span class="keyword">any</span> added <span class="keyword">segments</span>.  Data SHOULD be carried over HTTP [RFC7230], but,</span><br><span class="line"> <span class="keyword">in</span> general, <span class="keyword">a</span> URI can specify <span class="keyword">any</span> protocol that can reliably transfer</span><br><span class="line"> <span class="keyword">the</span> specified resource <span class="keyword">on</span> <span class="title">demand</span>.</span><br><span class="line"></span><br><span class="line">关于master playlist: 在于复杂点，提供一个可变流的集合，client可以根据自己的网络条件进行选择切换。</span><br><span class="line">A more complex presentation can be described <span class="keyword">by</span> <span class="keyword">a</span> Master Playlist.  A</span><br><span class="line"> Master Playlist provides <span class="keyword">a</span> <span class="built_in">set</span> <span class="keyword">of</span> Variant Streams, <span class="keyword">each</span> <span class="keyword">of</span> which</span><br><span class="line"> describes <span class="keyword">a</span> different <span class="built_in">version</span> <span class="keyword">of</span> <span class="keyword">the</span> same content.</span><br><span class="line"></span><br><span class="line"> A Variant Stream includes <span class="keyword">a</span> Media Playlist that specifies media</span><br><span class="line"> encoded <span class="keyword">at</span> <span class="keyword">a</span> particular bit rate, <span class="keyword">in</span> <span class="keyword">a</span> particular <span class="built_in">format</span>, <span class="keyword">and</span> <span class="keyword">at</span> <span class="keyword">a</span></span><br><span class="line"> particular resolution <span class="keyword">for</span> media containing video.</span><br><span class="line"></span><br><span class="line"> A Variant Stream can also specify <span class="keyword">a</span> <span class="built_in">set</span> <span class="keyword">of</span> Renditions.  Renditions</span><br><span class="line"> are alternate versions <span class="keyword">of</span> <span class="keyword">the</span> content, such <span class="keyword">as</span> audio produced <span class="keyword">in</span></span><br><span class="line"> different languages <span class="keyword">or</span> video recorded <span class="built_in">from</span> different camera angles.</span><br><span class="line"></span><br><span class="line"> Clients should <span class="keyword">switch</span> between different Variant Streams <span class="built_in">to</span> adapt <span class="built_in">to</span></span><br><span class="line"> network conditions.  Clients should choose Renditions based <span class="keyword">on</span> <span class="title">user</span></span><br><span class="line"> preferences.</span><br></pre></td></tr></table></figure>

<h4 id="媒体段：-media-segments即ts"><a href="#媒体段：-media-segments即ts" class="headerlink" title="媒体段： media segments即ts"></a>媒体段： media segments即ts</h4><h5 id="1-媒体段是什么："><a href="#1-媒体段是什么：" class="headerlink" title="1)媒体段是什么："></a>1)媒体段是什么：</h5><p>   A Media Playlist contains a series of Media Segments that make up the<br>   overall presentation.  A Media Segment is specified by a URI and<br>   optionally a byte range.<br>   playlist包含了一系列的媒体段，组成了整个presentation. 一个媒体段由一个URI和可选的一个字节范围指定。</p>
<h5 id="2）媒体段时长指定："><a href="#2）媒体段时长指定：" class="headerlink" title="2）媒体段时长指定："></a>2）媒体段时长指定：</h5><p>The duration of each Media Segment is indicated in the Media Playlist<br>   by its EXTINF tag (Section 4.3.2.1).</p>
<h5 id="3）媒体段的seq-num-每个seg-有一个唯一的seq-第一个为0或playlist指定，其他的都是前一个-1"><a href="#3）媒体段的seq-num-每个seg-有一个唯一的seq-第一个为0或playlist指定，其他的都是前一个-1" class="headerlink" title="3）媒体段的seq num: 每个seg 有一个唯一的seq,第一个为0或playlist指定，其他的都是前一个+1"></a>3）媒体段的seq num: 每个seg 有一个唯一的seq,第一个为0或playlist指定，其他的都是前一个+1</h5><p>Each segment in a Media Playlist has a unique integer Media Sequence Number.The Media Sequence Number of the first segment in the Media<br>   Playlist is either 0 or declared in the Playlist (Section 4.3.3.2).<br>   The Media Sequence Number of every other segment is equal to the<br>   Media Sequence Number of the segment that precedes it plus one.</p>
<h5 id="4-媒体段和连续性（dts连续和不连续等"><a href="#4-媒体段和连续性（dts连续和不连续等" class="headerlink" title="4)媒体段和连续性（dts连续和不连续等)"></a>4)媒体段和连续性（dts连续和不连续等)</h5><p>每个媒体段必须携带编码的延续<br>与以前媒体的段结尾的比特流<br>序列号，其中诸如时间戳等系列中的值<br>连续性计数器必须不间断地继续。唯一的例外<br>是媒体播放列表中的第一个媒体段和<br>明确地称为不连续性的媒体段<br>（第4.3.2.3节）。无标记的媒体不连续性可以触发<br>播放错误。<br> Each Media Segment MUST carry the continuation of the encoded<br>   bitstream from the end of the segment with the previous Media<br>   Sequence Number, where values in a series such as timestamps and<br>   Continuity Counters MUST continue uninterrupted.  The only exceptions<br>   are the first Media Segment ever to appear in a Media Playlist and<br>   Media Segments that are explicitly signaled as discontinuities<br>   (Section 4.3.2.3).  Unmarked media discontinuities can trigger<br>   playback errors.</p>
<h5 id="5-媒体段和IDR"><a href="#5-媒体段和IDR" class="headerlink" title="5) 媒体段和IDR:"></a>5) 媒体段和IDR:</h5><p>任何媒体段包含视频都应该包含足够信息来初始化解码器和解码一个连续的帧序列包含在段的最后一个帧。<br>网络有效性被优化如果有足够的解码全部帧的信息在段中。 例如，任何包含H.264视频的媒体段应该包含一个IDR帧。 在第一个IDR帧之前的帧可能会被下载但是可能会被丢弃。<br>Any Media Segment that contains video SHOULD include enough<br>   information to initialize a video decoder and decode a continuous set<br>   of frames that includes the final frame in the Segment; network<br>   efficiency is optimized if there is enough information in the Segment<br>   to decode all frames in the Segment.  For example, any Media Segment<br>   containing H.264 video SHOULD contain an Instantaneous Decoding<br>   Refresh (IDR); frames prior to the first IDR will be downloaded but<br>   possibly discarded.</p>
<h5 id="6）支持的Media-segment-格式："><a href="#6）支持的Media-segment-格式：" class="headerlink" title="6）支持的Media segment 格式："></a>6）支持的Media segment 格式：</h5><p>All Media Segments MUST be in a format described in this section.<br>   Transport of other media file formats is not defined.</p>
<p>   Some media formats require a common sequence of bytes to initialize a<br>   parser before a Media Segment can be parsed.  This format-specific<br>   sequence is called the Media Initialization Section.  The Media<br>   Initialization Section can be specified by an EXT-X-MAP tag<br>   (Section 4.3.2.5).  The Media Initialization Section MUST NOT contain<br>   sample data.</p>
<h5 id="有哪些类型的媒体段打包方式？"><a href="#有哪些类型的媒体段打包方式？" class="headerlink" title="有哪些类型的媒体段打包方式？"></a>有哪些类型的媒体段打包方式？</h5><p>3.2.  MPEG-2 Transport Streams<br>3.3.  Fragmented MPEG-4<br>3.4.  Packed Audio<br>3.5.  WebVTT</p>
<h4 id="关于playlist-以及它的语法："><a href="#关于playlist-以及它的语法：" class="headerlink" title="关于playlist:以及它的语法："></a>关于playlist:以及它的语法：</h4><p>本节介绍 HTTP Live 使用的播放列表文件<br>流媒体。在本节中，“MUST”和“MUST NOT”指定规则<br>用于合法播放列表文件的语法和结构。播放列表<br>违反这些规则无效；客户端必须无法解析它们。<br>请参见第 6.3.2 节。<br>播放列表文件的格式源自 M3U [M3U]<br>播放列表文件格式，并从该早期文件继承两个标签<br>格式：EXTM3U（第 4.3.1.1 节）和 EXTINF（第 4.3.2.1 节）</p>
<p>在标签语法规范中，一个字符串由<br>标识标签参数；其具体格式在其<br>标签定义。如果一个参数进一步被 [] 包围，它是<br>可选的;否则，它是必需的。</p>
<p>每个播放列表文件必须可以通过路径组件识别<br>其 URI 或 HTTP Content-Type。在第一种情况下，路径必须<br>以 .m3u8 或 .m3u 结尾。二、HTTP Content-Type<br>必须是“application&#x2F;vnd.apple.mpegurl”或“audio&#x2F;mpegurl”。客户<br>应该拒绝解析未被识别的播放列表。</p>
<h5 id="1）定义一个playlist-如何写？"><a href="#1）定义一个playlist-如何写？" class="headerlink" title="1）定义一个playlist:如何写？"></a>1）定义一个playlist:如何写？</h5><h5 id="2）属性列表：Attribute-Lists"><a href="#2）属性列表：Attribute-Lists" class="headerlink" title="2）属性列表：Attribute Lists"></a>2）属性列表：Attribute Lists</h5><h5 id="3）-Playlist-Tags-有很多"><a href="#3）-Playlist-Tags-有很多" class="headerlink" title="3） Playlist Tags 有很多"></a>3） Playlist Tags 有很多</h5><p>A basic Tags:These tags are allowed in both Media Playlists and Master Playlists.<br>EXTM3U<br>EXT-X-VERSION<br>B  Media Segment Tags: 4.3.2<br>  EXTINF<br>  EXT-X-BYTERANGE<br>  …<br>C Media Playlist Tags 4.3.3<br>…<br>D Master Playlist Tags 4.3.4<br>E  Media or Master Playlist Tags 4.3.5</p>
<h4 id="关于Key-FIles："><a href="#关于Key-FIles：" class="headerlink" title="关于Key FIles："></a>关于Key FIles：</h4><p>带有 URI 属性的 EXT-X-KEY 标记标识一个密钥文件(key file)。Key file 包含一个密钥，可以解密媒体段中的<br>播放列表。<br>…</p>
<h4 id="客户端-x2F-服务器职责"><a href="#客户端-x2F-服务器职责" class="headerlink" title="客户端&#x2F;服务器职责"></a>客户端&#x2F;服务器职责</h4><h5 id="服务器的职责："><a href="#服务器的职责：" class="headerlink" title="服务器的职责："></a>服务器的职责：</h5><p>1）一般服务器职责<br>2）直播的playlists<br>3） Encrypting Media Segments<br>4） Providing Variant Streams</p>
<h5 id="客户端的职责："><a href="#客户端的职责：" class="headerlink" title="客户端的职责："></a>客户端的职责：</h5><p>1）一般客户端职责<br>2）Loading the Media Playlist File<br>3）  Playing the Media Playlist File<br>4） Reloading the Media Playlist File<br>5） Determining the Next Segment to Load<br>6）Decrypting Encrypted Media Segments</p>
<h4 id="协议版本兼容性"><a href="#协议版本兼容性" class="headerlink" title="协议版本兼容性"></a>协议版本兼容性</h4><p>协议兼容性由Ext-X-Version标记指定。一种<br>包含不兼容的标记或属性的播放列表<br>具有协议版本1必须包含ext-x-version标记。</p>
<p>如果它不支持，客户端不得尝试播放<br>ext-x-version标记指定的协议版本或意外<br>可能发生行为。<br>更多说明见协议</p>
<h4 id="playlist-实例："><a href="#playlist-实例：" class="headerlink" title="playlist 实例："></a>playlist 实例：</h4><p>1）简单的media playlist<br>2)直播媒体使用https<br>3) playlist使用加密的media segments<br>4) Master Playlist<br> #EXTM3U<br>   #EXT-X-STREAM-INF:BANDWIDTH&#x3D;1280000,AVERAGE-BANDWIDTH&#x3D;1000000<br>   <a href="http://example.com/low.m3u8">http://example.com/low.m3u8</a><br>   #EXT-X-STREAM-INF:BANDWIDTH&#x3D;2560000,AVERAGE-BANDWIDTH&#x3D;2000000<br>   <a href="http://example.com/mid.m3u8">http://example.com/mid.m3u8</a><br>   #EXT-X-STREAM-INF:BANDWIDTH&#x3D;7680000,AVERAGE-BANDWIDTH&#x3D;6000000<br>   <a href="http://example.com/hi.m3u8">http://example.com/hi.m3u8</a><br>   #EXT-X-STREAM-INF:BANDWIDTH&#x3D;65000,CODECS&#x3D;”mp4a.40.5”<br>   <a href="http://example.com/audio-only.m3u8">http://example.com/audio-only.m3u8</a><br>5) Master Playlist with I-Frames<br>6) Master Playlist with Alternative Audio<br>7) Master Playlist with Alternative Video<br>8) Session Data in a Master Playlist<br>9) CHARACTERISTICS Attribute Containing Multiple Characteristics<br>10)EXT-X-DATERANGE Carrying SCTE-35 Tags</p>
<h4 id="IANA-考虑事项"><a href="#IANA-考虑事项" class="headerlink" title="IANA 考虑事项"></a>IANA 考虑事项</h4><p>Internet分配的号码权限（IANA）负责维护一系列注册管理机构，这对于确保DNS根域，IP地址和其他Internet协议资源的全球协调至关重要。自1997年以来，该作用是由ICANN进行的，根据美国商务部的国家电信和信息管理局（NTIA）授予的合同。<br>更多见协议</p>
<h4 id="安全性考虑"><a href="#安全性考虑" class="headerlink" title="安全性考虑"></a>安全性考虑</h4><p>因为是http的，所以。。。<br>虽然可以对media seg加密解密，。加密密钥由 URI 指定。这些钥匙的交付<br>应该通过 HTTP Over TLS [RFC2818] 等机制来保护<br>（以前称为 SSL）与安全领域或会话令牌结合使用。<br>更多见协议</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>hls支持的媒体类型：<br>1）支持mp3&#x2F;aac&#x2F;mp4&#x2F;webvtt(字幕)&#x2F;广告等<br>2）支持嵌套子m3u8<br>关于怎么用webvtt:<a href="https://aws.amazon.com/cn/blogs/china/encapsulation-of-hls-streaming-media-loaded-with-webvtt-subtitles-based-on-mediaconvert/">https://aws.amazon.com/cn/blogs/china/encapsulation-of-hls-streaming-media-loaded-with-webvtt-subtitles-based-on-mediaconvert/</a><br>hls是由apple开发的，所以更多资料：<a href="https://developer.apple.com/streaming/">https://developer.apple.com/streaming/</a></p>
]]></content>
      <categories>
        <category>protocol</category>
      </categories>
      <tags>
        <tag>protocol</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_netfilter</title>
    <url>/2022/03/27/linux-netfilter/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="关于netfilter"><a href="#关于netfilter" class="headerlink" title="关于netfilter"></a>关于netfilter</h3><p>netfilter的介绍：</p>
<p>PS: 关于netfilter属于内核中的哪一层，或者内核软件结构解析：<span id="more"></span><br>看下载下来的内核代码：可以看到netfilter相关的头文件在：&#x2F;linux-lts-xenial-4.4.0&#x2F;include&#x2F;linux&#x2F;netfilter&#x2F;目录中<br>而看实际实现文件在 &#x2F;net&#x2F;netfilter中，也就是说它属于linux的网络部分代码中的一个软件库；和ipv4并列，而ipv4&#x2F;中包含了ip，tcp等网络的实现；<br>所以netfilter在linux源码的地位可想而知；</p>
<p>再来思考下linux源代码：其实是一个大的软件库，而linux系统就是调用了里面的各种函数，运行起来的一个大软件；<br>对linux源代码的使用，可以编写linux内核相关的代码，而通过以模块的形式载入内核，就可以影响内核的行为；<br>内核软件架构本身是分部分分层的，实际上比如netfilter是可以被其他各个部分的代码引用使用，但是设计是需要考虑分层隔离概念，不然会做到耦合太强；</p>
<h4 id="netfilter的4个表和5个链的概念"><a href="#netfilter的4个表和5个链的概念" class="headerlink" title="netfilter的4个表和5个链的概念"></a>netfilter的4个表和5个链的概念</h4><h4 id="netfilter的使用例子："><a href="#netfilter的使用例子：" class="headerlink" title="netfilter的使用例子："></a>netfilter的使用例子：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>    <span class="comment">// included for all kernel modules</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>    <span class="comment">// included for KERN_INFO</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>      <span class="comment">// included for __init and __exit macros</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter_ipv4.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/vmalloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"><span class="built_in">MODULE_AUTHOR</span>(<span class="string">&quot;geeksword&quot;</span>);</span><br><span class="line"><span class="built_in">MODULE_DESCRIPTION</span>(<span class="string">&quot;A Simple Hello Packet Module&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;	NF_IP_PRE_ROUTING,</span><br><span class="line">	NF_IP_LOCAL_IN,</span><br><span class="line">	NF_IP_FORWARD,</span><br><span class="line">	NF_IP_LOCAL_OUT,</span><br><span class="line">	NF_IP_POST_ROUTING,</span><br><span class="line">	NF_IP_NUMHOOKS	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">nf_hook_ops</span> in_nfho;   <span class="comment">//net filter hook option struct</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">nf_hook_ops</span> out_nfho;   <span class="comment">//net filter hook option struct</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">dump_addr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *iphdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">printk</span>(<span class="string">&quot;%d.&quot;</span>, *(iphdr+<span class="number">12</span>+i));	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">printk</span>(<span class="string">&quot;%d.&quot;</span>, *(iphdr+<span class="number">16</span>+i));	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printk</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">my_hook</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> hooknum,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> net_device *in,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> net_device *out,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> sk_buff *))</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;Hello packet! &quot;</span>);</span><br><span class="line">    <span class="comment">//printk(&quot;from %s to %s\n&quot;, in-&gt;name, out-&gt;name);</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *iphdr = <span class="built_in">skb_network_header</span>(skb);</span><br><span class="line">    <span class="keyword">if</span>(iphdr)&#123;</span><br><span class="line">	<span class="built_in">dump_addr</span>(iphdr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">  <span class="comment">//  return NF_DROP;//会导致上不了网</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">init_filter_if</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//NF_IP_PRE_ROUTING hook</span></span><br><span class="line">  in_nfho.hook = my_hook;</span><br><span class="line">  in_nfho.hooknum = NF_IP_LOCAL_IN;</span><br><span class="line">  in_nfho.pf = PF_INET;</span><br><span class="line">  in_nfho.priority = NF_IP_PRI_FIRST;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">nf_register_hook</span>(&amp;in_nfho);</span><br><span class="line"></span><br><span class="line"><span class="comment">//NF_IP_LOCAL_OUT hook</span></span><br><span class="line">  out_nfho.hook = my_hook;</span><br><span class="line">  out_nfho.hooknum = NF_IP_LOCAL_OUT;</span><br><span class="line">  out_nfho.pf = PF_INET;</span><br><span class="line">  out_nfho.priority = NF_IP_PRI_FIRST;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">nf_register_hook</span>(&amp;out_nfho);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;[+] Register Hello_Packet module!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">init_filter_if</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">// Non-zero return means that the module couldn&#x27;t be loaded.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">nf_unregister_hook</span>(&amp;in_nfho);</span><br><span class="line">  <span class="built_in">nf_unregister_hook</span>(&amp;out_nfho); </span><br><span class="line">  <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;Cleaning up Helllo_Packet module.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br><span class="line"></span><br><span class="line">编译：</span><br><span class="line">obj-m += hello.o</span><br><span class="line">obj-m += hello-packet.o</span><br><span class="line"><span class="meta">#obj-m += rootkit.o</span></span><br><span class="line">obj-m += rickroll.o</span><br><span class="line">obj-m += excited_virus.o</span><br><span class="line">obj-m += task2file.o</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着make<br>sudo insmod hello-packet.ko<br>dmesg | tail 可以看到输出的日志<br>sudo rmmod hello-packet</p>
<h4 id="关于linux下如何下载编译linux源代码，使用源代码创建模块，加载卸载模块等内容，专门一个文章记录；"><a href="#关于linux下如何下载编译linux源代码，使用源代码创建模块，加载卸载模块等内容，专门一个文章记录；" class="headerlink" title="关于linux下如何下载编译linux源代码，使用源代码创建模块，加载卸载模块等内容，专门一个文章记录；"></a>关于linux下如何下载编译linux源代码，使用源代码创建模块，加载卸载模块等内容，专门一个文章记录；</h4>]]></content>
  </entry>
  <entry>
    <title>gdb_more</title>
    <url>/2022/03/27/gdb-more/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="gdb介绍："><a href="#gdb介绍：" class="headerlink" title="gdb介绍："></a>gdb介绍：</h3><p>gdb是一个c&#x2F;c++ 语言在gnu编译器下的debugger调试器，它支持单步调试，查看运行时内存，core-dump文件等功能；  <span id="more"></span><br>它可以做很多事情来发现程序的bug,通过以下步骤：<br>a  Start your program, specifying anything that might affect its behavior.<br>b  Make your program stop on specified conditions.<br>c  Examine what has happened, when your program has stopped.<br>d  Change things in your program, so you can experiment with correcting the effects of one bug and go on to learn about another.<br>它还支持其他语言，具体见文档；<a href="https://sourceware.org/gdb/download/onlinedocs/gdb/index.html">https://sourceware.org/gdb/download/onlinedocs/gdb/index.html</a>  </p>
<h3 id="一个简单的例子："><a href="#一个简单的例子：" class="headerlink" title="一个简单的例子："></a>一个简单的例子：</h3><p><a href="https://sourceware.org/gdb/download/onlinedocs/gdb/Sample-Session.html#Sample-Session">https://sourceware.org/gdb/download/onlinedocs/gdb/Sample-Session.html#Sample-Session</a><br>在gcc编译时，带上-g </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) set width <span class="number">70</span> 设置gdb屏幕显示宽度为<span class="number">70</span>列；</span><br><span class="line">(gdb) <span class="keyword">break</span> m4_changequote  设置一个断点，m4_changequote 这个是源文件中的一个函数名</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x62f4</span>: file builtin.c, line <span class="number">879.</span></span><br><span class="line">开始运行：</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /work/Editorial/gdb/gnu/m4/m4</span><br><span class="line">会在断点停住，并展示上下文信息：</span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">m4_changequote</span> (argc=<span class="number">3</span>, argv=<span class="number">0x33c70</span>)</span><br><span class="line">    at builtin.c:<span class="number">879</span></span><br><span class="line"><span class="number">879</span>         <span class="keyword">if</span> (<span class="built_in">bad_argc</span>(<span class="built_in">TOKEN_DATA_TEXT</span>(argv[<span class="number">0</span>]),argc,<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">于是我们可以接着执行下一行：</span><br><span class="line">(gdb) n  <span class="meta">#next，会执行下一行，但是碰到子函数不会进去；</span></span><br><span class="line"><span class="number">882</span>         <span class="built_in">set_quotes</span>((argc &gt;= <span class="number">2</span>) ? <span class="built_in">TOKEN_DATA_TEXT</span>(argv[<span class="number">1</span>])\</span><br><span class="line"> : nil,</span><br><span class="line">(gdb) s  <span class="meta">#step 真正的单步调试，碰到子函数会进去一步一步执行</span></span><br><span class="line">(gdb) finish  会将正在调试的函数执行完然后打印返回值，等待接下来的指令；简写：<span class="built_in">fin</span></span><br><span class="line">(gdb) bt <span class="meta"># backtrace 可以看到当前执行的backtrace</span></span><br><span class="line">(gdb) p var #打印当前上下文 var变量的值 <span class="meta">#print</span></span><br><span class="line">(gdb) l 列出当前的代码  <span class="meta">#list</span></span><br><span class="line">(gdb) c  <span class="meta">#continue 继续执行直到结束</span></span><br><span class="line">(gdb) Ctrl-d / quit 结束和退出gdb </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="常见指令："><a href="#常见指令：" class="headerlink" title="常见指令："></a>常见指令：</h3><h3 id="系统教程："><a href="#系统教程：" class="headerlink" title="系统教程："></a>系统教程：</h3><h4 id="如何进入和退出gdb"><a href="#如何进入和退出gdb" class="headerlink" title="如何进入和退出gdb"></a>如何进入和退出gdb</h4><ul>
<li>简单的进入和出来<br>type ‘gdb’ to start GDB.<br>type quit or Ctrl-d to exit.</li>
</ul>
<h4 id="GDB指令"><a href="#GDB指令" class="headerlink" title="GDB指令"></a>GDB指令</h4><p>可以缩写gdb的指令，用指令名字前面的几个字母，如果这个缩写是明确的;<br>您可以只输入回车来重复某些GDB命令，您还可以使用TAB键来让GDB填写命令中的剩余单词(或者向您显示可用的替代，如果有不止一种可能)。</p>
<h5 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h5><p>如何给定指令给gdb</p>
<p>关于指令语法： 指令名+参数<br>gdb的指令是单行输入，但是没有限制多长。起于一个指令名字，接着是一些参数，依赖于具体的指令；<br>例如：<br>step 接收一个参数，用来表示单步几次，如<br>step 5 ,会执行5次step<br>也可以不指定参数，有些指令不允许任何参数；</p>
<p>关于简写：<br>step的指令可以缩减为s，其他类似</p>
<p>关于回车的使用：<br>1）空白行回车会重复之前的指令<br>2）当使用回车重复list和x命令时，会构造新的参数，而不是完全按类型重复。这允许很容易地扫描源或存储器。<br>3）GDB还可以以另一种方式使用RET:以类似于常用实用程序more的方式对冗长的输出进行分区(参见屏幕大小)。<br>因为在这种情况下很容易多次按下RET，所以GDB会在生成这种显示的任何命令之后禁用命令重复。</p>
<p>关于注释：<br>从#到行尾的任何文本都是注释;它什么都不做。这主要在命令文件中有用(参见命令文件)。</p>
<p>Ctrl-o绑定对于重复一个复杂的命令序列非常有用。这个命令接受当前行，就像RET一样，然后从历史记录中获取相对于当前行的下一行，以便进行编辑。？？</p>
<h5 id="指令设置"><a href="#指令设置" class="headerlink" title="指令设置"></a>指令设置</h5><p>如何改变指令的默认行为<br>通过set等，可以改变一些指令的行为：如</p>
<ol>
<li>一个简单的例子：<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">gdb)<span class="built_in">set</span> <span class="built_in">print</span> elements 10</span><br><span class="line">gdb)<span class="built_in">print</span> some_array</span><br><span class="line"><span class="variable">$1</span> = &#123;0, 10, 20, 30, 40, 50, 60, 70, 80, 90<span class="built_in">..</span>.&#125; #只会输出10个，默认是200</span><br><span class="line">也可以这样指定，这样会覆盖之前set的设置：</span><br><span class="line">(GDB) <span class="built_in">print</span> -elements 10 -- some_array</span><br><span class="line"><span class="variable">$1</span> = &#123;0, 10, 20, 30, 40, 50, 60, 70, 80, 90<span class="built_in">..</span>.&#125;</span><br></pre></td></tr></table></figure></li>
<li>临时的设置：<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">语法;</span><br><span class="line">with setting [value] [-- command]</span><br><span class="line">w setting [value] [-- command]</span><br><span class="line">临时设置是在指令执行的期间生效，如果command未指定，则是作用的上个指令的重复；</span><br><span class="line">eg:</span><br><span class="line">(GDB) with print<span class="built_in"> array </span>on -- print some_array</span><br><span class="line">is equivalent to the following 3 commands:</span><br><span class="line"></span><br><span class="line">(GDB) set print<span class="built_in"> array </span>on</span><br><span class="line">(GDB) print some_array</span><br><span class="line">(GDB) set print<span class="built_in"> array </span>off</span><br><span class="line">也可以作用到用户设置的指令：</span><br><span class="line">(GDB) with print pretty on -- my_complex_command</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="指令的补全："><a href="#指令的补全：" class="headerlink" title="指令的补全："></a>指令的补全：</h5><p>如果只有一种可能，GDB可以在命令中为您填写单词的其余部分;<br>它还可以在任何时候向您显示命令中下一个单词的有效可能性。这适用于GDB命令、GDB子命令、命令选项和程序中符号的名称。<br>当您想让GDB填写单词的剩余部分时，请按TAB键。如果只有一种可能，GDB填充这个单词，并等待您完成命令(或按RET输入)。例如，如果你输入</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">(gdb) info bre TAB</span><br><span class="line">GDB fills <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">rest</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="built_in">word</span> ‘breakpoints’, <span class="keyword">since</span> <span class="keyword">that</span> <span class="keyword">is</span> <span class="keyword">the</span> only info subcommand <span class="keyword">beginning</span> <span class="keyword">with</span> ‘bre’:</span><br><span class="line"></span><br><span class="line">(gdb) info breakpoints</span><br><span class="line">接着你可以按回车键来执行，如果不是它，则删除重写，当然也可以info bre后回车，利用缩写功能；</span><br><span class="line"></span><br><span class="line">如果有多个选项：会展示出来让你选</span><br><span class="line">(gdb) b make_ TAB</span><br><span class="line">GDB sounds bell; press TAB again, <span class="keyword">to</span> see:</span><br><span class="line">make_a_section_from_file     make_environ</span><br><span class="line">make_abs_section             make_function_type</span><br><span class="line">make_blockvector             make_pointer_type</span><br><span class="line">make_cleanup                 make_reference_type</span><br><span class="line">make_command                 make_symbol_completion_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果嫌打印的太多了：</span><br><span class="line">可以设置：</span><br><span class="line"><span class="keyword">set</span> max-completions limit</span><br><span class="line"><span class="keyword">set</span> max-completions unlimited</span><br><span class="line">Set <span class="keyword">the</span> maximum <span class="built_in">number</span> <span class="keyword">of</span> completion candidates. GDB will stop looking <span class="keyword">for</span> more completions once <span class="keyword">it</span> collects this many candidates. This <span class="keyword">is</span> useful when completing <span class="keyword">on</span> things like function names <span class="keyword">as</span> collecting all <span class="keyword">the</span> possible candidates can be <span class="built_in">time</span> consuming. The default value <span class="keyword">is</span> <span class="number">200.</span> A value <span class="keyword">of</span> zero disables <span class="literal">tab</span>-completion. Note <span class="keyword">that</span> setting either no limit <span class="keyword">or</span> a very large limit can make completion slow.</span><br><span class="line"></span><br><span class="line">show max-completions</span><br></pre></td></tr></table></figure>
<p>或者其他办法：<br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Completion.html#Completion">https://sourceware.org/gdb/current/onlinedocs/gdb/Completion.html#Completion</a></p>
<h5 id="指令选项"><a href="#指令选项" class="headerlink" title="指令选项"></a>指令选项</h5><dl><dt>有些命令接受以破折号开头的选项，例如 print -pretty,类似于命令名称,您可以使用缩写词GDB选项选项名的前几个字母,<br>如果这个缩写是明确的,您还可以使用TAB键让GDB填写剩下的一个字一个选项(或向你们展示可用的替代品,如果有一个以上的可能性)。<br>有时候加上缩写时，会混淆，如print -p是意思是 print -pretty还是打印的-p? ,所以这个时候可以用–</dt><dd>print –p </dd></dl><p>有些选项被描述为接受一个既可以是开的也可以是关的参数。这些被称为布尔选项。与布尔设置命令类似，on和off是典型的值，但是1、yes和enable中的任何一个也可以用作“true”值，<br>0、no和disable中的任何一个也可以用作“false”值。您也可以忽略“true”值，因为默认情况下它是隐含的。<br>例如，下面两个指令相同：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">(gdb) print -<span class="keyword">object</span> <span class="keyword">on</span> -pretty <span class="keyword">off</span> -element unlimited <span class="comment">-- *myptr</span></span><br><span class="line">(gdb) p -o -p <span class="number">0</span> -e u <span class="comment">-- *myptr</span></span><br><span class="line"></span><br><span class="line">当你不知道指令的可选项时：</span><br><span class="line">(gdb) print -TABTAB</span><br><span class="line">-address         -max-depth       -raw-<span class="keyword">values</span>      -<span class="keyword">union</span></span><br><span class="line">-<span class="keyword">array</span>           -<span class="keyword">null</span>-stop       -repeats         -vtbl</span><br><span class="line">-<span class="keyword">array</span>-indexes   -<span class="keyword">object</span>          -static-members</span><br><span class="line">-elements        -pretty          -symbol</span><br><span class="line"></span><br><span class="line">完成在某些情况下会给你一个选项期望的参数的建议。例如:</span><br><span class="line">(gdb) print -elements TABTAB</span><br><span class="line">NUMBER     unlimited</span><br></pre></td></tr></table></figure>

<h5 id="指令的帮助"><a href="#指令的帮助" class="headerlink" title="指令的帮助"></a>指令的帮助</h5><p>gdb) help<br>List of classes of commands:</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">aliases <span class="comment">-- User-defined aliases of other commands</span></span><br><span class="line">breakpoints <span class="comment">-- Making program stop at certain points</span></span><br><span class="line">data <span class="comment">-- Examining data</span></span><br><span class="line"><span class="built_in">files</span> <span class="comment">-- Specifying and examining files</span></span><br><span class="line">internals <span class="comment">-- Maintenance commands</span></span><br><span class="line">obscure <span class="comment">-- Obscure features</span></span><br><span class="line">running <span class="comment">-- Running the program</span></span><br><span class="line">stack <span class="comment">-- Examining the stack</span></span><br><span class="line">status <span class="comment">-- Status inquiries</span></span><br><span class="line">support <span class="comment">-- Support facilities</span></span><br><span class="line">tracepoints <span class="comment">-- Tracing of program execution without</span></span><br><span class="line">               stopping <span class="keyword">the</span> program</span><br><span class="line">user-defined <span class="comment">-- User-defined commands</span></span><br><span class="line"></span><br><span class="line">Type <span class="string">&quot;help&quot;</span> followed <span class="keyword">by</span> <span class="keyword">a</span> class name <span class="keyword">for</span> <span class="keyword">a</span> list <span class="keyword">of</span></span><br><span class="line">commands <span class="keyword">in</span> that class.</span><br><span class="line">Type <span class="string">&quot;help&quot;</span> followed <span class="keyword">by</span> <span class="keyword">command</span> <span class="title">name</span> <span class="title">for</span> <span class="title">full</span></span><br><span class="line">documentation.</span><br><span class="line">Command name abbreviations are allowed <span class="keyword">if</span> unambiguous.</span><br><span class="line">(gdb)</span><br><span class="line"></span><br><span class="line">使用一个通用帮助类作为参数，您可以获得该类中各个命令的列表。如果命令有别名，</span><br><span class="line">别名将在命令名之后，用逗号分隔。如果别名具有默认参数，则在第一行之后给出别名的完整定义。例如，下面是类状态的帮助显示:</span><br><span class="line">(gdb) help status</span><br><span class="line">Status inquiries.</span><br><span class="line"></span><br><span class="line">List <span class="keyword">of</span> commands:</span><br><span class="line"></span><br><span class="line">info, inf, i <span class="comment">-- Generic command for showing things</span></span><br><span class="line">        about <span class="keyword">the</span> program being debugged</span><br><span class="line">info address, iamain  <span class="comment">-- Describe where symbol SYM is stored.</span></span><br><span class="line">  <span class="built_in">alias</span> iamain = info address main</span><br><span class="line">info all-registers <span class="comment">-- List of all registers and their contents,</span></span><br><span class="line">        <span class="keyword">for</span> selected stack frame.</span><br><span class="line">...</span><br><span class="line">show, info <span class="built_in">set</span> <span class="comment">-- Generic command for showing things</span></span><br><span class="line">        about <span class="keyword">the</span> debugger</span><br><span class="line"></span><br><span class="line">Type <span class="string">&quot;help&quot;</span> followed <span class="keyword">by</span> <span class="keyword">command</span> <span class="title">name</span> <span class="title">for</span> <span class="title">full</span></span><br><span class="line">documentation.</span><br><span class="line">Command name abbreviations are allowed <span class="keyword">if</span> unambiguous.</span><br><span class="line">(gdb)</span><br><span class="line"></span><br><span class="line">还有指令的帮助：</span><br><span class="line">gdb) help <span class="keyword">command</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="用gdb运行程序"><a href="#用gdb运行程序" class="headerlink" title="用gdb运行程序"></a>用gdb运行程序</h4><h5 id="如何编译才能用gdb-g"><a href="#如何编译才能用gdb-g" class="headerlink" title="如何编译才能用gdb  -g"></a>如何编译才能用gdb  -g</h5><p>这样调试信息会存储在对象文件中，它描述了每个变量或函数的数据类型以及可执行代码中源行号和地址之间的对应关系。</p>
<p>使用’ -O ‘编译器选项，将发送给客户的程序进行了优化编译。然而，有些编译器无法同时处理’ -g ‘和’ -O ‘选项。使用这些编译器，<br>您无法生成包含调试信息的优化的可执行文件。</p>
<h5 id="如何通过gdb启动你的程序"><a href="#如何通过gdb启动你的程序" class="headerlink" title="如何通过gdb启动你的程序"></a>如何通过gdb启动你的程序</h5><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">gdb) <span class="keyword">run</span> / r</span><br><span class="line">几种指定可执行程序的方式：</span><br><span class="line">1） gdb <span class="keyword">program</span></span><br><span class="line">2)  gdb</span><br><span class="line">gdb) <span class="keyword">file</span> <span class="keyword">program</span></span><br></pre></td></tr></table></figure>
<p>如果您在支持进程的执行环境中运行程序，则run将创建一个较差的进程，并让该进程运行您的程序。<br>在某些没有进程的环境中，run跳转到程序的开头。其他目标，比如“remote”，总是在运行。如果你得到这样的错误消息:<br>The “remote” target does not support “run”.<br>Try “help target” or “continue”.</p>
<p>then use continue to run your program. You may need load first<br>运行的时候，一些预先的动作环境等，可能需要指定，如下，在接下来的几节会体现：</p>
<ol>
<li>The arguments.<br>如果shell是可用的，那可以通过shell传入，可以通过SHELL环境变量来指定使用哪种shell,如果不指定，gdb默认用&#x2F;bin&#x2F;sh ,<br>You can disable use of any shell with the set startup-with-shell command</li>
</ol>
<p>2)The environment.<br>you can use the GDB commands set environment and unset environment to change parts of the environment<br>3）The working directory.<br>You can set your program’s working directory with the command set cwd<br>4）The standard input and output.</p>
<p>gdb中程序的运行可以看上面介绍，对停止：一旦您的程序停止，您可以调用程序中的函数，使用打印或调用命令。(print&#x2F;call)</p>
<p>关于start命令：<br>‘ start ‘命令相当于在主过程(main)开始处设置一个临时断点，然后调用’ run ‘命令。</p>
<p>关于starti命令：<br>‘ starti ‘命令相当于在程序执行的第一个指令处设置一个临时断点，然后调用’ run ‘命令。对于包含精化阶段的程序，starti命令将在精化阶段开始时停止执行。<br>关于精细阶段，是指如c++一些全局变量会在main之前就执行了，所以为了细化断点，在全局变量初始化前停，需用starti</p>
<p>关于运行的控制：<br>还可以包裹在exec函数执行，还可以set startup-with-shell on&#x2F;off开启关闭shell执行，以及set exec-wrapper env ‘LD_PRELOAD&#x3D;libtest.so’<br>控制执行的环境，等等，更多见：<br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Starting.html#Starting">https://sourceware.org/gdb/current/onlinedocs/gdb/Starting.html#Starting</a></p>
<h5 id="你的程序的参数如何传入gdb中"><a href="#你的程序的参数如何传入gdb中" class="headerlink" title="你的程序的参数如何传入gdb中"></a>你的程序的参数如何传入gdb中</h5><p>程序的参数可以通过run命令的参数指定。它们被传递给shell, shell展开通配符并执行I&#x2F;O的重定向，从而指向您的程序。<br>您的SHELL环境变量(如果存在的话)指定了SHELL GDB使用什么。如果没有定义SHELL, GDB使用默认的SHELL (Unix上的&#x2F;bin&#x2F;sh)。</p>
<p>run 不带参数将使用与前一次运行相同的参数，或由set args命令设置的参数。<br>set args来设置：<br>gdb) set -p 192.3.2.1<br>指定下次运行程序时要使用的参数。如果set args没有参数，<br>run将不带参数执行程序。一旦你运行了带参数的程序，在下次运行之前使用set args是再次运行它而不带参数的唯一方法。</p>
<p>show args<br>用来显示设置的参数；</p>
<h5 id="你的程序的执行环境和gdb"><a href="#你的程序的执行环境和gdb" class="headerlink" title="你的程序的执行环境和gdb"></a>你的程序的执行环境和gdb</h5><p>环境由一组环境变量及其值组成。环境变量通常会记录诸如用户名、主目录、终端类型和要运行程序的搜索路径等内容。通常您使用shell设置环境变量，它们被您运行的所有其他程序所继承。<br>在调试时，尝试在修改过的环境中运行程序，而不必重新启动GDB，这可能很有用。<br>几个指令：<br>1）path directory eg: path &#x2F;bin&#x2F;sh<br>将directory添加到PATH环境变量(可执行文件的搜索路径)的前面，这个环境变量将被传递给您的程序。<br>2）show paths<br>3）show environment [varname]<br>4）set environment varname [&#x3D;value]<br>eg:set env USER &#x3D; foo<br>5) unset environment varname</p>
<h5 id="gdb下，你的程序的执行目录"><a href="#gdb下，你的程序的执行目录" class="headerlink" title="gdb下，你的程序的执行目录"></a>gdb下，你的程序的执行目录</h5><p>几个命令：</p>
<ol>
<li>set cwd [directory]<br>Set the inferior’s working directory to directory</li>
<li>show cwd</li>
</ol>
<p>3)cd [directory]<br>Set the GDB working directory to directory. If not given, directory uses ‘~’.<br>4) pwd<br>Print the GDB working directory.</p>
<h5 id="gdb下，你的程序的输入和输出"><a href="#gdb下，你的程序的输入和输出" class="headerlink" title="gdb下，你的程序的输入和输出"></a>gdb下，你的程序的输入和输出</h5><p>默认情况下，在GDB下运行的程序向GDB使用的同一个终端进行输入和输出。<br>GDB将终端切换到它自己的终端模式以与您交互，但它会记录您的程序正在使用的终端模式，并在您继续运行程序时切换回它们。</p>
<p>几个指令：<br>1）info terminal<br>Displays information recorded by GDB about the terminal modes your program is using.<br>2）重定向运行输出：<br>run &gt; outfile<br>3） tty &#x2F;dev&#x2F;ttyb 重定向tty<br>4) set inferior-tty [ tty ]<br>5) show inferior-tty</p>
<h5 id="如何用gdb-attach一个正在运行的程序"><a href="#如何用gdb-attach一个正在运行的程序" class="headerlink" title="如何用gdb attach一个正在运行的程序"></a>如何用gdb attach一个正在运行的程序</h5><p>指令：<br>gdb attach process-id<br>这个命令附加到一个正在运行的进程—一个在GDB外部启动的进程<br>detach<br>release gdb control</p>
<h5 id="gdb下如何杀死子进程"><a href="#gdb下如何杀死子进程" class="headerlink" title="gdb下如何杀死子进程"></a>gdb下如何杀死子进程</h5><p>gdb) kill<br>终止您的程序在GDB下运行的子进程。<br>如果希望调试核心转储core而不是正在运行的进程，则此命令很有用。当程序运行时，GDB会忽略任何核心转储文件core。</p>
<p>在某些操作系统上，如果在GDB内部设置了断点，则程序不能在GDB外部执行。在这种情况下，可以使用kill命令允许在调试器外部运行程序。<br>如果您希望重新编译和重新链接程序，kill命令也很有用，因为在许多系统上，当可执行文件在进程中运行时，是不可能修改它的。在这种情况下，当您下一次输入run时，GDB会注意到文件已经更改，并再次读取符号表(同时试图保留当前的断点设置)。</p>
<h5 id="调试多个下级连接和程序"><a href="#调试多个下级连接和程序" class="headerlink" title="调试多个下级连接和程序"></a>调试多个下级连接和程序</h5><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Inferiors-Connections-and-Programs.html#Inferiors-Connections-and-Programs">https://sourceware.org/gdb/current/onlinedocs/gdb/Inferiors-Connections-and-Programs.html#Inferiors-Connections-and-Programs</a></p>
<h5 id="调试多线程的程序"><a href="#调试多线程的程序" class="headerlink" title="调试多线程的程序"></a>调试多线程的程序</h5><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Threads.html#Threads">https://sourceware.org/gdb/current/onlinedocs/gdb/Threads.html#Threads</a></p>
<h5 id="调试forks"><a href="#调试forks" class="headerlink" title="调试forks"></a>调试forks</h5><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Forks.html#Forks">https://sourceware.org/gdb/current/onlinedocs/gdb/Forks.html#Forks</a></p>
<h5 id="设置书签以便之后返回；"><a href="#设置书签以便之后返回；" class="headerlink" title="设置书签以便之后返回；"></a>设置书签以便之后返回；</h5><p>checkpoint： 用于保存程序的快照，然后可以返回；<br>checkpoint是程序在那一刻的快照，当我们发现错过了某个调试机会时，可以再次回到checkpoint保存的那个程序状态。<br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Checkpoint_002fRestart.html#Checkpoint_002fRestart">https://sourceware.org/gdb/current/onlinedocs/gdb/Checkpoint_002fRestart.html#Checkpoint_002fRestart</a><br>eg:<a href="http://blog.chinaunix.net/uid-23629988-id-2943273.html">http://blog.chinaunix.net/uid-23629988-id-2943273.html</a></p>
<h4 id="停止和继续"><a href="#停止和继续" class="headerlink" title="停止和继续"></a>停止和继续</h4><h5 id="断点：监控点和catch-points"><a href="#断点：监控点和catch-points" class="headerlink" title="断点：监控点和catch points"></a>断点：监控点和catch points</h5><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Breakpoints.html#Breakpoints">https://sourceware.org/gdb/current/onlinedocs/gdb/Breakpoints.html#Breakpoints</a></p>
<ol>
<li>设置断点<br>2）设置观察点<br>3）设置捕获点：catchpoints<br>4）删除断点<br>5）禁用断点</li>
<li>断点加条件控制<br>7）动态打印<br>8）保存断点到文件<br>9）静态的probe point<br>10）error in breakpoints</li>
<li>Breakpoint-related Warnings:</li>
</ol>
<h5 id="continue和step指令"><a href="#continue和step指令" class="headerlink" title="continue和step指令"></a>continue和step指令</h5><h5 id="skip函数和文件"><a href="#skip函数和文件" class="headerlink" title="skip函数和文件"></a>skip函数和文件</h5><h5 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h5><h5 id="停止和启动多线程程序"><a href="#停止和启动多线程程序" class="headerlink" title="停止和启动多线程程序"></a>停止和启动多线程程序</h5><h4 id="回退运行"><a href="#回退运行" class="headerlink" title="回退运行"></a>回退运行</h4><h4 id="进程记录和重放"><a href="#进程记录和重放" class="headerlink" title="进程记录和重放"></a>进程记录和重放</h4><h4 id="测试栈"><a href="#测试栈" class="headerlink" title="测试栈"></a>测试栈</h4><h5 id="栈帧的概念"><a href="#栈帧的概念" class="headerlink" title="栈帧的概念"></a>栈帧的概念</h5><p>调用堆栈被分成若干连续的块，称为堆栈帧，或简称帧;每一帧是与一个函数调用相关联的数据。<br>框架包含给出给函数的参数、函数的局部变量和函数执行的地址。</p>
<p>当程序启动时，堆栈只有一个帧，即main函数的帧。这叫做初始坐标系或者最外层的坐标系。每次调用一个函数，就会产生一个新的框架。每次函数返回时，用于该函数调用的帧就会被消除。如果一个函数是递归的，那么同一个函数可以有多个框架。<br>执行实际发生的函数的框架称为最内层框架。这是所有仍然存在的堆栈帧中最近创建的。</p>
<p>在程序中，堆栈帧通过它们的地址来标识。堆栈帧由许多字节组成，每个字节都有自己的地址;每一种计算机都有一个约定，即选择一个字节的地址作为帧的地址。<br>通常这个地址被保存在一个叫做帧指针寄存器(参见$fp)的寄存器中，而在这个帧中执行。</p>
<p>GDB给每个现有的堆栈帧标上一个级别，最里面的帧为0，调用它的帧为1，以此类推。这些级别数字为您提供了一种在GDB命令中指定堆栈帧的方法。<br>术语帧数和帧级可以互换地用来描述这个数字。</p>
<p>有些编译器提供了一种方法来编译函数，使它们在不使用堆栈帧的情况下运行。(例如，GCC选项<br>“-fomit-frame-pointer”<br>生成没有框架的函数。)为了节省帧设置时间，我们偶尔会使用大量的库函数。GDB只有有限的工具来处理这些函数调用。如果最内层的函数调用没有堆栈帧，<br>GDB仍然认为它有一个单独的帧，它通常被编号为零，允许正确地跟踪函数调用链。然而，GDB没有在栈的其他地方提供无框架函数。</p>
<h5 id="backtraces调用链"><a href="#backtraces调用链" class="headerlink" title="backtraces调用链"></a>backtraces调用链</h5><p>回溯是程序如何到达当前位置的摘要。它显示了每帧一行，对于许多帧，从当前执行的帧(帧0)开始，接着是它的调用者(帧1)，一直到堆栈。</p>
<p>要打印整个堆栈的回溯信息，可以使用backtrace命令或它的别名bt。该命令将为堆栈中的每帧打印一行。<br>默认情况下，将打印所有堆栈帧。您可以在任何时候通过输入系统中断字符(通常是Ctrl-c)来停止回溯。</p>
<p>语法：<br>backtrace [option]… [qualifier]… [count]<br>bt [option]… [qualifier]… [count]<br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Backtrace.html#Backtrace">https://sourceware.org/gdb/current/onlinedocs/gdb/Backtrace.html#Backtrace</a></p>
<h5 id="选择一个栈帧："><a href="#选择一个栈帧：" class="headerlink" title="选择一个栈帧："></a>选择一个栈帧：</h5><p>大多数用于检查程序中堆栈和其他数据的命令都在此时选择的任何堆栈帧上工作。<br>下面是选择堆栈帧的命令;所有这些都通过打印刚刚选择的堆栈帧的简要描述来完成。</p>
<p>1）指令1：<br>语法：<br>frame [ frame-selection-spec ]<br>f [ frame-selection-spec ]<br>frame命令允许选择不同的堆栈帧。帧选择规范可以是以下任意一种:<br>num<br>level num<br>选择帧级别num，回想一下，帧0是最内层(当前正在执行)的帧，帧1是调用最内层的帧，以此类推。最高层次的框架通常是主框架。<br>由于这是在帧堆栈中导航最常用的方法，所以可以省略字符串级别。例如，下面两个命令是等价的:<br>(gdb) frame 3<br>(gdb) frame level 3</p>
<p>2）指令2：<br>address stack-address<br>选择堆栈地址为stack-address的帧。例如，一个帧的堆栈地址可以在信息帧的输出中看到<br>(gdb) info frame<br>Stack level 1, frame at 0x7fffffffda30:<br> rip &#x3D; 0x40066d in b (amd64-entry-value.cc:59); saved rip 0x4004c5<br> tail call frame, caller of frame at 0x7fffffffda30<br> source language c++.<br> Arglist at unknown address.<br> Locals at unknown address, Previous frame’s sp is 0x7fffffffda30</p>
<p>The stack-address for this frame is 0x7fffffffda30 as indicated by the line:<br>Stack level 1, frame at 0x7fffffffda30:</p>
<p>3)指令3：<br>function function-name<br>选择函数function-name的堆栈帧。如果function function-name有多个堆栈帧，则选择最内部的堆栈帧。</p>
<p>4)指令4：<br>view stack-address [ pc-addr ]<br>查看一个不属于GDB回溯的帧。被查看的帧有堆栈地址stack-addr，也可以选择pc-addr的程序计数器地址</p>
<p>5）指令5:<br>up n<br>向上移动n帧堆栈;N默认为1。对于正数n，它向最外层的帧移动，向更高的帧移动，向存在时间更长的帧移动。</p>
<p>6)指令6：<br>down n<br>向下移动n帧堆栈;N默认为1。对于正数n，它向最里面的帧推进，向更低的帧数推进，向最近创建的帧推进。<br>eg:<br>(gdb) up<br>#1  0x22f0 in main (argc&#x3D;1, argv&#x3D;0xf7fffbf4, env&#x3D;0xf7fffbfc)<br>    at env.c:10<br>10              read_input_file (argv[i]);</p>
<h5 id="栈帧的相关信息："><a href="#栈帧的相关信息：" class="headerlink" title="栈帧的相关信息："></a>栈帧的相关信息：</h5><p>有一些指令可以打印选定的栈帧的相关信息：</p>
<ol>
<li>frame&#x2F;f<br>当不带任何参数使用时，这个命令不会改变所选择的帧，而是打印当前所选择的堆栈帧的简要描述。它可以缩写为f。该命令用于选择一个堆栈帧，带参数。</li>
</ol>
<p>2)info frame<br>info f<br>该命令打印所选堆栈帧的详细描述，包括:<br>the address of the frame<br>the address of the next frame down (called by this frame)<br>the address of the next frame up (caller of this frame)<br>the language in which the source code corresponding to this frame is written<br>the address of the frame’s arguments<br>the address of the frame’s local variables<br>the program counter saved in it (the address of execution in the caller frame)<br>which registers were saved in the frame</p>
<ol start="3">
<li><p>info frame [ frame-selection-spec ]<br>info f [ frame-selection-spec ]<br>Print a verbose description of the frame selected by frame-selection-spec</p>
</li>
<li><p>info args [-q]<br>Print the arguments of the selected frame</p>
</li>
<li><p>info args [-q] [-t type_regexp] [regexp]</p>
</li>
</ol>
<p>6)info locals [-q]<br>Print the local variables of the selected frame, each on a separate line.<br>7)info locals [-q] [-t type_regexp] [regexp]</p>
<h5 id="Applying-a-Command-to-Several-Frames"><a href="#Applying-a-Command-to-Several-Frames" class="headerlink" title="Applying a Command to Several Frames."></a>Applying a Command to Several Frames.</h5><h5 id="Management-of-Frame-Filters"><a href="#Management-of-Frame-Filters" class="headerlink" title="Management of Frame Filters."></a>Management of Frame Filters.</h5><h4 id="测试源文件"><a href="#测试源文件" class="headerlink" title="测试源文件"></a>测试源文件</h4><h5 id="打印源行"><a href="#打印源行" class="headerlink" title="打印源行"></a>打印源行</h5><p>list 的各种用法：<br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/List.html#List">https://sourceware.org/gdb/current/onlinedocs/gdb/List.html#List</a></p>
<h5 id="具体化位置："><a href="#具体化位置：" class="headerlink" title="具体化位置："></a>具体化位置：</h5><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Specify-Location.html#Specify-Location">https://sourceware.org/gdb/current/onlinedocs/gdb/Specify-Location.html#Specify-Location</a></p>
<h5 id="编辑源文件以及选择编辑器"><a href="#编辑源文件以及选择编辑器" class="headerlink" title="编辑源文件以及选择编辑器"></a>编辑源文件以及选择编辑器</h5><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Edit.html#Edit">https://sourceware.org/gdb/current/onlinedocs/gdb/Edit.html#Edit</a></p>
<h5 id="查找源文件：如何利用正则查找"><a href="#查找源文件：如何利用正则查找" class="headerlink" title="查找源文件：如何利用正则查找"></a>查找源文件：如何利用正则查找</h5><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Search.html#Search">https://sourceware.org/gdb/current/onlinedocs/gdb/Search.html#Search</a></p>
<h5 id="具体化源目录"><a href="#具体化源目录" class="headerlink" title="具体化源目录"></a>具体化源目录</h5><p>可执行程序有时不记录源文件的目录，而只记录其名称。即使是这样，也可以在编译会话和调试会话之间移动目录。GDB有一个目录列表来搜索源文件;<br>这称为源路径。每次GDB想要一个源文件时，它会按照目录在列表中出现的顺序尝试列表中的所有目录，直到找到一个具有所需名称的文件。</p>
<p>例如，假设一个可执行文件引用&#x2F;usr&#x2F;src&#x2F;foo-1.0&#x2F;lib&#x2F;foo.c文件，没有记录编译目录，源路径是&#x2F;mnt&#x2F;cross。GDB将在以下位置查找源文件:<br>&#x2F;usr&#x2F;src&#x2F;foo-1.0&#x2F;lib&#x2F;foo.c<br>&#x2F;mnt&#x2F;cross&#x2F;usr&#x2F;src&#x2F;foo-1.0&#x2F;lib&#x2F;foo.c<br>&#x2F;mnt&#x2F;cross&#x2F;foo.c</p>
<p>如果源文件不在上述任何位置，则会打印一个错误。GDB不查找源文件名的部分，例如&#x2F;mnt&#x2F;cross&#x2F;src&#x2F;foo-1.0&#x2F;lib&#x2F;foo.c。同样，也不会搜索源路径的子目录:如果源路径是&#x2F;mnt&#x2F;cross，<br>并且二进制文件指向foo.c, GDB将无法在&#x2F;mnt&#x2F;cross&#x2F;usr&#x2F;src&#x2F;foo-1.0&#x2F;lib下找到它。</p>
<p>。。。<br>怎么设置目录呢？</p>
<h5 id="源和机器码"><a href="#源和机器码" class="headerlink" title="源和机器码"></a>源和机器码</h5><p>可以使用命令信息行将源行映射到程序地址(反之亦然)，命令disassemble将地址范围作为机器指令显示。可以使用命令集disassemble-next-line设置在停止执行时是否反汇编下一个源行。<br>当在GNU Emacs模式下运行时，info line命令会使箭头指向指定的行。此外，信息行以符号形式和十六进制形式打印地址。</p>
<h4 id="检查数据"><a href="#检查数据" class="headerlink" title="检查数据"></a>检查数据</h4><p>常规的检查数据是使用print指令，或者缩写为p,或者它的替代者 inspect. 它能求值和打印你的程序中表达式写入的值；它也能利用python来做格式化打印，如果你的gdb配置了正确的python;</p>
<p>print 举例：</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> [[option] --] <span class="built_in">expr</span> </span><br><span class="line"><span class="built_in">print</span> [[option] --] /f  <span class="built_in">expr</span></span><br><span class="line">    <span class="built_in">expr</span>是一个表达式(在语言中)。默认的，表达式打印值的格式取决于数据的类型；你也可以选择一个不同的格式，通过使用/f,</span><br><span class="line">    f是一个具体的格式：如</span><br><span class="line">    x:将该值的位视为整数，以16进制方式输出。</span><br><span class="line">    d:以带符号的十进制形式打印整数。</span><br><span class="line">    u:无符号十进制整数</span><br><span class="line">    o:打印为八进制整数。</span><br><span class="line">    t:以二进制形式打印整数。字母“t”代表“二”。11</span><br><span class="line">    a:以地址的形式打印，十六进制的绝对地址和从最近的前面符号的偏移量。你可以使用这种格式来发现未知地址的位置(在什么函数中):</span><br><span class="line">    (gdb) p/a 0x54320</span><br><span class="line">    <span class="variable">$3</span> = 0x54320 &lt;_initialize_vx+396&gt;</span><br><span class="line">    和指令：info symbol 0x54320 类似</span><br><span class="line">    c:将其视为整数并将其打印为字符常量。这将打印数值及其字符表示形式。对于7位ASCII范围以外的字符，字符表示将被八进制转义<span class="string">&#x27; \nnn &#x27;</span>替换。</span><br><span class="line">    如果没有这种格式，GDB将char、unsigned char和signed char数据显示为字符常量。向量的单字节成员显示为整数数据。</span><br><span class="line">    f:将值的位视为浮点数并使用典型的浮点语法打印。</span><br><span class="line">    s:如果可能，将其视为字符串。使用这种格式，指向单字节数据的指针显示为以空结束的字符串，单字节数据的数组显示为固定长度的字符串。其他值以其自然类型显示。</span><br><span class="line">      如果没有这种格式，GDB将char、unsigned char和signed char的指针和数组显示为字符串。向量的单字节成员显示为整数数组。</span><br><span class="line">    z:与<span class="string">&#x27; x &#x27;</span>格式一样，该值被视为整数并打印为十六进制，但打印前导零以将值填充到整数类型的大小。</span><br><span class="line">    r:使用<span class="string">&#x27; raw &#x27;</span>格式打印。默认情况下，GDB将使用基于python的漂亮打印机，如果有的话(请参阅漂亮打印)。这通常会导致值内容的更高级别显示。<span class="string">&#x27; r &#x27;</span>格式绕过了任何可能存在的Python漂亮打印机。</span><br><span class="line">    例如，要以十六进制方式打印程序计数器(请参阅寄存器)，输入</span><br><span class="line">     p/x <span class="variable">$pc</span></span><br><span class="line">    注意斜杠前不需要空格;这是因为GDB中的命令名不能包含斜杠。</span><br><span class="line">    若要以不同的格式重新打印值历史中的最后一个值，可以使用只带格式而不带表达式的<span class="built_in">print</span>命令。例如，<span class="string">&#x27; p/x &#x27;</span>以十六进制重新打印最后一个值。</span><br><span class="line"></span><br><span class="line">    [option]可以有哪些值？ <span class="built_in">print</span>命令支持很多options来允许覆盖由<span class="built_in">set</span> <span class="built_in">print</span>子命令设置的相关全局打印设置:</span><br></pre></td></tr></table></figure>
<h5 id="表达式："><a href="#表达式：" class="headerlink" title="表达式："></a>表达式：</h5><p>print和许多其他GDB命令接受一个表达式并计算它的值。您正在使用的编程语言定义的任何类型的常量、变量或操作符在GDB的表达式中都是有效的。这包括条件表达式、函数调用、强制转换和字符串常量。<br>它还包括预处理器宏，如果你编译你的程序包含这些信息;看到编译。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">-address [on|off]</span><br><span class="line"><span class="built_in">Set</span> printing of addresses. Related setting: <span class="built_in">set</span> <span class="built_in">print</span> address.</span><br><span class="line">   打印设置：</span><br><span class="line">   GDB提供了以下方法来控制数组、结构和符号的打印方式</span><br><span class="line">   <span class="built_in">set</span> <span class="built_in">print</span><span class="built_in"> address</span></span><br><span class="line"><span class="built_in"></span>   <span class="built_in">set</span> <span class="built_in">print</span><span class="built_in"> address </span>on 默认是开启的：</span><br><span class="line">    (gdb) f</span><br><span class="line">    #0  set_quotes (<span class="attribute">lq</span>=0x34c78 <span class="string">&quot;&lt;&lt;&quot;</span>, <span class="attribute">rq</span>=0x34c88 <span class="string">&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">        at input.c:530</span><br><span class="line">    530         <span class="keyword">if</span> (lquote != def_lquote)</span><br><span class="line">    <span class="built_in">set</span> <span class="built_in">print</span><span class="built_in"> address </span>off</span><br><span class="line">    <span class="keyword">Do</span> <span class="keyword">not</span> <span class="built_in">print</span> addresses when displaying their contents. <span class="keyword">For</span> example, this is the same stack frame displayed with <span class="built_in">set</span> <span class="built_in">print</span><span class="built_in"> address </span>off:</span><br><span class="line">    </span><br><span class="line">    (gdb) <span class="built_in">set</span> <span class="built_in">print</span> addr off</span><br><span class="line">    (gdb) f</span><br><span class="line">    #0  set_quotes (<span class="attribute">lq</span>=<span class="string">&quot;&lt;&lt;&quot;</span>, <span class="attribute">rq</span>=<span class="string">&quot;&gt;&gt;&quot;</span>) at input.c:530</span><br><span class="line">    530         <span class="keyword">if</span> (lquote != def_lquote)</span><br><span class="line"></span><br><span class="line">-array [on|off] 更漂亮的打印数组，默认关闭</span><br><span class="line">Pretty formatting of arrays. Related setting: <span class="built_in">set</span> <span class="built_in">print</span> array.</span><br><span class="line"></span><br><span class="line">-array-indexes [on|off] 设置数组索引是否打印，即在显示数组时打印每个元素的索引。，默认关闭</span><br><span class="line"><span class="built_in">Set</span> printing of array indexes. Related setting: <span class="built_in">set</span> <span class="built_in">print</span> array-indexes.</span><br><span class="line"></span><br><span class="line">-elements number-of-elements|unlimited 设置要打印的字符串字符或数组元素的限制。这个限制默认被设置为200</span><br><span class="line"><span class="built_in">Set</span> limit on string chars <span class="keyword">or</span> array elements <span class="keyword">to</span> print. The value unlimited causes there <span class="keyword">to</span> be <span class="literal">no</span> limit. Related setting: <span class="built_in">set</span> <span class="built_in">print</span> elements.</span><br><span class="line"></span><br><span class="line">-max-depth depth|unlimited  设置打印的结构化内容的最大深度，默认未知？</span><br><span class="line"><span class="built_in">Set</span> the threshold after which nested structures are replaced with ellipsis. Related setting: <span class="built_in">set</span> <span class="built_in">print</span> max-depth.</span><br><span class="line">举例：</span><br><span class="line"><span class="keyword">For</span> example, given this C code</span><br><span class="line"></span><br><span class="line">typedef struct s1 &#123; int a; &#125; s1;</span><br><span class="line">typedef struct s2 &#123; s1 b; &#125; s2;</span><br><span class="line">typedef struct s3 &#123; s2 c; &#125; s3;</span><br><span class="line">typedef struct s4 &#123; s3 d; &#125; s4;</span><br><span class="line"></span><br><span class="line">s4 var = &#123; &#123; &#123; &#123; 3 &#125; &#125; &#125; &#125;;</span><br><span class="line">The following table shows how different values of depth will effect how var is printed by GDB:</span><br><span class="line"></span><br><span class="line">depth setting	Result of ‘p var’</span><br><span class="line">unlimited	<span class="variable">$1</span> = &#123;d = &#123;c = &#123;b = &#123;a = 3&#125;&#125;&#125;&#125;</span><br><span class="line">0	<span class="variable">$1</span> = &#123;<span class="built_in">..</span>.&#125;</span><br><span class="line">1	<span class="variable">$1</span> = &#123;d = &#123;<span class="built_in">..</span>.&#125;&#125;</span><br><span class="line">2	<span class="variable">$1</span> = &#123;d = &#123;c = &#123;<span class="built_in">..</span>.&#125;&#125;&#125;</span><br><span class="line">3	<span class="variable">$1</span> = &#123;d = &#123;c = &#123;b = &#123;<span class="built_in">..</span>.&#125;&#125;&#125;&#125;</span><br><span class="line">4	<span class="variable">$1</span> = &#123;d = &#123;c = &#123;b = &#123;a = 3&#125;&#125;&#125;&#125;</span><br><span class="line"><span class="keyword">To</span> see the contents of structures that have been hidden the<span class="built_in"> user </span>can either increase the <span class="built_in">print</span> max-depth, <span class="keyword">or</span> they can <span class="built_in">print</span> the elements of the structure that are visible, <span class="keyword">for</span> example</span><br><span class="line"></span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="built_in">print</span> max-depth 2</span><br><span class="line">(gdb) p var</span><br><span class="line"><span class="variable">$1</span> = &#123;d = &#123;c = &#123;<span class="built_in">..</span>.&#125;&#125;&#125;</span><br><span class="line">(gdb) p var.d</span><br><span class="line"><span class="variable">$2</span> = &#123;c = &#123;b = &#123;<span class="built_in">..</span>.&#125;&#125;&#125;</span><br><span class="line">(gdb) p var.d.c</span><br><span class="line"><span class="variable">$3</span> = &#123;b = &#123;a = 3&#125;&#125;</span><br><span class="line"></span><br><span class="line">-null-stop [on|off]  将字符数组的打印设置为在第一个空字符处停止。</span><br><span class="line"><span class="built_in">Set</span> printing of char arrays <span class="keyword">to</span> stop at first <span class="literal">null</span> char</span><br><span class="line"></span><br><span class="line">-object [on|off] 设置是否打印虚函数表；</span><br><span class="line"><span class="built_in">Set</span> printing C++ virtual function tables.</span><br><span class="line"></span><br><span class="line">-pretty [on|off] 设置是否以比较好看的格式打印；</span><br><span class="line"><span class="built_in">Set</span> pretty formatting of structures.</span><br><span class="line"></span><br><span class="line">-raw-values [on|off] 设置是否以原始值打印，绕过好看的打印格式；</span><br><span class="line"><span class="built_in">Set</span> whether <span class="keyword">to</span> <span class="built_in">print</span> values <span class="keyword">in</span><span class="built_in"> raw </span>form, bypassing any pretty-printers <span class="keyword">for</span> that value</span><br><span class="line"></span><br><span class="line">-repeats number-of-repeats|unlimited</span><br><span class="line"><span class="built_in">Set</span> threshold <span class="keyword">for</span> repeated <span class="built_in">print</span> elements. unlimited causes all elements <span class="keyword">to</span> be individually printed. </span><br><span class="line"></span><br><span class="line">-static-members [on|off] 设置是否打印c++的静态成员；</span><br><span class="line"><span class="built_in">Set</span> printing C++ static members.</span><br><span class="line"></span><br><span class="line">-symbol [on|off] 打印指针时设置符号名打印；这个符号和地址关联，默认关闭；！！！这个挺好的，可以打开；</span><br><span class="line"><span class="built_in">Set</span> printing of symbol names when printing pointers</span><br><span class="line"></span><br><span class="line">-union [on|off]</span><br><span class="line"><span class="built_in">Set</span> printing of unions interior <span class="keyword">to</span> structures. </span><br><span class="line"></span><br><span class="line">-vtbl [on|off]</span><br><span class="line"><span class="built_in">Set</span> printing of C++ virtual function tables. </span><br><span class="line">因为print命令接受看起来像选项(包括缩写)的任意表达式，如果指定任何命令选项，则必须使用双破折号(——)来标记选项处理的结束。</span><br><span class="line">如果单纯的p 会打印之前的值；</span><br><span class="line">双破折号举例：注意空格：</span><br><span class="line">(gdb) <span class="built_in">print</span> -pretty -- *myptr</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  next = 0x0,</span><br><span class="line">  flags = &#123;</span><br><span class="line">    sweet = 1,</span><br><span class="line">    sour = 1</span><br><span class="line">  &#125;,</span><br><span class="line">  meat = 0x54 <span class="string">&quot;Pork&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> [option]</span><br><span class="line"><span class="built_in">print</span> [option] /f </span><br></pre></td></tr></table></figure>
<p>1)如果体系结构支持内存标记，如果打印的是指针或引用类型，print命令将显示指针&#x2F;内存标记不匹配。看到内存标签。<br>2)检查数据的一种更低级的方法是使用x命令。它检查内存中指定地址的数据，并以指定的格式打印。看到检查内存。<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html#Memory">https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html#Memory</a><br>3)如果您对类型信息或结构或类的字段如何声明感兴趣，请使用ptype exp命令而不是print命令。<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Symbols.html#Symbols">https://sourceware.org/gdb/current/onlinedocs/gdb/Symbols.html#Symbols</a><br>例如可以直接打印某个变量的类型结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(gdb) whatis <span class="keyword">var</span></span><br><span class="line"><span class="keyword">type</span> = complex_t</span><br><span class="line">(gdb) ptype <span class="keyword">var</span></span><br><span class="line"><span class="keyword">type</span> = <span class="keyword">struct</span> <span class="built_in">complex</span> &#123;</span><br><span class="line">    real_t <span class="built_in">real</span>;</span><br><span class="line">    double <span class="built_in">imag</span>;</span><br><span class="line">&#125;</span><br><span class="line">再通过这个进一步打印：</span><br><span class="line">(gdb) ptype /o <span class="keyword">struct</span> <span class="built_in">complex</span></span><br><span class="line"><span class="comment">/* offset      |    size */</span>  <span class="keyword">type</span> = <span class="keyword">struct</span> tyu &#123;</span><br><span class="line"><span class="comment">/*      0:31   |       4 */</span>    <span class="type">int</span> a1 : <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*      0:28   |       4 */</span>    <span class="type">int</span> a2 : <span class="number">3</span>;</span><br><span class="line"><span class="comment">/*      0: 5   |       4 */</span>    <span class="type">int</span> a3 : <span class="number">23</span>;</span><br><span class="line"><span class="comment">/*      3: 3   |       1 */</span>    signed char a4 : <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* XXX  3-bit hole       */</span></span><br><span class="line"><span class="comment">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="comment">/*      8      |       8 */</span>    int64_t a5;</span><br><span class="line"><span class="comment">/*     16: 0   |       4 */</span>    <span class="type">int</span> a6 : <span class="number">5</span>;</span><br><span class="line"><span class="comment">/*     16: 5   |       8 */</span>    int64_t a7 : <span class="number">3</span>;</span><br><span class="line"><span class="comment">/* XXX  7-byte padding   */</span></span><br></pre></td></tr></table></figure>
<p>或者可以用python的：我测试了下，效果不是很好，输入数字的时候卡住了；<br>(gdb) explore</p>
<h5 id="表达式：-1"><a href="#表达式：-1" class="headerlink" title="表达式："></a>表达式：</h5><p>print和许多其他GDB命令接受一个表达式并计算它的值。<br>您所使用的编程语言定义的任何类型的常量、变量或运算符在GDB的表达式中都是有效的。<br>这包括条件表达式、函数调用、强制类型转换和字符串常量。它还包括预处理器宏，如果你编译你的程序包括这个信息<br>(gdb) p 123-3<br>120<br>(gdb) p func()</p>
<p>GDB支持用户输入的表达式中的数组常量。语法是{element, element…}。例如，可以使用命令print{1, 2, 3}创建一个由三个整数组成的数组。<br>如果将数组传递给函数或将其赋值给程序变量，GDB会将数组复制到目标程序中错误定位的内存中。<br>除了编程语言中常见的操作符外，GDB还支持这些操作符:<br>＠<br>‘ @ ‘是一个二进制操作符，用于将部分内存作为数组处理。<br>：：<br>‘:: ‘允许你在定义变量的文件或函数中指定变量,类似作用域<br>{type} addr<br>指向存储在内存地址addr的类型为类型的对象。地址addr可以是值为整数或指针的任何表达式(但是在二进制操作符周围需要圆括号，就像在强制转换中一样)。<br>这种构造是允许的，无论什么类型的数据通常应该驻留在addr。</p>
<h5 id="模糊的表达式："><a href="#模糊的表达式：" class="headerlink" title="模糊的表达式："></a>模糊的表达式：</h5><p>有些表达式有时候是模糊的，比如在c&#x2F;c++中，一个函数名可能被定义几次在不同的上下文(作用域，命名空间或类等)。它们叫重载；其他语言也类似；<br>可以调整表达式来使其意义明确。例如，在c++中，你可以具体化函数的签名，如 break 中break function(type).第一个选项总是’ [0]cancel ‘，输入0 RET将终止当前命令。<br>如果使用表达式的命令允许选择多个选项，则菜单中的下一个选项是’ [1]all ‘，输入1 RET将选择所有可能的选项。</p>
<p>当检测到需要解决的歧义时，调试器能够为每种可能性显示一个有编号的选项菜单，然后使用提示符“&gt;”等待选择。<br>例如，下面的会话摘录显示了在重载符号String::after上设置断点的尝试。我们选择函数名的三种特定定义:<br>(gdb) b String::after<br>[0] cancel<br>[1] all<br>[2] file:String.cc; line number:867<br>[3] file:String.cc; line number:860<br>[4] file:String.cc; line number:875<br>[5] file:String.cc; line number:853<br>[6] file:String.cc; line number:846<br>[7] file:String.cc; line number:735</p>
<blockquote>
<p>2 4 6<br>Breakpoint 1 at 0xb26c: file String.cc, line 867.<br>Breakpoint 2 at 0xb344: file String.cc, line 875.<br>Breakpoint 3 at 0xafcc: file String.cc, line 846.<br>Multiple breakpoints were set.<br>Use the “delete” command to delete unwanted<br> breakpoints.<br>(gdb)<br>这里String可能是一个类或作用域，而after是一个函数；<br>set multiple-symbols mode<br>    此选项允许您在表达式不明确时调整调试器行为。缺省情况下，mode为all。如果使用表达式的命令允许多个选择，那么GDB会自动选择所有可能的选择。<br>    例如，使用二义性名称在函数上插入断点将导致在每个可能的匹配上插入一个断点。<br>    但是，如果必须做出唯一的选择，那么GDB将使用菜单来帮助您消除表达式的歧义。例如，打印重载函数的地址将导致使用菜单。</p>
</blockquote>
<pre><code>当mode设置为ask时，当检测到歧义时，调试器总是使用菜单。
最后，当mode设置为cancel时，调试器会报告一个由于歧义而导致的错误，命令会终止。
</code></pre>
<p>show multiple-symbols<br>    Show the current value of the multiple-symbols setting.</p>
<h5 id="程序的变量："><a href="#程序的变量：" class="headerlink" title="程序的变量："></a>程序的变量：</h5><p>最常用的表达式类型是程序中变量的名称。表达式中的变量在选定的堆栈帧中被理解(参见选择帧);它们必须是:<br>global (or file-static)<br>或<br>根据编程语言的作用域规则可见，从该框架的执行角度来看</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">eg:</span></span><br><span class="line">foo (a)</span><br><span class="line">     int a;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">bar </span>(a);</span><br><span class="line">  &#123;</span><br><span class="line">    int <span class="keyword">b </span>= test ();</span><br><span class="line">    <span class="keyword">bar </span>(<span class="keyword">b);</span></span><br><span class="line"><span class="keyword"></span>  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当程序在函数foo中执行时，您可以检查和使用变量a，但只有当程序在声明b的块中执行时，您才能使用或检查变量b。<br>当然，有一种例外，就是你可以打印或引用一个变量或函数，它的作用域是一个文件的范围，即使当前的执行点不在这个文件；<br>当然，可能出现不同文件或函数有相同的变量名或函数名，这个时候你需要用::符号，如下：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>::<span class="keyword">variable</span></span><br><span class="line">function::varibale</span><br><span class="line">Here <span class="comment">file or function is the name of the context for the static variable.</span> </span><br><span class="line">for <span class="comment">example, to print a global value of x defined in f2.c:</span></span><br><span class="line"></span><br><span class="line">(gdb) p <span class="comment">&#x27;f2.c&#x27;</span><span class="comment">::x</span></span><br><span class="line">::符号通常用于引用静态变量，因为通常通过选择适当的框架和使用变量的简单名称来消除函数中局部变量的使用的歧义。然而，你也可以使用这种表示法来引用包含选定帧的帧中的局部变量:</span><br><span class="line">void</span><br><span class="line">foo <span class="comment">(int a)</span></span><br><span class="line">&#123;</span><br><span class="line">  if <span class="comment">(a &lt; 10)</span></span><br><span class="line">    bar <span class="comment">(a)</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    process (a);    <span class="comment">/* Stop here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">bar (int a)</span><br><span class="line">&#123;</span><br><span class="line">  foo (a + <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">For</span> example, <span class="keyword">if</span> there is a breakpoint at the commented line, here is what you might see when the program stops after executing the call bar(<span class="number">0</span>):</span><br><span class="line"></span><br><span class="line">(gdb) p a</span><br><span class="line"><span class="meta"><span class="keyword">$1</span> = 10</span></span><br><span class="line">(gdb) p bar::a</span><br><span class="line"><span class="meta"><span class="keyword">$2</span> = 5</span></span><br><span class="line">(gdb) up <span class="number">2</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x080483d0</span> in foo (a=<span class="number">5</span>) at foobar.c:<span class="number">12</span></span><br><span class="line">(gdb) p a</span><br><span class="line"><span class="meta"><span class="keyword">$3</span> = 5</span></span><br><span class="line">(gdb) p bar::a</span><br><span class="line"><span class="meta"><span class="keyword">$4</span> = 0</span></span><br></pre></td></tr></table></figure>
<p>‘:: ‘的这些用法很少与c++中非常相似的相同表示法的用法发生冲突。当它们发生冲突时，c++的含义优先;但是，可以通过用单引号引用文件或函数名来覆盖这一点。<br>例如，假设程序在一个具有includefile字段的类的方法中停止，并且还有一个名为includefile的包含文件，该文件定义了一个变量，some_global.<br>(gdb) p includefile<br>$1 &#x3D; 23<br>(gdb) p includefile::some_global<br>A syntax error in expression, near &#96;’.<br>(gdb) p ‘includefile’::some_global<br>$2 &#x3D; 27<br>有时候并不能很顺利打印出来，比如：<br>编译器优化的另一个可能的效果是优化不存在的变量，或者将变量分配给寄存器(而不是内存地址)。<br>根据编译器使用的调试信息格式对这种情况的支持，GDB可能无法显示这些局部变量的值。如果发生这种情况，GDB将打印如下消息:No symbol “foo” in current context.<br>若出现这种情况，可以关闭编译优化，或者改变debug info format<br>如果你打印的类型是无法确认的，gdb会打印‘<incomplete type>’，或者做下类型强制转换：<br>(gdb) p var<br>  ‘var’ has unknown type; cast it to its declared type<br>  (gdb) p (float) var<br>  $1 &#x3D; 3.14</p>
<p>其他： @entry ？</p>
<h5 id="伪造数组"><a href="#伪造数组" class="headerlink" title="伪造数组"></a>伪造数组</h5><p>在内存中连续输出几个相同类型的对象通常是有用的;数组的一段，或大小动态确定的数组，在程序中只有指针。</p>
<p>你可以通过使用二元运算符’ @ ‘引用一个连续的内存范围作为一个伪造数组来实现。’ @ ‘的左操作数应该是所需数组的第一个元素，并且是一个单独的对象。<br>正确的操作数应该是数组所需的长度。结果是一个数组值，其元素都是左参数的类型。第一个元素实际上是左参数;第二个元素来自存储第一个元素的字节之后的内存字节，依此类推。<br>下面是一个例子：<br>int *array &#x3D; (int *) malloc (len * sizeof (int));<br>you can print the contents of array with</p>
<p>p *array@len</p>
<p>‘ @ ‘的左操作数必须驻留在内存中。以这种方式使用’ @ ‘生成的数组值在下标方面的行为与其他数组类似，并且在表达式中使用时被强制转换为指针。<br>伪造数组通常通过值历史(参见值历史)出现在表达式中，在输出一个值之后。</p>
<p>另一种创建伪造数组的方法是使用类型转换。这将重新解释一个值，就像它是一个数组。该值不需要在内存中:<br>(gdb) p&#x2F;x (short[2])0x12345678<br>$1 &#x3D; {0x1234, 0x5678}<br>为了方便起见，如果你将数组长度留出来(如’ (type[])value ‘)， GDB会计算大小来填充值(如’ sizeof(value)&#x2F;sizeof(type) ‘:<br>(gdb) p&#x2F;x (short[])0x12345678<br>$2 &#x3D; {0x1234, 0x5678}</p>
<p>有时，伪造数组的方式是不够的;在中等复杂的数据结构中，感兴趣的元素实际上可能不是邻接的—例如，如果您感兴趣的是数组中的指针值。在这种情况下，<br>一个有用的解决办法是在一个表达式中使用一个方便变量(请参阅便利变量)作为计数器，该表达式打印第一个感兴趣的值，然后通过RET重复该表达式。你感兴趣的是每个结构中字段fv的值。<br>set $i &#x3D; 0<br>p dtab[$i++]-&gt;fv<br>RET<br>RET<br>…</p>
<h5 id="输出的格式：进制"><a href="#输出的格式：进制" class="headerlink" title="输出的格式：进制"></a>输出的格式：进制</h5><p>见上”#### 检查数据”<br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Output-Formats.html#Output-Formats">https://sourceware.org/gdb/current/onlinedocs/gdb/Output-Formats.html#Output-Formats</a></p>
<h5 id="打印和检查内存"><a href="#打印和检查内存" class="headerlink" title="打印和检查内存"></a>打印和检查内存</h5><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//sourceware.org/gdb/current/onlinedocs/gdb/Memory.html#Memory</span></span><br><span class="line">你可以使用指令 x来检查内存，并以各种格式打印出来，独立于你的程序数据类型；</span><br><span class="line">语法：</span><br><span class="line">x/nfu addr</span><br><span class="line">x addr</span><br><span class="line">x来检查内存，并以各种格式打印出来，独立于你的程序数据类型；</span><br><span class="line">n f和u是所有的可选参数，用来具体化多少内存展示出来，和什么格式。 addr是一个表达式，给定起始内存地址。如果你是用默认的nfu,</span><br><span class="line">你不需要打<span class="string">&#x27;/&#x27;</span>.有几个命令为addr设置了方便的缺省值。</span><br><span class="line">n, the repeat count是一个十进制整数;默认值是<span class="number">1</span>。它指定显示多少内存(以单位u计数)。如果指定了一个负数，则从addr开始向后检查内存。</span><br><span class="line">f, the display <span class="keyword">format</span> 是是<span class="keyword">print</span> (<span class="string">&#x27; x &#x27;</span>， <span class="string">&#x27; d &#x27;</span>， <span class="string">&#x27; u &#x27;</span>， <span class="string">&#x27; o &#x27;</span>， <span class="string">&#x27; t &#x27;</span>， <span class="string">&#x27; a &#x27;</span>， <span class="string">&#x27; c &#x27;</span>， <span class="string">&#x27; f &#x27;</span>， <span class="string">&#x27; s &#x27;</span>)，</span><br><span class="line"> <span class="string">&#x27; i &#x27;</span>(用于机器指令)和<span class="string">&#x27; m &#x27;</span>(用于显示内存标签)使用的格式之一。初始值是<span class="string">&#x27; x &#x27;</span>(十六进制)。每次使用x或<span class="keyword">print</span>时，默认值都会改变。</span><br><span class="line"></span><br><span class="line">u,the <span class="keyword">unit</span> <span class="keyword">size</span></span><br><span class="line">即单位内存大小：</span><br><span class="line">b</span><br><span class="line">Bytes.</span><br><span class="line"></span><br><span class="line">h</span><br><span class="line">Halfwords (two bytes).</span><br><span class="line"></span><br><span class="line">w</span><br><span class="line">Words (four bytes). This is the initial <span class="keyword">default</span>.</span><br><span class="line"></span><br><span class="line">g</span><br><span class="line">Giant words (eight bytes).</span><br><span class="line"></span><br><span class="line">每次你用x指定一个单位大小，下一次你使用x时，这个大小就会成为默认的单位。对于<span class="string">&#x27; i &#x27;</span>格式，单位大小会被忽略，通常不会被写入。对于<span class="string">&#x27; s &#x27;</span>格式，除非明确给出，否则单位大小默认为<span class="string">&#x27; b &#x27;</span>。使用x /hs显示<span class="number">16</span>位字符串，</span><br><span class="line">使用x /ws显示<span class="number">32</span>位字符串。下一次使用x /s将再次显示<span class="number">8</span>位字符串。注意，结果取决于当前编译单元的编程语言。如果语言是C， <span class="string">&#x27; s &#x27;</span>修饰符将使用UTF<span class="number">-16</span>编码，而<span class="string">&#x27; w &#x27;</span>将使用UTF<span class="number">-32</span></span><br><span class="line"></span><br><span class="line">addr:starting display address</span><br><span class="line">addr是你想要GDB开始显示内存的地址。表达式不需要有指针值(尽管可以);它总是被解释为内存的一个字节的整数地址。</span><br><span class="line">例如，<span class="string">&#x27; x/3uh 0x54320 &#x27;</span>是一个显示内存的三个半字(h)的请求，格式化为无符号十进制整数(<span class="string">&#x27; u &#x27;</span>)，从地址<span class="number">0x54320</span>开始。<span class="string">&#x27; x/4xw $sp &#x27;</span>打印堆栈指针上方的内存的四个单词(<span class="string">&#x27; w &#x27;</span>)</span><br><span class="line">您还可以指定一个负重复计数来从给定地址反向检查内存。例如，<span class="string">&#x27; x/-3uh 0x54320 &#x27;</span>打印三个半字(h)在<span class="number">0x54314</span>、<span class="number">0x54328</span>和<span class="number">0x5431c</span>。</span><br><span class="line"></span><br><span class="line">当检查机器指令时，当前程序计数器上的指令用=&gt;标记显示。例如:</span><br><span class="line">(gdb) x/<span class="number">5</span>i $pc<span class="number">-6</span></span><br><span class="line">   <span class="number">0x804837f</span> &lt;main+<span class="number">11</span>&gt;: mov    %esp,%ebp</span><br><span class="line">   <span class="number">0x8048381</span> &lt;main+<span class="number">13</span>&gt;: push   %ecx</span><br><span class="line">   <span class="number">0x8048382</span> &lt;main+<span class="number">14</span>&gt;: sub    $0x4,%esp</span><br><span class="line">=&gt; <span class="number">0x8048385</span> &lt;main+<span class="number">17</span>&gt;: movl   $0x8048460,(%esp)</span><br><span class="line">   <span class="number">0x804838c</span> &lt;main+<span class="number">24</span>&gt;: call   <span class="number">0x80482d4</span> &lt;puts@plt&gt;</span><br></pre></td></tr></table></figure>

<h5 id="内存标签"><a href="#内存标签" class="headerlink" title="内存标签"></a>内存标签</h5><p>不太理解，和架构支持有关，暂时不管；</p>
<h5 id="自动显示"><a href="#自动显示" class="headerlink" title="自动显示"></a>自动显示</h5><p>当你发现你想频繁的打印一个表达式时，你可以添加它到自动打印，gdb会自动打印它每当你的程序stop时，每个添加进自动打印的表达式列表，都有个数字标识它。若要移除<br>需要指定对应的数字：<br>这个列表看起来是这样的：<br>2: foo &#x3D; 38<br>3: bar[5] &#x3D; (struct hack *) 0x3804<br>此显示显示项目编号、表达式和它们的当前值。与使用x或print手动显示请求一样，<br>您可以指定您喜欢的输出格式;事实上，display决定是使用print还是x，这取决于你的格式规范——如果你指定了’ i ‘或’ s ‘格式或单位大小，它会使用x;否则使用print。<br>display expr 添加表达式，display does not repeat if you press RET again after using it.<br>display&#x2F;fmt expr 上面的基础上指定格式<br>display&#x2F;fmt addr 打印内存；<br>例如，’ display&#x2F;i $pc ‘可能是有帮助的，可以在每次执行停止时看到将要执行的机器指令(‘ $pc ‘是程序计数器的通用名称;见寄存器)。<br>如何删除或暂停，使能<br>undisplay dnums…<br>delete display dnums…<br>disable display dnums…<br>enable display dnums…<br>display<br>显示列表中表达式的当前值，就像程序停止时所做的那样。<br>info display<br>打印先前设置为自动显示的表达式列表，每个表达式都带有项目编号，但不显示值。这包括被标记为禁用的表达式。它还包括一些表达式，这些表达式现在不会显示出来，因为它们引用了当前不可用的自动变量。</p>
<h5 id="打印设置"><a href="#打印设置" class="headerlink" title="打印设置"></a>打印设置</h5><p>见上print相关内容</p>
<h5 id="漂亮的打印："><a href="#漂亮的打印：" class="headerlink" title="漂亮的打印："></a>漂亮的打印：</h5><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Pretty-Printing.html#Pretty-Printing">https://sourceware.org/gdb/current/onlinedocs/gdb/Pretty-Printing.html#Pretty-Printing</a></p>
<h5 id="值的历史："><a href="#值的历史：" class="headerlink" title="值的历史："></a>值的历史：</h5><p>print命令打印的值保存在GDB的值历史中。这允许您在其他表达式中引用它们。值将一直保持，直到符号表被重新读取或丢弃(例如使用file或symbol-file命令)。<br>当符号表发生变化时，值的历史记录将被丢弃，因为值可能包含指向符号表中定义的类型的指针。</p>
<p>打印的值是给定的历史数字，您可以通过这些历史数字来引用它们。它们是从1开始的连续整数。Print通过在值之前打印’ $num &#x3D; ‘来显示分配给某个值的历史编号;这里num是历史号码。</p>
<p>要引用之前的任何值，请使用’ $ ‘后跟该值的历史编号。print标签的输出就是为了提醒您这一点。<br>只是$指的是历史上最近的值，而$$指的是在那之前的值。$$n表示倒数第n个值;$$2是$$之前的值，$$1等价于$$，$$0等价于$。<br>例如，假设您刚刚打印了一个指向结构的指针，并希望查看该结构的内容。<br>p *$<br>如果你有一个结构链，其中组件的下一个指向下一个，你可以用这个打印下一个的内容:p *$.next<br>您可以通过重复这个命令来打印链中的连续链接——只需输入RET即可完成此操作。</p>
<p>注意，历史记录的是值，而不是表达式。如果x的值是4，你输入以下命令:<br>Print x<br>set x&#x3D;5<br>那么即使x的值发生了变化，Print命令记录在值历史中的值仍然保持为4。<br>show values<br>打印值历史中的最后10个值及其项目编号。这就像’ p $$9 ‘重复了10次，除了显示的值没有改变历史。<br>show values n<br>以历史项目号n为中心打印10个历史值。<br>show values +<br>在上次打印的值之后打印10个历史值。如果没有更多可用的值，则show values +不产生任何显示。<br>按RET重复show value n的效果与’ show values + ‘完全相同。</p>
<h5 id="gdb的变量"><a href="#gdb的变量" class="headerlink" title="gdb的变量"></a>gdb的变量</h5><p>GDB提供了方便的变量，您可以在GDB中使用这些变量来保存一个值并在以后引用它。这些变量完全存在于GDB中;它们不是程序的一部分，设置方便变量对程序的进一步执行没有直接影响。<br>这就是为什么你可以自由地使用它们。</p>
<p>使用$为开头，不过要避免和内置的冲突：<br>set $foo &#x3D; *object_ptr<br>将object_ptr指向的对象中包含的值保存在$foo中。<br>第一次使用方便变量创建它，但它的值是空的，直到您分配一个新值。您可以在任何时候使用另一个赋值来更改该值。<br>gdb变量没有固定的类型。您可以为方便变量指定任何类型的值，包括结构和数组，即使该变量已经具有不同类型的值。方便变量在用作表达式时，具有其当前值的类型。</p>
<p>show convenience<br>打印到目前为止使用的便利变量列表及其值，以及便利函数列表。缩写展示conv。</p>
<p>使用方便变量的一种方法是作为递增的计数器或前进的指针。例如，从结构数组的连续元素中打印字段:<br>set $i &#x3D; 0<br>print bar[$i++]-&gt;contents<br>还有一些自动变量，类似makefile;<br>如： $_thread<br>当前线程的线程号。<br>更多见手册；<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Convenience-Vars.html#Convenience-Vars">https://sourceware.org/gdb/current/onlinedocs/gdb/Convenience-Vars.html#Convenience-Vars</a></p>
<h5 id="gdb除了提供方便变量，还提供了函数；"><a href="#gdb除了提供方便变量，还提供了函数；" class="headerlink" title="gdb除了提供方便变量，还提供了函数；"></a>gdb除了提供方便变量，还提供了函数；</h5><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Convenience-Funs.html#Convenience-Funs">https://sourceware.org/gdb/current/onlinedocs/gdb/Convenience-Funs.html#Convenience-Funs</a></p>
<h5 id="gdb中的寄存器使用"><a href="#gdb中的寄存器使用" class="headerlink" title="gdb中的寄存器使用"></a>gdb中的寄存器使用</h5><h5 id="gdb中内存区域的属性"><a href="#gdb中内存区域的属性" class="headerlink" title="gdb中内存区域的属性"></a>gdb中内存区域的属性</h5><h5 id="如何dump指定内存区域内容到文件，或反向，即文件中读取到内存；"><a href="#如何dump指定内存区域内容到文件，或反向，即文件中读取到内存；" class="headerlink" title="如何dump指定内存区域内容到文件，或反向，即文件中读取到内存；"></a>如何dump指定内存区域内容到文件，或反向，即文件中读取到内存；</h5><p>dump指令</p>
<h5 id="如何产生一份core文件："><a href="#如何产生一份core文件：" class="headerlink" title="如何产生一份core文件："></a>如何产生一份core文件：</h5><p>有时候需要一份程序执行的内存快照：<br>generate-core-file [file]<br>(gdb) gcore [file]</p>
<h5 id="通过find指令在指定内存中查找字符或其他值"><a href="#通过find指令在指定内存中查找字符或其他值" class="headerlink" title="通过find指令在指定内存中查找字符或其他值"></a>通过find指令在指定内存中查找字符或其他值</h5><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Searching-Memory.html#Searching-Memory">https://sourceware.org/gdb/current/onlinedocs/gdb/Searching-Memory.html#Searching-Memory</a></p>
<h4 id="调试优化后的代码-–"><a href="#调试优化后的代码-–" class="headerlink" title="调试优化后的代码  –"></a>调试优化后的代码  –</h4><h4 id="c预处理宏-–"><a href="#c预处理宏-–" class="headerlink" title="c预处理宏 –"></a>c预处理宏 –</h4><h4 id="追踪点，无干扰的调试"><a href="#追踪点，无干扰的调试" class="headerlink" title="追踪点，无干扰的调试"></a>追踪点，无干扰的调试</h4><p>在某些应用程序中，调试器中断程序执行的时间不够长，以至于开发人员无法了解有关程序行为的任何有用信息。<br>如果程序的正确性取决于它的实时行为，那么调试器引入的延迟可能会导致程序彻底改变其行为，甚至可能会失败，即使代码本身是正确的。能够在不中断的情况下观察程序的行为是很有用的。<br>在服务器或网络程序中的调试经常遇到；</p>
<p>使用GDB的跟踪和收集命令，您可以在程序中指定位置、调用跟踪点以及在到达这些跟踪点时计算的任意表达式。稍后，使用tfind命令，您可以检查程序到达跟踪点时那些表达式的值。<br>表达式还可以表示内存结构或数组中的对象，例如GDB应该记录哪些对象的值;当访问一个特定的跟踪点时，您可以检查那些对象，就像它们当时在内存中一样。<br>由于GDB不需要与您交互就可以记录这些值，所以它可以快速而不引人注目地记录这些值，希望不会干扰程序的行为。</p>
<p>使用这种方式，需要gdb以类似attach的方式，这里是用的remote方式：<br>举例一个进程：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">test</span>.c:编译后为<span class="keyword">test</span> gcc -g <span class="keyword">test</span>.c -o <span class="keyword">test</span> </span><br><span class="line">先启动进程：进程会进入等待：</span><br><span class="line">gdbserver attach进程：</span><br><span class="line">gdbserver --attach <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">1234</span> `pidof <span class="keyword">test</span>` /直接填进程号</span><br><span class="line">另一个窗口使用：</span><br><span class="line">gdb --<span class="keyword">command</span>=<span class="keyword">command</span> </span><br><span class="line"><span class="keyword">command</span>文件示例：</span><br><span class="line"><span class="keyword">file</span> <span class="keyword">test</span></span><br><span class="line"><span class="keyword">target</span> remote <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">1234</span></span><br><span class="line">trace <span class="keyword">test</span>.c:<span class="number">15</span></span><br><span class="line">actions</span><br><span class="line">collect vara </span><br><span class="line">end</span><br><span class="line">tstart</span><br><span class="line"><span class="keyword">break</span> <span class="keyword">test</span>.c:<span class="number">14</span></span><br><span class="line">bt</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">tstop</span><br><span class="line">tstatus</span><br><span class="line">tfind start</span><br><span class="line"><span class="keyword">while</span>($trace_frame != -<span class="number">1</span>)</span><br><span class="line">printf <span class="string">&quot;Frame %d : indx = %d\n&quot;</span>, $trace_frame, indx</span><br><span class="line">tfind</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/gdb/gdb/gdb_11.html">https://developer.apple.com/library/archive/documentation/DeveloperTools/gdb/gdb/gdb_11.html</a></p>
<h4 id="调试使用覆盖的程序-–暂时不用"><a href="#调试使用覆盖的程序-–暂时不用" class="headerlink" title="调试使用覆盖的程序 –暂时不用"></a>调试使用覆盖的程序 –暂时不用</h4><p>如果您的程序太大，无法完全装入目标系统的内存，有时可以使用覆盖来解决这个问题。GDB为调试使用覆盖的程序提供了一些支持。</p>
<h4 id="用在不同的语言上-–"><a href="#用在不同的语言上-–" class="headerlink" title="用在不同的语言上 –"></a>用在不同的语言上 –</h4><h4 id="测试符号表"><a href="#测试符号表" class="headerlink" title="测试符号表"></a>测试符号表</h4><p>支持打印变量，打印变量的类型，打印类中的成员和函数，打印变量所在地址等；<br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Symbols.html#Symbols">https://sourceware.org/gdb/current/onlinedocs/gdb/Symbols.html#Symbols</a></p>
<h4 id="修改可执行程序"><a href="#修改可执行程序" class="headerlink" title="修改可执行程序"></a>修改可执行程序</h4><p>一旦您认为在程序中发现了错误，您可能希望确定纠正明显的错误是否会导致在其余的运行中得到正确的结果。您可以通过实验找到答案，使用GDB特性更改程序的执行。<br>例如，您可以将新值存储到变量或内存位置，给您的程序一个信号，在不同的地址重新启动它，甚至从函数提前返回。</p>
<p>• Assignment:          Assignment to variables<br>• Jumping:          Continuing at a different address<br>• Signaling:          Giving your program a signal<br>• Returning:          Returning from a function<br>• Calling:          Calling your program’s functions<br>• Patching:          Patching your program<br>• Compiling and Injecting Code:          Compiling and injecting code in GDB</p>
<h4 id="gdb和相关文件"><a href="#gdb和相关文件" class="headerlink" title="gdb和相关文件"></a>gdb和相关文件</h4><p>GDB需要知道要调试的程序的文件名，这既是为了读取它的符号表，也是为了启动程序。要调试上一次运行的核心转储，还必须告诉GDB核心转储文件的名称。</p>
<p>• Files:          Commands to specify files<br>您可能需要指定可执行文件和核心转储文件的名称。通常的方法是在启动时使用GDB的启动命令的参数，或者在启动gdb后，再进行指定；<br>在GDB会话期间，偶尔需要更改到不同的文件。或者您可能在运行GDB时忘记指定要使用的文件。或者您正在通过gdbserver调试远程目标(请参阅使用gdbserver程序)。在这些情况下，指定新文件的GDB命令很有用。</p>
<p>file filename:<br>使用文件名作为要调试的程序。读它是为了它的符号和纯粹记忆的内容。它也是使用run命令时执行的程序。如果没有指定目录，并且在GDB工作目录中没有找到该文件，<br>那么GDB将使用环境变量PATH作为要搜索的目录列表，就像shell在寻找要运行的程序时所做的那样。您可以使用path命令为GDB和您的程序更改这个变量的值。</p>
<p>可以使用file命令将未链接的对象.o文件加载到GDB中。你将不能“运行”一个目标文件，但你可以反汇编函数和检查变量。此外，如果底层的BFD功能支持它，<br>您可以使用gdb -write使用这种技术来修补对象文件。<br>注意，在这种情况下，GDB既不能解释也不能修改重定位，因此分支和一些初始化的变量似乎会移到错误的位置。但是这个功能还是很方便的。</p>
<p>file<br>file with no argument makes GDB discard any information it has on both executable file and the symbol table.</p>
<p>exec-file [ filename ]<br>指定在文件名中找到要运行的程序(而不是符号表)。如果需要的话，GDB会搜索环境变量PATH来定位您的程序。省略文件名意味着丢弃可执行文件上的信息。</p>
<p>symbol-file [ filename [ -o offset ]]<br>从文件文件名读取符号表信息。必要时搜索PATH。使用file命令从同一个文件获取符号表和要运行的程序。<br>如果指定了可选的偏移量，它将被添加到符号文件中每个部分的起始地址中。如果程序在运行时被重新定位，例如启用了kASLR的Linux内核，这将非常有用。<br>…</p>
<p>core-file [filename]<br>core<br>指定要用作“内存内容”的核心转储文件的下落。传统上，核心文件只包含生成它们的进程的地址空间的一部分;GDB可以为其他部分访问可执行文件本身。<br>core-file with no argument specifies that no core file is to be used.<br>注意，当您的程序在GDB下实际运行时，核心文件将被忽略。因此，如果您一直在运行您的程序，而您希望调试核心文件，则必须杀死程序正在其中运行的子进程。为此，可以使用kill命令(参见杀死子进程)。</p>
<p>其他:<br>add-symbol-file filename [ -readnow | -readnever ] [ -o offset ] [ textaddress ] [ -s section address … ]<br>remove-symbol-file filename<br>remove-symbol-file -a address</p>
<p>info files<br>info target<br>两个都是打印当前的目标；</p>
<p>• File Caching:          Information about GDB’s file caching<br>为了加快文件加载速度，减少内存占用，GDB会重用用于跟踪打开文件的bfd对象。请参见二进制文件描述符库中的BFD。下面的命令允许缓存行为的可见性和控制。<br>maint info bfds<br>输出GDB已知的每个bfd对象的信息<br>maint set bfd-sharing<br>maint show bfd-sharing<br>控制是否可以共享bfd对象。当启用共享时，GDB将重用已经打开的bfd对象，而不是重新打开相同的文件。关闭共享不会导致已经共享的bfd对象被取消共享，<br>但所有未来打开的文件将创建一个新的bfd对象。同样，重新启用共享功能不会导致多个现有的bfd对象坍缩为一个共享的bfd对象。<br>set debug bfd-cache level<br>Turns on debugging of the bfd cache, setting the level to level.</p>
<p>show debug bfd-cache<br>Show the current debugging level of the bfd cache.<br>• Separate Debug Files:          Debugging information in separate files<br>GDB允许您将程序的调试信息放在与可执行文件本身分离的文件中，以一种允许GDB自动查找和加载调试信息的方式。<br>由于调试信息可能非常大——有时比可执行代码本身还要大——一些系统将可执行文件的调试信息分发到单独的文件中，用户只能在需要调试问题时安装这些文件。<br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Separate-Debug-Files.html#Separate-Debug-Files">https://sourceware.org/gdb/current/onlinedocs/gdb/Separate-Debug-Files.html#Separate-Debug-Files</a><br>• MiniDebugInfo:          Debugging information in a special section<br>一些系统提供预构建的可执行文件和具有特殊’的库。gnu_debugdata”部分。这个特性被称为MiniDebugInfo。这个部分保存一个lzma压缩的对象，用于为回溯提供额外的符号。</p>
<p>• Index Files:          Index files speed up GDB<br>当GDB发现一个符号文件时，它会扫描文件中的符号，以构造一个内部符号表。这使得大多数GDB操作能够快速工作—但要以早期的延迟为代价。对于大型程序，这种延迟可能相当长，因此GDB提供了一种构建索引的方法，这可以加快启动速度。</p>
<p>• Symbol Errors:          Errors reading symbol files<br>在读取符号文件时，GDB偶尔会遇到一些问题，比如它不能识别的符号类型，或者编译器输出中的已知错误。默认情况下，GDB不会通知您此类问题，<br>因为它们是相对常见的，主要是调试编译器的人感兴趣的问题。如果您对查看有关构造不良的符号表的信息感兴趣，您可以要求GDB对每种类型的问题只打印一条消息，<br>不管问题发生了多少次;或者您可以使用set compl命令请求GDB打印更多消息，以查看问题发生的次数<br>• Data Files:          GDB data files<br>GDB有时会读取辅助数据文件。这些文件保存在一个称为数据目录的目录中。<br>您可以设置数据目录的名称，并查看GDB当前使用的名称。</p>
<h4 id="具体化一个调试目标"><a href="#具体化一个调试目标" class="headerlink" title="具体化一个调试目标"></a>具体化一个调试目标</h4><p>目标是程序所占用的执行环境。通常，GDB运行在与程序相同的主机环境中;在这种情况下，当您使用file或core命令时，调试目标被指定为副作用。<br>当你需要更多的灵活性,在物理上独立的主机上运行GDB或控制一个独立的系统通过串口或实时系统在一个TCP &#x2F; IP连接可以使用目标命令来指定一个目标类型配置为GDB(见命令来管理目标)。</p>
<h4 id="调试远程程序"><a href="#调试远程程序" class="headerlink" title="调试远程程序"></a>调试远程程序</h4><h4 id="配置具体的信息-—-和体系结构相关，暂时不看"><a href="#配置具体的信息-—-和体系结构相关，暂时不看" class="headerlink" title="配置具体的信息 — 和体系结构相关，暂时不看"></a>配置具体的信息 — 和体系结构相关，暂时不看</h4><p>尽管几乎所有的GDB命令都可以用于所有本机和跨版本的调试器，但也有一些例外。本章描述仅在某些配置中可用的东西。<br>有三种主要的配置类型:本机配置，其中主机和目标是相同的;嵌入式操作系统配置，这对于几个不同的处理器体系结构通常是相同的;裸嵌入式处理器，它们彼此之间差别很大。</p>
<h4 id="控制gdb"><a href="#控制gdb" class="headerlink" title="控制gdb"></a>控制gdb</h4><h4 id="扩展GDB"><a href="#扩展GDB" class="headerlink" title="扩展GDB"></a>扩展GDB</h4><p>GDB提供了几种扩展机制。GDB还提供了在读取文件进行调试时自动加载扩展名的能力。这允许用户为正在调试的程序自动定制GDB。<br>为了方便使用扩展语言，GDB能够评估文件的内容。这样做时，GDB可以通过查看文件名扩展名来识别正在使用的扩展语言。带有无法识别的文件名扩展名的文件总是被视为GDB命令文件。</p>
<h4 id="命令解释器"><a href="#命令解释器" class="headerlink" title="命令解释器"></a>命令解释器</h4><h4 id="gdb用户界面接口-TUI"><a href="#gdb用户界面接口-TUI" class="headerlink" title="gdb用户界面接口 TUI"></a>gdb用户界面接口 TUI</h4><p>​TUI（TextUser Interface）为GDB调试的文本用户界面，可以方便地显示源代码、汇编和寄存器文本窗口，支持类似ide中的源码级单步调试；</p>
<h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>在TUI模式中，可以显示以下几个窗口：<br>命令窗口：用于 GDB调试时的命令输入和命令结果输出显示，与普通 GDB窗口无异。<br>源代码窗口：用于显示程序源代码，包括当前运行行、中断以中断标识等。<br>汇编窗口：显示当前程序的汇编代码。<br>寄存器窗口：显示处理器的寄存器内容，当寄存器内容发生改变时会高亮显示。<br>源代码窗口和汇编窗口会高亮显示程序运行位置并以’&gt;’符号标记。有两个特殊标记用于标识断点，第一个标记用于标识断点类型：<br>B<br>程序至少有一次运行到了该断点<br>b<br>程序没有运行到过该断点<br>H<br>程序至少有一次运行到了该硬件断点<br>h<br>程序没有运行到过该硬件断点<br>第二个标记用于标识断点使能与否:<br>+<br>断点使能 Breakpointis enabled.<br>-<br>断点被禁用 Breakpointis disabled.<br>当调试程序时，源代码窗口、汇编窗口和寄存器窗口的内容会自动更新。<br>在命令窗口上方有一行状态栏，显示效果如下图所示，主要显示内容有：目标，函数，进程，行号，pc指针等</p>
<h5 id="TUI快捷键："><a href="#TUI快捷键：" class="headerlink" title="TUI快捷键："></a>TUI快捷键：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">C<span class="operator">-</span>x C<span class="operator">-</span>a</span><br><span class="line">C<span class="operator">-</span>x a</span><br><span class="line">C<span class="operator">-</span>x A</span><br><span class="line">Enter <span class="keyword">or</span> leave the TUI mode.</span><br><span class="line">C<span class="operator">-</span>x <span class="number">1</span></span><br><span class="line">Use a TUI layout <span class="keyword">with</span> <span class="keyword">only</span> <span class="keyword">one</span> <span class="keyword">window</span></span><br><span class="line">C<span class="operator">-</span>x <span class="number">2</span></span><br><span class="line">Use a TUI layout <span class="keyword">with</span> <span class="keyword">at</span> least two windows. </span><br><span class="line">C<span class="operator">-</span>x o</span><br><span class="line">Change the active window. </span><br><span class="line">C<span class="operator">-</span>x s</span><br><span class="line">Switch <span class="keyword">in</span> <span class="keyword">and</span> <span class="keyword">out</span> <span class="keyword">of</span> the TUI SingleKey mode </span><br><span class="line">在TUI模式下： </span><br><span class="line">The following key bindings <span class="keyword">only</span> work <span class="keyword">in</span> the TUI mode:</span><br><span class="line"></span><br><span class="line">PgUp</span><br><span class="line"><span class="keyword">Scroll</span> the active <span class="keyword">window</span> <span class="keyword">one</span> page up.</span><br><span class="line"></span><br><span class="line">PgDn</span><br><span class="line"><span class="keyword">Scroll</span> the active <span class="keyword">window</span> <span class="keyword">one</span> page down.</span><br><span class="line"></span><br><span class="line">Up</span><br><span class="line"><span class="keyword">Scroll</span> the active <span class="keyword">window</span> <span class="keyword">one</span> line up.</span><br><span class="line"></span><br><span class="line">Down</span><br><span class="line"><span class="keyword">Scroll</span> the active <span class="keyword">window</span> <span class="keyword">one</span> line down.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Left</span></span><br><span class="line"><span class="keyword">Scroll</span> the active <span class="keyword">window</span> <span class="keyword">one</span> <span class="keyword">column</span> left.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Right</span></span><br><span class="line"><span class="keyword">Scroll</span> the active <span class="keyword">window</span> <span class="keyword">one</span> <span class="keyword">column</span> right.</span><br><span class="line"></span><br><span class="line">C<span class="operator">-</span>L</span><br><span class="line">Refresh the screen.</span><br><span class="line"></span><br><span class="line">##### tui 的single key模式</span><br><span class="line">tui也提供single key模式，这个模式一个字母绑定一个指令，type C<span class="operator">-</span>x s进入退出这个模式；</span><br><span class="line">c</span><br><span class="line">continue</span><br><span class="line"></span><br><span class="line">d</span><br><span class="line">down</span><br><span class="line"></span><br><span class="line">f</span><br><span class="line">finish</span><br><span class="line"></span><br><span class="line">n</span><br><span class="line">next</span><br><span class="line"></span><br><span class="line">o</span><br><span class="line">nexti. The shortcut letter ‘o’ stands <span class="keyword">for</span> “step <span class="keyword">Over</span>”.</span><br><span class="line"></span><br><span class="line">q</span><br><span class="line">exit the SingleKey mode.</span><br><span class="line"></span><br><span class="line">r</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">s</span><br><span class="line">step</span><br><span class="line"></span><br><span class="line">i</span><br><span class="line">stepi. The shortcut letter ‘i’ stands <span class="keyword">for</span> “step <span class="keyword">Into</span>”.</span><br><span class="line"></span><br><span class="line">u</span><br><span class="line">up</span><br><span class="line"></span><br><span class="line">v</span><br><span class="line">info locals</span><br><span class="line"></span><br><span class="line">w</span><br><span class="line"><span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<h5 id="tui鼠标支持："><a href="#tui鼠标支持：" class="headerlink" title="tui鼠标支持："></a>tui鼠标支持：</h5><p>If the curses library supports the mouse, the TUI supports mouse actions.</p>
<p>The mouse wheel scrolls the appropriate window under the mouse cursor.</p>
<p>The TUI itself does not directly support copying&#x2F;pasting with the mouse. However, on Unix terminals, you can typically press and<br> hold the SHIFT key on your keyboard to temporarily bypass GDB’s TUI and access the terminal’s native mouse copy&#x2F;paste functionality<br> (commonly, click-drag-release or double-click to select text, middle-click to paste).<br>This copy&#x2F;paste works with the terminal’s selection buffer, as opposed to the TUI’s buffer.</p>
<h5 id="tui的具体指令："><a href="#tui的具体指令：" class="headerlink" title="tui的具体指令："></a>tui的具体指令：</h5><p>(gdb)tui enable<br>…<br><a href="https://sourceware.org/gdb/onlinedocs/gdb/TUI-Commands.html#TUI-Commands">https://sourceware.org/gdb/onlinedocs/gdb/TUI-Commands.html#TUI-Commands</a></p>
<h5 id="tui的可变配置："><a href="#tui的可变配置：" class="headerlink" title="tui的可变配置："></a>tui的可变配置：</h5><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/TUI-Configuration.html#TUI-Configuration">https://sourceware.org/gdb/onlinedocs/gdb/TUI-Configuration.html#TUI-Configuration</a></p>
<h4 id="GDB-x2F-MI-接口-–"><a href="#GDB-x2F-MI-接口-–" class="headerlink" title="GDB&#x2F;MI 接口 –"></a>GDB&#x2F;MI 接口 –</h4><p>GDB&#x2F;MI是一个基于行的面向GDB的机器文本接口，通过指定使用——interpreter命令行选项来激活(参见模式选项)。它专门用于支持将调试器作为更大系统的一个小组件使用的系统的开发。</p>
<h4 id="gdb注释-–"><a href="#gdb注释-–" class="headerlink" title="gdb注释  –"></a>gdb注释  –</h4><p>本章描述GDB中的注释。注解的设计目的是将GDB与图形用户界面或其他希望在相对较高的层次上与GDB交互的类似程序连接起来。注释机制在很大程度上已经被GDB&#x2F;MI所取代</p>
<h4 id="JIT编译接口-–"><a href="#JIT编译接口-–" class="headerlink" title="JIT编译接口  –"></a>JIT编译接口  –</h4><p>本章描述了GDB的JIT (just-in-time)编译接口。JIT编译器是在运行时生成本机可执行代码并执行它的程序或库，通常是为了在保持平台独立性的同时获得良好的性能。–java?</p>
<h4 id="进程代理"><a href="#进程代理" class="headerlink" title="进程代理"></a>进程代理</h4><p>传统的调试模型在概念上是低速的，但工作得很好，因为大多数错误都可以在调试模式执行中复制。然而，随着多核或多核处理器成为主流，多线程程序越来越流行，<br>应该会有越来越多的错误只在正常模式执行时出现，例如线程竞争，因为调试器对程序时间的干扰可能会隐藏这些错误。另一方面，在某些应用程序中，调试器中断程序执行的时间不够长，<br>以至于开发人员无法了解到有关程序行为的任何有用信息，<br>这是不可行的。如果程序的正确性取决于它的实时行为，那么调试器引入的延迟可能会导致程序失败，即使代码本身是正确的。能够在不中断的情况下观察程序的行为是很有用的。</p>
<p>因此，传统的调试模型干扰太大，无法重现一些bug。为了减少对程序的干扰，我们可以减少调试器执行的操作次数。进程内代理(In-Process Agent)是一个共享库，它运行在同一个进程中，<br>并且可以自己执行一些调试操作。因此，只在必要时使用调试器，从而提高调试性能。请注意，可以减少对程序的干扰，但不能完全消除，因为进程内代理仍然会停止或减慢程序。</p>
<p>进程内代理可以在执行调试操作时解释并执行agent表达式(参见agent表达式)。代理表达式可以用于不同的目的，例如在跟踪点中收集数据，以及在断点中计算条件。</p>
<p>可以使用以下命令控制进程内代理是否用于辅助调试:<br>set agent on<br>设置代理<br>使进程内代理代表调试器执行某些操作。用户所请求的操作将由进程内代理执行，这取决于它的能力。<br>例如，如果您请求在进程内代理中评估断点条件，并且进程内代理也具有这样的功能，那么将在进程内代理中评估断点条件。</p>
<p>set agent off<br>Disables execution of debugging operations by the in-process agent. All of the operations will be performed by GDB.</p>
<p>show agent<br>Display the current setting of execution of debugging operations by the in-process agent.</p>
<h4 id="交互式使用历史记录"><a href="#交互式使用历史记录" class="headerlink" title="交互式使用历史记录"></a>交互式使用历史记录</h4><h4 id="命令行交互指令"><a href="#命令行交互指令" class="headerlink" title="命令行交互指令"></a>命令行交互指令</h4><h4 id="如何保存历史指令和加载历史指令；"><a href="#如何保存历史指令和加载历史指令；" class="headerlink" title="如何保存历史指令和加载历史指令；"></a>如何保存历史指令和加载历史指令；</h4><p>常规的如果在一个session中，通过上下箭头键可以找到历史指令，但是退出就没了，如何使用上个session的指令？<br>echo ‘set history save on’ &gt;&gt; ~&#x2F;.gdbinit &amp;&amp; chmod 600 ~&#x2F;.gdbinit<br>set history size 1000<br>set history remove-duplicates <count> &#x2F;&#x2F;删除重复指令；<br>set history filename ~&#x2F;.gdb_history<br>这样就可以了；</p>
]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
</search>
