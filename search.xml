<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tcpip_mtu]]></title>
    <url>%2F2018%2F05%2F20%2Ftcpip-mtu%2F</url>
    <content type="text"><![CDATA[MTU这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍： 理论部分：１、MTU(Maximum Transmission Unit)如何定义: 指的是通信协议中的某一层上面所能通过的最大数据包大小 这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？ 答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B&gt;1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:分片：ip净载荷：MTU-IP头：1500-20=1480; 3008B 需要分为3片，3008=1480,1480,48总结：MTU就是MAC承载的载荷的最大值 2、MTU会影响什么: 数据包太大-&gt;分片重组-&gt;网络性能变差 数据包太小-&gt;一次能传输的数据小-&gt;网速差 路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191) 3、如何知道这个值呢？路径最大传输单元发现方法(RFC1191) 越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。 MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：ping -c 3 -s 1474 -M do 192.168.0.1PING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.ping: local error: Message too long, mtu=1500提示错误即消息太大且未设置分片 4 MTU大小的来源:ref https://www.zhihu.com/question/31460305/answer/183766816以太网传输帧的最小值： 最早的以太网工作方式：载波多路复用/冲突检测（CSMA/D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。 假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。 为什么标准以太网帧长度上限为1518字节? IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。 由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 byte那有效传输效率= 160 / 218 = 73%而如果以太网长度为1518，那有效传输效率= 1460 / 1518 = 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题. 于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。 其他疑问： 最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？ 这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到&gt; 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。 有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度&gt;接口MTU，怎么办？丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。 所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？ 我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU = MRU，但比如9000侧的数据到达1500，由于9000 &gt; MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样实践部分：如何设置MTU：ifconfig eth0 mtu 1460如何查看mtu:netstat -i]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[cpp_debug_layout_static]]></title>
    <url>%2F2018%2F05%2F20%2Fcpp-debug-layout-static%2F</url>
    <content type="text"><![CDATA[c compile time memory layout 标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法： 概述：首先介绍几个概念： 程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候； 当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程； 注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码 。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句； 本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c 前言：一个源代码通过编译后生成一个目标文件.o它是一个elf relocatable文件,以下.o文件指此类，elf文件为executable文件.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到 other data ... .comment offset 0x000000c6. .rodata ... //const &amp; str 常量 .data .text .elf header 一个elf文件的结构是这样的：可以通过readelf来看： elfheader 文件头包含了平台信息：/usr/include/elf.h .text 段表 各个段：应用程序也可以自己定义段，和指定变量在哪个段 .data .bss .. other sections section header table string tables 重定位表和字符串表 symbol tables 符号表是链接的接口 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂 可以通过readelf -s xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突 强符号和弱符号（强引用和若引用），调试信息 －g 扩展： １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀； 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o objdump -ht image.o 可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们 具体看文档２）自定义段：attribute((section(“FOO”))) int global=24; attribute((section(“BAR”))) void foo(){} 既可以把变量或函数放入该段中 段名：BAR FOO 正文： 0、先从几个命令：1)size filename:查看elf或.o文件中各个段大小： text data bss dec hex filename 74 0 0 74 4a simplest.o 代码段 数据段 代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null 2)其他工具： readelf -a simplest.o 可以看到更清楚的段信息 objdump -t simplest objdump -h simplest.o 替代size可以看到更多信息 此时显示出来的一些地址并不是装载后的地址 objdump -s -d xx.o: -s 16进制，-d反汇编 －－－查看代码段objdump -s -x -d xx.o: –查看数据段和rodata 3)查看目标文件文件属性如relocatable –.o/executable –elf/share object –.so.. file xxx １、从最简单的程序开始：simplest.cint main() { return 0; } 将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件： # 1 &quot;simplest.c&quot; # 1 &quot;&lt;built-in&gt;&quot; # 1 &quot;&lt;command-line&gt;&quot; # 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4 # 1 &quot;&lt;command-line&gt;&quot; 2 # 1 &quot;simplest.c&quot; int main() { return 0; } 将它进行汇编：gcc -S simplest.c .file “simplest.c” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits 生成.o文件：gcc -c simplest.c并通过file xx.o查看类型simplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped 通过size 查看各个段：size simplest.o: 可以看到只有代码段，数据为空，bss为空，是比较纯净的 text data bss dec hex filename 67 0 0 67 43 simplest.o 接着编译成elf:gcc -o simplest simplest.cfile simplestsimplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped可以看到连接器等信息 size simplest text data bss dec hex filename 1099 544 8 1651 673 simplest注意这里的和.o的文件大小和分段不同， ２、加入头文件和局部变量#include&lt;stdio.h&gt; int main() { int locala; int localb=3; return 0; } 进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数汇编，可以看到分配３到内存中 .file “simplest.c” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits 生成.o文件：可以看到未改变data和bss,但是代码段变大 text data bss dec hex filename 74 0 0 74 4a simplest.o 生成elf:数据区和bss未改变，代码段也未改变？ text data bss dec hex filename 1099 544 8 1651 673 simplest ３、加入已经初始化的局部静态变量：int main() { static int statica=3; .. } 看生成的汇编： .file “simplest.c” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .data .align 4 .type statica.2285, @object //新加的段 .size statica.2285, 4 statica.2285: .long 3 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits .o大小：在静态数据区增加了，４ １个int的长度 text data bss dec hex filename 74 4 0 78 4e simplest.o elf:有点费解，。。 text data bss dec hex filename 1099 548 4 1651 673 simplest ４、加入已经初始化的全局变量和全局静态变量int golbala=6; static long gs=12; 生成的汇编 .file “simplest.c” .globl golbala .data .align 4 .type golbala, @object .size golbala, 4 golbala://变量名 .long 6 .align 8 .type gs, @object .size gs, 8 gs://变量名 .quad 12 .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .data .align 4 .type statica.2287, @object .size statica.2287, 4 statica.2287: .long 3 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits size : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4=20 text data bss dec hex filename 74 20 0 94 5e simplest.o elf size:548–&gt;564 16 text data bss dec hex filename 1099 564 4 1667 683 simplest 5 将 int golbala=6; static long gs=12; 倒换位置！！！！！！！！！ 则对齐成：size x.o为：１６比原来小，可以用于节省内存： text data bss dec hex filename 74 16 0 90 5a simplest.o 汇编： .file “simplest.c” .data .align 8 .type gs, @object .size gs, 8gs: .quad 12 .globl golbala .align 4 .type golbala, @object .size golbala, 4golbala: .long 6 .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE0: .size main, .-main .data .align 4 .type statica.2287, @object .size statica.2287, 4statica.2287: .long 3 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbitself文件的也变小：但bss变大，费解。。 text data bss dec hex filename 1099 560 8 1667 683 simplest 6、加入未初始化的全局变量和全局与局部静态变量 1 #include&lt;stdio.h&gt; 2 static long gs=12; 3 int golbala=6; 4 5 6 static long gsl; 7 int gi; 8 int main() 9 { 10 static int staticn; 11 static int statica=3; 12 int locala; 13 int localb=3; 14 return 0; 15 } 汇编没有看到什么变化： .file “simplest.c” .data .align 8 .type gs, @object .size gs, 8gs: .quad 12 .globl golbala .align 4 .type golbala, @object .size golbala, 4golbala: .long 6 .local gsl .comm gsl,8,8 .comm gi,4,4 .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE0: .size main, .-main .data .align 4 .type statica.2290, @object .size statica.2290, 4statica.2290: .long 3 .local staticn.2289 .comm staticn.2289,4,4 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits .o文件：+12 未包含未初始化的全局变量text data bss dec hex filename 74 16 12 102 66 simplest.o elf:+16 未包含未初始化的全局变量text data bss dec hex filename 1099 560 24 1683 693 simplest 至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同 参考：程序员的自我修养]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_debug_layout_dynamic]]></title>
    <url>%2F2018%2F05%2F20%2Fcpp-debug-layout-dynamic%2F</url>
    <content type="text"><![CDATA[c执行期内存布局和调试：在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等１、将目标文件装入: １）重定位－－－ 放在内存哪里 2) 等待调度执行这里可以使用gdb进行调试查看 一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).一个进程主要包括： 在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等 栈区 高地址到低地址堆区 低地址到高地址bss数据代码 以下将从两个维度进行对一个程序被执行成进程时，内存的情况： １、各种段区的内存分布 ２、gdb 调试程序执行时的过程。－－可能涉及到汇编 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 1、gdb 常用的命令和用法：1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令 2)设置断点： b 行号b 函数名b 行号 if 条件eg:break main / b main 删除断点:delete 行号 3)列出代码l /list 4)运行，start 跳转到断点:c/continue r/run until 行号 运行直到该行5)观察变量b和地址watch b 若变量值发生变化，则程序停止 p/print b 看变量值 p/print &amp;b 看变量地址 i locals info registers 显示所有寄存器的值 查看特定内存位置的值如： print/x $eax 显示为16进制 print/t 2进制， print/d 十进制,x/nyz : n表示字段数，y为输出格式，z是字段长度 ６）单步调试 n/next / s/step 7) 保存断点： info b 查看断点信息 save breakpoint fig.dp 保存断点 读取断点文件： gdb hello -x fig.dp 退出quit http://bbs.chinaunix.net/thread-150524-1-1.html 2 使用kdbg 界面版本gdb 在gcc … -g后，用kdbg打开即可、 查看程序运行时各个地址： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;sys/types.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#define SHW_ADR(ID,I) printf("the id %s \t is at adr:%8X\n",ID,&amp;I);extern etext,edata,end;char *cptr="Hello World\n";char buffer1[25];int main(void)&#123; void showit(char *); int i=0; printf("Adr etext:%8x\tAdr edata:%8x \t Adr end :%8x \n\n",&amp;etext,&amp;edata,&amp;end); SHW_ADR("main",main); SHW_ADR("showit",showit); SHW_ADR("cptr",cptr); SHW_ADR("buffer1",buffer1); SHW_ADR("i",i); strcpy(buffer1,"A demonstration\n"); write(1,buffer1,strlen(buffer1)+1); for(;i&lt;1;++i) showit(cptr); return 0;&#125;void showit(char *p)&#123; char *buffer2; SHW_ADR("buffer2",buffer2); if((buffer2=(char *)malloc((unsigned)(strlen(p)+1)))!=NULL) &#123; strcpy(buffer2,p); printf("%s",buffer2); free(buffer2); &#125; else &#123; printf("Allocation error.\n"); exit(1); &#125;&#125; －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;unistd.h&gt;#include &lt;alloca.h&gt;extern void afunc(void);extern etext,edata,end;int bss_var; //no init globel data must be in bssint data_var=42; //init globel data must be in data#define SHW_ADR(ID,I) printf("the %8s\t is at adr:%8x\n",ID,&amp;I); //the macro to printf the addrint main(int argc,char *argv[])&#123; char *p,*b,*nb; printf("Adr etext:%8x\t Adr edata %8x\t Adr end %8x\t\n",&amp;etext,&amp;edata,&amp;end); printf("\ntext Location:\n"); SHW_ADR("main",main); //text section function SHW_ADR("afunc",afunc); //text section function printf("\nbss Location:\n"); SHW_ADR("bss_var",bss_var); //bss section var printf("\ndata location:\n"); SHW_ADR("data_var",data_var); //data section var printf("\nStack Locations:\n"); afunc(); p=(char *)alloca(32); //alloc memory from statck if(p!=NULL) &#123; SHW_ADR("start",p); SHW_ADR("end",p+31); &#125; b=(char *)malloc(32*sizeof(char)); //malloc memory from heap nb=(char *)malloc(16*sizeof(char)); printf("\nHeap Locations:\n"); printf("the Heap start: %p\n",b); printf("the Heap end:%p\n",(nb+16*sizeof(char))); printf("\nb and nb in Stack\n"); SHW_ADR("b",b); SHW_ADR("nb",nb); free(b); free(nb);&#125;void afunc(void)&#123; static int long level=0; //data section static var int stack_var; //temp var ,in stack section if(++level==5) &#123; return; &#125; SHW_ADR("stack_var in stack section",stack_var); SHW_ADR("Level in data section",level); afunc();&#125;]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_jni]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-jni%2F</url>
    <content type="text"><![CDATA[a example of JNI static way:first step: write a middle java file:mkdir jnicd jni/vim TestJni.java import java.util.*; public class TestJni { public native void xprint(String content); static { System.loadLibrary(&quot;TestJni&quot;); } } javac TestJni.java and make a class then javah -jni TestJni to make a .h file: /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class TestJni */ #ifndef _Included_TestJni #define _Included_TestJni #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: TestJni * Method: xprint * Signature: (Ljava/lang/String;)V */ JNIEXPORT void JNICALL Java_TestJni_xprint (JNIEnv *, jobject, jstring); #ifdef __cplusplus } #endif #endif step two write jni file.c:TestJni.c: #include&lt;jni.h&gt; #include&lt;stdio.h&gt; #include &quot;TestJni.h&quot; JNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content) { const jbyte *str=(const jbyte*)(*env)-&gt;GetStringUTFChars(env,content,JNI_FALSE); printf(&quot;hello--wo%s \n&quot;,str); (*env)-&gt;ReleaseStringUTFChars(env,content,(const char*)str); return; } three build .so libcc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c four write a test:hellow.javaimport java.util.*; public class hellow { public static void main(String argc[]) { new hellow(); } public hellow() { new TestJni().xprint(&quot;hi my name is keee&quot;); } } question:如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径： java -Djava.library.path=’.’ HelloWorld或者输入命令：export LD_LIBRARY_PATH=“HelloWorld路径”:$LD_LIBRARY_PATH 设置环境变量 然后再 java HelloWorld 一样OK referencehttp://www.cnblogs.com/bastard/archive/2012/05/17/2506877.htmlhttp://www.cnblogs.com/wzben/p/5733571.html a example of JNI dynamic way:step 1:write a TestJni.java public class SimpleJni{ static { System.out.println(&quot;[java] static code block,start load shared library...&quot;); System.loadLibrary(&quot;SimpleJni&quot;); System.out.println(&quot;[java]load library end...&quot;); } static native int add(int a,int b); public static void main(String args[]) { System.out.println(&quot;[java] in main...&quot;); System.out.println(&quot;[java] 3+4=&quot;+SimpleJni.add(3,4)); System.out.println(&quot;end...&quot;); } } step 2:write a Jni file: #include &lt;jni.h&gt; #include&lt;stdio.h&gt; const char *classPathName=&quot;com/bt/jni/SimpleJni&quot;; jint myadd(JNIEnv *env,jobject thiz,jint a,jint b) { return a+b; } static JNINativeMethod methods[]={ {&quot;add&quot;,&quot;(II)I&quot;,(void*)myadd},}; int registerNatives(JNIEnv *env) { jclass clazz; clazz=(*env)-&gt;FindClass(env,classPathName); if(NULL==clazz){ printf(&quot;[C] FindClass fail\n&quot;); goto failed; } if (0&gt;(*env)-&gt;RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0]))){ printf(&quot;RegisterNatives fail.\n&quot;); goto failed; } return JNI_TRUE; failed: return JNI_FALSE; } jint JNI_OnLoad(JavaVM *vm,void *reserved) { JNIEnv *env=NULL; jint result=-1; void **env_p=NULL; printf(&quot;start register native func\n&quot;); env_p=(void**)&amp;env; if(JNI_OK!=(*vm)-&gt;GetEnv(vm,env_p,0x00010006)){ printf(&quot;get env failed..\n&quot;); goto err; } if(JNI_TRUE!=registerNatives(env)){ printf(&quot;register fail...exit....\n&quot;); goto err; } result=0x00010006; err: return result; } step use:1.首先编写SimpleJni.java和simpel_jni.c 2.编译java和c文件$ java -d . SimpleJni.java$gcc -fPIC -I$JAVA_HOME/include/ -I$JAVA_HOME/include/linux/ -o libsimpleJni.so simple_jni.c 3.执行 $java -Djava.library.path=. com.bt.jni.SimpleJni other example:java file: import java.util.*; public class TestJni { public native void xprint(String content); static { System.loadLibrary(“TestJni”); } public native static String native_hello(); } JNI file: #include&lt;jni.h&gt; #include&lt;stdio.h&gt; //#include &quot;TestJni.h&quot; #include&lt;iostream&gt; using namespace std; void xprint(JNIEnv *env,jobject obj,jstring content) { // const jbyte *str=(const jbyte*)(env-&gt;GetStringUTFChars(env,content,JNI_FALSE)); //printf(&quot;hello--wo%s \n&quot;,str); // env-&gt;ReleaseStringUTFChars(env,content,(const char*)str); cout&lt;&lt;&quot;here:&quot;&lt;&lt;content&lt;&lt;endl; return; } static jstring native_hello(JNIEnv *env,jobject object) { return (env)-&gt;NewStringUTF(&quot;keshixi&quot;); } static JNINativeMethod method_table[]={ { &quot;xprint&quot;,&quot;(Ljava/lang/String;)V&quot;,(void*)xprint}, {&quot;native_hello&quot;,&quot;()Ljava/lang/String;&quot;,(void*)native_hello} // {,,(void*)xprint},{,,(void*)native_hello} }; jint JNI_OnLoad(JavaVM *jvm,void *reserved){ JNIEnv *env; if(jvm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6)!=JNI_OK){ return -1; } jclass clz=env-&gt;FindClass(&quot;TestJni&quot;); if(clz==NULL) { return JNI_FALSE; } if(env-&gt;RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK){ return JNI_VERSION_1_6; } } ####reference:jni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行 动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子 另外可以作为ndk在android中使用及在android stdio也可以直接生成so 一些链接：android_jni_ndk:http://www.cnblogs.com/wzben/p/5733571.html动态注册无运行实例：http://www.linuxidc.com/Linux/2017-02/140130.htm静态注册：http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html动态注册：有实例http://www.linuxidc.com/Linux/2017-02/140129.htm www.fer.unizg.hr/_download/repository/jni.pdf文档]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_adb]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-adb%2F</url>
    <content type="text"><![CDATA[android adb command从android群英传中学习到额外的几个adb指令，是之前没接触到的：adb list targetsadb install -r xx.apk -r为覆盖adb shell dfadb shell pm list packages -fadb shell input keyevent 3 －－模拟按键输入，这里为点击home建adb shell touchscreen ..模拟滑动adb shell dumpsys 监听Activity运行状态adb shell screenrecord /sdcard/demo.mp4 录制 屏幕adb shell am start -n 包名/包名＋类名 更多，见google develop中android studio的部分另在源码目录中/system/core/toolbox 和/frameworks/base/cmds为所有ADB命令和shell命令来源]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_AndroidManifest]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-AndroidManifest%2F</url>
    <content type="text"><![CDATA[一个典型的androidmanifest文件：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.ksx.helloworld&quot;&gt; &lt;!-- more --&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;hallo&quot;//app的名字和显示在bar上的文字 android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt;//活动的注册 &lt;android:label=&quot;this is hallo&quot;&gt;//会覆盖上面的 &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;//声明为主活动 &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_makefirst_app]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-makefirst-app%2F</url>
    <content type="text"><![CDATA[install and make first app20170608今天主要是安装了android-studio环境并成功开发第一个helloworld app 在模拟器和手机上运行，下面是整个教程：在ubuntu下 1 安装java-jdk:a 先下载java-jdk:Java SE Development Kit 8 Downloadshttp://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html下载对应系统的版本 b 下载到某个目录，解压到要安装的目录：如：/usr/jdk-8/ c 设置全局环境变量：如上述的安装目录，则将export JAVA_HOME=/usr/jdk-8export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin添加到/etc/profile文件中，在末尾另起一行添加 d 使用source /etc/profile命令使刚才配置的信息生效 e 测试是否成功：java -version测试,编写java文件：public class test{ public static void main(String[] args){ System.out.println(“hello world”); }}保存为test.java，生成字节码：javac test.java运行:java test 2 安装android-studio:a 下载：在官网或者其他网站下载后b 按照installion说明进行：一般是先选择要安装的目录：如/usr/android-studioc 直接在终端,进入bin目录后:./studio.shd 还有其他配置．比如在任意目录都能打开软件．e 其他见说明文件等 3 第一个app helloworld在模拟器上运行打开软件－－&gt;选择新建一个工程，适当选择之后-&gt;选择build-&gt;make project-&gt;点击run––&gt;会提示选择安装下载模拟器–&gt;选择合适的，最好不要是带锁的－－－&gt;之后会提示成功．再选择建立一个模拟器，之后就可以了 注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm如果不能运行x86的，可能需要安装kvm:也可以使用genymotion模拟器 4 安装kvm可选要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。首先要确定你的cpu满足要求，下面有几个命令可以参考： $ egrep -c ‘(vmx|svm)’ /proc/cpuinfo4 打印的值不为0即可。 下面安装kvm： $ sudo apt-get install qemu-kvm$ sudo adduser linc kvm$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils$ sudo adduser linc libvirtd (linc为用户名，适当改）检验安装是否成功： $ sudo virsh -c qemu:///system list Id Name State运行，在有模拟器的目录中：如/home/ksx/Android/Sdk/emulator/emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm 使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。 如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。 5在手机上运行app首先连接手机，打开usb调试还是一样，但是选择app那里不是app,而是选择Edit Configurations之后选择usb device，ok，就可以了，接着运行 关于项目结构模式：默认为android设置为project可以看到整个完整的目录结构： .gradle和.idea 为自动生成 app build 编译时自动生成的文件，不用太关心 gradle 包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle .gitignore build.gradle gradle.properties 全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本 gradlew 和gradlew.bat在命令行中执行gradle命令 local.properties 指定本机android sdk路径 setting.gradle指定项目中引入的模块 app目录下 build 为自动生成，同上 lib 项目使用的第三方库 test 测试用例 proguard-rules.pro 代码混淆规则 build gradle intruducegradle Groovy 领域语言 DSL 摒弃了Ant 和Maven 在app 外有一个 build.gradle。在app中有一个build.gradle 在外面的 gradle 也可以构建c++等项目，buildscript { repositories { jcenter() //代码托管仓库 利用它可以轻松引用jcenter开源项目 } dependencies { classpath &apos;com.android.tools.build:gradle:2.3.2&apos; //声明构建的是android // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { jcenter() }} task clean(type: Delete) { delete rootProject.buildDir} app中apply plugin: ‘com.android.application’ //表明为android 应用程序模块，为com.android.library表示库模块 android { //安卓闭包 compileSdkVersion 25 //项目的编译版本，25为API 25,对应android 7.1 buildToolsVersion “25.0.3” //项目构建工具版本 defaultConfig { applicationId “org.example.myactivity1” 项目包名 minSdkVersion 25 //项目最低兼容的android系统版本 targetSdkVersion 25 //表明如22表示只在22测试充分，如不启动运行时权限，android６ 的运行时权限就不会加，表明只在5上做充分测试 versionCode 1 项目版本编号 versionName “1.0” 项目版本名 testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner” } buildTypes {//分debug和release版本 release { minifyEnabled false //是否混淆代码 proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’//混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件 } }} dependencies {//分本地依赖，库依赖和远程依赖 compile fileTree(dir: ‘libs’, include: [‘*.jar’]) //本地依赖声明 androidTestCompile(‘com.android.support.test.espresso:espresso-core:2.2.2’, { exclude group: ‘com.android.support’, module: ‘support-annotations’ }) compile ‘com.android.support:appcompat-v7:25.3.1’ // 依赖库 compile ‘com.android.support.constraint:constraint-layout:1.0.2’ testCompile ‘junit:junit:4.12’ //测试用例库} 其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_howto_makeapk_cmd]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-howto-makeapk-cmd%2F</url>
    <content type="text"><![CDATA[how to make a android by cmd :在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni way 1:方法１prepareandroid studio 创建了一个工程，然后手动在命令行打包，进入工程里的. 或者direct use andrid create project创建 cd ~/Desktop/FirstTest/app/src/mainmkdir genmkdir buildmkdir out 在android工程目录下建立Makefile文件，添加如下代码： SDK=~/Android/Sdk BUILD_TOOLS=$(SDK)/build-tools/25.0.3 PLATFORMS=$(SDK)/platforms/android-25 aapt=$(BUILD_TOOLS)/aapt dx=$(BUILD_TOOLS)/dx aidl=$(BUILD_TOOLS)/aidl apkbuilder=$(SDK)/tools/apkbuilder2 //后面不支持apkbuilder所以 adb=$(SDK)/platform-tools/adb 资源编译，生成 R.javaaapt_task: $(aapt) package \ -f \ #如果编译出来的文件已经存在，强制覆盖 -M AndroidManifest.xml \ # Mainifest.xml 的路径 -I $(PLATFORMS)/android.jar \ # 某个版本平台的 android.jar 的路径 #依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:... -S res/ \ # res 文件夹路径 -J gen/ \ # 生成 R.java 的输出目录 -m #使得生成的包的目录放在 -J 参数指定的目录 代码编译，生成 .classjavac_task: javac -source 1.7 -target 1.7 \ # 使用 jdk1.8 编译 1.7 的 .class 文件 -encoding UTF-8 \ -bootclasspath $(PLATFORMS)/android.jar \ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:... -d build/ \ #指定放置生成的类文件的位置 java/thereisnospon/dextest/*.java \ gen/thereisnospon/dextest/*.java \ 生成 .dexdx_task: $(dx) --dex --output=build/classes.dex \ build 资源文件初始包resapk_task: $(aapt) package -f \ -M AndroidManifest.xml \ -I $(PLATFORMS)/android.jar \ -S res/ \ -F out/resources 将.dex 文件加入到资源文件初始包中 注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行 apk_task: java -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \ com.android.sdklib.build.ApkBuilderMain \ Demo.apk -v -u -z src/main/out/resources\ -f src/main/build/classes.dex -rf src 签名，使用debug的签名signer: jarsigner -verbose \ -keystore ~/.android/debug.keystore \ -storepass android \ -keypass android \ Demo.apk androiddebugkey 一次性打包pkg: make apk_task make signer 卸载apkuninstall: $(adb) uninstall thereisnospon.dextest 安装apkinstall: $(adb) install out/app.apk 运行run: make pkg make uninstall make install $(adb) shell am start -n thereisnospon.dextest/ thereisnospon.dextest.MainActivity 方法２，用gradle,首先用AS 建立工程，之后在工程文件下，之星执行，gradle cleangradle build即生成apk文件]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_will_write]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-will-write%2F</url>
    <content type="text"><![CDATA[#test categoriesthis is the android categories to test]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test_article_picture]]></title>
    <url>%2F2018%2F05%2F20%2Ftest-article-picture%2F</url>
    <content type="text"><![CDATA[##this is a test of pictureend]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ksance test article]]></title>
    <url>%2F2018%2F05%2F19%2Fksance-test-article%2F</url>
    <content type="text"><![CDATA[this is a test article by ksance]]></content>
  </entry>
</search>
