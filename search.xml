<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cpp_static]]></title>
    <url>%2F2018%2F06%2F08%2Fcpp-static%2F</url>
    <content type="text"><![CDATA[c++关键词之staticsomething share:其实，一开始学习c++的时候，并没有想去了解它的语法原理。虽然学c的时候，附带学了汇编，也学到了内存段，和学编译原理的时候顺带了解了它的相关词法语法处理。 现在开始从原因，历史，内存，汇编等角度去看cpp，觉得清晰了一些。虽然没有去学习g++或者其他编译器如何处理c++的语法词法。这个想着以后如果有时间再研究吧。应该也是有工具去看，毕竟，g++是开源的，可以直接看源码如何处理C++ static overiew static在c的时候就有，因存储的地方不同于局部变量(in static mem ,not in stack)，使得在函数代码块结束后不会被销毁。从而能持续整个程序. 静态存储区(data)：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。 目录：１、static概念和用法２、static内存存储和汇编３、static和类相关内容与原理 static概念： static为静态修饰符。编译器遇到这个修饰符时将对应的变量存储在静态存储区(data) 根据类型：static可以修饰变量和函数，修饰对象和成员函数 根据位置：静态局部变量和全局静态变量 -存于静态数据区(data) c中的static: 修饰变量：作用域是本程序文件，局部变量默认为auto,静态变量不管局部或者全局都存储于静态数据区，使得不会因为函数调用而销毁 修饰函数：只能用于本程序文件，普通函数默认为extern ,能被其他文件引用，static则不行 “ 举个例子：在stat.h中声明static int getstats()函数.并在stat.c中实现它，static int getstats(){return xxx;}在main中或者其他文件中使用这个函数编译时报错未能找到该函数（未定义该函数)c++中的static当和类无关时同c” static使用和内存与汇编：static全局变量123456789101112131415161718 static int global1=4; 12 int main() 13 &#123;&gt;&gt; 14 int loc1=global1;_ZL7global1: .long 4 .text .globl main .type main, @function movl _ZL7global1(%rip), %eax movl %eax, -4(%rbp)//且可以通过kdbg看到在执行期，static变量的内存位置约为：(int *) 0x601048 &lt;global1&gt; 数据段地址局部变量的位置约为：(char **) 0x7ffff7a54530 &lt;loc1&gt; 栈地址 静态局部变量1234567891011121314151617int main() 13 &#123; 14 static int locstatic1=5;&gt;&gt; 15 int loc1=global1;&gt;&gt; 16 int loc2=locstatic1; movl _ZZ4mainE10locstatic1(%rip), %eax movl %eax, -4(%rbp)_ZZ4mainE10locstatic1: .long 5执行期： loca1 (int *) 0x7fffffffd8a8 loca2 (int *) 0x7fffffffd8ac global1 (int *) 0x601048 &lt;global1&gt; locstatic:(int *) 0x60104c &lt;main::locstatic1&gt; static定义的变量和函数只能在本程序文件中使用要知道这个的原因可能有些复杂，一时半会也说不清，得先直到函数为什么能被外部引用：存在“符号表”中，能被外部链接，静态函数不在符号表中所以不行，类似这样吧，这块不太清楚，感觉是这个原因 static函数：12345678910111213141516171819 static int getv() 4 &#123; 5 int a=5; 6 a++; 7 cout&lt;&lt;a&lt;&lt;endl; 8 return 4; 9 &#125; .type _ZL4getvv, @function_ZL4getvv:.LFB1021: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $16, %rsp 。。。。 call _ZL4getvv从汇编代码看貌似跟普通函数没什么差别123456789101112131415161718192021运行时 static int getv()&#123;0x400816 push %rbp0x400817 mov %rsp,%rbp0x40081a sub $0x10,%rsp int a=5; a++; cout&lt;&lt;a&lt;&lt;endl; return 4;&#125; static int global1=4;int main()&#123; static int locstatic1=5; int loc1=global1; int loc2=locstatic1;// cout&lt;&lt;getv()&lt;&lt;endl; getv();0x400866 callq 0x400816 &lt;getv()&gt; static和类相关static成员变量的使用 static成员变量是类的所有对象共有的，但是只有一份，通过类也可以访问到12345678910111213141516class Something&#123;public: static int s_value; // declares the static member variable&#125;; int Something::s_value = 1; // defines the static member variable (we'll discuss this section below) int main()&#123; // note: we're not instantiating any objects of type Something Something::s_value = 2; std::cout &lt;&lt; Something::s_value &lt;&lt; '\n'; return 0;&#125; 12345678910111213_ZN9Something7s_valueE: .long 1 .text .globl main .type main, @function Something::s_value=3;0x40081a movl $0x3,0x20083c(%rip) # 0x601060 &lt;Something::s_value&gt;（ movl _ZN9Something7s_valueE(%rip), %eax movl %eax, %esi）可见类似于上述的，存在内存的数据段中 类静态变量作用域静态成员在多个文件中:类中的机制，可以让定义在文件中的静态成员变量能被其他文件访问；加了作用域的声明，所以可以这样用1234567891011121314151617181920212223在stati.h class Some&#123; 2 public: 3 static int s_v; 4 &#125;; 5 //static int s_vv;//error 错误在stati.cpp #include"stati.h" 2 int Some::s_v=4; 3 //static int s_vv=5;error在main #include "stati.h" int gets= Some::s_v;other:class Whatever&#123;public: static const int s_value = 4; // a static const int can be declared and initialized directly&#125;; 静态成员函数的使用 考虑一个问题，当静态成员被申明为private时，则无法使用它directly by class。but you can用非静态成员函数操作或者用静态成员函数操作to use it 静态成员函数也是可以用类直接调用，它没有this指针，所以不能修改和访问对象的成员； （非静态成员func,它可以定义在类的内部或者外部，外部不用加static,这点和static成员不同，成员得在外部初始化－－因为public等定义成员时，非const不能赋值，而static不能修饰构造函数（对象相关），所以只能在外部初始化) 1234567891011121314151617181920212223class IDGenerator&#123;private: static int s_nextID; // Here's the declaration for a static member public: static int getNextID(); // Here's the declaration for a static function&#125;; // Here's the definition of the static member outside the class. Note we don't use the static keyword here.// We'll start generating IDs at 1int IDGenerator::s_nextID = 1; // Here's the definition of the static function outside of the class. Note we don't use the static keyword here.int IDGenerator::getNextID() &#123; return s_nextID++; &#125; int main()&#123; for (int count=0; count &lt; 5; ++count) std::cout &lt;&lt; "The next ID is: " &lt;&lt; IDGenerator::getNextID() &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_const]]></title>
    <url>%2F2018%2F06%2F08%2Fcpp-const%2F</url>
    <content type="text"><![CDATA[c++关键词之constconst介绍，用法，原理，注意点等const 介绍：const是用于标示不可修改的变量，对象或函数的。在其前面添加const就无法在之后做修改 用法 const总结起来有以下用法： const 修饰基本类型的变量 const int xx=4; const double xd=3.3; const int array[3]={3,4,5}; const 修饰指针和引用 const 指针： const int *p=&value;//无法改变指针指向的值，但是可以改变指针,value可以是int value;/const int value; 123456 int va=4; 6 const int *p=&amp;va ; 7 va=5;&gt;&gt; 8 *p=6;//error 9 cout&lt;&lt;*p&lt;&lt;endl;//5 10 return 0; int *const p=&value; //无法改变指针的值，但是可以改变指针指向的值 const int *const p=&value;//指针的值和指针指向的值 都不可以改变 const 引用： const int &amp;ref=value; const c&amp;cpp差异 不同于CPP，c将const存入的内存中设为只读，还是在栈中，而取其值时需要从内存中获取，所以从这个点看其效率比cpp差why?see follow 123456 c code: const int cc=8;0x4004da movl $0x8,-0x8(%rbp) int ccc=cc;0x4004e1 mov -0x8(%rbp),%eax0x4004e4 mov %eax,-0x4(%rbp) const和类 const 对象 const对象不能调用非const成员函数，也不能改变成员 12345678910111213141516class constobj&#123; public: int ax; int bx; constonj(int a,int b):ax(a),bx(b)&#123;&#125;; int getax() const &#123;return ax;&#125; int getbx() const &#123;return bx;&#125; void setax(int a)&#123;ax=a;&#125; &#125; int main () &#123; constobj cobj; const constobj ccobj; ccobj.setax(3);//error return 0; &#125; const 成员函数（只有成员函数能被声明为const )，它不能改变成员 不能在const成员函数中修改成员变量，但是可以修改其他变量。 非const对象可以调用const成员函数 一个灵活使用const成员函数的例子： 12345678910111213141516171819class Something&#123;private: std::string m_value;public: Something(const std::string &amp;value="") &#123; m_value= value; &#125; const std::string&amp; getValue() const &#123; return m_value; &#125; // getValue() for const objects std::string&amp; getValue() &#123; return m_value; &#125; // getValue() for non-const objects&#125;;int main()&#123; Something something; something.getValue() = "Hi"; // calls non-const getValue(); const Something something2; something2.getValue(); // calls const getValue(); return 0;&#125; c++11中的添加的新内容 constexp，cv限定 c++ const内存和原理 基本变量const变量是在栈中分配内存的，但是仅限于定义的时候，之后其他地方使用这个const变量都直接是使用该值从汇编中可以看到 1234 const int co1=3;0x4008ed movl $0x3,-0x14(%rbp) int nor=co1;0x4008f4 movl $0x3,-0x10(%rbp) 所以无法当进行co1=4;的赋值操作时会被编译器拦截，想想，编译后会变成3=4;是不对的； 这也解释了为什么一开始就要给const的变量赋值 * 数组:save in stack 1234 const int a[3]=&#123;2,3,5&#125;;0x4008fb movl $0x2,-0x20(%rbp)0x400902 movl $0x3,-0x1c(%rbp)0x400909 movl $0x5,-0x18(%rbp) 指针：const指针结合，其并不像基本类型那样贴出值，而是每次还是得去内存中取值，它的限定改变值，由编译器控制报错 指针并不是像前面那样，如123456789101112 const int *p=&amp;value; int xx=*p;//被替换成值?不是的，而是去内存中先取出指针的值，再以此为地址去取值； int pv=4;0x400a12 movl $0x4,-0x58(%rbp) const int *p=&amp;pv;0x400a19 lea -0x58(%rbp),%rax0x400a1d mov %rax,-0x40(%rbp) int px=*p;0x400a69 mov -0x40(%rbp),%rax0x400a6d mov (%rax),%eax0x400a6f mov %eax,-0x48(%rbp) 1234567891011 int pv=4;0x400a12 movl $0x4,-0x70(%rbp)//put 4 in mem(statck) const int *p=&amp;pv;0x400a19 lea -0x70(%rbp),%rax//get its addr0x400a1d mov %rax,-0x58(%rbp)//addr to p int *const pp=&amp;pv; 0x400a21 lea -0x70(%rbp),%rax0x400a25 mov %rax,-0x50(%rbp)//adddr to pp int *ppp=pp;0x400a29 mov -0x50(%rbp),%rax//get pp num0x400a2d mov %rax,-0x48(%rbp)//to ppp 引用：引用同指针，是会去内存中取值的,same to pointer 12345678follow aboveconst int &amp;ref=pv;0x400aba lea -0x7c(%rbp),%rax//get pv0x400abe mov %rax,-0x38(%rbp)//to ref int cs=ref;0x400ac2 mov -0x38(%rbp),%rax//get ref0x400ac6 mov (%rax),%eax//get *ref0x400ac8 mov %eax,-0x64(%rbp)//to cs const类对象： const对象为什么不能更改成员：成员是存在对象中的，如int,char等成员，存在栈中const对象的成员也是放在栈中的，它们之所以不能赋值，是在编译期间确定，更具体的细节未知； const对象为什么不能调用非const成员函数： 一个成员函数如何被调用： 其实成员函数也是全局函数，所以它能被调用， eg: 123456 obj.show();---&gt;实际上被转换为： show(&amp;obj) --传递给this指针： 所以当：const OB obj();obj.show();时，翻译为 const OB *this;在传递给OB *this时会出现不能将this指针从const OB转换为OB &amp;的错误 可以做个实验试试 conclude:if it can use non const func ,it will change member by non const this pointer; 为什么可以调用const函数：const函数：void show() const转换为：show(const OB *this);所以匹配上了，就可以调用了 注意：有最小权限原则，非const对象可以调用const成员函数，就像可以赋值一样。非const变量可以用const赋值]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_linklist3]]></title>
    <url>%2F2018%2F06%2F07%2Fleetcode-linklist3%2F</url>
    <content type="text"><![CDATA[leetcode_linklist3continue.. 反转链表Given a linked list, rotate the list to the right by k places, where k is non-negative.Example 1: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL/** Definition for singly-linked list. struct ListNode { int val; struct ListNode *next; };*/ 12345678910111213141516171819202122232425262728293031323334struct ListNode* rotateRight(struct ListNode* head, int k) &#123; if(head==NULL) return NULL; if(head-&gt;next==NULL) return head; struct ListNode *headnode=(struct ListNode*)malloc(sizeof(struct ListNode)); headnode-&gt;next=head; struct ListNode *sumhead=head; //compute len of list int sum=0; while(sumhead-&gt;next!=NULL) &#123; sum++; sumhead=sumhead-&gt;next; &#125; sum++; //compare k and len,or just compute the rota num int num=k%sum; int i=0; struct ListNode *dealheadf=head; for(i=1;i&lt;sum-num;i++) &#123; dealheadf=dealheadf-&gt;next; &#125; sumhead-&gt;next=headnode-&gt;next; headnode-&gt;next=dealheadf-&gt;next; dealheadf-&gt;next=NULL; head=headnode-&gt;next; headnode-&gt;next=NULL; free(headnode); return head;&#125; 移除倒数第n个元素Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? /** Definition for singly-linked list. struct ListNode { int val; struct ListNode *next; };*/ 12345678910111213141516171819202122232425262728293031323334353637383940struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123; if(head==NULL)//这个几乎没道题都要注意 return head; if(head-&gt;next==NULL&amp;&amp;n&gt;=1) return NULL; int sum=0; struct ListNode *sumhead=head; while(sumhead!=NULL) &#123; sum++; sumhead=sumhead-&gt;next; &#125; int remove=sum-n; struct ListNode *removenode=head; while(remove&gt;1) &#123; removenode=removenode-&gt;next; remove--; &#125; struct ListNode *rmnode; if(remove==1) &#123; struct ListNode *rmnode; rmnode=removenode-&gt;next; removenode-&gt;next=removenode-&gt;next-&gt;next; rmnode-&gt;next=NULL; free(rmnode); &#125; else//删除头 &#123; rmnode=removenode; head=head-&gt;next; rmnode-&gt;next=NULL; free(rmnode); &#125; return head; &#125; //一开始未考虑到删除头的情况，所以加了else 部分 交换元素Given a linked list, swap every two adjacent nodes and return its head. Example: Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Note: Your algorithm should use only constant extra space. You may not modify the values in the list&apos;s nodes, only nodes itself may be changed. /** Definition for singly-linked list. struct ListNode { int val; struct ListNode *next; };*/ 1234567891011121314151617181920212223242526272829struct ListNode* swapPairs(struct ListNode* head) &#123; if(head==NULL) return head; if(head-&gt;next==NULL) return head; struct ListNode *headNode=(struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode *second=head-&gt;next; struct ListNode *first=head; struct ListNode *curhead=headNode; while(1) &#123; if(first==NULL)break; second=first-&gt;next; if(second!=NULL) &#123; first-&gt;next=second-&gt;next==NULL?NULL:second-&gt;next; second-&gt;next=first; curhead-&gt;next=second; curhead=first; first=first-&gt;next==NULL?NULL:first-&gt;next; &#125; else break; &#125; head=headNode-&gt;next; headNode-&gt;next=NULL; free(headNode); return head; &#125; k组反转Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note: Only constant extra memory is allowed. You may not alter the values in the list&apos;s nodes, only nodes itself may be changed. /** Definition for singly-linked list. struct ListNode { int val; struct ListNode *next; };//这道题目原想在遍历一次就解决，可是还是想不出好的方法，得遍历两次，一次计算长度，一次正真的处理；在处理的过程使用头插法。注意边界条件，但因为有数量控制好些*/12345678910111213141516171819202122232425262728293031323334struct ListNode* reverseKGroup(struct ListNode* head, int k) &#123; if(head==NULL) return head; struct ListNode* headnode=(struct ListNode*)malloc(sizeof(struct ListNode)); headnode-&gt;next=head; int len=0; struct ListNode *lenhead=head,*curhead=headnode,*cur=head,*tmp=NULL; while(lenhead!=NULL)//计算长度 &#123; len++; lenhead=lenhead-&gt;next; &#125; int numofreverse=len/k;//要reverse几次 int i=0; int j=0; for(i=1;i&lt;=numofreverse;i++) &#123; j=k; while(j&gt;1)//每一次reverse k次，头插法 &#123; tmp=curhead-&gt;next; curhead-&gt;next=cur-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; curhead-&gt;next-&gt;next=tmp; j--; &#125; curhead=cur; cur=cur-&gt;next; &#125; head=headnode-&gt;next; headnode-&gt;next=NULL; free(headnode); return head; &#125; 总结后面还有几道题，不贴了，这里简述下： 检查是否链表中存在循环 检查链表中是否存在循环并找到循环的起点 深度复制链表，链表中的每个节点存在一个指向任意节点的指针 设计一个LRU cache,即（最近使用的） 。。。。。 链表的套路： 常使用头插法进行反转操作 使用两个指针解决循环问题，指针相遇测试是否存在循环，指针遍历减少时间 使用哈希，以空间换时间 加头节点，简化逻辑 使用链表注意 检查空和是否只有一个节点 释放空间，和放置取空指针，可以通过次数控制和判空]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_linklist2]]></title>
    <url>%2F2018%2F06%2F03%2Fleetcode-linklist2%2F</url>
    <content type="text"><![CDATA[leetcode——单链表2partition list这个是快速排序中一个很重要的步骤，即比该数大于等于的放其前小的放后。在链表中，基本思路:扫描链表，比给定数字小的不处理，比给定数字大的取下并插入到末尾 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions.Example:Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5*//** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* partition(struct ListNode* head, int x) &#123; /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */ if(head==NULL) return NULL; if(head-&gt;next ==NULL) return head; struct ListNode *list=(struct ListNode*)malloc(sizeof(struct ListNode)); list-&gt;next=head; struct ListNode*head1=list; struct ListNode*cur = head1-&gt;next; struct ListNode*tail=head1; int lenoflist1=0; while(tail-&gt;next!=NULL) &#123; tail=tail-&gt;next; lenoflist1++; &#125; struct ListNode* tmp=tail; while(lenoflist1&gt;=1) &#123; lenoflist1--; if(tail==cur) continue; if(cur-&gt;val&gt;=x) &#123; head1-&gt;next=cur-&gt;next; cur-&gt;next=NULL; tail-&gt;next=cur; tail=tail-&gt;next;//not consid at first cur=head1-&gt;next; &#125; else&#123; head1=head1-&gt;next; cur=cur-&gt;next; &#125; // printf("%d : ",cur-&gt;num); &#125; //if(head1-&gt;next==NULL)head1-&gt;next=tmp; head=list-&gt;next; list-&gt;next=NULL; free(list); printf("\n"); return head; &#125; //此题目最终被accepted//应该在函数中添加头节点而不是依靠传入的链表带头节点,一开始没有考虑到传入的链表不带链表头。。，没有考虑到一个元素的情况，这个方案最终accept 链表中的子链表反转，考察头插法 头插法在链表的反转，倒序，常被用到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* reverse a linklist from m to n * 1-&gt;2-&gt;4-&gt;5-&gt;null and m,n(ex:2,4) * return 1-&gt;5-&gt;4-&gt;2-&gt;null */#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;typedef struct LinkList&#123; int num; struct LinkList *next;&#125;Linklist;int reverselinklist(Linklist *list1,int m,int n,Linklist **result)&#123; if(list1==NULL) return -1; int i=0; Linklist *head1,*head2,*cur,*tmp,*pre; cur=list1; head1=cur; pre=head1; if(m==1) &#123; cur=cur-&gt;next; for(i=m;i&lt;n;i++) &#123; pre-&gt;next=cur-&gt;next; cur-&gt;next=head1; head1=cur; cur=pre-&gt;next; &#125; *result=head1; return 1; &#125; for(i=1;i&lt;m;i++)//node1-&gt;node2-&gt;node3---1-&gt;2-&gt;3--ex:m=2,list1-&gt;1 &#123; head1=cur; cur=cur-&gt;next; &#125; head2=cur; cur=cur-&gt;next; pre=head2; for(i=m;i&lt;n;i++) &#123; pre-&gt;next=cur-&gt;next; cur-&gt;next=head1-&gt;next; head1-&gt;next=cur; cur=pre-&gt;next; &#125; return 3;&#125;int main ()&#123; Linklist *list1=(Linklist*)malloc(sizeof(Linklist)); Linklist *result11=list1; int i; list1-&gt;num=4; printf("4 "); for(i=1; i&lt;9;i++) &#123; list1-&gt;next = (Linklist *)malloc(sizeof(Linklist)); list1 = list1-&gt;next; list1-&gt;num = i*2; printf("%d ",i*2); &#125; printf("\n"); Linklist *rr=(Linklist *)malloc(sizeof(Linklist)); Linklist **resull=&amp;rr; int rere=reverselinklist(result11,1,9,resull); if(rere==3) &#123; for(i=0;result11!=NULL ;i++,result11=result11-&gt;next) printf("%d ",result11-&gt;num); free(list1); &#125; else &#123; for(i=0;*resull!=NULL ;i++,*resull= (*resull)-&gt;next) printf("%d ",(*resull)-&gt;num); free(*resull); &#125; return 0;&#125; //此解法未经过leetcode检验，不过应该问题不大 有序链表移除重复元素 考察的是遍历链表删除链表中的元素，注意边缘条件控制如头部和尾部 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** Given a sorted linked list, delete all duplicates such that each element appear only once.Example 1:Input: 1-&gt;1-&gt;2Output: 1-&gt;2Example 2:Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* deleteDuplicates(struct ListNode* head) &#123; if(head==NULL)return NULL; if(head-&gt;next==NULL)return head; struct ListNode *first=head; struct ListNode *second=head-&gt;next; struct ListNode *tmp=second; while(second!=NULL) &#123; tmp=second; if(first-&gt;val==second-&gt;val) &#123; second=second-&gt;next; &#125; else &#123; first-&gt;next=second; first=first-&gt;next; second=second-&gt;next; &#125; &#125; if(first-&gt;val==tmp-&gt;val) first-&gt;next=NULL; return head;&#125; //此方案最后被accepted 删除有序链表中的有重复的node 和上一道题目类似: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** Given a sorted linked list, delete all duplicates such that each element appear only once.Example 1:Input: 1-&gt;1-&gt;2Output: 1-&gt;2Example 2:Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct ListNode &#123; int val; struct ListNode *next; &#125;;struct ListNode* deleteDuplicates(struct ListNode* head) &#123; if(head==NULL)return NULL; if(head-&gt;next==NULL)return head; struct ListNode *headnode=(struct ListNode*)malloc(sizeof(struct ListNode)); headnode-&gt;next=head; struct ListNode *first=head; struct ListNode *second=head-&gt;next; int numsame=0; struct ListNode *tmphead=headnode; while(second!=NULL) &#123; if(first-&gt;val==second-&gt;val) &#123; numsame++; first=first-&gt;next; second=second-&gt;next; &#125; else if(first-&gt;val !=second-&gt;val &amp;&amp; numsame==0) &#123; tmphead-&gt;next=first; tmphead=tmphead-&gt;next; first=first-&gt;next; second=second-&gt;next; &#125; else &#123; first=first-&gt;next; second=second-&gt;next; numsame=0; &#125; &#125; if(numsame==0)tmphead-&gt;next=first; else tmphead-&gt;next =NULL; head=headnode-&gt;next; headnode-&gt;next=NULL; free(headnode); return head;&#125;int main()&#123; struct ListNode *list1=(struct ListNode *)malloc(sizeof(struct ListNode)); struct ListNode *tmp=list1; struct ListNode *freelist1=list1; int i=0; for(i=1;i&lt;9;i++) &#123; list1-&gt;val=20-i; list1-&gt;next=(struct ListNode *)malloc(sizeof(struct ListNode)); list1=list1-&gt;next; printf("%d ",20-i); &#125; list1-&gt;val=12; tmp=deleteDuplicates(tmp); printf("\n"); for(i=1;tmp!=NULL;i++) &#123; printf("%d ",tmp-&gt;val); tmp=tmp-&gt;next; &#125; free(freelist1); return 0;&#125;这道题做的比较顺利，一次提交就=通过了注意：加头节点，由于解题的思路是两个指针的遍历，在第二个指针为空时停止，就会有尾巴为几种情况时的处理：如当尾巴为：4,4,4;4,5,5 这两种情况时，去掉尾巴，否则4,5,6.4,4,5时尾巴保留；见代码]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_linklist1]]></title>
    <url>%2F2018%2F06%2F03%2Fleetcode-linklist1%2F</url>
    <content type="text"><![CDATA[leetcode——单链表两数相加： 这道题是经一年多没刷题目之后，重新开始的第一道题，本来想着只是本地刷刷，后面开始就到leetcode提交了，毕竟写的程序还是得经过检验 所以这道题就纯粹的解答，未经检验，只是本地跑通，并且加上了自己的一些看法，比如对该题目该思路可能可以应用在哪些地方，这样算法才有了真正的意义，个人十分不赞同一些在公司呆久了的人说数据结构算法没什么用的人2333 废话不多说： 好久没写，第一道就别吐槽了，慢慢来 题目描述： You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.ExampleInput: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.注意两个数字位数可能不同，所以需要一些特殊情况要处理12#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149struct ListNode &#123; struct ListNode *next; int num;&#125; *linklist,listnode;//这是自己加的扩展，把输入的两个大数字符串转换为链表int changtolist(struct ListNode *list1,char num1[],struct ListNode *list2,char num2[])&#123;//应该在接口内计算长度好些 int i=0; int lennum1=0; while(num1[lennum1]!='\0')&#123;lennum1++;&#125; int lennum2=0; while(num2[lennum2]!='\0')&#123;lennum2++;&#125;//分配空间加字母转数字，无头节点 list1-&gt;num=num1[lennum1-1]-48; for(i=lennum1-2;i&gt;=0;i--) &#123; list1-&gt;next=(struct ListNode*)malloc(sizeof(struct ListNode)); list1=list1-&gt;next; list1-&gt;num=num1[i]-48; &#125; list1-&gt;next=NULL; list2-&gt;num=num2[lennum2-1]-48; for(i=lennum2-2;i&gt;=0;i--) &#123; list2-&gt;next=(struct ListNode*)malloc(sizeof(struct ListNode)); list2=list2-&gt;next; list2-&gt;num=num2[i]-48; &#125; list2-&gt;next=NULL; return 0;&#125;//两个大数相加，不用头节点的方式，麻烦一些int Add_two_num(struct ListNode *list1,struct ListNode *list2)&#123; int adding = 0; if(list1 == NULL || list2 == NULL) return -1;/* while(list1!=NULL &amp;&amp; list2!=NULL) &#123; list1-&gt;num = (list1-&gt;num+list2-&gt;num+adding)%10; adding = (list1-&gt;num + list2-&gt;num+adding)/10; list1 = list1-&gt;next; list2 = list2-&gt;next; &#125; if(list1==NULL &amp;&amp; list2!=NULL) */ struct ListNode *xx=list1; int n=0; int sum=0; sum = list1-&gt;num+list2-&gt;num+adding; list1-&gt;num = sum%10; adding = sum/10; do &#123;//常规情况，两个同长度部分 list1 = list1-&gt;next; list2 = list2-&gt;next; sum= list1-&gt;num+list2-&gt;num+adding; list1-&gt;num = sum %10; // printf("%d ",list1-&gt;num); adding = sum/10; &#125;while(list1-&gt;next!=NULL &amp;&amp; list2-&gt;next!=NULL); if(list1-&gt;next ==NULL&amp;&amp; list2-&gt;next==NULL &amp;&amp;adding!=0)//串1短于串2 &#123; list1-&gt;next = (struct ListNode *)malloc(sizeof(struct ListNode)); list1-&gt;next-&gt;num= adding; printf("show:%d\n",adding); &#125; if(list1-&gt;next==NULL &amp;&amp; list2-&gt;next !=NULL) &#123; list1-&gt;next = list2-&gt;next; while(list2-&gt;next!=NULL&amp;&amp;adding !=0) &#123; list2=list2-&gt;next; sum= list2-&gt;num+adding; list2-&gt;num=sum%10; adding = sum/10; &#125; if(adding&gt;0) &#123; list2-&gt;next=(struct ListNode *)malloc(sizeof(struct ListNode)); list2-&gt;next-&gt;num=adding; &#125; &#125; ...//串1长于 串2 ..... return 0;&#125;//需要思考，当进位到最后时，可能1,2都结束了，但是产生高位，此时要new listnode 完成//或者剩下２，和进位，则考虑２加进位int main ()&#123; struct ListNode *list1,*list2; list1 = (struct ListNode*)malloc(sizeof(struct ListNode)); list2 = (struct ListNode*)malloc(sizeof(struct ListNode)); list1-&gt;num=3; list2-&gt;num=5; struct ListNode *tmplist1=list1; struct ListNode *tmplist2=list2; int i; for(i=1; i&lt;9;i++) &#123; list1-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); list2-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); list1 = list1-&gt;next; list2 = list2-&gt;next; list1-&gt;num = 2; list2-&gt;num= 8; &#125; list2-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); list2-&gt;next-&gt;num=9; struct ListNode *result=tmplist1; struct ListNode *freelist1 = tmplist1; struct ListNode *freelist2 = tmplist2; for (i=0;i&lt;9;i++,tmplist1=tmplist1-&gt;next) printf("%d ",tmplist1-&gt;num); printf("\n"); for (i=0;i&lt;10;i++,tmplist2=tmplist2-&gt;next) printf("%d ",tmplist2-&gt;num); printf("\n"); Add_two_num(freelist1,freelist2); for(i=0;result!=NULL ;i++,result=result-&gt;next) printf("%d ",result-&gt;num); free(freelist1); free(freelist2); printf("\n");//------------------------------- struct ListNode *list11,*list22; list11 = (struct ListNode*)malloc(sizeof(struct ListNode)); list22 = (struct ListNode*)malloc(sizeof(struct ListNode)); char num1[100],num2[100]; gets(num1); gets(num2); changtolist(list11,num1,list22,num2); struct ListNode *result11 = list11; Add_two_num(list11,list22); for(i=0;result11!=NULL ;i++,result11=result11-&gt;next) printf("%d ",result11-&gt;num); free(list11); free(list22); return 0;&#125; //思考，扩大这道题的应用，在大数相加的时候，增加用户输入接口:”//5263565656554+5656537677834546//由char读入，int/char相加，——-极其丑的程序，以后不能这么搞，留个纪念想贴下两年多前（大三吧，那会刷这道题通过的程序–看来最喜欢的还是c）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *sum, *l4; sum = new ListNode(0); //新节点 l4 = sum; int sum_single, en = 0;//en表示进位的标志 while (l1 != NULL&amp;&amp;l2 != NULL) &#123; sum-&gt;next = new ListNode(0);//这里有个问题变为sum=NULL就行 sum = sum-&gt;next; // signal = 0; sum_single = l1-&gt;val + l2-&gt;val + en; if (sum_single&lt;10) &#123; sum-&gt;val = sum_single; en = 0; &#125; else if (sum_single &gt;= 10) &#123; sum-&gt;val = sum_single - 10; en = 1; &#125; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; while (l1 != NULL&amp;&amp;l2 == NULL) &#123; sum-&gt;next = new ListNode(0); sum = sum-&gt;next; sum_single = en + l1-&gt;val; if (sum_single &gt;= 10) &#123; sum-&gt;val = sum_single - 10; en = 1; &#125; else &#123; sum-&gt;val = sum_single; en = 0; &#125; l1 = l1-&gt;next; &#125; while (l2 != NULL&amp;&amp;l1 == NULL) &#123; sum-&gt;next = new ListNode(0); sum = sum-&gt;next; sum_single = en + l2-&gt;val; if (sum_single &gt;= 10) &#123; sum-&gt;val = sum_single - 10; en = 1; &#125; else &#123; sum-&gt;val = sum_single; en = 0; &#125; l2 = l2-&gt;next; &#125; if (l1 == NULL&amp;&amp;l2 == NULL&amp;&amp;en == 1) sum-&gt;next = new ListNode(en); //if(l1==NULL&amp;&amp;l2==NULL&amp;&amp;en==0)sum = NULL; /* while (l3) &#123; cout &lt;&lt; l3-&gt;val; l3 = l3-&gt;next; &#125;*/ return l4-&gt;next; &#125; &#125;;/*int main()&#123; Solution sou; ListNode *l1,*l2,*l3; l1=new ListNode(3); l1-&gt;next=new ListNode(7); l1-&gt;next-&gt;next=new ListNode(5); l2=new ListNode(7); l2-&gt;next=new ListNode(7); l2-&gt;next-&gt;next=new ListNode(5); l3=sou.addTwoNumbers(l1,l2); cout&lt;&lt;l3-&gt;val&lt;&lt;l3-&gt;next-&gt;val&lt;&lt;l3-&gt;next-&gt;next-&gt;val; return 0;&#125;*/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_IP]]></title>
    <url>%2F2018%2F06%2F03%2Ftcpip-IP%2F</url>
    <content type="text"><![CDATA[IP 协议和路由IP的作用–路由路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作? 从广义上讲，路由是路线图，就像百度地图上源地址到目的地址的路线，路线有很多，故路由也很多； 从网络层面讲，路由是一个数据包从源地址到目的地的传输路径，它如何被决定怎么走，即中间经过哪些路由器，选择哪一条路线等等。 一个数据包在网络上传输实例：A,B连上AP进行上网，AP和外网连接，AP的下一站是D;A 在构造了数据包后选择发送，要查询路由表，若该数据包发送给B,则通过路由表中的直连路由，找到B的ip,发送时不知道B的mac地址，故先做arp,得到后将数据包发给B:数据包：源ip：A,源mac A ，目的IP:B,目的mac:B若A在构造了数据包后，查询路由，该数据包是发送给外网，目的地址是百度ip,则无此条目，向默认路由；即发给路由器，此时若不知道mac地址会做arp;数据包：源ip:A,源mac：A ,目的ip:百度，目的mac：路由器(arp代理）数据包到路由器后，将做下一步转发：在路由发送的数据包：源ip:路由外网地址，源mac:路由，目的ip:百度ip.目的mac,D(注意，在源ip改为路由外网地址后，此时ip唯一，源地址在传输过程中不会再改变） 内网的路由器会将源地址改为路由器的外网地址—想想像192.168.0.4这样的源地址是内网地址，如果在包的传输过程中不做处理，到达目的地如QQ的服务器，那QQ处理完要发给你，这时得到包是从192.168.0.4来的，它作为内网地址，全世界很多个，怎么决定—–所以ip首部中的源地址和目的地址必须是全球唯一的ip地址，即外网地址； 路由器会对ttl做减1,然后再重新做校验和–即直接加1 路由器会将数据包的mac首部，源地址改为路由的mac地址，目的地址改为默认路由（或其他导向路由）ip对应的mac地址 网络地址和子网这里不记录太多的ip地址相关的内容，毕竟比较基础，且协议卷或者网上很多介绍 网络地址简介网络地址用来在网络上代表一台设备，就像家庭地址一样，当然现在的设备，如手机可以同时拥有几个ip地址（数据网，wifi，等等，可以理解为家有多个门）而现在的网络地址从32位点分十进制地址， 决定了它的数量–&gt;一个网络中的设备数量决定了它如何划分网络 网络中的设备数量动态性，可能很少，ip地址不够用–&gt;子网出现（CIDR) 网络地址不够用了–&gt;NAT出现，内网 网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?—其实本质上，设备间可以通过知道mac地址相互通信，即没有网络的隔离（只要介质支持如wifi,或者有线网下设备能被连在一起)在二层上考虑的 到了三层，ip层，设备与设备之间的通信，取决于网络的大小，在同一个局域网中，设备间可以直接通信，但是不同局域网，就必须借助路由器，网络，为什么?首先，考虑他们的距离，若很远，则单纯直连很难，则需要转发，转发单知道mac地址（好吧，假设一开始知道对方的mac地址），很难像现在用ip地址的方式去找到它emm感觉考虑到协议设计了。。。其次，考虑相邻的不同网络，对应不同的网段，路由表规定了只能和该网络地址范围的主机直接连接，否则就要用默认路由了 考虑这样一个例子：A 在子网192.168.0.0中，地址为192.168.0.3,B在子网10.170.3.0,地址为10.170.3.2,使用wifi,他们之间相邻，此时，A向B发送ARP请求，广播帧，所以B可以接收到，接着B给A回复了响应帧，单波能收到，因为在二层传递，能接收到，不被内核过滤，此时arp表中应该多了条目；接着为了能在三层通信，在路由表中增加一条路由指示不同网段的一个地址，表示他们可以直连，接着测试看看能不能相互发送ip包，ping通，当然可能因为防火墙等；就理论而言，应该是能通的，没试过~–&gt;问题总结：IP地址网段不同的两个设备，一定不能直接通信码? 网关地址必须是.1结尾码?恩当然可以是别的地址 路由表和路由规则决定了这些路由表如何决定了网络的方向，下一跳，和限制了网络范围？网络的拓扑结构:理论上，网络中的每台设备都能相互通信，即使是点对点通信p2p.但是这要求设备能在网络上被唯一标示，如外网ip地址； 所以常见的设备A和B的通信借助服务器如：主机A路由器(给主机唯一标识)服务器路由器主机B(现有的大部分通信软件等都是这样的) 而主机A可以直接和主机B通信不通过服务器吗?答案是可以，我们使用的迅雷，bt,这些下载资源就是利用的各个主机的资源，其结构如何：主机A路由器(做NAPT等)路由器主机B那和主机A和B如何在网络上被唯一标示，且被B知道该地址呢?路由器在其中充当什么角色，会做什么限制呢？见下NAT和NAT穿透路由深入–NAT和NAT穿透感谢这两篇文章把我带进门：https://blog.csdn.net/u012908515/article/details/53518062https://blog.csdn.net/ustcgy/article/details/5655050rfc ：nathttps://tools.ietf.org/html/rfc1631https://tools.ietf.org/html/rfc2663rfc：p2phttps://tools.ietf.org/html/rfc5694NAT的由来 NAT的出现是因为ipv4的地址不够用，所以大量主机在内网使用内网地址，这样在互联网上通信的时候不能被寻找到，此时路由器将内网的设备发送的包中的ip转换为外网的ip,并记录映射在路由器中，这样就能实现主机在互联网上的正常通信，即发包和收包都能找到； 而这种方式阻碍了不同内网的主机之间的通信，即p2p;NAT的分类（路由器决定） 静态NAT:即内网的一个IP对应外网的一个IP，且一一对应，即每次分配的时候都是相同的，永久的 动态NAT：即内网的一个IP对应外网的一个IP,但是每次分配的外网IP可能不同，映射不同 NAPT:即为了使同一个外网IP能被多个内网的主机使用而出现；如何区分各个主机？即路由器发包时和收包时，如收包时，如何确定该包是发给主机A还是B?即用NAPT,IP加端口号的形式来区分 NAPT分为以下两大类：cone锥形NAT和symmetric 对称NAT cone NAT的特点是对内网的主机A，和外网所有的服务器通信，都使用相同的端口号；如：内网：192.168.4.5:4323–&gt;server:222.33.22.334:80则经过路由器：外网ip:122.332.43.32:1234–&gt;server:22…路由器把源地址改为122.332.43.32:1234后发送进过服务器2也是类似的，使用同一个端口1234//这里有个疑问，即内网下相同的ip地址，不同的端口时，经过路由器转换后是否为不同端口考虑在接收服务器回复的内容时:222.33.22.334:80–&gt;122.332.43.32：1234此时路由器根据映射，即端口122.332.43.32：1234对应的是192.168.4.5把目的地址和端口更改为它后发送。所以为了能让包在主机内找到对应端口的程序，路由器的设置应为内网同ip不同端口，映射外网的ip+不同端口（待验证） 锥形NAT类型：完全锥形full cone和受限锥形( restricted cone) 以及端口受限锥形（port restricted cone) 完全锥形：任何知道主机B银蛇在NAT上的外部地址和端口的主机都可以通过它发包给内部主机B,即使A在内网(在内网时通过映射的外网地址） 受限锥形：只有内部主机B向其发送过包的主机A才能对这个内部主机B发包（通过主机B映射在外部的地址端口） 端口受限：在受限锥形的基础上加了端口限制 对称NAT(symmetric nat):会为新的session分配新的端口，即和服务器1通信时使用端口1234，接着发起新的服务器2访问时，使用端口1235等如何检测类型？https://blog.csdn.net/u012908515/article/details/53518062 ipv6不需要NATipv6地址很多，有人形容世界上的每个沙子都能被定址，所以地址够用，也就不用内网，所以用来做p2p更适用，自然也就不用什么nat转换 p2p网络架构和内网穿透基于上面的napt类型介绍，可以知道内网的主机如何和外网的服务器通信，那内网的主机1如何和另一个内网的主机2直接通信?（不借助服务器）答案:基于上面的限制，有几种方案： 针对full cone类型的，内网主机2只要知道内网主机1映射到外部的ip地址和端口，就可以直接发送数据包给1，且能接收； 针对受限的cone类型，内网机2像上面的方式是不行的：得满足两个条件：1是知道主机1映射到外部的ip和端口，2是主机1曾向主机2发送过请求，相当于开了个口，显然这个条件下2为服务器或者有公网ip的设备；所以针对此受限的类型，有一下场景+方案： 场景1：主机1在nat后，打开了和服务器A通信，主机2想和1通信，主机2不在nat后；显然直接向主机1发起请求是不行的，上述条件2不满足，主机1不曾向2发起请求； 解决方案是，借助服务器A请求主机1做一个反向连接，即向2发起请求，从而打开通道，进而2就可以跟1通信了 场景2：主机1在nat后，主机2在nat后，主机1，2均打开了和服务器A通信，主机1想直接和2通过双方映射到外网的地址端口进行通信 解决方案：UDP打洞：假如1开始发送一个UDP信息到2的公网地址上,与此同时,他又通过A中转发送了一个邀请信息给2,请求2也给1发送一个UDP信息到1的公网地址上.这时1向2的公网IP发送的信息导致 NAT 1 打开一个处于1的私有地址和2的公网地址之间的新的通信会话,与此同时NAT 2也打开了一个处于2的私有地址和1的公网地址之间的新的通信会话.一旦这个新的UDP会话各自向对方打开了,1和2之间就可以直接通信,而无需A来牵线搭桥了.这就是所谓的打洞技术.一旦这种处于NAT之后的端对端的直连建立之后,连接的双方可以轮流担任对方的”媒人”,把对方介绍给其他的客户端,这样就极大的降低了服务器A的工作量. 场景3：主机1和2处于同一个NAT下，他们却不知道： 解决方案：综合相同内网下主机可以直接相互通信原理：在主机1发送给A的包中携带其内网地址和端口，A从而知道了1的外网端口地址和内网端口地址，相互都发给1,2，若接着1发起请求给2能收到回复说明在同一个内网，否则采用场景2的解决方案 场景4：主机1处于多层NAT下 问题：udp空闲状态下超时断开的问题：使用心跳包 扩展：tcp的打洞，同时开放tcp连接，原理类似，较复杂 针对对称性的cone,不定因素多，不建议写 所以p2p网络即是多个内网主机1,2,3,4等之间的相互直接通信，即他们之间的下载数据可以相互共享，也就是平常说的挂种子，bt下载，也是为什么能达到那么快速的原因;当然可想这个过程和普通的cs架构区别： p2p架构，bt模型（猜测)：首先客户端负责下载和挂种的基本功能。下载:需要向服务器取得可以获取资源的主机的nat外网地址和ip,接着服务器为其打洞，将正在挂种的客户ip等提供给该客户端，从而能下载；挂种：给服务器声明自己能提供资源，并通过心跳维持一个持续的洞；BT服务器做什么?综合客户端资源和打洞，即让下载方能方访问挂种放 。 这个过程需要考虑：下载方面对多个挂种方，如何下载文件块和组装，最多同时和几个挂种方下载等等； 回忆：之前学校的rs bt站就是这样，只是开放在学校的内网，可以说是相同nat下的不同主机???好像也不能这么说。。然后采用的原理就是上述的，记得一开始速度不是很快，但是后面15年吧，下载速度能达到10+m/s,很快的，我想可能是优化了下载多个挂种方的方案，增加了最多的下载源，或者学校的网络变优～Cbitterrot源码分析（待~)https://linux.cn/thread-5529-1-1.html对于p2p架构的软件设计，其实跟平常的cs架构很象，都需要用到socket等]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_MAC]]></title>
    <url>%2F2018%2F06%2F03%2Ftcpip-MAC%2F</url>
    <content type="text"><![CDATA[mac数据链路层的理解mac层的功能介绍mac层在理论上赋予了较全的功能，但是其实，实际上在使用的时候，由于无噪声通道，或者一些功能交给了上层的协议，所以实际的mac功能没有理论那么全面。mac层的实现包括在驱动和固件中，所以实际的功能得看芯片和固件的支持，比如是否支持监听模式； 理论上：建议书籍《数据通信与网络》寻址：实际的端到端通信，都是需要先知到对方的mac地址(通过arp),才能进行实际传输的；帧构建：这一层结束后就是完成了包封装，下一步传送给物理层编码发送了；数据差错检查；传送控制，流量控制，差错控制，编码，校验和等等；，编码是指在原始数据mac封包后，在实际传输时进行编码（按照某个80x协议等，这个属于偏物理层的事情了）实际上：数据差错检查，流量控制，差错控制等都没做，或者要看具体的厂商实现如高通，mtk等 mac层的传输限制 考虑一个包从电脑发出去，最后一次封包根据接口不同(有线，无线),协议不同，采用的mac头也不同，如ppp协议要加其他信息； –&gt;简述:接着可能发给无线路由器或者交换机，路由器会判断是wifi的mac头，接着要向以太网传输时，或者无线传输时，需要去掉mac头，并加上自己的mac头，改变mac源地址为自己，目的地址为(路由表对应)arp寻找的下一跳mac地址;若为以太网，还要转换为以太网的头类型等 … 整个过程，从物理层角度看，是可以顺利进行的，但是实际为了效率，不接受无用的包，不发送无效的包和安全等，在驱动和固件都会有做相应的过滤处理，从而使发包收包，转发包等受到了限制，见下实验等； mac层的封包,mtu,msdu,mpdu在包的封装上，有线网和无线网不同，更确切的是协议不同，其mac层封包也不同–对相同的ip包(ip头+上层数据/arp/…）带有不同的mac头：例如对以太网（有线）：常见有一下四种mac头封装的帧： EthernetII: dest addr+src addr+type+data+fcs Ethernet 802.2:dest addr+srcaddr+len+ llc+data+fcs Ethernet 802.3:dest addr+src addr+len+data+fcs Ethernet SNAP:dest addr+src addr+len+llc+snap+data+fcs参考：https://blog.csdn.net/xiao628945/article/details/8006022针对无线网络：802.11n等，更复杂些： 802.11头+msdu(数据部分)+fcs(crc)而802.11wifi无线帧分为控制帧，管理帧和数据帧，因为在无线网络中的安全性等考虑，需要扫描，关联，认证四次握手等步骤,在802.11头就包含了subtype，即数据部分是什么类型（控制，。。）https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了这么多的封包类型，除却ip层只有一种，那在传递的过程中如何处理?即有线到无线，怎么识别?答案是在路由器，主机中进行去头和加头不同厂商实现不同，在无线中，非数据帧部分：底层的实现分为full mac driver（Full Mac的Driver，一般Auth和Assoc的包直接在芯片里边处理了，Driver通过command形式告诉Firmware要连接AP的信息，Firmware处理了Assoc Response之后，report给Driver一个Event，说明连接的情况（result和AID）以及assoc相关的IE，Driver会直接调用cfg80211的接口报告给supplicant，然后处理EAPOL的握手过程，因为之后的EAPOL Data的处理会用到Assoc Response里边的IE） 而用soft mac则软件可以控制较多的事情(Soft Mac模块开源代码mac80211的WiFi芯片，会将这两种包送到Mac80211处理，mac80211处理完后调用cfg80211的接口通过nl80211(netlink)通知wpa_supplicant准备认证以及四次握手的状态机，等待处理EAPOL包，EAPOL是二层的Data包，会在Supplicant里边处理，连接加密的路由情况就是这样处理的，如果不加密，那就直接DHCP了)；扯远了。。在pc等设备中，在封装到数据链路层时，封装时用的是ethernetII，到底层驱动时就被替换为对应的802.11的头了，进而发送出去，而在接收数据包的时候，底层上报上来又会把802.11格式的转换为ehternetII的形式，所以我在实验wifi的时候，用的PF_PACKET来操作数据包，加的是ethernetII的头，接收到打印出来后还是ethernetII的头晒张空中包的和本地tcpdump抓到的包对比：//to do 当然除却mac头的不同，mtu的概念还是存在:mac层在传输时一次传输一帧，这一帧即是封装了mac头的数据包，它常为[46-1500]+mac头,而mtu即是最大的传输单元，是去掉mac头的负载部分最大值，如1500而在实际传输的空中包，情况又可能不同，这里看msdu 和mpdu:https://blog.csdn.net/zhengnice/article/details/51923132这篇文章讲的很好，在理解了上述的内容后，看这篇文章里面的msdu和mpdu就能很好的理解了，spec的416页也有相关的内容 mac头格式：不同协议可能不同：常见：dest addr,src addr ,proto type; 14byte见上文 mac层的发包和收包限制考虑一个问题，即在不考虑网络网段的情况下，两台设备在开启wifi或者连接网线的情况下，能相互直接通信吗？从理论上是可以的，首先是发送，无问题，接收，可以接收；其次，接收之后解码，需要双方使用相同的编码协议等；其次：实际上，需要几个条件，且有线和无线的方式不同： 有线：需要双方相同的编码，直连的情况下，可以直接通信； 无线: (分为数据部分和管理部分，需要双方相同的编码)，但是仅开启wifi，只能接收小量信息的beacon帧；即wifi为了安全性，效率等(wifi本身可以接收所有数据），做了连接前的扫描，关联认证，四次握手等过程，并且对mac地址进行过滤，使不同网段的两个相邻设备不能通过直接发送接收mac层数据来交互；具体见厂商的实现，可以参考实验部分； 所以关键看厂商怎么实现，底层的东西，他们提供接口给你，你就能操作了balalal普通模式，混杂模式和监听模式mac层的几个实验普通模式下，wifi实验，以station架构进行：设备A，B,路由器C，D; A,B连接同一个路由器C,A,B通过PF_PACKET发送和接收mac头加任意数据，成功发送接收，即使arp表无对方的条目 A,B都不连接wifi,只是打开wifi，此时无法发送和接收数据，厂商默认的只会发送主动扫苗和接收beacon帧，扫描的具体过程待文章写,在没有连接上时，只会发送小数据 A,B间任意设备连上路由器，同上 A连接路由C,B连接路由D,相互发送和接收mac头加任意数据，目的地址为对方mac，源地址为自己的mac—失败，其实一开始是怀着疑问的，从理论分析是可以的，但是还是不行，若只是在二层的话，对方怎么知道这个源mac地址是在不同网段并做过滤?难道发之前，底层进行了隐式arp？但是我发的包里面没有带ip信息啊，同时进行了广播帧的发送接收，还是失败了；应该都是出在接收的环节；也有可能是两个ap使用的协议不同导致编码方式不同从而接收失败 考虑到可能是两个路由器编码和使用的协议如一个是802.11n,一个是ac，等，可能导致接收不到，所以可以再尝试使用两个相同的型号的路由器；//待测试 发送方普通模式，接收方监听模式，接收方可以收到所有包，所以可以接收到 openwrt开源路由系统，驱动，固件了解一下。。。spec:Wireless LAN Medium Access Control(MAC)and Physical Layer (PHY) Specifications]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_ARP]]></title>
    <url>%2F2018%2F05%2F27%2Ftcpip-ARP%2F</url>
    <content type="text"><![CDATA[ARP 协议ARP协议的作用 ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信； 在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：端设备手机pc等–&gt;(交换机)路由器—&gt;下一个路由器—&gt;下一个终端设备 端设备默认路由到网关–&gt;网关收到包后，将源地址改为网关的外网地址—&gt;下一个路由–&gt;….-&gt;设备地址为目的地址时，接收而不转发 考虑一个问题：在上述的网络上发送时，如pc发给路由器时，只知道它的ip地址，怎么发给它：即端到端的发送：是借助设备唯一的mac地址来发送的在有线网中。利用了交换机的端口和mac地址关系，转发在wifi中，能接收到所有的包，但是会在驱动中将mac目的地址非本地的包丢弃，除非开启了混杂监听模式 但是路由器怎么知道设备如手机的mac地址呢？通过arp协议来获取，arp是依赖mac和ip的”映射” tcpip卷1中4.2举了一个完整的例子，可以去看ARP协议的交互过程 基本的交互方式：例如ping网关：station —ARP request—-&gt; AP ARP请求，广播帧station &lt;—ARP response — AP ARP应答 ,单播帧通过上述的方式，station得到了AP的mac地址，之后将AP的MAC地址存在缓存中，在下次数据包等包的时候就可以将该mac地址填在mac头中，即知道了AP的地址后，包就可以顺利的被AP接收了 AP(路由器)也会主动的向station发送arp request，当它不知道station的mac地址（或缓存过期），例如，AP收到一个外网的包，要转发给对应192.168.0.4的staton,但是没有他的mac地址，或者过期了或者其他情况，则向该station发出arp请求。从而得打station的mac地址 什么时候会触发arp请求？1.在ping的时候2.在发送tcp，ip包的时候3.在缓存过期时主动发出，这个由arp状态机中实现ARP代理和免费ARP 当我们通过ping百度，或者想访问百度的时候，怎么在mac头中填写目的mac地址呢？即怎么找到百度?（另一个网络) 是通过在mac头目的mac地址填写网关的mac地址实现的，借助w网关的来帮我们寻找，这个叫做ARP代理,其实欺骗了主机 tcpip卷对此有较详细解说4.6 免费ARP是用于检测是否周围有使用相同的ip地址的设备，即通过ping自己，寻找有自己的ip的主机ARP协议的包封装格式和抓包分析 分组格式： ()为字节数mac头：以太网目的地址(6) mac源地址(6) 帧类型(2)(0x0806)28byte arp帧：硬件类型(2)|协议类型(2)|硬件地址长度(1)|协议地址长度(1)|op(请求或应答或rarp 2)|发送端mac地址(6)|发送端ip(4)|接收端mac地址(6)|接收端ip(4) 请求广播帧：目的mac地址为全1，电缆上所有的以太网接口都要接收广播帧,硬件类型为1表示以太网地址，协议类型为要映射的协议地址类型0x0800,表示为ip地址，op（arp请求为1，答应为2，rarp请求为3，rarp答应为4） arp填充：以太网帧最小值为60，mac头14，所以=46，要填充：46-28=18个字节 arp抓包，可以用wireshark,Omnipeek - Savvius,tcpdump,或者自己写一个程序来抓～tcpdump : sudo tcpdump -vv arp 12345 tcpdump: listening on wlp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes21:51:21.134575 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.101 tell 192.168.0.1, length 28 //ap ask me21:51:21.135404 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.110 tell 192.168.0.1, length 2821:51:21.135413 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.0.110 is-at 48:5a:b6:6e:c9:5f (oui Unknown), length 28// i reply ap21:51:32.081916 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.106 tell 192.168.0.1, length 28 //ask other 123456722:01:27.149947 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.0.107 tell 192.168.0.1, length 28 0x0000: 0001 0800 0604 0001 206b e70f 1b42 c0a8 .........k...B.. 0x0010: 0001 0000 0000 0000 c0a8 006b ...........k 22:04:17.114593 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.0.110 is-at 48:5a:b6:6e:c9:5f (oui Unknown), length 28 0x0000: 0001 0800 0604 0002 485a b66e c95f c0a8 ........HZ.n._.. 0x0010: 006e 206b e70f 1b42 c0a8 0001 .n.k...B.... ARP协议的常用命令和调试分析 查看ARP缓存：即现在保存的arp映射表: 12345arp -a? (192.168.0.101) at 4c:32:75:3a:09:b3 [ether] on wlp2s0? (192.168.0.1) at 20:6b:e7:0f:1b:42 [ether] on wlp2s0? (192.168.0.108) at 94:d0:29:9d:74:dd [ether] on wlp2s0? (192.168.0.107) at 94:65:2d:ab:88:8b [ether] on wlp2s0 1234arp Address HWtype HWaddress Flags Mask Iface192.168.0.101 ether 4c:32:75:3a:09:b3 C wlp2s0192.168.0.1 ether 20:6b:e7:0f:1b:42 C wlp2s0 123456ip neigh192.168.0.101 dev wlp2s0 lladdr 4c:32:75:3a:09:b3 STALE192.168.0.1 dev wlp2s0 lladdr 20:6b:e7:0f:1b:42 STALE192.168.0.108 dev wlp2s0 lladdr 94:d0:29:9d:74:dd STALE192.168.0.107 dev wlp2s0 lladdr 94:65:2d:ab:88:8b STALE192.168.0.104 dev wlp2s0 lladdr e4:9a:dc:b0:a5:36 STALE arping命令：http://man.linuxde.net/arping arp 命令man arp 包括删除arp表项等，有问题，找男人~ARP协议内核状态机 对不存在的主机，arp请求的超时机制 arp缓存和老化时间：http://www.jb51.net/LINUXjishu/65693.html：改变老化时间：在Linux上如果你想设置你的ARP缓存老化时间，那么执行sysctl -w net.ipv4.neigh.ethX=Y即ARP协议的编程 在PF_PACKET中发出ARP包 直接贴例子，具体可以看博客的PF_PACKET文章：123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;linux/if.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;linux/if_ether.h&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230//获取硬件网卡的相应信息void GetEthInfor(char *name , char *MAC_addr , struct in_addr * IP_addr);//arp包的结构定义struct ARP_PACKET&#123; //以太网首部 unsigned char dest_mac[6]; //6字节 unsigned char sorce_mac[6];//6字节 unsigned short type; //2字节 //arp——内容 unsigned short hw_type; //2字节：硬件地址类型 0x0001 表示mac地址 unsigned short pro_type; //2字节：软件地址类型 0x0806 表示IPV4地址 unsigned char hw_len; //1字节：硬件地址长度 unsigned char pro_len; //1字节：软件地址长度 unsigned short op; //2字节：操作类型 0x0001表示ARP请求；0x0002表示ARP应答 unsigned char from_mac[6];//6字节 unsigned char from_ip[4]; //4字节 unsigned char to_mac[6]; //6字节 unsigned char to_ip[4]; //4字节 unsigned char padding[18];//18字节：填充字节，因为以太网数据最少要46字节&#125;;//主函数int main()&#123; int i = 0; int fd = 0; int num=0; unsigned char MAC_ADDR[6]; struct in_addr IP_ADDR;//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址. struct ARP_PACKET arp_pk=&#123;0&#125;; struct sockaddr_ll eth_info;//结构体的定义//在/linux/if_packet.h中， 表示设备无关的物理层地址结构 //第一步：获取指定网卡的信息（MAC地址和IP地址） GetEthInfor("wlp2s0",MAC_ADDR,&amp;IP_ADDR); /*printf("The MAC_addr is:"); for(i =0 ;i&lt;6;i++) printf("%4X",MAC_ADDR[i]); printf("\n"); printf("the IP is:%s\n",inet_ntoa(IP_ADDR));*/ //第二步：填充ARP数据包的内容 for(i=0;i&lt;6;i++) //填充以太网首部的目的mac地址 &#123; arp_pk.dest_mac[i]=0XFF; &#125; for(i=0;i&lt;6;i++) //填充以太网首部的源mac地址 &#123; arp_pk.sorce_mac[i]=MAC_ADDR[i]; &#125; arp_pk.type = htons(0x0806); //填充以太网首部的侦类型 arp_pk.hw_type = htons(0x0001); //填充硬件地址类型：0x0001表示的是MAC地址 arp_pk.pro_type = htons(0x0800);//填充协议地址类型：0x0800表示的是IP地址 arp_pk.hw_len = 6; //填充硬件地址长度 arp_pk.pro_len = 4; //填充协议地址长度 arp_pk.op = htons(0x0001); //填充操作类型：0x0001表示ARP请求 for(i=0;i&lt;6;i++) //填充源mac地址 &#123; arp_pk.from_mac[i]=MAC_ADDR[i]; &#125; in_addr_t ipaddr=inet_network(inet_ntoa(IP_ADDR)); for(i=3;i&gt;=0;i--) //填充源IP地址 &#123; arp_pk.from_ip[i]=(unsigned char)ipaddr&amp;0xFF; ipaddr=ipaddr&gt;&gt;8; printf("-%d-",arp_pk.from_ip[i]); &#125; /* arp_pk.from_ip[0]=192; arp_pk.from_ip[1]=168; arp_pk.from_ip[2]=199; arp_pk.from_ip[3]=145;*/ for(i=0;i&lt;6;i++) //填充欲获取的目的mac地址 &#123; arp_pk.to_mac[i]=0X00; &#125; arp_pk.to_ip[0]=0X0B; //填充想要装换为MAC地址的IP地址。可以使用命令行参数来做 arp_pk.to_ip[1]=0X40; arp_pk.to_ip[2]=0X39; arp_pk.to_ip[3]=0X0A; //第三步：填充sockaddr_ll eth_info结构 eth_info.sll_family = PF_PACKET; eth_info.sll_ifindex = if_nametoindex("wlp2s0");//返回输入的接口名称的索引值 //printf("number is:%d\n",eth_info.sll_family); //第四步：创建原始套接字 fd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL)); // if(fd&lt;0) &#123; printf("socket SOCK_RAW failed!\n"); exit(1); &#125; //第五步：发送ARP数据包 num = sendto(fd , &amp;arp_pk , sizeof(struct ARP_PACKET) , 0 ,(struct sockaddr*)(&amp;eth_info),sizeof(eth_info)); if(num&lt;0) &#123; printf("sendto failed!\n"); exit(1); &#125; //第六步：接受ARP应答 num = recvfrom(fd , &amp;arp_pk , sizeof(struct ARP_PACKET) ,0,NULL,0); if(num&lt;0) &#123; printf("rcvfrom failed!\n"); exit(1); &#125; else &#123; printf("I receive %d bytes!\n",num); printf("the mac is:"); for(i=0;i&lt;6;i++) &#123; printf("%4X ",arp_pk.from_mac[i]); &#125; printf("op:%d\n",arp_pk.op); for(i=0;i&lt;4;i++) &#123; printf("%d. ",arp_pk.to_ip[i]); &#125; printf("\n"); &#125; close(fd); return 0;&#125;void GetEthInfor(char *name , char *MAC_addr , struct in_addr * IP_addr)&#123; struct ifreq eth; //够结构用于存放最初多获取的接口信息//该结构存放在：/net/if.h,详细字段表示在头文件中 int fd; //用于创建套接字 int temp=0; //用于验证接口调用 int i=0; //用于循环 strncpy(eth.ifr_name,name,sizeof(struct ifreq)-1);// fd = socket(AF_INET,SOCK_DGRAM,0); // fd=socket(AF_INET,SOCK_STREAM,0); fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));if(fd&lt;0) &#123; printf("socket failed!\n"); exit(1); &#125; //获取并且保存和打印指定的物理接口MAC地址信息 temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth); if(temp&lt;0) &#123; printf("ioctl--get hardware addr failed!\n"); exit(1); &#125; strncpy(MAC_addr,eth.ifr_hwaddr.sa_data,6); printf("The MAC_addr is:"); for(i =0 ;i&lt;6;i++) printf("%4X",(unsigned char)eth.ifr_hwaddr.sa_data[i]); printf("\n"); //获取并且保存和打印指定的物理接口IP地址信息 temp = ioctl(fd,SIOCGIFADDR,&amp;eth); if(temp&lt;0) &#123; printf("ioctl--get hardware addr failed!\n"); exit(1); &#125; memcpy(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),4); //关闭套接口 printf("got ipaddr:%s\n",inet_ntoa(*IP_addr));/*i=0;printf("get the MAC_ADDR:\n");for(i;i&lt;6;i++) printf("%.2X:",MAC_addr[i]&amp;0xFF);*/ close(fd);&#125;//第二步填充arp数据包的时候，填充的数据和类型根据需要进行。//这里的arp数据包结构体是自己定义的，也可以是利用linux的相关结构：/*eg:typedef struct _tagARP_PACKET&#123; struct ether_header eh; ///net/ethernet.h struct ether_arp arp; &#125;ARP_PACKET_OBJ, *ARP_PACKET_HANDLE; /netinet/if_ether.h;/net/if_arp.h各个字段的填充见头文件*//*第三步：填充sockaddr_ll eth_info结构,关键是填充网络接口索引值，最直接的方法是上面的函数，还有另外的方法:利用ioctl函数获取struct ifreq结构的信息，该结构放置了很多网络接口的相关信息*//* struct sockaddr_ll&#123; unsigned short sll_family; //总是 AF_PACKET unsigned short sll_protocol; // 物理层的协议 int sll_ifindex; //接口号 unsigned short sll_hatype; // 报头类型 unsigned char sll_pkttype; // 分组类型 unsigned char sll_halen; // 地址长度 unsigned char sll_addr[8]; // 物理层地址 &#125;;eg:* struct sockaddr_ll peer_addr; * memset(&amp;peer_addr, 0, sizeof(peer_addr)); peer_addr.sll_family = AF_PACKET; struct ifreq req; bzero(&amp;req, sizeof(struct ifreq)); strcpy(req.ifr_name, "eth0"); if(ioctl(sockfd, SIOCGIFINDEX, &amp;req) != 0) perror("ioctl()"); peer_addr.sll_ifindex = req.ifr_ifindex; peer_addr.sll_protocol = htons(ETH_P_ARP); *//*第四步，创建套结字的时候，有以下的组合：更多见：man packet * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux. * 第二个参数： 2）套接字类型： SOCK_DGRAM----以太网头已经构造好了 SOCK_RAW------自己构造以太头 * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字 * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr）， * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部， * 而发送时也无须用户添加头部字段。 第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型： 1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806) 和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100) 2)IEEE维护的注册以太网类型列表 3）半官方的列表由IANA维护 ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。 0x88b5和0x88b6是保留以太网类型，供实验或私人使用。 */ /*第五步发送和接收套接字的函数可以是read write操作套结字，也可以是上文的UDP无连接用的函数*/ 处理的时候可能需要获取网关的ip地址：1234567891011121314151617181920212223242526272829303132333435363738/*proc方法获取网关地址*/void GetGateWayIP(uint8 *ip_addr)&#123; char inf[100]; FILE *file_fd; uint8 high=0,low=0,value; int i; file_fd = fopen("/proc/net/route","r"); if(file_fd==NULL) &#123; printf("can not open /proc/net/route\n"); &#125; else &#123; while(!feof(file_fd)) &#123; memset(inf,0,sizeof(inf)); fgets(inf,100,file_fd); if(inf[5]=='0'&amp;&amp;inf[6]=='0'&amp;&amp;inf[7]=='0'&amp;&amp;inf[8]=='0'&amp;&amp;inf[9]=='0'&amp;&amp;inf[10]=='0'&amp;&amp;inf[11]=='0'&amp;&amp;inf[12]=='0') &#123; for(i=20;i&gt;=14;i-=2) &#123; if(inf[i]&gt;=65) high = inf[i]-55; else high = inf[i]-48; if(inf[i+1]&gt;=65) low = inf[i+1]-55; else low = inf[i+1]-48; value = high*16+low; ip_addr[10-i/2] = value; &#125; break; &#125; &#125; &#125;&#125; ARP攻击 ARP包可以直接发送给对端不经过路由器，有趣在一个局域网中，客户端的几乎所有的包都是发往路由器的，这归结于默认路由设置，而在无线网，网卡其实可以接收所有数据，毕竟空气介质，所以，局域网中的设备可以直接通信实验：在文件全能王中开启wifi文件传输，和它在同一个局域网的sta能访问该地址，抓包，发现目的地址和源地址都为同一个局域网的不同ip,且不为路由器网关ip，证明其两个设备是可以直接通信的 再来做一个实验：通过pf_packet1、在电脑A上写一个程序，mac目的地址为B,源地址为A,协议类型随机，数据随意，发送给B 同时在B端进行接收，过滤掉其他mac地址，看是否可以接收到，在连接ap和不连接ap的条件下2、在A和B设置静态ip地址，且不同网段，都不连接AP ,让A向B 发送ARP请求包，B接收到后回复arp响应包，接着做ping或其他操作，看是否能互相通信 编程可以参考上述程序，改一下地址什么的就可以，或者参考其他：http://www.freebuf.com/articles/system/5157.html这篇文章讲的很具体，个人也喜欢这个网站，emm,实验过了，还可以，can also make your own program,具体程序不贴了 arp欺骗的基本原理：在局域网中，设备A,B连接同一个路由器，他们之间可以直接相互通信，因此可以直接向对方发送arp包；设备A ,B都会定期和AP交互arp请求和回复，相互知道对方的mac地址，这样，就能给ap发送请求，ap也能知道回复给谁；arp欺骗的基本原理在于，如B是攻击方，则B向A发送ARP回复自己是AP ,即在ARP回复包中带上自己的mac地址，ap的ip地址；同时向AP回复自己是A，即带上A的ip地址，自己的mac地址；这样A就会以为B是AP，就会把请求发给B ,同时AP以为B是A，会把回复传给B,但是同时得配置B的转发功能，echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot该博文中有一处错误，见评论]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_PF_PACKET]]></title>
    <url>%2F2018%2F05%2F27%2Ftcpip-PF-PACKET%2F</url>
    <content type="text"><![CDATA[PF_PACKET的使用：PF_PACKET简介：是linux下的用于发送和接收二层(mac层)的套接字： PF_PACKET基本使用： 基本的几个操作： 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;linux/if.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;linux/if_ether.h&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//获取硬件网卡的相应信息void GetEthInfor(char *name , char *MAC_addr , struct in_addr * IP_addr)//传入接口名，取回mac和ip&#123; struct ifreq eth; //结构用于存放最初获取的接口信息 //该结构存放在：/net/if.h,详细字段表示在头文件中 int fd; //用于创建套接字 int temp=0; //用于验证接口调用 int i=0; //用于循环 strncpy(eth.ifr_name,name,sizeof(struct ifreq)-1); // fd = socket(AF_INET,SOCK_DGRAM,0); // fd=socket(AF_INET,SOCK_STREAM,0); fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL)); if(fd&lt;0) &#123; printf("socket failed!\n"); exit(1); &#125; //获取并且保存和打印指定的物理接口MAC地址信息 temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth); if(temp&lt;0) &#123; printf("ioctl--get hardware addr failed!\n"); exit(1); &#125; strncpy(MAC_addr,eth.ifr_hwaddr.sa_data,6); printf("The MAC_addr is:"); for(i =0 ;i&lt;6;i++) printf("%4X",(unsigned char)eth.ifr_hwaddr.sa_data[i]); printf("\n"); //获取并且保存和打印指定的物理接口IP地址信息 temp = ioctl(fd,SIOCGIFADDR,&amp;eth); if(temp&lt;0) &#123; printf("ioctl--get hardware addr failed!\n"); exit(1); &#125; memcpy(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),4); //关闭套接口 printf("got ipaddr:%s\n",inet_ntoa(*IP_addr)); close(fd);&#125;//取得网络接口的索引：int值,传入fd和接口名int Get_IfaceIndex(int fd, const char* interfaceName)&#123;struct ifreq ifr;if (interfaceName == NULL)&#123; return -1;&#125;memset(&amp;ifr, 0, sizeof(ifr));strcpy(ifr.ifr_name, interfaceName);if (ioctl(fd, SIOCGIFINDEX, &amp;ifr) == -1)&#123; printf("RED ioctl error\n"); return -1;&#125;return ifr.ifr_ifindex;&#125;int set_Iface_promisc(int fd, int dev_id)//传入fd和index&#123;struct packet_mreq mr;memset(&amp;mr,0,sizeof(mr));mr.mr_ifindex = dev_id;mr.mr_type = PACKET_MR_PROMISC;if(setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&amp;mr,sizeof(mr))==-1)//退出混杂模式使用这个：PACKET_DROP_MEMBERSHIP&#123; fprintf(stderr,"GREEN set promisc failed! \n"); return -1;&#125;return 0;&#125; 使用123456789101112int main ()&#123; unsigned char MAC_ADDR[6]; struct in_addr IP_ADDR;//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址. //第一步：获取指定网卡的信息（MAC地址和IP地址） GetEthInfor("wlp2s0",MAC_ADDR,&amp;IP_ADDR); int fd; fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP)); int index=Get_IfaceIndex(fd,"enp1s0"); printf("index:%d\n",index); return 0; &#125; PF_PACKET的接收：简单说明：创建套结字的时候，有以下的组合：更多见：man packet 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux. 第二个参数： 套接字类型：SOCK_DGRAM----以太网头已经构造好了 SOCK_RAW------自己构造以太头 * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字 * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr）， * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部， * 而发送时也无须用户添加头部字段。 第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)2) IEEE维护的注册以太网类型列表3）半官方的列表由IANA维护 ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。 0x88b5和0x88b6是保留以太网类型，供实验或私人使用。(若指定socket_type为SOCK_RAW则意味着原始数据包包含了链路层头部，若指定为SOCK_DGRAM则将做一些处理以剥掉链路层头部。链路层头部信息的通用格式是一个sockaddr_ll结构。protocol填入网络字节序的IEEE 802.3协议号。参见&lt;linux/if_ether.h&gt;头文件了解允许的协议。如果protocol被设置为htons(ETH_P_ALL)，则意味着接受所有协议。所有接入的协议类型为protocol的数据包将在传递给内核之前传递到PACKET套接字。) 收包可以使用的接口：123int readnum = recvfrom(rawsock, buffer,2048,0, (struct sockaddr*)(&amp;eth_info),&amp;leneth_info);int readnum = read(rawsock, buffer,2048);int readnum = recvfrom(rawsock, buffer,2048,0, NULL,NULL); 一个简单的接收包的例子：12345678910111213141516#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/if_ether.h&gt;#include &lt;linux/in.h&gt;#include &lt;stdlib.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netdb.h&gt;#include &lt;linux/if.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;linux/if_packet.h&gt;#include &lt;linux/if_ether.h&gt;#define BUFFER_MAX 2048 1234567891011121314int main(int argc, char *argv[])&#123; if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; 0) &#123; printf("error: create raw socket!!!\n"); exit(0); &#125; while(1) &#123; int readnum = read(rawsock, buffer,2048);// can read packet //printf("recv buffer:%s\n",buffer); &#125; return 0; &#125; 指定从某个接口接收数据：12345678910111213141516171819202122int main(int argc, char *argv[])&#123; struct sockaddr_ll eth_info;//结构体的定义在/linux/if_packet.h中， 表示设备无关的物理层地址结构 eth_info.sll_family = PF_PACKET; //PF_PACKET定义在sys/types.h中 eth_info.sll_ifindex = if_nametoindex("lo");//返回输入的接口名称的索引值 //次函数定义在net/if.h中 if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; 0) &#123; printf("error: create raw socket!!!\n"); exit(0); &#125; if(bind(rawsock,(struct sockaddr *)(&amp;eth_info),sizeof(eth_info))==-1)//绑定接口，从而只接收那个接口上的数据&#123; printf("error: bind!!\n"); exit(0);&#125; while(1) &#123; int readnum = read(rawsock, buffer,2048);// can read packet //printf("recv buffer:%s\n",buffer); &#125; return 0; &#125; 接收后的包如何读取：以包括mac头的形式来看：粗暴的形式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798int main(int argc, char *argv[])&#123; int rawsock; char buffer[BUFFER_MAX]; char *ethhead; char *iphead; char *tcphead; char *udphead; char *icmphead; char *pHead; if((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; 0) &#123; printf("error: create raw socket!!!\n"); exit(0); &#125; while(1) &#123; int readnum = read(rawsock, buffer,2048);// can read packet //printf("recv buffer:%s\n",buffer); if(readnum &lt; 42) &#123; printf("error: Header is incomplete!!!\n"); continue; &#125; // for(j;j&lt;readnum;j++) // printf("%.2X:",buffer[j]&amp;0xFF); ethhead = (char *)buffer; pHead = ethhead; int ethernetmask = 0XFF; framecount++; printf("------------------Analysis Packet [%d]---------------------\n",framecount); // printf("all:-----%s\n",ethhead); printf("MAC:"); int i = 6; for(; i &lt;=11; i++) &#123; printf("%.2X:",pHead[i]&amp;ethernetmask); &#125; printf("----&gt;"); for(i = 0; i &lt;=5; i++) &#123; printf("%.2X:",pHead[i]&amp;ethernetmask); &#125; printf("\n"); printf("proto: %.2x:",pHead[12]&amp;ethernetmask); printf("proto2: %.2x:\n",pHead[13]&amp;ethernetmask); iphead = ethhead + 14; pHead = iphead + 14; printf("IP:"); for(i = 0; i &lt;=3; i++) &#123; printf("%d",pHead[i]&amp;ethernetmask); if(i != 3) printf("."); &#125; printf("----&gt;"); for(i = 10; i &lt;=13; i++) &#123; printf("%d",pHead[i]&amp;ethernetmask); if(i != 13) printf("."); &#125; printf("\n"); int prototype = (iphead + 9)[0]; // printf("Protocol: %.2X:",prototype); //int prototype = (iphead + 9)[0]; pHead = iphead + 20; printf("Protocol: "); switch(prototype) &#123; case IPPROTO_ICMP: printf("ICMP\n"); break; case IPPROTO_IGMP: printf("IGMP\n"); break; case IPPROTO_IPIP: printf("IP\n"); break; case IPPROTO_TCP : printf("TCP | source port: %u | ",(pHead[0]&lt;&lt;8)&amp;0XFF00 | pHead[1]&amp;0XFF); printf("dest port: %u\n", (pHead[2]&lt;&lt;8)&amp;0XFF00 | pHead[3]&amp;0XFF); break; case IPPROTO_UDP : printf("UDP | source port: %u | ",(pHead[0]&lt;&lt;8)&amp;0XFF00 | pHead[1]&amp;0XFF); printf("dest port: %u\n", (pHead[2]&lt;&lt;8)&amp;0XFF00 | pHead[3]&amp;0XFF); break; case IPPROTO_RAW : printf("RAW\n"); break; default: printf("Unkown\n"); &#125; printf("-------------------------end-----------------------\n"); &#125; return 0; &#125; 收包处理的方式，也可以把指针赋给内核的结构：struct iphdr如：12struct iphdr ip;ip = (struct iphdr *)(buffer + sizeof(struct ethhdr)); 内核提供了很多的包结构，在发包或者收包的时候可以直接使用这些结构解析或者粗暴的用字符串解析 PF_PACKET发送包： 发包和接收包类似： 1234567num = sendto(rawsock, buffer,2048 , 0 ,(struct sockaddr*)(&amp;eth_info),sizeof(eth_info)); if(num&lt;0) &#123; printf("sendto failed!\n"); exit(1); &#125; printf("success:%d\n",num);]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>PF_PACKET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DS_linklist]]></title>
    <url>%2F2018%2F05%2F26%2FDS-linklist%2F</url>
    <content type="text"><![CDATA[数据结构之线性表：有序表：数组：单链表：链表定义 { 数据成员:常见的基本类型或者对象类型均可 数据关系:在链表中的块的成员在连续的内存中，块与块之间内存位置不连续 指向块的指针：单链表只有一个next,双链表加上pre }基本运算：{ InitList(&amp;L);:初始化链表，在c/c++中需要做分配内存，初始化链表头和其值的操作； DestroyList(&amp;L); 在销毁时需要free内存 Length(L);链表的长度是块的个数 GetElem(L,i,&amp;e); 在链表中取元素需要一个一个遍历直到下标值，若为双链表会快些。所以这里取索引值对应的值和取链表的值，效率几乎一样； LocateElem(L,e,compare()); 和链表中的元素做对比 InsertElem(&amp;L,i,e); 在链表中插入元素，复杂度O(1),在提供位置的时候，若不提供位置，还需要加搜索的时间 DeleteElem(&amp;L,i,&amp;e); 在链表中删除元素，复杂度O(1)…… }eg:1234567891011typedef struct LNode &#123; ElemType data；//数据域 struct LNode *next； //指针域&#125; LNode, *LinkList;LNode *L;LinkList L;L = (LinkList) malloc( sizeof (LNode) );或 L = new LNode;L-&gt;data;LNode L;L.date 链表的两种头部： 没有头的链表：第一个块就开始存储数据 任何时候都有头的链表： 第一个块不存储数据，作为头节点，第二个块开始存数据 应用：在leetcode中的ReverseLinklist中，当反转的是从1开始的时候，若使用的是没有头的，则需要额外判断处理，否则可以统一处理； 链表的几个常见操作： 取第i个元素： 123456789101112Status GetElem_L(LinkList L, int i, ElemType &amp;e)&#123;//查找操作 p = L-&gt;next; j = 1; while( p &amp;&amp; j &lt; i)&#123; p = p-&gt;next; ++j; &#125; if (!p || j&gt;i) return ERROR; e = p-&gt;data; return OK;&#125; 插入元素：在第i个位置上插入 1234567891011Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123; p = L; j = 0; while (p &amp;&amp; j &lt; i-1) &#123; p = p-&gt;next; ++j &#125; if (!p || j&gt;i-1) return ERROR; s = (LinkList) malloc( sizeof (LNode) ); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return OK; &#125; 删除元素:删除第i个元素: 1234567891011 Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e)&#123; p = L; j = 0; while (p-&gt;next &amp;&amp; j &lt; i-1) &#123; p = p-&gt;next; ++j &#125; if (!(p-&gt;next) || j&gt;i-1) return ERROR; q = p-&gt;next; e = q-&gt;data; p-&gt;next = p-&gt;next-&gt;next; //(p-&gt;next = q-&gt;next;) free(q); return OK;&#125; 链表的建立： 头插法： 1234567891011CreateList_L(LinkList &amp;L, int n)&#123; L = (LinkList) malloc( sizeof (LNode) ); L-&gt;next = NULL; for( i=n; i&gt;0; --i)&#123; s = (LinkList) malloc( sizeof (LNode) ); scanf( &amp;s-&gt;data); s-&gt;next = L-&gt;next; ① L-&gt;next = s; ② &#125;&#125; 尾插法： 12345678910CreateList_L(LinkList &amp;L, int n)&#123; tail = L = (LinkList) malloc( sizeof (LNode) ); L-&gt;next = NULL; for( i=n; i&gt;0; --i)&#123; s = (LinkList) malloc( sizeof (LNode) ); scanf( &amp;s-&gt;data); tail-&gt;next = s; ① tail = s; ② &#125; &#125; 链表的常见复杂操作： 两个有序链表的合并：123456789101112131415void MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)&#123; pa = La-&gt;next; pb = Lb-&gt;next; Lc = pc = La; while( pa &amp;&amp; pb )&#123; if(pa-&gt;data &lt;= pb-&gt;data)&#123; pc-&gt;next = pa; pc = pa; pa = pa-&gt;next; &#125; else&#123; pc-&gt;next = pb; pc = pb; pb= pb-&gt;next; &#125; &#125; pc-&gt;next = pa ? pa : pb; free( Lb );&#125; 一些特殊的链表： 单向循环链表： 图示： 多重循环链表： 双向链表：12345typedef struct DuLNode&#123; ElemType data; struct DuLNode *prior; struct DuLNode *next;&#125;DuLNode, *DuLinkList; 双向循环链表： 探讨： 链表作为最基础的数据结构，是对其他数据结构：如栈，树等的支撑，其他这些大部分是在链表的基础上建立的； 从较底层的层面：即深入到内存，链表实现了对零散内存的有效使用，内存在为链表分配空间的时候不用大段的连续空间； 从较高层，即抽象的层面看，链表仅仅是一批数据的拓扑结构之一，就常见的栈，队列，树，图等等，你还可以想出其他可能有用没用的，如，立体的结构，方块，金字塔形(emm这个像堆），还有随意的，感觉想到了矩阵里面的压缩。 应用： 链表的应用：如 在文件中，对大文件的存储，采用类似链表的结构， 大数相加，像两个100位的整数相加，使用链表，每个块为一位，就可以解决这个问题，数组也行 倒排索引结构，在操作系统中用到，我的github上放着一个本科毕业设计做的简单搜索引擎，几乎全是自己搞的（解析网页那块自己c写了状态机，觉得效果不如beatifulsoup好，后面用它了),不过想想那会还不会很有意识的去想如果让它运行在大量用户下，各种使用条件（如输入条件下，会怎么样，年轻啊~) 其他，当然是其他数据结构基于链表做的，多了去了]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[code_efficandreadable]]></title>
    <url>%2F2018%2F05%2F26%2Fcode-efficandreadable%2F</url>
    <content type="text"><![CDATA[论代码的效率和可读性的权衡高效代码可读性差：有一些代码，占用额外内存小，即run in place，且执行的速度快，即复杂度O()低，但是可读性差，即使注释了，修改起来也容易出错，如：对链表的操作：举一个leetcode的例子：(这个例子不是很典型，能说明问题即可） reverse a linklist from m to n; 1-&gt;3-&gt;4-&gt;5-&gt;null and m,n(ex:2,4); return 1-&gt;5-&gt;4-&gt;2-&gt;null; 上面例子一开始可以想到，头插法，或者将范围内的那一段用新的处理过的链表替换掉，即只需要处理该片段的头和尾部，当然可能还有其他方法，这里先不考虑； 于是，头插法不是很复杂，但是在这里不用额外的内存时，需要频繁的改变next指针和对pre元素做临时保存，使得代码可读性差，所以可以考虑以下方案： 在替换的内存小时，可以采用后者，让代码可读性高些，方便维护和（被替代~更容易被炒鱿鱼的风险哈哈) 在内存小时，采用前者，爱怎么指怎么指，看不懂不管哈哈哈]]></content>
      <categories>
        <category>代码整洁</category>
      </categories>
      <tags>
        <tag>代码可读性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcpip_mtu]]></title>
    <url>%2F2018%2F05%2F20%2Ftcpip-mtu%2F</url>
    <content type="text"><![CDATA[MTU这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍： 理论部分：１、MTU(Maximum Transmission Unit)如何定义: 指的是通信协议中的某一层上面所能通过的最大数据包大小 这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？ 答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B&gt;1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:分片：ip净载荷：MTU-IP头：1500-20=1480; 3008B 需要分为3片，3008=1480,1480,48总结：MTU就是MAC承载的载荷的最大值 2、MTU会影响什么: 数据包太大-&gt;分片重组-&gt;网络性能变差 数据包太小-&gt;一次能传输的数据小-&gt;网速差 路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191) 3、如何知道这个值呢？路径最大传输单元发现方法(RFC1191) 越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。 MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：ping -c 3 -s 1474 -M do 192.168.0.1PING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.ping: local error: Message too long, mtu=1500提示错误即消息太大且未设置分片 4 MTU大小的来源:ref https://www.zhihu.com/question/31460305/answer/183766816以太网传输帧的最小值： 最早的以太网工作方式：载波多路复用/冲突检测（CSMA/D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。 假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。 为什么标准以太网帧长度上限为1518字节? IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。 由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 byte那有效传输效率= 160 / 218 = 73%而如果以太网长度为1518，那有效传输效率= 1460 / 1518 = 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题. 于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。 其他疑问： 最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？ 这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到&gt; 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。 有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度&gt;接口MTU，怎么办？丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。 所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？ 我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU = MRU，但比如9000侧的数据到达1500，由于9000 &gt; MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样实践部分：如何设置MTU：ifconfig eth0 mtu 1460如何查看mtu:netstat -i]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[cpp_debug_layout_static]]></title>
    <url>%2F2018%2F05%2F20%2Fcpp-debug-layout-static%2F</url>
    <content type="text"><![CDATA[c compile time memory layout 标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法： 概述：首先介绍几个概念： 程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候； 当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程； 注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码 。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句； 本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c 前言：一个源代码通过编译后生成一个目标文件.o它是一个elf relocatable文件,以下.o文件指此类，elf文件为executable文件.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到 other data ... .comment offset 0x000000c6. .rodata ... //const &amp; str 常量 .data .text .elf header 一个elf文件的结构是这样的：可以通过readelf来看： elfheader 文件头包含了平台信息：/usr/include/elf.h .text 段表 各个段：应用程序也可以自己定义段，和指定变量在哪个段 .data .bss .. other sections section header table string tables 重定位表和字符串表 symbol tables 符号表是链接的接口 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂 可以通过readelf -s xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突 强符号和弱符号（强引用和若引用），调试信息 －g 扩展： １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀； 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o objdump -ht image.o 可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们 具体看文档２）自定义段：attribute((section(“FOO”))) int global=24; attribute((section(“BAR”))) void foo(){} 既可以把变量或函数放入该段中 段名：BAR FOO 正文： 0、先从几个命令：1)size filename:查看elf或.o文件中各个段大小： text data bss dec hex filename 74 0 0 74 4a simplest.o 代码段 数据段 代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null 2)其他工具： readelf -a simplest.o 可以看到更清楚的段信息 objdump -t simplest objdump -h simplest.o 替代size可以看到更多信息 此时显示出来的一些地址并不是装载后的地址 objdump -s -d xx.o: -s 16进制，-d反汇编 －－－查看代码段objdump -s -x -d xx.o: –查看数据段和rodata 3)查看目标文件文件属性如relocatable –.o/executable –elf/share object –.so.. file xxx １、从最简单的程序开始：simplest.cint main() { return 0; } 将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件： # 1 &quot;simplest.c&quot; # 1 &quot;&lt;built-in&gt;&quot; # 1 &quot;&lt;command-line&gt;&quot; # 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4 # 1 &quot;&lt;command-line&gt;&quot; 2 # 1 &quot;simplest.c&quot; int main() { return 0; } 将它进行汇编：gcc -S simplest.c .file “simplest.c” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits 生成.o文件：gcc -c simplest.c并通过file xx.o查看类型simplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped 通过size 查看各个段：size simplest.o: 可以看到只有代码段，数据为空，bss为空，是比较纯净的 text data bss dec hex filename 67 0 0 67 43 simplest.o 接着编译成elf:gcc -o simplest simplest.cfile simplestsimplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped可以看到连接器等信息 size simplest text data bss dec hex filename 1099 544 8 1651 673 simplest注意这里的和.o的文件大小和分段不同， ２、加入头文件和局部变量#include&lt;stdio.h&gt; int main() { int locala; int localb=3; return 0; } 进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数汇编，可以看到分配３到内存中 .file “simplest.c” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits 生成.o文件：可以看到未改变data和bss,但是代码段变大 text data bss dec hex filename 74 0 0 74 4a simplest.o 生成elf:数据区和bss未改变，代码段也未改变？ text data bss dec hex filename 1099 544 8 1651 673 simplest ３、加入已经初始化的局部静态变量：int main() { static int statica=3; .. } 看生成的汇编： .file “simplest.c” .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .data .align 4 .type statica.2285, @object //新加的段 .size statica.2285, 4 statica.2285: .long 3 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits .o大小：在静态数据区增加了，４ １个int的长度 text data bss dec hex filename 74 4 0 78 4e simplest.o elf:有点费解，。。 text data bss dec hex filename 1099 548 4 1651 673 simplest ４、加入已经初始化的全局变量和全局静态变量int golbala=6; static long gs=12; 生成的汇编 .file “simplest.c” .globl golbala .data .align 4 .type golbala, @object .size golbala, 4 golbala://变量名 .long 6 .align 8 .type gs, @object .size gs, 8 gs://变量名 .quad 12 .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .data .align 4 .type statica.2287, @object .size statica.2287, 4 statica.2287: .long 3 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits size : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4=20 text data bss dec hex filename 74 20 0 94 5e simplest.o elf size:548–&gt;564 16 text data bss dec hex filename 1099 564 4 1667 683 simplest 5 将 int golbala=6; static long gs=12; 倒换位置！！！！！！！！！ 则对齐成：size x.o为：１６比原来小，可以用于节省内存： text data bss dec hex filename 74 16 0 90 5a simplest.o 汇编： .file “simplest.c” .data .align 8 .type gs, @object .size gs, 8gs: .quad 12 .globl golbala .align 4 .type golbala, @object .size golbala, 4golbala: .long 6 .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE0: .size main, .-main .data .align 4 .type statica.2287, @object .size statica.2287, 4statica.2287: .long 3 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbitself文件的也变小：但bss变大，费解。。 text data bss dec hex filename 1099 560 8 1667 683 simplest 6、加入未初始化的全局变量和全局与局部静态变量 1 #include&lt;stdio.h&gt; 2 static long gs=12; 3 int golbala=6; 4 5 6 static long gsl; 7 int gi; 8 int main() 9 { 10 static int staticn; 11 static int statica=3; 12 int locala; 13 int localb=3; 14 return 0; 15 } 汇编没有看到什么变化： .file “simplest.c” .data .align 8 .type gs, @object .size gs, 8gs: .quad 12 .globl golbala .align 4 .type golbala, @object .size golbala, 4golbala: .long 6 .local gsl .comm gsl,8,8 .comm gi,4,4 .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $3, -4(%rbp) movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE0: .size main, .-main .data .align 4 .type statica.2290, @object .size statica.2290, 4statica.2290: .long 3 .local staticn.2289 .comm staticn.2289,4,4 .ident “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609” .section .note.GNU-stack,””,@progbits .o文件：+12 未包含未初始化的全局变量text data bss dec hex filename 74 16 12 102 66 simplest.o elf:+16 未包含未初始化的全局变量text data bss dec hex filename 1099 560 24 1683 693 simplest 至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同 参考：程序员的自我修养]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_debug_layout_dynamic]]></title>
    <url>%2F2018%2F05%2F20%2Fcpp-debug-layout-dynamic%2F</url>
    <content type="text"><![CDATA[c执行期内存布局和调试：在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等１、将目标文件装入: １）重定位－－－ 放在内存哪里 2) 等待调度执行这里可以使用gdb进行调试查看 一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).一个进程主要包括： 在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等 栈区 高地址到低地址堆区 低地址到高地址bss数据代码 以下将从两个维度进行对一个程序被执行成进程时，内存的情况： １、各种段区的内存分布 ２、gdb 调试程序执行时的过程。－－可能涉及到汇编 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 1、gdb 常用的命令和用法：1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令 2)设置断点： b 行号b 函数名b 行号 if 条件eg:break main / b main 删除断点:delete 行号 3)列出代码l /list 4)运行，start 跳转到断点:c/continue r/run until 行号 运行直到该行5)观察变量b和地址watch b 若变量值发生变化，则程序停止 p/print b 看变量值 p/print &amp;b 看变量地址 i locals info registers 显示所有寄存器的值 查看特定内存位置的值如： print/x $eax 显示为16进制 print/t 2进制， print/d 十进制,x/nyz : n表示字段数，y为输出格式，z是字段长度 ６）单步调试 n/next / s/step 7) 保存断点： info b 查看断点信息 save breakpoint fig.dp 保存断点 读取断点文件： gdb hello -x fig.dp 退出quit http://bbs.chinaunix.net/thread-150524-1-1.html 2 使用kdbg 界面版本gdb 在gcc … -g后，用kdbg打开即可、 查看程序运行时各个地址： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;sys/types.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#define SHW_ADR(ID,I) printf("the id %s \t is at adr:%8X\n",ID,&amp;I);extern etext,edata,end;char *cptr="Hello World\n";char buffer1[25];int main(void)&#123; void showit(char *); int i=0; printf("Adr etext:%8x\tAdr edata:%8x \t Adr end :%8x \n\n",&amp;etext,&amp;edata,&amp;end); SHW_ADR("main",main); SHW_ADR("showit",showit); SHW_ADR("cptr",cptr); SHW_ADR("buffer1",buffer1); SHW_ADR("i",i); strcpy(buffer1,"A demonstration\n"); write(1,buffer1,strlen(buffer1)+1); for(;i&lt;1;++i) showit(cptr); return 0;&#125;void showit(char *p)&#123; char *buffer2; SHW_ADR("buffer2",buffer2); if((buffer2=(char *)malloc((unsigned)(strlen(p)+1)))!=NULL) &#123; strcpy(buffer2,p); printf("%s",buffer2); free(buffer2); &#125; else &#123; printf("Allocation error.\n"); exit(1); &#125;&#125; －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;unistd.h&gt;#include &lt;alloca.h&gt;extern void afunc(void);extern etext,edata,end;int bss_var; //no init globel data must be in bssint data_var=42; //init globel data must be in data#define SHW_ADR(ID,I) printf("the %8s\t is at adr:%8x\n",ID,&amp;I); //the macro to printf the addrint main(int argc,char *argv[])&#123; char *p,*b,*nb; printf("Adr etext:%8x\t Adr edata %8x\t Adr end %8x\t\n",&amp;etext,&amp;edata,&amp;end); printf("\ntext Location:\n"); SHW_ADR("main",main); //text section function SHW_ADR("afunc",afunc); //text section function printf("\nbss Location:\n"); SHW_ADR("bss_var",bss_var); //bss section var printf("\ndata location:\n"); SHW_ADR("data_var",data_var); //data section var printf("\nStack Locations:\n"); afunc(); p=(char *)alloca(32); //alloc memory from statck if(p!=NULL) &#123; SHW_ADR("start",p); SHW_ADR("end",p+31); &#125; b=(char *)malloc(32*sizeof(char)); //malloc memory from heap nb=(char *)malloc(16*sizeof(char)); printf("\nHeap Locations:\n"); printf("the Heap start: %p\n",b); printf("the Heap end:%p\n",(nb+16*sizeof(char))); printf("\nb and nb in Stack\n"); SHW_ADR("b",b); SHW_ADR("nb",nb); free(b); free(nb);&#125;void afunc(void)&#123; static int long level=0; //data section static var int stack_var; //temp var ,in stack section if(++level==5) &#123; return; &#125; SHW_ADR("stack_var in stack section",stack_var); SHW_ADR("Level in data section",level); afunc();&#125;]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_jni]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-jni%2F</url>
    <content type="text"><![CDATA[a example of JNI static way:first step: write a middle java file:mkdir jnicd jni/vim TestJni.java import java.util.*; public class TestJni { public native void xprint(String content); static { System.loadLibrary(&quot;TestJni&quot;); } } javac TestJni.java and make a class then javah -jni TestJni to make a .h file: /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class TestJni */ #ifndef _Included_TestJni #define _Included_TestJni #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: TestJni * Method: xprint * Signature: (Ljava/lang/String;)V */ JNIEXPORT void JNICALL Java_TestJni_xprint (JNIEnv *, jobject, jstring); #ifdef __cplusplus } #endif #endif step two write jni file.c:TestJni.c: #include&lt;jni.h&gt; #include&lt;stdio.h&gt; #include &quot;TestJni.h&quot; JNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content) { const jbyte *str=(const jbyte*)(*env)-&gt;GetStringUTFChars(env,content,JNI_FALSE); printf(&quot;hello--wo%s \n&quot;,str); (*env)-&gt;ReleaseStringUTFChars(env,content,(const char*)str); return; } three build .so libcc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c four write a test:hellow.javaimport java.util.*; public class hellow { public static void main(String argc[]) { new hellow(); } public hellow() { new TestJni().xprint(&quot;hi my name is keee&quot;); } } question:如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径： java -Djava.library.path=’.’ HelloWorld或者输入命令：export LD_LIBRARY_PATH=“HelloWorld路径”:$LD_LIBRARY_PATH 设置环境变量 然后再 java HelloWorld 一样OK referencehttp://www.cnblogs.com/bastard/archive/2012/05/17/2506877.htmlhttp://www.cnblogs.com/wzben/p/5733571.html a example of JNI dynamic way:step 1:write a TestJni.java public class SimpleJni{ static { System.out.println(&quot;[java] static code block,start load shared library...&quot;); System.loadLibrary(&quot;SimpleJni&quot;); System.out.println(&quot;[java]load library end...&quot;); } static native int add(int a,int b); public static void main(String args[]) { System.out.println(&quot;[java] in main...&quot;); System.out.println(&quot;[java] 3+4=&quot;+SimpleJni.add(3,4)); System.out.println(&quot;end...&quot;); } } step 2:write a Jni file: #include &lt;jni.h&gt; #include&lt;stdio.h&gt; const char *classPathName=&quot;com/bt/jni/SimpleJni&quot;; jint myadd(JNIEnv *env,jobject thiz,jint a,jint b) { return a+b; } static JNINativeMethod methods[]={ {&quot;add&quot;,&quot;(II)I&quot;,(void*)myadd},}; int registerNatives(JNIEnv *env) { jclass clazz; clazz=(*env)-&gt;FindClass(env,classPathName); if(NULL==clazz){ printf(&quot;[C] FindClass fail\n&quot;); goto failed; } if (0&gt;(*env)-&gt;RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0]))){ printf(&quot;RegisterNatives fail.\n&quot;); goto failed; } return JNI_TRUE; failed: return JNI_FALSE; } jint JNI_OnLoad(JavaVM *vm,void *reserved) { JNIEnv *env=NULL; jint result=-1; void **env_p=NULL; printf(&quot;start register native func\n&quot;); env_p=(void**)&amp;env; if(JNI_OK!=(*vm)-&gt;GetEnv(vm,env_p,0x00010006)){ printf(&quot;get env failed..\n&quot;); goto err; } if(JNI_TRUE!=registerNatives(env)){ printf(&quot;register fail...exit....\n&quot;); goto err; } result=0x00010006; err: return result; } step use:1.首先编写SimpleJni.java和simpel_jni.c 2.编译java和c文件$ java -d . SimpleJni.java$gcc -fPIC -I$JAVA_HOME/include/ -I$JAVA_HOME/include/linux/ -o libsimpleJni.so simple_jni.c 3.执行 $java -Djava.library.path=. com.bt.jni.SimpleJni other example:java file: import java.util.*; public class TestJni { public native void xprint(String content); static { System.loadLibrary(“TestJni”); } public native static String native_hello(); } JNI file: #include&lt;jni.h&gt; #include&lt;stdio.h&gt; //#include &quot;TestJni.h&quot; #include&lt;iostream&gt; using namespace std; void xprint(JNIEnv *env,jobject obj,jstring content) { // const jbyte *str=(const jbyte*)(env-&gt;GetStringUTFChars(env,content,JNI_FALSE)); //printf(&quot;hello--wo%s \n&quot;,str); // env-&gt;ReleaseStringUTFChars(env,content,(const char*)str); cout&lt;&lt;&quot;here:&quot;&lt;&lt;content&lt;&lt;endl; return; } static jstring native_hello(JNIEnv *env,jobject object) { return (env)-&gt;NewStringUTF(&quot;keshixi&quot;); } static JNINativeMethod method_table[]={ { &quot;xprint&quot;,&quot;(Ljava/lang/String;)V&quot;,(void*)xprint}, {&quot;native_hello&quot;,&quot;()Ljava/lang/String;&quot;,(void*)native_hello} // {,,(void*)xprint},{,,(void*)native_hello} }; jint JNI_OnLoad(JavaVM *jvm,void *reserved){ JNIEnv *env; if(jvm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6)!=JNI_OK){ return -1; } jclass clz=env-&gt;FindClass(&quot;TestJni&quot;); if(clz==NULL) { return JNI_FALSE; } if(env-&gt;RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK){ return JNI_VERSION_1_6; } } ####reference:jni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行 动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子 另外可以作为ndk在android中使用及在android stdio也可以直接生成so 一些链接：android_jni_ndk:http://www.cnblogs.com/wzben/p/5733571.html动态注册无运行实例：http://www.linuxidc.com/Linux/2017-02/140130.htm静态注册：http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html动态注册：有实例http://www.linuxidc.com/Linux/2017-02/140129.htm www.fer.unizg.hr/_download/repository/jni.pdf文档]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_adb]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-adb%2F</url>
    <content type="text"><![CDATA[android adb command从android群英传中学习到额外的几个adb指令，是之前没接触到的：adb list targetsadb install -r xx.apk -r为覆盖adb shell dfadb shell pm list packages -fadb shell input keyevent 3 －－模拟按键输入，这里为点击home建adb shell touchscreen ..模拟滑动adb shell dumpsys 监听Activity运行状态adb shell screenrecord /sdcard/demo.mp4 录制 屏幕adb shell am start -n 包名/包名＋类名 更多，见google develop中android studio的部分另在源码目录中/system/core/toolbox 和/frameworks/base/cmds为所有ADB命令和shell命令来源]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_AndroidManifest]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-AndroidManifest%2F</url>
    <content type="text"><![CDATA[一个典型的androidmanifest文件：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.ksx.helloworld&quot;&gt; &lt;!-- more --&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;hallo&quot;//app的名字和显示在bar上的文字 android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt;//活动的注册 &lt;android:label=&quot;this is hallo&quot;&gt;//会覆盖上面的 &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;//声明为主活动 &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_makefirst_app]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-makefirst-app%2F</url>
    <content type="text"><![CDATA[install and make first app20170608今天主要是安装了android-studio环境并成功开发第一个helloworld app 在模拟器和手机上运行，下面是整个教程：在ubuntu下 1 安装java-jdk:a 先下载java-jdk:Java SE Development Kit 8 Downloadshttp://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html下载对应系统的版本 b 下载到某个目录，解压到要安装的目录：如：/usr/jdk-8/ c 设置全局环境变量：如上述的安装目录，则将export JAVA_HOME=/usr/jdk-8export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin添加到/etc/profile文件中，在末尾另起一行添加 d 使用source /etc/profile命令使刚才配置的信息生效 e 测试是否成功：java -version测试,编写java文件：public class test{ public static void main(String[] args){ System.out.println(“hello world”); }}保存为test.java，生成字节码：javac test.java运行:java test 2 安装android-studio:a 下载：在官网或者其他网站下载后b 按照installion说明进行：一般是先选择要安装的目录：如/usr/android-studioc 直接在终端,进入bin目录后:./studio.shd 还有其他配置．比如在任意目录都能打开软件．e 其他见说明文件等 3 第一个app helloworld在模拟器上运行打开软件－－&gt;选择新建一个工程，适当选择之后-&gt;选择build-&gt;make project-&gt;点击run––&gt;会提示选择安装下载模拟器–&gt;选择合适的，最好不要是带锁的－－－&gt;之后会提示成功．再选择建立一个模拟器，之后就可以了 注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm如果不能运行x86的，可能需要安装kvm:也可以使用genymotion模拟器 4 安装kvm可选要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。首先要确定你的cpu满足要求，下面有几个命令可以参考： $ egrep -c ‘(vmx|svm)’ /proc/cpuinfo4 打印的值不为0即可。 下面安装kvm： $ sudo apt-get install qemu-kvm$ sudo adduser linc kvm$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils$ sudo adduser linc libvirtd (linc为用户名，适当改）检验安装是否成功： $ sudo virsh -c qemu:///system list Id Name State运行，在有模拟器的目录中：如/home/ksx/Android/Sdk/emulator/emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm 使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。 如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。 5在手机上运行app首先连接手机，打开usb调试还是一样，但是选择app那里不是app,而是选择Edit Configurations之后选择usb device，ok，就可以了，接着运行 关于项目结构模式：默认为android设置为project可以看到整个完整的目录结构： .gradle和.idea 为自动生成 app build 编译时自动生成的文件，不用太关心 gradle 包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle .gitignore build.gradle gradle.properties 全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本 gradlew 和gradlew.bat在命令行中执行gradle命令 local.properties 指定本机android sdk路径 setting.gradle指定项目中引入的模块 app目录下 build 为自动生成，同上 lib 项目使用的第三方库 test 测试用例 proguard-rules.pro 代码混淆规则 build gradle intruducegradle Groovy 领域语言 DSL 摒弃了Ant 和Maven 在app 外有一个 build.gradle。在app中有一个build.gradle 在外面的 gradle 也可以构建c++等项目，buildscript { repositories { jcenter() //代码托管仓库 利用它可以轻松引用jcenter开源项目 } dependencies { classpath &apos;com.android.tools.build:gradle:2.3.2&apos; //声明构建的是android // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { jcenter() }} task clean(type: Delete) { delete rootProject.buildDir} app中apply plugin: ‘com.android.application’ //表明为android 应用程序模块，为com.android.library表示库模块 android { //安卓闭包 compileSdkVersion 25 //项目的编译版本，25为API 25,对应android 7.1 buildToolsVersion “25.0.3” //项目构建工具版本 defaultConfig { applicationId “org.example.myactivity1” 项目包名 minSdkVersion 25 //项目最低兼容的android系统版本 targetSdkVersion 25 //表明如22表示只在22测试充分，如不启动运行时权限，android６ 的运行时权限就不会加，表明只在5上做充分测试 versionCode 1 项目版本编号 versionName “1.0” 项目版本名 testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner” } buildTypes {//分debug和release版本 release { minifyEnabled false //是否混淆代码 proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’//混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件 } }} dependencies {//分本地依赖，库依赖和远程依赖 compile fileTree(dir: ‘libs’, include: [‘*.jar’]) //本地依赖声明 androidTestCompile(‘com.android.support.test.espresso:espresso-core:2.2.2’, { exclude group: ‘com.android.support’, module: ‘support-annotations’ }) compile ‘com.android.support:appcompat-v7:25.3.1’ // 依赖库 compile ‘com.android.support.constraint:constraint-layout:1.0.2’ testCompile ‘junit:junit:4.12’ //测试用例库} 其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_howto_makeapk_cmd]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-howto-makeapk-cmd%2F</url>
    <content type="text"><![CDATA[how to make a android by cmd :在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni way 1:方法１prepareandroid studio 创建了一个工程，然后手动在命令行打包，进入工程里的. 或者direct use andrid create project创建 cd ~/Desktop/FirstTest/app/src/mainmkdir genmkdir buildmkdir out 在android工程目录下建立Makefile文件，添加如下代码： SDK=~/Android/Sdk BUILD_TOOLS=$(SDK)/build-tools/25.0.3 PLATFORMS=$(SDK)/platforms/android-25 aapt=$(BUILD_TOOLS)/aapt dx=$(BUILD_TOOLS)/dx aidl=$(BUILD_TOOLS)/aidl apkbuilder=$(SDK)/tools/apkbuilder2 //后面不支持apkbuilder所以 adb=$(SDK)/platform-tools/adb 资源编译，生成 R.javaaapt_task: $(aapt) package \ -f \ #如果编译出来的文件已经存在，强制覆盖 -M AndroidManifest.xml \ # Mainifest.xml 的路径 -I $(PLATFORMS)/android.jar \ # 某个版本平台的 android.jar 的路径 #依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:... -S res/ \ # res 文件夹路径 -J gen/ \ # 生成 R.java 的输出目录 -m #使得生成的包的目录放在 -J 参数指定的目录 代码编译，生成 .classjavac_task: javac -source 1.7 -target 1.7 \ # 使用 jdk1.8 编译 1.7 的 .class 文件 -encoding UTF-8 \ -bootclasspath $(PLATFORMS)/android.jar \ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:... -d build/ \ #指定放置生成的类文件的位置 java/thereisnospon/dextest/*.java \ gen/thereisnospon/dextest/*.java \ 生成 .dexdx_task: $(dx) --dex --output=build/classes.dex \ build 资源文件初始包resapk_task: $(aapt) package -f \ -M AndroidManifest.xml \ -I $(PLATFORMS)/android.jar \ -S res/ \ -F out/resources 将.dex 文件加入到资源文件初始包中 注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行 apk_task: java -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \ com.android.sdklib.build.ApkBuilderMain \ Demo.apk -v -u -z src/main/out/resources\ -f src/main/build/classes.dex -rf src 签名，使用debug的签名signer: jarsigner -verbose \ -keystore ~/.android/debug.keystore \ -storepass android \ -keypass android \ Demo.apk androiddebugkey 一次性打包pkg: make apk_task make signer 卸载apkuninstall: $(adb) uninstall thereisnospon.dextest 安装apkinstall: $(adb) install out/app.apk 运行run: make pkg make uninstall make install $(adb) shell am start -n thereisnospon.dextest/ thereisnospon.dextest.MainActivity 方法２，用gradle,首先用AS 建立工程，之后在工程文件下，之星执行，gradle cleangradle build即生成apk文件]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android_will_write]]></title>
    <url>%2F2018%2F05%2F20%2Fandroid-will-write%2F</url>
    <content type="text"><![CDATA[#test categoriesthis is the android categories to test]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test_article_picture]]></title>
    <url>%2F2018%2F05%2F20%2Ftest-article-picture%2F</url>
    <content type="text"><![CDATA[##this is a test of pictureend]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ksance test article]]></title>
    <url>%2F2018%2F05%2F19%2Fksance-test-article%2F</url>
    <content type="text"><![CDATA[this is a test article by ksance]]></content>
  </entry>
</search>
