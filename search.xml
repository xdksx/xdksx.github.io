<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cprogram_generate</title>
    <url>/2021/02/20/cprogram-generate/</url>
    <content><![CDATA[<h3 id="关于编译链接执行，编译器和cpu相关"><a href="#关于编译链接执行，编译器和cpu相关" class="headerlink" title="关于编译链接执行，编译器和cpu相关"></a>关于编译链接执行，编译器和cpu相关</h3><p>目标： 学完这个部分的知识和调试方法后，一方面可以在写程序时，减少编译错误等，在遇到编译和运行时错误，可以更快的解决或者知道怎么解决，用什么工具可以<br>更快的解决，另一方面，在处理cpu高载，dump问题时，能知道怎么处理和更好的处理； <a id="more"></a></p>
<h4 id="预处理，编译，链接实践和相关gnu工具"><a href="#预处理，编译，链接实践和相关gnu工具" class="headerlink" title="预处理，编译，链接实践和相关gnu工具"></a>预处理，编译，链接实践和相关gnu工具</h4><h5 id="c-c-的预处理，编译，静态链接，运行时动态链接的基本原理和调试工具；"><a href="#c-c-的预处理，编译，静态链接，运行时动态链接的基本原理和调试工具；" class="headerlink" title="c/c++的预处理，编译，静态链接，运行时动态链接的基本原理和调试工具；"></a>c/c++的预处理，编译，静态链接，运行时动态链接的基本原理和调试工具；</h5><p>1) 预处理阶段<br>c/c++是编译类型的语言，即c/c++源文件，是比较符合人类语言的文本文件，需要将这个文件翻译为机器能直接执行的可执行文件，这个翻译成可执行文件的过程，就是编译的过程；<br>运行： 可执行文件是怎么运行的，见下的说明；</p>
<p>程序在编译的过程中，需要经过几个阶段，第一个阶段是预处理阶段：<br>在正式的编译阶段之前进行。预处理阶段将根据已放置在文件中的预处理指令来修改源文件的内容。如#include指令就是一个预处理指令，它把头文件的内容添加到.cpp文件中。<br>预处理指令，不是真正的程序语句，而是给预处理器的命令；</p>
<p>预处理指令不止于#include,还有：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span></span></span><br><span class="line"><span class="meta">#end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span></span></span><br><span class="line">一些已定义好的宏：</span><br><span class="line">__LINE__	整数值，表示当前正在编译的行在源文件中的行数。</span><br><span class="line">__FILE__	字符串，表示被编译的源文件的文件名。</span><br><span class="line">__DATE__	一个格式为 <span class="string">"Mmm dd yyyy"</span> 的字符串，存储编译开始的日期。</span><br><span class="line">__TIME__	一个格式为 <span class="string">"hh:mm:ss"</span> 的字符串，存储编译开始的时间。</span><br><span class="line">__cplusplus	整数值，所有C++编译器都定义了这个常量为某个值。如果这个编译器是完全遵守C++标准的，它的值应该等于或大于<span class="number">199711L</span>，具体值取决于它遵守的是哪个版本的标准。</span><br><span class="line">ref: 见手册；</span><br></pre></td></tr></table></figure></p>
<p>预处理阶段，是预处理器对预处理指令的解析，并将解析后的内容输出出来或者到下个阶段的输入；<br>实践：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">gcc -E test.c -o test.i 或 gcc -E test.c  或用cpp</span><br><span class="line">将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件：</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">"simplest.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"simplest.c"</span></span><br><span class="line">stdio.h的内容在这里铺开;</span><br><span class="line">包含了各种函数的声明；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他c/cpp文件也是一样，但是一个程序(进程)只能有一个main函数<br>PS:关于g++和gcc的不同： g++ 比gcc 多了一些库的链接功能，当使用了c++的标准库的时候，必须用g++;</p>
<p>2) 编译阶段；<br>这个阶段，编译器会把每个实现文件，结合头文件编译成中间文件(其实编译过程是不需要头文件的，原因是一些文件中会引用头文件，所以需要，而也可以引用.c文件，但是会出现重复定义，而声明是可以重复)，一般是一个二进制.o文件，并进行相关的编译器优化，即将一些语句顺序进行调节等；<br>先把源文件翻译成汇编文件，再通过汇编器将汇编文件翻译为二进制文件；<br>一个例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">m</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>gcc -S hh.cpp<br>生成hh.s:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	.file	<span class="string">"hh.cpp"</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	_Z1mv</span><br><span class="line">	.type	_Z1mv, @function</span><br><span class="line">_Z1mv:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">	movl	$<span class="number">3</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">	movl	<span class="number">-4</span>(%rbp), %eax</span><br><span class="line">	popq	%rbp</span><br><span class="line">	.cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	_Z1mv, .-_Z1mv</span><br><span class="line">	.ident	<span class="string">"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4"</span></span><br><span class="line">	.section	.note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure>
<p>暂时不解析</p>
<p>接着通过汇编器将汇编文件翻译为.o中间文件，这里汇编器其实已经包含到gcc中了，也可以自己下载一个特定平台的比如：NASM<br>输出可执行程序时，必须实现入口函数，比如main;<br>gcc -o main main.s</p>
<p>3) 关于编译时的链接：<br>我们在编译一个完整的程序时，除了指定含有main函数的程序文件外，这个文件还可能依赖定义在其他源程序中的函数，这个时候，编译时需要指定如：<br>gcc -o main main.cpp func.cpp …<br>有时候这些源文件以编译好的.o的形式呈现，也可以进行：gcc -o main main.cpp func.o<br>而当许多.o需要指定比较麻烦，所以库出现了，用来将.o文件汇总，分为两种形式，一种是静态库，一种是动态库；<br>静态库，就是在编译时将文件的执行代码都聚合到可执行文件中，包括调用的功能函数等，执行时不需要额外的库支持；编译出来的可执行文件会比较大；<br>动态库，即在编译时只是将调用的函数符号指定到符号表中，在执行时才去系统默认库路径(头文件指定的)寻找库,并链接该函数执行；</p>
<p>静态链接：在编译时，要指定链接的静态库，包括位置等；<br>eg:<br>gcc -o main main.cpp func.a /home/zhangsan/lib/funall.a local/local.a<br>动态链接：编译时，需要指定链接的动态库，包括位置等；默认会找默认位置的动态库<br>gcc -o main main.cpp -L./xxx   -lcurl -lpthread<br>-L./xx 为指定了目录下有动态链接库，也可以链接成功；<br>注意形式为：libxxx.so 链接为 -lxxx<br>在运行的时候：<br>ldd a.out这种可以得到可执行文件希望在哪里找到库；而一般要设置export LD_LIBRARY_PATH=/home/think/c++/ 或者放在<br>系统默认搜索路径下，或者修改系统文件/etc/ld.so.conf，添加路径，运行ldconfig命令<br>默认搜索路径：<br>/lib<br>/usr/lib<br>/usr/local/lib </p>
<p>4) 关于目标文件：<br>在编译时除了可以生成可执行文件，还可以生产静态库，动态库，中间文件，汇编文件等，这里看静态库和动态库的生成规则<br>生成静态库文件：<br>ar rvs libfunc.a func.o func2.o<br>man ar 查看更多<br>生成动态库文件:<br>gcc func.cpp  -fPIC -shared -o libfunc.so<br>-shared 该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接<br>Produce a shared object which can then be linked with other objects to form an executable.  Not all systems support this option.  For predictable results, you must also specify the same</p>
<p>-fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。<br>更多见man gcc<br>5) 总：<br>一个完整的gcc/g++编译命令，除了指定上面的内容，还需要指定头文件的位置，默认目录有哪些？，优化选项，-c/-o/-S/-E其他选项等，这里把这些汇总下，并给上参考地址方便查阅；man gcc<br>-c:  -c  Compile or assemble the source files, but do not link.  The linking stage simply is not done.  The ultimate output is in the form of an object file for each source file.<br>-I: 指定头文件的路径<br>gcc -I. -I /home/include/ ..<br>指定了头文件路径后，在#include时可以省略路径；</p>
<h5 id="c-c-的反汇编，二进制查看，可执行文件格式等；"><a href="#c-c-的反汇编，二进制查看，可执行文件格式等；" class="headerlink" title="c/c++的反汇编，二进制查看，可执行文件格式等；"></a>c/c++的反汇编，二进制查看，可执行文件格式等；</h5><p>1) 可执行文件的结构：<br>think@think-VirtualBox:~/c++$ size hh.o<br>   text       data        bss        dec        hex    filename<br>     72          0          0         72         48    hh.o<br>代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量;还有就是代码本身的0101机器码<br>数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）<br>bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null</p>
<p>2）可执行文件的查看工具等；<br>为了看清楚可执行文件的结构，也可以使用如下工具，在unix类系统下使用，elf等；<br>上面的hh.cpp编译为.o后：readelf工具可以清晰看到elf文件的魔数，架构，大小端等信息；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~/c++$ readelf -a hh.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              <span class="number">2'</span>s complement, little endian</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       <span class="number">0</span></span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  Version:                           <span class="number">0x1</span></span><br><span class="line">  Entry point address:               <span class="number">0x0</span></span><br><span class="line">  Start of program headers:          <span class="number">0</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">272</span> (bytes into file)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  Size of <span class="keyword">this</span> header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">0</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">0</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">11</span></span><br><span class="line">  Section header <span class="built_in">string</span> table index: <span class="number">8</span></span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000040</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .data             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000050</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">3</span>] .bss              NOBITS           <span class="number">0000000000000000</span>  <span class="number">00000050</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">4</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000050</span></span><br><span class="line">       <span class="number">000000000000002</span>c  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">5</span>] .note.GNU-<span class="built_in">stack</span>   PROGBITS         <span class="number">0000000000000000</span>  <span class="number">0000007</span>c</span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .eh_frame         PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000080</span></span><br><span class="line">       <span class="number">0000000000000038</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">7</span>] .rela.eh_frame    RELA             <span class="number">0000000000000000</span>  <span class="number">000004b</span>8</span><br><span class="line">       <span class="number">0000000000000018</span>  <span class="number">0000000000000018</span>           <span class="number">9</span>     <span class="number">6</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">8</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">000000b</span>8</span><br><span class="line">       <span class="number">0000000000000054</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">9</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">000003</span>d0</span><br><span class="line">       <span class="number">00000000000000</span>d8  <span class="number">0000000000000018</span>          <span class="number">10</span>     <span class="number">8</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">000004</span>a8</span><br><span class="line">       <span class="number">000000000000000</span>e  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br><span class="line"></span><br><span class="line">There are no section groups in <span class="keyword">this</span> file.</span><br><span class="line"></span><br><span class="line">There are no program headers in <span class="keyword">this</span> file.</span><br><span class="line"></span><br><span class="line">Relocation section '.rela.eh_frame' at offset 0x4b8 contains 1 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line"><span class="number">000000000020</span>  <span class="number">000200000002</span> R_X86_64_PC32     <span class="number">0000000000000000</span> .text + <span class="number">0</span></span><br><span class="line"></span><br><span class="line">The decoding of unwind sections <span class="keyword">for</span> machine type Advanced Micro Devices X86<span class="number">-64</span> is <span class="keyword">not</span> currently supported.</span><br><span class="line"></span><br><span class="line">Symbol table '.symtab' contains 9 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS hh.cpp</span><br><span class="line">     <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> </span><br><span class="line">     <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">2</span> </span><br><span class="line">     <span class="number">4</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">3</span> </span><br><span class="line">     <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span> </span><br><span class="line">     <span class="number">6</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">6</span> </span><br><span class="line">     <span class="number">7</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">4</span> </span><br><span class="line">     <span class="number">8</span>: <span class="number">0000000000000000</span>    <span class="number">16</span> FUNC    GLOBAL DEFAULT    <span class="number">1</span> _Z1mv</span><br><span class="line"></span><br><span class="line">No version information found in <span class="keyword">this</span> file.</span><br></pre></td></tr></table></figure></p>
<p>3）如何反汇编；<br>objdump 工具，除了可以反汇编，还可以查看二进制文件等：<br>objdump -s hh.o : 查看十六进制<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">think@think-VirtualBox:~/c++$ objdump -s  hh.o</span><br><span class="line"></span><br><span class="line">hh.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> <span class="number">0000</span> <span class="number">554889e5</span> c745fc03 <span class="number">0000008b</span> <span class="number">45f</span>c5dc3  UH...E......E.].</span><br><span class="line">Contents of section .comment:</span><br><span class="line"> <span class="number">0000</span> <span class="number">00474343</span> <span class="number">3</span>a202855 <span class="number">62756e74</span> <span class="number">7520342</span>e  .GCC: (Ubuntu <span class="number">4.</span></span><br><span class="line"> <span class="number">0010</span> <span class="number">382e342</span>d <span class="number">32756275</span> <span class="number">6e747531</span> <span class="number">7e31342</span>e  <span class="number">8.4</span><span class="number">-2u</span>buntu1~<span class="number">14.</span></span><br><span class="line"> <span class="number">0020</span> <span class="number">30342e34</span> <span class="number">2920342</span>e <span class="number">382e3400</span>           <span class="number">04.4</span>) <span class="number">4.8</span><span class="number">.4</span>.    </span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> <span class="number">0000</span> <span class="number">14000000</span> <span class="number">00000000</span> <span class="number">017</span>a5200 <span class="number">01781001</span>  .........zR..x..</span><br><span class="line"> <span class="number">0010</span> <span class="number">1b</span>0c0708 <span class="number">90010000</span> <span class="number">1</span>c000000 <span class="number">1</span>c000000  ................</span><br><span class="line"> <span class="number">0020</span> <span class="number">00000000</span> <span class="number">10000000</span> <span class="number">00410e10</span> <span class="number">8602430</span>d  .........A....C.</span><br><span class="line"> <span class="number">0030</span> <span class="number">064b</span>0c07 <span class="number">08000000</span>                    .K......</span><br></pre></td></tr></table></figure></p>
<p> objdump -d hh.o: 反汇编：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> think@think-VirtualBox:~/c++$ objdump -d  hh.o</span><br><span class="line"></span><br><span class="line">hh.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;_Z1mv&gt;:</span><br><span class="line">   <span class="number">0</span>:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">   <span class="number">1</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line">   <span class="number">4</span>:	c7 <span class="number">45</span> fc <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	movl   $<span class="number">0x3</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   b:	<span class="number">8b</span> <span class="number">45</span> fc             	mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">   e:	<span class="number">5</span>d                   	pop    %rbp</span><br><span class="line">   f:	c3                   	retq</span><br></pre></td></tr></table></figure></p>
<p> objdump 查看各个段：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> think@think-VirtualBox:~/c++$ objdump -x hh.o</span><br><span class="line"></span><br><span class="line">hh.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line">hh.o</span><br><span class="line">architecture: i386:x86<span class="number">-64</span>, flags <span class="number">0x00000011</span>:</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address <span class="number">0x0000000000000000</span></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00000010</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000050</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000050</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .comment      <span class="number">0000002</span>c  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000050</span>  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">4</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000007</span>c  <span class="number">2</span>**<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .eh_frame     <span class="number">00000038</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000080</span>  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">SYMBOL TABLE:</span><br><span class="line"><span class="number">0000000000000000</span> l    df *ABS*	<span class="number">0000000000000000</span> hh.cpp</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .text	<span class="number">0000000000000000</span> .text</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .data	<span class="number">0000000000000000</span> .data</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .bss	<span class="number">0000000000000000</span> .bss</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .note.GNU-<span class="built_in">stack</span>	<span class="number">0000000000000000</span> .note.GNU-<span class="built_in">stack</span></span><br><span class="line"><span class="number">0000000000000000</span> l    d  .eh_frame	<span class="number">0000000000000000</span> .eh_frame</span><br><span class="line"><span class="number">0000000000000000</span> l    d  .comment	<span class="number">0000000000000000</span> .comment</span><br><span class="line"><span class="number">0000000000000000</span> g     F .text	<span class="number">0000000000000010</span> _Z1mv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000000020</span> R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure></p>
<h5 id="makefile-make-和-cmake"><a href="#makefile-make-和-cmake" class="headerlink" title="makefile,make 和 cmake"></a>makefile,make 和 cmake</h5><p>单独一个章来记录make,makefile和cmake</p>
<h4 id="运行时："><a href="#运行时：" class="headerlink" title="运行时："></a>运行时：</h4><h5 id="c-c-文件如何执行，动态链接如何进行；"><a href="#c-c-文件如何执行，动态链接如何进行；" class="headerlink" title="c/c++文件如何执行，动态链接如何进行；"></a>c/c++文件如何执行，动态链接如何进行；</h5><p>c/c++可执行文件如何执行呢？<br>可执行文件分为完整的非动态链接的可执行文件和完整的静态链接的可执行文件<br>1）静态链接：在./a.out的时候，会通过触发起一个execl系列函数，起一个进程，并开始执行，执行过程即会创建进程空间，内核管理，内核分时间片运行；<br>即作为一个进程来运行，而进程有自己的生命周期：就绪，运行，阻塞等等，也有各种进程上下文，当前的资源等等；<br>总的来讲： 生命周期，进程管理的私有结构，进程的动态空间：堆，栈，虚拟地址空间，各种阻塞队列等等；<br>2）动态链接：动态链接的可执行文件，需要搜索路径下有依赖的动态库，否则无法运行，在运行时会通过链接的符号等去寻找对应的动态库函数实现，加载调用运行；<br>之后的运行和静态链接基本一致；</p>
<h5 id="gdb基础和gdb常用，手册等；"><a href="#gdb基础和gdb常用，手册等；" class="headerlink" title="gdb基础和gdb常用，手册等；"></a>gdb基础和gdb常用，手册等；</h5><p>当编译时带上-g后即带debug信息，运行时即可以进行gdb 运行；<br>gdb main<br>gdb attach 挂的是线程还是进程？<br>见gdb文章</p>
<h4 id="c-程序执行过程调试例子，注意执行语句先后，编译器优化前后不同"><a href="#c-程序执行过程调试例子，注意执行语句先后，编译器优化前后不同" class="headerlink" title="c++程序执行过程调试例子，注意执行语句先后，编译器优化前后不同"></a>c++程序执行过程调试例子，注意执行语句先后，编译器优化前后不同</h4><h4 id="堆栈空间表现例子"><a href="#堆栈空间表现例子" class="headerlink" title="堆栈空间表现例子"></a>堆栈空间表现例子</h4><p>堆栈空间如何增长呢？<br>跟cpu系统有关，暂时不深究；要知道new/malloc是在堆上分配空间，普通定义数组，变量是在栈上分配空间；<br>struct class这种的，定义一个非指针变量，是放栈还是堆？</p>
<h4 id="多线程相关调试例子；"><a href="#多线程相关调试例子；" class="headerlink" title="多线程相关调试例子；"></a>多线程相关调试例子；</h4><p>1）查看多线程pid: top -Hp pid<br>2) 多线程是系统层面的，多线程的实现可以是用系统的接口，比如posix的pthread,fork进程等，或者用语言的thread ,这种最后也是调用的pthread系列函数；<br>这里默认都是unix系统；<br>3）使用linux系统工具调试多线程程序；</p>
<h4 id="linux-core-dump机制和相关工具"><a href="#linux-core-dump机制和相关工具" class="headerlink" title="linux core-dump机制和相关工具"></a>linux core-dump机制和相关工具</h4><p>1) core-dump是什么？<br>2）core-dump如何触发？</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>compilelink</tag>
      </tags>
  </entry>
  <entry>
    <title>live_media_audioformat</title>
    <url>/2021/02/17/live-media-audioformat/</url>
    <content><![CDATA[<h3 id="音频编码：-aac-adts-wav-mp3-等编码的意义和基本概念"><a href="#音频编码：-aac-adts-wav-mp3-等编码的意义和基本概念" class="headerlink" title="音频编码： aac, adts, wav ,mp3 等编码的意义和基本概念"></a>音频编码： aac, adts, wav ,mp3 等编码的意义和基本概念</h3><ul>
<li>原始音频： 采集后得到的是音频的裸数据：在采集时需要指定采样率，量化位数(一般采样也会有几种协议，比如常见的PCM，里面会自带量化位数指定)，channle数，以及必要的大小端数据等<a id="more"></a></li>
<li><p>音频的裸数据有以下特点，在用Audacity导入原始数据播放时，需要填写相关参数(采样率，量化协议，channel数，数据的大小端情况等)：<br>由此可以知道，在播放裸数据(解释)裸音频数据时，至少需要上面的几个参数；</p>
</li>
<li><p>音频编码在音频裸数据的基础上做了什么？可以用来干嘛?<br>那么对于音频编码来说，主要是在裸数据上做了封装，带了以下几件事：<br>1）加上音频编码的头：主要内容是采样率，channel数，量化协议，大小端等，用来告诉解码器如何解释这个音频；<br>2)  加上其他的元数据：比如音频编码本身的协议标志，版本号，等等<br>3)  带上裸数据，长度size等，有的音频编码会对裸数据进行合理的压缩，去噪等等，减少文件大小等，如opus；</p>
</li>
<li><p>常见的音频编码：AAC,OPUS,FLAC,MP3,SBC,Vorbis等，更多可以看wiki:<br><a href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83</a></p>
</li>
<li><p>如何查看音频编码：最直接的就是用notepad++ ,vim等二进制方式打开，然后对着协议标志看等；<br>或者根据文件名使用工具查看；用播放软件查看文件信息看编码格式；但是只能看元信息；</p>
</li>
<li><p>查看AAC:<br>AAC Audio ES Viewer </p>
<h3 id="音频编码文件容器："><a href="#音频编码文件容器：" class="headerlink" title="音频编码文件容器："></a>音频编码文件容器：</h3></li>
<li>音频为什么需要容器：<br>如果说编码主要是压缩和携带解析的元数据，那容器的出现，除了增加更多元数据信息外，还加了时间戳dts等信息，封装为容器，一个重要的因素是为了和视频封装在一起，音视频<br>做同步解码播放；</li>
<li>音频编码和容器的关系<br> 音频容器是在音频编码的基础上增加了一些信息，和编码格式不同，比如opus编码的容器格式是oggs，是在opus封装为一页一页，并且加了页头；<br> 大部分容器其实可以封装视频和音频；比如Oggs也可以封装视频，只是现在不流行；所以你看到的Oggs基本都是音频的；而纯音频容器：如wav,mp3等</li>
<li>音视频容器常见: flv，avi,mov,mp4,3gp等<h3 id="音频编码流媒体-比如aac是怎么在直播系统中传输的；"><a href="#音频编码流媒体-比如aac是怎么在直播系统中传输的；" class="headerlink" title="音频编码流媒体: 比如aac是怎么在直播系统中传输的；"></a>音频编码流媒体: 比如aac是怎么在直播系统中传输的；</h3>流媒体是在网络传输中流式媒体数据，在网络中传输音视频数据时，也是主要是压缩的数据，比如音频，在网络上传输以opus的流格式，其实可以是oggs封装再加到其他传输协议中；<br>或者是Opus直接封装到完善的协议比如Rtp中；<br>而流媒体考虑到带宽利用率等，往往不会传输太多多余的东西，所以一些头带了的信息就不会重复封装头；<br>总的理解就是： 流媒体传输中，使用适合于音视频传输的(比如专门做了网络优化)的网络协议如Srt,Rtmp等，封装流媒体编码或容器进行传输；</li>
</ul>
]]></content>
      <categories>
        <category>audio</category>
      </categories>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>live_media_video</title>
    <url>/2021/02/17/live-media-video/</url>
    <content><![CDATA[<h3 id="图像科技发展史："><a href="#图像科技发展史：" class="headerlink" title="图像科技发展史："></a>图像科技发展史：</h3><h4 id="图像的本质："><a href="#图像的本质：" class="headerlink" title="图像的本质："></a>图像的本质：</h4><p>图像的本质可以说是反射光的集合，不同的物质分子组成等不同，那么光照射到物质上，有部分频率的光被吸收，剩下的反射出来，就形成不同的<a id="more"></a><br>颜色，反映了物质的基本特征；可以说每个像素点是一维值，就像声音的采样值；但图片还有大小位置，等信息；所以以一个方图为例，有图片的x轴<br>大小，y轴大小，甚至z轴空间信息，反映出来就是光影形成的三维效果；另外还有物体的位置；<br>而声音其实也有这些信息，声音的位置，不同物体的振动不同，在空气中振动的大小等；只是声音这些信息不能像图像一样能被人更好的利用；<br>或者说信息含量比较小；所以自然界中动物不止出现听觉还有视觉；<br>图像作为这种波动类型的物理信号的特点和表示：振幅，频率，相位，波长，共振等等，这些不赘述，有兴趣再翻阅资料；</p>
<h4 id="图像的记录发展史："><a href="#图像的记录发展史：" class="headerlink" title="图像的记录发展史："></a>图像的记录发展史：</h4><pre><code>图像最开始只能通过绘画记录下来，直到后来，人们发现了透镜成像原理和感光物质显像原理，即时记录图像的工具-相机才慢慢被开发出来；
</code></pre><ul>
<li>简单来说，图像的记录经历了一下的时代:<br>图像-<->湿版摄影法： 即通过成像后，一些感光的化学物质记录，形成图像<br>图像<--> 胶卷相机时代：即：图像反射光-&gt;小孔成像-&gt;感光物质曝光底片-&gt;冲洗照片<br>图像<-->数字信号和处理时代：即图像反射光–&gt;光敏电阻(单色)–&gt;电信号–&gt;模数转换–&gt;101010的数字信号–&gt;  像素值-&gt;计算机处理–&gt;屏幕呈现<br>PS:<a href="https://zhuanlan.zhihu.com/p/161200077" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/161200077</a></--></--></-></li>
</ul>
<h4 id="图像基本入门："><a href="#图像基本入门：" class="headerlink" title="图像基本入门："></a>图像基本入门：</h4><img src="/2021/02/17/live-media-video/basic.png" title="This is an example image">
<p>图像由像素点构成，简称像素(Pixel:picture Element）：像素是图像显示的基本单位，通常说一幅图片的大小，例如是1920<em>1080，即长度为1920个像素点，宽度为1080个像素点，乘积为2,073,600，即这个图片是两百万像素的，拍照中常说的也是这个；<br>PPI: 分辨率也是显示器的重要指标，而PPI是Pixels Per Inch，即每英寸像素；即手机或显示器屏幕上每英寸面积可以放多少个像素点；苹果的PPI值高达326<br><img src="/2021/02/17/live-media-video/pixel.png" title="This is an example image"><br>像素堆积成图片，所以像素本身需要颜色；如上那副图；每个像素点用一个数字来代表颜色，人眼的视锥细胞有三种分别过滤红蓝绿，其他颜色按照比例刺激；所以任何一种颜色可以通过R(红色), G(绿色),B(蓝色)按照一定的比例调配出来；这三种颜色被称为三原色；<br>而比例：是R,G,B的取值，分别从0-255，即8bit表示，所以一个像素点用3</em>8bit 即3个字节表示；而可以代表的颜色在256<em>256</em>256种；任何颜色，都可以用这三个值的组合表示；现在可以用画图试试；我们常说的RGB24就是3*8bit的形式；而一个颜色的16进制即是RGB的16进制即如：R:01,G:02,B:03–&gt; 010203</p>
<h4 id="原始图像和原始视频的文件表示和格式："><a href="#原始图像和原始视频的文件表示和格式：" class="headerlink" title="原始图像和原始视频的文件表示和格式："></a>原始图像和原始视频的文件表示和格式：</h4><ul>
<li>原始图像和原始视频：<br> 一个原始的图片是RGB或YUV格式的，即每个像素点都由8*3 24bit/yuv的数据格式，决定即：Red Green Blue<br>一个原始的视频也是没经过编码压缩的，每一帧都是完整的图像；</li>
<li>RGB YUV 表示和打开，修改等：<br><a href="https://blog.csdn.net/leixiaohua1020/article/details/50534150" target="_blank" rel="noopener">https://blog.csdn.net/leixiaohua1020/article/details/50534150</a><br>另外还有 ffmpeg对图片格式的转换，也能转换为rgb,yuv;<br>RGB和OpenCV,可以直接采集后用opencv调试；<br>RGB： 即每个像素由三个通道值组成R G B,都是8bit;<br>YUV:<br>人们常用RGB表示三基色，而且RGB也可以表示出所有颜色。但视觉心理学研究表明，人眼主要是对光的感知，人的视觉系统对光的感知程度用亮度（luminance）和色度（chrominance）两个属性表示，也就是我们常说的YUV。Y就是亮度感知，而色度感知分为两个属性：色相（hue）和色饱和度（saturation）。色相也就是U,是由光波的峰值定义的，描述的是光的颜色；色饱和度V是光波的谱宽定义的，描述的是光的纯度。 采用YUV色度空间比采用RGB颜色空间更利于视频的压缩，也能更有效的表示彩色视频图像<br><a href="https://www.jianshu.com/p/6a361e86ccd5" target="_blank" rel="noopener">https://www.jianshu.com/p/6a361e86ccd5</a><br>实践：<br>1） 先通过ffmpeg 将jpg或其他通用图片格式转换为 yuv或rgb ffmpeg -i 1.jpg -vcodec rawvideo -pix_fmt rgba raw1.rgb<br>2)   通过程序如<a href="https://blog.csdn.net/leixiaohua1020/article/details/50534150" target="_blank" rel="noopener">https://blog.csdn.net/leixiaohua1020/article/details/50534150</a> 或opencv来处理图像；<br>3） 用相关工具打开：<a href="https://github.com/leixiaohua1020/YUVplayer/blob/master/Release/yuvplayer.exe" target="_blank" rel="noopener">https://github.com/leixiaohua1020/YUVplayer/blob/master/Release/yuvplayer.exe</a><br>验证；</li>
<li>图像基本编码：<br>从RGB–&gt;YUV–&gt;JPEG/BMP/JPG/…</li>
<li>视频基本编码：<img src="/2021/02/17/live-media-video/video.png" title="This is an example image">
从yuv-&gt;h264</li>
<li>I,P,B帧和GOP的基本概念：其中I帧也叫关键帧，是一副完整的画面，而P帧则是记录I帧的变化（H.264中通过补偿算法根据I帧得到的差异文件），B帧类似。<br>I 帧：一个可以独立解码的帧，size大<br>P 帧：依赖前面的帧来解码，size小<br>B 帧：依赖前后的帧来解码，size小<br>GOP: 两个I帧之间的间隔，GOP = I(帧内编码帧) + B（双向预测帧） + P（前向预测帧）<br>其中I帧也叫关键帧，是一副完整的画面，而P帧则是记录I帧的变化（H.264中通过补偿算法根据I帧得到的差异文件），B帧类似。再简单点说，如果没有I帧，P帧和B帧也无法解码。这也很好理解，没有原始对比文件，只有差异文件是无法渲染画面的。<br>GOP结构一般两个数字，如M=1，N=2。M指定I帧和P帧之间的距离，N指定两个I帧之间的距离，其他都是B帧填充。如M=1，N=2这里的例子是IDR PB I排序。<br>有些地方会讲IDR帧，其实就是GOP的第一个I帧，这个帧很重要，因为关于首开优化基本上都在去尽可能减小IDR帧的大小</li>
<li>视频的几个参数和影响：<br>帧率：即每秒有多少帧，帧率越大，说明每秒帧数越多，即视频越流畅；若是假设一段10s的视频总帧数在200，则原本帧率为20fps,增大帧率<pre><code>到40fps会导致只需要5s就能放完，即加速了x2; 所以视频加速播放和慢速播放就是控制帧率的大小；
</code></pre>dts：DTS：Decode Time Stamp。DTS主要是标识读入内存中的bit流在什么时候开始送入解码器中进行解码。<br>DTS主要用于视频的解码,在解码阶段使用,每帧都有一个dts值，一般是个数值，一般视频帧之间差30，音频帧之间差20<br>pts:PTS主要用于视频的同步和输出.在display的时候使用.在没有B frame的情况下.DTS和PTS的输出顺序是一样的.<br>音视频同步的概念： 一般在看视频画面时，音频也要跟上嘴型和情节，所以音画同步需要借助dts/pts; 线性传递时，一般是一个音频帧一个视频帧；<pre><code>而音频帧和视频帧的dts也是有序的，如：a1:123 v1: 134 a2: 145 v2: 155
</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>video</category>
      </categories>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>live_media_audio</title>
    <url>/2021/02/17/live-media-audio/</url>
    <content><![CDATA[<h3 id="音频科技发展史："><a href="#音频科技发展史：" class="headerlink" title="音频科技发展史："></a>音频科技发展史：</h3><h4 id="声音的本质："><a href="#声音的本质：" class="headerlink" title="声音的本质："></a>声音的本质：</h4><p>声音的本质是一种振动，可以说是一种一维的物理信号；可以通过敲击，让物体振动产生，并且可以使空气产生振动，从而传播，不过会能量衰减，导致只能传播一定的距离，原始振动<br>能量越大，传输的距离就越大；<a id="more"></a><br>声音作为这种波动类型的物理信号的特点和表示：振幅，频率，相位，波长，共振等等，这些不赘述，有兴趣再翻阅资料；</p>
<h4 id="音频的录制发展史："><a href="#音频的录制发展史：" class="headerlink" title="音频的录制发展史："></a>音频的录制发展史：</h4><p><em>豆瓣有篇文章说的还可以：<a href="https://www.douban.com/group/topic/28212958/" target="_blank" rel="noopener">https://www.douban.com/group/topic/28212958/</a></em></p>
<ul>
<li>简单来说，声音的录制经历了一下的时代:<br>声音-<->动能(机械)的时代： 即通过声波振记器，比如：可以将声波变换成金属针的震动，然后将波形刻录在圆筒形腊管的锡箔上。当针再一次沿着刻录的轨迹行进时，便可以重新发出留下的声音。<br>声音<-->电信号的时代：即：声音–&gt;振动–麦克风振动膜放大–&gt;线圈磁铁–&gt;电信号磁信号： 由磁带记录，播放；<br>声音<-->数字信号和处理时代：即声音–&gt;麦克风–&gt;电信号–&gt;模拟信号处理AD/DA转换成数字信号：具体学习数字信号和模拟信号处理，了解示波器等器件；–&gt;101010的数字信号–&gt;<br>电脑接收和处理–&gt;数字信号转模拟信号AD/DA –&gt;转为声音信号–&gt;扬声器  增加了立体声；<br>PS:<a href="https://zhuanlan.zhihu.com/p/64050348" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/64050348</a><br>ADC=Analog Digital Change 模数转换<br>DAC= Digital Analog Change 数模转换<h4 id="现代声音录制采集处理的基本过程："><a href="#现代声音录制采集处理的基本过程：" class="headerlink" title="现代声音录制采集处理的基本过程："></a>现代声音录制采集处理的基本过程：</h4>即上述的第三个时代，这里稍微详细解释：现代为了提高声音的质量，在采集上也有各种细分： 环境的保证，声音无损传递，放大，麦克风的设计和材料，声音芯片的设计和材料(语音芯片有多种，涉及<br>声音从模拟信号到数字信号的过程：AD/DA转换), 采样也有相关定理：奈奎斯特采样定律；(模拟信号数字化必须经过三个过程，即抽样、量化和编码，以实现话音数字化的脉冲编码调制（PCM，Pulse Coding Modulation）技术。)，至此，完成声音的数字化过程，但是对声音的处理还远不止于此，采集到的声音可能有噪声，对噪声的处理，降噪技术等，采集到的声音的转换，混合，传输<br>识别，智能转文本等等。</--></--></-></li>
</ul>
<h3 id="音频的组成："><a href="#音频的组成：" class="headerlink" title="音频的组成："></a>音频的组成：</h3><h4 id="音频的表示和基本参数："><a href="#音频的表示和基本参数：" class="headerlink" title="音频的表示和基本参数："></a>音频的表示和基本参数：</h4><pre><code>+ 简单介绍PCM 声音如何从模拟信号转换为数字信号：  
</code></pre><img src="/2021/02/17/live-media-audio/pcmall.png" title="This is an example image">
<pre><code>      + 采样：采样是将模拟信号以其带宽两倍以上的频率提取样值，变为在时间轴上离散数据的过程：
         采样率：每秒从连续信号中提取出并组成离散信号的采样个数：用Hz表示；  
         如：
    如音频信号采样率为8000hz。
    可以理解上图采样对应图中 那段电压随时间变化的曲线 为1秒 那下面那个1 2 3 …10那就因该有1-8000个点，即将1秒均分为8000份，依次取出来那8000个点时间 对应的电压值。
      + 量化：
         可以看到，在时间轴上连续的值已经变为离散的了，但是在电压上(y轴)上的值还是可能有无限多个值的情况，所以这个时候需要将电压上的值进行量化,举个例子：
         采样位数： 即描述数字信号所用的位数：如t1时间的电压值V1用8bit的数值表示： 3： 00000011 ，8bit最大可以表示数值为256,16位类似；
         量化精度，即将一个范围的值转换为另一个范围的值，两个值之间的间隔： 比如：将0-3.3V的范围电压值存储在8位的数字里即： 3.3/256=0.0128
         量化： 即比如将0-3.3V的电压值放到8位数字中：即 电压值1.65V对应的值就是128，以此类推；
         量化的后果：量化后的抽样信号与量化前的抽样信号相比较，当然有所失真，且不再是模拟信号。这种量化失真在接收端还原模拟信号时表现为噪声，并称为量化噪声。量化噪声的大小取决于把样值分级“取整”的方式，分的级数越多，即          量化级差或间隔越小，量化噪声也越小。

      + 编码：将量化后得到的类似十进制数字码流经过一定的规则转换为二进制码流进入数字系统的过程；  
         常见的有PCM音频编码：
         PCM协议：  
PCM（PCM-clock、PCM-sync、PCM-in、PCM-out）脉冲编码调制，模拟语音信号经过采样量化以及一定数据排列就是PCM了。理论上可以传   输单声道，双声道立体声和多声道。是数字音频的raw data.
         PCM信号：PCM信号未经过任何编码和压缩处理(无损压缩)。与模拟信号比，它不易受传送系统的杂波及失真的影响。动态范围宽，可得到音质相当好的效果。编码上采用A律13折线编码。
        关于双声道的采样：  
</code></pre><img src="/2021/02/17/live-media-audio/channel.png" title="This is an example image">
<pre><code>  +  关于采样频率：
   人对频率的识别范围是 20HZ - 20000HZ, 如果每秒钟能对声音做 20000 个采样, 回放时就足可以满足人耳的需求.
      8000hz 为电话采样。
      22050 的采样频率是常用的。
      44100已是CD音质, 超过48000的采样对人耳已经没有意义
      对采样率为44.1kHz的AAC（Advanced Audio Coding）音频进行解码时，一帧的解码时间须控制在23.22毫秒内。通常是按1024个采样点一帧。
      而一个采样点，可以理解为就是一个8bit/16bit的音频值/hz
      PS： 音频其实没有帧的概念，音频是一连串的采样值，比如采样率为44.1kHZ，采样精度为16位的音频，你可以算出bitrate（比特率）是4410016kbps，每秒的音频数据是固定的4410016/8 字节。而一般是每次返回1024个采样值；
+ 什么样的采样和音频值位数叫无损呢？
</code></pre><h5 id="音频的采集和表示："><a href="#音频的采集和表示：" class="headerlink" title="音频的采集和表示："></a>音频的采集和表示：</h5><ul>
<li>pcm的格式的raw data数据；<pre><code>在linux下的采集
1）采集白噪音，播放并导入到/null  cat /dev/urandom | padsp tee /dev/audio &gt; /dev/null 
2）采集内存内容到播放audio,和/null cat /dev/mem | padsp tee /dev/audio &gt; /dev/null 
3)  采集白噪音并播放和保存：cat /dev/urandom | padsp tee /dev/audio &gt; /home/some.raw
注意这里是按默认的采样率，声道数，量化位数的；
更多接口：音频的linux下的编程接口；https://docs.google.com/viewerng/viewer?url=https://www.programmer-books.com/wp-content/uploads/2019/06/Linux-Sound-Programming.pdf
</code></pre></li>
<li>音频音量，pcm格式等表示；见上</li>
<li>音频编码情况：<br>WAV:pcm是无损wav文件中音频数据的一种编码方式，但wav还可以用其它方式编码<h5 id="音频的基本参数：采样率，音频值位数，比特率等；"><a href="#音频的基本参数：采样率，音频值位数，比特率等；" class="headerlink" title="音频的基本参数：采样率，音频值位数，比特率等；"></a>音频的基本参数：采样率，音频值位数，比特率等；</h5><h4 id="音频查看的相关工具：Audacity-可以导入原始格式进行播放和查看："><a href="#音频查看的相关工具：Audacity-可以导入原始格式进行播放和查看：" class="headerlink" title="音频查看的相关工具：Audacity 可以导入原始格式进行播放和查看："></a>音频查看的相关工具：Audacity 可以导入原始格式进行播放和查看：</h4>将wav或其他格式转换为pcm: eg:<br>ffmpeg -i file.wav -f s16be -ar 8000 -acodec pcm_s16be file.raw<br>PCM数据格式：即原始的音频采样数据：<br>比如：在得到file.raw后，用audacity播放，用文本编辑器打开，删除一半或一些数据，保存后再次用audacity播放，即可得到剩一半的数据；<br>WAV数据格式：PCM的基础上加上一些头，meta信息<br>其他工具：praat</li>
</ul>
]]></content>
      <categories>
        <category>audio</category>
      </categories>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>live_media_overiew</title>
    <url>/2021/02/17/live-media-overiew/</url>
    <content><![CDATA[<h3 id="音视频基础知识：理论-实践"><a href="#音视频基础知识：理论-实践" class="headerlink" title="音视频基础知识：理论+实践"></a>音视频基础知识：理论+实践</h3><h4 id="音频的基本原理和组成"><a href="#音频的基本原理和组成" class="headerlink" title="音频的基本原理和组成"></a>音频的基本原理和组成</h4><ul>
<li>音频的表示和基本参数： Hz, 音量，pcm等以及基本编码；</li>
<li>音频查看的相关工具； <a id="more"></a></li>
</ul>
<h4 id="视频的基本原理和组成"><a href="#视频的基本原理和组成" class="headerlink" title="视频的基本原理和组成"></a>视频的基本原理和组成</h4><ul>
<li>图像基础知识：RGB,YUV </li>
<li>图像和视频：</li>
<li>关键帧和参考帧的概念：I,P,B</li>
<li>GOP的概念和应用；</li>
</ul>
<h4 id="音频文件和直播中的音频流"><a href="#音频文件和直播中的音频流" class="headerlink" title="音频文件和直播中的音频流"></a>音频文件和直播中的音频流</h4><ul>
<li>音频文件和直播中的音频流的基本区别和原理</li>
<li>音频编码格式和容器封装，以及相关格式和特点  </li>
</ul>
<h4 id="视频文件和直播中的视频流"><a href="#视频文件和直播中的视频流" class="headerlink" title="视频文件和直播中的视频流"></a>视频文件和直播中的视频流</h4><ul>
<li>视频文件和直播中的视频的基本区别和原理</li>
<li>视频编码格式和容器封装，以及相关格式和特点；  </li>
</ul>
<h3 id="音视频高级知识：-理论-实践"><a href="#音视频高级知识：-理论-实践" class="headerlink" title="音视频高级知识： 理论+实践"></a>音视频高级知识： 理论+实践</h3><h4 id="音频的编码技术："><a href="#音频的编码技术：" class="headerlink" title="音频的编码技术："></a>音频的编码技术：</h4><ul>
<li>AAC和ADTS</li>
<li>OPUS和OGG</li>
<li>其他  </li>
</ul>
<h4 id="视频的编码技术："><a href="#视频的编码技术：" class="headerlink" title="视频的编码技术："></a>视频的编码技术：</h4><ul>
<li>H.264/H.265和MPEG系列</li>
<li>VP8/VP9 google</li>
<li>其他，MS的VC-1  </li>
</ul>
<h4 id="实践：ffmpeg"><a href="#实践：ffmpeg" class="headerlink" title="实践：ffmpeg:"></a>实践：ffmpeg:</h4><ul>
<li>专注在ffmpeg的接口如何使用，并构建类似播放器这种例子；在遇到问题时查阅接口的源代码，这种学习方式；<br>在这种路子，可以学习各种ffmpeg支持的常用协议  </li>
</ul>
<h3 id="直播技术栈全貌"><a href="#直播技术栈全貌" class="headerlink" title="直播技术栈全貌"></a>直播技术栈全貌</h3><h4 id="直播技术架构：客户端，服务端，网络CDN等等；"><a href="#直播技术架构：客户端，服务端，网络CDN等等；" class="headerlink" title="直播技术架构：客户端，服务端，网络CDN等等；"></a>直播技术架构：客户端，服务端，网络CDN等等；</h4><h3 id="服务器后台直播技术栈：构建基本的直播后台架构；"><a href="#服务器后台直播技术栈：构建基本的直播后台架构；" class="headerlink" title="服务器后台直播技术栈：构建基本的直播后台架构；"></a>服务器后台直播技术栈：构建基本的直播后台架构；</h3><h4 id="分布式系统的技术栈"><a href="#分布式系统的技术栈" class="headerlink" title="分布式系统的技术栈"></a>分布式系统的技术栈</h4><h4 id="所在公司的直播网系统；"><a href="#所在公司的直播网系统；" class="headerlink" title="所在公司的直播网系统；"></a>所在公司的直播网系统；</h4><h4 id="所在公司的分发网系统"><a href="#所在公司的分发网系统" class="headerlink" title="所在公司的分发网系统"></a>所在公司的分发网系统</h4><h4 id="所在公司的直播网，分发网，p2p和cdn的融合；"><a href="#所在公司的直播网，分发网，p2p和cdn的融合；" class="headerlink" title="所在公司的直播网，分发网，p2p和cdn的融合；"></a>所在公司的直播网，分发网，p2p和cdn的融合；</h4><h3 id="服务器后台直播技术栈高级：-优化"><a href="#服务器后台直播技术栈高级：-优化" class="headerlink" title="服务器后台直播技术栈高级： 优化"></a>服务器后台直播技术栈高级： 优化</h3><h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><h4 id="网络本身：路由等等；延迟和卡顿-jitterbuffer-重传和fec"><a href="#网络本身：路由等等；延迟和卡顿-jitterbuffer-重传和fec" class="headerlink" title="网络本身：路由等等；延迟和卡顿(jitterbuffer,重传和fec)"></a>网络本身：路由等等；延迟和卡顿(jitterbuffer,重传和fec)</h4><h4 id="直播后台性能：缓存，资源调度和流量管理"><a href="#直播后台性能：缓存，资源调度和流量管理" class="headerlink" title="直播后台性能：缓存，资源调度和流量管理"></a>直播后台性能：缓存，资源调度和流量管理</h4><h3 id="音视频编码技术："><a href="#音视频编码技术：" class="headerlink" title="音视频编码技术："></a>音视频编码技术：</h3><h4 id="基本编码原理"><a href="#基本编码原理" class="headerlink" title="基本编码原理"></a>基本编码原理</h4><h4 id="opencv等视觉"><a href="#opencv等视觉" class="headerlink" title="opencv等视觉"></a>opencv等视觉</h4><h4 id="ai"><a href="#ai" class="headerlink" title="ai"></a>ai</h4><h3 id="更多：TODO"><a href="#更多：TODO" class="headerlink" title="更多：TODO:"></a>更多：TODO:</h3>]]></content>
      <categories>
        <category>live_media</category>
      </categories>
      <tags>
        <tag>overiew</tag>
      </tags>
  </entry>
  <entry>
    <title>my_funds_and_stocks</title>
    <url>/2021/02/09/my-funds-and-stocks/</url>
    <content><![CDATA[<h3 id="简介和写这篇文章的目的："><a href="#简介和写这篇文章的目的：" class="headerlink" title="简介和写这篇文章的目的："></a>简介和写这篇文章的目的：</h3><p>  其实在上大学，大三大四的时候就有财商的思考了，而触发这个思考一开始是大学期间看的穷爸爸和富爸爸那本书，和那个老鼠赛跑的游戏，再之后，财商这个词，<a id="more"></a>主要源于一个做生意的初中同学在某句话中出现了这个词，其实不用解释很多，仅仅是一个新概念，就足以引人深思；但是那会其实没有钱，也没啥概念，也单单只是停留在如何通过一些渠道更快更便捷的赚更多的钱；所以那个时候做一些兼职，也停留在简单的生意层面；  </p>
<p>  直到开始工作，因为繁忙，多加班，让我没有更多的精力去做斜杠青年，而老家的房子问题，让我第一份工作，即头两年左右的时间，都将工资，年终奖等，去掉生活费攒下的钱，都交给家里了；<br>没有时间消费，加上其他福利，少社交等，让我的生活基本只有工作；于是第一份工作，在完成家里的房子后，我也没剩下什么钱了；于是。累的我，跳槽了；  </p>
<p>  之后，才是我自己的生活，而这个时候已经毕业两年了；第二份工作时2019年11月底开始的，拿到工资的时候，钱也终于能自由支配；于是顺理成章的，我会去思考，如何理财，而无非，就是如何进行资产配置，如何记账，如何管理财富等等；<br>  于是我开始查理财的知识，直到加入一个线上低价的小白课入门，渐渐开始了解这个基金，股票的世界，而最让我感觉到希望的是，可以借此财富自由；毕竟，在这之前，我以为财富自由要赚很多很多钱，或者是要有类似书籍版权等类似的睡后收入；  </p>
<p>  于是我开始学习基金，股票知识，慢慢的，接触到螺丝钉和他的书，接着在2020年02月开始通过蛋卷基金买基金等；到现在2021年02月，整整一年，我的收益年化在15%左右；我了解的知识不多，只是跟着大螺买，了解基金的基本原理；<br>而后来我要自选一些基金，加上想在下一年进军美股港股等，所以，要接着继续学习；  </p>
<p>  于是这篇文章，想记录下我这2020年的资产配置和投资的总结；  </p>
<h3 id="关于资产的概念和资产配置："><a href="#关于资产的概念和资产配置：" class="headerlink" title="关于资产的概念和资产配置："></a>关于资产的概念和资产配置：</h3><ul>
<li>家庭日常消费规划一般：消费计划，投资计划，保险计划，教育金计划，养老金计划等；都是理财，凡是和钱有关的安排都是理财；</li>
<li>生钱资产，耗钱资产和其他资产，这三个重要概念：<ul>
<li>1)资产：房子，车子，手机，钱，桌子，椅子，基金，股票等等；</li>
<li>2)流动资产和非流动资产：流动资产：方便变现的如股票，基金等；非流动资产：不方便变现的如：房子，车子等；</li>
<li>3)资产的内涵：现金流</li>
<li>4)生钱资产：能给你持续带来净现金流入的东西，可以躺着赚钱，睡后收入；如基金，余额宝，债券等，变富有</li>
<li>5)耗钱资产：能给你持续带来净现金流出的东西，可以躺着付钱，睡后支出；如贷款的房子，车子；变穷</li>
<li>6)其他资产：净现金流为0 的资产，如黄金等；</li>
<li>7)注意耗钱资产在某个情况条件下也能变为生钱资产，若其生钱大于耗钱；且不用支出劳动力；</li>
</ul>
</li>
<li>财富自由<ul>
<li>收入低：分清楚必要开支和不必要开支；好支出和坏支出；<br>开源，提高工资收入；建议30岁前，多花时间在工作技能上；工资的增长比投资快多了；</li>
<li>工资收入和非工资收入要同步进行；</li>
<li>中产阶级的现金流和富人现金流的不同：中产：房贷等等；</li>
<li>财务自由的概念：你的非工资收入大于日常开支</li>
<li>财富自由度：年非工资收入(年投资收入)/年生活支出==1是最基本的自由度，数字越大，自由度越高；</li>
<li>富人的两个秘密：<ul>
<li>1）生钱资产占总资产的80%</li>
<li>2）好支出占总支出的80%；比如学习的，健康的；</li>
</ul>
</li>
</ul>
</li>
<li>从一万到100万的理财法则<ul>
<li>复利的强大力量：印度宰相米粒摆棋盘的故事；</li>
<li>复利的一些计算例子：</li>
<li>复利公式：最终收益=本金*（1+收益率）^时间—其实就是以前学政治的里面的公式；</li>
<li>复利曲线和单利曲线，单利就是比如本金10万，利率10%，那么第一年1万，第10年10万(除开本金),…而复利是把利息也投进去了；<br>从公式看y=x*z^t ,可见哪个因素影响大；从曲线来看，时间和z影响很大；所以越早投资越好；</li>
<li>复利计算器：<a href="http://www.yaocaiwuziyou.com/calculator.html" target="_blank" rel="noopener">www.yaocaiwuziyou.com/calculator.html</a>;</li>
</ul>
</li>
<li>财富配置举例：</li>
<li>3：家庭年收入的30%用来作为应急金（包括日常消费），以备不时之需，可以通过无风险工具管理处置，灵活存取</li>
<li>1: 家庭年收入的10%用来配置家庭保险，作为家庭资产的后盾</li>
<li>4：家庭年收入的40%用来养鹅，钱生钱</li>
<li>2：家庭年收入的20%用来投资自己，学习相关技巧，增加自己的工资和非工资收入<br>关于通货膨胀；~</li>
</ul>
<h3 id="本文主要写投资计划"><a href="#本文主要写投资计划" class="headerlink" title="本文主要写投资计划"></a>本文主要写投资计划</h3><h3 id="基金的相关知识"><a href="#基金的相关知识" class="headerlink" title="基金的相关知识"></a>基金的相关知识</h3><h4 id="股票，股权，股东，股份，原始股等概念："><a href="#股票，股权，股东，股份，原始股等概念：" class="headerlink" title="股票，股权，股东，股份，原始股等概念："></a>股票，股权，股东，股份，原始股等概念：</h4><ul>
<li><p>什么是股票?<br>股票（stock）是指股份公司发行的所有权凭证，是股份证书的简称，每家上市公司都会发行股票，是股份公司为筹集资金而发行给股东作为持股凭证并借以取得股息和红利的一种有价证券。<br>每股股票都代表股东对企业拥有一个基本单位的所有权。这种所有权是一种综合权利，如参加股东大会、投票表决、参与公司的重大决策、收取股息或分享红利等。同一类别的每一份股票所代表的公司所有权是相等的。每个股东所拥有的公司所有权份额的大小，取决于其持有的股票数量占公司总股本的比重。股票是股份公司资本的构成部分，可以转让、买卖或作价抵押，是资本市场的主要长期信用工具，但不能要求公司返还其出资。股东与公司之间的关系不是债权债务关系。股东是公司的所有者，以其出资份额为限对公司负有限责任，承担风险，分享收益。  –来自MBA智库  </p>
</li>
<li><p>为什么会有股票：<br>举个例子：<br>假设小明开了一家餐饮公司，名字就叫A公司吧。为了筹集更多资金扩大公司规模，小明准备把A公司上市，股价定为10元。<br>为了让大家购买股票，成为股东，小明承诺每年拿出A公司的部分利润分给股东。—这是投资股票的本质，也是价值投资最看重的，价值来自于公司盈利。<br>(除此之外，还可能承诺给与一定的权利，比如管理权，决策权等)<br>小红花了1000元，买了100股A公司股票，股价10元。<br>去年A公司利润算出来了，准备每股分红1元。分红前股价10元，分红后，小红得到现金1元，股价可能因此变成9元。小红总资产没有变化。—这个后面讨论为什么会可能变为9元  </p>
</li>
</ul>
<ul>
<li><p>股权，股份和股东：</p>
<ul>
<li>股权可以理解为对股票的一种权利，这种权利可以有多种，比如表决权，分红权等等，根据所拥有的股票种类和股票份数，权利也有对应的不同，份数越多，股权越大，越有话语权和管理权；  </li>
<li>股东可以理解为拥有股权的个人或机构；大股东是指拥有份数占比较大股票的个人或机构，这种对应的股权也会比较大；  </li>
<li>股份即拥有股票总数的占比等；  </li>
</ul>
</li>
<li><p>股票的分类：<br>股票有很多种类：  </p>
<ul>
<li><p>1) 按股东权利分类，股票可分为普通股、优先股和后配股。  </p>
<ul>
<li>普通股：在公司的经营管理和盈利及财产分配上有普通权利的股份，代表满足所有债权偿付要求及优先股东的收益权与求偿权要求后对企业盈利和剩余财产的索取权，它构成公司资本的基础，是股票的一种基本形式，也是发行量最大，最为重要的股票。目前在上海和深圳证券交易所上中交易的股票，都是普通股。</li>
<li>优先股：相对于普通股而言的。主要指在利润分红及剩余财产分配的权利方面，优先于普通股。</li>
<li>后配股：是与优先股相反的一种股票。它是指利润分配和剩余财产分配后于普通股的股票。正因为它在财产和股息上的权利顺序比普通股要落后，故称之为后配股。</li>
</ul>
</li>
<li><p>2) 根据上市地区可以分为，我国上市公司的股票有A股、B股、H股、N股和S股等的区分。这一区分主要依据股票的上市地点和所面对的投资者而定。</p>
</li>
<li><p>3) 根据业绩也分为：ST股、垃圾股、绩优股、蓝筹股 。</p>
</li>
<li>4) 其他分类： <ul>
<li>记名股票和无记名股票：是否记载股东姓名来划分股票</li>
<li>有票面值股票和无票面值股票：这主要是根据股票是否记明每股金额来划分的。有票面值股票，是在股票上记载每股的金额。无票面值股票，只是记明股票和公司资本总额，或每股占公司资本总额的比例。</li>
<li>单一股票和复数股票：这主要是根据股票上表示的份数来划分的。单一股票是指每张股票表示一股。复数股票是指每张股票表示数股。</li>
<li>普通股票和特别股票：普通股票的股息随公司利润大小而增减。特别股票一般按规定利率优先取得固定股息，但其股东的表决权有所限制。</li>
<li>表决权股票和无表决权股票：普通股票持有者都有表决权，而那些在某些方面享有特别利益的优先股票持有者在表决权上常受到限制。无表决权的股东，不能参与公司决策。</li>
<li>原始股： 公司申请上市之前发行的股票；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="股权和债权的区别："><a href="#股权和债权的区别：" class="headerlink" title="股权和债权的区别："></a>股权和债权的区别：</h4><ul>
<li>债权：对方借了你的钱，需要还你本金和利息，比如银行的定期存款，利息约定多少，到期还你多少，而活期，贷款等都是这种；  </li>
<li>股权：你花钱买了上市公司股票，成为公司股东，公司定期给你分红。不存在本金和利息。你只要还持有，就继续享受分红；公司不会还你本金和利息；而你要回本或者赚取利益，只能卖出股票或者继续持有通过分红等享受收益；  </li>
</ul>
<h4 id="分红，填权，除权和股票下跌上涨的关系"><a href="#分红，填权，除权和股票下跌上涨的关系" class="headerlink" title="分红，填权，除权和股票下跌上涨的关系"></a>分红，填权，除权和股票下跌上涨的关系</h4><ul>
<li><p>分红：  </p>
<ul>
<li><p>前提：其实股票是一种权利的凭证，股票本身的价值是一种非实体价值，在公司盈利的情况下，且扩张需求不大，无资金需求时，上不上市其实无关紧要，比如华为，OPPO就没上市，而是类似全员持股，或者管理者持股等等；<br>在这种情况下，一家企业的经营，盈利后抛去人力等成本，剩下的钱由老板和管理者，创始人拥有，并决定分配等；和股票和上市没有半毛钱关系；<br>当企业经营不善，或者寻求更进一步的扩张，需要资金支持或者仅仅是资本扩张等，会选择进行融资，上市，而上市前一般是融资，比如天使轮融资，A轮，B轮等直到上市；融资是寻求外部资金，那投资者为什么会给你投资呢？<br>你通过介绍产品等，承诺未来有希望做大，且给与一定的股权和分红等等，于是股票诞生，持有股票越多，股权越大，权利越大等等，至于后面的拆股以及一些手段，有兴趣的再查；  </p>
</li>
<li><p>所以分红，就是：给投资者利益，红利，钱等；有两种形式：向股东派发现金股利和股票股利，上市公司可根据情况选择其中一种形式进行分红，也可以两种形式同时用。  </p>
<ul>
<li>现金股利是指以现金形式向股东发放股利，称为派股息或派息；  </li>
<li>股票股利是指上市公司向股东分发股票，红利以股票的形式出现，又称为送红股或送股；  </li>
</ul>
</li>
</ul>
</li>
<li><p>分红派息，分红的意义？<br>分红即派息，是对投资者回报的一种方式，比如小红买了A公司股票后，股价每股10元，每年派息1元，则10年可以回本，之后还能继续派息；<br>但是投资回报还可以是利用股票的涨跌套利，这种可能是当前比较火的方式；时间也比较短；</p>
</li>
<li><p>那股票一定会分红吗？股票分红对套利的人来讲有意义吗？<br>股票是否分红是上市公司自己决定的，一般要赚钱了才会分红，且分红需要扣税，加上除权的影响，可能分红后持有的股票总资产可能反而有所下降；</p>
</li>
<li><p>PS:<br>对于投资者来说，很多人觉得分红没用其实是站在一个短期投资的角度来看的，如果是长期投资，每年的分红累计起来，过几年就可以收回成本。<br>分红的时候股价降低了，但是持股份额没有变，只要公司能够持续盈利，产生持续分红，那么基本上就是稳赚的。要知道公司只有赚了钱才能分红，能够持续分红的上市公司，一定是优质的投资公司。所以有的公司为了吸引投资者，还会进行强制分红，就是为了吸收更多的资金。<br>不过市场上真正的长期投资者并不是，大多都是短期投资者，所以分红的存在感就很弱，很多人都觉得股票分红没什么用。<br>对于上市公司来说，股票分红后，股价低了，就可以吸引更多的散户买入，同时也更容易获得投资者的信任，获得稳定的资金来源，稳定股价。这是一个良性循环。</p>
</li>
</ul>
<ul>
<li><p>除权，除息：<br>继续上面的例子：<br>去年A公司利润算出来了，准备每股分红1元。分红前股价10元，分红后，小红得到现金1元，股价可能因此变成9元。小红总资产没有变化。<br>因为股票在市场上一直在投资者之间进行转让买卖，当上市公司在一定时期向股东分派股利进行配股时，为使本公司的股东真正得到其应得的分红配股权利，就存在着一个这种权利应该分配给股票的买入者还是卖出者才合理的问题，由此产生了股票除息与除权交易。<br>比如上面的小红在分红日卖出股票，这个时候分红算给谁？ 或者说分红给小红，然后小红再以同样价格的股价卖出？是否合理？<br>此外，由于公司分红配股引起公司股本以及每股股票所代表的企业的实际价值（每股净资产）的变动，需要在发生该事实之后以股票市场价格中剔除这部分因素。<br>比如上面的，本来如果利润以净资产等方式保留下来，那股票价值应该是上涨的，但是因为分红导致少了，所以这个时候需要将每股价格进行下调，即除权：<br>而比如上面的，分红后，小红的总资产可能不变，不过这种情况比较少；毕竟股价和很多因素有关；<br>更多： 除息报价，股权登记日，送股率等等；</p>
</li>
<li><p>填权：<br>在除权（息）后的一段时间内，如果多数投资者对该股看好，使得该股股价上涨，其价格高于除权（息）报价，即股价比除（息）前有所上涨，这种行情称为填权。如果股价上涨到除权（息）前的价格水平，称为填满权。<br>相反，如果多数投资者不看好该股，使得该股价下跌，其价格低于除权（息）报价，即股价比除权（息）前有所下降，则为贴权。</p>
</li>
</ul>
<p>所以，除权和填权，是股票上涨和下跌的一个基础因素之一；<br>除此之外，供需关系，和投资者的看好，也会推高股价，比如这双鞋，我觉得价值高，我在市场上出价就高，即投资者推高股价；同样想买的人多，也会推高股价；  </p>
<h4 id="一级市场和二级市场"><a href="#一级市场和二级市场" class="headerlink" title="一级市场和二级市场"></a>一级市场和二级市场</h4><p>  这篇文章对一级市场和二级市场讲的比较清楚：<br><a href="https://www.zhihu.com/question/36594463" target="_blank" rel="noopener">https://www.zhihu.com/question/36594463</a><br>简单来讲：  </p>
<ul>
<li>一级市场：就是股票最先发行的市场，比如批发市场，而在股市中，一级市场是最开始发行的，对符合条件的机构投资者线下配售的和对个人的网上发行(打新股), 这个时候，往往是股价比较低的，可以理解为批发价，批发市场；</li>
<li>二级市场：就是在批发市场后，由投资机构和打新者，通过交易在零售市场上进行流通；这个时候会有很多散户等入场，于是将价格推高，就像平常的经销商将批发价进价的鞋提高到零售价发售的过程，而打新者因为拿到的是批发价，所以在交易时卖掉可以得到不错的收入；</li>
<li><p>关于破发：<br>如果股票定价1,000元，但二级市场上压根没有想要购买的交易者或者交易者非常少，如果想尽快出售股票就要承担一个比发行价更低市场价格，比如800块，这个过程就叫做股票破发（跌破发行价）。</p>
</li>
<li><p>一级市场的范围：<br>一级市场被称作发行市场其实是不严谨的，因为一级市场的范围其实更广，除了首次公开募股IPO的股票发行外，还包括了股票在公开发行和上市前的私募股权数轮融资过程，通常会以风投Venture Capital/私募股权Private Equity的形式来完成，对应着天使轮-A轮-B轮-C轮有些独角兽企业会一直进行到F轮直至上市退出。这些VC/PE，因为投资的都是一级市场未上市的股权，所以也被称为一级市场基金。</p>
</li>
<li><p>为什么要有一级二级市场：<br>就像鞋一样，如果一开始就投入零售市场，价格比较难确定，因为散户对这个鞋的价值认同不一样，需要经过较长时间的定价才能投入；</p>
</li>
</ul>
<h4 id="关于股票投资和股权投资："><a href="#关于股票投资和股权投资：" class="headerlink" title="关于股票投资和股权投资："></a>关于股票投资和股权投资：</h4><ul>
<li><p>股权投资：是一种价值投资，长期投资：<br>股权投资是投到实体经济、投到企业，投资人变成企业长期股东，投资人把自己的资源和隐性能力嫁接到这个公司，为公司的长期发展做出持续性贡献。所以，股权投资有两个非常鲜明的特点：一是增量资金进入公司；二是投资人作为股东会为这个公司做持续性的增值或服务。</p>
</li>
<li><p>股票投资：是一种零和游戏，是赚取波动的钱；<br>在投资者多空博弈中，股价会出现上涨和下跌，幅度有时候会远远超过业绩的变动幅度，意味着股价可能会涨太多偏离内在价值，之后又下跌进行修复，股民通过股价的涨跌波动赚取差价，就是赚波动的钱。那么这部分钱从哪里来，就是从对手的账户中来，有人赚必然就有人亏，你赚的钱就是别人亏的钱。</p>
</li>
<li><p>其他：央行印发钞票，这个时候大家都赚钱：央行印发钞票，为市场提供流动性，流动性充足甚至流动性泛滥，就会出现资产价格上涨，有时还会持续上涨，在由巨量流动性推升的行情中，所有人都赚到钱了，公司盈利没有明显增加，也没有对手博弈亏钱，这赚的就是央行的钱。</p>
</li>
<li><p>PS:<br>股票盈利靠价格波动，股权盈利靠价值增长。<br>A股（二级市场）遍布“铁公鸡”，有钱也不分红，投资人只能通过不断的交易，然后赢得差价。<br>而在一级市场中，较长的锁定期使得股权流动性大大降低，公司未来的估值提升才是盈利核心。<br>在中国，股票市场的绝大多数投资者是散户，而绝大多数上市公司的分红很少，具备持续成长能力的上市公司数量也少。<br>　　所以，中国的股票投资本质是我的钱进到别人兜里，我赚的钱是从别人口袋掏出来的，钱并没有进入公司，而是在不同股东之间高速流转，某种程度上是一种资金的空转。<br>　　股票投资是在交易市场里赚取交易的不对称性、不平衡性，某些人赚钱就意味着其他人一定亏钱，基本上是一个零和游戏。  </p>
</li>
<li><p>如何做股权投资？ TODO;  </p>
</li>
</ul>
<h4 id="基金是什么，基金分类"><a href="#基金是什么，基金分类" class="headerlink" title="基金是什么，基金分类"></a>基金是什么，基金分类</h4><p>股票和债券(债权)都是直接投资，而基金，是一种间接投资：  </p>
<ul>
<li>基金：代表一种委托关系，委托专业机构帮你理财，收益受专业机构的理财能力影响。一般来说，基金收益小于股票，大于债券，相对应，风险小于股票，大于债券。基金是一种间接投资，是委托专业的人员帮你理财，而专业人员往往会分散投资等等，基金公司将各种投资方案包装为一个个套餐供你选择；而专业人员如基金经理，可能会购买如股票，债券，银行存款等或者混合，来进行投资，并将收益转换为基金收益，返利给投资者等；而基金投资的东西不同，则有不同的基金分类，如股票基金，混合基金等；</li>
<li><p>因此：</p>
<ul>
<li>股票基金，收益大，风险高；</li>
<li>混合基金，收益中等，风险相对小；</li>
<li>债券基金，收益低，风险小；</li>
<li>还有一种指数基金：如果说普通的基金是由基金经理去主动挑选股票，债券等，那指数基金则是被动的跟踪某个指数来买入股票等组合；</li>
</ul>
</li>
<li><p>引用知乎上的一个解释：<br>指数就是一个选股规则。<br>指数基金它跟踪特定的指数，并按照这个指数成分股的比例买入同样的股票组合。<br>举个例子：学校选取校花有三个标准：身高1.68以上，腰围65cm以下，体重100斤以下。小A（身高1.71，腰围63cm，体重98斤）小B（身高1.70，腰围63cm，体重99斤）小C （身高1.69，腰围64cm，体重98斤）她们三个的身高，体重，腰围都符合选校花的三个标准，就被分到校花之列。<br>而有一天小B由于最近夜宵吃多了长胖了，体重达到了102，那么她就被踢出校花之列，而小D的身高，体重，腰围达标，她就被分到校花之列，只要选择校花的标准不变，就会有源源不断的符合校花条件的人列入其中。<br>计算纳入校花的人群各自美貌分，在加权平均一下，变成一个校花指数。<br>所以，金融市场上的指数的编制，就注定了会有源源不断的好公司被纳入指数中来。而且指数基金，不需要基金经理主动选股，直接买这些指数背后的成分股，构成对应的指数基金。  </p>
</li>
</ul>
<h4 id="为什么指数基金值得投资："><a href="#为什么指数基金值得投资：" class="headerlink" title="为什么指数基金值得投资："></a>为什么指数基金值得投资：</h4><p>1) 不依赖基金经理选股，而是依赖特定指数；<br>2）不依赖某家公司，公司倒闭了，也不受影响；<br>3）指数基金通过投资指数成分股来获得和市场持平的收益，所以长期看好就有收益；  </p>
<h4 id="基金中的名词概念："><a href="#基金中的名词概念：" class="headerlink" title="基金中的名词概念："></a>基金中的名词概念：</h4><ul>
<li>净值：基金单位净值即每份基金单位的净资产价值，等于基金的总资产减去总负债后的余额再除以基金全部发行的单位份额总数</li>
<li>申购和申购费率：认购费与申购费性质相似，都是向基金管理人购买基金单位时所支付的手续费<h4 id="基金的相关时间："><a href="#基金的相关时间：" class="headerlink" title="基金的相关时间："></a>基金的相关时间：</h4></li>
<li>基金交易时间：指开放式基金接受申购、转换、赎回或其它交易的时间段。<br>基金主要投资于股票和债券，所以交易时间和股票的开盘时间相同。一般为周一至周五上午9：30-下午3：00，国家法定假日除外，因此这和我们平时说的工作日并不完全相同。  </li>
<li>T日交易规则：<br>T日交易规则中的T日指的是不包括周末和节假日的交易日，一般以股市收市时间15:00为界。<br>一般来说，如果在交易日的15:00前申购，会按当天的净值计算，当天的净值一般在晚上8-10点更新后查看；如果在交易日3点之后购买，那么则按照下个交易日（T+1）当天的净值，具体以基金购买后被确认的信息为准。<br>在提交申购申请的T+1日，基金公司会确认份额，也就是交易确认日。在提交申购申请的T+2日可以查看基金的收益，也就是收益查看日。<br>这里要注意的是，我们在买入基金的时候其实并不知道买入的价格，因为具体的净值要等到当天收盘，基金公司根据收盘价计算后才会更新。  </li>
</ul>
<p>举例来说：<br>小明预计下周一市场上涨，因此在周五收盘后提交了订单，但是这和小红在周一下午3点前提交订单是一个效果，都是以周一收盘价计算，而周一的上涨和他都没有关系。因此，在当天下午2点左右操作是一个最佳时间点，因为越接近下午三点买入，就越接近收盘价格。  </p>
<ul>
<li>赎回时间：<br>一般的开放式基金赎回的流程为：T日卖出→ T+1确认→T+3到账。<br>赎回和购买时一样，如果在交易日下午3点前赎回，会按照当天收盘价格计算净值，如果在下午3点后申报赎回，赎回的基金净值则会按照下一个工作日的基金净值计算，资金一般在T+3日到账。<br>不过，具体的基金到账时间要根据实际情况为准，可以在每只基金的交易规则中查看。  </li>
</ul>
<h4 id="基金怎么算收益："><a href="#基金怎么算收益：" class="headerlink" title="基金怎么算收益："></a>基金怎么算收益：</h4><p>申购：<br>用1万元申购某基金，申购费率是1.5％，该基金当日净值是1.2000。<br>申购手续费＝10000.00×1.5％＝150.00(元)<br>申购份额＝(10000.00－150.00)÷1.2000＝8208.33(份)<br>赎回：<br>      1个月后赎回该基金，当日净值是1.4000，赎回费率是0.5％。<br>      赎回总额＝8208.33×1.4000＝11491.66(元)<br>      赎回手续费＝11491.66×0.5％＝57.46(元)<br>      赎回净额＝11491.66－57.46＝11434.20(元)<br>      净收益＝11434.20－10000.00＝1434.20(元)</p>
<h3 id="买基金需要看什么："><a href="#买基金需要看什么：" class="headerlink" title="买基金需要看什么："></a>买基金需要看什么：</h3><h4 id="持仓-规模，增长曲线，历史收益，净值估算，最大回撤，基金公告；"><a href="#持仓-规模，增长曲线，历史收益，净值估算，最大回撤，基金公告；" class="headerlink" title="持仓,规模，增长曲线，历史收益，净值估算，最大回撤，基金公告；"></a>持仓,规模，增长曲线，历史收益，净值估算，最大回撤，基金公告；</h4><ul>
<li>持仓：在蛋卷基金或其他基金软件，通过详情可以看到持仓，从而可以看到这个基金购买的公司股票或具体实体。以此判断公司和行业是否值得购买，是否是估值偏高等；</li>
<li>规模：通过详情可以看到规模，即这个基金有多少规模，投入多少money,一般越大越好，即基金净值乘以总数，净值受股价和供需的影响，一般购买规模大的比较稳定，比如100亿以上的；</li>
<li>增长曲线，通过净值年曲线，月曲线等，可以看到这个基金的总体收益等情况；</li>
<li>净值估算：比如支付宝可以看到实时的基金净值估算，从而判断改天的净值走势；</li>
<li>最大回撤： 即最大跌幅是多少；</li>
<li>基金公告：有些基金会进入封闭期等，此时可以通过公告来看什么时候开放等；</li>
</ul>
<h4 id="公司财报"><a href="#公司财报" class="headerlink" title="公司财报"></a>公司财报</h4><p>买股票和基金等，其实是在对公司的投资，所以需要对公司进行分析，只有公司，企业盈利，发展好等，才能有更大的上涨；而分析公司财报，可以看出这家公司的盈利情况等等；<br>公司财报没怎么看过，所以没啥记录的，只有一点宏观的：  </p>
<ul>
<li>A  衡量一个公司的还坏，营收能力，需要看以下几个点：<br>应付预收<ul>
<li>1)应付：【先用货，后给钱】，我大海天要产酱油了，我没有黄豆了，我先跟供货商说，你把豆子给我，然后我晚点结账。帅吧！不给钱就能空手套白狼</li>
<li>2)预收：【先收钱，后发货】，我跟经销商说，我酱油马上做好了，你先打钱，然后我再给你发货。快打钱，不打钱没货了啊，别人订走了。牛吧，先给钱后发货。</li>
</ul>
</li>
</ul>
<p>应收预付</p>
<ul>
<li>1)应收：【先发货，收不到钱】，我先发酱油给经销商，但是人家不给我钱，谁让他卖得好呢。哎不牛了。</li>
<li>2)预付：【先给钱，收不到货】，哎，我黄豆钱都打过去了，黄豆还没给我呢，谁让人既黄豆好呢。不帅。不牛。<ul>
<li>B:通过什么科目判断公司的安全性：？<br>资产负债率：=总负债/总资产；负债率大于70%的公司偿债风险比较大，而小于40%的几乎没有偿债风险；<br>股票可以参考A,B指标来购买；</li>
<li>C:如何下载上市公司的财报：<br><a href="http://www.cninfo.com.cn/new/index巨潮资讯网；" target="_blank" rel="noopener">http://www.cninfo.com.cn/new/index巨潮资讯网；</a><br>财报分析看结构，有23个步骤；</li>
<li>D:找工作跳槽等也是可以参考该上市公司的财务报表情况来看这家公司是不是一家好公司；<br>要选择好的行业；</li>
</ul>
</li>
</ul>
<h4 id="公司的ROE等参数"><a href="#公司的ROE等参数" class="headerlink" title="公司的ROE等参数"></a>公司的ROE等参数</h4><ul>
<li><p>市盈率：<br>公司市值/公司盈利 (即PE=P/E),P为公司市值，E表示公司盈利；(市值是指一家上市公司的发行股份按市场价格计算出来的股票总价值，其计算方法为每股股票的市场价格乘以发行总股数）<br>反映了我们愿意为获取1元的净利润付出多少代价：比如一个公司的市盈率是10，则代表我们愿意为这个公司的1元盈利付出10元；<br>适用范围：流通性好，盈利稳定的品种；周期行业也不适用市盈率；</p>
</li>
<li><p>盈利收益率<br>市盈率的倒数：公司盈利除以公司市值 E/P，即收益率</p>
</li>
<li><p>市净率<br>每股股价与每股净资产的比率：账面价值；PB=P/B P：公司市值，B：公司净资产；(资产-负债)  —越小越好</p>
</li>
<li><p>ROE: 净资产收益率  净利润/净资产   ： ROE越高，则资产运作效率越高</p>
</li>
<li><p>股息率<br>股息：是公司现金分红除以公司的市值，得到的就是股息率了；–越高越好</p>
</li>
</ul>
<h4 id="什么时候开始定投？"><a href="#什么时候开始定投？" class="headerlink" title="什么时候开始定投？"></a>什么时候开始定投？</h4><p>盈利收益率大于10%时，开始定投，6.4%到10%时，坚持持有<br>盈利收益率低于6.4%时，分批卖出基金  </p>
<h3 id="基金的投资指南–参考《指数基金投资指南》"><a href="#基金的投资指南–参考《指数基金投资指南》" class="headerlink" title="基金的投资指南–参考《指数基金投资指南》"></a>基金的投资指南–参考《指数基金投资指南》</h3><p>这本书主要讲述，指数基金的投资：<br>包括指数基金的解释，<br>指数基金的分类和特点，涵盖宽基，行业指数等等，<br>基金的投资理念：价值投资，估值等方法；<br>如何定投和如何制定属于自己的投资计划；<br>家庭资产配置和如何做长期投资的心理建设，不被短期涨跌影响；<br>更多具体可以查，当工具书等；  </p>
<h3 id="我目前买的组合和持仓："><a href="#我目前买的组合和持仓：" class="headerlink" title="我目前买的组合和持仓："></a>我目前买的组合和持仓：</h3><p>目前主要关注螺丝钉和螺丝钉相关组合，通过蛋卷基金投资，另外一些自选主要有易方达系列，汇添系列，兴全系列，银华富裕主题混合，招行中证白酒指数，华夏上证50AH优选指数(LOF)A,沪深300大盘，钉钉宝365组合等等；  </p>
<h3 id="一些基金软件等："><a href="#一些基金软件等：" class="headerlink" title="一些基金软件等："></a>一些基金软件等：</h3><p>天天基金，蛋卷基金，易方达基金<br>东方财富，雪球</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>打算玩点美股，港股打新，正在学习和搞账号，下一篇记录下美股和美股的一些知识，比如做空等等是什么意思；</p>
]]></content>
      <categories>
        <category>Financial_management</category>
      </categories>
      <tags>
        <tag>Funds_and_stocks</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_template_class</title>
    <url>/2021/01/09/cpp-template-class/</url>
    <content><![CDATA[<h3 id="类模板的基本概念"><a href="#类模板的基本概念" class="headerlink" title="类模板的基本概念"></a>类模板的基本概念</h3><h3 id="类模板的引入："><a href="#类模板的引入：" class="headerlink" title="类模板的引入："></a>类模板的引入：<a id="more"></a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">一个例子：</span><br><span class="line">用类封装一个包含多操作的IntArray:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INTARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt; // for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;</span><br><span class="line">    <span class="keyword">int</span> *m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    IntArray()</span><br><span class="line">    &#123;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    IntArray(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(length &gt; <span class="number">0</span>);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~IntArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">用类封装一个包含多操作的DoubleArray:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOUBLEARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOUBLEARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt; // for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;</span><br><span class="line">    <span class="keyword">double</span> *m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DoubleArray()</span><br><span class="line">    &#123;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    DoubleArray(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(length &gt; <span class="number">0</span>);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">double</span>[length];</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~DoubleArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">以上两个定义内容只有里面的类型不同，那么为什么不忽略类型的差异，定义通用的容器？于是类模板出现：</span><br><span class="line">类模板的定义和使用：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt; // for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">This</span> <span class="title">is</span> <span class="title">a</span> <span class="title">template</span> <span class="title">class</span>, <span class="title">the</span> <span class="title">user</span> <span class="title">will</span> <span class="title">provide</span> <span class="title">the</span> <span class="title">data</span> <span class="title">type</span> <span class="title">for</span> <span class="title">T</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;<span class="comment">//注意这里可以指定具体类型；</span></span><br><span class="line">    T *m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array()</span><br><span class="line">    &#123;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Array(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> T[length];</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Array()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The length of the array is always an integer</span></span><br><span class="line">    <span class="comment">// It does not depend on the data type of the array</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>; <span class="comment">// templated getLength() function defined below</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// member functions defined outside the class need their own template declaration</span></span><br><span class="line"><span class="keyword">int</span> Array&lt;T&gt;::getLength() &#123; <span class="keyword">return</span> m_length; &#125; <span class="comment">// note class name is Array&lt;T&gt;, not Array</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">使用：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Array&lt;<span class="keyword">int</span>&gt; intArray(<span class="number">12</span>);</span><br><span class="line">	Array&lt;<span class="keyword">double</span>&gt; doubleArray(<span class="number">12</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; intArray.getLength(); ++count)</span><br><span class="line">	&#123;</span><br><span class="line">		intArray[count] = count;</span><br><span class="line">		doubleArray[count] = count + <span class="number">0.5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = intArray.getLength()<span class="number">-1</span>; count &gt;= <span class="number">0</span>; --count)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intArray[count] &lt;&lt; <span class="string">"\t"</span> &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类模板和标准库："><a href="#类模板和标准库：" class="headerlink" title="类模板和标准库："></a>类模板和标准库：</h3><p>从上面的例子可以看到，类模板定义的Array和Vector容器很类似，而类似vector的容器就是类模板实现的；</p>
<h3 id="模板类无法进行定义和函数实现的分离："><a href="#模板类无法进行定义和函数实现的分离：" class="headerlink" title="模板类无法进行定义和函数实现的分离："></a>模板类无法进行定义和函数实现的分离：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">如下例子，在链接时会出现问题：</span><br><span class="line">Array.h:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt; // for assert()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;</span><br><span class="line">    T *m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array()</span><br><span class="line">    &#123;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Array(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> T[length];</span><br><span class="line">        m_length = length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Array()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="comment">// We need to make sure we set m_data to 0 here, otherwise it will</span></span><br><span class="line">        <span class="comment">// be left pointing at deallocated memory!</span></span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        m_length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; m_length);</span><br><span class="line">        <span class="keyword">return</span> m_data[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The length of the array is always an integer</span></span><br><span class="line">    <span class="comment">// It does not depend on the data type of the array</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">Array.cpp:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Array&lt;T&gt;::getLength() &#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">使用时：链接时出错</span><br><span class="line">main.cpp:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Array&lt;<span class="keyword">int</span>&gt; intArray(<span class="number">12</span>);</span><br><span class="line">	Array&lt;<span class="keyword">double</span>&gt; doubleArray(<span class="number">12</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; intArray.getLength(); ++count)</span><br><span class="line">	&#123;</span><br><span class="line">		intArray[count] = count;</span><br><span class="line">		doubleArray[count] = count + <span class="number">0.5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = intArray.getLength()<span class="number">-1</span>; count &gt;= <span class="number">0</span>; --count)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intArray[count] &lt;&lt; <span class="string">"\t"</span> &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```cpp</span><br><span class="line"></span><br><span class="line">为什么呢：？</span><br><span class="line">实例化模板的必要条件：</span><br><span class="line">   为了让编译器去使用一个模板，它必须看到包括模板定义(而不是只有一个声明),和用于实例化模板的模板类型如<span class="keyword">int</span>等；</span><br><span class="line">上述例子为什么不成功？</span><br><span class="line">   且记住C++是单独编译文件的；当Array.h头文件被包含到main时，模板类定义被拷贝到main.cpp,当编译器看到我们需</span><br><span class="line">要两个模板实例，Array&lt;<span class="keyword">int</span>&gt;和Array&lt;<span class="keyword">double</span>&gt;,它将实例化他们，且编译他们作为main.cpp中的一部分；</span><br><span class="line">然而，当他单独的获取和编译Array.cpp时，他已经忘记我们需要一个Array&lt;<span class="keyword">int</span>&gt;和Array&lt;<span class="keyword">double</span>&gt;（单独编译，看不到main),所以Array.cpp中的模板函数不会被实例化；因此会因为找不到函数getLength()的定义而得到链接错误；</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">   针对上述问题，有几种处理方式：</span><br><span class="line">     <span class="number">1</span>)把定义全放在.h头文件</span><br><span class="line">  <span class="number">2</span>)把 rename Array.cpp to Array.inl (.inl stands <span class="keyword">for</span> <span class="keyword">inline</span>), <span class="keyword">and</span> then include Array.inl from the bottom of the Array.h header. That yields the same result as putting all the code in the header, but helps keep things a little cleaner.</span><br><span class="line"> <span class="number">3</span>）在main中include所有：</span><br><span class="line"><span class="comment">// Ensure the full Array template definition can be seen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Array.cpp"</span> <span class="comment">// we're breaking best practices here, but only in this one place</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// #include other .h and .cpp template definitions you need here</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;int&gt;;</span> <span class="comment">// Explicitly instantiate template Array&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;double&gt;;</span> <span class="comment">// Explicitly instantiate template Array&lt;double&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// instantiate other templates here</span></span><br></pre></td></tr></table></figure>
<h3 id="模板类类参数多样性"><a href="#模板类类参数多样性" class="headerlink" title="模板类类参数多样性"></a>模板类类参数多样性</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">模板类参数可以是无类型，即某种特定的类型：</span><br><span class="line">A value that has an integral type <span class="keyword">or</span> enumeration</span><br><span class="line">A pointer <span class="keyword">or</span> reference to a <span class="class"><span class="keyword">class</span> <span class="title">object</span></span></span><br><span class="line"><span class="class"><span class="title">A</span> <span class="title">pointer</span> <span class="title">or</span> <span class="title">reference</span> <span class="title">to</span> <span class="title">a</span> <span class="title">function</span></span></span><br><span class="line"><span class="class"><span class="title">A</span> <span class="title">pointer</span> <span class="title">or</span> <span class="title">reference</span> <span class="title">to</span> <span class="title">a</span> <span class="title">class</span> <span class="title">member</span> <span class="title">function</span></span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="keyword">nullptr_t</span></span><br><span class="line">例子：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; // <span class="title">size</span> <span class="title">is</span> <span class="title">the</span> <span class="title">non</span>-<span class="title">type</span> <span class="title">parameter</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StaticArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// The non-type parameter controls the size of the array</span></span><br><span class="line">    T m_array[size];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">getArray</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Showing how a function for a class with a non-type parameter is defined outside of the class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">StaticArray</span>&lt;T, size&gt;:</span>:getArray()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_array;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// declare an integer array with room for 12 integers</span></span><br><span class="line">    StaticArray&lt;<span class="keyword">int</span>, <span class="number">12</span>&gt; intArray;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Fill it up in order, then print it backwards</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">12</span>; ++count)</span><br><span class="line">        intArray[count] = count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">11</span>; count &gt;= <span class="number">0</span>; --count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intArray[count] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// declare a double buffer with room for 4 doubles</span></span><br><span class="line">    StaticArray&lt;<span class="keyword">double</span>, <span class="number">4</span>&gt; doubleArray;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">4</span>; ++count)</span><br><span class="line">        doubleArray[count] = <span class="number">4.4</span> + <span class="number">0.1</span>*count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">4</span>; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; doubleArray[count] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类模板的特化"><a href="#类模板的特化" class="headerlink" title="类模板的特化"></a>类模板的特化</h3><p>什么是类模板的特化，为什么需要，什么时候使用？<br>类模板的特化和函数模板特化类似，当我们定义了一个类模板后，这个类模板可以实例成int ,bool,char等等类型，都是同样的处理逻辑；<br>当我们想针对bool特殊化，比如bool本身用一个bit就可以实现，节省空间，时，可以用类模板的特化，来为实例成bool时定义一个类模板的特化，这样，bool就和其他int等不同了；</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage8</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_array[<span class="number">8</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_array[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">特化<span class="keyword">bool</span>:</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// the following is a template class with no templated parameters</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage8</span>&lt;bool&gt; // <span class="title">we</span>'<span class="title">re</span> <span class="title">specializing</span> <span class="title">Storage8</span> <span class="title">for</span> <span class="title">bool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// What follows is just standard class implementation details</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> m_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Storage8() : m_data(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">bool</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Figure out which bit we're setting/unsetting</span></span><br><span class="line">        <span class="comment">// This will put a 1 in the bit we're interested in turning on/off</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> mask = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (value)  <span class="comment">// If we're setting a bit</span></span><br><span class="line">            m_data |= mask;  <span class="comment">// Use bitwise-or to turn that bit on</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// if we're turning a bit off</span></span><br><span class="line">            m_data &amp;= ~mask;  <span class="comment">// bitwise-and the inverse mask to turn that bit off</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Figure out which bit we're getting</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> mask = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">        <span class="comment">// bitwise-and to get the value of the bit we're interested in</span></span><br><span class="line">        <span class="comment">// Then implicit cast to boolean</span></span><br><span class="line">        <span class="keyword">return</span> (m_data &amp; mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Define a Storage8 for integers (instantiates Storage8&lt;T&gt;, where T = int)</span></span><br><span class="line">    Storage8&lt;<span class="keyword">int</span>&gt; intStorage;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count&lt;<span class="number">8</span>; ++count)</span><br><span class="line">        intStorage.<span class="built_in">set</span>(count, count);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count&lt;<span class="number">8</span>; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intStorage.get(count) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Define a Storage8 for bool  (instantiates Storage8&lt;bool&gt; specialization)</span></span><br><span class="line">    Storage8&lt;<span class="keyword">bool</span>&gt; boolStorage;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count&lt;<span class="number">8</span>; ++count)</span><br><span class="line">        boolStorage.<span class="built_in">set</span>(count, count &amp; <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count&lt;<span class="number">8</span>; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (boolStorage.get(count) ? <span class="string">"true"</span> : <span class="string">"false"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板的偏特化"><a href="#模板的偏特化" class="headerlink" title="模板的偏特化"></a>模板的偏特化</h3><p>区别于前文说的特化，偏特化指的是部分的特化，比如两个模板类型，将其中一个特化了，或者是<br>特化为指针等等；见下面例子：</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 两个类型特化了其中一个</span><br><span class="line">泛化：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">特化：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&lt;bool,Alloc&gt;//在类型化时，若传入的第一个参数为<span class="title">bool</span>，则用以下版<span class="title">zf</span>本；</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="偏特化为指针"><a href="#偏特化为指针" class="headerlink" title="偏特化为指针"></a>偏特化为指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">泛化：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="keyword">int</span> ittt;</span><br><span class="line">&#125;;</span><br><span class="line">偏特化：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>*&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="keyword">double</span> ittt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_template</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_template_func</title>
    <url>/2021/01/09/cpp-template-func/</url>
    <content><![CDATA[<h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>为什么需要函数模板：类型限制了函数的通用性，参数换一种类型，即得重新再定义一个处理流程相同的函数；<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>,ints等等，甚至实现了&gt;运算符函数的类也是如此；</span><br></pre></td></tr></table></figure></p>
<h3 id="什么是函数模板："><a href="#什么是函数模板：" class="headerlink" title="什么是函数模板："></a>什么是函数模板：</h3><p>In C++, function templates are functions that serve as a pattern for creating other similar functions.<br>在c++中，函数模板即是能作为一个模式来创建其他相似函数的一组函数；<br>在c++函数模板中，我们使用占位符来替代部分或全部的函数中具体类型的变量；<br>返回值，形参，以及函数内定义的局部变量等都能使用；<br>typename和class 的区别：<a href="http://www.cplusplus.com/forum/general/8027/" target="_blank" rel="noopener">http://www.cplusplus.com/forum/general/8027/</a></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;                                                             </span></span></span><br><span class="line"><span class="comment">//using namespace std;导入这个为什么会出错？这里也定义了min函数，那么会冲突？                            </span></span><br><span class="line"><span class="keyword">using</span>  <span class="built_in">std</span>::<span class="built_in">cout</span>;                                                              </span><br><span class="line"><span class="keyword">using</span>  <span class="built_in">std</span>::<span class="built_in">endl</span>;                                                              </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                          </span><br><span class="line">   <span class="comment">/* T min( T x, T y)&#123; </span></span><br><span class="line"><span class="comment">            T t=x;                                          </span></span><br><span class="line"><span class="comment">        return (x+t&gt;y)?y:x;                                                      </span></span><br><span class="line"><span class="comment">&#125;   */</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">( T x, T y)</span></span>&#123;                                       </span><br><span class="line">        <span class="keyword">return</span> (x&gt;y)?y:x;                                                      </span><br><span class="line">&#125;                                                                               </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>                                                                    </span></span><br><span class="line"><span class="function"></span>&#123;                                                                              </span><br><span class="line">    <span class="keyword">int</span> i = min(<span class="number">3</span>,<span class="number">4</span>);                                                          </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;                                                             </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="keyword">double</span> d=min(<span class="number">6.38</span>,<span class="number">12.32</span>);                                                  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;                                                             </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="keyword">char</span> ch=min(<span class="string">'a'</span>,<span class="string">'6'</span>);                                                      </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;                                                            </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">建议，这里的模板定义加上<span class="keyword">const</span>和使用引用会更好，使用引用的原因是传入的参数有可能是类类型(这样参数类型和返回值应为引用更通用），使用<span class="keyword">const</span>是为了避免对传入参数的原变量造成影响；如下：</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">const</span> T&amp; min(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)&#123;</span><br><span class="line">        <span class="keyword">return</span> (x&gt;y)?y:x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="更多使用例子"><a href="#更多使用例子" class="headerlink" title="更多使用例子"></a>更多使用例子</h4><p>用于类类型:注意类需要实现对应的运算符函数等；<br>模板类型和实际类型混合<br>指针类型：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">average</span>(<span class="title">T</span> *<span class="title">array</span>, <span class="title">int</span> <span class="title">length</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; length; ++count)</span><br><span class="line">        sum += <span class="built_in">array</span>[count];</span><br><span class="line"> </span><br><span class="line">    sum /= length;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多个模板类型</p>
<h3 id="假设这里我传入了int-会怎么样？"><a href="#假设这里我传入了int-会怎么样？" class="headerlink" title="假设这里我传入了int* 会怎么样？"></a>假设这里我传入了int* 会怎么样？</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">来看一个例子：指针的话会优先匹配指针</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;导入这个为什么会出错？这里也定义了min函数，那么会冲突？                            </span></span><br><span class="line"><span class="keyword">using</span>  <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span>  <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">   <span class="comment">/* T min( T x, T y)&#123; </span></span><br><span class="line"><span class="comment">            T t=x;                                          </span></span><br><span class="line"><span class="comment">        return (x+t&gt;y)?y:x;                                                      </span></span><br><span class="line"><span class="comment">&#125;   */</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">( T* x, T* y)</span></span>&#123;<span class="comment">//这样的话，这里的x实际上是指针类型，比如传入int* ==&gt; T* ，要返回int的话，得对x做*，如*x</span></span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"real"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> (*x&gt;*y)?*y:*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*template&lt;typename T&gt; 模板只能匹配参数，不能匹配返回值，所以这里和上面的是重复的；编译会报错；</span></span><br><span class="line"><span class="comment">T* min(T* x,T* y)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">     return (x&gt;y)?y:x;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T x,T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = min(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> d=min(<span class="number">6.38</span>,<span class="number">12.32</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch=min(<span class="string">'a'</span>,<span class="string">'6'</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//以上匹配的是非指针的版本+</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"now pointer"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> m =<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> jj=min(&amp;m,&amp;n); <span class="comment">//这里匹配的是指针的</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m:"</span>&lt;&lt;&amp;m&lt;&lt;<span class="string">"n:"</span>&lt;&lt;&amp;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(&amp;m,&amp;n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;jj&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">~</span><br></pre></td></tr></table></figure>
<h3 id="函数模板的特化-什么时候需要"><a href="#函数模板的特化-什么时候需要" class="headerlink" title="函数模板的特化 什么时候需要"></a>函数模板的特化 什么时候需要</h3><p>引入：有时候，针对具体的类型，我们想定义具体的函数，而不是用模板中对所有类型通用的函数时，可以定义一个函数模板的特化函数；<br>语法：<br>eg</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Storage(T value)</span><br><span class="line">    &#123;</span><br><span class="line">         m_value = value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Storage()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Define some storage units</span></span><br><span class="line">    Storage&lt;<span class="keyword">int</span>&gt; nValue(<span class="number">5</span>);</span><br><span class="line">    Storage&lt;<span class="keyword">double</span>&gt; dValue(<span class="number">6.7</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print out some values</span></span><br><span class="line">    nValue.print();</span><br><span class="line">    dValue.print();</span><br><span class="line">&#125;</span><br><span class="line">那么当我们想针对<span class="keyword">double</span>有个特殊专属的print函数时，应该怎么做？</span><br><span class="line">答案是针对其写一个函数：特化：</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Storage&lt;<span class="keyword">double</span>&gt;::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::scientific &lt;&lt; m_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">这样，当编译器实例化模板时，<span class="keyword">double</span>时，就会使用这个特化的print;</span><br><span class="line">The template &lt;&gt; tells the compiler that this is a template function, but that there are no template parameters (since in this case, we’re explicitly specifying all of the types). Some compilers may allow you to omit this, but it’s proper to include it.</span><br></pre></td></tr></table></figure>
<h3 id="类相关例子："><a href="#类相关例子：" class="headerlink" title="类相关例子："></a>类相关例子：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类模板的构造函数也可以这样处理：</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">Storage&lt;<span class="keyword">char</span>*&gt;::Storage(<span class="keyword">char</span>* value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Figure out how long the string in value is</span></span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (value[length] != <span class="string">'\0'</span>)</span><br><span class="line">        ++length;</span><br><span class="line">    ++length; <span class="comment">// +1 to account for null terminator</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Allocate memory to hold the value string</span></span><br><span class="line">    m_value = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Copy the actual value string into the m_value memory we just allocated</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; length; ++count)</span><br><span class="line">        m_value[count] = value[count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_template</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_template_deepin</title>
    <url>/2021/01/09/cpp-template-deepin/</url>
    <content><![CDATA[<h3 id="模板是什么，为什么要引入模板："><a href="#模板是什么，为什么要引入模板：" class="headerlink" title="模板是什么，为什么要引入模板："></a>模板是什么，为什么要引入模板：</h3><p>模板是用来生成代码的，通过模板可以定义一组类型的共同行为；<br>为什么要引入模板：<br>继承和组合是实现重用代码的方法，而容器也是，为了实现能承载不同类型的容器，java等其他语言用所有类都继承于根类型等方式，<a id="more"></a><br>而c++这里为了减少不必要的开支，和冗余，采用预定义等方式，在预处理和编译时，将T替换为实际类型参数，并生成对应的类型；<br>来从而实现了容器；<br>所以说：模板的引入，是为了实现容器的需求；</p>
<p>那么容器呢？为什么容器被需要？<br>栈的内存管理依赖于函数本身，或者说操作系统，在函数的调用结束后，会回收相关的存于栈的结构，所以不用我们去考虑清理的事情；<br>但是当我们在堆上使用时，malloc/new后，往往需要free/delete,在传统的c中，malloc后会需要进行free，否则程序运行时会出现内存泄漏；<br>容器的真正需求，是在这种情景下，减轻程序员的负担，担负起自动new和清理的工作；</p>
<p>c++是怎么做的？ c++标准容器，用new创建需要的对象，将其指针放入容器中，实际使用时取出并处理，这种方法创建的只是对象，<br>清理时依赖析构函数时进行合理的free；不过需要注意，当存储的对象是指针时，此时的指针需要程序员自己去new和释放；<br>同时为了支持承载多种类型的对象，所以模板就被创建出来；</p>
<h3 id="模板的基本原理："><a href="#模板的基本原理：" class="headerlink" title="模板的基本原理："></a>模板的基本原理：</h3><p>为了解决多类型：有几个方法，模板采用的是第三个：<br>1) c方法复制粘贴代码<br>2) 继承来实现代码重用，但是需要学习基础类库<br>3) 实现类似宏替换的逻辑，并放到编译器中，编译器识别到类似声明，就进行替换，从而重新生成类定义等，也取消类型的指定；而容器的实现则是<br>    以堆来存放一组特定类型对象。类似对象数组等；</p>
<h3 id="模板是怎么工作的，工程上，内部结构等，编译器的作用；"><a href="#模板是怎么工作的，工程上，内部结构等，编译器的作用；" class="headerlink" title="模板是怎么工作的，工程上，内部结构等，编译器的作用；"></a>模板是怎么工作的，工程上，内部结构等，编译器的作用；</h3><h4 id="1）工程文件上，如何预编译，编译，链接等；"><a href="#1）工程文件上，如何预编译，编译，链接等；" class="headerlink" title="1）工程文件上，如何预编译，编译，链接等；"></a>1）工程文件上，如何预编译，编译，链接等；</h4><p> 模板中分为函数模板和类模板：<br>类模板：定义和成员函数实现都是写在头文件中<br>函数模板：定义声明等都是写在头文件中；<br>模板编译模型：<br>模板的完整定义都是放在每个编译单元中；例如完全放在单个文件程序中，或者放在文件程序的头文件中；和传统的编程方式背道而驰；</p>
<h5 id="1-传统的为什么要这么做？—分离模型："><a href="#1-传统的为什么要这么做？—分离模型：" class="headerlink" title="(1) 传统的为什么要这么做？—分离模型："></a>(1) 传统的为什么要这么做？—分离模型：</h5><p>不要放置分配存储空间的任何东西(这条规定是为了防止在链接期间的多重定义错误)，编译期间是单个文件的，此时不会出现，但是链接的时候是多个实现文件，若是头文件里也定义了，就会导致链接的时候多重定义，而编译器对此并没有去重；</p>
<p>头文件中的非内联函数体会导致多函数的定义，从而导致链接错误；<br>隐藏来自客户有益函数实现，减少了编译时链接；<br>隐藏代码，代码所有权；<br>头文件越小，编译时间越短；</p>
<h5 id="2-模板时包含模型，那这样客户代码想隐藏怎么办？"><a href="#2-模板时包含模型，那这样客户代码想隐藏怎么办？" class="headerlink" title="(2) 模板时包含模型，那这样客户代码想隐藏怎么办？"></a>(2) 模板时包含模型，那这样客户代码想隐藏怎么办？</h5><p>在template&lt;..&gt;后的任何东西都意味着编译器在当时不为它分配存储空间，而是一直处于等待状态直到一个模板示例告知，而此时是编译器在碰到模板示例时，往往是编译期间，然后生成对应的类，然后在运行时，才分配对象的空间；在编译器和连接器中有机制能去掉同一模板的多重定义；所以为了使用方便，几乎总是在头文件中放置全部的模板声明和定义；</p>
<p>模板代码本质上只是产生代码的指令，不是真正的代码，只有实例化了才是，一个编译器在编译期间看到模板的完整定义后，在同一个翻译单元中碰到模板实例化点时，也会在其他翻译单元碰到同样的实例化点，这样就会重复生成实例化代码；而编译器和连接器需要解决这个重复定义；<br>这种有两个缺点：<br>a  编译时间增加  b 无法隐藏实现代码；<br>如何处理？ 如何实现分离？<br>一种是显示实例化，一种是导出模板：<br>显示实例化：<br>    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	eg:</span><br><span class="line">ourMin.h :</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OURMIN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OURMIN_H</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">ourMin.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ourMin.h"</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (a&lt;b)?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UseMin1.cpp:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"outMin.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usemin1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;min(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UseMin2.cpp:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">#Include <span class="string">"outMin.h"</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usemin2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;min(<span class="number">3.2</span> ,<span class="number">4.3</span>) &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.cpp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usemin1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usemin2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    usemin1();</span><br><span class="line">    usemin2();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>建立这个程序式，连接器报告有未解析的min<int>() 和min<double>()的外部引用； 因为编译器在min的特化时，只有min的声明可见，定义不可见，编译器认为它可能来自于其他单元，所以即没有实例化，问题留给了连接器，连接器无法找到；<br>所以可用加一个显示实例化来进行，即显示特化：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Minstances.cpp:</span><br><span class="line">#Include <span class="string">"ourMin.cpp"</span><span class="comment">//因为编译器需要模板定义来实例化；</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">const</span> <span class="keyword">int</span>&amp; min&lt;min&gt;(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;);</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">const</span> <span class="keyword">double</span>&amp; min&lt;<span class="keyword">double</span>&gt; (<span class="keyword">const</span> <span class="keyword">double</span> &amp;,<span class="keyword">const</span> <span class="keyword">double</span>&amp;);</span><br></pre></td></tr></table></figure></double></int></p>
<p>导出模板：<br>export关键字： </p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-模板定义的几种方式："><a href="#2-模板定义的几种方式：" class="headerlink" title="2)模板定义的几种方式："></a>2)模板定义的几种方式：</h4><p>声明和内联函数的形式<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span> :</span><br><span class="line">       AA ()&#123;&#125;;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;...&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">声明和非内联函数的形式；</span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="title">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">          <span class="keyword">enum</span> &#123; size = <span class="number">1000</span>&#125;;</span><br><span class="line">          T A[size];</span><br><span class="line">          <span class="keyword">public</span>:</span><br><span class="line">               T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">    &#125;;</span><br><span class="line">       <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="title">T</span>&amp; <span class="title">Array</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line">               .....</span><br><span class="line">              <span class="keyword">return</span> A[index];</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>声明在头文件，定义在cpp的显示实例化，注意需要cpp加显示实例声明，见上面2</p>
<h4 id="3）模板的一些使用技巧：-在stl源码解析中："><a href="#3）模板的一些使用技巧：-在stl源码解析中：" class="headerlink" title="3）模板的一些使用技巧： 在stl源码解析中："></a>3）模板的一些使用技巧： 在stl源码解析中：</h4><pre><code>涉及以下几种： 类型萃取，迭代器，智能指针(引用释放等) ,泛型算法等等；
</code></pre><h3 id="模板的使用细节："><a href="#模板的使用细节：" class="headerlink" title="模板的使用细节："></a>模板的使用细节：</h3><h4 id="1-模板参数：-类型-基础或用户自定义-编译时常数值-整数，指针或某些静态实体的引用，通常作为无类型模板参数，支持默认参数-其他模板；"><a href="#1-模板参数：-类型-基础或用户自定义-编译时常数值-整数，指针或某些静态实体的引用，通常作为无类型模板参数，支持默认参数-其他模板；" class="headerlink" title="1) 模板参数： 类型(基础或用户自定义), 编译时常数值(整数，指针或某些静态实体的引用，通常作为无类型模板参数，支持默认参数),其他模板；"></a>1) 模板参数： 类型(基础或用户自定义), 编译时常数值(整数，指针或某些静态实体的引用，通常作为无类型模板参数，支持默认参数),其他模板；</h4><p>模板类型参数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line">     ....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">template</span>&lt;class&gt; <span class="title">class</span> <span class="title">Seq</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Container</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Seq&lt;T&gt; seq;<span class="comment">//通知编译器，Seq是一个模板；本例子中Seq代表Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">使用：Container&lt;<span class="keyword">int</span>,Array&gt; container;</span><br><span class="line">还可以支持标准库中的容器：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">template</span>&lt;class U,class = allocator&lt;U&gt;&gt;  <span class="title">class</span> <span class="title">Seq</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Container</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Seq&lt;T&gt; seq;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用： Container<int ,vector=""> xxx;实际上容器适配器就是用类似的方法实现的，如stack<br>typename关键字用法；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">当在模板中用T::id这种类型时，编译器会默认解析为T类中的静态成员id,而不会认为这个是一个内部类，所以，当用法为：</span><br><span class="line">T::id i ;这种定义变量的方式时，会出错，此时需要向编译器说明这个是一个嵌套类；</span><br><span class="line">所以<span class="keyword">typename</span>在这里的作用： <span class="number">1</span>) 声明是一个类型，<span class="number">2</span>）可以替换<span class="class"><span class="keyword">class</span> <span class="title">template</span>&lt; typename T&gt; <span class="title">class</span> <span class="title">X</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">typename</span>并不能起到定义新类型的作用，可以用<span class="keyword">typedef</span> <span class="keyword">typename</span> Seq&lt;it&gt;::iterator It;类似的</span><br></pre></td></tr></table></figure></int></p>
<p>template关键字的作用：<br>1）声明模板<br>2）模板中遇到&gt; &lt;等和模板的&gt; &lt;混合时，用template声明；</p>
<h4 id="2-成员模板；"><a href="#2-成员模板；" class="headerlink" title="2)成员模板；"></a>2)成员模板；</h4><p>就是在类模板中定义一个新的内部类模板：<br>eg:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Outer</span>&#123;</span></span><br><span class="line">     <span class="keyword">public</span> :</span><br><span class="line">         <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>&gt; <span class="title">class</span> <span class="title">inter</span>&#123;</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                 <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">template</span>&lt;class R&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Outer</span>&lt;T&gt;:</span>:inter&lt;R&gt;::g() &#123;</span><br><span class="line">      ..</span><br><span class="line">&#125;</span><br><span class="line">使用：</span><br><span class="line"> Outer&lt;<span class="keyword">int</span>&gt;::inter&lt;<span class="keyword">bool</span>&gt; interr;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-有关函数模板的内容"><a href="#3-有关函数模板的内容" class="headerlink" title="3) 有关函数模板的内容"></a>3) 有关函数模板的内容</h4><p>1) 函数模板定义了一簇函数； —函数模板参数的类型如何推断：涉及一些参数可以省略的问题<br>2) 函数模板重载：其实是直接定义了普通函数，这样若是符合普通函数的类型则调用的是定义的普通函数，否则是模板生成；<br>3）以一个已生成的函数模板地址作为参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T*)</span> </span>&#123;&#125;</span><br><span class="line">void h(void (*pf)(int*)) &#123;&#125;</span><br><span class="line">template&lt;typename T&gt;void g(void (*pf)(T*)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">    h(&amp;f&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">    h(&amp;f);</span><br><span class="line">    g&lt;<span class="keyword">int</span>&gt;(&amp;f&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">    g&lt;<span class="keyword">int</span>&gt;(&amp;f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4)将函数用到stl序列容器中：TODO<br>5）函数模板的半有序： 即T, T<em>,const T</em>的区分，优先匹配特化程度最高的那个模板；他们的特化程度逐渐递增；</p>
<h4 id="4-模板特化相关"><a href="#4-模板特化相关" class="headerlink" title="4)模板特化相关"></a>4)模板特化相关</h4><p>显示特化：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>&amp; min&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(.....)</span><br></pre></td></tr></table></figure></p>
<p>半特化：<br>比如有两个参数，只限定了其中一个类型；<br>防止代码膨胀– TODO</p>
<h4 id="5-模板中的名称查找问题"><a href="#5-模板中的名称查找问题" class="headerlink" title="5)模板中的名称查找问题"></a>5)模板中的名称查找问题</h4><p>编译器解析模板定义，并寻找明显的语法错误，还要对其所能解析的所有名称进行解析；对于不依赖模板参数的名称，编译器使用普通名称查找解析他们，不能解析的就是关联名称，只有等到实例化才知道；<br>模板和友元：  –TODO</p>
<h4 id="6-模板编程中的习语"><a href="#6-模板编程中的习语" class="headerlink" title="6)模板编程中的习语:"></a>6)模板编程中的习语:</h4><p>1) 特征：将与某种类型相关联的所有声明绑定在一起的实现方式；<br>2）策略： 其实就是类似萃取类型；<br>3）神奇的递归模板，在编译期间就算出来值了；运行时只需要读取即可</p>
<h4 id="7-模板元编程："><a href="#7-模板元编程：" class="headerlink" title="7)模板元编程："></a>7)模板元编程：</h4><p>1） 编译时编程 :模板中编译时循环，循环分解，编译时选择，编译时断言—即利用模板，在编译时就算出值，减少运行开销哈<br>2)  表达式模板：</p>
<h4 id="8-模板与继承：-模板实例也可以作为被继承方；"><a href="#8-模板与继承：-模板实例也可以作为被继承方；" class="headerlink" title="8)模板与继承： 模板实例也可以作为被继承方；"></a>8)模板与继承： 模板实例也可以作为被继承方；</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xx</span>:</span> <span class="keyword">public</span> tes&lt;A&gt; &#123;&#125;;</span><br><span class="line">模板其他资料；见书：c++ templates,the complete guide</span><br></pre></td></tr></table></figure>
<h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><p>懒惰初始化，使用时才分配空间，读写时分配<br>存放指针对象时，为了避免多重释放，可以实现所有权函数，拥有所有权的才有释放的权利 owns函数</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref:"></a>ref:</h3><p>c++编程思想；</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_template</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb基础</title>
    <url>/2020/07/11/gdb%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>1、总体<br>GDB可以做四种主要的事情（以及支持这些事情的其他事情）来帮助您捕获行为中的错误：<br><a id="more"></a><br>1）启动程序，并指定可能影响其行为的所有内容。<br>2）使程序在指定条件下停止。<br>3）检查程序停止时发生的情况。<br>4）更改程序中的内容，以便您可以尝试纠正一个错误的影响，然后继续学习另一个错误。<br>2、一个例子：<br>gdb 调试运行一个程序：<br>$ gdb m4  –运行<br>(gdb) set width 70 –设置显示最大字符数，类似more<br>(gdb) break m4_changequote   –设置断点，断点可以是某个函数，如main<br>Breakpoint 1 at 0x62f4: file builtin.c, line 879.<br>(gdb) run<br>Starting program: /work/Editorial/gdb/gnu/m4/m4  –开始运行<br>(gdb) n   –next 不进入函数运行，运行下一行；<br>(gdb) s  –step 运行下一行，遇到函数会进入</p>
<p>(gdb) bt –backtrace 打印调用栈<br>(gdb) p lquote  –打印变量lquote,这个是变量名<br>(gdb) p 表达式，这个表达式可以是符合语法的表达式，比如赋值语句和函数调用等，是生效的；<br>eg (gdb) p ++a</p>
<p>$1 = 0x35d40 “<quote>“<br>(gdb) l    —list，显示源代码<br>533             xfree(rquote);<br>(gdb) Ctrl-d –退出程序<br>(gdb)quit  /q –退出gdb<br>3、经常使用分类<br>3.1 如何开始：<br> 1）gdb programname<br>        2）gdb programname corefile<br>        3)  gdb  programname pid   / gdb -p pid  (关联上一个-g编译过的正在运行的进程)<br>        4)  gdb –args programname arg1 2 3….<br>        eg:gdb –args gcc -O2 -c foo.c<br>        5) gdb xx     –silent/–quit /-q 不用输出信息<br>3.2 在gdb中也可以使用shell指令：<br>(gdb) !ifconfig</quote></p>
<p>3.3 设置log文件<br>使用技巧：<br>1）回车表示重复上一个命令，除了run等；<br>2）step 数字，可以表示步进多少<br>3.4 设置打印方式：<br>1)要更改要打印的数组元素的限制<br>(gdb)set print elements 10<br>2)是否打印数组：<br>       (GDB) set print array on<br>       (GDB) print some_array<br>       (GDB) set print array off<br>3.5 gdb的自动补全，按tab即可，甚至可以补全函数名；<br>3.6 gdb 命令有option ,tab键可以召唤出来；<br>3.7 gdb和线程；<br>3.8 gdb的栈概念<br>4  常见命令<br>gdb栈查看命令<br>backtrace [option]… [qualifier]… [count]<br>bt [option]… [qualifier]… [count]<br>(gdb) frame 3<br>(gdb) frame level 3<br>(gdb) info frame<br>Stack level 1, frame at 0x7fffffffda30:<br>向上或向下跳帧；<br>up n<br>down n </p>
<p>(gdb) frame apply all p j</p>
<p>#0  some_function (i=5) at fun.c:4<br>No symbol “j” in current context.<br>(gdb) frame apply all -c p j</p>
<p>#0  some_function (i=5) at fun.c:4<br>No symbol “j” in current context.<br>打印变量：p<br>显示源码 l</p>
<p>5 参考资料</p>
<p><a href="https://scc.ustc.edu.cn/zlsc/sugon/intel/debugger/cl/index.htm#commandref/gdb_mode/cmd_set_width.htm" target="_blank" rel="noopener">https://scc.ustc.edu.cn/zlsc/sugon/intel/debugger/cl/index.htm#commandref/gdb_mode/cmd_set_width.htm</a><br>more:<br><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a><br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">https://sourceware.org/gdb/current/onlinedocs/gdb/</a></p>
<p>使用例子：</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>我理解的心理模型</title>
    <url>/2020/04/03/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E5%BF%83%E7%90%86%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>以下内容均为本人构想理解提出，如有雷同纯属巧合，仅为本人粗略观点，不期赞同；</p>
<h3 id="一、模型概念"><a href="#一、模型概念" class="headerlink" title="一、模型概念"></a>一、模型概念</h3><h4 id="1）模型的广义解释"><a href="#1）模型的广义解释" class="headerlink" title="1）模型的广义解释"></a>1）模型的广义解释</h4><p>模型用于抽象化一类事物的特点和规律，甚至是发展周期；模型常见有数学模型，物理模型，工业模型等等；<a id="more"></a><br>如数学模型，是用来处理一类问题，通过输入，模型处理，得到想要的预测输出，模型常用来预测和计算问题的结果和答案；逼近结果甚至计算出结果本身；最简单如: 1天卖10斤菜，预测10天卖多少斤这种简单问题，则模型就是10*天数；输入就是天数，输出就是卖了多少斤；复杂一点可以加上条件，阴天卖多少斤，晴天卖多少斤，阴天有几天，或者甚至让你预测天气等等；</p>
<h4 id="2）复杂的模型"><a href="#2）复杂的模型" class="headerlink" title="2）复杂的模型"></a>2）复杂的模型</h4><p>用于解释数学的模型，还可以用来解释更多内容，并归结升级到当下流行的人工智能中的机器学习模型和深度学习等等；这些大部分也是通过输入和模型获得输出；而模型的建立将是一个很复杂繁琐的过程；模型的正确性也是个重要因素；</p>
<h3 id="二、心理模型"><a href="#二、心理模型" class="headerlink" title="二、心理模型"></a>二、心理模型</h3><h4 id="1）起源"><a href="#1）起源" class="headerlink" title="1）起源"></a>1）起源</h4><p>PS: 博主其实从初中就开始关注心理学，不过没有深入了解；最初想探寻人的心理模型，是在博主遇到19年创伤事件后，不明白心理为什么会出现如此变化；且还没有去借助外在心理学知识来解释，尝试自己去理解时，总结出来的；</p>
<h5 id="（1）动物行为基本分析："><a href="#（1）动物行为基本分析：" class="headerlink" title="（1）动物行为基本分析："></a>（1）动物行为基本分析：</h5><p>​       动物通过感知周围的环境刺激如食物，猎食者等，和自身的内在刺激如饥饿等，输入，进入到自己的简单模型，处理后进行反应即输出，比如见到猎食者，输入刺激，模型处理的结果是要逃跑，于是反应为逃跑等等；而动物的几乎一切的行为活动，贯穿一生，都是这样度过的；所以动物的本质，是个输入输出模型；从这个角度理解的话。</p>
<h5 id="（2）人类"><a href="#（2）人类" class="headerlink" title="（2）人类"></a>（2）人类</h5><p>​       人类其实也是动物，只是因为人类有高级的模型，所以能使得有控制输入输出，以及控制模型的能力；但因为基因和自身的认知等影响，导致不同的人对这些控制能力不同，就算是最强的人，对这些控制也不是100%的；</p>
<p>​        人的模型很复杂，人需要适应多变的环境，并安稳的生存下来，需要得到更多的信息，来应对种种危险等等；所以人类进化出了各种感官器，处理器如最强的大脑；内在神经感受器等等；</p>
<h4 id="2）模型基本框架"><a href="#2）模型基本框架" class="headerlink" title="2）模型基本框架"></a>2）模型基本框架</h4><p>人的心理模型在：</p>
<p>外界的输入–&gt;人对应的感受器–&gt;进入处理器模型–&gt;决策后输出；</p>
<p>以下是处理器模型，优先从第一层传递到第五层；</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">第五层<span class="symbol">:---------</span>自我意识：理性思考(一般有多个)------------</span><br><span class="line">第四层<span class="symbol">:-------</span>受限的自我意识：感受----------------------</span><br><span class="line">第三层：------受约束的自我意识：道德，法律-----------------</span><br><span class="line">第二层：------潜意识，习惯-----------------------------</span><br><span class="line">第一层：------身体，物理感受和直接处理------------------</span><br></pre></td></tr></table></figure>
<p>身体：比如膝跳反应等；</p>
<p>潜意识习惯：比如交流中的口头禅等；</p>
<p>其他类似；总是先经过第一层，第一层处理不了或者不需要则往上传递；严格来说也不是层级关系，是一种分类的处理；</p>
<p>输入输出方式：</p>
<p>可以分为两种：</p>
<p>1、接收输入，处理(处理包括思维层面，感受等等)，表现出来输出(可能是行为或者单纯的感受并会存储记忆，内反馈形成下次处理同类型问题的经验或者进步)；</p>
<p>2、进行输出(可能之前得到输入或单纯想输出)，得到输入，处理，感受；</p>
<h4 id="3）人心理模型的基本组成分析"><a href="#3）人心理模型的基本组成分析" class="headerlink" title="3）人心理模型的基本组成分析"></a>3）人心理模型的基本组成分析</h4><h5 id="（1）-组成：输入源，感受器，处理器，输出器"><a href="#（1）-组成：输入源，感受器，处理器，输出器" class="headerlink" title="（1） 组成：输入源，感受器，处理器，输出器"></a>（1） 组成：输入源，感受器，处理器，输出器</h5><h5 id="（2）各个组成分析："><a href="#（2）各个组成分析：" class="headerlink" title="（2）各个组成分析："></a>（2）各个组成分析：</h5><h6 id="A-输入源："><a href="#A-输入源：" class="headerlink" title="A 输入源："></a>A 输入源：</h6><p>​    一个是外部输入源，对应于第一种方式：输入-&gt;处理-&gt;输出的方式：很多，几乎是无限的，而感受器却只有有限种类型，而为了缔结输入源，感受器和输出等的联系，所建立的缔结关系，也是无限的；即体现为知识，能力等等；输入源举例：不同的食物，不同的感受刺激如漂亮的花朵等等；深层的如赞美的话，得到礼物等等，其他人也是一种输入源；</p>
<p>​     一个是内部的输入源：对应于第二种方式：输出-&gt;输入-&gt;处理的方式：很多，推理，瞎想，想象，创作等等；甚至简单如思考后的说话等等；</p>
<h6 id="B-感受器："><a href="#B-感受器：" class="headerlink" title="B 感受器："></a>B 感受器：</h6><p>   感受器目前我了解到的有：</p>
<p>外在实体：触觉，嗅觉，味觉，听觉，视觉，痛觉，温觉；</p>
<h6 id="C-处理器："><a href="#C-处理器：" class="headerlink" title="C 处理器："></a>C 处理器：</h6><p> 见上图；最低层次为身体，这个和动物也类似，即本能，人会本能的躲避危险，碰到烫的东西会自动收回；这些是不经过大脑的；</p>
<p>接着是潜意识和习惯等，大部分没有被大脑意识到；这个层面反应很快；类似口头禅，可以理解为一个map,针对某个输入，有确定的输出；所以往往直接表现出来；</p>
<p>接着是感受和道德层面：某个事物让自己感受到开心或伤心，可能还来不及去考虑，就直接反应，而道德法律也是，即自己的底线；这种一般不用思考；这个其实也是意识层面，只是是较浅的意识；当然有些人是感受强势些，有些人是理性意识强势些；</p>
<p>意识层面：即在感受和道德无法做决定时，则到了意识层面，经过处理后得到反应；而这个层面的思考，取决于人的认知，学识，智慧，即智商，情商等等；更多的是：涉及计算，规律，预测，分析问题本质，多因素考虑等等；</p>
<h6 id="D-输出器"><a href="#D-输出器" class="headerlink" title="D 输出器"></a>D 输出器</h6><p>​    内在感受：快乐感受器，悲伤感受器，愤怒感受器，害怕感受器等自尊感受器，安全感受器，归属感，等等；基本感受表现器，这个和输入其实息息相关；只有很少的处理过程；比如快乐往往很简单；不用经过太多的思考；偏向于对应于输入输出方式</p>
<p>输出方式也有：行为，选择决策，语言等等；</p>
<h4 id="4）人类模型的复杂度分析"><a href="#4）人类模型的复杂度分析" class="headerlink" title="4）人类模型的复杂度分析"></a>4）人类模型的复杂度分析</h4><p>(1)  人的感受器丰富，不仅有外在感受器如：视觉，听觉，触觉，嗅觉，味觉，还有如痛觉等内在感受器，甚至高级的自尊感，安全感，归属感等等一些进化的非显性但是实际存在的感觉器；（这些感受器大多是因为社交体系，和他人的情感体系环境下产生的，和等级等观念也相关）</p>
<p>(2)  人的感受器特性：感受器有个特点，对初次刺激记忆最深，敏感度最高，对之后的相同刺激习惯了，就显得表现的不是很强烈，可能是因为进化的原因，第一次不知道是不是危险，所以显得最警惕，之后熟悉了便失去了焦点；所以才会有腻了，味觉疲劳等现象；而对于隔了很久的没有的刺激，再次刺激也会有比较大的反应，这个也是很容易理解的；也就是边际递减效应；</p>
<p>(3)  外界输入类型的多样性，有些输入是人类自身创造的；而这个太多了；比如游戏；</p>
<p>(4)  人的处理器复杂度高：正常处理：输入到达身体层面能处理则不会传递上去：如人碰到烫的东西自动收回等等；若能传递，则到潜意识，接着到意识进行逻辑等处理，而意识层面的处理是最复杂的；</p>
<p>(5)  人的感受器对应的是输入，而人的一部分感受器可以作为输出，而输出同样也是复杂，不同类型的人不同环境下等等输出的效果可能类似，但是输出方式不同；</p>
<h3 id="三、详解输入源等"><a href="#三、详解输入源等" class="headerlink" title="三、详解输入源等"></a>三、详解输入源等</h3><p>输入源分为外部输入源和内部输入源：当你的输入源能量大，形成一个能量场，别人也会被你吸引，到你的能量场，于是你可能成为别人眼中的有趣的人；而最好这些不要太过依赖外部能量的提供；生活的品质和热爱表现于此；</p>
<p>1） 外部输入源：</p>
<p>划分方式1：根据特性划分</p>
<p>人或其他活物：亲人朋友爱人，崇拜对象，宠物等等，这种可以提供长期的源，和刺激；</p>
<p>一次性物：食物，视频等等</p>
<p>游戏/竞技/运动：同时刺激多个感官，而且高反馈即时反馈的特性让人享受其中；</p>
<p>…</p>
<p>划分方式2：根据归属划分：</p>
<p>现实物理世界日常活动：</p>
<p>吃-食物和怎样获取食物：自己下厨，外卖刷剧，堂食探索，各种体验不同；</p>
<p>穿-衣服化妆护肤等颜值相关，保暖舒适好看漂亮气质吸引别人等等；</p>
<p>住-居家环境宜家家居：居住环境构成和特点：干净整洁安全安静床舒适度气味等等；</p>
<p>行-交通工具：汽车高铁公交飞机走路自行车跑步平衡车轮滑等不同体验；空间方位认路等体验；”</p>
<p>健康-健身等；喝茶泡脚吃等等，</p>
<p>纯玩：打球游戏等等；</p>
<p>工作-知识技能解决问题需求，</p>
<p>社交-人</p>
<p>网络世界：游戏，视频媒体，文字信息，虚拟化，创作编程等，社交购物等和现实挂钩的，统称信息；而媒介可以是手机，平板，电脑，手表，智能硬件等等；</p>
<p>2） 内部输入源：</p>
<p>内心世界：</p>
<p>关系情感：友情爱情亲情等；</p>
<p>欲望：性，贪，懒</p>
<p>自尊自信等需求；</p>
<h3 id="四、心理模型的影响因素和发展周期"><a href="#四、心理模型的影响因素和发展周期" class="headerlink" title="四、心理模型的影响因素和发展周期"></a>四、心理模型的影响因素和发展周期</h3><p>1)   模型的影响因素：基因，家庭环境，学校环境，社会环境；环境包括人；</p>
<p>2)   模型的变化特性：人格，气质，性格，等是不容易变化的，可以理解为硬编码，强缔结；而意识层面涉及情商，智商等认知是容易改变的，而道德，感受涉及三观等等，也是能改变的，不过比意识层面更难；</p>
<p>3)   模型的发展周期：</p>
<p>人诞生时，是婴儿时期，此时还未被环境影响，各个感受器处于初始状态；模型原始由基因决定；婴儿期性本善，性本偏外向</p>
<p>孩童时期：在接受家庭环境影响，父母等影响后，感受器特质发生改变，此时比如接收到的某种刺激较少，比如爱，则缺爱，则长大后，第一次感受到爱后，会比别人表现更强烈；内向或者外向：一开始是外向的，通过输出能量，但是得到的反馈，输入进来的时候被判断为不好的感受，即负能量，则长此以往，则不愿意再去输出，形成内向的性格，即只喜欢输出到内部环境；</p>
<p> 青少年：开始受到身体激素影响，并开始更理性的关注周围的事物，受到学校影响较大；</p>
<p> 成年期：模型基本稳定，会轻微调整，不过受到创伤等大事会重新建立等；</p>
<p>PS:模型的影响，包括模型的感受器，处理器和表现(输出);感受器的特质:敏感度等是能被随着发展周期改变的；</p>
<p>学校环境：更多的是改变道德，感受和意识层面，少量的改变潜意识和习惯；</p>
<h3 id="五、用此心理模型来解释一些心理现象"><a href="#五、用此心理模型来解释一些心理现象" class="headerlink" title="五、用此心理模型来解释一些心理现象"></a>五、用此心理模型来解释一些心理现象</h3><p>1） 人格：人格指一个人在一定情况下所作行为反应的特质，即人们在生活、工作中独特的行为表现，包括思考方式、决策方式等；包括了内向外向，感觉直觉，思考情感，判断知觉；</p>
<p>内向外向：内向的人偏向于第一种方式：即输入-&gt;处理-&gt;输出；而外向的人偏向于输出-&gt;处理-&gt;输入的方式；和小时候的经历等有关；</p>
<p>感觉直觉：获取信息的方式：是感官获取听到看到还是自己推理瞎想；模型解释：感官感觉针对第一种输入输出方式:即输入-&gt;处理-&gt;输出，而直觉：第二种：输出-&gt;输入-&gt;处理，而输入往往作为一种验证的方式；</p>
<p>思考情感：决策方式：对应于模型中的处理器中的意识层面中哪个占主导，是感受还是理性；而这其中其实还有道德在作用；</p>
<p>判断还是知觉：喜欢做计划还是灵活处理适应环境？做计划其实是由内而外，因为计划是偏向于自己做的，且更容易控制，而适应环境则是针对环境的输入，来做对应的输出，针对的是第一种输入输出方式，所以和内向外向有关；可能还涉及到安全感等；</p>
<p>2） 气质：其实是一个人的输出，表现，这个多是自我的主动输出，少部分是针对输入做的输出；气质，这个词太虚：</p>
<p>来看普世解释：气质是人的个性心理特征之一，它是指在人的认识、情感、言语、行动中，心理活动发生时力量的强弱、变化的快慢和均衡程度等稳定的动力特征。主要表现在情绪体验的快慢、强弱、表现的隐显以及动作的灵敏或迟钝方面，因而它为人的全部心理活动表现染上了一层浓厚的色彩。</p>
<p>可以理解为感受器，表现器的特质吧；</p>
<h3 id="六、马斯洛需求解释"><a href="#六、马斯洛需求解释" class="headerlink" title="六、马斯洛需求解释"></a>六、马斯洛需求解释</h3><p>最高层面的即价值，自我实现，创造等等，即对应了模型类别中的输出类模型，即模型本身偏向于输出源，能源源不断的给其他人(模型)提供输入，所以其他模型在感兴趣的情况下，被吸引，建立缔结，从而记得记住这个人；所以这个人的价值被体现出来；</p>
<p>尊重需要：更深层次的内在感受器，凌驾于开心等之上，表现为舒适，满足，安全，信心等等；</p>
<p>社会需要：亲情，爱情，友情：实际上是和某个输入源(包括方式1和2)，缔结了强烈的关系，这个源能提供源源不断的输入，好的或不好的，但是缔结的联系深深的印在脑子里了；所以一旦这个源不存在了，就体现为难受，其实这是一种上瘾；所以这种情况可以是建立一个相似的输入源不同的缔结；或者等自己适应了这种缔结的消失，而不再需要这种缔结；类似的还有和动物的情感，特殊物品的情感等等；</p>
<p>安全需要：安全感：财产人身等安全，工作等：这个是属于内在高级的感受器：但是它可能依赖的东西并不高级，因人而异，比如在一间新房子还是旧房子里；</p>
<p>生理需求：吃喝拉撒睡性穿住行；身体需求层面，本能，低级感受器；</p>
<p>没有了身体，就没有大脑，所以身体的感受是最强烈的但是短暂，而越靠近上层，感觉越不强烈但是可能长远；除非，和身体的感受形成了缔结；</p>
<p>预测行为；了解自己行动原因，深层原因，从而改变自己，完善自己，善待自己；</p>
<h3 id="七、模型和现代互联网AI"><a href="#七、模型和现代互联网AI" class="headerlink" title="七、模型和现代互联网AI"></a>七、模型和现代互联网AI</h3><p>模型编程和如何塑造一个你，TODO</p>
]]></content>
      <categories>
        <category>心理</category>
      </categories>
  </entry>
  <entry>
    <title>cpp_runtime_semantis</title>
    <url>/2018/07/29/cpp-runtime-semantis/</url>
    <content><![CDATA[<h3 id="c-执行期语意学"><a href="#c-执行期语意学" class="headerlink" title="c++ 执行期语意学"></a>c++ 执行期语意学</h3><h4 id="执行期和编译期的理解"><a href="#执行期和编译期的理解" class="headerlink" title="执行期和编译期的理解"></a>执行期和编译期的理解</h4><ul>
<li>执行期：此时是对已经编译等生成的可执行文件装载到内存并调用cpu将其作为一个进程执行的过程，对c.c++来说程序的入口为main,即第一条指令是执行main函数开始的，而c++可能会加入一些额外的代码，所以实际写的第一条语句和执行的第一条语句可能有偏差；　　　<a id="more"></a></li>
<li>在执行的过程，是程序代码运行的过程，可以想象为工厂开始生产，此时需要空间来运行，需要生产线，产品，工人，工人们走来走去搬运物品等；对程序的运行而言，此时主要的活动空间为栈和堆，即在栈和堆分配空间，而流程制式就是代码段，静态变量的数据区可以比喻为整个工厂共有的数据等；　这个过程中栈会被不断生成消失，堆也是，承载他们的是内存对应的区域；执行完后就从内存消失；</li>
<li>　编译期，就像生孩子之前的扫描，检查，看看语法对不对，添加额外的内容(c++).生成对应的汇编代码和二进制代码，而程序员需要尽力　编译出高效，整洁，可读等特性的代码，就像这个过程中通过调理，吃合适的东西等；尽可能避开一些坑和耗时的行为le.</li>
<li>　这部分的内容并不涉及太多执行期的，而更多的是编译器在编译代码时做了什么手脚<h4 id="c-中的运算符函数和运算符语法糖"><a href="#c-中的运算符函数和运算符语法糖" class="headerlink" title="c++中的运算符函数和运算符语法糖"></a>c++中的运算符函数和运算符语法糖</h4></li>
<li><p>运算符被编译器转换为运算符函数<br>操作符函数例子–&gt;到临时对象的产生和销毁带来的效率问题<br>–&gt;如何在程序中尽量避免产生临时变量和调用析构函数<br>例子：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X xx;</span><br><span class="line">Y yy;</span><br><span class="line"><span class="keyword">if</span>(yy==xx.getvalue()) ``` </span><br><span class="line">其中涉及到yy的==运算符函数和xx的getvalue函数，前者为：  </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Y&amp;) <span class="keyword">const</span>后者为X getvalue()  　　</span><br><span class="line">yy==xx.getvalue()被转换为yy.<span class="keyword">operator</span>==(xx.getvalue),显然类型不相符；  </span><br><span class="line">而此时若X有函数<span class="keyword">operator</span> Y()<span class="keyword">const</span>;<span class="comment">//conversion运算符，则进一步转换为：  </span></span><br><span class="line">     yy.<span class="keyword">operator</span>==(xx.getvalue.<span class="keyword">operator</span> Y())  </span><br><span class="line"> 这行代码看上去是这样简单，但是实际上需要产生中间变量，转为伪代码:  </span><br><span class="line">   X　tmp1=xx.getvalue;<span class="comment">//放返回值  </span></span><br><span class="line">   Y tmp2=tmp1.<span class="keyword">operator</span> Y()<span class="comment">//同上  </span></span><br><span class="line">   <span class="keyword">int</span> tmp3=yy.<span class="keyword">operator</span>==(tmp2);<span class="comment">//放置返回值  </span></span><br><span class="line">   总共产生三个临时变量，而且还得析构，麻烦效率低  </span><br><span class="line">   (注意，上述的为什么不能直接连锁调用?因为返回的是值而不是指针，思考<span class="keyword">this</span>指针的连锁操作，<span class="built_in">cout</span>的连锁操作，个人思考，应该是因为返回的是指针，上述返回的是值，所以无法用值调用下面的函数）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 对象的构造和解构</span><br><span class="line">+ 构造函数在哪里被安插:  </span><br><span class="line">构造函数在编译时，由编译器在合适的地方安插，一般情况下，正如我们想像的一样：在定义对象时会执行构造函数,解构在对象销毁时;</span><br><span class="line"><span class="comment">//c++伪代码  </span></span><br><span class="line">```cpp</span><br><span class="line">&#123;</span><br><span class="line">   Point point ;</span><br><span class="line">   <span class="comment">//point.Point::Point() 一般而言会被安插在这里</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//point.Point::~Point() 一般而言会被安插在这里</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解构函数在哪里被安插:<br>1、解构函数的安插需要考虑程序的退出时间（或者某个代码块的退出时间，在可能退出的地方都要加解构函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Point point;</span><br><span class="line">  <span class="comment">//constructor here</span></span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">int</span> (point.x()) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">    <span class="comment">//mumble;</span></span><br><span class="line">    <span class="comment">//destructor here</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="comment">//mumble;</span></span><br><span class="line">    <span class="comment">//destructor here</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">      <span class="comment">//mumble</span></span><br><span class="line">      <span class="comment">//destructor here</span></span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">    destructor here</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>解构代码应该在任何可能退出代码块的地方，return等，switch,if，goto等都会使加上解构函数的调用以避免出现退出但是还没有执行析构函数的尴尬；</li>
<li><p>而在如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(cache)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   Point xx;</span><br><span class="line">   <span class="keyword">if</span>(xx.get()==<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   和</span><br><span class="line">   &#123;</span><br><span class="line">     Point xx;</span><br><span class="line">     <span class="keyword">if</span>(cache）</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 前者不需要在if(cache）的return 前加解构和　构造函数，而后者需要，显然后者综合效率更差些；<br> 所以设计c++代码时候需要考虑，尽量在使用它的附近定义它</p>
</li>
<li><p>对特殊情况的考虑–全局对象的构造函数和解构函数的安插，有特殊的处理<br>“前面看到的是正常的局部情况，现在考虑的是全局对象，定义在main外面，它的构造函数被安插在哪里，什么时候执行?”<br>考虑以下例子：  </p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Matrix</span> identity;</span><br><span class="line"> main ()</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">//identity 必须在这里被初始化</span></span><br><span class="line">    <span class="keyword">Matrix</span> m1=identity;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 很明显，c++ 必须保证第一次用到identity把他构造出来而在main结束前销毁它；对全局对象而言，有构造函数和析构函数时，称为静态的初始化和内存释放操作；<br> 全局对象和全局变量一样被放在数据段(data segment),在c中，可以在编译期间给定全局变量常量值，而c++中的全局对象需要程序激活后才能执行构造函数给初值；相当于给全局对象做静态初始化；</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如,cfront在执行前，加入_main来初始化各种全局对象；</span></span><br><span class="line"><span class="comment">//sti_xxx---static initialization</span></span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="variable">_main</span>();---(<span class="variable">_sti_xxx</span>(); <span class="variable">_sti_xxx</span>();,,,)</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable">_exit</span>()---(<span class="variable">_std_xxx</span>()....)</span><br><span class="line">    <span class="comment">//而在结束时调用他们的析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    但是需要收集程序中各个对象文件的<span class="variable">_sti</span>函数和<span class="variable">_std</span>函数，此时可以用nm命令，即它会倾倒出符号表项目，nm会施加到.o文件上；搜寻<span class="variable">_sti</span> <span class="variable">_std</span>开头的函数；最后总结整理出来；</span><br></pre></td></tr></table></figure>
</li>
<li><p>对特殊情况的考虑–局部静态对象<br>考虑局部静态对象只会构造一次和销毁一次，却是可能调用多次包含定义局部静态对象的函数，如何保证只会构造一次和销毁一次呢?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> Matrix&amp;</span><br><span class="line"> identify() &#123;</span><br><span class="line">    <span class="keyword">static</span> Matrix mat_identify;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> mat_identify;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//1\首先要保证在调用该函数才初始化局部静态变量，</span></span><br><span class="line"><span class="comment">//2、其次，保证多次调用该函数不会重复初始化对象；</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>简单的说，解决方案就是用一个标志变量，当已经初始化一次局部静态变量就置为真；</p>
<ul>
<li>对象数组什么时候构造和解构?<br>考虑一下定义了一个对象数组，之后未做任何改动，要取其中的值，会在定义数组的时候也初始化数组中每一个对象（即调用构造函数)吗？<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">int</span> a;</span><br><span class="line">      Point ()&#123;a=<span class="number">3</span>;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">Point knot[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;knot[<span class="number">3</span>].a;<span class="comment">//会打印3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当这种对象数组没有默认构造函数和析构函数，则定义时和内置类型相同，只需配置足够的内存保存即可；<br>而当对象有构造函数和析构函数时，编译器提供了vec_new() vec_delete()之类的函数来统一做构造和析构</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *vec_new(<span class="keyword">void</span> *<span class="keyword">array</span>,<span class="comment">//数组起始地址</span></span><br><span class="line">      size_t elem_size,<span class="keyword">int</span> elem_count,<span class="comment">//对象大小和数组对象个数</span></span><br><span class="line">      <span class="keyword">void</span> (*constructor)(*<span class="keyword">void</span>)</span><br><span class="line">      <span class="keyword">void</span>(*destructor)(*<span class="keyword">void</span>)</span><br><span class="line">      而实际上调用时：</span><br><span class="line">      Point knots[<span class="number">10</span>]</span><br><span class="line">      <span class="comment">//可能是这样调用，delete类似</span></span><br><span class="line">      vec_new(&amp;knnots,<span class="keyword">sizeof</span>(Point),<span class="number">10</span>,&amp;Point::Point,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>而如果程序员额外调用了其中一些元素的构造函数，则：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>]=&#123;Point(),Point(<span class="number">1.8</span>,<span class="number">2.1</span>,<span class="number">0.2</span>),<span class="number">-1.9</span>&#125;;</span><br><span class="line">类似这样，则可能会明确的初始化前三个元素，后面的其他则用vec_new</span><br></pre></td></tr></table></figure></p>
<ul>
<li>默认构造函数和数组</li>
</ul>
<h4 id="new和delete运算符"><a href="#new和delete运算符" class="headerlink" title="new和delete运算符"></a>new和delete运算符</h4><p>上述是针对对象的，new和delete是针对指针的；</p>
<ul>
<li>本质上调用malloc函数和free函数,编译器解析new，delete会安插构造函数和解构函数<br>new 的实际过程：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">对内建类型</span><br><span class="line"><span class="keyword">int</span> *pi=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//1 调用函数库的new:_new </span></span><br><span class="line"><span class="comment">//int *pi=_new(sizeof(int));</span></span><br><span class="line"><span class="comment">//2 设置初值：*pi=5;</span></span><br><span class="line"><span class="comment">//或加条件：</span></span><br><span class="line">(<span class="keyword">int</span>  *pi ; <span class="keyword">if</span>(pi=_new(...))*pi=<span class="number">5</span>)</span><br><span class="line"><span class="comment">//delete类似；</span></span><br><span class="line">对对象：</span><br><span class="line">Point3d *origin =<span class="keyword">new</span> Point3d;</span><br><span class="line">转换为：</span><br><span class="line">Point3d *origin;</span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">if</span>(origin =_new(<span class="keyword">sizeof</span>(Point3d))</span><br><span class="line">origin=Pointed::Point3d(origin)<span class="comment">//注意这里会调用构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> origin;</span><br><span class="line">转换为：</span><br><span class="line"><span class="keyword">if</span> (!origin !=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">Point3d::~Point3d(origin);</span><br><span class="line">_delete(origin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">而<span class="keyword">new</span> 一般由<span class="built_in">malloc</span>实现，<span class="keyword">delete</span>由<span class="built_in">free</span>实现；</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">size_t</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (size =<span class="number">0</span>)</span><br><span class="line">    size=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">void</span> *last_alloc</span><br><span class="line">  <span class="keyword">while</span>(!(last_alloc=<span class="built_in">malloc</span>(size)))</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(_new_handle)</span><br><span class="line">   (*_new_handle)();</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="keyword">return</span> last_alloc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>针对数组的new和delete<br>实际上的new数组，若不存在构造函数，则只会做new的运算符函数：int <em>parray=(</em>int)_new(5*sizeof(int));<br>待续，略复杂。。。</li>
<li>placement operator new的语意-——new的重载；</li>
</ul>
<h4 id="影响c-效率因素之一—临时性对象"><a href="#影响c-效率因素之一—临时性对象" class="headerlink" title="影响c++效率因素之一—临时性对象"></a>影响c++效率因素之一—临时性对象</h4><ul>
<li><p>为什么需要临时性对象<br>临时性对象是影响程序效率和引入bug的来源之一；</p>
<ul>
<li><p>隐式的类型转换需要临时性对象：<br>当用内建类型写下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">....</span><br><span class="line">a=b+c;<span class="comment">//内建类型将算出的值赋给a</span></span><br><span class="line"><span class="comment">//想象一下如果此时a,b,c都是对象，b+c返回一个对象呢？</span></span><br><span class="line">在c++中操作符运算本质上也是函数，则这里单纯靠b+c返回</span><br><span class="line">一个对象的值赋值给a已经不现实了，对象是一个结构性的</span><br><span class="line">变量；所以在这种情况下就需要构建一个临时性对象，并将</span><br><span class="line">此临时性对象（函数的结果）利用赋值函数拷贝给a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单纯传入对象作为函数参数时，即使不返回对象，也会产生临时性对象，为什么? 随意写了个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">     <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="number">2</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="number">3</span>         <span class="keyword">public</span>:</span><br><span class="line">    <span class="number">4</span>                 <span class="keyword">int</span> a;</span><br><span class="line">    <span class="number">5</span>                 Point()&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"constructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; a=<span class="number">4</span>;&#125;</span><br><span class="line">    <span class="number">6</span>                 <span class="function"><span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="number">32</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="number">7</span>                 ~Point()&#123;</span><br><span class="line">    <span class="number">8</span>                         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"~destrucot"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">&gt;&gt;  <span class="number">9</span>                Point(<span class="keyword">const</span> Point&amp; p)</span><br><span class="line">   <span class="number">10</span>                &#123;</span><br><span class="line">   <span class="number">11</span>                                 <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy Constructor"</span> &lt;&lt; <span class="built_in">std</span>::en      dl;</span><br><span class="line">   <span class="number">12</span>                &#125;</span><br><span class="line">   <span class="number">13</span> </span><br><span class="line">&gt;&gt; <span class="number">14</span>               Point&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp; p)</span><br><span class="line">   <span class="number">15</span>               &#123;</span><br><span class="line">   <span class="number">16</span>                  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Assign"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="number">17</span>                  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   <span class="number">18</span>               &#125;</span><br><span class="line">   <span class="number">19</span> </span><br><span class="line">   <span class="number">20</span> &#125;;</span><br><span class="line">   <span class="number">21</span> <span class="function"><span class="keyword">void</span> <span class="title">getv</span><span class="params">(<span class="keyword">const</span> Point pp)</span></span></span><br><span class="line"><span class="function">   22 </span>&#123;</span><br><span class="line">   <span class="number">23</span>     <span class="comment">//= pp.a=6;</span></span><br><span class="line">   <span class="number">24</span>         pp.printa();</span><br><span class="line">   <span class="number">25</span>         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;pp.a&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="number">26</span> &#125;</span><br><span class="line">   <span class="number">27</span> </span><br><span class="line">   <span class="number">28</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   29 </span>&#123;</span><br><span class="line">   <span class="number">30</span>         Point pplist;</span><br><span class="line">   <span class="number">31</span>         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;pplist.a&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="number">32</span>         getv(pplist);<span class="comment">//这里产生临时对象是调用拷贝构造函数</span></span><br><span class="line">   <span class="number">33</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">34</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>按照内建类型来看，传入函数参数，其实传入的是值，<br>而对于对象来说，若传入的是引用或指针则不需要产生临时性对象，但是传入的若是值，则c++编译器需要产生一个临时性对象，在函数的栈中，供函数中对该对象调用函数和值等操作；</p>
<ul>
<li><p>函数返回对象；</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">另一个例子：</span><br><span class="line">   如何做X xxx=bar();如何拷贝的？双阶段初始化：</span><br><span class="line"> a 增加一个额外的引用参数给函数，如void bar(X＆　_result)</span><br><span class="line"> b 在return 前插入一个<span class="keyword">copy</span> <span class="function"><span class="keyword">constructor</span> </span></span><br><span class="line"><span class="function">     <span class="title">void</span> <span class="title">bar</span><span class="params">(X &amp;__result)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">               X xx;</span></span></span><br><span class="line"><span class="function"><span class="comment">               xx.X::X();</span></span></span><br><span class="line"><span class="function"><span class="comment">               __result.X::XX(xx);</span></span></span><br><span class="line"><span class="function"><span class="comment">               return ;</span></span></span><br><span class="line"><span class="function"><span class="comment">       &#125;</span></span></span><br><span class="line"><span class="function">   <span class="title">X</span> <span class="title">xxx</span>=<span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   //-&gt;<span class="title">bar</span><span class="params">(X &amp;__result)</span>;</span></span><br><span class="line">       xxx=_result;</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动调用构造函数：此时也会生成临时性对象；</p>
</li>
<li>其他如通过构造函数调用成员函数的：单纯一个表达式 a+b这种的</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tmpclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    tmpclass(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmpclass()</span><br><span class="line">    &#123;</span><br><span class="line">        tmpclass(<span class="number">0</span>);<span class="comment">//手动调用构造函数会产生临时对象，临时对象的a=0,故最后结果show还是无初值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tmpclass c;</span><br><span class="line">    c.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">其他：</span><br><span class="line"> tmpclass c1 = tmpclass(<span class="number">6</span>);<span class="comment">//赋值构造+构造函数</span></span><br><span class="line"> tmpclass(<span class="number">6</span>).show()<span class="comment">//产生临时性对象；</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如何避免产生临时性对象<br>尽量不用上述的手法编程</li>
<li>临时性对象的效率（迷思，测试)<br>临时性对象会造成效率低下，在不当的代码下容易产生很多临时性对象；不当的使用也会造成非预期的结果；</li>
<li>临时性对象的生命周期：<br>可能是这个表达式的生命周期，具体可以通过构造类函数和析构函数调试；</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_pingtraceroute</title>
    <url>/2018/06/24/tcpip-pingtraceroute/</url>
    <content><![CDATA[<h3 id="ping-and-traceroute"><a href="#ping-and-traceroute" class="headerlink" title="ping and traceroute"></a>ping and traceroute</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>ping是ICMP中的回显报文类型：</p>
<ul>
<li>ping 对应的icmp，type字段为0/8,code字段为0</li>
<li>ICMP回显请求和应答报文格式：<a id="more"></a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类型(<span class="number">0</span>/<span class="number">8</span>）       code(<span class="number">0</span>)       检验和 -<span class="number">-4B</span></span><br><span class="line">标示符（unix系统中为进程pid)   序号   -<span class="number">-4B</span></span><br><span class="line">           选项数据</span><br></pre></td></tr></table></figure>
<ul>
<li>最常见，回显时间，得到往返时间：<br>通过在icmp数据报文中存放发送请求的时间值来计算往返时间，当应答返回时，用当前时间减去存放在ICMP报文中的时间值，即是往返时间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类型(<span class="number">0</span>/<span class="number">8</span>）       code(<span class="number">0</span>)       检验和 -<span class="number">-4B</span></span><br><span class="line">标示符（unix系统中为进程pid)   序号   -<span class="number">-4B</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span>         -<span class="number">-8B</span></span><br></pre></td></tr></table></figure>
<p>共16Byte,除开ip头</p>
<ul>
<li>放抓包的图片，ping回显示时间</li>
<li>ping程序代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addr_conv</span><span class="params">(<span class="keyword">char</span> *address,struct in_addr *inaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">he</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(inet_aton(address,inaddr)==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">	he=gethostbyname(address);</span><br><span class="line">	<span class="keyword">if</span>(he!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*inaddr=*((struct in_addr *)he-&gt;h_addr_list[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_icmp</span><span class="params">(<span class="keyword">int</span> sockfd,sockaddr_in send_addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recv_icmp</span><span class="params">(<span class="keyword">int</span> sockfd,sockaddr_in send_addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">	sockfd=socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);</span><br><span class="line">    <span class="keyword">if</span>(sockfd&lt;<span class="number">0</span>)</span><br><span class="line"> 	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"creat socket error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sockaddr_in send_addr;</span><br><span class="line">	bzero(&amp;send_addr,<span class="keyword">sizeof</span>(send_addr));</span><br><span class="line">	send_addr.sin_family=AF_INET;</span><br><span class="line">	addr_conv(argv[<span class="number">1</span>],&amp;send_addr.sin_addr);</span><br><span class="line"><span class="comment">//send_addr.sin_addr.s_addr=inet_addr("192.168.0.110");</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line"> 	&#123;</span><br><span class="line">		send_icmp(sockfd,send_addr);</span><br><span class="line">		recv_icmp(sockfd,send_addr);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">checksum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> *addr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nleft=len;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> *w=addr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> answer=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(nleft&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=*w++;</span><br><span class="line">		nleft-=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(nleft==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)(&amp;answer)=*(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)w;</span><br><span class="line">		sum+=answer;</span><br><span class="line">	&#125;</span><br><span class="line">	sum=(sum&gt;&gt;<span class="number">16</span>)+(sum&amp;<span class="number">0xffff</span>);</span><br><span class="line">	sum+=(sum&gt;&gt;<span class="number">16</span>);</span><br><span class="line">	answer=~sum;</span><br><span class="line">	<span class="comment">//answer=(unsigned short)sum&amp;0xffff;</span></span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_icmp</span><span class="params">(<span class="keyword">int</span> sockfd,sockaddr_in send_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">short</span> <span class="keyword">int</span> seq=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">char</span>  buf[<span class="number">8</span>+<span class="number">8</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icmphdr</span> *<span class="title">icmp</span>=(<span class="title">struct</span> <span class="title">icmphdr</span> *)<span class="title">buf</span>;</span></span><br><span class="line">	<span class="comment">//填充icmp首部</span></span><br><span class="line">	icmp-&gt;type=ICMP_ECHO;<span class="comment">//类型</span></span><br><span class="line">	icmp-&gt;code=<span class="number">0</span>;<span class="comment">//和编码共同决定是回显报文</span></span><br><span class="line">	icmp-&gt;checksum=<span class="number">0</span>;<span class="comment">//头部包含校验和</span></span><br><span class="line">	icmp-&gt;un.echo.id=getpid();<span class="comment">//标识符，唯一性，一般填充pid，这样即使几个程序发送ping也能识别，写成其他时接收失败</span></span><br><span class="line">	icmp-&gt;un.echo.sequence=seq++;<span class="comment">//顺序号，回显时，显示，一般无规定，但是会在此基础上加１，接着加１，，</span></span><br><span class="line">	<span class="comment">//填充icmp数据(时间)//这里报文数据只有时间戳</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	<span class="comment">//tv=(struct timeval*)icmp-&gt;icmp_data;</span></span><br><span class="line">	gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(buf+<span class="number">8</span>,&amp;tv,<span class="keyword">sizeof</span>(tv));</span><br><span class="line">	<span class="keyword">int</span> buflen=<span class="keyword">sizeof</span>(struct icmphdr)+<span class="keyword">sizeof</span>(struct timeval);</span><br><span class="line">	<span class="comment">//计算校验和</span></span><br><span class="line">	icmp-&gt;checksum=checksum((<span class="keyword">unsigned</span> <span class="keyword">short</span> *)buf,buflen);</span><br><span class="line">	<span class="comment">//发送icmp数据包</span></span><br><span class="line">	<span class="keyword">int</span> len=sendto(sockfd,buf,buflen,<span class="number">0</span>,(struct sockaddr *)&amp;send_addr,<span class="keyword">sizeof</span>(send_addr));</span><br><span class="line">	<span class="keyword">if</span>(len&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"send icmp error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"senmd ok"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recv_icmp</span><span class="params">(<span class="keyword">int</span> sockfd,sockaddr_in send_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icmphdr</span> *<span class="title">icmp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">ip</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ipheadlen;</span><br><span class="line">	<span class="keyword">int</span> icmplen;</span><br><span class="line">	<span class="comment">//接收icmp响应</span></span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n=recvfrom(sockfd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"recv error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ip=(struct ip *)buf;	</span><br><span class="line">		ipheadlen=ip-&gt;ip_hl&lt;&lt;<span class="number">2</span>;</span><br><span class="line">		icmplen=n-ipheadlen;</span><br><span class="line">		<span class="keyword">if</span>(icmplen&lt;<span class="number">16</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		icmp=(struct icmphdr *)(buf+ipheadlen);</span><br><span class="line">		<span class="keyword">if</span>(icmp-&gt;type==ICMP_ECHOREPLY&amp;&amp;icmp-&gt;un.echo.id==getpid())</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算时间差</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">recv_tv</span>;</span></span><br><span class="line">	gettimeofday(&amp;recv_tv,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">send_tv</span>;</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;send_tv,icmp+<span class="number">1</span>,<span class="keyword">sizeof</span>(send_tv));</span><br><span class="line">	recv_tv.tv_sec-=send_tv.tv_sec;</span><br><span class="line">	recv_tv.tv_usec+=recv_tv.tv_sec*<span class="number">1000000L</span>;</span><br><span class="line">	<span class="keyword">long</span> interval=recv_tv.tv_usec-send_tv.tv_usec;</span><br><span class="line">	<span class="comment">//输出信息</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;icmplen&lt;&lt; <span class="string">" bytes fromfdfd "</span>&lt;&lt;inet_ntoa(send_addr.sin_addr);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">" icmp_seq="</span>&lt;&lt;icmp-&gt;un.echo.sequence&lt;&lt;<span class="string">" bytes="</span>&lt;&lt;icmplen&lt;&lt;<span class="string">" ttl="</span>&lt;&lt;(<span class="keyword">int</span>)ip-&gt;ip_ttl;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">" time="</span>&lt;&lt;(<span class="keyword">float</span>)interval/<span class="number">1000.0</span>&lt;&lt;<span class="string">"ms"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ip 记录路由选项：<br>利用ip头，ip头长度字段为4bit,最长的ip首部为15x32bit=60字节，所以除去头20字节，选项字段最大40字节，除去3字节的code,len.ptr三个字节，剩下37个字节，可以容纳9个ip地址<br>windows下可以通过ping -r ip来尝试</li>
<li>ip时间戳选项</li>
</ul>
<h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><h5 id="traceroute主要两点"><a href="#traceroute主要两点" class="headerlink" title="traceroute主要两点"></a>traceroute主要两点</h5><ul>
<li>利用ttl,ttl是一个有限值，每经过一个路由器减1，这样放置循环发包。</li>
<li>利用icmp报文，当路由器接收到ttl为0或1时，不转发，而是丢弃，并给信源回复一个icmp超时信息，且包含该路由器的ip</li>
<li>具体流程：<br>traceroute发送一份ttl字段为1的ip数据报给目的主机，处理这个数据报的第一个路由器将ttl值减去1，丢弃该数据报，并发送一份超时icmp报文，这样就得到了该路径的第一个路由器的地址；<br>以此类推，发送ttl为2的数据报，则得到第二个路由器的地址；直到到达目的地址；<br>怎么知道到达了目的地?<br>traceroute发送了一份udp数据包给目的主机，但它选择了一个不可能的值作为udp端口号（大于30000)，使目的主机的任何一个应用程序都不可能使用该端口号，则当包到达目的主机时，目的主机的udp模块会产生一个端口不可达的错误icmp报文。traceroute要做的是区分icmp是超时还是端口不可达，以判断什么时候结束</li>
</ul>
<h5 id="traceroute命令"><a href="#traceroute命令" class="headerlink" title="traceroute命令"></a>traceroute命令</h5><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">traceroute www.baidu.com</span><br><span class="line">traceroute to www.baidu.com (<span class="number">119.75</span><span class="number">.216</span><span class="number">.20</span>), <span class="number">30</span> hops max, <span class="number">60</span> byte packets<span class="comment">//ttl字段为30跳，每个数据包为60字节（20ip头等）</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> (<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>)  <span class="number">2.762</span> ms  <span class="number">3.485</span> ms  <span class="number">3.477</span> ms/发到网关<span class="number">1</span>,针对每个ttl值发送三份包，分别在<span class="number">2.762</span>,<span class="number">3.485</span>,<span class="number">3.477</span>收到</span><br><span class="line"> <span class="number">2</span>  <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> (<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>)  <span class="number">3.466</span> ms  <span class="number">3.453</span> ms  <span class="number">3.443</span> ms</span><br><span class="line"> <span class="number">3</span>  <span class="number">101.232</span><span class="number">.192</span><span class="number">.1</span> (<span class="number">101.232</span><span class="number">.192</span><span class="number">.1</span>)  <span class="number">6.807</span> ms  <span class="number">6.813</span> ms  <span class="number">7.412</span> ms</span><br><span class="line"> <span class="number">4</span>  <span class="number">10.144</span><span class="number">.11</span><span class="number">.37</span> (<span class="number">10.144</span><span class="number">.11</span><span class="number">.37</span>)  <span class="number">7.405</span> ms  <span class="number">7.393</span> ms  <span class="number">7.381</span> ms</span><br><span class="line"> <span class="number">5</span>  <span class="number">10.144</span><span class="number">.14</span><span class="number">.138</span> (<span class="number">10.144</span><span class="number">.14</span><span class="number">.138</span>)  <span class="number">7.369</span> ms  <span class="number">7.362</span> ms  <span class="number">7.340</span> ms</span><br><span class="line"> <span class="number">6</span>  * * <span class="number">14.197</span><span class="number">.242</span><span class="number">.145</span> (<span class="number">14.197</span><span class="number">.242</span><span class="number">.145</span>)  <span class="number">10.329</span> ms</span><br><span class="line"> <span class="number">7</span>  <span class="number">14.197</span><span class="number">.218</span><span class="number">.173</span> (<span class="number">14.197</span><span class="number">.218</span><span class="number">.173</span>)  <span class="number">7.240</span> ms <span class="number">14.197</span><span class="number">.248</span><span class="number">.253</span> (<span class="number">14.197</span><span class="number">.248</span><span class="number">.253</span>)  <span class="number">6.855</span> ms  <span class="number">7.212</span> ms</span><br><span class="line"> <span class="number">8</span>  <span class="number">14.197</span><span class="number">.240</span><span class="number">.249</span> (<span class="number">14.197</span><span class="number">.240</span><span class="number">.249</span>)  <span class="number">44.799</span> ms <span class="number">14.197</span><span class="number">.252</span><span class="number">.189</span> (<span class="number">14.197</span><span class="number">.252</span><span class="number">.189</span>)  <span class="number">42.107</span> ms <span class="number">14.197</span><span class="number">.253</span><span class="number">.145</span> (<span class="number">14.197</span><span class="number">.253</span><span class="number">.145</span>)  <span class="number">50.051</span> ms</span><br><span class="line"> <span class="number">9</span>  <span class="number">14.197</span><span class="number">.252</span><span class="number">.54</span> (<span class="number">14.197</span><span class="number">.252</span><span class="number">.54</span>)  <span class="number">49.394</span> ms  <span class="number">49.414</span> ms <span class="number">14.197</span><span class="number">.248</span><span class="number">.94</span> (<span class="number">14.197</span><span class="number">.248</span><span class="number">.94</span>)  <span class="number">49.406</span> ms</span><br><span class="line"><span class="number">10</span>  <span class="number">14.197</span><span class="number">.149</span><span class="number">.178</span> (<span class="number">14.197</span><span class="number">.149</span><span class="number">.178</span>)  <span class="number">49.406</span> ms  <span class="number">49.383</span> ms <span class="number">14.197</span><span class="number">.178</span><span class="number">.102</span> (<span class="number">14.197</span><span class="number">.178</span><span class="number">.102</span>)  <span class="number">49.382</span> ms</span><br><span class="line"><span class="number">11</span>  <span class="number">182.61</span><span class="number">.253</span><span class="number">.119</span> (<span class="number">182.61</span><span class="number">.253</span><span class="number">.119</span>)  <span class="number">49.912</span> ms <span class="number">182.61</span><span class="number">.253</span><span class="number">.117</span> (<span class="number">182.61</span><span class="number">.253</span><span class="number">.117</span>)  <span class="number">50.916</span> ms <span class="number">182.61</span><span class="number">.253</span><span class="number">.119</span> (<span class="number">182.61</span><span class="number">.253</span><span class="number">.119</span>)  <span class="number">50.554</span> ms</span><br><span class="line"><span class="number">12</span>  <span class="number">182.61</span><span class="number">.253</span><span class="number">.126</span> (<span class="number">182.61</span><span class="number">.253</span><span class="number">.126</span>)  <span class="number">47.975</span> ms *  <span class="number">50.625</span> ms<span class="comment">//5s未收到时打印一个*号并发送下一份数据包</span></span><br><span class="line"><span class="number">13</span>  * * *</span><br><span class="line"><span class="number">14</span>  * * *</span><br><span class="line"><span class="number">15</span>  * * *</span><br><span class="line"><span class="number">16</span>  * * *</span><br><span class="line"><span class="number">17</span>  * * *</span><br><span class="line"><span class="number">18</span>  * * *</span><br><span class="line"><span class="number">19</span>  * * *</span><br><span class="line"><span class="number">20</span>  * * *</span><br><span class="line"><span class="number">21</span>  * * *</span><br><span class="line"><span class="number">22</span>  * * *</span><br><span class="line"><span class="number">23</span>  * * *</span><br><span class="line"><span class="number">24</span>  * * *</span><br><span class="line"><span class="number">25</span>  * * *</span><br><span class="line"><span class="number">26</span>  * * *</span><br><span class="line"><span class="number">27</span>  * * *</span><br><span class="line"><span class="number">28</span>  * * *</span><br><span class="line"><span class="number">29</span>  * * *</span><br><span class="line"><span class="number">30</span>  * * *</span><br></pre></td></tr></table></figure>
<p>tcpdump输出：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">traceroute www.baidu.com(<span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span>)</span><br><span class="line"><span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.39650</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33434</span>: [udp sum ok] UDP, length <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009075</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">1</span>, id <span class="number">5354</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)//ttl=<span class="number">1</span></span><br><span class="line"><span class="number">192.168</span><span class="meta">.0</span><span class="meta">.1</span> &gt; <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span>: ICMP time exceeded <span class="keyword">in</span>-transit, length <span class="number">68</span>//网关回复icmp超时</span><br><span class="line">	<span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">1</span>, id <span class="number">941</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.48912</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33435</span>: [udp sum ok] UDP, length <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009114</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">1</span>, id <span class="number">5355</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.43061</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33436</span>: [udp sum ok] UDP, length <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009148</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">2</span>, id <span class="number">5356</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)//ttl=<span class="number">2</span></span><br><span class="line"> <span class="number">192.168</span><span class="meta">.1</span><span class="meta">.1</span> &gt; <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span>: ICMP time exceeded <span class="keyword">in</span>-transit, length <span class="number">68</span></span><br><span class="line">	<span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">1</span>, id <span class="number">942</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)</span><br><span class="line">//第<span class="number">2</span>个路由器回复超时</span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.52554</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33437</span>: [udp sum ok] UDP, length <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009189</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">2</span>, id <span class="number">5357</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.51967</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33438</span>: [udp sum ok] UDP, length <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009243</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">2</span>, id <span class="number">5358</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.45922</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33439</span>: [udp sum ok] UDP, length <span class="number">32</span></span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">58.009281</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">3</span>, id <span class="number">5359</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)//ttl==<span class="number">3</span></span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.34392</span> &gt; <span class="number">119.75</span><span class="meta">.213</span><span class="meta">.61</span><span class="meta">.33440</span>: [udp sum ok] UDP, length <span class="number">32</span>  </span><br><span class="line">    <span class="number">101.232</span><span class="meta">.192</span><span class="meta">.1</span> &gt; <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span>: ICMP time exceeded <span class="keyword">in</span>-transit, length <span class="number">60</span></span><br><span class="line">	<span class="built_in">IP</span> (tos <span class="number">0x0</span>, id <span class="number">945</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">60</span>)</span><br><span class="line">    <span class="number">192.168</span><span class="meta">.0</span><span class="meta">.110</span><span class="meta">.57724</span> &gt; <span class="number">119.75</span><span class="meta">.216</span><span class="meta">.20</span><span class="meta">.33440</span>: UDP, length <span class="number">32</span></span><br><span class="line">//第三个路由器回复icmpc超时</span><br><span class="line"><span class="number">20</span>:<span class="number">21</span>:<span class="number">59.304604</span> <span class="built_in">IP</span> (tos <span class="number">0x0</span>, ttl <span class="number">59</span>, id <span class="number">0</span>, offset <span class="number">0</span>, flags [DF], proto UDP (<span class="number">17</span>), length <span class="number">161</span>)</span><br></pre></td></tr></table></figure>
<p>从上面包的情况可以看到:</p>
<ul>
<li>设备首先发送ucp包。若用更详细的打印看到端口号为源55050 目的端口:33443别的设备可能不同，但是都很大，这样到达时会发出端口不可达；ttl字段从1递增，源地址目的地址不变</li>
<li>路由器根据ttl的值，回复icmp超时包，回复给设备，从源地址可以看到，经过的路由器；</li>
<li>该icmp的包格式：<br>类型11  code 0/1  校验和<br>ip首部（包括选项)+原始ip数据报中数据的前8个字节</li>
<li>注意：每一次的路由都可能不一样</li>
</ul>
<h5 id="关于ip源站选路选项"><a href="#关于ip源站选路选项" class="headerlink" title="关于ip源站选路选项"></a>关于ip源站选路选项</h5><ul>
<li>ip通常都是动态的，即每个路由都要判断数据报下面该转发到哪个路由器，一般不对此进行控制；这里提供的思想是：</li>
<li>由源站发送者指定路由，即经过哪些ip</li>
<li>分为严格的源路由选择和宽松的源站选路</li>
<li>前者必须采用确切的路由，若发现失败则路由器返回源站选路失败的icmp报文；</li>
<li>后者致命一个数据包经过的ip清单，但是数据包在清单上指明的任意两个地址之间可以通过其他路由器；</li>
<li>ip源站路由选项的格式：<br>包含在ip头部的选项中，因长度有限只能包含9个ip:<br>code(1) len(1) ptr(1) ip1(4) ip2(4)….</li>
<li>eg: traceroute -g 192.168.23.1 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></li>
</ul>
<h5 id="traceroute实现"><a href="#traceroute实现" class="headerlink" title="traceroute实现"></a>traceroute实现</h5><ul>
<li>参考linux traceroute源码实现；</li>
<li>主要就是发送一多个dp包设置ttl递增，并将接收到的icmp报文打印出来；直到收到端口不可达报文时退出；</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_string</title>
    <url>/2018/06/24/leetcode-string/</url>
    <content><![CDATA[<h3 id="leetcode-string"><a href="#leetcode-string" class="headerlink" title="leetcode_string"></a>leetcode_string</h3><h4 id="传统字符串匹配："><a href="#传统字符串匹配：" class="headerlink" title="传统字符串匹配："></a>传统字符串匹配：</h4><ul>
<li>简单写写,变量命名等就先不纠结了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">char</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'\0'</span>||p[<span class="number">0</span>]==<span class="string">'\0'</span>)</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"p or s is null"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> k=<span class="number">0</span>,j=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;s[i]!=<span class="string">'\0'</span>&amp;&amp;s[k]!=<span class="string">'\0'</span>;)</span><br><span class="line">		&#123;</span><br><span class="line">		     <span class="keyword">if</span>(p[j]==<span class="string">'\0'</span>)</span><br><span class="line">				   <span class="keyword">break</span>;	 </span><br><span class="line">			 <span class="keyword">if</span>(s[k]==p[j])</span><br><span class="line">			 &#123;</span><br><span class="line">					 k++;</span><br><span class="line">					 j++;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">else</span> <span class="comment">//不匹配时重新来过</span></span><br><span class="line">			 &#123;</span><br><span class="line">					 i++;</span><br><span class="line">					 k=i;</span><br><span class="line">					 j=<span class="number">0</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span>(p[j]==<span class="string">'\0'</span>)</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kmp匹配算法"><a href="#kmp匹配算法" class="headerlink" title="kmp匹配算法"></a>kmp匹配算法</h4><p>kmp算法：基本过程见另一篇文章数据结构之字符串<a id="more"></a>，这里贴写代码(未经大数据检验，谨慎观看)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextfunc</span><span class="params">(<span class="keyword">char</span> p[],<span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">   next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(p[j]!=<span class="string">'\0'</span>)</span><br><span class="line">   &#123;</span><br><span class="line">		   <span class="keyword">if</span>(k==<span class="number">0</span>||p[j]==p[k])</span><br><span class="line">		   &#123;</span><br><span class="line">				   ++j;</span><br><span class="line">				   ++k;</span><br><span class="line">				   next[j]=k;</span><br><span class="line">		   &#125;</span><br><span class="line">		   <span class="keyword">else</span></span><br><span class="line">				   k=next[k];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">char</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> next[<span class="number">100</span>];</span><br><span class="line">   nextfunc(p,next);</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>;s[i]!=<span class="string">'\0'</span>&amp;&amp;p[j]!=<span class="string">'\0'</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">		   <span class="comment">//if(j==-1)j=0;</span></span><br><span class="line">		   <span class="keyword">if</span>(s[i]==p[j])</span><br><span class="line">		   &#123;</span><br><span class="line">		     j++;</span><br><span class="line">			 <span class="keyword">continue</span>;</span><br><span class="line">		   &#125;</span><br><span class="line">		   <span class="keyword">while</span>(s[i]!=p[j]&amp;&amp;j&gt;=<span class="number">0</span>)j=next[j];</span><br><span class="line">		   j++;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">if</span>(p[j]==<span class="string">'\0'</span>)</span><br><span class="line">		 <span class="keyword">return</span> i-j;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">		 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单测试<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">char</span> a[<span class="number">19</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'s'</span>,<span class="string">'s'</span>,<span class="string">'f'</span>,<span class="string">'r'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>&#125;;</span><br><span class="line">		<span class="keyword">char</span> b[<span class="number">10</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'s'</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> pos=strStr(a,b);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;pos&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> pos2=kmp(a,b);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;pos2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="其他字符串算法题目："><a href="#其他字符串算法题目：" class="headerlink" title="其他字符串算法题目："></a>其他字符串算法题目：</h4><h5 id="判读字符串是否为回文串"><a href="#判读字符串是否为回文串" class="headerlink" title="判读字符串是否为回文串"></a>判读字符串是否为回文串</h5><ul>
<li>所谓回文串即正者读反着读都一样：</li>
<li>解决方案：<ul>
<li>1.设置两个索引，一个从字符串开始位置往后走，一个从字符串最后的位置往前走，比较这两个索引指向的字符是否相等，直到遍历完整个字符串；注意这里其实并不需要遍历整个字符串，一个索引只需要走一半就可以，回文串两边对称的。</li>
<li>2.利用栈，思路类似</li>
</ul>
</li>
</ul>
<h5 id="字符串转整数-atoi"><a href="#字符串转整数-atoi" class="headerlink" title="字符串转整数(atoi)"></a>字符串转整数(atoi)</h5><ul>
<li>分析：这个题目需要注意的是各种不规则的输入和其他边缘条件如int整数的范围等</li>
<li>解决方案:<ul>
<li>若是严格的检查，则判断字符ASCII码是否在0-9之间，注意整数的首位不能为0）；整数的正负；数据是否溢出；是否数据的表现形式如33x8fe；等等。</li>
<li>非严格的检查，如遇到非法的字符跳过即可；首位为0时跳过或者当成八进制等等</li>
</ul>
</li>
</ul>
<h5 id="对两个二进制字符串求和"><a href="#对两个二进制字符串求和" class="headerlink" title="对两个二进制字符串求和"></a>对两个二进制字符串求和</h5><ul>
<li>如”111”+”101”=”1100”</li>
<li>解决方案：<ul>
<li><ol>
<li>像十进制那样直接求和，进位，从最右边的字符开始，若相加大于1则进位，注意两个字符串可能一个很长一个很短，而进位可能一直需要延续</li>
</ol>
</li>
<li>2.将两个字符串分别转换为十进制再做运算，结果再转为二进制</li>
</ul>
</li>
</ul>
<h5 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h5><ul>
<li>暴力方法：将所有子串列出来先判断哪些是回文串，再取长度最长的；<h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5></li>
<li>我对正则表达式的处理方案一直很倾向于用状态机，这种方法可以用图表示出来，方案的完备性好判断，别人也好理解；</li>
<li>递归方案<h5 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h5></li>
<li>找出字符串数组中的最长公共前缀：给定一个字符串数组，找出他们的最长公共前缀</li>
<li>分析：这道题目需求不明确，是需要 所有的字符串=都有的公共前缀还是若只有部分字符串有公共前缀也可以？也可能我理解有误~</li>
</ul>
<h5 id="实现strtod-函数"><a href="#实现strtod-函数" class="headerlink" title="实现strtod()函数"></a>实现strtod()函数</h5><ul>
<li>即判断一个字符串是否表示一个数字如:”1.0”</li>
<li>分析：可以用状态机实现</li>
</ul>
<h5 id="整数和罗马数字的相互转换"><a href="#整数和罗马数字的相互转换" class="headerlink" title="整数和罗马数字的相互转换"></a>整数和罗马数字的相互转换</h5><ul>
<li>这道题有些无聊<h5 id="count-and-say"><a href="#count-and-say" class="headerlink" title="count and say"></a>count and say</h5></li>
<li>一个数列如下：<br>1 11 21 1211 111221,…<br>意思是1,第二个表示第一个的情况，即1个1故为11,第三个数表示第二个数的情况，即两个1,21，以此类推  </li>
<li>求数列中的第n个数</li>
<li>解决方案，直接模拟，一个一个算出来</li>
</ul>
<h5 id="Anagrams"><a href="#Anagrams" class="headerlink" title="Anagrams:"></a>Anagrams:</h5><ul>
<li>字符串中的打乱字母顺序从而得到新的单词如eat打乱后得到tea等</li>
</ul>
<h5 id="给定绝对路径简化它"><a href="#给定绝对路径简化它" class="headerlink" title="给定绝对路径简化它"></a>给定绝对路径简化它</h5><h5 id="在一个英文句子中找到最后一个单词的长度"><a href="#在一个英文句子中找到最后一个单词的长度" class="headerlink" title="在一个英文句子中找到最后一个单词的长度"></a>在一个英文句子中找到最后一个单词的长度</h5>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_string</tag>
      </tags>
  </entry>
  <entry>
    <title>DS_string</title>
    <url>/2018/06/24/DS-string/</url>
    <content><![CDATA[<h3 id="数据结构之串"><a href="#数据结构之串" class="headerlink" title="数据结构之串"></a>数据结构之串</h3><p>欢迎来到简单而又复杂的串世界,博主许久没有去研究串，还停留在以前学习和使用串的水平，再来一波学习和归纳，发现串的基本用法其实简单，也好理解，但是衍生出来的和应用相关，而且复杂，下面道来；<a id="more"></a></p>
<h4 id="串的基本"><a href="#串的基本" class="headerlink" title="串的基本"></a>串的基本</h4><h5 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h5><ul>
<li>“a1a2…..an”,其中包含字母，广义上可以是任意字符</li>
<li>在c/c++中结尾带’\0’，python则不带，长度均不包含’\0’</li>
<li>串长度-不同编码不同，根据具体需要如字节，实际字符等</li>
<li>空串和空白串，空白又可能是tab,回车，空格等等“</li>
<li>串的子串:子串个数：n(n+1)/2–等差数列，<h5 id="串常用的数据结构"><a href="#串常用的数据结构" class="headerlink" title="串常用的数据结构"></a>串常用的数据结构</h5></li>
<li><p>串常量–存在从汇编去看－数据段(data)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    .file	<span class="string">"test.c"</span></span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">"kesance"</span></span><br><span class="line">.LC1:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">"%d\n"</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br></pre></td></tr></table></figure>
</li>
<li><p>串数组:<br>将字符串存在顺序数组中</p>
</li>
<li>堆分配存在链表中<h5 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h5></li>
<li>子串个数：</li>
<li>串赋值</li>
<li>串比较</li>
<li>求串长</li>
<li>串拼接</li>
<li>求子串</li>
<li>替换子串</li>
<li>定位子串的位置<h4 id="字符编码和字符串匹配"><a href="#字符编码和字符串匹配" class="headerlink" title="字符编码和字符串匹配"></a>字符编码和字符串匹配</h4><h5 id="字符串的编码"><a href="#字符串的编码" class="headerlink" title="字符串的编码"></a>字符串的编码</h5></li>
<li>所谓字符编码，就是将字符用二进制唯一表示。在计算机的世界里不是1就是0，无论什么字符最后存入的还是二进制数，只是从内存中读出来时解析不同而已，即如让计算机将读出来的00111000解析成数字8,如文本显示程序，当设定为某种编码时，将字节流解析成对应的字符～现在看到的许多字体库也是这样的，将一串二进制串和某个字体对应起来，解析程序负责处理匹配和显示等</li>
<li><a href="https://en.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Unicode</a>　unicode编码了解一下</li>
</ul>
<h5 id="传统模式匹配算法"><a href="#传统模式匹配算法" class="headerlink" title="传统模式匹配算法"></a>传统模式匹配算法</h5><p>模式匹配，就是在字符串里面匹配另一个串相似或者相同的子串，传统的想法也和一般人想到的一样，扫描并一个一个字符对比，若第二串失配，则第二串重新匹配第一串的第二个，接着往下。。</p>
<h5 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h5><p>kmp作为完全匹配算法中的高效算法，基本原理如下：ps:大学学这个算法只学了它是什么原理，还没去想为什么这么做等）</p>
<ul>
<li><p><strong>基本思想</strong>：从上面看传统的匹配算法：  </p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> e f g </span><br><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> d <span class="selector-tag">a</span> e f</span><br></pre></td></tr></table></figure>
<p> 像上面的字符串匹配，第一次失配的地方是在c,则按照传统的方式，则应该重新：</p>
 <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> e f g</span><br><span class="line">  <span class="selector-tag">a</span> <span class="selector-tag">b</span> d <span class="selector-tag">a</span> e f</span><br></pre></td></tr></table></figure>
<p>但是其实如果是我们人去做匹配时，则会直接从：  </p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> e f g</span><br><span class="line">      <span class="selector-tag">a</span> <span class="selector-tag">b</span> d <span class="selector-tag">a</span> e f</span><br></pre></td></tr></table></figure>
<p>开始匹配，而kmp的基本思想也是这样；<br>例子：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c d <span class="selector-tag">a</span> <span class="selector-tag">b</span> c f g e </span><br><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c e <span class="selector-tag">a</span> <span class="selector-tag">b</span> c t</span><br><span class="line">第一次失配在d,那下一次应该在  </span><br><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c d <span class="selector-tag">a</span> <span class="selector-tag">b</span> c f g e </span><br><span class="line">        <span class="selector-tag">a</span> <span class="selector-tag">b</span> c e <span class="selector-tag">a</span> <span class="selector-tag">b</span> c t</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>所以它分为两部分，１是模式串在移动时候遵循的基本原理，２是当失配时，模式串的哪个位置的字符和源串的当前位置进行重新匹配；</li>
<li>1基本原理，重复：当模式串中存在大量的重复时，效果尤为明显<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c d <span class="selector-tag">a</span> <span class="selector-tag">b</span> c e f g </span><br><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c d <span class="selector-tag">a</span> <span class="selector-tag">b</span> c t</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述例子一样，可以看到 以d 为中点，前后有相同的串，abc,则显然next函数也能隐士检测到这个，所以当显然因为模式串的前后abc相等，而后abc又和源串的后abc相等，所以源串的后abc和模式串的前abc想等，自然失配时候就可以从模式串的d开始匹配起</p>
<ul>
<li><p><strong>2重点在next的计算，它决定当发生失配时，模式串如何移动</strong>：  </p>
<ul>
<li>假设模式串为P,j是当前模式串正在匹配的位置，源串为S,i是源串的当前位置，k是当P[j]!=S[i]时，P应该和S[i]比较的位置，以next[j]=k表示，故关键是求出next数组，显然k&lt;j</li>
<li>next如何计算得到:其实要利用前面的基本原理，<br>P[0-k-1]==P[j-k~j-1]==S[i-k到i-1] (即next[j]=k)<br>所以要求next[j+1]=?<br>-若P[k]==P[j]<br>P[0-k-1]+P[k]==P[j-k~j-1]+P[j]<br>即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1<br>-若P[k]!=P[j]<br>我们已经知道（0，k-1）串和（j-k,j-1）串是相等的，所以可以把（0，k-1）串当做一个新的模式串，发现在新模式串中<br>（0，next[k]-1）串与（k-next[k],k-1）串相等，所以（j-k,j-1）中存在与（0，next[k]-1）相等的串，所以可以把j移动到next[k],继续比较和移动。</li>
</ul>
</li>
<li><p>具体程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显然，next[0]=-1,此时无法向左边移动了源串模式串都要移动</span></span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>,此时只能向左移动到<span class="number">0.</span></span><br><span class="line"><span class="keyword">int</span> getnext(<span class="keyword">char</span> *P,<span class="keyword">int</span> next[])&#123;</span><br><span class="line">    j=<span class="number">1</span>,next[j]=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;<span class="keyword">sizeof</span>(P)&#123;</span><br><span class="line">      <span class="keyword">if</span>(k==<span class="number">0</span>||P[j++]==P[k++])</span><br><span class="line">            next[j]==k;<span class="comment">//next[j]=next[j]+1</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">           k=next[k];</span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="串和哈夫曼编码"><a href="#串和哈夫曼编码" class="headerlink" title="串和哈夫曼编码"></a>串和哈夫曼编码</h5><ul>
<li>霍夫曼编码是和编码相关的一个算法，是将一个串编码为二进制整数，如类似AABXBDHADFBFJD编码为1010011100011101001,而霍夫曼编码则作为转换算法，Huffman编码使得每一个字符的编码都与另一个字符编码的前一部分不同，不会出现像’A’：00，  ’B’：001，这样的情况，解码也不会出现冲突。</li>
</ul>
<h4 id="论文查重对比的几个算法-文本相似度）"><a href="#论文查重对比的几个算法-文本相似度）" class="headerlink" title="论文查重对比的几个算法(文本相似度）"></a>论文查重对比的几个算法(文本相似度）</h4><ul>
<li>杰卡德（Jaccard）相似系数<br>这种相似度计算方式相对简单，原理也易于理解，就是计算单词集合之间的交集和并集大小的比例，该值越大，表示两个文本越相似。在涉及到大规模并行计算时，该方法效率上有一定的优势。</li>
<li>余弦（Cosine）相似度<br>余弦相似度是利用计算两个向量之间的夹角，夹角越小相似度越高，其公式为：<br>假定A和B是两个n维向量，A是[A1,A2,…,An],B是[B1,B2,B3,…,Bn],则A与B的夹角余弦等于</li>
<li>等等,用时再看：<br><a href="https://www.cnblogs.com/huilixieqi/p/6493089.html" target="_blank" rel="noopener">https://www.cnblogs.com/huilixieqi/p/6493089.html</a></li>
<li>linux下的diff命令<br>还有win上的beyondcompare软件，这两个是用于比较文本的差异的，在代码移植时经常用到</li>
</ul>
<h4 id="串匹配－正则表达式"><a href="#串匹配－正则表达式" class="headerlink" title="串匹配－正则表达式"></a>串匹配－正则表达式</h4><ul>
<li>正则表达式用于匹配文本字符串，但是并不一定是完全匹配，且是匹配的串出现有随意性</li>
</ul>
<h5 id="正则表达式的理论基础"><a href="#正则表达式的理论基础" class="headerlink" title="正则表达式的理论基础"></a>正则表达式的理论基础</h5><ul>
<li>最早接触到正则表达式，是在大三学习编译原理的时候，解析词法语法的时候会用到正则表达式，用来过滤关键词，像c语言的很多关键词，以及判断它是不是合法的表达式，等等，常用的是lex和yacc,最原始的是自己的实现对词法和语法的解析，而不借助的lex；</li>
<li>正则表达，语法树，常用有限状态机来来实现，功能强大的如图灵机；</li>
</ul>
<h5 id="正则表达式和编译原理"><a href="#正则表达式和编译原理" class="headerlink" title="正则表达式和编译原理"></a>正则表达式和编译原理</h5><h5 id="正则表达式的基本实现"><a href="#正则表达式的基本实现" class="headerlink" title="正则表达式的基本实现"></a>正则表达式的基本实现</h5><ul>
<li>用c实现正则表达实现词法分析：</li>
<li><h5 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h5></li>
<li>语言支持</li>
<li>脚本语言支持情况</li>
<li>sed,awk</li>
</ul>
<h4 id="串和流"><a href="#串和流" class="headerlink" title="串和流"></a>串和流</h4><ul>
<li>流，所有的文本流</li>
<li>流分为二进制流和文本流</li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_routeicmp</title>
    <url>/2018/06/10/tcpip-routeicmp/</url>
    <content><![CDATA[<h3 id="IP选路和ICMP协议"><a href="#IP选路和ICMP协议" class="headerlink" title="IP选路和ICMP协议"></a>IP选路和ICMP协议</h3><h4 id="IP如何选路概述："><a href="#IP如何选路概述：" class="headerlink" title="IP如何选路概述："></a>IP如何选路概述：</h4><ul>
<li>ip选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组，区别于选路策略，后者是一组决定把哪些路由放入路由表的规则；ip执行选路机制，而路由守护程序则一般提供选路策略如rip,ospf</li>
<li>点对点时，直接送到  </li>
<li>非点对点时，经过路由器送到  </li>
<li>Ip层可以是配置为路由或者主机前者非则转发，后者非则丢弃</li>
<li>路由表项：每一项为<a id="more"></a><ul>
<li>目的ip地址（网络地址指定网络中所有主机或主机地址);</li>
<li>下一站路由器的ip地址，可能充当中继转发的，下一站非终点；</li>
<li>标志：指明目的地址是网络还是主机，下一站是路由器还是直连的接口</li>
<li>数据传输的网络接口如wlan0,eth0</li>
</ul>
</li>
<li>ip选路是逐跳进行的，</li>
<li>例子：<br>没连接热点前：<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">ernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line"><span class="number">10.42</span><span class="number">.0</span><span class="number">.0</span>       *               <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>   U     <span class="number">600</span>    <span class="number">0</span>        <span class="number">0</span> wlp2s0</span><br><span class="line">link-local      *               <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>     U     <span class="number">1000</span>   <span class="number">0</span>        <span class="number">0</span> wlp2s0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>连接热点后：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line"><span class="section">default</span>         <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         UG    <span class="number">600</span>    <span class="number">0</span>        <span class="number">0</span> wlp2s0</span><br><span class="line">link-local      *               <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>     U     <span class="number">1000</span>   <span class="number">0</span>        <span class="number">0</span> wlp2s0</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>     *               <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>   U     <span class="number">600</span>    <span class="number">0</span>        <span class="number">0</span> wlp2s0</span><br></pre></td></tr></table></figure></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Destination 	目标网段或者主机</span><br><span class="line">Gateway 	网关地址，”*” 表示目标是本主机所属的网络，不需要路由</span><br><span class="line">Genmask 	网络掩码</span><br><span class="line">Flags 	标记。一些可能的标记如下：</span><br><span class="line">  	U — 路由是活动的</span><br><span class="line">  	H — 目标是一个主机</span><br><span class="line">  	G — 路由指向网关</span><br><span class="line">  	R — 恢复动态路由产生的表项</span><br><span class="line">  	D — 由路由的后台程序动态地安装,(由重定向报文创建）</span><br><span class="line">  	M — 由路由的后台程序修改(已被重定向报文修改）</span><br><span class="line">  	! — 拒绝路由</span><br><span class="line">Metric 	路由距离，到达指定网络所需的中转数（linux 内核中没有使用）</span><br><span class="line">Ref 	路由项引用次数（linux 内核中没有使用）</span><br><span class="line"><span class="keyword">Use</span> 	此路由项被路由软件查找的次数</span><br><span class="line">Iface 	该路由表项对应的输出接口</span><br></pre></td></tr></table></figure>
<h5 id="如何搜索路由表"><a href="#如何搜索路由表" class="headerlink" title="如何搜索路由表"></a>如何搜索路由表</h5><ul>
<li>搜索路由表，目的ip地址匹配条母时，送到该条目的下一站，否则下一步：</li>
<li>搜索路由表，寻找与目的网络相匹配的条目，找到则送到下一站，如本地局域网；否则下一步：</li>
<li>搜索路由表，寻找标为默认的条目，有则使用它</li>
<li>若走完最后一步都没有，则数据包无法被传送，会向生成数据包的程序返回主机不可达或者网络不可达的错误</li>
<li>详细例子见卷１，这里较清楚了</li>
</ul>
<h5 id="子网寻址rfc950"><a href="#子网寻址rfc950" class="headerlink" title="子网寻址rfc950"></a>子网寻址rfc950</h5><ul>
<li>主机号再分为子网号和主机号，子网掩码也跟着变化；这样可以缩小路由表规模，想象一个包含30个子网的B类地址和30个C类地址相比</li>
<li>此时，外网–&gt;网关–&gt;局域网１–&gt;局域网１中的子网（局域网）10–&gt;子网11。。。</li>
<li>所以此时网关并非就是其直接路由器，若主机在子网11,10中，路由器需要知道发往哪个子网，通过子网掩码</li>
<li>给定ip地址和子网掩码后能知道什么：<br>知道该主机所在的子网；路由器可以知道是本子网的主机还是本网络中其他子网的主机还是其他网络的主机。。。路由进行的比较不需要比较到主机，如先比较类别网络地址如A,B,C:<br>如我们主机为140.252.1.1,子掩码为255.255.255.0,则与目的ip地址比较：140.252.4.5,可以知道B类网络地址相同但是子网不同(1,4),就不用再比较主机了，</li>
</ul>
<h5 id="特殊的网络地址"><a href="#特殊的网络地址" class="headerlink" title="特殊的网络地址"></a>特殊的网络地址</h5><h5 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h5><ul>
<li>ifconfig -a<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">wlp2s0</span>    <span class="selector-tag">Link</span> <span class="selector-tag">encap</span><span class="selector-pseudo">:Ethernet</span>  <span class="selector-tag">HWaddr</span> <span class="selector-tag">48</span><span class="selector-pseudo">:5a</span><span class="selector-pseudo">:b6</span><span class="selector-pseudo">:6e</span><span class="selector-pseudo">:c9</span><span class="selector-pseudo">:5f</span>  </span><br><span class="line">          <span class="selector-tag">inet</span> <span class="selector-tag">addr</span><span class="selector-pseudo">:192.168.0.110</span>  <span class="selector-tag">Bcast</span><span class="selector-pseudo">:192.168.0.255</span>  <span class="selector-tag">Mask</span><span class="selector-pseudo">:255.255.255.0</span></span><br><span class="line">          <span class="selector-tag">inet6</span> <span class="selector-tag">addr</span>: <span class="selector-tag">fe80</span><span class="selector-pseudo">::d713</span><span class="selector-pseudo">:7c0f</span><span class="selector-pseudo">:b40c</span><span class="selector-pseudo">:c085</span>/<span class="selector-tag">64</span> <span class="selector-tag">Scope</span><span class="selector-pseudo">:Link</span></span><br><span class="line">          <span class="selector-tag">UP</span> <span class="selector-tag">BROADCAST</span> <span class="selector-tag">RUNNING</span> <span class="selector-tag">MULTICAST</span>  <span class="selector-tag">MTU</span><span class="selector-pseudo">:1500</span>  <span class="selector-tag">Metric</span><span class="selector-pseudo">:1</span></span><br><span class="line">          <span class="selector-tag">RX</span> <span class="selector-tag">packets</span><span class="selector-pseudo">:7032</span> <span class="selector-tag">errors</span><span class="selector-pseudo">:0</span> <span class="selector-tag">dropped</span><span class="selector-pseudo">:0</span> <span class="selector-tag">overruns</span><span class="selector-pseudo">:0</span> <span class="selector-tag">frame</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">TX</span> <span class="selector-tag">packets</span><span class="selector-pseudo">:4297</span> <span class="selector-tag">errors</span><span class="selector-pseudo">:0</span> <span class="selector-tag">dropped</span><span class="selector-pseudo">:0</span> <span class="selector-tag">overruns</span><span class="selector-pseudo">:0</span> <span class="selector-tag">carrier</span><span class="selector-pseudo">:0</span></span><br><span class="line">          <span class="selector-tag">collisions</span><span class="selector-pseudo">:0</span> <span class="selector-tag">txqueuelen</span><span class="selector-pseudo">:1000</span> </span><br><span class="line">          <span class="selector-tag">RX</span> <span class="selector-tag">bytes</span><span class="selector-pseudo">:3668623</span> (<span class="number">3.6</span> MB)  <span class="selector-tag">TX</span> <span class="selector-tag">bytes</span><span class="selector-pseudo">:703812</span> (<span class="number">703.8</span> KB)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h5><ul>
<li>其实这个命令的功能很强，可以相互开服务端客户端通信和反向shell</li>
<li>netstat -in<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Kernel Interface table</span><br><span class="line">Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">enp1s0     <span class="number">1500</span> <span class="number">0</span>         <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> <span class="number">0</span>             <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> BMU</span><br><span class="line">lo        <span class="number">65536</span> <span class="number">0</span>      <span class="number">1404</span>      <span class="number">0</span>      <span class="number">0</span> <span class="number">0</span>          <span class="number">1404</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> LRU</span><br><span class="line">wlp2s0     <span class="number">1500</span> <span class="number">0</span>      <span class="number">7257</span>      <span class="number">0</span>      <span class="number">0</span> <span class="number">0</span>          <span class="number">4311</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> BMRU</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">netstat -rn</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line"><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         UG        <span class="number">0</span> <span class="number">0</span>          <span class="number">0</span> wlp2s0</span><br><span class="line"><span class="number">169.254</span><span class="number">.0</span><span class="number">.0</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span>     U         <span class="number">0</span> <span class="number">0</span>          <span class="number">0</span> wlp2s0</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>         <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>   U         <span class="number">0</span> <span class="number">0</span>          <span class="number">0</span> wlp2s0</span><br></pre></td></tr></table></figure>
<h5 id="初始化路由表"><a href="#初始化路由表" class="headerlink" title="初始化路由表"></a>初始化路由表</h5><ul>
<li>ifconfig设置接口地址，并用route　命令添加或删除路由表项<h5 id="主机可以选择转发或者不转发报文"><a href="#主机可以选择转发或者不转发报文" class="headerlink" title="主机可以选择转发或者不转发报文"></a>主机可以选择转发或者不转发报文</h5></li>
<li>在配置文件中配置ipfordwarding:</li>
<li>echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot<h4 id="ICMP协议rfc792"><a href="#ICMP协议rfc792" class="headerlink" title="ICMP协议rfc792"></a>ICMP协议rfc792</h4><h5 id="Icmp报文："><a href="#Icmp报文：" class="headerlink" title="Icmp报文："></a>Icmp报文：</h5></li>
<li>ICMP：IP头(20字节）+ICMP报文</li>
<li>IP头：<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code"> 0                   1                   2                   3</span></span><br><span class="line"><span class="code"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中options和padding不一定有</p>
<ul>
<li><p>ICMP报文：type+code共同决定ICMP类型，如回显or差错，，，</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|     Type      |     Code      |          Checksum             |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|       different type and code has different content           |</span><br><span class="line">|                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
</li>
<li><p>被封装于ip报文中，ip头加icmp,所有报文前四个字节都相同<br>(8位类型，8位代码，16位校验和）</p>
</li>
<li>类型+代码决定ICMP的报文类型，种类很多，见协议卷表</li>
<li>下列几种不会导致icmp差错报文：<ul>
<li>icmp差错报文；</li>
<li>目的地址为广播地址</li>
<li>作为链路层的广播地址</li>
<li>不是ip分片第一片</li>
<li>源地址不能为零地址，环回地址，广播地址或多播地址</li>
<li>上述是为了防止过去允许icmp差错报文对广播分组带来的广播风暴</li>
</ul>
</li>
<li><h5 id="ICMP协议总结几种类型："><a href="#ICMP协议总结几种类型：" class="headerlink" title="ICMP协议总结几种类型："></a>ICMP协议总结几种类型：</h5><ul>
<li>主机不可达</li>
<li>重定向错误</li>
<li>路由发现报文</li>
<li>icmp地址掩码请求和应答</li>
<li>icmp时间戳请求和应答</li>
<li>icmp端口不可达</li>
<li>ping 回显请求：</li>
<li>等等见表</li>
<li>且类型不同发送的报文格式不同</li>
</ul>
</li>
<li>主机不可达：当路由器收到一份ip数据报但是在路由表中搜索后找不到，不能转发时，会发送一份icmp主机不可达的差错报文</li>
<li>还有可能是已经经过了几个路由器后出现主机或网络不可达的情况，所以若是测试局域网，则先让路由器断开网络，ping路由器则确保问题不是在本地，而是在网络上；</li>
<li>icmp重定向错误：<br>举个例子，主机在路由表中搜索后将数据包发给默认路由，R1路由器，接着R1路由器搜索后发送给R2路由器，并同时发现它正在发送的接口(R2)和数据报到达的接口相同，即主机和两个路由器所在lan，即在同一个lan中）此时主机可以直接发送给R2,所以R1就发送一份ICMP重定向报文给主机，这样主机下次就可以直接发给R2了</li>
<li>如何更新路由表?通过ICMP的路由器发现报文：<br>以及利用路由器的定期广播多播它们的路由器通告报文rfc1256,而它一般是由用户守护进程来创建和处理</li>
<li>icmp地址掩码请求和应答，发送对某个ip地址请求地址掩码，并接收到子网掩码。路由器回复或者主机回复</li>
<li>icmp时间戳请求和应答，通过向某个IP主机发送这个，从而得到时间信息，telnet也可以进行，如NTP协议（网络时间协议）</li>
<li>icmp端口不可达：udp报文发送给主机后，若端口不匹配，对方主机会发送端口不可达的差错报文</li>
<li>ping回显，后面有文章记录ping程序编写<h4 id="动态选路"><a href="#动态选路" class="headerlink" title="动态选路"></a>动态选路</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5>上述讲的是静态路由表的情况：适合于1网络较小，2且与其他网络只有单个连接点，3且没有多余的路由时（如主路由失败，可以选择备用路由）；</li>
<li>总结：一种更新路由表的动态协议，从而达到最短路径  </li>
<li>上述三个条件不满足时，通常使用动态选路协议</li>
<li>当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时出现动态选路，路由器之间必须采用选路协议进行通信；路由器上有一个称为路由守护程序的进程，它运行选路协议，并与相邻的路由器通信，根据收到的信息，更新路由表</li>
</ul>
<h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><p>RIP ,OSPF(开放最短路径优先）,BGP</p>
<h5 id="宏观上看"><a href="#宏观上看" class="headerlink" title="宏观上看"></a>宏观上看</h5><p>在internet上，存在大量的主机，路由器等；并以一组自治系统(AS)的方式组织的，每个自治系统通常由单个实体管理，比如大学校园，公司，常常被定义为一个自治系统，NSFNET的internet骨干网形成一个自治系统；</p>
<ul>
<li>自治系统中使用的选路协议，称为内部网关协议IGP或者称为域内选路协议，这些协议有RIP,OSPF</li>
<li>用于不同自治系统之间的路由器，称为外部网关协议EGP,常见有BGP</li>
<li>unix选路守护程序：routed,gated等</li>
</ul>
<h5 id="RIP：rfc1058"><a href="#RIP：rfc1058" class="headerlink" title="RIP：rfc1058"></a>RIP：rfc1058</h5><ul>
<li>rip采用udp报文，端口号位520，为一种采用距离向量的协议,易受攻击</li>
<li>流程：<ul>
<li>初始化：启动一个路由守护进程时，先判断启动了哪些接口，接着在每个接口上发送请求报文，要求其他路由器发送完整的路由表，广播或点对点</li>
<li>接收请求：接收到上述请求后，会回复完整的路由表，否则处理请求报文每一个表项，若有链接到指明地址路由，则度量设置为我们的值，否则设置为16表示无穷大。返回响应</li>
<li>接收到响应后，更新路由表，如增加或修改或删除,采用Dijkstra算法得到最短路径树</li>
<li>定期选路更新，30s一次，进行广播发送完整路由表给相邻的路由器</li>
<li>触发更新：即每当度量发生变化，则对它进行更新，只需要发送度量变化的表项</li>
<li>定时器：3min内无更新路由，则度量设置为无穷大，标注为删除，再过60s删除并传波</li>
</ul>
</li>
<li>注:度量就是跳数，相邻路由度量为１</li>
<li>rip问题：无子网概念；路由器或链路故障要很久才能稳定下来，即收敛慢；易发生环回路由；跳数限制了网络大小15</li>
</ul>
<h5 id="OSPF开放最短路径优先：rfc1247"><a href="#OSPF开放最短路径优先：rfc1247" class="headerlink" title="OSPF开放最短路径优先：rfc1247"></a>OSPF开放最短路径优先：rfc1247</h5><ul>
<li>是一个链路状态协议；</li>
<li>使用ip协议而不是udp.tcp,</li>
<li>不与邻站交换距离信息而是主动测试与其他邻站相连链路状态，并将这些信息发送给它的其他邻站，邻站接着广播出去，每个路由器接收到后更新路由表</li>
<li>收敛快</li>
<li>可以对每个ip服务类型计算各自的路由集，意味着对任何目的，可以有多个路由表表项，每个表项对应一个ip服务类型；</li>
<li>给每个接口指派一个费用，通过吞吐率，往返时间，可靠性等，可以给每个ip服务类型指派一个费用</li>
<li><strong>同一个目的地址存在多个相同费用的路由时，在这些路由上平均分配流量，即流量平衡</strong></li>
<li><strong>支持子网</strong></li>
<li>路由器之间的点对点链路不需要每端都有一个ip地址，－无编号网络，节省ip</li>
<li>多播而非广播</li>
</ul>
<h5 id="BGP边界网关协议rfc1268"><a href="#BGP边界网关协议rfc1268" class="headerlink" title="BGP边界网关协议rfc1268"></a>BGP边界网关协议rfc1268</h5><ul>
<li>自治系统分类：<ul>
<li>残桩自治系统，他和其他自治系统只有单个连接，只有本地流量</li>
<li>多接口自治系统，和其他多个自治系统有多个链接，但是拒绝传送流量</li>
<li>转送自治系统，多链接且在一些策略准则下，它可以传送本地流量和通过流量</li>
</ul>
</li>
<li>是距离向量协议，用于自治系统之间，定期发送keepalive报文，30s<h5 id="CIDR无类型域间选路：rfc1518-1519"><a href="#CIDR无类型域间选路：rfc1518-1519" class="headerlink" title="CIDR无类型域间选路：rfc1518,1519"></a>CIDR无类型域间选路：rfc1518,1519</h5>待探索</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_conanddest_semantics</title>
    <url>/2018/06/09/cpp-conanddest-semantics/</url>
    <content><![CDATA[<h3 id="构造和析构函数语义学"><a href="#构造和析构函数语义学" class="headerlink" title="构造和析构函数语义学"></a>构造和析构函数语义学</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>即使是abstract base class也可能需要手动写constructor,de…,关键是看它有没有non satic data member  <a id="more"></a><br>例如:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_class</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="keyword">virtual</span> ~Abstract_base() = <span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span></span>=<span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> _mumble;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">       <span class="keyword">char</span> *_mumble;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>  上述例子，该抽象类本身不能被实例化，但是可以被继承，被继承时在构造时必须初始化 “mumble”,此时就需要用它的默认构造函数，所以必须为这个抽象类写一个构造函数；   </p>
<h4 id="2-纯虚函数的存在："><a href="#2-纯虚函数的存在：" class="headerlink" title="2. 纯虚函数的存在："></a>2. 纯虚函数的存在：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstra_class</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">	   <span class="comment">// virtual ~Abstra_class() =0;</span></span><br><span class="line">		<span class="keyword">virtual</span> ~Abstra_class() &#123; <span class="keyword">delete</span> _mumble;<span class="built_in">cout</span>&lt;&lt;<span class="string">"use ~abstra_class"</span>;&#125;</span><br><span class="line">		<span class="comment">//virtual void interface() const=0;</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"use interface Abstra_class:"</span>;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> _mumble;</span><br><span class="line">		&#125;</span><br><span class="line">		Abstra_class()&#123;_mumble=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];<span class="built_in">cout</span>&lt;&lt;<span class="string">"construct:Abs.."</span>;&#125;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="keyword">char</span>* _mumble;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dev</span> :</span> <span class="keyword">public</span> Abstra_class &#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				~dev() &#123;dd=<span class="number">0</span>;&#125;</span><br><span class="line">				dev()&#123;dd=<span class="number">3</span>;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">void</span> <span class="title">useA</span> <span class="params">()</span></span>&#123;</span><br><span class="line">               Abstra_class::interface();<span class="comment">//即使可以这样，但是链接失败，即因该函数的定义=0,重新加上定义使之不为pure就ok了</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">if</span>(dd==<span class="number">4</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"re"</span>;&#125;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="keyword">int</span> dd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  dev ddd;</span><br><span class="line">		ddd.useA();</span><br><span class="line">		ddd.interface();</span><br><span class="line">	  <span class="comment">//  Abstra_class::interface();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：construct:Abs..use interface Abstra_class:use ~Abstra_class: </p>
<p>　“可以定义和调用pure virtual func ,但是只能被静态的调用，而不能通过虚拟机制 “这个在g++上实验了下，发现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstra_class</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">	   <span class="comment">// virtual ~Abstra_class() =0;</span></span><br><span class="line">		<span class="keyword">virtual</span> ~Abstra_class() &#123; <span class="keyword">delete</span> _mumble;<span class="built_in">cout</span>&lt;&lt;<span class="string">"use ~Abstra_class:"</span>;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span></span>=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//virtual void interface() const &#123; cout&lt;&lt;"use interface Abstra_class:";&#125;</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> _mumble;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">ii</span><span class="params">()</span> <span class="keyword">const</span></span>=<span class="number">0</span>;<span class="comment">//ensure is a abstra class</span></span><br><span class="line">		Abstra_class()&#123;_mumble=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];<span class="built_in">cout</span>&lt;&lt;<span class="string">"construct:Abs.."</span>;&#125;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="keyword">char</span>* _mumble;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Abstra_class::interface() <span class="keyword">const</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dev</span> :</span> <span class="keyword">public</span> Abstra_class &#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				~dev() &#123;dd=<span class="number">0</span>;&#125;</span><br><span class="line">				dev()&#123;dd=<span class="number">3</span>;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">void</span> <span class="title">useA</span> <span class="params">()</span></span>&#123;</span><br><span class="line">                Abstra_class::interface();<span class="comment">//即使可以这样，但是链接失败，即因该函数的引用为0</span></span><br><span class="line">		           dd=<span class="number">4</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">						<span class="keyword">if</span>(dd==<span class="number">4</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"\nre\n"</span>;</span><br><span class="line">						<span class="comment">//Abstra_class::interface();</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ii</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"is implenment"</span>;&#125;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="keyword">int</span> dd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  dev ddd;</span><br><span class="line">		ddd.useA();</span><br><span class="line">		ddd.interface();</span><br><span class="line">	Abstra_class *pt=&amp;ddd;</span><br><span class="line">	pt-&gt;interface();</span><br><span class="line">	  <span class="comment">//  Abstra_class::interface();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  输出了两次re,说明可以通过虚拟机制调用它；interface在这里被内联的定义了空的函数，它不算pure了，所以上述说法感觉存在问题。。。<br>　注意，因为在每一个derived class　destructor会被扩展，以静态方式调用每一个virtual base class 和上一层的desturctor,<br>     所以只要缺少任何一个 base destructor定义则链接失败　，所以需要定义pure virtual destructor<br>      一个比较好的替代方式就是不要把vitual dect~定义为pure<br>      考虑到成本，不要把所有的函数都定以为virtual</p>
<p>3)虚拟规格的存在：<br>　　　　在virtual func要不要为const ,主要看要不要对date member做修改<br>所以不要随便定义为pure,virtual const,毕竟效率</p>
<h4 id="考虑几种情况下的构造情况："><a href="#考虑几种情况下的构造情况：" class="headerlink" title="考虑几种情况下的构造情况："></a>考虑几种情况下的构造情况：</h4><h5 id="一、无继承情况下对象构造几种方式："><a href="#一、无继承情况下对象构造几种方式：" class="headerlink" title="一、无继承情况下对象构造几种方式："></a>一、无继承情况下对象构造几种方式：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point global;　<span class="comment">//周期：程序的生命周期，exit前</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Point local;　<span class="comment">//此函数的周期，调用默认构造函数但是不会初始化成员</span></span><br><span class="line">   Point *heap=<span class="keyword">new</span> Point;<span class="comment">//delete 前，调用默认构造函数，但不会初始化成员</span></span><br><span class="line">   *heap=local;<span class="comment">//local若未调用用户初始化的构造函数，则warning,调用拷贝赋值函数，maybe 位搬移</span></span><br><span class="line">   <span class="keyword">delete</span> heap;<span class="comment">//默认析构函数</span></span><br><span class="line">   <span class="keyword">return</span> local;<span class="comment">//maybe拷贝构造或者位搬移</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>考虑这几个对象的声明周期</li>
<li>在c中，global会被放入bss中，未初始化，但是c++中所有的全局对象被当做“初始化过的数据”，会调用constructor函数　可以测试一下</li>
<li>一般情况下，c++默认为类生成：default constructor,destructor,copy constructor,copy assignment operator<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">			Point ()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"in constructor "</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">			~Point() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"in destructor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point glo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>显然在定义Point glo的时候构造函数是会调用的</p>
<p>１、抽象数据类型：<br>　　根据需要决定是否写constructor destructor或者默认的就足够了<br>　　　global类型的对象直到程序激活才调用构造函数<br>　　　显性的初始化列表比将构造函数扩展为inline效率更高，后者需要赋值等，看下面例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0.0</span>, <span class="keyword">double</span> y = <span class="number">0.0</span>, <span class="keyword">double</span> z = <span class="number">0.0</span>) :_x(x), _y(y), _z(z)&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; _x &lt;&lt; <span class="built_in">endl</span> &lt;&lt; _y &lt;&lt; <span class="built_in">endl</span> &lt;&lt; _z &lt;&lt; <span class="built_in">endl</span>; &#125;;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">double</span> _x, _y, _z;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    Point local1 = &#123; <span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span> &#125;;<span class="comment">//用g++ --std=c++11可以，若为double a=1.5; ..=&#123;a,...&#125;变量形式则不行（c++11可以） </span></span><br><span class="line">    local1.print();  </span><br><span class="line">  </span><br><span class="line">    system(<span class="string">"pause"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; ``` </span><br><span class="line">而在显性初始化列表（<span class="keyword">explicit</span> initialization <span class="built_in">list</span>)-&gt;xxx=&#123;yyy&#125;;使用时较快是如下原因：  </span><br><span class="line">函数的activation record 被放进程序的堆栈时，initializatioin <span class="built_in">list</span> 中的常量就可以被放进local1的内存中了;  </span><br><span class="line">但是<span class="keyword">explicit</span> initialization <span class="built_in">list</span>带来三个缺点：</span><br><span class="line">+ 只有当<span class="class"><span class="keyword">class</span> <span class="title">member</span> 都是<span class="title">public</span>时才生效，这点实验<span class="title">private</span>时也可以  </span></span><br><span class="line"><span class="class">+ 只能在&#123;</span> &#125;中指定常量，因为在编译期间进行评估求值</span><br><span class="line">+ 由于编译器为自动施行，所以失败的可能性更高  </span><br><span class="line">看一下汇编代码：</span><br><span class="line">```cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span>  y = <span class="number">0</span>, <span class="keyword">int</span> z = <span class="number">0</span>) :_x(x), _y(y), _z(z)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
 <figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x400938</span> push   <span class="symbol">%rbp</span></span><br><span class="line"><span class="number">0x400939</span> mov    <span class="symbol">%rsp</span>,<span class="symbol">%rbp</span></span><br><span class="line"><span class="number">0x40093c</span> mov    <span class="symbol">%rdi</span>,<span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="symbol">%rbp</span>)</span><br><span class="line"><span class="number">0x400940</span> mov    <span class="symbol">%esi</span>,<span class="number">-0</span>xc(<span class="symbol">%rbp</span>)</span><br><span class="line"><span class="number">0x400943</span> mov    <span class="symbol">%edx</span>,<span class="number">-0</span><span class="keyword">x</span><span class="number">10</span>(<span class="symbol">%rbp</span>)</span><br><span class="line"><span class="number">0x400946</span> mov    <span class="symbol">%ecx</span>,<span class="number">-0</span><span class="keyword">x</span><span class="number">14</span>(<span class="symbol">%rbp</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; _x &lt;&lt; <span class="built_in">endl</span> &lt;&lt; _y &lt;&lt; <span class="built_in">endl</span> &lt;&lt; _z &lt;&lt; <span class="built_in">endl</span>; &#125;;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">int</span> _x, _y, _z;  </span><br><span class="line">&#125;;   </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="keyword">int</span>  a=<span class="number">1</span>;	</span><br><span class="line">    Point local1 = &#123; a, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x4008a4</span> <span class="keyword">mov</span>    -<span class="number">0x24</span>(%rbp),%esi</span><br><span class="line"><span class="number">0x4008a7</span> <span class="keyword">lea</span>    -<span class="number">0x20</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x4008ab</span> <span class="keyword">mov</span>    <span class="number">$0</span>x5,%ecx</span><br><span class="line"><span class="number">0x4008b0</span> <span class="keyword">mov</span>    <span class="number">$0</span>x4,%edx</span><br><span class="line"><span class="number">0x4008b5</span> <span class="keyword">mov</span>    %rax,%rdi</span><br><span class="line"><span class="number">0x4008b8</span> callq  <span class="number">0x400938</span> &lt;Point::Point(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>上述讲的activation record是：  </p>
<ul>
<li>Locals to the callee</li>
<li>Return address to the caller</li>
<li><p>Parameters of the callee<br>从上述的汇编代码可以看到，在做显示初始化列表时将常量值赋给ecx等两个寄存器，接着调用构造函数，构造函数将寄存器的内容赋给成员，而其实采用Point local2;这种直接调用构造函数的发式也是如此，且和在构造函数中赋值给成员时转换的汇编相同，所以不是很理解这块的区别，在g++ c++11是如此表现的    </p>
<h5 id="２、为继承做准备："><a href="#２、为继承做准备：" class="headerlink" title="２、为继承做准备："></a>２、为继承做准备：</h5><p>继承可能用到多态，此时需要使用virtual ,那就会带来constructor等函数中加入对vptr的初始化（copy constructor等）<br>c++标准会要求编译器尽量延迟对nontrivial members的实际合成 操作，直到真正遇到其使用场合：这里trivial意思是无意义，这个trivial和non-trivial是对类的四种函数来说的：</p>
<p>  构造函数(ctor)<br>  复制构造函数(copy)<br>  赋值函数(assignment)<br>  析构函数(dtor)  </p>
</li>
</ul>
<p>如果至少满足下面3条里的一条：</p>
<pre><code>显式(explict)定义了这四种函数。
类里有非静态非POD的数据成员。
有基类。
</code></pre><p>那么上面的四种函数是non-trivial函数，比如叫non-trivial ctor、non-trivial copy…，也就是说有意义的函数，里面有一下必要的操作，比如类成员的初始化，释放内存等。   </p>
<h5 id="二、继承体系下的对象构造："><a href="#二、继承体系下的对象构造：" class="headerlink" title="二、继承体系下的对象构造："></a>二、继承体系下的对象构造：</h5><p>constructor函数中的隐藏代码，  </p>
<ol>
<li>初始化列表  </li>
<li>member的默认构造函数,若该member未出现在初始化列表中</li>
<li>vptr，在1,2之前，指向vtable   </li>
<li>base class constructor  1,2,3之前，以声明顺序为顺序，若在member initialization list中，则应传递参数，否则在1,2,3前加入其默认构造函数。多继承时可能this指针调</li>
<li>virtual base class constructor，从左到右，从最深到最浅 ，同4，若在list中有则用，否则。。  </li>
</ol>
<p>例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   Point (<span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>);  </span><br><span class="line">   Point(<span class="keyword">const</span> Point&amp;);</span><br><span class="line">   Point&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp;);</span><br><span class="line">   <span class="keyword">virtual</span> ~Point();</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0.0</span>;&#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">float</span> _x,_y;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">line</span> &#123;</span></span><br><span class="line">   Point _begin,_end;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     Line(....);</span><br><span class="line">     Line(...);</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure></p>
<p>line的默认析构函数会被合成，但是无意义，当然它的member的默认析构函数会被加入。。。其他类似</p>
<h5 id="三、虚拟继承："><a href="#三、虚拟继承：" class="headerlink" title="三、虚拟继承："></a>三、虚拟继承：</h5><ul>
<li><p>考虑下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       Point3d(<span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>,<span class="keyword">float</span> z=<span class="number">0.0</span>):Point(x,y),_z(z)&#123;&#125;</span><br><span class="line">       Point3d(<span class="keyword">const</span> Point3d&amp; rhs):point(rhs),_z(rhs._z)&#123;&#125;</span><br><span class="line">       ~Point3d();</span><br><span class="line">       Point3d&amp; <span class="keyword">operator</span>=...</span><br><span class="line">       <span class="comment">//..</span></span><br><span class="line">      proteced:</span><br><span class="line">      <span class="keyword">float</span> _z;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>传统的如上面的扩充构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;Point(:Point(x,y);</span><br><span class="line"><span class="keyword">this</span>-&gt;_vptr_Point3d = vtbl_Point3d;</span><br><span class="line"><span class="keyword">this</span>-&gt;_vptr_point3d_point=_vtbl_point3d_point;</span><br><span class="line"><span class="keyword">this</span>-&gt;_z=rhs_z;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span></span><br></pre></td></tr></table></figure>
<p>但是在这里，虚拟继承这显然不够准确：　　<br>考虑当出现菱形继承：　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Point;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Point3d,<span class="keyword">public</span> Vertex&#123;;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pvertex</span>:</span><span class="keyword">public</span> Vertex3d&#123;;&#125;;'</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  那作为被共享的Point subobject应该由最底层的如Vertex3d来初始化：<br>  而最底层显然也会初始化Point3d和vertex,并调用他们的构造函数；如果他们的构造函数不加限制，就会又调用Point的构造，导致错误；　　<br>  所以应该做限制，如下：<br>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vertex3d::Vertex3d(Vertex3d *<span class="keyword">this</span>,<span class="keyword">bool</span> __most_derived,<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> z)&#123;</span><br><span class="line"><span class="keyword">if</span>(__most_derived!=<span class="literal">false</span>)<span class="comment">//判断是否为最底层</span></span><br><span class="line">   <span class="keyword">this</span>-&gt;Point::Point(x,y);<span class="comment">//是则构造最上层的</span></span><br><span class="line">   <span class="comment">//调用上一层的base classes</span></span><br><span class="line">   <span class="comment">//设定__most_derived为false</span></span><br><span class="line"><span class="keyword">this</span>-&gt;Point3d::Ponint3d(..);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>而在<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point3d::Point3d(Point3d* <span class="keyword">this</span>,...)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(___most_derived!=<span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">this</span>-&gt;Point::Point(x,y);</span><br><span class="line">      ....</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>所以最底层的构造函数等会限制中间层对最上层的构造</p>
<ul>
<li>思考：</li>
<li>当obj只是某个完整的obj的子obj时，则不用调用virtual base class constructor:,如上，那就产生了一种提高效率的方式：</li>
<li>将构造函数分割为obj和subobj,，前者为完整版本的obj，自然要调用所有，包括基类的构造，后者不用，这种分裂可以提高效率</li>
</ul>
<h4 id="vptr初始化语意"><a href="#vptr初始化语意" class="headerlink" title="vptr初始化语意"></a>vptr初始化语意</h4><ul>
<li>题外，这本书总喜欢讨论特殊的情况，哭笑，下面也是，在构造函数中调用虚函数222</li>
<li>主要讨论vptr什么时候初始化合适，以及为什么</li>
<li><p>constructor调用顺序：考虑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Point;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Point3d,<span class="keyword">public</span> Vertex&#123;;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pvertex</span>:</span><span class="keyword">public</span> Vertex3d&#123;;&#125;;'</span><br></pre></td></tr></table></figure>
<p>当一个PVertex对象被构造时，构造函数顺序为：　　<br>Point<br>Point3d<br>Vertex<br>Vertex3d<br>Pvertex  </p>
</li>
<li>假设这个继承体系中的每一个类都定义了一个virtual func size()，该函数负责传回class的大小；如果我们写：<br>Pvertex pv;<br>Point3d p3d;<br>Point  *pt=&pv;<br>那么这个调用pt-&gt;size()传回PVertex的大小，而<br>pt=&p3d; pt-&gt;size()则传回p3d的大小；</li>
<li><p>更进一步，特殊情况：<br>当在构造函数中调用这个操作时，如在point3d构造函数中调用时，是选择哪个class的size,毕竟现在正在构造point3d,答案是point3d的</p>
<ul>
<li>考虑如何使得上述生效?</li>
<li>静态调用Point3d::size()或者bnalalla</li>
<li>最后，利用vptr虚拟机制，即要在调用size之前初始化好其class对应的vptr</li>
<li>总结：在这种情况下，vptr在base class constructor 调用之后，在程序员代码之前（如size),或是初始化列表所列的member初始化操作前</li>
<li>更好的，分割constructor为完整obj和subobj</li>
</ul>
<h3 id="对象复制语意学"><a href="#对象复制语意学" class="headerlink" title="对象复制语意学"></a>对象复制语意学</h3><h4 id="复制函数什么时候会被合成和使用"><a href="#复制函数什么时候会被合成和使用" class="headerlink" title="复制函数什么时候会被合成和使用"></a>复制函数什么时候会被合成和使用</h4></li>
<li>前言，当你设计一个类，并以一个对象复制给另一个对象时，有三种选择：  <ul>
<li>什么也不做，实行默认行为  </li>
<li>提供一个显性拷贝函数</li>
<li>拒绝，只需要把复制函数声明为private就可以 </li>
</ul>
</li>
<li>考虑默认的行为：<ul>
<li>bitwise copy行为，当不出现一下情况时，甚至不会调用复制函数，而是做bitwise copy</li>
<li>而当出现以下行为时，调用默认的copy assignment operator函数，并合成相关操作：　　<ol>
<li>当class中有mem obj，这个obj有一个copy ass operaator</li>
<li>当类的基类有copy assi opera..</li>
<li>类带virtual func</li>
<li>继承自一个virtual base class  </li>
</ol>
</li>
</ul>
</li>
<li>写一个显性的复制函数：  <ul>
<li>在发生上述情况时，编译器也会像合成构造函数一样在显性的复制函数中加东西</li>
<li>而继上面的，Point共享基类，编译器如何能在Point3d和Vertex的copy assignment operator中压抑point的copy assignment operator呢?</li>
<li>书中的后面有些难以理解，等后面再探索吧，哎时间有限。。<h3 id="对象的功能"><a href="#对象的功能" class="headerlink" title="对象的功能"></a>对象的功能</h3>测试对象构造和拷贝的成本，在从简单形式，单一继承，到多重继承，虚拟继承等情况下的时间复杂度<h3 id="解构语意学"><a href="#解构语意学" class="headerlink" title="解构语意学"></a>解构语意学</h3></li>
</ul>
</li>
<li>析构函数并不会总是被合成出来，更别提调用；</li>
<li>只有在类内带的member object或者自己的base class带有destructor，编译器才会合成一个析构函数，否则被视为不需要或者不用合成调用</li>
<li>析构函数没必要和构造函数对称</li>
<li>析构函数一般有以下顺序：<ul>
<li>先调用最底层子类析构函数，接着往上，直到基类</li>
<li>析构函数本身在被执行时，vprt会在程序员代码前被执行</li>
<li>若class拥有member class object ,而后者拥有destructor,则他们会以其声明顺序相反顺序被调用</li>
<li>如果object内带一个vptr,则首先重设相关的virtual table</li>
<li>若有任何直接的非虚基类拥有析构函数，则同上</li>
<li>若有虚基类，则按照构造顺序相反顺序调用</li>
</ul>
</li>
<li>类似于构造函数，可以分裂</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_funcmember_memory</title>
    <url>/2018/06/09/cpp-funcmember-memory/</url>
    <content><![CDATA[<h3 id="c-function语意学"><a href="#c-function语意学" class="headerlink" title="c++ function语意学"></a>c++ function语意学</h3><p>something:<br>恩，这部分记录自己对c++中的函数特殊性的理解，本想深入函数本质，之前接触过，记得在linux内核剖析那本书讲的很好。<br> 可以参考；<a id="more"></a></p>
<ul>
<li>实现类的成员函数和类之间的关联，即通过对象能调用成员函数。这种实现，可以是以下几种方式：<br>1）struct+函数指针：结构体中，一个成员函数对应一个指针，增加空间 如何操作成员？<br>2）函数+this指针，普通函数，this指针一个，不添加额外多的空间，this 操作成员<br>。。。</li>
</ul>
<ul>
<li>c++的类主要是将成员和函数封装起来。那么成员的封装就像struct一样，而函数呢？成员函数如何和类，对象联系起来？–this指针</li>
</ul>
<ul>
<li>c++中的成员函数和普通函数一样，只是多了个this指针，这个指针指向当前调用这个函数的对象，并以形参传入，这样，成员函数就可以使用对象成员了，通过<br>this指针；</li>
</ul>
<ul>
<li><p>这里也是根据深入探索c++模型中第四章，function语义学总结的：</p>
<h4 id="引入这个问题："><a href="#引入这个问题：" class="headerlink" title="引入这个问题："></a>引入这个问题：</h4><p>通过对象和对象指针来调用成员函数的不同：<br>Point3d obj;<br>Point3d *p=&obj;<br>两者效率有何不同？</p>
<p>通过上面分析：当这个成员函数为普通的成员函数时，则直接调用函数，传入this指针，所以基本没有大的区别  </p>
<h4 id="以下分为几种函数讨论："><a href="#以下分为几种函数讨论：" class="headerlink" title="以下分为几种函数讨论："></a>以下分为几种函数讨论：</h4><h5 id="非静态成员函数："><a href="#非静态成员函数：" class="headerlink" title="非静态成员函数："></a>非静态成员函数：</h5><p>为了支持this指针等构成成员函数，c++做了如下步骤：  </p>
<ul>
<li>a;改写函数原型：安插了一个this参数</li>
<li>b；对对象成员的操作，通过this</li>
<li>c;对成员函数写成外部函数，并将其名称进行mangling处理，成独一无二～类似：函数名___类名参数名 等等</li>
<li>如何命名：成员函数和成员都会被名称特殊化处理：一般加上base class &amp;derived class名<br> 对重载函数而言如何区分：加上参数链表；<br> 当extern C时，会压抑这种特殊命名化<br> 具体编译器实现不同，可以通过汇编等。gdb等看</li>
</ul>
</li>
</ul>
<ul>
<li><p>鉴于此：看一个例子：<br>当你需要构造一个（拷贝构造函数）或者改变一个类的成员： 伪代码：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize__Point</span><span class="params">(<span class="keyword">register</span> <span class="keyword">const</span> Point3d *<span class="keyword">const</span> <span class="keyword">this</span>,Point3d &amp;_result)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    _reuslt.Point3d::Point3d() <span class="comment">//默认构造函数：</span></span><br><span class="line">    _result._x=<span class="keyword">this</span>-&gt;__x/<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"> 那么，以下这种方式：更好：</span><br><span class="line"> Point3d Point3d::normmalize() <span class="keyword">const</span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  Point3d(_x/<span class="number">2</span> ...)直接构建会更快） </span><br><span class="line">  =》转换为<span class="keyword">return</span> Point3d(<span class="keyword">this</span>-&gt;_x/<span class="number">2</span>,...)</span><br></pre></td></tr></table></figure>
<h5 id="virtual-func"><a href="#virtual-func" class="headerlink" title="virtual func"></a>virtual func</h5><p>若normilaze是虚拟函数，则<br>ptr-&gt;normilaze()=》 （*ptr-&gt;vptr[1])(ptr);<br>可以看到效率较低，所以当确认不用多态机制的时候，最好抑制它，直接使用：Point3d::xxx  这种方式调用函数<br>而若被写成内连函数会更优–原因待探索：</p>
</li>
</ul>
<h5 id="静态成员函数："><a href="#静态成员函数：" class="headerlink" title="静态成员函数："></a>静态成员函数：</h5><p> 显然这种能被类直接调用的函数，没有this指针，从而也就无法用成员<br> 这种函数的出现，是因为一种需求：即不用每个成员函数都会使用成员，不一定需要this<br> 不用声明一个对象就可以调用函数，当非要对象不可，又不用成员时：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">((Point3d*)<span class="number">0</span>)-&gt;object_count() ;</span><br></pre></td></tr></table></figure></p>
<p> 有了static后，就不用上述方式了<br> 所以static的特性完全来源它的原理：  </p>
<ul>
<li>它不能直接存取non static 成员</li>
<li>它不能被声明为const volatile virtual</li>
<li><p>能直接被类调用<br>静态成员函数和普通函数更像，因为它没有this指针，也就不是这种类型：~ unsigned int(*) ();<br>所以更可以和类之外的元素沟通，比如回调函数</p>
<h5 id="虚拟成员函数"><a href="#虚拟成员函数" class="headerlink" title="虚拟成员函数"></a>虚拟成员函数</h5><ul>
<li>a 为了支持多态，需要在执行期间能判断到底调用哪个函数？即pz-&gt;z()这个函数，pz为基类指针，而能调用子类函数</li>
<li>b 基类指针或引用参考到的（指向的）子类，，子类中的重写父类的函数，在调用时并不知道传入哪个this,即表现为调用哪个函数</li>
<li>c　那么为了支持通过基类能调用它，通过子类也能调用该函数，则需要基类和子类共享某个东西，他能正确决议出要调用的函数</li>
</ul>
</li>
<li><p>带来：额外的空间，和c的兼容性</p>
<h5 id="积极多态的概念："><a href="#积极多态的概念：" class="headerlink" title="积极多态的概念："></a>积极多态的概念：</h5><p>（１）被指出的对象真正被使用；（２）dynamic_cast<br>那么哪些函数需要支持这样的特性－－－》由virtual标志来指出<br>如何在执行期间调用真正的函数？－－－》ptr所指的对象真实类型＋函数的位置　真实类型放在vtable[0]</p>
</li>
<li><p>编译期间做的：<br>在每个对象中加入：一个字符串或数字来表示class　类型＋一个指针，指向表格vtable,它带有程序的virtual func执行期地址<br>确定表格中的函数指针，执行期无法改变表格一个类对应一个表格，每个virtual func被指定一个固定的索引值</p>
</li>
<li>执行期间做的：<br>为vptr分配内存地址。它的值在编译期间确定，类似于x=3;  指向vtable<br>调用函数时激活　。编译器已经为其转换语义为xxx-&gt;vptr<a href="this">n</a>.. </li>
<li>注意，当一个子类继承基类时，vptr继承过来，当子类改写virtual函数时，则改变表中的指针指向子类的；当子类添加一个新的virtual func时，则在表中加一个slot</li>
<li>唯一在执行期间才知道的：slot(n)到底指向哪个函数实体<br>细想一下：  <pre><code>derived de; //编译期间，符号表确认要分配的对象类型,执行期间分配内存和调用构造函数等，构造函数中会初始化vptr,    
base *p=&amp;de;//编译期间，类似于int x=3;,执行期间分
配内存给x,并将３给x,确定p所指的真正对象，从而才能取得vptr,到调用到最终的函数
p-&gt;xx();//xx为virtual (*p-&gt;vptr[1])(p)
</code></pre></li>
</ul>
<h5 id="some-question"><a href="#some-question" class="headerlink" title="some question"></a>some question</h5><p> //关于执行期和编译期确定的东西，有些困惑，为啥编译器不能在p-&gt;xx()的时候指定调用子类的xx()?<br> //在编译器扫描代码的时候，知道定义了一个derived类型的变量，知道，定义了一个base指针，并指向的变量类型为derived,后面调用时也能<br> 确定函数名，为啥不能根据已存的这些信息。来得到哦。这时p指向的是derive类型的。所以调用derived的函数？<br> 不过也是，编译器从做词汇扫描，到语义扫描，出符号表，到语法检查，语义规则等</p>
<h5 id="多重继承下面的virtual-func"><a href="#多重继承下面的virtual-func" class="headerlink" title="多重继承下面的virtual func"></a>多重继承下面的virtual func</h5><p> 考虑以下例子：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span> :</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">　　　<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> base1* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base2</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> b;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> b;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> base2* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derive</span>:</span><span class="keyword">public</span> base1,<span class="keyword">public</span> base2</span><br><span class="line">   <span class="keyword">int</span> c;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">c</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> c;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> derive* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p> 对于和derived有相同起点的base1不用考虑太多，关键是base2,;有三个问题要解决：<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">　(<span class="number">1</span>)<span class="keyword">virtual</span> <span class="function"><span class="keyword">destructor</span> <span class="params">(记得之前是逐层调用）</span></span></span><br><span class="line"><span class="function"><span class="params"> 　（２）被继承下来的b()</span></span></span><br><span class="line"><span class="function">  <span class="params">(3）一组clone函数 </span></span></span><br><span class="line"><span class="function"><span class="params">（a)</span>   做<span class="title">base2</span> *<span class="title">pbase2</span>=<span class="title">new</span> <span class="title">derive</span>;</span></span><br><span class="line">　　　　＆＆＆编译期间确定：＆＆＆</span><br><span class="line"> =&gt;  derived *tmp=new derive;</span><br><span class="line"> 　　　base2 *pbase2=tmp?tmp+sizeof(base1):<span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p> 为了使pbase2能访问到　b 即pbase２-&gt;b, 多重继承下使用 base *p=de;时，注意此时需要调整，让p指向的是de中的base对应部分</p>
<ul>
<li>当通过delete pbase2时，此时需要删除完整的对象，所以pbase２指针需要调整到指出完整对象的起始点<br>他也要通过上述a类似的加法，以及调用virtual destructor函数  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> 如base2 *pbase2=<span class="keyword">new</span> derive;  </span><br><span class="line"><span class="keyword">delete</span> pbase2;<span class="comment">//invoke derive class's destructor (virtual )</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> 　首先这个调用要通过vptr,其次，传入的this指针需要调整<br>  ＆＆＆执行期间确定＆＆＆</p>
<ul>
<li><p>注意：然而，这种offset加法无法在编译期间直接设定。pbase2所指的真正对象只有在执行期间才能确定<br>//如何调整；早期的想法是：将vtable中的slot改为一个slot放置函数指针faddr和this的offset<br>//则：（<em>pbase2-&gt;vptr[1])(pbase2);<br>//改为　（</em>pbase2-&gt;vptr[1].faddr)(pbase2+pbase2-  &gt;vptr[1].offset);但是连带处罚了其他形式virtual func调用，</p>
<ul>
<li>那如何处理？  </li>
<li>[１]方法１：thunk<br>　　　～：this+=sizeof(base1)<pre><code>Derived::~Derived(this);//只有汇编才有效率
</code></pre>如何使能？在virtual table slot继续内含一个简单的指针，slot中的地址可以指向一个virtual func或者一个thunk(若需要调整this)<br>其实多重继承来讲，每个继承的基类，都需要一个virtual table;,这样派生类就会维护多个基类的vtable</li>
<li>1)经由derived或第一个base class)调用，不需要调整this</li>
<li><p>2)经由&gt;=2的base class 调用，同一种函数在virtual table中可能需要多笔对应的slot</p>
<pre><code>base1 *pbase1 =new derived;
base2 *pbase2=new derived;
delete pbase1//不需要调整this,virtual table slot放置正真的destructor地址

delete pbase2//需要调整this ,放置thunk
vptr和vtable命名也会被特殊化
参考图在书中，这里不放
</code></pre></li>
</ul>
</li>
<li><p>[２]方法２　：<br> 因为动态链接器的原因，使得符号链接变得缓慢<br> 为了调整执行期链接器的效率，sun编译器将多个vtable 连锁为一个，指向次要表格的指针可以由主要表格加offset<br>　  其他类似。<br>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　　　　　base2 *ptr =<span class="keyword">new</span> derived;</span><br><span class="line"><span class="keyword">delete</span> ptr;<span class="comment">//此时调用derived::~deirved,故ptr需要被调整，若为virtual，需要更多</span></span><br><span class="line"></span><br><span class="line">derived *pder=<span class="keyword">new</span> derived;</span><br><span class="line">pder-&gt;b();<span class="comment">//注意b没有被改写，所以需要调整pder指向base2 subobj</span></span><br><span class="line"></span><br><span class="line">base2 *pb1=<span class="keyword">new</span> derived;</span><br><span class="line">base2 *pb2=pb1-&gt;clone()<span class="comment">//注意是调用derived:clone,所以调用后返回值要改变器指向base2 subobj</span></span><br><span class="line"></span><br><span class="line">当函数被认为足够小　，sun编译器会采用某种算法优化，split。。，否则不会，具体待了解。</span><br><span class="line">所以<span class="keyword">virtual</span> func的通常大小为８行</span><br></pre></td></tr></table></figure>
</li>
<li><p>[３]IBM:<br>函数若支持多重进入点，将不必有许多thunk;将thunk操作放在virtual func中，里面判断是否需要调整this指针</p>
</li>
</ul>
<h5 id="虚拟继承下的virtual-func"><a href="#虚拟继承下的virtual-func" class="headerlink" title="虚拟继承下的virtual func"></a>虚拟继承下的virtual func</h5><p>这种情况相当复杂了。需要探索上述的这些问题：point2d.point3d的对象不再相符，即使只继承一个，即单一虚拟继承，也需要调整this指针<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point2d</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  point2d()</span><br><span class="line">  <span class="keyword">virtual</span> ~point2d()</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mumble</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  virutal  <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span></span><br><span class="line">  protected:</span><br><span class="line">  <span class="keyword">float</span> _x,_y;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">point3d</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> point2d&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    point3d()</span><br><span class="line">    ~point3d</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>可以尝试下写出例子比较point2d和point3d指针看指向是否相同
当virtual base class中包含virtual func和nonstatic member时，各个厂商实现不同，复杂，作者不建议这么做

－－－－－－－－－－－－－－－－－－－
</code></pre><h4 id="函数的效能："><a href="#函数的效能：" class="headerlink" title="函数的效能："></a>函数的效能：</h4><p>  这部分可以通过函数的调用方式感性的了解，或者根据不同的编译器。测试对比几种调用的时间，以及是否已经开启优化等<br>  （如编译器将被视为不变的表达式提到循环之外）<br>  （通过消除局部对象的使用可以消除对constructor的调用）</p>
<h4 id="指向memeber-func的指针："><a href="#指向memeber-func的指针：" class="headerlink" title="指向memeber　func的指针："></a>指向memeber　func的指针：</h4><p>  取一个nonstatic member func的地址，若为nonvirtual 则为其在内存中的真正地址。<br>  但需要this参数。　<br>  指向member func的指针：double (Point::<em>pmf)();类似<br>  定义：double (point::</em>coord)() =&amp;point::x;<br>       赋值:coord=&amp;point::y<br>       调用：（origin.<em>coord)()/(ptr-&gt;</em>coord)()<br>       转换为：(coord)(&amp;origin)/(coord)(ptr)</p>
<h5 id="指向virtual-memeber-func指针"><a href="#指向virtual-memeber-func指针" class="headerlink" title="指向virtual memeber func指针"></a>指向virtual memeber func指针</h5><p>  在g++中<br>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">getp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mp;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">void</span> <span class="title">setp</span><span class="params">(<span class="keyword">float</span> mmp)</span></span>&#123;mp=mmp;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">4</span>;&#125;</span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">				<span class="keyword">float</span> mp;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">		<span class="keyword">float</span> (Base1::*pmf)()=&amp;Base1::getp;</span><br><span class="line">		Base1 *ptr=<span class="keyword">new</span> Base1;</span><br><span class="line">		ptr-&gt;setp(<span class="number">3.2</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ptr-&gt;getp()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//3.2</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//3.2　　会被内部转换：（*ptr-&gt;vptr[(int)pmf])(ptr)</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::getp);<span class="comment">//1　索引值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::setp);<span class="comment">//40xxx真实地址</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::test);<span class="comment">// 9，为什么是９不清楚</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::test1);<span class="comment">//11</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　所以，对于虚拟函数也是可以通过函数指针来访问的，只不过得到的地址是索引值，但不影响访问<br>或者对以下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">getp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mp;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">void</span> <span class="title">setp</span><span class="params">(<span class="keyword">float</span> mmp)</span></span>&#123;mp=mmp;&#125;</span><br><span class="line">			        <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">4</span>;&#125;</span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">				<span class="keyword">float</span> mp;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">		<span class="keyword">float</span> (Base1::*pmf)()=&amp;Base1::getp;</span><br><span class="line">		Base1 *ptr=<span class="keyword">new</span> Base1;</span><br><span class="line">		ptr-&gt;setp(<span class="number">3.2</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ptr-&gt;getp()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::getp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::setp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::test);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::test1);</span><br><span class="line">                  </span><br><span class="line">                <span class="keyword">int</span> (Base1::*pmi)()=&amp;Base1::test1;<span class="comment">//or test　可以指向两种，编译器如何区分呢？cfront２　通过判断是索引（may &lt;127)还是函数地址来区分</span></span><br><span class="line">                Base1 *ptr2=<span class="keyword">new</span> Base1;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;(ptr2-&gt;*pmi)()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> ptr2;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="多重继承下指向member-func指针"><a href="#多重继承下指向member-func指针" class="headerlink" title="多重继承下指向member func指针"></a>多重继承下指向member func指针</h5><p>为了让mem func point能支持多重继承和虚拟继承：<br>噢这种情况很复杂了。你得知道它指向的是virtual 还是non virtual<br>书中并没有探讨太多，野比较复杂，这里举一个例子，探索细节可以看编译器，gdb等结果：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">getp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mp;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">void</span> <span class="title">setp</span><span class="params">(<span class="keyword">float</span> mmp)</span></span>&#123;mp=mmp;&#125;</span><br><span class="line">			        <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">4</span>;&#125;</span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">				<span class="keyword">float</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">get2p</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m2p;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set2p</span><span class="params">(<span class="keyword">float</span> m2pp)</span></span>&#123;m2p=m2pp;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">int</span> <span class="title">test22</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test21</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">6</span>;&#125;</span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">				<span class="keyword">float</span> m2p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Der</span>:</span><span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">get3p</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m3p;&#125;</span><br><span class="line">		<span class="keyword">private</span>:</span><br><span class="line">				<span class="keyword">float</span> m3p;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">		<span class="keyword">float</span> (Base1::*pmf)()=&amp;Base1::getp;<span class="comment">//这后面的调用就发挥想象把，想怎么尝试都行</span></span><br><span class="line">		Base1 *ptr=<span class="keyword">new</span> Der;</span><br><span class="line">		ptr-&gt;setp(<span class="number">3.2</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ptr-&gt;getp()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(ptr-&gt;*pmf)()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Der::getp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::setp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::test);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Base1::test1);</span><br><span class="line">                  </span><br><span class="line">                <span class="keyword">int</span> (Base1::*pmi)()=&amp;Base1::test1;<span class="comment">//or test</span></span><br><span class="line">                Base1 *ptr2=<span class="keyword">new</span> Base1;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;(ptr2-&gt;*pmi)()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> ptr2;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="效能"><a href="#效能" class="headerlink" title="效能"></a>效能</h5><h5 id="inline-func"><a href="#inline-func" class="headerlink" title="inline func:"></a>inline func:</h5><p>首先得直到，内联函数实际上表现为什么？函数本质上被经过栈调用，而内联函数是直接　在主函数中铺开为表达式，所以调用内联函数　能提高效率，但是响应的<br>源代码会变大，而且有参数的限制<br>应用：在操作符函数中，指定set,get类函数，使得操作符函数能被写成普通的函数。　而set get 写成inline函数，会减少效率降低<br>inline关键词只是请求，并不会所有都inline展开，编译器会做判断权衡<br>具体看书，不是很细<br>内联函数两个注意点：<br>形式参数：inline扩展时，每一个形式参数会被对应的实际参数代替：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　　　　　　<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> i&lt;j?i:j;</span><br><span class="line">          &#125;</span><br><span class="line">三个调用：</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> minval;</span><br><span class="line">   <span class="keyword">int</span> val1=<span class="number">1024</span>;</span><br><span class="line">   <span class="keyword">int</span> val2=<span class="number">2048</span>;</span><br><span class="line">   minval=min(val1,val2); 参数直接替换val1&lt;val2?val1:val2;</span><br><span class="line">   minval=min(<span class="number">1024</span>,<span class="number">2048</span>);替换后直接使用常量：<span class="number">1024</span></span><br><span class="line">   minval=min(fool(),bar()+<span class="number">1</span>) 引发参数副作用，需要导入一个临时对象，以避免重复求值：</span><br><span class="line">   　　　　     <span class="keyword">int</span> t1,t2; minval=(t1=foo()),(t2=bar()+<span class="number">1</span>),t1&lt;t2?...)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> minval&#125;</span><br></pre></td></tr></table></figure></p>
<p> 局部变量:在内联函数中加入局部变量，会导致因为维护局部变量带来的成本；<br> 内联函数在替代c宏，是比较安全的；但是若宏中参数有副作用的话，如上，会导致大的扩展码以维护局部变量或者生成临时的变量</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_datamember_memory</title>
    <url>/2018/06/08/cpp-datamember-memory/</url>
    <content><![CDATA[<h3 id="c-class-datamemory"><a href="#c-class-datamemory" class="headerlink" title="c++ class  datamemory"></a>c++ class  datamemory</h3><p>详细介绍c++的成员布局，类本身的布局和在各种情况下的布局</p>
<h4 id="“类”本身的大小："><a href="#“类”本身的大小：" class="headerlink" title="“类”本身的大小："></a>“类”本身的大小：</h4><ul>
<li>the simplest 引入</li>
<li>1.2 多少内存能表现一个class?<br>最小是１　  size<a id="more"></a></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span> &#125;;   --<span class="number">-1</span> 一个<span class="keyword">char</span> 表示这个类型</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;　　--指针大小，指针指向T  <span class="keyword">virtual</span> base <span class="class"><span class="keyword">class</span> <span class="title">subobject</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Y</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;  --指针大小</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> X,<span class="keyword">public</span> Y &#123;&#125;;　--两个指针大小　```  </span><br><span class="line">－－从深入那本书中说有两种方式，体现<span class="class"><span class="keyword">class</span>的大小，这里是优化的特殊的类型，这些好理解，但是需要类的空间的真正原因是什么？这<span class="title">T</span>的一个<span class="title">char</span>存储了什么？  </span></span><br><span class="line"><span class="class">用来干嘛？那在<span class="title">X</span>中指向<span class="title">T</span>的又是为什么需要？  </span></span><br><span class="line"><span class="class">最小１<span class="title">char</span>?  </span></span><br><span class="line"><span class="class">我们知道，当一个类中仅包含一个<span class="title">nonstatic</span> <span class="title">member</span>时，如<span class="title">int</span> ,则对象为<span class="title">int</span>大小，但是当类为空时，对象如何去分配内存？</span></span><br><span class="line"><span class="class">如果同时定义了两个对象，那如何去区分这两个对象？让他们地址不相同？－－－所以这里需要一个<span class="title">char</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">+ 注意，类本身也是一个类型，像<span class="title">int</span>，<span class="title">struct</span>一样，它的大小为４，<span class="title">struct</span>成员和对齐，则类也一样，<span class="title">sizeof</span>是在编译期间（确定<span class="title">c89</span>中）  </span></span><br><span class="line"><span class="class">一个例子：</span></span><br><span class="line"><span class="class">```<span class="title">cpp</span></span></span><br><span class="line"><span class="class">#<span class="title">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="class">#<span class="title">define</span> _<span class="title">sizeof</span>(<span class="title">T</span>) ((<span class="title">size_t</span>)((<span class="title">T</span>*)0+1))</span></span><br><span class="line"><span class="class">#<span class="title">include</span>&lt;stdio.h&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">namespace</span> <span class="title">std</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span><span class="keyword">public</span> X,<span class="keyword">public</span> Y&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TT</span>&#123;</span><span class="keyword">public</span>:<span class="keyword">int</span> q;<span class="keyword">int</span> x;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		T t1,t2;</span><br><span class="line">		<span class="keyword">int</span> xx;</span><br><span class="line">		<span class="keyword">if</span> (&amp;t1==&amp;t2)</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"same"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%x\n"</span>,&amp;t1);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%x\n"</span>,&amp;t2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,&amp;xx);</span><br><span class="line">	<span class="comment">//	int sie=(Y*)0+1;</span></span><br><span class="line">	<span class="comment">//	printf("%x\n",X&#123;&#125;);</span></span><br><span class="line">	    <span class="keyword">int</span> s= _sizeof(TT);　８　编译期间确定，直接把８赋给内存</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;_sizeof(T)&lt;&lt;<span class="built_in">endl</span>;　１</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(TT)&lt;&lt;<span class="built_in">endl</span>;　　８</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(T)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(X)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自然t1,t2地址不同，相邻</p>
<h4 id="那么一个类大的方面需要这些："><a href="#那么一个类大的方面需要这些：" class="headerlink" title="那么一个类大的方面需要这些："></a>那么一个类大的方面需要这些：</h4><p>１）类中定义的普通成员<br>２）语言本身所造成的额外负担如virtual机制，virtual table ,virtual base class subobject<br>３）Aligmnment带来的<br>（编译器的优化会带来内存布局的影响）</p>
<p>上述例子：当编译器不做优化时，为１，8+1+3,8+1+3 ,1(X)+8+8+3(ali)</p>
<h4 id="总结datamember的布局"><a href="#总结datamember的布局" class="headerlink" title="总结datamember的布局"></a>总结datamember的布局</h4><ul>
<li>对象只存非静态的成员变量，而无论中间放置了几个静态变量都不会影响他们之间的排布。<br>　　　大部分的编译器将先定义的非静态成员变量放在低地址，而后的放在高地址。最好用时先用kdbg或测试程序等看下</li>
<li>静态成员的存取不通过对象，他们放在数据段中</li>
<li>vptr一般会放在哪里？　<br>　　对象的头或者尾巴</li>
<li>align:C++标准要求，在同一个access section(private,public,protect等区段），member的排列只需要符和较晚出现放在较高的地址“即可，<br>　　access sections的多少并不会带来额外的负担</li>
<li>我在g++上做了测试:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TT</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line">   <span class="keyword">sizeof</span>&#123;TT);   <span class="number">8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TT</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line"> protect:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">   <span class="keyword">sizeof</span>(TT)=<span class="number">16</span></span><br><span class="line">class TT&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line"> protect:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">char</span> f;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">sizeof</span>(TT)=<span class="number">24</span> </span><br><span class="line">class TT&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">char</span> f;</span><br><span class="line"> protect:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">sizeof</span>(TT)=<span class="number">24</span></span><br><span class="line">class TT&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">char</span> f;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line"> protect:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">sizeof</span>(TT)=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>  由此看来这个编译器是按着c的struct对齐来的啊， </p>
<h4 id="data-member的存取："><a href="#data-member的存取：" class="headerlink" title="data member的存取："></a>data member的存取：</h4><ul>
<li><p>成本<br>比较：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">        TT tt1;</span><br><span class="line">		TT *tt2=&amp;tt1;</span><br><span class="line"><span class="number">0x400b87</span> lea    <span class="number">-0x20</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400b8b</span> mov    %rax,<span class="number">-0x48</span>(%rbp)</span><br><span class="line">		<span class="keyword">int</span> d=tt1.d;</span><br><span class="line"><span class="number">0x400b8f</span> mov    <span class="number">-0x1c</span>(%rbp),%eax</span><br><span class="line"><span class="number">0x400b92</span> mov    %eax,<span class="number">-0x68</span>(%rbp)</span><br><span class="line">		<span class="keyword">int</span> f=tt2-&gt;d;</span><br><span class="line"><span class="number">0x400b95</span> mov    <span class="number">-0x48</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400b99</span> mov    <span class="number">0x4</span>(%rax),%eax</span><br><span class="line"><span class="number">0x400b9c</span> mov    %eax,<span class="number">-0x64</span>(%rbp)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对static成员啊而言，实际是在数据段中，所以不管什么形式的访问都是相同的<br>待测试</p>
</li>
<li>通过成员函数<br>需要通过this 指针，则同上例子中的指针访问</li>
</ul>
<h3 id="总结几种情况下的的布局"><a href="#总结几种情况下的的布局" class="headerlink" title="总结几种情况下的的布局"></a>总结几种情况下的的布局</h3><h4 id="单一继承不含多态"><a href="#单一继承不含多态" class="headerlink" title="单一继承不含多态"></a>单一继承不含多态</h4><h5 id="一个典型的例子如下"><a href="#一个典型的例子如下" class="headerlink" title="一个典型的例子如下"></a>一个典型的例子如下</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    Point2d( <span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>):_x(x),_y(y)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123; _x=newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123; _y=newY;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+= (<span class="keyword">const</span> Point2d&amp;  rhs) &#123;</span><br><span class="line">        _x+=rhs.x();</span><br><span class="line">        _y+=rhs.y();</span><br><span class="line">        &#125;</span><br><span class="line">    ...more member;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Point3d</span>:</span> <span class="keyword">public</span> Point2d&#123;</span><br><span class="line">     <span class="keyword">public</span>: </span><br><span class="line">        Point3d(<span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>,<span class="keyword">float</span> z=<span class="number">0.0</span>):Point2d(x,y),_z(z)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">z</span><span class="params">(<span class="keyword">float</span> newZ)</span></span>&#123;_z=newZ;&#125; </span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Point3d&amp; rhs) &#123;</span><br><span class="line">           Point2d::<span class="keyword">operator</span>+=(rhs);</span><br><span class="line">           _z+=rhs.z();</span><br><span class="line">           &#125;</span><br><span class="line">          ...more member               </span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h5><p>则　基类的成员被子类包含，放在较低的地址；相比之下，多了对齐的空间；<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     <span class="keyword">char</span> c1;</span><br><span class="line">     <span class="keyword">char</span> c2;</span><br><span class="line">     <span class="keyword">char</span> c3;</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure></p>
<p>则需要占用８bytes;</p>
<p>而当被继承实现时：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete1</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     <span class="keyword">char</span> bit1;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete2</span>：<span class="title">public</span> <span class="title">Concrete1</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">char</span> bit2;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="class"><span class="keyword">class</span>  <span class="title">Concrete3</span>:</span><span class="keyword">public</span> Concrete2&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> bit3;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>  由此带来成本 8+4+4=16</p>
<ul>
<li>那为什么要这么做的？继承的时候不能挤在一起吗？<br>（在深入c++对象模型中有图容易理解。这里仅说明：<br>　　　若：　Concrete2  *pc2;<pre><code>Concrete1 *pc1_1,*pc1_2;
*pc1_2=*pc1_1; -默认复制构造
pc1_1 = pc2; //pc1_1指向pc2;
*pc1_2=*pc1_1;//覆盖掉了，如果继承是成员挤在一起，而不是对齐来的
</code></pre></li>
</ul>
<h5 id="单一继承含多态："><a href="#单一继承含多态：" class="headerlink" title="单一继承含多态："></a>单一继承含多态：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    Point2d( <span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>):_x(x),_y(y)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">0.0</span>;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z</span><span class="params">(<span class="keyword">float</span>)</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123; _x=newX;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123; _y=newY;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="keyword">operator</span>+= (<span class="keyword">const</span> Point2d&amp;  rhs) &#123;</span><br><span class="line">        _x+=rhs.x();</span><br><span class="line">        _y+=rhs.y();</span><br><span class="line">        &#125;</span><br><span class="line">    ...more member;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Point3d</span>:</span> <span class="keyword">public</span> Point2d&#123;</span><br><span class="line">     <span class="keyword">public</span>: </span><br><span class="line">        Point3d(<span class="keyword">float</span> x=<span class="number">0.0</span>,<span class="keyword">float</span> y=<span class="number">0.0</span>,<span class="keyword">float</span> z=<span class="number">0.0</span>):Point2d(x,y),_z(z)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z</span><span class="params">(<span class="keyword">float</span> newZ)</span></span>&#123;_z=newZ;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Point3d&amp; rhs) &#123;</span><br><span class="line">           Point2d::<span class="keyword">operator</span>+=(rhs);</span><br><span class="line">           _z+=rhs.z();</span><br><span class="line">           &#125;</span><br><span class="line">          ...more member     </span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由此可以满足<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　<span class="function"><span class="keyword">void</span> <span class="title">fool</span><span class="params">(Point2d &amp;p1,Point2d &amp;p2)</span></span>&#123;</span><br><span class="line">p1+=p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以是Point2d和Point3d 这种弹性，牺牲了时间和空间<br>加入了什么呢？  </p>
<pre><code>virtual table
vptr
add constructor vptr setting
add destructor vptr virtual table dele
</code></pre><p>所以需要视情况而定，如若只是涉及到2d&amp;3d之间，则可以是<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Point２d&amp; rhs) &#123;</span><br><span class="line">           Point2d::<span class="keyword">operator</span>+=(rhs);</span><br><span class="line">           _z+=rhs.z();<span class="comment">//此时＋０</span></span><br><span class="line">           &#125;</span><br><span class="line"><span class="function">Point2d <span class="title">p2d</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">Point3d <span class="title">p3d</span><span class="params">(,,,,)</span></span>;</span><br><span class="line">p3d+=p2d</span><br></pre></td></tr></table></figure></p>
<p>另外：对vptr的摆放位置，若放在最后面，则兼容c<br>但是损失了对继承的更好支持，所以现在放在最前面</p>
<h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>多重继承考虑的问题较多？但从设计角度看，你可能会问？<br>对比单一继承，子类成员起始地址和基类相同，那多重继承，和哪个基类一样？其他基类怎么办，在向上转型如何处理，指针呢？</p>
<p>另外，在单一继承中，vptr放在最开始的地方，如果base class没有virtual func而derived　class有呢？则此时单一继承的自然多态被打破，<br>若此时把一个derived class 转换为base class则　需要编译器介入，在多重继承+虚拟继承下就更有必要了</p>
<p>考虑这个例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　<span class="class"><span class="keyword">class</span> <span class="title">Point2d</span>&#123;</span> 带<span class="keyword">virtual</span> 接口</span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">float</span> _x _y;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> Point2d&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   protectd:</span><br><span class="line">      <span class="keyword">float</span> _z;</span><br><span class="line">      &#125;'</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> &#123;</span>带<span class="keyword">virtual</span>接口</span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">        Vertex *next;</span><br><span class="line">   &#125;;    </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Point3d,<span class="keyword">public</span> Vertex &#123;</span><br><span class="line">   protexted:</span><br><span class="line">     <span class="keyword">float</span> mumble;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>对多重继承派生对象，若将其地址　指定给最左端的base class则情况同单一继承一样，因为二者指向相同的地址。但是对第二个及以上时<br>需要将地址修改，加上或减去　介于中间的base class subobject<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  eg:  Vertex3d v3d;</span><br><span class="line">        Vertex *pv;</span><br><span class="line">        Point２d *p2d</span><br><span class="line">        POint3d  *p3d;  </span><br><span class="line">        pv=&amp;v3d</span><br><span class="line">     则内部为：pv=(Vertex*)(((<span class="keyword">char</span>*)&amp;v3d)+<span class="keyword">sizeof</span>(Point3d));     </span><br><span class="line">     而对p2d=&amp;v3d;</span><br><span class="line">         p3d=&amp;v3d则只需要简单的拷贝</span><br><span class="line">```              </span><br><span class="line">      若为Vertex3d　*v3d;  pv=v3d;则内部还要进行判断空。因为*v3d可能为空，</span><br><span class="line">      而引用不用，因为引用不可能参考到无</span><br><span class="line">对存取其第二个基类成员，也是做类似的offset操作</span><br><span class="line">##### 虚拟继承</span><br><span class="line">在多重继承加虚拟继承时，如ios istream ostream</span><br><span class="line">前面的内容会好理解一些，这部分的内容不好理解，也有些繁琐，于是，我回到之前学习的方法，即为什么，出现的原因，如果是自己实现又如何，等思考：</span><br><span class="line">+ 为什么需要虚拟继承？  </span><br><span class="line">虚拟继承出现，是因为当基类<span class="number">2</span>和<span class="number">3</span>都继承了基类<span class="number">1</span>，而基类<span class="number">4</span>继承了<span class="number">2</span>和<span class="number">3</span>，则基类<span class="number">4</span>会同时拥有两份基类<span class="number">1</span>，而虚拟继承就是为了让基类<span class="number">4</span>只包含一份基类<span class="number">1</span>，形成菱形继承结构</span><br><span class="line">```cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ios</span>&#123;</span>..&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> ios&#123;..&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> ios&#123;..&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iostream</span>:</span></span><br><span class="line"><span class="keyword">public</span> istream, <span class="keyword">public</span> ostream &#123;..&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，虚拟继承是如何做，使得类4能只包含1份基类1，而不影响其他功能呢：</p>
<ul>
<li><p>梳理下：<br>上述例子：挑战在于，将istream 和ostream 各自维护的一个ios subobj ，折叠为一个由iostream维护的单一ios subobj ，<br>并且还可以保存base class 和derived class的指针（以及reference)之间的多态操作<br>一般的实现方式如下： class 如果内含一个或者多个virtual base class obj,像istream那样，将被分割为两部分，一个不变的局部和一个共享局部<br>不变的局部中的数据，不管后继如何演化，都总是拥有固定的offset(从obj头算起），这部分数据可以直接存取，共享局部，则是virtual base class subject，这部分数据位置会因为每次派生发生变化，所以他们只能被间接存取  </p>
<p>所以就是：istream 中有自己的和ios相关的部分，这部分为共享部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> _<span class="title">x</span> _<span class="title">y</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point2d  _z</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point2d</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Point3d <span class="keyword">public</span> Vertex</span><br></pre></td></tr></table></figure>
<p>那 istream 如何存取这部分共享的数据？和iostream共享？感觉有点像单例模式</p>
</li>
<li><p>cfront是这样实现的：（这语言没见过）： 会在每个derived class obj中安插一些指针，每个指针 指向一个virtual base class 存取继承得来的virtual base<br>class member;所以在存取时通过这个指针存取<br>在多层继承时间接存取次数多；每个对象需要为每个virtual base class 背负一个指针）</p>
<pre><code> void Point3d::operator+=(const Point3d &amp;rhs) {
  _x+=rhs._x;
  _y+=rhs._y;
  _z+=rhs._z;
  }
 则在这里：被转为：伪代码：_vbcPoint2d-&gt;_x+=rhs.__vbcPoint2d-&gt;_x;//vbc==virtual base class
 ....

而Point2d *2d=3d;
Point2d *2d=3d? 3d-&gt;__vbcPoint2d:0;
</code></pre></li>
</ul>
<ul>
<li><p>microsoft ：引入类似于vbtable的方法，引入virtual base class table 。而在对象中放一个指针指向该表，表则放置那些指向virtual base class 指针<br>Bjarne: g++等（现在可能变了，但是类似）：</p>
<pre><code>在虚函数表中放置virtual base class 的offset而不是地址。
在这里，上面的例子：（this+__vbtr__point3d[-1])-&gt;_x+= (&amp;rhs+rhs.__vptr__point3d[-1])-&gt;_x;
...
Point2d *2d=3d?3d+3d-&gt;__vptr__point3d[-1]:0
</code></pre></li>
<li><p>注意：若是基类1含有virtual func则会拥有一个vptr指向自己的vtable. 而虚拟继承它的基类2,3，基类2,3本身含有virtual func则不会通过继承基类1的方式<br>继承它的vptr,所以可以看到在书中的图中point3d有两个指针vptr,以下例子通过kdbg调试可以看到这个两个vptr</p>
</li>
</ul>
<ul>
<li>两个问题：</li>
<li>基类1在继承连增加时位置如何变化？</li>
<li>在基类自己有virtual func时为什么要自己独用一个vptr?<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> &#123;</span></span><br><span class="line">                <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">printx</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="keyword">float</span> _x,_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point2d&#123;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				Vertex *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Point2d&#123;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span>:</span><span class="keyword">public</span> Vertex,<span class="keyword">public</span> Point3d&#123;</span><br><span class="line">		<span class="keyword">protected</span>:</span><br><span class="line">				<span class="keyword">float</span> mumble;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PO</span>&#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">		    <span class="comment">// virtual ~PO();</span></span><br><span class="line">			 <span class="keyword">static</span> <span class="keyword">int</span> origin;</span><br><span class="line">			 <span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> PO::origin =<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		Point2d d2d;</span><br><span class="line">		Point3d d3d;</span><br><span class="line">		Vertex vx;</span><br><span class="line">		Vertex3d v3x;</span><br><span class="line">		PO po;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,&amp; PO::z);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,&amp;po);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,&amp;po.x);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,&amp;po.y);</span><br><span class="line"><span class="comment">//		printf("%d\n",&amp;po.origin);</span></span><br><span class="line">		<span class="keyword">float</span> PO::*p1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">float</span> PO::*p2=&amp;PO::x;</span><br><span class="line">		<span class="keyword">if</span>(p1==p2)</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"sma"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="使用gdb调试："><a href="#使用gdb调试：" class="headerlink" title="使用gdb调试："></a>使用gdb调试：</h5><p>写完程序后：<br>编译时加-g<br>gdb 科执行程序名</p>
<ul>
<li>设置断点：break 行号<br>s向下执行<br>set p obj &lt;on/off&gt;: 在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。 使用show print object查看对象选项的设置。<br>set p pertty &lt;on/off&gt;: 按照层次打印结构体。可以从设置前后看到这个区别。on的确更容易阅读。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> p obj on</span><br><span class="line"><span class="built_in">set</span> p pertty on</span><br><span class="line">p 对象名</span><br><span class="line">p /a ((<span class="keyword">void</span> ***)d3d)[<span class="number">0</span>]@<span class="number">18</span> <span class="comment">//看到更详细的内存 @18为打印的成员数，[0]指从第0个开始打印--感觉不太对</span></span><br><span class="line">p /a ((<span class="keyword">void</span> **)vx)[<span class="number">0</span>]@<span class="number">16</span><span class="comment">//同上</span></span><br><span class="line">(gdb) p b</span><br><span class="line">$<span class="number">1</span> = &#123;_vptr.Base = <span class="number">0x400a60</span> &lt;vtable <span class="keyword">for</span> Base+<span class="number">16</span>&gt;&#125;</span><br><span class="line">(gdb) x/<span class="number">16</span>x <span class="number">0x400a60</span></span><br><span class="line"><span class="number">0x400a60</span> &lt;_ZTV4Base+<span class="number">16</span>&gt;:    <span class="number">0x0040094c</span>  <span class="number">0x00000000</span>  <span class="number">0x72654437</span>  <span class="number">0x64657669</span></span><br><span class="line">(gdb) x/<span class="number">16</span>x <span class="number">0x0040094c</span></span><br><span class="line"><span class="number">0x40094c</span> &lt;Base::f()&gt;:   <span class="number">0xe5894855</span>  <span class="number">0x10ec8348</span>  <span class="number">0xf87d8948</span>  <span class="number">0x400a15be</span></span><br><span class="line"><span class="number">0x40095c</span> &lt;Base::f()+<span class="number">16</span>&gt;:    <span class="number">0x10c0bf00</span>  <span class="number">0xf9e80060</span>  <span class="number">0xc9fffffd</span>  <span class="number">0x485590c3</span></span><br><span class="line"><span class="number">0x40096c</span> &lt;Derived::f()+<span class="number">2</span>&gt;:  <span class="number">0x8348e589</span>  <span class="number">0x894810ec</span>  <span class="number">0x1bbef87d</span>  <span class="number">0xbf00400a</span></span><br><span class="line"><span class="number">0x40097c</span> &lt;Derived::f()+<span class="number">18</span>&gt;: <span class="number">0x006010c0</span>  <span class="number">0xfffddbe8</span>  <span class="number">0x66c3c9ff</span>  <span class="number">0x00841f0f</span></span><br><span class="line">  (gdb) <span class="built_in">set</span> $i = <span class="number">0</span></span><br><span class="line">  (gdb) <span class="keyword">while</span> $i &lt; <span class="number">10</span></span><br><span class="line">     &gt;print $i</span><br><span class="line">     &gt;p /a (*(<span class="keyword">void</span> ***)obj)[$i]</span><br><span class="line">     &gt;<span class="built_in">set</span> $i = $i + <span class="number">1</span></span><br><span class="line">     &gt;end</span><br><span class="line">Where <span class="string">"obj"</span> is the object whose vtable you'd like to print, <span class="keyword">and</span> <span class="number">10</span> is the number of methods.</span><br><span class="line">p /a (*(<span class="keyword">void</span> ***)obj)[<span class="number">0</span>]@<span class="number">10</span></span><br><span class="line">info address _ZTV3Bar</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="对象成员的效率"><a href="#对象成员的效率" class="headerlink" title="对象成员的效率"></a>对象成员的效率</h4><h4 id="指向对象成员变量的指针"><a href="#指向对象成员变量的指针" class="headerlink" title="指向对象成员变量的指针"></a>指向对象成员变量的指针</h4><p>可以用于测试底层布局，如vptr放在哪，access section 次序。等<br>例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　<span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> &#123;</span></span><br><span class="line">     <span class="keyword">public</span> :</span><br><span class="line">        <span class="keyword">virtual</span> ~Point3d();</span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">static</span> Point3d origin；</span><br><span class="line">        <span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1)&amp;Point3d::z  –得到z在class obj中的偏移量<br>需用printf</p>
<p>书中说的为了使得指向对象和对象成员的指针区分，而+1,在g++中没有怎么体现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//			virtual ~Point3d()&#123;;&#125;</span></span><br><span class="line">				<span class="keyword">static</span> Point3d origin;</span><br><span class="line">				<span class="keyword">float</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line">Point3d Point3d::origin;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Point3d p3d;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&amp;Point3d=%p\n"</span>,&amp;p3d);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&amp;Point3d=%p\n"</span>,&amp;p3d.x);<span class="comment">//这两个地址相同</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&amp;Point3d=%p\n"</span>,&amp;p3d.y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&amp;Point3d::x=%p\n"</span>,&amp;Point3d::x);<span class="comment">//nil,若Point3d带virtual func,则为8</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&amp;Point3d::y=%p\n"</span>,&amp;Point3d::y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&amp;Point3d::z=%p\n"</span>,&amp;Point3d::z);</span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">float</span>*)&amp;p3d==(<span class="keyword">float</span>*)&amp;p3d.x)<span class="built_in">cout</span>&lt;&lt;<span class="string">"yes"</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出yes</span></span><br><span class="line">		<span class="keyword">float</span> Point3d::*p1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">float</span> Point3d::*p2=&amp;Point3d::x;</span><br><span class="line">		<span class="keyword">float</span> Point3d::*p3=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span>(p1==p2)<span class="comment">//未输出</span></span><br><span class="line">		&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"p1==p2"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//no output in g++</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span>(p2==p3)</span><br><span class="line">		&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"p2==p3"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//no output in g++</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里若是加了virtual func则，x为8，说明是vptr是放在前面的<br>通过指针取得对象成员:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> *p=origin.z  </span><br><span class="line">struct  Base1&#123;<span class="keyword">int</span> val1;&#125;</span><br><span class="line"><span class="function">struct <span class="title">Base2</span> <span class="params">(<span class="keyword">int</span> val2;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">struct Derved:Base1,Base2&#123;..&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> func1(<span class="keyword">int</span> Derved::*bmp,Derved *pd)</span><span class="comment">//传入offset等，多继承时易出错</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pd-&gt;*dmp;.....</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_polymorphism</title>
    <url>/2018/06/08/cpp-polymorphism/</url>
    <content><![CDATA[<h3 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h3><h4 id="为什么需要多态？"><a href="#为什么需要多态？" class="headerlink" title="为什么需要多态？"></a>为什么需要多态？</h4><p>引入几个点：<br>　　继承的机制中，基类的指针和引用能指向派生类，（派生类对象中的基类成员是在内存前面的，即指向派生类对象的指针指向的是第一个基类的第一个成员）  </p>
<ul>
<li>指针的值本质上是内存地址，也就是说指向不同变量(int char.)，对象的指针本身的值都是地址的value)</li>
<li>指针的类型限定了指针的操作内存范围和取值的方式，如通过int指针取值的时候，取到４byte,通过char指针取值时取得1byte;）<a id="more"></a></li>
<li>因此，基类指针限定了，即使它指向派生类，它也只能操作基类自身的成员和方法；就像char形指针指向int形，取得的只是一部分）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　　<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="number">4</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 5 </span>&#123;</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">int</span> in=<span class="number">2</span>;</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">char</span> *pc=(<span class="keyword">char</span>*)&amp;in;</span><br><span class="line"> <span class="number">8</span>     <span class="built_in">cout</span>&lt;&lt;*pc&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//乱码</span></span><br><span class="line"> <span class="number">9</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure>
<p>所以基类指针可以指向子类，但是只能调用基类的函数，即使子类复写了父类的函数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;rBase = derived;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>This example prints the result:</p>
<p>rBase is a Base</p>
<p>/＝》简化：如何让下面的例子得到想要的结果？<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Animal *animals[] = &#123; &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iii=<span class="number">0</span>; iii &lt; <span class="number">6</span>; iii++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animals[iii]-&gt;getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; animals[iii]-&gt;speak() &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如何让父类指针指向子类对象，可以调用子类函数呢？<pre><code>－－－多态
</code></pre></li>
<li>调用的子类函数要满足:<br>A derived function is considered a match if it has the same signature (name, parameter types, and whether it is const) and return type as the base version of the function. Such functions are called overrides.</li>
</ul>
<h4 id="如何使用－－－例子"><a href="#如何使用－－－例子" class="headerlink" title="如何使用－－－例子"></a>如何使用－－－例子</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Base"</span>; &#125; <span class="comment">// note addition of virtual keyword</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Derived"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;rBase = derived;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This example prints the result:</p>
<p>rBase is a Derived<br>－－－－－－－－－－－－－－－－－－－－－－－<br>再盗一个例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We're making this constructor protected because</span></span><br><span class="line">    <span class="comment">// we don't want people creating Animal objects directly,</span></span><br><span class="line">    <span class="comment">// but we still want derived classes to be able to use it.</span></span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"???"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Meow"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Woof"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(Animal &amp;animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; animal.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; animal.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cat <span class="title">cat</span><span class="params">(<span class="string">"Fred"</span>)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">dog</span><span class="params">(<span class="string">"Garbo"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    report(cat);</span><br><span class="line">    report(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="注意多态的方式："><a href="#注意多态的方式：" class="headerlink" title="注意多态的方式："></a>注意多态的方式：</h4><p>调用基类指针指向子类，函数时，会调用到继承琏最底端，且该最低端的子类有该virtual函数的，否则只调用到最下且复写了该函数的。如下例子：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> <span class="number">3</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"> 4 &#123;</span></span><br><span class="line"> <span class="number">5</span>         <span class="keyword">public</span>:</span><br><span class="line"> <span class="number">6</span>                     <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line"> <span class="number">7</span> &#125;;</span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line"><span class="number">10</span> &#123;</span><br><span class="line"><span class="number">11</span>         <span class="keyword">public</span>:</span><br><span class="line"><span class="number">12</span>                     <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line"><span class="number">13</span> &#125;;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line"><span class="number">16</span> &#123;</span><br><span class="line"><span class="number">17</span>         <span class="keyword">public</span>:</span><br><span class="line"><span class="number">18</span>                     <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">                       <span class="comment">//or const char * getName()&#123;..&#125; and default virtual</span></span><br><span class="line"><span class="number">19</span> &#125;;</span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">21</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line"><span class="number">22</span> &#123;</span><br><span class="line"><span class="number">23</span>         <span class="keyword">public</span>:</span><br><span class="line"><span class="number">24</span>                    <span class="comment">// virtual const char* getName() &#123; return "D"; &#125;</span></span><br><span class="line"><span class="number">25</span> &#125;;</span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">28 </span>&#123;</span><br><span class="line"><span class="number">29</span>             D d;</span><br><span class="line"><span class="number">30</span>             A &amp;rBase = d;</span><br><span class="line"><span class="number">31</span>             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="number">32</span> </span><br><span class="line"><span class="number">33</span>             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">34</span> &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>输出c
</code></pre><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><ul>
<li>virtual关键字是否都需要写？：<br>Only the most base class function needs to be tagged as virtual for all of the derived<br>functions to work virtually. However, having the keyword virtual on the derived functions<br>does not hurt, and it serves as a useful reminder that the function is a virtual function<br>rather than a normal one.</li>
</ul>
<ul>
<li><p>不能在构造函数和西沟函数中调用它，因为此时子类对象还没有被构造</p>
</li>
<li><p>c++11引入override和final来防止避免不匹配的复写和阻止继承：<br>１）override:<br>出现错误的例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// note: parameter is a short int</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// note: function is const</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	A &amp;rBase = b;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName1(<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName2(<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> 由于参数返回值不匹配，所以编译器认为不是复写，结果：<br> A<br>A<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">加入override:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName1</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> x)</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// compile error, function is not an override</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// compile error, function is not an override</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName3</span><span class="params">(<span class="keyword">int</span> x)</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// okay, function is an override of A::getName3(int) </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">Rule: Apply the override specifier to every intended override function you write.</span><br></pre></td></tr></table></figure></p>
<ul>
<li>final:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> 加了final的函数无法被复写：</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// note use of final specifier on following line -- that makes this function no longer overridable</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> override final </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125; <span class="comment">// okay, overrides A::getName()</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125; <span class="comment">// compile error: overrides B::getName(), which is final</span></span><br><span class="line">&#125;;</span><br><span class="line"> 加了final的类不能被继承：</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">final</span> :</span> <span class="keyword">public</span> A <span class="comment">// note use of final specifier here</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B <span class="comment">// compile error: cannot inherit from final class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> override </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> `</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>对匹配返回值的一个“例外”：covariant return types:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// This version of getThis() returns a pointer to a Base class</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Normally override functions have to return objects of the same type as the base function</span></span><br><span class="line">    <span class="comment">// However, because Derived is derived from Base, it's okay to return Derived* instead of Base*</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">getThis</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意当base=&derive;<br>     base.getThis()—-取得的任然是base</p>
<h4 id="当想基类指针指向派生类，虚函数但仍然想用基类虚函数时："><a href="#当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：" class="headerlink" title="当想基类指针指向派生类，虚函数但仍然想用基类虚函数时："></a>当想基类指针指向派生类，虚函数但仍然想用基类虚函数时：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base &amp;base = derived;</span><br><span class="line">    <span class="comment">// Calls Base::GetName() instead of the virtualized Derived::GetName()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; base.Base::getName() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="虚析构函数-："><a href="#虚析构函数-：" class="headerlink" title="虚析构函数　："></a>虚析构函数　：</h3><h4 id="为什么需要虚析构函数："><a href="#为什么需要虚析构函数：" class="headerlink" title="为什么需要虚析构函数："></a>为什么需要虚析构函数：</h4><p> 当基类指针指向派生类时，当析构后，只会调用基类的析构函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Base() <span class="comment">// note: not virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Base()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_array;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">    ~Derived() <span class="comment">// note: not virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Derived()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *derived = <span class="keyword">new</span> Derived(<span class="number">5</span>);</span><br><span class="line">    Base *base = derived ;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 只输出Calling ~Base()</p>
<ul>
<li>所以为了调用派生类的析构函数，需要定义为虚析构函数：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() <span class="comment">// note: virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Base()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_array;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        m_array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Derived() <span class="comment">// note: virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling ~Derived()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *derived = <span class="keyword">new</span> Derived(<span class="number">5</span>);</span><br><span class="line">    Base *base = derived;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Now <span class="keyword">this</span> program produces the following result:</span><br><span class="line">Calling ~Derived()</span><br><span class="line">Calling ~Base()</span><br><span class="line">Rule: Whenever you are dealing with inheritance, you should make any <span class="keyword">explicit</span> destructors <span class="keyword">virtual</span>.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="虚表："><a href="#虚表：" class="headerlink" title="虚表："></a>虚表：</h3><h4 id="Early-binding（静态绑定）-and-late-binding（动态绑定）"><a href="#Early-binding（静态绑定）-and-late-binding（动态绑定）" class="headerlink" title="Early binding（静态绑定） and late binding（动态绑定）"></a>Early binding（静态绑定） and late binding（动态绑定）</h4><p> 前者指的是直接在代码里调用函数，通过函数名，即编译期间就可以直到函数的地址的（偏移，非真实的内存地址）<br>“” Early binding (also called static binding) means the compiler (or linker) is able to directly associate the identifier name (such as a function or variable name) with a machine address.<br> Remember that all functions have a unique address. So when the compiler (or linker) encounters a function call,<br>  it replaces the function call with a machine language instruction that tells the CPU to jump to the address of the function.””<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter another number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an operation (0=add, 1=subtract, 2=multiply): "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">    &#125; <span class="keyword">while</span> (op &lt; <span class="number">0</span> || op &gt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// call the target function directly using early binding</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: result = add(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: result = subtract(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: result = multiply(x, y); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The answer is: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 后者指的是通过函数指针等方式，即在编译期间无法确定调用什么函数，需要通过指针来访问函数（函数指针），效率比前者低<br> in some programs, it is not possible to know which function will be called until runtime (when the program is run).<br> This is known as late binding (or dynamic binding). In C++, one way to get late binding is to use function pointers.<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a function pointer and make it point to the Add function</span></span><br><span class="line">    <span class="keyword">int</span> (*pFcn)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pFcn(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// add 5 + 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h4><p> 为什么虚函数能成立－－基类指针指向派生类能调用派生类的函数：<br> 实际上，在定义了虚函数的基类中维护了一个虚指针：它指向一张表，表中包含各个虚函数指针；在这个继承琏中的每一个类有自己的一张虚表，这张表由编译器在编译期间生成, 虚指针在包含虚函数的类的对象被创建时自动创建<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;; </span><br><span class="line"> 实际上为：</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FunctionPointer *__vptr;<span class="comment">//虚指针</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> base</span><br><span class="line">    *__vptr;--------------------------&gt;base vtable</span><br><span class="line">   virtual function1()&lt;----------------function1()</span><br><span class="line">|-&gt;virtual function2()&lt;----------------function2()</span><br><span class="line">-----------------------------------------------------|</span><br><span class="line">   D1:<span class="keyword">public</span> base                                    |</span><br><span class="line">   *__vptr,(inherited) ----------------D1 vtable     |</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="title">function1</span><span class="params">()</span></span>; &lt;--------------function1()   |</span><br><span class="line">                                       function2()----</span><br><span class="line"> D2类似D1</span><br></pre></td></tr></table></figure></p>
<h3 id="纯虚函数和纯虚类："><a href="#纯虚函数和纯虚类：" class="headerlink" title="纯虚函数和纯虚类："></a>纯虚函数和纯虚类：</h3><h4 id="什么是纯虚函数和纯虚类："><a href="#什么是纯虚函数和纯虚类：" class="headerlink" title="什么是纯虚函数和纯虚类："></a>什么是纯虚函数和纯虚类：</h4><ul>
<li>没有定义函数体的虚成员函数成为纯虚函数：<br>virtual int getValue() = 0; // a pure virtual function<br>包含一个或多个纯虚函数的类成为纯虚类<br>虚基类是不能被对象化的，当对象化后调用纯虚函数，就会出现错误  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base; <span class="comment">// We can't instantiate an abstract base class, but for the sake of example, pretend this was allowed</span></span><br><span class="line">    base.getValue(); <span class="comment">// what would this do?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="为什么需要纯虚函数和纯虚类？"><a href="#为什么需要纯虚函数和纯虚类？" class="headerlink" title="为什么需要纯虚函数和纯虚类？"></a>为什么需要纯虚函数和纯虚类？</h4><p>当子类继承了基类后，对虚函数来讲，需要复写基类的虚函数，而当忘记去写时，默认就会调用基类的虚函数；<br>而如果将基类的虚函数定义为纯虚函数。就会通过编译报错来提醒我们要复写子类的虚函数：<br> 例子：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> // <span class="title">This</span> <span class="title">Animal</span> <span class="title">is</span> <span class="title">an</span> <span class="title">abstract</span> <span class="title">base</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// note that speak is now a pure virtual function</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cow(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We forgot to redefine speak</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">cow</span><span class="params">(<span class="string">"Betsy"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cow.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cow(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Moo"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">cow</span><span class="params">(<span class="string">"Betsy"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cow.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; cow.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当想要使用虚基类的实现时，又同时想让虚基类不能对象化且子类能提示需要实现纯虚函数时，应该怎么做？<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> // <span class="title">This</span> <span class="title">Animal</span> <span class="title">is</span> <span class="title">an</span> <span class="title">abstract</span> <span class="title">base</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// note that speak is a pure virtual function</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* Animal::speak()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"buzz"</span>; <span class="comment">// some default implementation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dragonfly</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dragonfly(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : Animal(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">speak</span><span class="params">()</span> <span class="comment">// this class is no longer abstract because we defined this function</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Animal::speak(); <span class="comment">// use Animal's default implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Dragonfly <span class="title">dfly</span><span class="params">(<span class="string">"Sally"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dfly.getName() &lt;&lt; <span class="string">" says "</span> &lt;&lt; dfly.speak() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">The above code prints:</span><br><span class="line">Sally says buzz</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="接口类："><a href="#接口类：" class="headerlink" title="接口类："></a>接口类：</h4><p>接口类的类中没有成员变量。全部由纯虚函数构成；常命名为I开头的:如IErrorLog,类似于java中的接口<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IErrorLog</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">openLog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">closeLog</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">writeError</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *errorMessage)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~IErrorLog() &#123;&#125;; <span class="comment">// make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="virtual-base-class"><a href="#virtual-base-class" class="headerlink" title="virtual base class"></a>virtual base class</h4><p>当普通的继承，即一个子类继承自两个不同的父类，这两个父类继承自同一个基类时。就容易出现问题：<br>如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PoweredDevice(<span class="keyword">int</span> power)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"PoweredDevice: "</span> &lt;&lt; power &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Scanner(<span class="keyword">int</span> scanner, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Scanner: "</span> &lt;&lt; scanner &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Printer(<span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Printer: "</span> &lt;&lt; printer &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Copier(<span class="keyword">int</span> scanner, <span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : Scanner(scanner, power), Printer(printer, power)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Copier <span class="title">copier</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">PoweredDevice: <span class="number">3</span></span><br><span class="line">Scanner: <span class="number">1</span></span><br><span class="line">PoweredDevice: <span class="number">3</span></span><br><span class="line">Printer: <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>从输出看，基类被构造了两次<br>如何防止构造两个基类呢？使用virtual base class<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PoweredDevice(<span class="keyword">int</span> power)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PoweredDevice: "</span> &lt;&lt; power &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice <span class="comment">// note: PoweredDevice is now a virtual base class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Scanner(<span class="keyword">int</span> scanner, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power) <span class="comment">// this line is required to create Scanner objects, but ignored in this case</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Scanner: "</span> &lt;&lt; scanner &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> PoweredDevice <span class="comment">// note: PoweredDevice is now a virtual base class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Printer(<span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : PoweredDevice(power) <span class="comment">// this line is required to create Printer objects, but ignored in this case</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Printer: "</span> &lt;&lt; printer &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> <span class="keyword">public</span> Scanner, <span class="keyword">public</span> Printer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Copier(<span class="keyword">int</span> scanner, <span class="keyword">int</span> printer, <span class="keyword">int</span> power)</span><br><span class="line">        : Scanner(scanner, power), Printer(printer, power),</span><br><span class="line">        PoweredDevice(power) <span class="comment">// PoweredDevice is constructed here</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">This time, our previous example:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Copier <span class="title">copier</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">produces the result:</span><br><span class="line">PoweredDevice: <span class="number">3</span></span><br><span class="line">Scanner: <span class="number">1</span></span><br><span class="line">Printer: <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>这样的话，基类的构造交给了继承琏最底层的类</p>
<ul>
<li>注意：</li>
<li>virtual base class在子类对象之前就创建了</li>
<li>if Copier was singly inherited from Printer, and Printer was virtually inherited from PoweredDevice, Copier is still responsible for creating PoweredDevice</li>
<li>Fourth, a virtual base class is always considered a direct base of its most derived class<br>(which is why the most derived class is responsible for its construction).</li>
<li>But classes inheriting the virtual base still need access to it. So in order to facilitate this, the compiler creates a virtual table for each class directly inheriting the virtual class (Printer and Scanner). These virtual tables point to the functions in the most derived class. Because the derived classes have a virtual table,  that also means they are now larger by a pointer (to the virtual table).</li>
</ul>
<h4 id="对象分割："><a href="#对象分割：" class="headerlink" title="对象分割："></a>对象分割：</h4><p>当子类对象赋值给基类会发生什么？<br>子类对象的基类部分会给基类对象<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    Base base = derived; <span class="comment">// what happens here?</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base is a "</span> &lt;&lt; base.getName() &lt;&lt; <span class="string">" and has value "</span> &lt;&lt; base.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">传值给基类</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">(<span class="keyword">const</span> Base base)</span> <span class="comment">// note: base passed by value, not reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; base.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">This is a pretty simple function with a <span class="keyword">const</span> base object parameter that is passed by value. If we call <span class="keyword">this</span> function like such:	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    printName(d); <span class="comment">// oops, didn't realize this was pass by value on the calling end </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>vector<base>和vector&lt;&amp;base&gt;和vector&lt;base*&gt;<br>第一种可以但是只能调用基类的部分<br>第二种不行：std::vector&lt;Base&amp;&gt; v;<br>Unfortunately, this won’t compile. The elements of std::vector must be assignable, whereas references can’t be reassigned (only initialized).<br>第三种可以但是要做delete<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Base*&gt; v;</span><br><span class="line">	v.push_back(<span class="keyword">new</span> Base(<span class="number">5</span>)); <span class="comment">// add a Base object to our vector</span></span><br><span class="line">	v.push_back(<span class="keyword">new</span> Derived(<span class="number">6</span>)); <span class="comment">// add a Derived object to our vector</span></span><br><span class="line">        <span class="comment">// Print out all of the elements in our vector</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; v.size(); ++count)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; v[count]-&gt;getName() &lt;&lt; <span class="string">" with value "</span> &lt;&lt; v[count]-&gt;getValue() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; v.size(); ++count)</span><br><span class="line">		<span class="keyword">delete</span> v[count];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">用智能指针可以避免：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; // for std::reference_wrapper</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::reference_wrapper&lt;Base&gt; &gt; v; <span class="comment">// our vector is a vector of std::reference_wrapper wrapped Base (not Base&amp;)</span></span><br><span class="line">	<span class="function">Base <span class="title">b</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// b and d can't be anonymous objects</span></span><br><span class="line">	<span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">	v.push_back(b); <span class="comment">// add a Base object to our vector</span></span><br><span class="line">	v.push_back(d); <span class="comment">// add a Derived object to our vector</span></span><br><span class="line">	<span class="comment">// Print out all of the elements in our vector</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; v.size(); ++count)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a "</span> &lt;&lt; v[count].get().getName() &lt;&lt; <span class="string">" with value "</span> &lt;&lt; v[count].get().getValue() &lt;&lt; <span class="string">"\n"</span>; <span class="comment">// we use .get() to get our element from the wrapper</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一种极端情况：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Derived <span class="title">d2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    Base &amp;b = d2;<span class="comment">//b为d2的引用</span></span><br><span class="line">    b = d1; <span class="comment">// this line is problematic　导致b的基类部分为d1,子类部分为d2,因为b是d2的引用，导致现在d2的基类部分是d1而子类部分是d2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="总结多态的方式＋dynamic-cast"><a href="#总结多态的方式＋dynamic-cast" class="headerlink" title="总结多态的方式＋dynamic_cast:"></a>总结多态的方式＋dynamic_cast:</h4><ul>
<li><p>　shape <em>ps=new circle();<br>  经由virtual func:  ps-&gt;rotate()    //virtual func<br>  经由dynamic_cast:和type运算符：<br>  if(circle </em>pc=dynamic_cast&lt;circle*&gt;(ps))</p>
<p>  (理解了指针类型的本质就可以理解它和理解分割的内容了:指针的类型会教导编译器如何解释某个特定地址的内容和大小:<br>  所以一个void*的指针无法去确定涵盖多大的地址空间，所以它只能含有一个地址但是不能操作它指向的Ｏｂｊｅｃｔ<br>  所以转型只是一种编译器指令，不改变真正的地址，而是改变解读指针的方式让它指出其内存的大小和内容）<br>  更多见内存布局第一章图就能理解）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_inheritance</title>
    <url>/2018/06/08/cpp-inheritance/</url>
    <content><![CDATA[<h3 id="c-继承："><a href="#c-继承：" class="headerlink" title="c++ 继承："></a>c++ 继承：</h3><h4 id="继承是什么能做什么"><a href="#继承是什么能做什么" class="headerlink" title="继承是什么能做什么"></a>继承是什么能做什么</h4><p>继承是创建复杂类的另一种方式，它展现出来俩个obj 的is-a的概念（前一种方式是加入复杂的函数和成员等has-a　概念）<br>继承体现的是两个对象（类）之间的联系，子类继承父类的成员和方法，然后特殊化于扩展自己的成员和方法，正如苹果和梨都是水果，它们拥有水果的一般特性，等边三角形是特殊的等腰三角形<a id="more"></a><br>几个概念引英文词： the class being inherited from is called the parent class, base class, or superclass, and the class doing the inheriting is called the child class, derived class, or subclass.</p>
<h4 id="继承怎么使用，分为什么"><a href="#继承怎么使用，分为什么" class="headerlink" title="继承怎么使用，分为什么"></a>继承怎么使用，分为什么</h4><p>继承的使用通过例子来学习，分为单继承和多继承等<br>多继承的问题：<br>１）两个基类中存在相同的方法，子类调用该方法－－－》解决，可以调用的方法前加上类限定符base::<br>2)俩个类继承自同一个类，接着另一个类继承这两个类<br>懒得自己写，从learncpp拷贝<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure></p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"> </span><br><span class="line">    Person(<span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">""</span>, <span class="keyword">int</span> age = <span class="number">0</span>)</span><br><span class="line">        : m_name(name), m_age(age)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_age; &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// BaseballPlayer publicly inheriting Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseballPlayer</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_battingAverage;</span><br><span class="line">    <span class="keyword">int</span> m_homeRuns;</span><br><span class="line"> </span><br><span class="line">    BaseballPlayer(<span class="keyword">double</span> battingAverage = <span class="number">0.0</span>, <span class="keyword">int</span> homeRuns = <span class="number">0</span>)</span><br><span class="line">       : m_battingAverage(battingAverage), m_homeRuns(homeRuns)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a new BaseballPlayer object</span></span><br><span class="line">    BaseballPlayer joe;</span><br><span class="line">    <span class="comment">// Assign it a name (we can do this directly because m_name is public)</span></span><br><span class="line">    joe.m_name = <span class="string">"Joe"</span>;</span><br><span class="line">    <span class="comment">// Print out the name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; joe.getName() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// use the getName() function we've acquired from the Person base class</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承的方式，访问控制"><a href="#继承的方式，访问控制" class="headerlink" title="继承的方式，访问控制"></a>继承的方式，访问控制</h4><p>A child class inherits both behaviors (member functions) and properties (member variables) from the parent 但是受继承方式的限制<br>继承的方式有public等，受限制，这种可以通俗的理解为，你和你妈，你姨妈，你表舅等的亲密度和能访问的内容是有等级差别的</p>
<table>
<thead>
<tr>
<th style="text-align:left">Access specifier in base class</th>
<th style="text-align:left">when inherited publicly</th>
<th style="text-align:left">when　inherited privately</th>
<th style="text-align:left">when inherited protectedly</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Public</td>
<td style="text-align:left">Public</td>
<td style="text-align:left">Private</td>
<td style="text-align:left">Protected</td>
</tr>
<tr>
<td style="text-align:left">Private</td>
<td style="text-align:left">Inaccessible</td>
<td style="text-align:left">Inaccessible</td>
<td style="text-align:left">Inaccessible</td>
</tr>
<tr>
<td style="text-align:left">Protected</td>
<td style="text-align:left">Protected</td>
<td style="text-align:left">Private</td>
<td style="text-align:left">Protected</td>
</tr>
</tbody>
</table>
<h4 id="继承的内存"><a href="#继承的内存" class="headerlink" title="继承的内存"></a>继承的内存</h4><ul>
<li>对单纯的类对象来说，没有继承时，其对象内存是成员变量，存储在栈中<br>，当继承了基类后，基类的成员变量（即使是private不能访问的）会添加到子类的对象内存中，而且一般是放在低地址（前面）<br>对访问控制是在编译期间去做限制的</li>
</ul>
<h4 id="编译器对继承做了什么？"><a href="#编译器对继承做了什么？" class="headerlink" title="编译器对继承做了什么？"></a>编译器对继承做了什么？</h4><ul>
<li>构造函数  </li>
<li>首先，构造函数顺序：Because Derived inherits functions and variables from Base,<br>you may assume that the members of Base are copied into Derived.<br>However, this is not true. Instead, we can consider Derived as a two part class:<br>one part Derived, and one part Base.<br>，从构造函数可以看出，继承的类，对象先调用继承连最上层的类构造函数，最后调用它自己的构造函数</li>
<li>其次，基类构造函数被子类调用：//弥补了子类不能　初始化父类成员的缺陷－－－为什么子类不能在初始化队列中初始化父类成员？若为const就出错了，初始化两次</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// our member is now private</span></span><br><span class="line">    <span class="keyword">double</span> m_cost;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">double</span> cost=<span class="number">0.0</span>, <span class="keyword">int</span> id=<span class="number">0</span>)</span><br><span class="line">        : Base(id), <span class="comment">// Call Base(int) constructor with value id!</span></span><br><span class="line">            m_cost(cost)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>析构函数：调用顺序和构造函数相反</li>
<li><p>子类加入自己的函数和ovrridewirte父类函数  </p>
<ul>
<li><p>策略：<br>When a member function is called with a derived class object,<br>the compiler first looks to see if that member exists in the derived class.<br>If not, it begins walking up the inheritance chain and checking whether the member<br>has been defined in any of the parent classes. It uses the first one it finds.</p>
</li>
<li><p>在父类中被声明为private 的函数经过子类重写后可能会变成public:  </p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derived derived;</span><br><span class="line">	derived.print(); <span class="comment">// calls derived::print(), which is public</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>保留父类函数的方法:</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> value)</span><br><span class="line">        : m_value(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identify</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a Base\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base::identify(); <span class="comment">// call Base::identify() first</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a Derived\n"</span>; <span class="comment">// then identify ourselves</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>c++11新：<br>将base类中的保护函数，在子类中声明为public:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> value)</span><br><span class="line">        : m_value(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> value)</span><br><span class="line">        : Base(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Base::printValue was inherited as protected, so the public has no access</span></span><br><span class="line">    <span class="comment">// But we're changing it to public via a using declaration</span></span><br><span class="line">    <span class="keyword">using</span> Base::printValue; <span class="comment">// note: no parenthesis here  //c++11</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// printValue is public in Derived, so this is okay</span></span><br><span class="line">    derived.printValue(); <span class="comment">// prints 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类中将父类的方法隐藏：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Base(<span class="keyword">int</span> value)</span><br><span class="line">		: m_value(value)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Derived(<span class="keyword">int</span> value)</span><br><span class="line">		: Base(value)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>= <span class="keyword">delete</span>; <span class="comment">// mark this function as inaccessible</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Derived <span class="title">derived</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// The following won't work because getValue() has been deleted!</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; derived.getValue();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_conandde</title>
    <url>/2018/06/08/cpp-conandde/</url>
    <content><![CDATA[<h2 id="c-class-constructor-and-destructor"><a href="#c-class-constructor-and-destructor" class="headerlink" title="c++ class constructor and destructor"></a>c++ class constructor and destructor</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="构造函数表现"><a href="#构造函数表现" class="headerlink" title="构造函数表现"></a>构造函数表现</h4><h5 id="构造函数的作用："><a href="#构造函数的作用：" class="headerlink" title="构造函数的作用："></a>构造函数的作用：</h5><p>构造函数主要是用来初始化对象的－－－一般是成员，函数不用<br>–所以它需要在构建对象时就执行<a id="more"></a></p>
<h5 id="构造函数如何写："><a href="#构造函数如何写：" class="headerlink" title="构造函数如何写："></a>构造函数如何写：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:　classname(arg...):member(arg),mem2(arg),..&#123;xxx&#125;</span><br><span class="line">    classname(..)&#123;..&#125;</span><br><span class="line">```        </span><br><span class="line">##### 默认构造函数的生成规则（深入对象模型）</span><br><span class="line">+ 下面四个情况下会生成默认构造函数（编译器控制）(nontrivial <span class="keyword">default</span> constructor)  </span><br><span class="line"> + 带有<span class="keyword">default</span> constructor的member <span class="class"><span class="keyword">class</span> <span class="title">object</span>  </span></span><br><span class="line"><span class="class"> 即在类中带有对象成员，该对象成员所属的类有构造函数</span></span><br><span class="line"><span class="class">如：　</span></span><br><span class="line"><span class="class">```<span class="title">cpp</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Foo</span> &#123;</span><span class="keyword">public</span> :Foo(),Foo(<span class="keyword">int</span>)...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span><span class="keyword">public</span>:Foo foo;<span class="keyword">char</span> *str&#125;;</span><br><span class="line">                          <span class="function"><span class="keyword">void</span> <span class="title">funv</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                          </span>&#123;   Bar bar;....</span><br><span class="line">                          &#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下若程序员没有实现构造函数，则编译器会自己生成构造函数，来调用Foo的构造函数<br>但是不初始化str,这个得由程序员来做。<br>如类似于：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Bar::Bar()&#123;</span><br><span class="line">   foo.Foo::Foo();</span><br><span class="line"> ```                  </span><br><span class="line"> 若程序员自己写了构造函数但是不包括初始化foo则，编译器会在程序眼写的构造函数中加入上述，另外若有多个对象</span><br><span class="line">则按照声明顺序进行调用他们的构造函数；</span><br><span class="line"> + 带有Default constructor 的base <span class="class"><span class="keyword">class</span>  </span></span><br><span class="line"><span class="class"> 同理，当继承的基类带有构造函数时就会加入，若程序员的构造函数没有初始化他们时就会扩展  </span></span><br><span class="line"><span class="class">//以上见例子<span class="title">class_constructor</span>.<span class="title">cpp</span>，</span></span><br><span class="line"><span class="class"> + 和<span class="title">vcirtual</span>相关<span class="title">need</span> <span class="title">to</span> <span class="title">create</span> <span class="title">vptr</span>  </span></span><br><span class="line"><span class="class">    带有一个<span class="title">virtual</span>　<span class="title">func</span>的<span class="title">class</span>  </span></span><br><span class="line"><span class="class">     1)<span class="title">class</span>　声明或继承一个<span class="title">virtua</span> <span class="title">func</span>  </span></span><br><span class="line"><span class="class">     2)<span class="title">class</span>派生自一个继承琏，其中有<span class="title">virtual</span> <span class="title">base</span> <span class="title">classes</span>       这个比较容易理解</span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class"> + 和<span class="title">virtual</span>相关 <span class="title">need</span> <span class="title">to</span> <span class="title">init</span> <span class="title">vptr</span></span></span><br><span class="line"><span class="class">   带有一个<span class="title">virtual</span>　<span class="title">base</span> <span class="title">class</span> 的<span class="title">class</span>  </span></span><br><span class="line"><span class="class">   如：</span></span><br><span class="line"><span class="class">   ```<span class="title">cpp</span></span></span><br><span class="line"><span class="class">       <span class="title">class</span> <span class="title">X</span>&#123;</span>  <span class="keyword">public</span> <span class="keyword">int</span> i;&#125;  </span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="comment">///</span></span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A,<span class="keyword">public</span> B</span><br></pre></td></tr></table></figure></p>
<h5 id="构造函数何时被执行"><a href="#构造函数何时被执行" class="headerlink" title="构造函数何时被执行"></a>构造函数何时被执行</h5><p>-在对象定义时若有构造函数，则会执行</p>
<h5 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h5><p>1:5构造函数的使用：重载，初始化式</p>
<h4 id="构造函数表现的原理"><a href="#构造函数表现的原理" class="headerlink" title="构造函数表现的原理"></a>构造函数表现的原理</h4><h5 id="构造函数在静态代码块中的位置和符号体现"><a href="#构造函数在静态代码块中的位置和符号体现" class="headerlink" title="构造函数在静态代码块中的位置和符号体现"></a>构造函数在静态代码块中的位置和符号体现</h5><p>如果有定义构造函数，它本身也是一个函数，放在代码段中，可以通过kdbg查看<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">origin(<span class="keyword">int</span> ax=<span class="number">3</span>,<span class="keyword">int</span> bx=<span class="number">4</span>):a(ax),b(bx)&#123;&#125;</span><br><span class="line"><span class="number">0x400bae</span> push   %rbp</span><br><span class="line"><span class="number">0x400baf</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x400bb2</span> mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line"><span class="number">0x400bb6</span> mov    %esi,<span class="number">-0xc</span>(%rbp)</span><br><span class="line"><span class="number">0x400bb9</span> mov    %edx,<span class="number">-0x10</span>(%rbp)</span><br></pre></td></tr></table></figure></p>
<h5 id="构造函数在动态执行时，放在哪个内存段中，如何被引用，使用"><a href="#构造函数在动态执行时，放在哪个内存段中，如何被引用，使用" class="headerlink" title="构造函数在动态执行时，放在哪个内存段中，如何被引用，使用"></a>构造函数在动态执行时，放在哪个内存段中，如何被引用，使用</h5><ul>
<li>动态执行时，在代码段中，通过this引用</li>
<li>构造函数总结：任何c++ class只有在以上四中情况下才会产生默认构造函数，且产生的默认构造函数不会去初始化成员的值<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><h4 id="拷贝的动作发生了什么"><a href="#拷贝的动作发生了什么" class="headerlink" title="拷贝的动作发生了什么"></a>拷贝的动作发生了什么</h4>拷贝的本质，为什么需要拷贝构造函数？</li>
<li>首先对基本的类型而言，拷贝是把值赋给另一个同类型的变量，而数租不能做=赋值拷贝</li>
<li>对对象而言，也是把值赋给同类型的对象，而不是共享一个指针，所以这个过程需要将对象中的成员也复制过去（复制的是当前对象在此时时成员的值　）</li>
<li>c++中的拷贝构造函数针对三种行为：＝　，f(T t)和　f(){T t;return t}返回对象－－这三种情况都针对左值的　　　</li>
<li>=:注意这个是在定义时做的，如origin or1=or2;此时会调用”拷贝构造函数”（　同or1(or2))<br>　or2=or3;此时不会调用拷贝构造函数<br>（当程序员自己写了拷贝构造函数时，默认调用该构造函数，而不会区做成员复制，所以若在其中没有做复制，可能得到不想要的值，见例子)</li>
</ul>
<h4 id="拷贝构造函数的作用和使用"><a href="#拷贝构造函数的作用和使用" class="headerlink" title="拷贝构造函数的作用和使用"></a>拷贝构造函数的作用和使用</h4><h5 id="什么情况下会生成默认的拷贝构造函数？"><a href="#什么情况下会生成默认的拷贝构造函数？" class="headerlink" title="什么情况下会生成默认的拷贝构造函数？"></a>什么情况下会生成默认的拷贝构造函数？</h5><p>类似于构造函数，在以下情形会生成默认的拷贝构造函数－</p>
<ul>
<li>当需要调用别的拷贝构造函数时，如：当类内含有一个member object而后者的class声明有一个copy　constructor时；</li>
<li>当类继承自一个base class而后者有拷贝构造函数</li>
<li>当类声明了一个或多个virtual functions时</li>
<li>当class 派生自一个继承　串琏，而其中有一个或多个virtual base classes 时</li>
</ul>
<h4 id="拷贝构造函数和编译器－－－汇编，转换："><a href="#拷贝构造函数和编译器－－－汇编，转换：" class="headerlink" title="拷贝构造函数和编译器－－－汇编，转换："></a>拷贝构造函数和编译器－－－汇编，转换：</h4><p>分三种情况讨论：</p>
<ul>
<li><p>初始化拷贝构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;</span><br><span class="line">X x2=x0;</span><br><span class="line">X x3=X(x0);</span><br></pre></td></tr></table></figure>
<p> 上述三种都是定义一个类，即定义的本质会在内存中开辟空间<br>上述三个都会执行拷贝构造函数，如何执行？<br>会被转换为：伪代码</p>
<pre><code>X x1;
x1.X::X(x0);
会调用X::X(const X&amp; xx) 
x2,x3也是这样，将拷贝方作为函数参数传入
这样就可以解释为什么拷贝构造函数的定义是      
classname (const classname &amp;obj)
</code></pre></li>
<li>参数的初始化<br>即传入一个参数给函数：<pre><code>foo(X x)
</code></pre>如：<pre><code>X xx;
//,..
foo(xx);
则会产生一个临时的对象：
</code></pre>伪代码<pre><code>X __temp0;
_temp0.X::X(xx);//use copy construtor
 foo(__temp0)
</code></pre>这里因为它是临时的，所以则定义的时候需要用引用foo(X &amp;x)//这里不是很清楚为什么用引用～！，是否后面的操作直接面向该对象，需要做实际的修改，所以。。<br>所以，为了对付临时的对象，在执行完函数后，需要调用该对象的析构函数</li>
<li>返回值的初始化：<br>如<pre><code>X bar(){
               X xx;
                //...
                return xx;
     }
  如何做X xxx=bar();如何拷贝的？双阶段初始化：
  a 增加一个额外的引用参数给函数，如void bar(X＆　_result)
  b 在return 前插入一个copy constructor 
      void bar(X &amp;__result){
                X xx;
                xx.X::X();
                __result.X::XX(xx);
                return ;
        }
 所以上述会被转化为：
 Ｘ　xx=bar()  ---&gt;  X xx ;//注意这里不会执行默认构造函数　　bar(xx);
     ex:bar().memfunc()---&gt;X __temp0;(bar(__temp0),__temp0).memfunc();
     X (*pf)();pf=bar;---&gt;void (*pf)(X&amp;);pf=bar;
</code></pre></li>
</ul>
<h5 id="关于上述三种情况的优化："><a href="#关于上述三种情况的优化：" class="headerlink" title="关于上述三种情况的优化："></a>关于上述三种情况的优化：</h5><p>１)在使用者层面上优化；２）在编译器层面的优化（ＮＲＶ）具体见深入模型（书）</p>
<h5 id="关于该不该编写copy-constructor"><a href="#关于该不该编写copy-constructor" class="headerlink" title="关于该不该编写copy  constructor:"></a>关于该不该编写copy  constructor:</h5><p>除非需要大量的memberwise 初始化操作，如传值给object以便做NRV优化，否则不需要<br>//上述情况的检验可以通过代码，或者去看编译器的生成代码～    </p>
<h5 id="拷贝构造函数的内存"><a href="#拷贝构造函数的内存" class="headerlink" title="拷贝构造函数的内存"></a>拷贝构造函数的内存</h5><p>放在代码段，</p>
<h3 id="初始化队列"><a href="#初始化队列" class="headerlink" title="初始化队列"></a>初始化队列</h3><p>即构造函数的一种形式如：X(int f):a(ax),b(bx)..{….}</p>
<ul>
<li><p>问题：什么时候用初始化列表？它和初始化赋值有什么不同？</p>
<pre><code>有以下四种情况需要使用初始化列表：
１）当初始化一个reference member时
２）当初始化一个const member时
３）当调用一个base class的constructor,当它拥有一组参数时
４）当调用一个member　class 的consructor，而它有一组参数时；
</code></pre><p>如<br><code></code>cpp<br> class world {</p>
<pre><code>String _nhame;
int cnt;
public :world(){_nhame=0;cnt=0;}}<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时，对_nhame这个成员，需要做较多的事，如产生临时对像，调用operator=....</span></span><br><span class="line">   －－－－所以想到用初始化列表：</span><br><span class="line">```cpp </span><br><span class="line">          world::world:nhame(<span class="number">0</span>)&#123;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            这样只会调用nhame的构造函数</span><br><span class="line">            会被转换为：world::world&#123; <span class="comment">//伪代码</span></span><br><span class="line">             _nhame.String::String(<span class="number">0</span>);</span><br><span class="line">              cnt=<span class="number">0</span>;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
<li><p>更具体的，初始化列表如何进行：顺序如何：如前，初始化列表最终会被转换为初始化表达式到构造函数体中，那是什么顺序呢？<br>注意这里的初始化顺序是根据成员在类中的定义（声明）顺序来的，而不是初始化列表中的顺序<br>看这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">             <span class="keyword">int</span> i; </span><br><span class="line">             <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">              X(<span class="keyword">int</span> cal):i(j)&#123;&#125;</span><br><span class="line">              ...</span><br><span class="line">              此时，因为i先初始化,再j,出错，i需要j</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  —-&gt;可以改善为：X::X(int cal):j(cal){i=j;}<br>   —-为什么这样可以？<br>   因为初始化列表的内容会放到初始化体中的表达式前面，这样j就会先定义<br>        －－－－》另一个可能出错的例子：<br>        　　　X::X(int cal):i(xfoo(cal)),j(cal){}<br>        –&gt;转换为：X::X(/<em>this pointer</em>/ int cal){<br>                      i=this-&gt;xfoo(cal);<br>                      j=cal;<br>                      }<br>            这个情况在这里是对的，但是当X 继承自某个类，在xfoo是基类的函数，，则会出错this-&gt;xfoo</p>
<h4 id="几个问题："><a href="#几个问题：" class="headerlink" title="几个问题："></a>几个问题：</h4><ul>
<li>较为简单的例子见文件中的例子</li>
<li>当程序员定义了拷贝构造函数时，还会执行memberwise initialization吗　－－会执行拷贝构造函数<br>参考：深入c++对象模型和<a href="http://en.cppreference.com/w/cpp/language/copy_constructor" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/language/copy_constructor</a></li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_class</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_class_memory</title>
    <url>/2018/06/08/cpp-class-memory/</url>
    <content><![CDATA[<h3 id="c-类内存布局："><a href="#c-类内存布局：" class="headerlink" title="c++类内存布局："></a>c++类内存布局：</h3><h4 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h4><p>下编译后的“内存布局”，此时还未分配内存，不能算是内存，只能说是文件布局<a id="more"></a></p>
<ul>
<li>two question:<br>多少内存能表现一个ob:?<br>多少内存能表现一个class?–编译期，如　int 大小为４ </li>
<li>静态下，编译后同C一样分为代码段等；而类的特性有些类似于struct,定义类的文件中包含了成员变量，成员函数。</li>
<li>类：<pre><code>非静态成员变量：存于对象中
vptr指针：存于对象中
vt表:vptr指向这个表，这个表在构造函数中默认隐士初始化，将对应的虚拟函数地址赋给表中的各个值（表本身with&quot;类&quot;）
obj:         class:
_vptr ---&gt;   table: ptr1 --&gt;virtual func1
                    ptr2 --&gt;virtual func2
静态变量: 存入数据段中
成员函数:代码段,通过this和成员变量建立联系
静态函数：　存于代码段中
全局函数
main函数
全局变量和静态变量
局部变量：栈
something extra depend on compiler~
</code></pre></li>
<li>some rules<ul>
<li>每个类产生一堆指向virtual func的指针，放在表格中，表称为：vtbl;   </li>
<li>每个obj被添加了一个指针，指向相关的tirtual table ,为vptr;</li>
<li>vptr的设定和重置由constructor，destructor,copy assignment运算服自动完成）　</li>
<li>注意每一个class所关联的type info object(用于支持runtime type identification  )也经由virtual table指出，放在vptr[0]处）</li>
<li>虚函数有可能被转换为：(*px-&gt;vtbl[1])(px)<pre><code>具体见深入c++模型书
</code></pre></li>
</ul>
</li>
</ul>
<h4 id="多少内存能表现一个ob"><a href="#多少内存能表现一个ob" class="headerlink" title="多少内存能表现一个ob:?"></a>多少内存能表现一个ob:?</h4><ul>
<li>non static data members</li>
<li>padding</li>
<li>virtual—vptr<h4 id="多少内存能表现一个class"><a href="#多少内存能表现一个class" class="headerlink" title="多少内存能表现一个class?"></a>多少内存能表现一个class?</h4>见datamember_memory  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">最小是１　  size  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span> &#125;;   --<span class="number">-1</span> 一个<span class="keyword">char</span> 表示这个类型  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;　　--指针大小，指针指向T    <span class="keyword">virtual</span> base <span class="class"><span class="keyword">class</span> <span class="title">subobject</span>  </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Y</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;  --指针大小</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> X,<span class="keyword">public</span> Y &#123;&#125;;　--两个指针大小</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>more seee datamember_memory</p>
<h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4><p>的内存布局，即作为进程运行时，其内存是如何的；</p>
<ul>
<li>运行时，涉及类的对象模型，对象的内存部分只包含非静态成员变量和虚拟函数指针表；</li>
<li>可以通过gdb 或kgdb进行查看类对象的地址或者类函数的地址：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	Circle c12;</span><br><span class="line">		<span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">1.2</span>,<span class="string">"red"</span>)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"getRadius:%x\n"</span>,&amp;Circle::getRadius);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x, %x\n"</span>,&amp;c12,c12);</span><br><span class="line"> <span class="keyword">void</span> *cc;</span><br><span class="line">        cc=(Circle*)(&amp;c12);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;*((<span class="keyword">double</span>*)cc)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">```		</span><br><span class="line">    		</span><br><span class="line">所以c++的对象带来的开销在于操作多态时的vptr等效率低）		</span><br><span class="line"></span><br><span class="line">一个例子</span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line">					<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line">					<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line">					<span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">6</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">public</span>:</span><br><span class="line">				    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"D"</span>; &#125;</span><br><span class="line"><span class="number">0x400ae8</span> push   %rbp</span><br><span class="line"><span class="number">0x400ae9</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x400aec</span> mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">					<span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">8</span>;&#125;</span><br><span class="line"><span class="number">0x400af8</span> push   %rbp</span><br><span class="line"><span class="number">0x400af9</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x400afc</span> mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">		    A aa;</span><br><span class="line">			aa.getName();</span><br><span class="line">		    D d;</span><br><span class="line">			d.getName();</span><br><span class="line">			A &amp;rBase = d;</span><br><span class="line">			rBase.getName();</span><br><span class="line"><span class="number">0x400986</span> mov    <span class="number">-0x28</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x40098a</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x40098d</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x400990</span> mov    <span class="number">-0x28</span>(%rbp),%rdx</span><br><span class="line"><span class="number">0x400994</span> mov    %rdx,%rdi</span><br><span class="line"><span class="number">0x400997</span> callq  *%rax</span><br><span class="line">            rBase.getage();</span><br><span class="line"><span class="number">0x400999</span> mov    <span class="number">-0x28</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x40099d</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x4009a0</span> add    $<span class="number">0x8</span>,%rax</span><br><span class="line"><span class="number">0x4009a4</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x4009a7</span> mov    <span class="number">-0x28</span>(%rbp),%rdx</span><br><span class="line"><span class="number">0x4009ab</span> mov    %rdx,%rdi</span><br><span class="line"><span class="number">0x4009ae</span> callq  *%rax</span><br><span class="line">		    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">					 </span><br><span class="line">			D d2;</span><br><span class="line">            A &amp;rBase2 =d2;</span><br><span class="line"><span class="number">0x4009f9</span> lea    <span class="number">-0x30</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x4009fd</span> mov    %rax,<span class="number">-0x20</span>(%rbp)</span><br><span class="line">		   rBase2.getName();	</span><br><span class="line"><span class="number">0x400a01</span> mov    <span class="number">-0x20</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a05</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x400a08</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x400a0b</span> mov    <span class="number">-0x20</span>(%rbp),%rdx</span><br><span class="line"><span class="number">0x400a0f</span> mov    %rdx,%rdi</span><br><span class="line"><span class="number">0x400a12</span> callq  *%rax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>something else:  </p>
<ul>
<li>成员函数也是只有一份被存于代码区中，而对象并没有指向成员函数的指针，对象只存成员和虚拟表　；那在对象.成员函数使用时，</li>
<li>是如何确定该函数中使用的成员是该对象的成员?<br>这里是this指针的作用<br>从汇编看，是否是成员函数在取的成员变量时，会做一些动作，这时的成员变量是在栈区；；<br>或者从调用成员函数时，是否有传入或控制函数的一些动作，让它知道从哪里取得对应的成员返回；</li>
<li>成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_this</title>
    <url>/2018/06/08/cpp-this/</url>
    <content><![CDATA[<h3 id="c-关键字之this"><a href="#c-关键字之this" class="headerlink" title="c++关键字之this"></a>c++关键字之this</h3><h4 id="this指针是什么"><a href="#this指针是什么" class="headerlink" title="this指针是什么"></a>this指针是什么</h4><p>this是一个指向当前正在使用的对象的指针，它是一个指针；<br>成员函数通过它来使用对象的值，通过它知道要对哪个对象的成员操作<br>如：<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Simple(<span class="keyword">int</span> id)</span><br><span class="line">    &#123;</span><br><span class="line">        setID(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; m_id = id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Simple <span class="title">simple</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    simple.setID(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; simple.getID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">simple.setID(<span class="number">2</span>);---&gt;</span><br><span class="line">setID(&amp;simple, <span class="number">2</span>); <span class="comment">// note that simple has been changed from an object prefix to a function argument!</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; m_id = id; &#125;---&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(Simple* <span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">int</span> id)</span> </span>&#123; <span class="keyword">this</span>-&gt;m_id = id; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="this指针用法"><a href="#this指针用法" class="headerlink" title="this指针用法"></a>this指针用法</h4><p>关键词 this 是一个纯右值表达式，其值是在调用成员函数时的对象地址。它能出现于下列语境：</p>
<ul>
<li>在任何非静态成员函数体内，含成员初始化列表</li>
<li>在非静态成员函数的声明内任何(可选) cv 限定符序列后处，包含动态异常规定(弃用)、 noexcept 规定(C++11)及尾随返回类型(C++11 起)</li>
<li>在默认成员初始化中 (C++11 起)</li>
<li>在一个对象的构造期间，若通过不直接或间接从构造函数的 this 指针获得的泛左值，访问对象的值或任何其子对象，则如此获得的对象或子对象的值是未指定的。换言之，构造函数中 this 指针不能别名使用：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">D</span> <span class="title">d</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line">D(<span class="keyword">int</span> a) : a(a), b(d.a) &#123;&#125; <span class="comment">// a(a)will change to this-&gt;a(a),but b(d.a)--&gt;this-&gt;b(d.a),and will get random value,but b(a) 或 b(this-&gt;a) 是正确的</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line">D d = D(<span class="number">1</span>);   <span class="comment">// 因为 b(d.a) 不通过 this 访问， d.b 现在是未指定的,i try in g++.find it d.b==1</span></span><br></pre></td></tr></table></figure>
<h4 id="this指针于内存哪里？"><a href="#this指针于内存哪里？" class="headerlink" title="this指针于内存哪里？"></a>this指针于内存哪里？</h4><p>this 指针是不占类的内存的，它是传入成员函数的参数，所以它在栈中  </p>
<h4 id="this-指针总是指向正在操作的对象："><a href="#this-指针总是指向正在操作的对象：" class="headerlink" title="this 指针总是指向正在操作的对象："></a>this 指针总是指向正在操作的对象：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Simple <span class="title">A</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// *this = &amp;A inside the Simple constructor</span></span><br><span class="line">    <span class="function">Simple <span class="title">B</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// *this = &amp;B inside the Simple constructor</span></span><br><span class="line">    A.setID(<span class="number">3</span>); <span class="comment">// *this = &amp;A inside member function setID</span></span><br><span class="line">    B.setID(<span class="number">4</span>); <span class="comment">// *this = &amp;B inside member function setID</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line">+ <span class="keyword">this</span>指针的连锁使用：  </span><br><span class="line">由<span class="keyword">this</span>指针理解<span class="built_in">cout</span>&lt;&lt;xxx&lt;&lt;&lt;xxx&lt;&lt;&lt;xxxxx....</span><br><span class="line">对上述的表达式，<span class="built_in">cout</span>是一个类，&lt;&lt;是该类的操作符函数，则&lt;&lt;函数返回<span class="keyword">this</span>，若返回空，则无法进行：  </span><br><span class="line">```cpp</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; userName;</span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span>) &lt;&lt; userName;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">void</span>) &lt;&lt; userName;　错误</span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span>) &lt;&lt; userName;正确</span><br><span class="line">如何写？</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Calc() &#123; m_value = <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Calc&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value += value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">sub</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value -= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">mult</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value *= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calc calc;</span><br><span class="line">    calc.add(<span class="number">5</span>).sub(<span class="number">3</span>).mult(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; calc.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意Calc&amp; 和return *this</p>
<h4 id="this指针到对象名代表的是什么"><a href="#this指针到对象名代表的是什么" class="headerlink" title="this指针到对象名代表的是什么"></a>this指针到对象名代表的是什么</h4><p>由above和以下例子：来看对象的地址等<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">set</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">set</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_i += i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">getval</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span> s;</span><br><span class="line">    s.add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.getval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//结果是２　因为函数返回的*this是一个值，它是set对象的值：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span></span></span><br><span class="line"><span class="class">    5 &#123;</span>   </span><br><span class="line">    <span class="number">6</span>     <span class="keyword">int</span> m_e;</span><br><span class="line">    <span class="number">7</span>     <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="number">8</span>  <span class="keyword">public</span>:</span><br><span class="line">    <span class="number">9</span>     <span class="built_in">set</span>()</span><br><span class="line">   <span class="number">10</span>     &#123;</span><br><span class="line">   <span class="number">11</span>         m_e=<span class="number">0</span>;</span><br><span class="line">   <span class="number">12</span>         m_i=<span class="number">0</span>;</span><br><span class="line">   <span class="number">13</span>     &#125;</span><br><span class="line">   <span class="number">14</span>     <span class="function"><span class="built_in">set</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">   <span class="number">15</span>             m_i+=i;</span><br><span class="line">   <span class="number">16</span>             <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   <span class="number">17</span>     &#125;</span><br><span class="line">   <span class="number">18</span>     <span class="function"><span class="keyword">int</span> <span class="title">getval</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   <span class="number">19</span>             <span class="keyword">return</span> m_i;</span><br><span class="line">   <span class="number">20</span>     &#125;</span><br><span class="line">   <span class="number">21</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   33 </span>&#123;</span><br><span class="line">   <span class="number">34</span>         <span class="built_in">set</span> s;</span><br><span class="line">   <span class="number">35</span>         <span class="built_in">set</span> s2;</span><br><span class="line">&gt;&gt; <span class="number">36</span>         <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,s.add(<span class="number">2</span>));--输出<span class="number">0</span>,返回的是*<span class="keyword">this</span>，为s的值，m_e是其第一个成员</span><br><span class="line">&gt;&gt; <span class="number">37</span>         <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,s);－－输出<span class="number">0</span></span><br><span class="line">   <span class="number">38</span>         s2=s.add(<span class="number">2</span>);--s2被赋值了s，s此时的m_i=<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">   <span class="number">39</span>         s2.add(<span class="number">2</span>);--s2的m_i=<span class="number">6</span></span><br><span class="line">&gt;&gt; <span class="number">40</span>         <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s2);<span class="comment">//输出的是０－－－ m_e=0</span></span><br><span class="line">   <span class="number">41</span>         <span class="built_in">cout</span>&lt;&lt;s2.getval()&lt;&lt;<span class="built_in">endl</span>;-输出<span class="number">6</span>，因为</span><br><span class="line">   <span class="number">42</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">43</span> &#125;</span><br><span class="line"> 由此可以看出<span class="keyword">this</span>-&gt;object  <span class="keyword">this</span>-&gt;s</span><br><span class="line">            *<span class="keyword">this</span>==s</span><br><span class="line">            *<span class="keyword">this</span>==s的内容</span><br><span class="line">　　　　　　取对象的地址　&amp;s</span><br></pre></td></tr></table></figure></p>
<p>ref:<br><a href="http://zh.cppreference.com/w/cpp/language/this" target="_blank" rel="noopener">http://zh.cppreference.com/w/cpp/language/this</a><br><a href="http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/" target="_blank" rel="noopener">http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/</a></p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_static</title>
    <url>/2018/06/08/cpp-static/</url>
    <content><![CDATA[<h3 id="c-关键词之static"><a href="#c-关键词之static" class="headerlink" title="c++关键词之static"></a>c++关键词之static</h3><h5 id="something-share"><a href="#something-share" class="headerlink" title="something share:"></a>something share:</h5><p>其实，一开始学习c++的时候，并没有想去了解它的语法原理。虽然学c的时候，附带学了汇编，也学到了内存段，和学编译原理的时候顺带了解了它的相关词法语法处理。　　<br>现在开始从原因，历史，内存，汇编等角度去看cpp，觉得清晰了一些。虽然没有去学习g++或者其他编译器<a id="more"></a><br>如何处理c++的语法词法。这个想着以后如果有时间再研究吧。应该也是有工具去看，毕竟，g++是开源的，可以直接看源码如何处理C++</p>
<h4 id="static-overiew"><a href="#static-overiew" class="headerlink" title="static overiew"></a>static overiew</h4><ul>
<li>static在c的时候就有，因存储的地方不同于局部变量(in static mem ,not in stack)，使得在函数代码块结束后不会被销毁。从而能持续整个程序.</li>
<li>静态存储区(data)：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</li>
</ul>
<h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><p>１、static概念和用法<br>２、static内存存储和汇编<br>３、static和类相关内容与原理  </p>
<h4 id="static概念："><a href="#static概念：" class="headerlink" title="static概念："></a>static概念：</h4><p>　static为静态修饰符。编译器遇到这个修饰符时将对应的变量存储在静态存储区(data)  　</p>
<ul>
<li>根据类型：static可以修饰变量和函数，修饰对象和成员函数  </li>
<li>根据位置：静态局部变量和全局静态变量 -存于静态数据区(data)</li>
</ul>
<h5 id="c中的static"><a href="#c中的static" class="headerlink" title="c中的static:"></a>c中的static:</h5><ul>
<li>修饰变量：作用域是本程序文件，局部变量默认为auto,静态变量不管局部或者全局都存储于静态数据区，使得不会因为函数调用而销毁</li>
<li>修饰函数：只能用于本程序文件，普通函数默认为extern ,能被其他文件引用，static则不行</li>
</ul>
<p>“ 举个例子：<br>在stat.h中声明static int getstats()函数.<br>并在stat.c中实现它，static int getstats(){return xxx;}<br>在main中或者其他文件中使用这个函数<br>编译时报错未能找到该函数（未定义该函数)<br>c++中的static当和类无关时同c” </p>
<h4 id="static使用和内存与汇编："><a href="#static使用和内存与汇编：" class="headerlink" title="static使用和内存与汇编："></a>static使用和内存与汇编：</h4><h5 id="static全局变量"><a href="#static全局变量" class="headerlink" title="static全局变量"></a>static全局变量</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> global1=<span class="number">4</span>;</span><br><span class="line">   <span class="number">12</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   13 </span>&#123;</span><br><span class="line">&gt;&gt; <span class="number">14</span>         <span class="keyword">int</span> loc1=global1;</span><br><span class="line"></span><br><span class="line">_ZL7global1:</span><br><span class="line">	.<span class="keyword">long</span>	<span class="number">4</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line"></span><br><span class="line">	movl	_ZL7global1(%rip), %eax</span><br><span class="line">	movl	%eax, <span class="number">-4</span>(%rbp)</span><br><span class="line"><span class="comment">//且可以通过kdbg看到在执行期，</span></span><br><span class="line"><span class="keyword">static</span>变量的内存位置约为：</span><br><span class="line">(<span class="keyword">int</span> *) <span class="number">0x601048</span> &lt;global1&gt;　数据段地址</span><br><span class="line">局部变量的位置约为：</span><br><span class="line">(<span class="keyword">char</span> **) <span class="number">0x7ffff7a54530</span> &lt;loc1&gt;　栈地址</span><br></pre></td></tr></table></figure>
<h5 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   13 </span>&#123;</span><br><span class="line">   <span class="number">14</span>         <span class="keyword">static</span> <span class="keyword">int</span> locstatic1=<span class="number">5</span>;</span><br><span class="line">&gt;&gt; <span class="number">15</span>         <span class="keyword">int</span> loc1=global1;</span><br><span class="line">&gt;&gt; <span class="number">16</span>         <span class="keyword">int</span> loc2=locstatic1;</span><br><span class="line"></span><br><span class="line">	movl	_ZZ4mainE10locstatic1(%rip), %eax</span><br><span class="line">	movl	%eax, <span class="number">-4</span>(%rbp)</span><br><span class="line"></span><br><span class="line">_ZZ4mainE10locstatic1:</span><br><span class="line">	.<span class="keyword">long</span>	<span class="number">5</span></span><br><span class="line">执行期：</span><br><span class="line">　　loca1 　(<span class="keyword">int</span> *) <span class="number">0x7fffffffd8a8</span></span><br><span class="line">　　loca2 (<span class="keyword">int</span> *) <span class="number">0x7fffffffd8ac</span></span><br><span class="line"></span><br><span class="line">  global1 (<span class="keyword">int</span> *) <span class="number">0x601048</span> &lt;global1&gt;</span><br><span class="line">  locstatic:(<span class="keyword">int</span> *) <span class="number">0x60104c</span> &lt;main::locstatic1&gt;</span><br></pre></td></tr></table></figure>
<h5 id="static定义的变量和函数只能在本程序文件中使用"><a href="#static定义的变量和函数只能在本程序文件中使用" class="headerlink" title="static定义的变量和函数只能在本程序文件中使用"></a>static定义的变量和函数只能在本程序文件中使用</h5><p>要知道这个的原因可能有些复杂，一时半会也说不清，得先直到函数为什么能被外部引用：存在“符号表”中，能被外部链接，静态函数不在符号表中所以不行，类似这样吧，<br>这块不太清楚，感觉是这个原因</p>
<h5 id="static函数："><a href="#static函数：" class="headerlink" title="static函数："></a>static函数：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">getv</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    4 </span>&#123;</span><br><span class="line">    <span class="number">5</span>         <span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="number">6</span>         a++;</span><br><span class="line">    <span class="number">7</span>         <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="number">8</span>         <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="number">9</span> &#125; </span><br><span class="line"></span><br><span class="line">	.type	_ZL4getvv, @function</span><br><span class="line">_ZL4getvv:</span><br><span class="line">.LFB1021:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">	subq	$<span class="number">16</span>, %rsp</span><br><span class="line">　　　。。。。</span><br></pre></td></tr></table></figure>
<p>　    call    _ZL4getvv<br>从汇编代码看貌似跟普通函数没什么差别<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">运行时</span><br><span class="line">　　<span class="function"><span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">getv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="number">0x400816</span> push   %rbp</span><br><span class="line"><span class="number">0x400817</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x40081a</span> sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">		<span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line">		a++;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> global1=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">int</span> locstatic1=<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">int</span> loc1=global1;</span><br><span class="line">		<span class="keyword">int</span> loc2=locstatic1;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;getv()&lt;&lt;endl;</span></span><br><span class="line">    	getv();</span><br><span class="line"><span class="number">0x400866</span> callq  <span class="number">0x400816</span> &lt;getv()&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="static和类相关"><a href="#static和类相关" class="headerlink" title="static和类相关"></a>static和类相关</h4><h5 id="static成员变量的使用"><a href="#static成员变量的使用" class="headerlink" title="static成员变量的使用"></a>static成员变量的使用</h5><p> static成员变量是类的所有对象共有的，但是只有一份，通过类也可以访问到<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value; <span class="comment">// declares the static member variable</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Something::s_value = <span class="number">1</span>; <span class="comment">// defines the static member variable (we'll discuss this section below)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// note: we're not instantiating any objects of type Something</span></span><br><span class="line"> </span><br><span class="line">    Something::s_value = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Something::s_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_ZN9Something7s_valueE:</span><br><span class="line">	.<span class="keyword">long</span>	<span class="number">1</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line"></span><br><span class="line">　　</span><br><span class="line">  Something::s_value=<span class="number">3</span>;</span><br><span class="line"><span class="number">0x40081a</span> movl   $<span class="number">0x3</span>,<span class="number">0x20083c</span>(%rip)        # <span class="number">0x601060</span> &lt;Something::s_value&gt;</span><br><span class="line">（	movl	_ZN9Something7s_valueE(%rip), %eax</span><br><span class="line">	movl	%eax, %esi</span><br><span class="line">）</span><br><span class="line">可见类似于上述的，存在内存的数据段中</span><br></pre></td></tr></table></figure>
<h5 id="类静态变量作用域"><a href="#类静态变量作用域" class="headerlink" title="类静态变量作用域"></a>类静态变量作用域</h5><p>静态成员在多个文件中:<br>类中的机制，可以让定义在文件中的静态成员变量能被其他文件访问；加了作用域的声明，所以可以这样用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">在stati.h</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Some</span>&#123;</span></span><br><span class="line">  <span class="number">2</span>         <span class="keyword">public</span>:</span><br><span class="line">  <span class="number">3</span>                 <span class="keyword">static</span> <span class="keyword">int</span> s_v;</span><br><span class="line">  <span class="number">4</span> &#125;;</span><br><span class="line">  <span class="number">5</span> <span class="comment">//static int s_vv;//error 错误</span></span><br><span class="line"></span><br><span class="line">在stati.cpp</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stati.h"</span></span></span><br><span class="line">  <span class="number">2</span> <span class="keyword">int</span> Some::s_v=<span class="number">4</span>;</span><br><span class="line">  <span class="number">3</span> <span class="comment">//static int s_vv=5;error</span></span><br><span class="line"></span><br><span class="line">在main</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stati.h"</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> gets= Some::s_v;</span><br><span class="line"></span><br><span class="line">other:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Whatever</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> s_value = <span class="number">4</span>; <span class="comment">// a static const int can be declared and initialized directly</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="静态成员函数的使用"><a href="#静态成员函数的使用" class="headerlink" title="静态成员函数的使用"></a>静态成员函数的使用</h5><ul>
<li>考虑一个问题，当静态成员被申明为private时，则无法使用它directly by class。<br>but you can用非静态成员函数操作或者用静态成员函数操作to use it  </li>
<li>静态成员函数也是可以用类直接调用，它没有this指针，所以不能修改和访问对象的成员； </li>
<li>（非静态成员func,它可以定义在类的内部或者外部，外部不用加static,这点和static成员不同，成员得在外部初始化－－因为public等定义成员时，非const不能赋值，而<br>static不能修饰构造函数（对象相关），所以只能在外部初始化)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDGenerator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_nextID; <span class="comment">// Here's the declaration for a static member</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextID</span><span class="params">()</span></span>; <span class="comment">// Here's the declaration for a static function</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Here's the definition of the static member outside the class.  Note we don't use the static keyword here.</span></span><br><span class="line"><span class="comment">// We'll start generating IDs at 1</span></span><br><span class="line"><span class="keyword">int</span> IDGenerator::s_nextID = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Here's the definition of the static function outside of the class.  Note we don't use the static keyword here.</span></span><br><span class="line"><span class="keyword">int</span> IDGenerator::getNextID() &#123; <span class="keyword">return</span> s_nextID++; &#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">5</span>; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The next ID is: "</span> &lt;&lt; IDGenerator::getNextID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_const</title>
    <url>/2018/06/08/cpp-const/</url>
    <content><![CDATA[<h3 id="c-关键词之const"><a href="#c-关键词之const" class="headerlink" title="c++关键词之const"></a>c++关键词之const</h3><h4 id="const介绍，用法，原理，注意点等"><a href="#const介绍，用法，原理，注意点等" class="headerlink" title="const介绍，用法，原理，注意点等"></a>const介绍，用法，原理，注意点等</h4><h5 id="const-介绍："><a href="#const-介绍：" class="headerlink" title="const 介绍："></a>const 介绍：</h5><p>const是用于标示不可修改的变量，对象或函数的。<br>在其前面添加const就无法在之后做修改  </p>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法 "></a>用法 <a id="more"></a></h5><p>const总结起来有以下用法：</p>
<ul>
<li>const 修饰基本类型的变量  <ul>
<li>const int xx=4; const double xd=3.3;   </li>
<li>const int array[3]={3,4,5};</li>
<li>const　修饰指针和引用</li>
</ul>
</li>
<li>const 指针： <ul>
<li>const int *p=&value;<br>//无法改变指针指向的值，但是可以改变指针,<br>value可以是int value;/const int value;</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">          <span class="keyword">int</span> va=<span class="number">4</span>;</span><br><span class="line">    <span class="number">6</span>         <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;va ;</span><br><span class="line">    <span class="number">7</span>         va=<span class="number">5</span>;</span><br><span class="line">&gt;&gt;  <span class="number">8</span>         *p=<span class="number">6</span>;<span class="comment">//error</span></span><br><span class="line">    <span class="number">9</span>         <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//5</span></span><br><span class="line">   <span class="number">10</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>int *const p=&value; //无法改变指针的值，但是可以改变指针指向的值</li>
<li>const int *const p=&value;//指针的值和指针指向的值　都不可以改变<ul>
<li>const 引用：</li>
<li>const int &amp;ref=value;</li>
</ul>
</li>
</ul>
<h5 id="const-c-amp-cpp差异"><a href="#const-c-amp-cpp差异" class="headerlink" title="const  c&amp;cpp差异"></a>const  c&amp;cpp差异</h5><ul>
<li>不同于CPP，c将const存入的内存中设为只读，还是在栈中，而取其值时需要从内存中获取，所以从这个点看其效率比cpp差<br>why?see follow <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    c code:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cc=<span class="number">8</span>;</span><br><span class="line"><span class="number">0x4004da</span> movl   $<span class="number">0x8</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">		<span class="keyword">int</span> ccc=cc;</span><br><span class="line"><span class="number">0x4004e1</span> mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line"><span class="number">0x4004e4</span> mov    %eax,<span class="number">-0x4</span>(%rbp)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="const和类"><a href="#const和类" class="headerlink" title="const和类"></a>const和类</h5><ul>
<li><p>const 对象 const对象不能调用非const成员函数，也不能改变成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">constobj</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> ax;</span><br><span class="line">     <span class="keyword">int</span> bx;</span><br><span class="line">     constonj(<span class="keyword">int</span> a,<span class="keyword">int</span> b):ax(a),bx(b)&#123;&#125;;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">getax</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> ax;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">getbx</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bx;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setax</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;ax=a;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     constobj cobj;</span><br><span class="line">     <span class="keyword">const</span> constobj ccobj;</span><br><span class="line">     ccobj.setax(<span class="number">3</span>);<span class="comment">//error</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>const 成员函数（只有成员函数能被声明为const )，它不能改变成员</p>
</li>
<li>不能在const成员函数中修改成员变量，但是可以修改其他变量。</li>
<li>非const对象可以调用const成员函数</li>
<li>一个灵活使用const成员函数的例子：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Something(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;value=<span class="string">""</span>) &#123; m_value= value; &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125; <span class="comment">// getValue() for const objects</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125; <span class="comment">// getValue() for non-const objects</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Something something;</span><br><span class="line">	something.getValue() = <span class="string">"Hi"</span>; <span class="comment">// calls non-const getValue();</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">const</span> Something something2;</span><br><span class="line">	something2.getValue(); <span class="comment">// calls const getValue();</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="c-11中的添加的新内容"><a href="#c-11中的添加的新内容" class="headerlink" title="c++11中的添加的新内容"></a>c++11中的添加的新内容</h5><ul>
<li>constexp，cv限定  <h5 id="c-const内存和原理"><a href="#c-const内存和原理" class="headerlink" title="c++ const内存和原理"></a>c++ const内存和原理</h5></li>
<li>基本变量<br>const变量是在栈中分配内存的，但是仅限于定义的时候，之后其他地方使用这个const变量都直接是使用该值<br>从汇编中可以看到</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">    const int  co1=<span class="number">3</span>;</span><br><span class="line"><span class="number">0x4008ed</span> movl   $<span class="number">0x3</span>,<span class="number">-0x14</span>(%rbp)</span><br><span class="line">		 int  nor=co1;</span><br><span class="line"><span class="number">0x4008f4</span> movl   $<span class="number">0x3</span>,<span class="number">-0x10</span>(%rbp)</span><br></pre></td></tr></table></figure>
<p>所以无法当进行co1=4;的赋值操作时会被编译器拦截，想想，编译后会变成3=4;是不对的； </p>
<ul>
<li>这也解释了为什么一开始就要给const的变量赋值 *</li>
</ul>
<ul>
<li>数组:save in stack</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">3</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="number">0x4008fb</span> movl   $<span class="number">0x2</span>,<span class="number">-0x20</span>(%rbp)</span><br><span class="line"><span class="number">0x400902</span> movl   $<span class="number">0x3</span>,<span class="number">-0x1c</span>(%rbp)</span><br><span class="line"><span class="number">0x400909</span> movl   $<span class="number">0x5</span>,<span class="number">-0x18</span>(%rbp)</span><br></pre></td></tr></table></figure>
<ul>
<li>指针：<br>const指针结合，其并不像基本类型那样贴出值，而是每次还是得去内存中取值，它的限定改变值，由编译器控制报错  </li>
</ul>
<p>指针并不是像前面那样，如<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;value;</span><br><span class="line">    <span class="keyword">int</span> xx=*p;<span class="comment">//被替换成值?不是的，而是去内存中先取出指针的值，再以此为地址去取值；</span></span><br><span class="line">     <span class="keyword">int</span> pv=<span class="number">4</span>;</span><br><span class="line"><span class="number">0x400a12</span> movl   $<span class="number">0x4</span>,<span class="number">-0x58</span>(%rbp)</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;pv;</span><br><span class="line"><span class="number">0x400a19</span> lea    <span class="number">-0x58</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a1d</span> mov    %rax,<span class="number">-0x40</span>(%rbp)</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">int</span> px=*p;</span><br><span class="line"><span class="number">0x400a69</span> mov    <span class="number">-0x40</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a6d</span> mov    (%rax),%eax</span><br><span class="line"><span class="number">0x400a6f</span> mov    %eax,<span class="number">-0x48</span>(%rbp)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">　　　   <span class="keyword">int</span> pv=<span class="number">4</span>;</span><br><span class="line"><span class="number">0x400a12</span> movl   $<span class="number">0x4</span>,<span class="number">-0x70</span>(%rbp)<span class="comment">//put 4 in mem(statck)</span></span><br><span class="line">		 <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;pv;</span><br><span class="line"><span class="number">0x400a19</span> lea    <span class="number">-0x70</span>(%rbp),%rax<span class="comment">//get its addr</span></span><br><span class="line"><span class="number">0x400a1d</span> mov    %rax,<span class="number">-0x58</span>(%rbp)<span class="comment">//addr to p</span></span><br><span class="line">         <span class="keyword">int</span> *<span class="keyword">const</span> pp=&amp;pv; </span><br><span class="line"><span class="number">0x400a21</span> lea    <span class="number">-0x70</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a25</span> mov    %rax,<span class="number">-0x50</span>(%rbp)<span class="comment">//adddr to pp</span></span><br><span class="line">         <span class="keyword">int</span>  *ppp=pp;</span><br><span class="line"><span class="number">0x400a29</span> mov    <span class="number">-0x50</span>(%rbp),%rax<span class="comment">//get pp num</span></span><br><span class="line"><span class="number">0x400a2d</span> mov    %rax,<span class="number">-0x48</span>(%rbp)<span class="comment">//to ppp</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>引用：<br>引用同指针，是会去内存中取值的,same to pointer</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">follow above</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref=pv;</span><br><span class="line"><span class="number">0x400aba</span> lea    <span class="number">-0x7c</span>(%rbp),%rax<span class="comment">//get pv</span></span><br><span class="line"><span class="number">0x400abe</span> mov    %rax,<span class="number">-0x38</span>(%rbp)<span class="comment">//to ref</span></span><br><span class="line">		 <span class="keyword">int</span> cs=ref;</span><br><span class="line"><span class="number">0x400ac2</span> mov    <span class="number">-0x38</span>(%rbp),%rax<span class="comment">//get ref</span></span><br><span class="line"><span class="number">0x400ac6</span> mov    (%rax),%eax<span class="comment">//get *ref</span></span><br><span class="line"><span class="number">0x400ac8</span> mov    %eax,<span class="number">-0x64</span>(%rbp)<span class="comment">//to cs</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>const类对象：  </p>
<ul>
<li>const对象为什么不能更改成员：<br>成员是存在对象中的，如int,char等成员，存在栈中<br>const对象的成员也是放在栈中的，它们之所以不能赋值，是在编译期间确定，更具体的细节未知；  　</li>
</ul>
</li>
<li>const对象为什么不能调用非const成员函数：<ul>
<li>一个成员函数如何被调用：   　　</li>
<li>其实成员函数也是全局函数，所以它能被调用，<br>　eg:    <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  obj.show();---&gt;实际上被转换为：</span><br><span class="line">  show(&amp;obj)  --传递给<span class="keyword">this</span>指针：</span><br><span class="line"> 所以当：<span class="function"><span class="keyword">const</span> OB <span class="title">obj</span><span class="params">()</span></span>;</span><br><span class="line">obj.show();时，翻译为　<span class="keyword">const</span> OB *<span class="keyword">this</span>;</span><br><span class="line">在传递给OB *<span class="keyword">this</span>时会出现不能将<span class="keyword">this</span>指针</span><br><span class="line">从<span class="keyword">const</span> OB转换为OB &amp;的错误</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>可以做个实验试试</p>
<ul>
<li><p>conclude:<br>if it can use non const func ,it will change member by non const this pointer;</p>
</li>
<li><p>为什么可以调用const函数：<br>const函数：void show() const转换为：show(const OB *this);所以匹配上了，就可以调用了</p>
</li>
</ul>
<p>注意：有最小权限原则，非const对象可以调用const成员函数，就像可以赋值一样。非const变量可以用const赋值</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_keyword</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_linklist3</title>
    <url>/2018/06/07/leetcode-linklist3/</url>
    <content><![CDATA[<h3 id="leetcode-linklist3"><a href="#leetcode-linklist3" class="headerlink" title="leetcode_linklist3"></a>leetcode_linklist3</h3><p>continue..</p>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.<br><a id="more"></a><br>Example 1:</p>
<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
<p>Example 2:</p>
<p>Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>Output: 2-&gt;0-&gt;1-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL<br>rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL<br>rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>/**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li>int val;</li>
<li>struct ListNode *next;</li>
<li>};<br>*/</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">rotateRight</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">headnode</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    headnode-&gt;next=head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">sumhead</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">//compute len of list</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sumhead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        sumhead=sumhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    sum++;</span><br><span class="line">    <span class="comment">//compare k and len,or just compute the rota num</span></span><br><span class="line">    <span class="keyword">int</span> num=k%sum;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dealheadf</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;sum-num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dealheadf=dealheadf-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sumhead-&gt;next=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=dealheadf-&gt;next;</span><br><span class="line">    dealheadf-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">    head=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headnode);</span><br><span class="line">    <span class="keyword">return</span>  head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移除倒数第n个元素"><a href="#移除倒数第n个元素" class="headerlink" title="移除倒数第n个元素"></a>移除倒数第n个元素</h4><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>
<p>Example:</p>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p>
<p>Note:</p>
<p>Given n will always be valid.</p>
<p>Follow up:</p>
<p>Could you do this in one pass?</p>
<p>/**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li>int val;</li>
<li>struct ListNode *next;</li>
<li>};<br>*/</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="comment">//这个几乎没道题都要注意</span></span><br><span class="line">         <span class="keyword">return</span> head;</span><br><span class="line">     <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>&amp;&amp;n&gt;=<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">sumhead</span>=<span class="title">head</span>;</span></span><br><span class="line">     <span class="keyword">while</span>(sumhead!=<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         sum++;</span><br><span class="line">         sumhead=sumhead-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> remove=sum-n;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">removenode</span>=<span class="title">head</span>;</span></span><br><span class="line">     <span class="keyword">while</span>(remove&gt;<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         removenode=removenode-&gt;next;</span><br><span class="line">         remove--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">rmnode</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(remove==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">rmnode</span>;</span></span><br><span class="line">     rmnode=removenode-&gt;next;</span><br><span class="line">     removenode-&gt;next=removenode-&gt;next-&gt;next;</span><br><span class="line">     rmnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">     <span class="built_in">free</span>(rmnode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//删除头</span></span><br><span class="line">    &#123;</span><br><span class="line">        rmnode=removenode;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">        rmnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(rmnode);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//一开始未考虑到删除头的情况，所以加了else 部分</p>
<h4 id="交换元素"><a href="#交换元素" class="headerlink" title="交换元素"></a>交换元素</h4><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>Example:</p>
<p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Note:</p>
<pre><code>Your algorithm should use only constant extra space.
You may not modify the values in the list&apos;s nodes, only nodes itself may be changed.
</code></pre><p>/**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li>int val;</li>
<li>struct ListNode *next;</li>
<li>};<br>*/</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">swapPairs</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">headNode</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">second</span>=<span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">first</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">curhead</span>=<span class="title">headNode</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="literal">NULL</span>)<span class="keyword">break</span>;</span><br><span class="line">        second=first-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(second!=<span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          first-&gt;next=second-&gt;next==<span class="literal">NULL</span>?<span class="literal">NULL</span>:second-&gt;next;</span><br><span class="line">          second-&gt;next=first;</span><br><span class="line">          curhead-&gt;next=second;</span><br><span class="line">          curhead=first;</span><br><span class="line">          first=first-&gt;next==<span class="literal">NULL</span>?<span class="literal">NULL</span>:first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head=headNode-&gt;next;</span><br><span class="line">    headNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headNode);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="k组反转"><a href="#k组反转" class="headerlink" title="k组反转"></a>k组反转</h4><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>Example:</p>
<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>Note:</p>
<pre><code>Only constant extra memory is allowed.
You may not alter the values in the list&apos;s nodes, only nodes itself may be changed.
</code></pre><p>/**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li>int val;</li>
<li>struct ListNode *next;</li>
<li>};<br><em>/<br>/</em><br>这道题目原想在遍历一次就解决，可是还是想不出好的方法，得遍历两次，一次计算长度，一次正真的处理；<br>在处理的过程使用头插法。注意边界条件，但因为有数量控制好些*/<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseKGroup</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">headnode</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    headnode-&gt;next=head;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">lenhead</span>=<span class="title">head</span>,*<span class="title">curhead</span>=<span class="title">headnode</span>,*<span class="title">cur</span>=<span class="title">head</span>,*<span class="title">tmp</span>=<span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(lenhead!=<span class="literal">NULL</span>)<span class="comment">//计算长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        lenhead=lenhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numofreverse=len/k;<span class="comment">//要reverse几次</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=numofreverse;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j=k;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">1</span>)<span class="comment">//每一次reverse k次，头插法</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp=curhead-&gt;next;</span><br><span class="line">            curhead-&gt;next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            curhead-&gt;next-&gt;next=tmp;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        curhead=cur;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    head=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headnode);</span><br><span class="line">    <span class="keyword">return</span> head;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>后面还有几道题，不贴了，这里简述下：  </p>
<ul>
<li>检查是否链表中存在循环</li>
<li>检查链表中是否存在循环并找到循环的起点</li>
<li>深度复制链表，链表中的每个节点存在一个指向任意节点的指针</li>
<li>设计一个LRU cache,即（最近使用的）</li>
<li><p>。。。。。</p>
</li>
<li><p>链表的套路：</p>
<ul>
<li>常使用头插法进行反转操作</li>
<li>使用两个指针解决循环问题，指针相遇测试是否存在循环，指针遍历减少时间</li>
<li>使用哈希，以空间换时间</li>
<li>加头节点，简化逻辑</li>
</ul>
</li>
<li>使用链表注意<ul>
<li>检查空和是否只有一个节点</li>
<li>释放空间，和放置取空指针，可以通过次数控制和判空</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_linklist2</title>
    <url>/2018/06/03/leetcode-linklist2/</url>
    <content><![CDATA[<h3 id="leetcode——单链表2"><a href="#leetcode——单链表2" class="headerlink" title="leetcode——单链表2"></a>leetcode——单链表2</h3><h4 id="partition-list"><a href="#partition-list" class="headerlink" title="partition list"></a>partition list</h4><p>这个是快速排序中一个很重要的步骤，即比该数大于等于的放其前小的放后。在链表中，基本思路:扫描链表，比给定数字小的不处理，比给定数字大的取下并插入到末尾 <a id="more"></a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">You should preserve the original relative order of the nodes in each of the two partitions.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">partition</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next ==<span class="literal">NULL</span>)</span><br><span class="line">              <span class="keyword">return</span> head;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span>  <span class="title">ListNode</span>));</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;next=head;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">head1</span>=<span class="title">list</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">cur</span> = <span class="title">head1</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">tail</span>=<span class="title">head1</span>;</span></span><br><span class="line">		<span class="keyword">int</span> lenoflist1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(tail-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">				tail=tail-&gt;next;</span><br><span class="line">				lenoflist1++;</span><br><span class="line">		&#125;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tmp</span>=<span class="title">tail</span>;</span></span><br><span class="line">		<span class="keyword">while</span>(lenoflist1&gt;=<span class="number">1</span>)</span><br><span class="line">		&#123; </span><br><span class="line">            lenoflist1--;</span><br><span class="line">            <span class="keyword">if</span>(tail==cur)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span>(cur-&gt;val&gt;=x)</span><br><span class="line">		  &#123;</span><br><span class="line">				  head1-&gt;next=cur-&gt;next;</span><br><span class="line">				  cur-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		          tail-&gt;next=cur;</span><br><span class="line">				  tail=tail-&gt;next;<span class="comment">//not consid at first</span></span><br><span class="line">				  cur=head1-&gt;next;</span><br><span class="line"></span><br><span class="line">		  &#125; </span><br><span class="line">		  <span class="keyword">else</span>&#123;</span><br><span class="line">				  head1=head1-&gt;next;</span><br><span class="line">				  cur=cur-&gt;next;</span><br><span class="line">		  &#125;</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">//  printf("%d : ",cur-&gt;num);</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//if(head1-&gt;next==NULL)head1-&gt;next=tmp;</span></span><br><span class="line">         head=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">   <span class="built_in">list</span>-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//此题目最终被accepted<br>//应该在函数中添加头节点而不是依靠传入的链表带头节点,一开始没有考虑到传入的链表不带链表头。。，没有考虑到一个元素的情况，这个方案最终accept</p>
<h4 id="链表中的子链表反转，考察头插法"><a href="#链表中的子链表反转，考察头插法" class="headerlink" title="链表中的子链表反转，考察头插法"></a>链表中的子链表反转，考察头插法</h4><ul>
<li>头插法在链表的反转，倒序，常被用到  </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* reverse a linklist from m to n</span></span><br><span class="line"><span class="comment"> * 1-&gt;2-&gt;4-&gt;5-&gt;null and m,n(ex:2,4)</span></span><br><span class="line"><span class="comment"> * return 1-&gt;5-&gt;4-&gt;2-&gt;null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span>  *<span class="title">next</span>;</span></span><br><span class="line">&#125;Linklist;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverselinklist</span><span class="params">(Linklist *list1,<span class="keyword">int</span> m,<span class="keyword">int</span> n,Linklist **result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(list1==<span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		Linklist *head1,*head2,*cur,*tmp,*pre;</span><br><span class="line">		cur=list1;</span><br><span class="line">		head1=cur;</span><br><span class="line">		pre=head1;</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">				cur=cur-&gt;next;</span><br><span class="line">				<span class="keyword">for</span>(i=m;i&lt;n;i++)</span><br><span class="line">				&#123;</span><br><span class="line">				  pre-&gt;next=cur-&gt;next;</span><br><span class="line">				  cur-&gt;next=head1;</span><br><span class="line">				  head1=cur;</span><br><span class="line">				  cur=pre-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			    *result=head1;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)<span class="comment">//node1-&gt;node2-&gt;node3---1-&gt;2-&gt;3--ex:m=2,list1-&gt;1</span></span><br><span class="line">		&#123;</span><br><span class="line">		  head1=cur;</span><br><span class="line">          cur=cur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		head2=cur;</span><br><span class="line">		cur=cur-&gt;next;</span><br><span class="line">		pre=head2;</span><br><span class="line">		<span class="keyword">for</span>(i=m;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">		   pre-&gt;next=cur-&gt;next;</span><br><span class="line">		   cur-&gt;next=head1-&gt;next;</span><br><span class="line">		   head1-&gt;next=cur;</span><br><span class="line">		   cur=pre-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		Linklist *list1=(Linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">		Linklist *result11=list1;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		list1-&gt;num=<span class="number">4</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"4 "</span>);</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">9</span>;i++)</span><br><span class="line">	  &#123;</span><br><span class="line">						     </span><br><span class="line">			list1-&gt;next = (Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">			list1 = list1-&gt;next;</span><br><span class="line">		    list1-&gt;num = i*<span class="number">2</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,i*<span class="number">2</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	   Linklist *rr=(Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">	   Linklist **resull=&amp;rr;</span><br><span class="line">	   <span class="keyword">int</span> rere=reverselinklist(result11,<span class="number">1</span>,<span class="number">9</span>,resull);</span><br><span class="line">	   <span class="keyword">if</span>(rere==<span class="number">3</span>) &#123;</span><br><span class="line">	    <span class="keyword">for</span>(i=<span class="number">0</span>;result11!=<span class="literal">NULL</span> ;i++,result11=result11-&gt;next)</span><br><span class="line">				       <span class="built_in">printf</span>(<span class="string">"%d "</span>,result11-&gt;num); </span><br><span class="line">	  	<span class="built_in">free</span>(list1);</span><br><span class="line">	   &#125;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	  &#123; </span><br><span class="line">	    <span class="keyword">for</span>(i=<span class="number">0</span>;*resull!=<span class="literal">NULL</span> ;i++,*resull= (*resull)-&gt;next)</span><br><span class="line">				       <span class="built_in">printf</span>(<span class="string">"%d "</span>,(*resull)-&gt;num); </span><br><span class="line">	  	<span class="built_in">free</span>(*resull);</span><br><span class="line">	  &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//此解法未经过leetcode检验，不过应该问题不大</p>
<h4 id="有序链表移除重复元素"><a href="#有序链表移除重复元素" class="headerlink" title="有序链表移除重复元素"></a>有序链表移除重复元素</h4><ul>
<li>考察的是遍历链表删除链表中的元素，注意边缘条件控制如头部和尾部</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Given a sorted linked list, delete all duplicates such that each element appear only once.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1-&gt;1-&gt;2</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">first</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">second</span>=<span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span>=<span class="title">second</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(second!=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        tmp=second;</span><br><span class="line">        <span class="keyword">if</span>(first-&gt;val==second-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            first-&gt;next=second;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(first-&gt;val==tmp-&gt;val)</span><br><span class="line">        first-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//此方案最后被accepted</p>
<h4 id="删除有序链表中的有重复的node"><a href="#删除有序链表中的有重复的node" class="headerlink" title="删除有序链表中的有重复的node"></a>删除有序链表中的有重复的node</h4><ul>
<li>和上一道题目类似:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Given a sorted linked list, delete all duplicates such that each element appear only once.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1-&gt;1-&gt;2</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">headnode</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    headnode-&gt;next=head;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">first</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">second</span>=<span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> numsame=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmphead</span>=<span class="title">headnode</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(second!=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(first-&gt;val==second-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">               numsame++;</span><br><span class="line">               first=first-&gt;next;</span><br><span class="line">               second=second-&gt;next;</span><br><span class="line">               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(first-&gt;val !=second-&gt;val &amp;&amp; numsame==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmphead-&gt;next=first;</span><br><span class="line">            tmphead=tmphead-&gt;next;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">            numsame=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numsame==<span class="number">0</span>)tmphead-&gt;next=first;</span><br><span class="line">    <span class="keyword">else</span> tmphead-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">    head=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headnode);   </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list1</span>=(<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span>=<span class="title">list1</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">freelist1</span>=<span class="title">list1</span>;</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">		 list1-&gt;val=<span class="number">20</span>-i;</span><br><span class="line">		 list1-&gt;next=(struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">		 list1=list1-&gt;next;</span><br><span class="line">		 <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="number">20</span>-i);</span><br><span class="line">   &#125;</span><br><span class="line">   list1-&gt;val=<span class="number">12</span>;</span><br><span class="line">   tmp=deleteDuplicates(tmp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;tmp!=<span class="literal">NULL</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">		   <span class="built_in">printf</span>(<span class="string">"%d  "</span>,tmp-&gt;val);</span><br><span class="line">		   tmp=tmp-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">free</span>(freelist1);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这道题做的比较顺利，一次提交就=通过了</span><br><span class="line">注意：加头节点，由于解题的思路是两个指针的遍历，在第二个指针为空时停止，就会有尾巴为几种情况时的处理：如当尾巴为：<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span> 这两种情况时，去掉尾巴，否则<span class="number">4</span>,<span class="number">5</span>,<span class="number">6.4</span>,<span class="number">4</span>,<span class="number">5</span>时尾巴保留；见代码</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_linklist1</title>
    <url>/2018/06/03/leetcode-linklist1/</url>
    <content><![CDATA[<h3 id="leetcode——单链表"><a href="#leetcode——单链表" class="headerlink" title="leetcode——单链表"></a>leetcode——单链表</h3><h4 id="两数相加："><a href="#两数相加：" class="headerlink" title="两数相加："></a>两数相加：</h4><ul>
<li>这道题是经一年多没刷题目之后，重新开始的第一道题，本来想着只是本地刷刷，后面开始就到leetcode提交了，毕竟写的程序还是得经过检验</li>
<li>所以这道题就纯粹的解答，未经检验，只是本地跑通，并且加上了自己的一些看法，比如对该题目该思路可能可以应用在哪些地方，这样算法才有了真正的意义，个人十分不赞同一些在公司呆久了的人说数据结构算法没什么用的人2333</li>
<li>废话不多说：  好久没写，第一道就别吐槽了，慢慢来</li>
<li>题目描述：  <a id="more"></a><br>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>Example<br>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.<br>注意两个数字位数可能不同，所以需要一些特殊情况要处理<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">		<span class="keyword">int</span> num;</span><br><span class="line">&#125; *linklist,listnode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是自己加的扩展，把输入的两个大数字符串转换为链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">changtolist</span><span class="params">(struct ListNode *list1,<span class="keyword">char</span> num1[],struct ListNode *list2,<span class="keyword">char</span>  num2[])</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//应该在接口内计算长度好些</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> lennum1=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(num1[lennum1]!=<span class="string">'\0'</span>)&#123;lennum1++;&#125;</span><br><span class="line">   <span class="keyword">int</span> lennum2=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(num2[lennum2]!=<span class="string">'\0'</span>)&#123;lennum2++;&#125;</span><br><span class="line"><span class="comment">//分配空间加字母转数字，无头节点</span></span><br><span class="line">   list1-&gt;num=num1[lennum1<span class="number">-1</span>]<span class="number">-48</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=lennum1<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">   &#123;</span><br><span class="line">		list1-&gt;next=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">		list1=list1-&gt;next;</span><br><span class="line">        list1-&gt;num=num1[i]<span class="number">-48</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   list1-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   list2-&gt;num=num2[lennum2<span class="number">-1</span>]<span class="number">-48</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=lennum2<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">   &#123;</span><br><span class="line">		list2-&gt;next=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">		list2=list2-&gt;next;</span><br><span class="line">		list2-&gt;num=num2[i]<span class="number">-48</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   list2-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个大数相加，不用头节点的方式，麻烦一些</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add_two_num</span><span class="params">(struct ListNode *list1,struct ListNode *list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">int</span> adding = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(list1 == <span class="literal">NULL</span> || list2 == <span class="literal">NULL</span>)</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/*	 while(list1!=NULL &amp;&amp; list2!=NULL)</span></span><br><span class="line"><span class="comment">	 &#123;</span></span><br><span class="line"><span class="comment">			 list1-&gt;num = (list1-&gt;num+list2-&gt;num+adding)%10;</span></span><br><span class="line"><span class="comment">             adding = (list1-&gt;num + list2-&gt;num+adding)/10;</span></span><br><span class="line"><span class="comment">			 list1 = list1-&gt;next;</span></span><br><span class="line"><span class="comment">			 list2 = list2-&gt;next;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	 if(list1==NULL &amp;&amp; list2!=NULL)</span></span><br><span class="line"><span class="comment">	*/</span>		 </span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">xx</span>=<span class="title">list1</span>;</span></span><br><span class="line">      <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	  sum = list1-&gt;num+list2-&gt;num+adding;</span><br><span class="line">	  list1-&gt;num = sum%<span class="number">10</span>;</span><br><span class="line">      adding = sum/<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;<span class="comment">//常规情况，两个同长度部分</span></span><br><span class="line">			 list1 = list1-&gt;next;</span><br><span class="line">			 list2 = list2-&gt;next;</span><br><span class="line">			 sum= list1-&gt;num+list2-&gt;num+adding;</span><br><span class="line">			 list1-&gt;num = sum %<span class="number">10</span>;</span><br><span class="line">			<span class="comment">// printf("%d ",list1-&gt;num);</span></span><br><span class="line">             adding = sum/<span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(list1-&gt;next!=<span class="literal">NULL</span> &amp;&amp; list2-&gt;next!=<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(list1-&gt;next ==<span class="literal">NULL</span>&amp;&amp; list2-&gt;next==<span class="literal">NULL</span> &amp;&amp;adding!=<span class="number">0</span>)<span class="comment">//串1短于串2</span></span><br><span class="line">	&#123;</span><br><span class="line">			list1-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">			list1-&gt;next-&gt;num= adding;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"show:%d\n"</span>,adding);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(list1-&gt;next==<span class="literal">NULL</span> &amp;&amp; list2-&gt;next !=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">			list1-&gt;next = list2-&gt;next;</span><br><span class="line">			<span class="keyword">while</span>(list2-&gt;next!=<span class="literal">NULL</span>&amp;&amp;adding !=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">              list2=list2-&gt;next;</span><br><span class="line">			  sum= list2-&gt;num+adding;</span><br><span class="line">              list2-&gt;num=sum%<span class="number">10</span>;</span><br><span class="line">			  adding = sum/<span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(adding&gt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">					list2-&gt;next=(struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">		            list2-&gt;next-&gt;num=adding;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">    ...<span class="comment">//串1长于 串2</span></span><br><span class="line">    .....</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要思考，当进位到最后时，可能1,2都结束了，但是产生高位，此时要new　listnode 完成</span></span><br><span class="line"><span class="comment">//或者剩下２，和进位，则考虑２加进位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list1</span>,*<span class="title">list2</span>;</span></span><br><span class="line">  list1 = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">  list2 = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">  list1-&gt;num=<span class="number">3</span>;</span><br><span class="line">  list2-&gt;num=<span class="number">5</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmplist1</span>=<span class="title">list1</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmplist2</span>=<span class="title">list2</span>;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">9</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">	list1-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">	list2-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">	list1 = list1-&gt;next;</span><br><span class="line">	list2 = list2-&gt;next;</span><br><span class="line">    list1-&gt;num = <span class="number">2</span>;</span><br><span class="line">	list2-&gt;num= <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  list2-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">  list2-&gt;next-&gt;num=<span class="number">9</span>; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">result</span>=<span class="title">tmplist1</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">freelist1</span> = <span class="title">tmplist1</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">freelist2</span> = <span class="title">tmplist2</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++,tmplist1=tmplist1-&gt;next)</span><br><span class="line">		  <span class="built_in">printf</span>(<span class="string">"%d "</span>,tmplist1-&gt;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++,tmplist2=tmplist2-&gt;next)</span><br><span class="line">		  <span class="built_in">printf</span>(<span class="string">"%d "</span>,tmplist2-&gt;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  Add_two_num(freelist1,freelist2);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;result!=<span class="literal">NULL</span> ;i++,result=result-&gt;next)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d "</span>,result-&gt;num); </span><br><span class="line">  <span class="built_in">free</span>(freelist1);</span><br><span class="line">  <span class="built_in">free</span>(freelist2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list11</span>,*<span class="title">list22</span>;</span></span><br><span class="line">  list11 = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">  list22 = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> num1[<span class="number">100</span>],num2[<span class="number">100</span>];</span><br><span class="line">  gets(num1);</span><br><span class="line">  gets(num2);</span><br><span class="line">  changtolist(list11,num1,list22,num2);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">result11</span> = <span class="title">list11</span>;</span></span><br><span class="line">  Add_two_num(list11,list22);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;result11!=<span class="literal">NULL</span> ;i++,result11=result11-&gt;next)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d "</span>,result11-&gt;num); </span><br><span class="line">  <span class="built_in">free</span>(list11);</span><br><span class="line">  <span class="built_in">free</span>(list22);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//思考，扩大这道题的应用，在大数相加的时候，增加用户输入接口:”<br>//5263565656554+5656537677834546<br>//由char读入，int/char相加，<br>——-极其丑的程序，以后不能这么搞，留个纪念<br>想贴下两年多前（大三吧，那会刷这道题通过的程序–看来最喜欢的还是c）<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	 <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">		 ListNode *sum, *l4;</span><br><span class="line">		 sum = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//新节点</span></span><br><span class="line">		 l4 = sum;</span><br><span class="line">		 <span class="keyword">int</span> sum_single, en = <span class="number">0</span>;<span class="comment">//en表示进位的标志</span></span><br><span class="line">		 <span class="keyword">while</span> (l1 != <span class="literal">NULL</span>&amp;&amp;l2 != <span class="literal">NULL</span>)</span><br><span class="line">		 &#123;</span><br><span class="line">			 </span><br><span class="line">				 sum-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//这里有个问题变为sum=NULL就行</span></span><br><span class="line">				 sum = sum-&gt;next;</span><br><span class="line">			<span class="comment">// signal = 0;</span></span><br><span class="line">			 sum_single = l1-&gt;val + l2-&gt;val + en;</span><br><span class="line">			 <span class="keyword">if</span> (sum_single&lt;<span class="number">10</span>)</span><br><span class="line">			 &#123;</span><br><span class="line">				 sum-&gt;val = sum_single;</span><br><span class="line">				 en = <span class="number">0</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">else</span> <span class="keyword">if</span> (sum_single &gt;= <span class="number">10</span>)</span><br><span class="line">			 &#123;</span><br><span class="line">				 sum-&gt;val = sum_single - <span class="number">10</span>;</span><br><span class="line">				 en = <span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 l1 = l1-&gt;next;</span><br><span class="line">			 l2 = l2-&gt;next;</span><br><span class="line">		</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">while</span> (l1 != <span class="literal">NULL</span>&amp;&amp;l2 == <span class="literal">NULL</span>)</span><br><span class="line">		 &#123; </span><br><span class="line">			 sum-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">			 sum = sum-&gt;next;</span><br><span class="line">			 sum_single = en + l1-&gt;val;</span><br><span class="line">			 <span class="keyword">if</span> (sum_single &gt;= <span class="number">10</span>)</span><br><span class="line">			 &#123;</span><br><span class="line">				 sum-&gt;val = sum_single - <span class="number">10</span>;</span><br><span class="line">				 en = <span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">else</span></span><br><span class="line">			 &#123;</span><br><span class="line">				 sum-&gt;val = sum_single;</span><br><span class="line">				 en = <span class="number">0</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 l1 = l1-&gt;next;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">while</span> (l2 != <span class="literal">NULL</span>&amp;&amp;l1 == <span class="literal">NULL</span>)</span><br><span class="line">		 &#123; </span><br><span class="line">			 sum-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">			 sum = sum-&gt;next;</span><br><span class="line">			 sum_single = en + l2-&gt;val;</span><br><span class="line">			 <span class="keyword">if</span> (sum_single &gt;= <span class="number">10</span>)</span><br><span class="line">			 &#123;</span><br><span class="line">				 sum-&gt;val = sum_single - <span class="number">10</span>;</span><br><span class="line">				 en = <span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">else</span></span><br><span class="line">			 &#123;</span><br><span class="line">				 sum-&gt;val = sum_single;</span><br><span class="line">				 en = <span class="number">0</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 l2 = l2-&gt;next;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>&amp;&amp;l2 == <span class="literal">NULL</span>&amp;&amp;en == <span class="number">1</span>)</span><br><span class="line">			 sum-&gt;next = <span class="keyword">new</span> ListNode(en);</span><br><span class="line">		<span class="comment">//if(l1==NULL&amp;&amp;l2==NULL&amp;&amp;en==0)sum = NULL;</span></span><br><span class="line">	<span class="comment">/*	 while (l3)</span></span><br><span class="line"><span class="comment">		 &#123;</span></span><br><span class="line"><span class="comment">			 cout &lt;&lt; l3-&gt;val;</span></span><br><span class="line"><span class="comment">			 l3 = l3-&gt;next;</span></span><br><span class="line"><span class="comment">		 &#125;*/</span></span><br><span class="line">		 <span class="keyword">return</span> l4-&gt;next;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Solution sou;</span></span><br><span class="line"><span class="comment">    ListNode *l1,*l2,*l3;</span></span><br><span class="line"><span class="comment">    l1=new ListNode(3);</span></span><br><span class="line"><span class="comment">    l1-&gt;next=new ListNode(7);</span></span><br><span class="line"><span class="comment">    l1-&gt;next-&gt;next=new ListNode(5);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     l2=new ListNode(7);</span></span><br><span class="line"><span class="comment">    l2-&gt;next=new ListNode(7);</span></span><br><span class="line"><span class="comment">    l2-&gt;next-&gt;next=new ListNode(5);</span></span><br><span class="line"><span class="comment">    l3=sou.addTwoNumbers(l1,l2);</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;l3-&gt;val&lt;&lt;l3-&gt;next-&gt;val&lt;&lt;l3-&gt;next-&gt;next-&gt;val;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode_linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_IP</title>
    <url>/2018/06/03/tcpip-IP/</url>
    <content><![CDATA[<h3 id="IP-协议和路由"><a href="#IP-协议和路由" class="headerlink" title="IP 协议和路由"></a>IP 协议和路由</h3><h4 id="IP的作用–路由"><a href="#IP的作用–路由" class="headerlink" title="IP的作用–路由"></a>IP的作用–路由</h4><h5 id="路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作"><a href="#路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作" class="headerlink" title="路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?"></a>路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?</h5><ol>
<li><p>从广义上讲，路由是路线图，就像百度地图上源地址到目的地址的路线，路线有很多，故路由也很多；  <a id="more"></a><br>从网络层面讲，路由是一个数据包从源地址到目的地的传输路径，它如何被决定怎么走，即中间经过哪些路由器，选择哪一条路线等等。</p>
</li>
<li><p>一个数据包在网络上传输实例：<br>A,B连上AP进行上网，AP和外网连接，AP的下一站是D;<br>A 在构造了数据包后选择发送，要查询路由表，若该数据包发送给B,则通过路由表中的直连路由，找到B的ip,发送时不知道B的mac地址，故先做arp,得到后将数据包发给B:<br>数据包：源ip：A,源mac A ，目的IP:B,目的mac:B<br>若A在构造了数据包后，查询路由，该数据包是发送给外网，目的地址是百度ip,则无此条目，向默认路由；即发给路由器，此时若不知道mac地址会做arp;<br>数据包：源ip:A,源mac：A  ,目的ip:百度，目的mac：路由器(arp代理）<br>数据包到路由器后，将做下一步转发：<br>在路由发送的数据包：源ip:路由外网地址，源mac:路由，目的ip:百度ip.目的mac,D<br>(注意，在源ip改为路由外网地址后，此时ip唯一，源地址在传输过程中不会再改变）  </p>
</li>
<li><p>内网的路由器会将源地址改为路由器的外网地址<br>—想想像192.168.0.4这样的源地址是内网地址，如果在包的传输过程中不做处理，到达目的地如QQ的服务器，那QQ处理完要发给你，这时得到包是从192.168.0.4来的，它作为内网地址，全世界很多个，怎么决定—–所以ip首部中的源地址和目的地址必须是全球唯一的ip地址，即外网地址；</p>
</li>
<li>路由器会对ttl做减1,然后再重新做校验和–即直接加1</li>
<li>路由器会将数据包的mac首部，源地址改为路由的mac地址，目的地址改为默认路由（或其他导向路由）ip对应的mac地址</li>
</ol>
<h4 id="网络地址和子网"><a href="#网络地址和子网" class="headerlink" title="网络地址和子网"></a>网络地址和子网</h4><p>这里不记录太多的ip地址相关的内容，毕竟比较基础，且协议卷或者网上很多介绍</p>
<h5 id="网络地址简介"><a href="#网络地址简介" class="headerlink" title="网络地址简介"></a>网络地址简介</h5><p>网络地址用来在网络上代表一台设备，就像家庭地址一样，当然现在的设备，如手机可以同时拥有几个ip地址（数据网，wifi，等等，可以理解为家有多个门）<br>而现在的网络地址从32位点分十进制地址，  </p>
<ul>
<li>决定了它的数量–&gt;一个网络中的设备数量决定了它如何划分网络   </li>
<li>网络中的设备数量动态性，可能很少，ip地址不够用–&gt;子网出现（CIDR)  </li>
<li>网络地址不够用了–&gt;NAT出现，内网  </li>
</ul>
<h5 id="网段，网络范围内，由谁主导生效进行实际的网络隔离和连接"><a href="#网段，网络范围内，由谁主导生效进行实际的网络隔离和连接" class="headerlink" title="网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?"></a>网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?</h5><p>—其实本质上，设备间可以通过知道mac地址相互通信，即没有网络的隔离（只要介质支持如wifi,或者有线网下设备能被连在一起)在二层上考虑的    </p>
<ul>
<li>到了三层，ip层，设备与设备之间的通信，取决于网络的大小，在同一个局域网中，设备间可以直接通信，但是不同局域网，就必须借助路由器，网络，为什么?<br>首先，考虑他们的距离，若很远，则单纯直连很难，则需要转发，转发单知道mac地址（好吧，假设一开始知道对方的mac地址），很难像现在用ip地址的方式去找到它emm感觉考虑到协议设计了。。。<br>其次，考虑相邻的不同网络，对应不同的网段，路由表规定了只能和该网络地址范围的主机直接连接，否则就要用默认路由了</li>
<li>考虑这样一个例子：A 在子网192.168.0.0中，地址为192.168.0.3,B在子网10.170.3.0,地址为10.170.3.2,使用wifi,他们之间相邻，此时，A向B发送ARP请求，广播帧，所以B可以接收到，接着B给A回复了响应帧，单波能收到，因为在二层传递，能接收到，不被内核过滤，此时arp表中应该多了条目；接着为了能在三层通信，在路由表中增加一条路由指示不同网段的一个地址，表示他们可以直连，接着测试看看能不能相互发送ip包，ping通，当然可能因为防火墙等；就理论而言，应该是能通的，没试过~–&gt;问题总结：IP地址网段不同的两个设备，一定不能直接通信码?<ul>
<li>网关地址必须是.1结尾码?<br>恩当然可以是别的地址</li>
<li>路由表和路由规则决定了这些<br>路由表如何决定了网络的方向，下一跳，和限制了网络范围？</li>
</ul>
</li>
</ul>
<h5 id="IP封包简介"><a href="#IP封包简介" class="headerlink" title="IP封包简介"></a>IP封包简介</h5><ul>
<li>ip封包网上能找到详情，这里记录几个注意点：</li>
<li>网络字节序的概念，是大端字节序，传输的次序是先0-7bit—最后到24-31这样，所以小端的设备需要线转换为网络字节序再传输</li>
<li>首部长度字段是指占32bit的数量，有4bit，最大1111*4bytes=60bytes,即ip首部最长为60字节，普通ip同不带选项时是20字节</li>
<li>服务类型现在已经不怎么用，主要是指在不同服务下拥有不同的最小时延，最大吞吐，最高可靠性的情况，具体见协议卷１图3-2</li>
<li>总长度，指整个ip数据包的长度，包含首部和数据报，16位，即最大2^16=65535个字节，（考虑超级通道的mtu=65535并非是真正的mtu,而是最长ip数据报），数据报分片时会随着变化</li>
<li>标示和分片偏移等后面补充</li>
<li>校验和为ip首部校验和:首先校验和设置为0，接着每个16bit进行反码求和。rfc1071</li>
</ul>
<h4 id="网络的拓扑结构"><a href="#网络的拓扑结构" class="headerlink" title="网络的拓扑结构:"></a>网络的拓扑结构:</h4><p>理论上，网络中的每台设备都能相互通信，即使是点对点通信p2p.但是这要求设备能在网络上被唯一标示，如外网ip地址；</p>
<ul>
<li>所以常见的设备A和B的通信借助服务器如：<br>主机A<-->路由器(给主机唯一标识)<-->服务器<-->路由器<-->主机B<br>(现有的大部分通信软件等都是这样的)</--></--></--></--></li>
<li>而主机A可以直接和主机B通信不通过服务器吗?<br>答案是可以，我们使用的迅雷，bt,这些下载资源就是利用的各个主机的资源，其结构如何：<br>主机A<-->路由器(做NAPT等)<-->路由器<-->主机B<br>那和主机A和B如何在网络上被唯一标示，且被B知道该地址呢?路由器在其中充当什么角色，会做什么限制呢？<br>见下NAT和NAT穿透<h4 id="路由深入–NAT和NAT穿透"><a href="#路由深入–NAT和NAT穿透" class="headerlink" title="路由深入–NAT和NAT穿透"></a>路由深入–NAT和NAT穿透</h4>感谢这两篇文章把我带进门：<br><a href="https://blog.csdn.net/u012908515/article/details/53518062" target="_blank" rel="noopener">https://blog.csdn.net/u012908515/article/details/53518062</a><br><a href="https://blog.csdn.net/ustcgy/article/details/5655050" target="_blank" rel="noopener">https://blog.csdn.net/ustcgy/article/details/5655050</a><br>rfc ：nat<br><a href="https://tools.ietf.org/html/rfc1631" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1631</a><br><a href="https://tools.ietf.org/html/rfc2663" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2663</a><br>rfc：p2p<br><a href="https://tools.ietf.org/html/rfc5694" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc5694</a><h5 id="NAT的由来"><a href="#NAT的由来" class="headerlink" title="NAT的由来"></a>NAT的由来</h5></--></--></--></li>
<li>NAT的出现是因为ipv4的地址不够用，所以大量主机在内网使用内网地址，这样在互联网上通信的时候不能被寻找到，此时路由器将内网的设备发送的包中的ip转换为外网的ip,并记录映射在路由器中，这样就能实现主机在互联网上的正常通信，即发包和收包都能找到；</li>
<li>而这种方式阻碍了不同内网的主机之间的通信，即p2p;<h4 id="NAT的分类（路由器决定）"><a href="#NAT的分类（路由器决定）" class="headerlink" title="NAT的分类（路由器决定）"></a>NAT的分类（路由器决定）</h4></li>
<li>静态NAT:即内网的一个IP对应外网的一个IP，且一一对应，即每次分配的时候都是相同的，永久的</li>
<li>动态NAT：即内网的一个IP对应外网的一个IP,但是每次分配的外网IP可能不同，映射不同</li>
<li>NAPT:即为了使同一个外网IP能被多个内网的主机使用而出现；<br>如何区分各个主机？即路由器发包时和收包时，如收包时，如何确定该包是发给主机A还是B?即用NAPT,IP加端口号的形式来区分  </li>
<li>NAPT分为以下两大类：cone锥形NAT和symmetric 对称NAT</li>
</ul>
<ol>
<li>cone NAT的特点是对内网的主机A，和外网所有的服务器通信，都使用相同的端口号；<br>如：内网：192.168.4.5:4323–&gt;server:222.33.22.334:80<br>则经过路由器：外网ip:122.332.43.32:1234–&gt;server:22…路由器把源地址改为122.332.43.32:1234后发送<br>进过服务器2也是类似的，使用同一个端口1234<br>//这里有个疑问，即内网下相同的ip地址，不同的端口时，经过路由器转换后是否为不同端口<br>考虑在接收服务器回复的内容时:<br>222.33.22.334:80–&gt;122.332.43.32：1234此时路由器根据映射，即端口122.332.43.32：1234对应的是192.168.4.5把目的地址和端口更改为它后发送。所以为了能让包在主机内找到对应端口的程序，路由器的设置应为内网同ip不同端口，映射外网的ip+不同端口（待验证）</li>
</ol>
<ul>
<li>锥形NAT类型：完全锥形full cone和受限锥形( restricted cone) 以及端口受限锥形（port restricted cone)  <ul>
<li>完全锥形：任何知道主机B银蛇在NAT上的外部地址和端口的主机都可以通过它发包给内部主机B,即使A在内网(在内网时通过映射的外网地址）</li>
<li>受限锥形：只有内部主机B向其发送过包的主机A才能对这个内部主机B发包（通过主机B映射在外部的地址端口）</li>
<li>端口受限：在受限锥形的基础上加了端口限制</li>
</ul>
</li>
</ul>
<ol start="2">
<li>对称NAT(symmetric nat):<br>会为新的session分配新的端口，即和服务器1通信时使用端口1234，接着发起新的服务器2访问时，使用端口1235等<br>如何检测类型？<a href="https://blog.csdn.net/u012908515/article/details/53518062" target="_blank" rel="noopener">https://blog.csdn.net/u012908515/article/details/53518062</a></li>
</ol>
<h5 id="ipv6不需要NAT"><a href="#ipv6不需要NAT" class="headerlink" title="ipv6不需要NAT"></a>ipv6不需要NAT</h5><p>ipv6地址很多，有人形容世界上的每个沙子都能被定址，所以地址够用，也就不用内网，所以用来做p2p更适用，自然也就不用什么nat转换</p>
<h5 id="p2p网络架构和内网穿透"><a href="#p2p网络架构和内网穿透" class="headerlink" title="p2p网络架构和内网穿透"></a>p2p网络架构和内网穿透</h5><p>基于上面的napt类型介绍，可以知道内网的主机如何和外网的服务器通信，那内网的主机1如何和另一个内网的主机2直接通信?（不借助服务器）<br>答案:基于上面的限制，有几种方案：  </p>
<ul>
<li>针对full cone类型的，内网主机2只要知道内网主机1映射到外部的ip地址和端口，就可以直接发送数据包给1，且能接收；</li>
<li>针对受限的cone类型，内网机2像上面的方式是不行的：得满足两个条件：1是知道主机1映射到外部的ip和端口，2是主机1曾向主机2发送过请求，相当于开了个口，显然这个条件下2为服务器或者有公网ip的设备；所以针对此受限的类型，有一下场景+方案：<ul>
<li>场景1：主机1在nat后，打开了和服务器A通信，主机2想和1通信，主机2不在nat后；显然直接向主机1发起请求是不行的，上述条件2不满足，主机1不曾向2发起请求；  </li>
<li>解决方案是，借助服务器A请求主机1做一个反向连接，即向2发起请求，从而打开通道，进而2就可以跟1通信了</li>
<li>场景2：主机1在nat后，主机2在nat后，主机1，2均打开了和服务器A通信，主机1想直接和2通过双方映射到外网的地址端口进行通信 </li>
<li>解决方案：UDP打洞：假如1开始发送一个UDP信息到2的公网地址上,与此同时,他又通过A中转发送了一个邀请信息给2,请求2也给1发送一个UDP信息到1的公网地址上.这时1向2的公网IP发送的信息导致 NAT 1 打开一个处于1的私有地址和2的公网地址之间的新的通信会话,与此同时NAT 2也打开了一个处于2的私有地址和1的公网地址之间的新的通信会话.一旦这个新的UDP会话各自向对方打开了,1和2之间就可以直接通信,而无需A来牵线搭桥了.这就是所谓的打洞技术.一旦这种处于NAT之后的端对端的直连建立之后,连接的双方可以轮流担任对方的”媒人”,把对方介绍给其他的客户端,这样就极大的降低了服务器A的工作量.</li>
<li>场景3：主机1和2处于同一个NAT下，他们却不知道：</li>
<li>解决方案：综合相同内网下主机可以直接相互通信原理：在主机1发送给A的包中携带其内网地址和端口，A从而知道了1的外网端口地址和内网端口地址，相互都发给1,2，若接着1发起请求给2能收到回复说明在同一个内网，否则采用场景2的解决方案</li>
<li>场景4：主机1处于多层NAT下</li>
<li>问题：udp空闲状态下超时断开的问题：使用心跳包</li>
<li>扩展：tcp的打洞，同时开放tcp连接，原理类似，较复杂</li>
</ul>
</li>
<li>针对对称性的cone,不定因素多，不建议写</li>
<li>所以p2p网络即是多个内网主机1,2,3,4等之间的相互直接通信，即他们之间的下载数据可以相互共享，也就是平常说的挂种子，bt下载，也是为什么能达到那么快速的原因;当然可想这个过程和普通的cs架构区别：</li>
<li>p2p架构，bt模型（猜测)：首先客户端负责下载和挂种的基本功能。下载:需要向服务器取得可以获取资源的主机的nat外网地址和ip,接着服务器为其打洞，将正在挂种的客户ip等提供给该客户端，从而能下载；挂种：给服务器声明自己能提供资源，并通过心跳维持一个持续的洞；BT服务器做什么?综合客户端资源和打洞，即让下载方能方访问挂种放 。   这个过程需要考虑：下载方面对多个挂种方，如何下载文件块和组装，最多同时和几个挂种方下载等等；</li>
<li>回忆：之前学校的rs bt站就是这样，只是开放在学校的内网，可以说是相同nat下的不同主机???好像也不能这么说。。然后采用的原理就是上述的，记得一开始速度不是很快，但是后面15年吧，下载速度能达到10+m/s,很快的，我想可能是优化了下载多个挂种方的方案，增加了最多的下载源，或者学校的网络变优～<h5 id="Cbitterrot源码分析（待"><a href="#Cbitterrot源码分析（待" class="headerlink" title="Cbitterrot源码分析（待~)"></a>Cbitterrot源码分析（待~)</h5><a href="https://linux.cn/thread-5529-1-1.html" target="_blank" rel="noopener">https://linux.cn/thread-5529-1-1.html</a><br>对于p2p架构的软件设计，其实跟平常的cs架构很象，都需要用到socket等</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_ip</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_MAC</title>
    <url>/2018/06/02/tcpip-MAC/</url>
    <content><![CDATA[<h3 id="mac数据链路层的理解"><a href="#mac数据链路层的理解" class="headerlink" title="mac数据链路层的理解"></a>mac数据链路层的理解</h3><h4 id="mac层的功能介绍"><a href="#mac层的功能介绍" class="headerlink" title="mac层的功能介绍"></a>mac层的功能介绍</h4><p>mac层在理论上赋予了较全的功能，但是其实，实际上在使用的时候，由于无噪声通道，或者一些功能交给了上层的协议，所以实际的mac功能没有理论那么全面。mac层的实现包括在驱动和固件中，所以实际的功能得看芯片和固件的支持，比如是否支持监听模式；  <a id="more"></a><br>理论上：建议书籍《数据通信与网络》<br>寻址：实际的端到端通信，都是需要先知到对方的mac地址(通过arp),才能进行实际传输的；<br>帧构建：这一层结束后就是完成了包封装，下一步传送给物理层编码发送了；<br>数据差错检查；传送控制，流量控制，差错控制，编码，校验和等等；，编码是指在原始数据mac封包后，在实际传输时进行编码（按照某个80x协议等，这个属于偏物理层的事情了）<br>实际上：数据差错检查，流量控制，差错控制等都没做，或者要看具体的厂商实现如高通，mtk等</p>
<h4 id="mac层的传输限制"><a href="#mac层的传输限制" class="headerlink" title="mac层的传输限制"></a>mac层的传输限制</h4><p> 考虑一个包从电脑发出去，最后一次封包根据接口不同(有线，无线),协议不同，采用的mac头也不同，如ppp协议要加其他信息；<br> –&gt;简述:接着可能发给无线路由器或者交换机，路由器会判断是wifi的mac头，接着要向以太网传输时，或者无线传输时，需要去掉mac头，并加上自己的mac头，改变mac源地址为自己，目的地址为(路由表对应)arp寻找的下一跳mac地址;若为以太网，还要转换为以太网的头类型等<br> …<br> 整个过程，从物理层角度看，是可以顺利进行的，但是实际为了效率，不接受无用的包，不发送无效的包和安全等，在驱动和固件都会有做相应的过滤处理，从而使发包收包，转发包等受到了限制，见下实验等；</p>
<h4 id="mac层的封包-mtu-msdu-mpdu"><a href="#mac层的封包-mtu-msdu-mpdu" class="headerlink" title="mac层的封包,mtu,msdu,mpdu"></a>mac层的封包,mtu,msdu,mpdu</h4><p>在包的封装上，有线网和无线网不同，更确切的是协议不同，其mac层封包也不同–对相同的ip包(ip头+上层数据/arp/…）带有不同的mac头：<br>例如对以太网（有线）：常见有一下四种mac头封装的帧：</p>
<ul>
<li>EthernetII:  dest addr+src addr+type+data+fcs</li>
<li>Ethernet 802.2:dest addr+srcaddr+len+ llc+data+fcs</li>
<li>Ethernet 802.3:dest addr+src addr+len+data+fcs </li>
<li>Ethernet SNAP:dest addr+src addr+len+llc+snap+data+fcs<br>参考：<a href="https://blog.csdn.net/xiao628945/article/details/8006022" target="_blank" rel="noopener">https://blog.csdn.net/xiao628945/article/details/8006022</a><br>针对无线网络：802.11n等，更复杂些：</li>
<li>802.11头+msdu(数据部分)+fcs(crc)<br>而802.11wifi无线帧分为控制帧，管理帧和数据帧，因为在无线网络中的安全性等考虑，需要扫描，关联，认证四次握手等步骤,在802.11头就包含了subtype，即数据部分是什么类型（控制，。。）<a href="https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末" target="_blank" rel="noopener">https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末</a><br><a href="https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了" target="_blank" rel="noopener">https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了</a><br>这么多的封包类型，除却ip层只有一种，那在传递的过程中如何处理?即有线到无线，怎么识别?答案是在路由器，主机中进行去头和加头<br>不同厂商实现不同，在无线中，非数据帧部分：底层的实现分为full mac driver（Full Mac的Driver，一般Auth和Assoc的包直接在芯片里边处理了，Driver通过command形式告诉Firmware要连接AP的信息，Firmware处理了Assoc Response之后，report给Driver一个Event，说明连接的情况（result和AID）以及assoc相关的IE，Driver会直接调用cfg80211的接口报告给supplicant，然后处理EAPOL的握手过程，因为之后的EAPOL Data的处理会用到Assoc Response里边的IE）  而用soft mac则软件可以控制较多的事情(Soft Mac模块开源代码mac80211的WiFi芯片，会将这两种包送到Mac80211处理，mac80211处理完后调用cfg80211的接口通过nl80211(netlink)通知wpa_supplicant准备认证以及四次握手的状态机，等待处理EAPOL包，EAPOL是二层的Data包，会在Supplicant里边处理，连接加密的路由情况就是这样处理的，如果不加密，那就直接DHCP了)；扯远了。。<br>在pc等设备中，在封装到数据链路层时，封装时用的是ethernetII，到底层驱动时就被替换为对应的802.11的头了，进而发送出去，而在接收数据包的时候，底层上报上来又会把802.11格式的转换为ehternetII的形式，所以我在实验wifi的时候，用的PF_PACKET来操作数据包，加的是ethernetII的头，接收到打印出来后还是ethernetII的头<br>晒张空中包的和本地tcpdump抓到的包对比：<br>//to do</li>
</ul>
<p>当然除却mac头的不同，mtu的概念还是存在:<br>mac层在传输时一次传输一帧，这一帧即是封装了mac头的数据包，它常为[46-1500]+mac头,而mtu即是最大的传输单元，是去掉mac头的负载部分最大值，如1500<br>而在实际传输的空中包，情况又可能不同，这里看msdu 和mpdu:<br><a href="https://blog.csdn.net/zhengnice/article/details/51923132" target="_blank" rel="noopener">https://blog.csdn.net/zhengnice/article/details/51923132</a><br>这篇文章讲的很好，在理解了上述的内容后，看这篇文章里面的msdu和mpdu就能很好的理解了，spec的416页也有相关的内容</p>
<h5 id="mac头格式：不同协议可能不同："><a href="#mac头格式：不同协议可能不同：" class="headerlink" title="mac头格式：不同协议可能不同："></a>mac头格式：不同协议可能不同：</h5><p>常见：dest addr,src addr ,proto type; 14byte<br>见上文</p>
<h4 id="mac层的发包和收包限制"><a href="#mac层的发包和收包限制" class="headerlink" title="mac层的发包和收包限制"></a>mac层的发包和收包限制</h4><p>考虑一个问题，即在不考虑网络网段的情况下，两台设备在开启wifi或者连接网线的情况下，能相互直接通信吗？<br>从理论上是可以的，首先是发送，无问题，接收，可以接收；其次，接收之后解码，需要双方使用相同的编码协议等；<br>其次：实际上，需要几个条件，且有线和无线的方式不同：</p>
<ul>
<li>有线：需要双方相同的编码，直连的情况下，可以直接通信；</li>
<li>无线: (分为数据部分和管理部分，需要双方相同的编码)，但是仅开启wifi，只能接收小量信息的beacon帧；即wifi为了安全性，效率等(wifi本身可以接收所有数据），做了连接前的扫描，关联认证，四次握手等过程，并且对mac地址进行过滤，使不同网段的两个相邻设备不能通过直接发送接收mac层数据来交互；具体见厂商的实现，可以参考实验部分；  </li>
<li>所以关键看厂商怎么实现，底层的东西，他们提供接口给你，你就能操作了balalal<h5 id="普通模式，混杂模式和监听模式"><a href="#普通模式，混杂模式和监听模式" class="headerlink" title="普通模式，混杂模式和监听模式"></a>普通模式，混杂模式和监听模式</h5><h4 id="mac层的几个实验"><a href="#mac层的几个实验" class="headerlink" title="mac层的几个实验"></a>mac层的几个实验</h4>普通模式下，wifi实验，以station架构进行：<br>设备A，B,路由器C，D;  </li>
<li>A,B连接同一个路由器C,A,B通过PF_PACKET发送和接收mac头加任意数据，成功发送接收，即使arp表无对方的条目  </li>
<li>A,B都不连接wifi,只是打开wifi，此时无法发送和接收数据，厂商默认的只会发送主动扫苗和接收beacon帧，扫描的具体过程待文章写,在没有连接上时，只会发送小数据</li>
<li>A,B间任意设备连上路由器，同上</li>
<li><em>A连接路由C,B连接路由D,相互发送和接收mac头加任意数据，目的地址为对方mac，源地址为自己的mac—失败，其实一开始是怀着疑问的，从理论分析是可以的，但是还是不行，若只是在二层的话，对方怎么知道这个源mac地址是在不同网段并做过滤?难道发之前，底层进行了隐式arp？但是我发的包里面没有带ip信息啊，同时进行了广播帧的发送接收，还是失败了；应该都是出在接收的环节；也有可能是两个ap使用的协议不同导致编码方式不同从而接收失败</em></li>
<li>考虑到可能是两个路由器编码和使用的协议如一个是802.11n,一个是ac，等，可能导致接收不到，所以可以再尝试使用两个相同的型号的路由器；//待测试</li>
<li>发送方普通模式，接收方监听模式，接收方可以收到所有包，所以可以接收到</li>
</ul>
<h4 id="openwrt开源路由系统，驱动，固件"><a href="#openwrt开源路由系统，驱动，固件" class="headerlink" title="openwrt开源路由系统，驱动，固件"></a>openwrt开源路由系统，驱动，固件</h4><p>了解一下。。。<br>spec:Wireless LAN Medium Access Control<br>(MAC)<br>and Physical Layer (PHY) Specifications</p>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_ARP</title>
    <url>/2018/05/27/tcpip-ARP/</url>
    <content><![CDATA[<h3 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h3><h4 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h4><ul>
<li>ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信；</li>
<li>在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：<br>端设备手机pc等–&gt;(交换机)路由器—&gt;下一个路由器—&gt;下一个终端设备  <a id="more"></a><br>端设备默认路由到网关–&gt;网关收到包后，将源地址改为网关的外网地址—&gt;下一个路由–&gt;….-&gt;设备地址为目的地址时，接收而不转发</li>
<li>考虑一个问题：在上述的网络上发送时，如pc发给路由器时，只知道它的ip地址，怎么发给它：<br>即端到端的发送：是借助设备唯一的mac地址来发送的<br>在有线网中。利用了交换机的端口和mac地址关系，转发<br>在wifi中，能接收到所有的包，但是会在驱动中将mac目的地址非本地的包丢弃，除非开启了混杂监听模式</li>
<li>但是路由器怎么知道设备如手机的mac地址呢？<br>通过arp协议来获取，arp是依赖mac和ip的”映射”</li>
<li>tcpip卷1中4.2举了一个完整的例子，可以去看<h4 id="ARP协议的交互过程"><a href="#ARP协议的交互过程" class="headerlink" title="ARP协议的交互过程"></a>ARP协议的交互过程</h4></li>
<li>基本的交互方式：<br>例如ping网关：<br>station  —ARP request—-&gt;   AP  ARP请求，广播帧<br>station  &lt;—ARP response —  AP  ARP应答 ,单播帧<br>通过上述的方式，station得到了AP的mac地址，之后将AP的MAC地址存在缓存中，在下次数据包等包的时候就可以将该mac地址填在mac头中，即知道了AP的地址后，包就可以顺利的被AP接收了</li>
<li>AP(路由器)也会主动的向station发送arp request，当它不知道station的mac地址（或缓存过期），例如，AP收到一个外网的包，要转发给对应192.168.0.4的staton,但是没有他的mac地址，或者过期了或者其他情况，则向该station发出arp请求。从而得打station的mac地址</li>
<li>什么时候会触发arp请求？<br>1.在ping的时候<br>2.在发送tcp，ip包的时候<br>3.在缓存过期时主动发出，这个由arp状态机中实现<h4 id="ARP代理和免费ARP"><a href="#ARP代理和免费ARP" class="headerlink" title="ARP代理和免费ARP"></a>ARP代理和免费ARP</h4></li>
<li>当我们通过ping百度，或者想访问百度的时候，怎么在mac头中填写目的mac地址呢？即怎么找到百度?（另一个网络)</li>
<li>是通过在mac头目的mac地址填写网关的mac地址实现的，借助w网关的来帮我们寻找，这个叫做ARP代理,其实欺骗了主机</li>
<li>tcpip卷对此有较详细解说4.6</li>
<li>免费ARP是用于检测是否周围有使用相同的ip地址的设备，即通过ping自己，寻找有自己的ip的主机<h4 id="ARP协议的包封装格式和抓包分析"><a href="#ARP协议的包封装格式和抓包分析" class="headerlink" title="ARP协议的包封装格式和抓包分析"></a>ARP协议的包封装格式和抓包分析</h4></li>
<li>分组格式：  ()为字节数<br>mac头：以太网目的地址(6) mac源地址(6) 帧类型(2)(0x0806)<br>28byte arp帧：硬件类型(2)|协议类型(2)|硬件地址长度(1)|协议地址长度(1)|op(请求或应答或rarp 2)|发送端mac地址(6)|发送端ip(4)|接收端mac地址(6)|接收端ip(4)  </li>
<li>请求广播帧：目的mac地址为全1，电缆上所有的以太网接口都要接收广播帧,硬件类型为1表示以太网地址，协议类型为要映射的协议地址类型0x0800,表示为ip地址，op（arp请求为1，答应为2，rarp请求为3，rarp答应为4）</li>
<li>arp填充：以太网帧最小值为60，mac头14，所以=46，要填充：46-28=18个字节</li>
<li>arp抓包，可以用wireshark,Omnipeek - Savvius,tcpdump,或者自己写一个程序来抓～<br>tcpdump : sudo tcpdump -vv arp  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> tcpdump: listening on wlp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">21.134575</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span> <span class="comment">//ap ask me</span></span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">21.135404</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span></span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">21.135413</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Reply <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> is-at <span class="number">48</span>:<span class="number">5</span>a:b6:<span class="number">6</span>e:c9:<span class="number">5f</span> (oui Unknown), length <span class="number">28</span><span class="comment">// i reply ap</span></span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">32.081916</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.106</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span> <span class="comment">//ask other</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">01</span>:<span class="number">27.149947</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.107</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span></span><br><span class="line">	<span class="number">0x0000</span>:  <span class="number">0001</span> <span class="number">0800</span> <span class="number">0604</span> <span class="number">0001</span> <span class="number">206b</span> e70f <span class="number">1b</span>42 c0a8  .........k...B..</span><br><span class="line">	<span class="number">0x0010</span>:  <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> c0a8 <span class="number">006b</span>            ...........k</span><br><span class="line">    </span><br><span class="line">    <span class="number">22</span>:<span class="number">04</span>:<span class="number">17.114593</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Reply <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> is-at <span class="number">48</span>:<span class="number">5</span>a:b6:<span class="number">6</span>e:c9:<span class="number">5f</span> (oui Unknown), length <span class="number">28</span></span><br><span class="line">	<span class="number">0x0000</span>:  <span class="number">0001</span> <span class="number">0800</span> <span class="number">0604</span> <span class="number">0002</span> <span class="number">485</span>a b66e c95f c0a8  ........HZ.n._..</span><br><span class="line">	<span class="number">0x0010</span>:  <span class="number">006</span>e <span class="number">206b</span> e70f <span class="number">1b</span>42 c0a8 <span class="number">0001</span>            .n.k...B....</span><br></pre></td></tr></table></figure>
<h4 id="ARP协议的常用命令和调试分析"><a href="#ARP协议的常用命令和调试分析" class="headerlink" title="ARP协议的常用命令和调试分析"></a>ARP协议的常用命令和调试分析</h4><ul>
<li>查看ARP缓存：即现在保存的arp映射表:  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">arp</span> <span class="selector-tag">-a</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.101</span>) <span class="selector-tag">at</span> 4<span class="selector-tag">c</span><span class="selector-pseudo">:32</span><span class="selector-pseudo">:75</span><span class="selector-pseudo">:3a</span><span class="selector-pseudo">:09</span><span class="selector-pseudo">:b3</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.1</span>) <span class="selector-tag">at</span> 20<span class="selector-pseudo">:6b</span><span class="selector-pseudo">:e7</span><span class="selector-pseudo">:0f</span><span class="selector-pseudo">:1b</span><span class="selector-pseudo">:42</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.108</span>) <span class="selector-tag">at</span> 94<span class="selector-pseudo">:d0</span><span class="selector-pseudo">:29</span><span class="selector-pseudo">:9d</span><span class="selector-pseudo">:74</span><span class="selector-pseudo">:dd</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.107</span>) <span class="selector-tag">at</span> 94<span class="selector-pseudo">:65</span><span class="selector-pseudo">:2d</span><span class="selector-pseudo">:ab</span><span class="selector-pseudo">:88</span><span class="selector-pseudo">:8b</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">arp</span> </span><br><span class="line"><span class="selector-tag">Address</span>                  <span class="selector-tag">HWtype</span>  <span class="selector-tag">HWaddress</span>           <span class="selector-tag">Flags</span> <span class="selector-tag">Mask</span>            <span class="selector-tag">Iface</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.101</span>            <span class="selector-tag">ether</span>   4<span class="selector-tag">c</span><span class="selector-pseudo">:32</span><span class="selector-pseudo">:75</span><span class="selector-pseudo">:3a</span><span class="selector-pseudo">:09</span><span class="selector-pseudo">:b3</span>   <span class="selector-tag">C</span>                     <span class="selector-tag">wlp2s0</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.1</span>              <span class="selector-tag">ether</span>   20<span class="selector-pseudo">:6b</span><span class="selector-pseudo">:e7</span><span class="selector-pseudo">:0f</span><span class="selector-pseudo">:1b</span><span class="selector-pseudo">:42</span>   <span class="selector-tag">C</span>                     <span class="selector-tag">wlp2s0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ip neigh</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span> dev wlp2s0 lladdr <span class="number">4</span>c:<span class="number">32</span>:<span class="number">75</span>:<span class="number">3</span>a:<span class="number">09</span>:b3 STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> dev wlp2s0 lladdr <span class="number">20</span>:<span class="number">6b</span>:e7:<span class="number">0f</span>:<span class="number">1b</span>:<span class="number">42</span> STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.108</span> dev wlp2s0 lladdr <span class="number">94</span>:d0:<span class="number">29</span>:<span class="number">9</span>d:<span class="number">74</span>:dd STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.107</span> dev wlp2s0 lladdr <span class="number">94</span>:<span class="number">65</span>:<span class="number">2</span>d:ab:<span class="number">88</span>:<span class="number">8b</span> STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.104</span> dev wlp2s0 lladdr e4:<span class="number">9</span>a:dc:b0:a5:<span class="number">36</span> STALE</span><br></pre></td></tr></table></figure>
<ul>
<li>arping命令：<br><a href="http://man.linuxde.net/arping" target="_blank" rel="noopener">http://man.linuxde.net/arping</a></li>
<li>arp 命令<br>man arp 包括删除arp表项等，有问题，找男人~<h4 id="ARP协议内核状态机"><a href="#ARP协议内核状态机" class="headerlink" title="ARP协议内核状态机"></a>ARP协议内核状态机</h4></li>
<li>对不存在的主机，arp请求的超时机制  </li>
<li>arp缓存和老化时间：<br><a href="http://www.jb51.net/LINUXjishu/65693.html：" target="_blank" rel="noopener">http://www.jb51.net/LINUXjishu/65693.html：</a><br>改变老化时间：在Linux上如果你想设置你的ARP缓存老化时间，那么执行sysctl -w net.ipv4.neigh.ethX=Y即<h4 id="ARP协议的编程"><a href="#ARP协议的编程" class="headerlink" title="ARP协议的编程"></a>ARP协议的编程</h4></li>
<li>在PF_PACKET中发出ARP包</li>
<li>直接贴例子，具体可以看博客的PF_PACKET文章：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取硬件网卡的相应信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="keyword">char</span> *name , <span class="keyword">char</span> *MAC_addr , struct in_addr * IP_addr)</span></span>;</span><br><span class="line"><span class="comment">//arp包的结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ARP_PACKET</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="comment">//以太网首部</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> dest_mac[<span class="number">6</span>]; <span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> sorce_mac[<span class="number">6</span>];<span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> type;       <span class="comment">//2字节</span></span><br><span class="line">  <span class="comment">//arp——内容</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> hw_type;   <span class="comment">//2字节：硬件地址类型     0x0001 表示mac地址</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> pro_type;  <span class="comment">//2字节：软件地址类型    0x0806 表示IPV4地址</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> hw_len;     <span class="comment">//1字节：硬件地址长度  </span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> pro_len;    <span class="comment">//1字节：软件地址长度</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> op;        <span class="comment">//2字节：操作类型           0x0001表示ARP请求；0x0002表示ARP应答</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> from_mac[<span class="number">6</span>];<span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> from_ip[<span class="number">4</span>]; <span class="comment">//4字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> to_mac[<span class="number">6</span>];  <span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> to_ip[<span class="number">4</span>];   <span class="comment">//4字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> padding[<span class="number">18</span>];<span class="comment">//18字节：填充字节，因为以太网数据最少要46字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> MAC_ADDR[<span class="number">6</span>];</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">IP_ADDR</span>;</span><span class="comment">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ARP_PACKET</span> <span class="title">arp_pk</span>=&#123;</span><span class="number">0</span>&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">eth_info</span>;</span><span class="comment">//结构体的定义//在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class="line"> <span class="comment">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class="line"> GetEthInfor(<span class="string">"wlp2s0"</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class="line">   <span class="comment">/*printf("The MAC_addr is:");</span></span><br><span class="line"><span class="comment"> for(i =0 ;i&lt;6;i++)</span></span><br><span class="line"><span class="comment">    printf("%4X",MAC_ADDR[i]); </span></span><br><span class="line"><span class="comment"> printf("\n");</span></span><br><span class="line"><span class="comment">    printf("the IP is:%s\n",inet_ntoa(IP_ADDR));*/</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//第二步：填充ARP数据包的内容</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充以太网首部的目的mac地址</span></span><br><span class="line"> &#123;</span><br><span class="line">  arp_pk.dest_mac[i]=<span class="number">0XFF</span>;      </span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充以太网首部的源mac地址</span></span><br><span class="line"> &#123;</span><br><span class="line">  arp_pk.sorce_mac[i]=MAC_ADDR[i];</span><br><span class="line"> &#125;</span><br><span class="line">   arp_pk.type = htons(<span class="number">0x0806</span>);    <span class="comment">//填充以太网首部的侦类型</span></span><br><span class="line">   arp_pk.hw_type = htons(<span class="number">0x0001</span>); <span class="comment">//填充硬件地址类型：0x0001表示的是MAC地址</span></span><br><span class="line">   arp_pk.pro_type = htons(<span class="number">0x0800</span>);<span class="comment">//填充协议地址类型：0x0800表示的是IP地址</span></span><br><span class="line">   arp_pk.hw_len = <span class="number">6</span>;              <span class="comment">//填充硬件地址长度</span></span><br><span class="line">   arp_pk.pro_len = <span class="number">4</span>;             <span class="comment">//填充协议地址长度</span></span><br><span class="line">   arp_pk.op = htons(<span class="number">0x0001</span>);      <span class="comment">//填充操作类型：0x0001表示ARP请求</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充源mac地址</span></span><br><span class="line">   &#123;</span><br><span class="line">  arp_pk.from_mac[i]=MAC_ADDR[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">in_addr_t</span> ipaddr=inet_network(inet_ntoa(IP_ADDR));</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)                 <span class="comment">//填充源IP地址</span></span><br><span class="line">   &#123;</span><br><span class="line">  arp_pk.from_ip[i]=(<span class="keyword">unsigned</span> <span class="keyword">char</span>)ipaddr&amp;<span class="number">0xFF</span>;</span><br><span class="line">   ipaddr=ipaddr&gt;&gt;<span class="number">8</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"-%d-"</span>,arp_pk.from_ip[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">/* arp_pk.from_ip[0]=192;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[1]=168;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[2]=199;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[3]=145;*/</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充欲获取的目的mac地址</span></span><br><span class="line">   &#123;</span><br><span class="line">    arp_pk.to_mac[i]=<span class="number">0X00</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   arp_pk.to_ip[<span class="number">0</span>]=<span class="number">0X0B</span>;        <span class="comment">//填充想要装换为MAC地址的IP地址。可以使用命令行参数来做</span></span><br><span class="line">   arp_pk.to_ip[<span class="number">1</span>]=<span class="number">0X40</span>;</span><br><span class="line">   arp_pk.to_ip[<span class="number">2</span>]=<span class="number">0X39</span>;</span><br><span class="line">   arp_pk.to_ip[<span class="number">3</span>]=<span class="number">0X0A</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第三步：填充sockaddr_ll eth_info结构</span></span><br><span class="line">    eth_info.sll_family = PF_PACKET;</span><br><span class="line"> eth_info.sll_ifindex = if_nametoindex(<span class="string">"wlp2s0"</span>);<span class="comment">//返回输入的接口名称的索引值</span></span><br><span class="line"> <span class="comment">//printf("number is:%d\n",eth_info.sll_family);</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第四步：创建原始套接字</span></span><br><span class="line"> fd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));  <span class="comment">//</span></span><br><span class="line"> <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"socket SOCK_RAW failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="comment">//第五步：发送ARP数据包</span></span><br><span class="line"> num = sendto(fd , &amp;arp_pk , <span class="keyword">sizeof</span>(struct ARP_PACKET) , <span class="number">0</span> ,(struct sockaddr*)(&amp;eth_info),<span class="keyword">sizeof</span>(eth_info));</span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sendto failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">        <span class="comment">//第六步：接受ARP应答</span></span><br><span class="line"> num = recvfrom(fd , &amp;arp_pk , <span class="keyword">sizeof</span>(struct ARP_PACKET) ,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"rcvfrom failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"I receive %d bytes!\n"</span>,num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the mac  is:"</span>);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%4X "</span>,arp_pk.from_mac[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"op:%d\n"</span>,arp_pk.op);</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d. "</span>,arp_pk.to_ip[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="keyword">char</span> *name ,  <span class="keyword">char</span> *MAC_addr , struct in_addr * IP_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span>  <span class="title">eth</span>;</span>  <span class="comment">//够结构用于存放最初多获取的接口信息</span></span><br><span class="line"><span class="comment">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class="line">   <span class="keyword">int</span> fd;             <span class="comment">//用于创建套接字</span></span><br><span class="line"> <span class="keyword">int</span> temp=<span class="number">0</span>;         <span class="comment">//用于验证接口调用</span></span><br><span class="line"> <span class="keyword">int</span> i=<span class="number">0</span>;            <span class="comment">//用于循环</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">strncpy</span>(eth.ifr_name,name,<span class="keyword">sizeof</span>(struct ifreq)<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class="line"> <span class="comment">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class="line">    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"socket failed!\n"</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class="line">   temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class="line"> <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="built_in">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class="number">6</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"The MAC_addr is:"</span>);</span><br><span class="line"> <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%4X"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class="line">   temp = ioctl(fd,SIOCGIFADDR,&amp;eth);</span><br><span class="line"> <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="built_in">memcpy</span>(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class="number">4</span>);</span><br><span class="line"> <span class="comment">//关闭套接口</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"got ipaddr:%s\n"</span>,inet_ntoa(*IP_addr));</span><br><span class="line"><span class="comment">/*i=0;</span></span><br><span class="line"><span class="comment">printf("get the MAC_ADDR:\n");</span></span><br><span class="line"><span class="comment">for(i;i&lt;6;i++)</span></span><br><span class="line"><span class="comment">  printf("%.2X:",MAC_addr[i]&amp;0xFF);*/</span></span><br><span class="line">   close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步填充arp数据包的时候，填充的数据和类型根据需要进行。</span></span><br><span class="line"><span class="comment">//这里的arp数据包结构体是自己定义的，也可以是利用linux的相关结构：</span></span><br><span class="line"><span class="comment">/*eg:</span></span><br><span class="line"><span class="comment">typedef struct _tagARP_PACKET&#123;    </span></span><br><span class="line"><span class="comment">    struct ether_header  eh;    ///net/ethernet.h</span></span><br><span class="line"><span class="comment">    struct ether_arp arp;    </span></span><br><span class="line"><span class="comment">&#125;ARP_PACKET_OBJ, *ARP_PACKET_HANDLE; /netinet/if_ether.h;/net/if_arp.h</span></span><br><span class="line"><span class="comment">各个字段的填充见头文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三步：填充sockaddr_ll eth_info结构,关键是填充网络接口索引值，最直接的方法是上面的函数，</span></span><br><span class="line"><span class="comment">还有另外的方法:利用ioctl函数获取struct ifreq结构的信息，该结构放置了很多网络接口的相关信息*/</span></span><br><span class="line"><span class="comment">/*  struct sockaddr_ll&#123;</span></span><br><span class="line"><span class="comment">    unsigned short sll_family; //总是 AF_PACKET </span></span><br><span class="line"><span class="comment">    unsigned short sll_protocol; // 物理层的协议 </span></span><br><span class="line"><span class="comment">    int sll_ifindex; //接口号 </span></span><br><span class="line"><span class="comment">    unsigned short sll_hatype; // 报头类型 </span></span><br><span class="line"><span class="comment">    unsigned char sll_pkttype; // 分组类型 </span></span><br><span class="line"><span class="comment">    unsigned char sll_halen; // 地址长度 </span></span><br><span class="line"><span class="comment">    unsigned char sll_addr[8]; // 物理层地址 </span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">eg:</span></span><br><span class="line"><span class="comment">*     struct sockaddr_ll peer_addr;  </span></span><br><span class="line"><span class="comment">*    memset(&amp;peer_addr, 0, sizeof(peer_addr));    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_family = AF_PACKET;    </span></span><br><span class="line"><span class="comment">        struct ifreq req;  </span></span><br><span class="line"><span class="comment">    bzero(&amp;req, sizeof(struct ifreq));  </span></span><br><span class="line"><span class="comment">        strcpy(req.ifr_name, "eth0");    </span></span><br><span class="line"><span class="comment">        if(ioctl(sockfd, SIOCGIFINDEX, &amp;req) != 0)  </span></span><br><span class="line"><span class="comment">        perror("ioctl()");    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_ifindex = req.ifr_ifindex;    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_protocol = htons(ETH_P_ARP);  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*第四步，创建套结字的时候，有以下的组合：更多见：man packet</span></span><br><span class="line"><span class="comment"> * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</span></span><br><span class="line"><span class="comment"> * 第二个参数： 2）套接字类型：</span></span><br><span class="line"><span class="comment">          SOCK_DGRAM----以太网头已经构造好了</span></span><br><span class="line"><span class="comment">          SOCK_RAW------自己构造以太头 </span></span><br><span class="line"><span class="comment">          * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字</span></span><br><span class="line"><span class="comment">          * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），</span></span><br><span class="line"><span class="comment">          * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，</span></span><br><span class="line"><span class="comment">          * 而发送时也无须用户添加头部字段。</span></span><br><span class="line"><span class="comment">   第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP</span></span><br><span class="line"><span class="comment">   * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：</span></span><br><span class="line"><span class="comment">   1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)</span></span><br><span class="line"><span class="comment">  和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)</span></span><br><span class="line"><span class="comment">    2)IEEE维护的注册以太网类型列表</span></span><br><span class="line"><span class="comment">     3）半官方的列表由IANA维护</span></span><br><span class="line"><span class="comment">      ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。</span></span><br><span class="line"><span class="comment">      0x88b5和0x88b6是保留以太网类型，供实验或私人使用。 </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">   <span class="comment">/*第五步发送和接收套接字的函数可以是read write操作套结字，也可以是上文的UDP无连接用的函数*/</span></span><br></pre></td></tr></table></figure>
<p>处理的时候可能需要获取网关的ip地址：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*proc方法获取网关地址*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetGateWayIP</span><span class="params">(uint8 *ip_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> inf[<span class="number">100</span>];</span><br><span class="line">      FILE *file_fd;</span><br><span class="line">      uint8 high=<span class="number">0</span>,low=<span class="number">0</span>,value;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      file_fd = fopen(<span class="string">"/proc/net/route"</span>,<span class="string">"r"</span>);</span><br><span class="line">      <span class="keyword">if</span>(file_fd==<span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"can not open /proc/net/route\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">             <span class="keyword">while</span>(!feof(file_fd))</span><br><span class="line">             &#123;</span><br><span class="line">                     <span class="built_in">memset</span>(inf,<span class="number">0</span>,<span class="keyword">sizeof</span>(inf));</span><br><span class="line">                     fgets(inf,<span class="number">100</span>,file_fd);</span><br><span class="line">                     <span class="keyword">if</span>(inf[<span class="number">5</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">6</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">7</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">8</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">9</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">10</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">11</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">12</span>]==<span class="string">'0'</span>)</span><br><span class="line">                     &#123;</span><br><span class="line">                              <span class="keyword">for</span>(i=<span class="number">20</span>;i&gt;=<span class="number">14</span>;i-=<span class="number">2</span>)</span><br><span class="line">                              &#123;</span><br><span class="line">                                         <span class="keyword">if</span>(inf[i]&gt;=<span class="number">65</span>)</span><br><span class="line">                                                 high = inf[i]<span class="number">-55</span>;</span><br><span class="line">                                         <span class="keyword">else</span></span><br><span class="line">                                                 high = inf[i]<span class="number">-48</span>;</span><br><span class="line">                                         <span class="keyword">if</span>(inf[i+<span class="number">1</span>]&gt;=<span class="number">65</span>)</span><br><span class="line">                                                 low = inf[i+<span class="number">1</span>]<span class="number">-55</span>;</span><br><span class="line">                                         <span class="keyword">else</span></span><br><span class="line">                                                 low = inf[i+<span class="number">1</span>]<span class="number">-48</span>;</span><br><span class="line">                                        value = high*<span class="number">16</span>+low;</span><br><span class="line">                                       ip_addr[<span class="number">10</span>-i/<span class="number">2</span>] = value;</span><br><span class="line">                              &#125;</span><br><span class="line">                              <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h4><ul>
<li>ARP包可以直接发送给对端不经过路由器，有趣<br>在一个局域网中，客户端的几乎所有的包都是发往路由器的，这归结于默认路由设置，而在无线网，网卡其实可以接收所有数据，毕竟空气介质，所以，局域网中的设备可以直接通信<br>实验：在文件全能王中开启wifi文件传输，和它在同一个局域网的sta能访问该地址，抓包，发现目的地址和源地址都为同一个局域网的不同ip,且不为路由器网关ip，证明其两个设备是可以直接通信的</li>
<li>再来做一个实验：通过pf_packet<br>1、在电脑A上写一个程序，mac目的地址为B,源地址为A,协议类型随机，数据随意，发送给B<br> 同时在B端进行接收，过滤掉其他mac地址，看是否可以接收到，在连接ap和不连接ap的条件下<br>2、在A和B设置静态ip地址，且不同网段，都不连接AP ,让A向B 发送ARP请求包，B接收到后回复arp响应包，接着做ping或其他操作，看是否能互相通信</li>
<li>编程可以参考上述程序，改一下地址什么的就可以，或者参考其他：<br><a href="http://www.freebuf.com/articles/system/5157.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/system/5157.html</a><br>这篇文章讲的很具体，个人也喜欢这个网站，emm,实验过了，还可以，can also make your own program,具体程序不贴了  </li>
<li>arp欺骗的基本原理：<br>在局域网中，设备A,B连接同一个路由器，他们之间可以直接相互通信，因此可以直接向对方发送arp包；<br>设备A ,B都会定期和AP交互arp请求和回复，相互知道对方的mac地址，这样，就能给ap发送请求，ap也能知道回复给谁；<br>arp欺骗的基本原理在于，如B是攻击方，则B向A发送ARP回复自己是AP ,即在ARP回复包中带上自己的mac地址，ap的ip地址；<br>同时向AP回复自己是A，即带上A的ip地址，自己的mac地址；<br>这样A就会以为B是AP，就会把请求发给B ,同时AP以为B是A，会把回复传给B,但是同时得配置B的转发功能，<br>echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot<br>该博文中有一处错误，见评论</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_PF_PACKET</title>
    <url>/2018/05/27/tcpip-PF-PACKET/</url>
    <content><![CDATA[<img src="/2018/05/27/tcpip-PF-PACKET/pf_packet.jpg" title="it just picture">
<h3 id="PF-PACKET的使用："><a href="#PF-PACKET的使用：" class="headerlink" title="PF_PACKET的使用："></a>PF_PACKET的使用：</h3><h3 id="PF-PACKET简介："><a href="#PF-PACKET简介：" class="headerlink" title="PF_PACKET简介："></a>PF_PACKET简介：</h3><p>是linux下的用于发送和接收二层(mac层)的套接字：<br><a id="more"></a></p>
<h3 id="PF-PACKET基本使用："><a href="#PF-PACKET基本使用：" class="headerlink" title="PF_PACKET基本使用："></a>PF_PACKET基本使用：</h3><ul>
<li>基本的几个操作：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取硬件网卡的相应信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="keyword">char</span> *name ,  <span class="keyword">char</span> *MAC_addr , struct in_addr * IP_addr)</span><span class="comment">//传入接口名，取回mac和ip</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span>  <span class="title">eth</span>;</span>  <span class="comment">//结构用于存放最初获取的接口信息</span></span><br><span class="line">   <span class="comment">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class="line">   <span class="keyword">int</span> fd;             <span class="comment">//用于创建套接字</span></span><br><span class="line">   <span class="keyword">int</span> temp=<span class="number">0</span>;         <span class="comment">//用于验证接口调用</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;            <span class="comment">//用于循环</span></span><br><span class="line">   <span class="built_in">strncpy</span>(eth.ifr_name,name,<span class="keyword">sizeof</span>(struct ifreq)<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class="line">  <span class="comment">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class="line">    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"socket failed!\n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class="line">     temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class="line">     <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="built_in">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class="number">6</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"The MAC_addr is:"</span>);</span><br><span class="line">      <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%4X"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class="line">      temp = ioctl(fd,SIOCGIFADDR,&amp;eth);</span><br><span class="line">      <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class="number">4</span>);</span><br><span class="line">      <span class="comment">//关闭套接口</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"got ipaddr:%s\n"</span>,inet_ntoa(*IP_addr)); </span><br><span class="line">      close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取得网络接口的索引：int值,传入fd和接口名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_IfaceIndex</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* interfaceName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"><span class="keyword">if</span> (interfaceName == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line"><span class="built_in">strcpy</span>(ifr.ifr_name, interfaceName);</span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, SIOCGIFINDEX, &amp;ifr) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"RED ioctl error\n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ifr.ifr_ifindex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_Iface_promisc</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> dev_id)</span><span class="comment">//传入fd和index</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_mreq</span> <span class="title">mr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;mr,<span class="number">0</span>,<span class="keyword">sizeof</span>(mr));</span><br><span class="line">mr.mr_ifindex = dev_id;</span><br><span class="line">mr.mr_type = PACKET_MR_PROMISC;</span><br><span class="line"><span class="keyword">if</span>(setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&amp;mr,<span class="keyword">sizeof</span>(mr))==<span class="number">-1</span>)<span class="comment">//退出混杂模式使用这个：PACKET_DROP_MEMBERSHIP</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"GREEN set promisc failed! \n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">unsigned</span> <span class="keyword">char</span> MAC_ADDR[<span class="number">6</span>];</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">IP_ADDR</span>;</span><span class="comment">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class="line">	 <span class="comment">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class="line">    GetEthInfor(<span class="string">"wlp2s0"</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">     fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP));</span><br><span class="line">    <span class="keyword">int</span> index=Get_IfaceIndex(fd,<span class="string">"enp1s0"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"index:%d\n"</span>,index);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="PF-PACKET的接收："><a href="#PF-PACKET的接收：" class="headerlink" title="PF_PACKET的接收："></a>PF_PACKET的接收：</h3><p>简单说明：<br>创建套结字的时候，有以下的组合：更多见：man packet</p>
<ul>
<li>利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</li>
<li>第二个参数： 套接字类型：<pre><code>SOCK_DGRAM----以太网头已经构造好了
SOCK_RAW------自己构造以太头 
* 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字
* 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），
* 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，
* 而发送时也无须用户添加头部字段。
</code></pre></li>
</ul>
<ul>
<li>第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP<ul>
<li>以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：<br>1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)<br>和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)<br>2)  IEEE维护的注册以太网类型列表<br>3）半官方的列表由IANA维护<br> ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。<br> 0x88b5和0x88b6是保留以太网类型，供实验或私人使用。<br>(若指定socket_type为SOCK_RAW则意味着原始数据包包含了链路层头部，若指定为SOCK_DGRAM则将做一些处理以剥掉链路层头部。链路层头部信息的通用格式是一个sockaddr_ll结构。protocol填入网络字节序的IEEE 802.3协议号。参见&lt;linux/if_ether.h&gt;头文件了解允许的协议。如果protocol被设置为htons(ETH_P_ALL)，则意味着接受所有协议。所有接入的协议类型为protocol的数据包将在传递给内核之前传递到PACKET套接字。)</li>
</ul>
<ul>
<li>收包可以使用的接口：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readnum = recvfrom(rawsock, buffer,<span class="number">2048</span>,<span class="number">0</span>, (struct sockaddr*)(&amp;eth_info),&amp;leneth_info);</span><br><span class="line"><span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);</span><br><span class="line"><span class="keyword">int</span> readnum = recvfrom(rawsock, buffer,<span class="number">2048</span>,<span class="number">0</span>, <span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>一个简单的接收包的例子：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_MAX 2048</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: create raw socket!!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf("recv buffer:%s\n",buffer);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>指定从某个接口接收数据：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">eth_info</span>;</span><span class="comment">//结构体的定义在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class="line">  eth_info.sll_family = PF_PACKET;  <span class="comment">//PF_PACKET定义在sys/types.h中</span></span><br><span class="line">  eth_info.sll_ifindex = if_nametoindex(<span class="string">"lo"</span>);<span class="comment">//返回输入的接口名称的索引值　　//次函数定义在net/if.h中</span></span><br><span class="line"> <span class="keyword">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: create raw socket!!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">if</span>(bind(rawsock,(struct sockaddr *)(&amp;eth_info),<span class="keyword">sizeof</span>(eth_info))==<span class="number">-1</span>)<span class="comment">//绑定接口，从而只接收那个接口上的数据</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"error: bind!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf("recv buffer:%s\n",buffer);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>接收后的包如何读取：以包括mac头的形式来看：粗暴的形式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rawsock;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_MAX];</span><br><span class="line">    <span class="keyword">char</span> *ethhead;</span><br><span class="line">    <span class="keyword">char</span> *iphead;</span><br><span class="line">    <span class="keyword">char</span> *tcphead;</span><br><span class="line">    <span class="keyword">char</span> *udphead;</span><br><span class="line">    <span class="keyword">char</span> *icmphead;</span><br><span class="line">    <span class="keyword">char</span> *pHead;</span><br><span class="line"> <span class="keyword">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: create raw socket!!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf("recv buffer:%s\n",buffer);</span></span><br><span class="line">         <span class="keyword">if</span>(readnum &lt; <span class="number">42</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error: Header is incomplete!!!\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//  for(j;j&lt;readnum;j++)</span></span><br><span class="line">      <span class="comment">//     printf("%.2X:",buffer[j]&amp;0xFF);</span></span><br><span class="line">        ethhead = (<span class="keyword">char</span> *)buffer;</span><br><span class="line">        pHead = ethhead;</span><br><span class="line">        <span class="keyword">int</span> ethernetmask = <span class="number">0XFF</span>;</span><br><span class="line">        framecount++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"------------------Analysis   Packet [%d]---------------------\n"</span>,framecount);</span><br><span class="line">       <span class="comment">// printf("all:-----%s\n",ethhead);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"MAC:"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;=<span class="number">11</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2X:"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;=<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2X:"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"proto: %.2x:"</span>,pHead[<span class="number">12</span>]&amp;ethernetmask);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"proto2: %.2x:\n"</span>,pHead[<span class="number">13</span>]&amp;ethernetmask);        </span><br><span class="line">        iphead = ethhead + <span class="number">14</span>;</span><br><span class="line">        pHead = iphead + <span class="number">14</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"IP:"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;=<span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">10</span>; i &lt;=<span class="number">13</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">13</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> prototype = (iphead + <span class="number">9</span>)[<span class="number">0</span>];</span><br><span class="line">     <span class="comment">//   printf("Protocol: %.2X:",prototype);</span></span><br><span class="line">        <span class="comment">//int prototype = (iphead + 9)[0];</span></span><br><span class="line">        pHead = iphead + <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Protocol: "</span>);</span><br><span class="line">        <span class="keyword">switch</span>(prototype)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_ICMP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ICMP\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_IGMP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"IGMP\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_IPIP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"IP\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_TCP :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"TCP | source port: %u | "</span>,(pHead[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">1</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"dest port: %u\n"</span>, (pHead[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">3</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_UDP :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"UDP | source port: %u | "</span>,(pHead[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">1</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"dest port: %u\n"</span>, (pHead[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">3</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_RAW :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"RAW\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Unkown\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-------------------------end-----------------------\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>收包处理的方式，也可以把指针赋给内核的结构：struct iphdr<br>如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> <span class="title">ip</span>;</span></span><br><span class="line">ip = (struct iphdr *)(buffer + <span class="keyword">sizeof</span>(struct ethhdr));</span><br></pre></td></tr></table></figure></p>
<p>内核提供了很多的包结构，在发包或者收包的时候可以直接使用这些结构解析或者粗暴的用字符串解析</p>
<h3 id="PF-PACKET发送包："><a href="#PF-PACKET发送包：" class="headerlink" title="PF_PACKET发送包："></a>PF_PACKET发送包：</h3><ul>
<li>发包和接收包类似：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">num = sendto(rawsock, buffer,<span class="number">2048</span> , <span class="number">0</span> ,(struct sockaddr*)(&amp;eth_info),<span class="keyword">sizeof</span>(eth_info));</span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sendto failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"success:%d\n"</span>,num);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>PF_PACKET</tag>
      </tags>
  </entry>
  <entry>
    <title>DS_linklist</title>
    <url>/2018/05/26/DS-linklist/</url>
    <content><![CDATA[<h2 id="数据结构之线性表："><a href="#数据结构之线性表：" class="headerlink" title="数据结构之线性表："></a>数据结构之线性表：</h2><h3 id="有序表：数组："><a href="#有序表：数组：" class="headerlink" title="有序表：数组："></a>有序表：数组：</h3><h3 id="单链表："><a href="#单链表：" class="headerlink" title="单链表："></a>单链表：</h3><p>链表定义  <a id="more"></a><br>{  </p>
<ul>
<li>数据成员:常见的基本类型或者对象类型均可  </li>
<li>数据关系:在链表中的块的成员在连续的内存中，块与块之间内存位置不连续  </li>
<li>指向块的指针：单链表只有一个next,双链表加上pre  </li>
</ul>
<p>}<br>基本运算：<br>{</p>
<ul>
<li>InitList(&amp;L);:初始化链表，在c/c++中需要做分配内存，初始化链表头和其值的操作；  </li>
<li>DestroyList(&amp;L); 在销毁时需要free内存  </li>
<li>Length(L);链表的长度是块的个数</li>
<li>GetElem(L,i,&amp;e); 在链表中取元素需要一个一个遍历直到下标值，若为双链表会快些。所以这里取索引值对应的值和取链表的值，效率几乎一样；  </li>
<li>LocateElem(L,e,compare()); 和链表中的元素做对比</li>
<li>InsertElem(&amp;L,i,e); 在链表中插入元素，复杂度O(1),在提供位置的时候，若不提供位置，还需要加搜索的时间</li>
<li>DeleteElem(&amp;L,i,&amp;e); 在链表中删除元素，复杂度O(1)<br>……  </li>
</ul>
<p>}<br>eg:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span> </span><br><span class="line">       ElemType data；<span class="comment">//数据域</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>  *<span class="title">next</span>； //指针域</span></span><br><span class="line"><span class="class">&#125; <span class="title">LNode</span>,  *<span class="title">LinkList</span>;</span></span><br><span class="line">LNode  *L;</span><br><span class="line">LinkList  L;</span><br><span class="line">L =  (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">或 L = <span class="keyword">new</span> LNode;</span><br><span class="line">L-&gt;data;</span><br><span class="line">LNode  L;</span><br><span class="line">L.date</span><br></pre></td></tr></table></figure></p>
<img src="/2018/05/26/DS-linklist/linklist.png" title="链表示意图">    
<h3 id="链表的两种头部："><a href="#链表的两种头部：" class="headerlink" title="链表的两种头部："></a>链表的两种头部：</h3><ol>
<li>没有头的链表：第一个块就开始存储数据  </li>
<li>任何时候都有头的链表：  第一个块不存储数据，作为头节点，第二个块开始存数据  </li>
<li>应用：在leetcode中的ReverseLinklist中，当反转的是从1开始的时候，若使用的是没有头的，则需要额外判断处理，否则可以统一处理；  </li>
</ol>
<img src="/2018/05/26/DS-linklist/headnode.png" title="头节点示意图">  
<h3 id="链表的几个常见操作："><a href="#链表的几个常见操作：" class="headerlink" title="链表的几个常见操作：　"></a>链表的几个常见操作：　</h3><ul>
<li><p>取第i个元素：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//查找操作</span></span><br><span class="line">    p = L-&gt;next;  </span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; j &lt; i)&#123;</span><br><span class="line">          p = p-&gt;next; </span><br><span class="line">          ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j&gt;i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入元素：在第i个位置上插入    </p>
<img src="/2018/05/26/DS-linklist/insert.png" title="插入示意图">    
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p = L; j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (p &amp;&amp; j &lt; i<span class="number">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class="line">     <span class="keyword">if</span> (!p || j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line">  s =  (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     s-&gt;data = e;  </span><br><span class="line">  s-&gt;next = p-&gt;next;  </span><br><span class="line">  p-&gt;next = s;  </span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素:删除第i个元素:  </p>
<img src="/2018/05/26/DS-linklist/delete.png" title="删除示意图">  
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> p = L; j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i<span class="number">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class="line">     <span class="keyword">if</span> (!(p-&gt;next) || j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line"> q = p-&gt;next;</span><br><span class="line">     e = q-&gt;data;  </span><br><span class="line"> p-&gt;next = p-&gt;next-&gt;next;  <span class="comment">//(p-&gt;next = q-&gt;next;)</span></span><br><span class="line"> <span class="built_in">free</span>(q);  </span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="链表的建立："><a href="#链表的建立：" class="headerlink" title="链表的建立："></a>链表的建立：</h3><ul>
<li><p>头插法：  </p>
<img src="/2018/05/26/DS-linklist/headbuild.png" title="头插法示意图">  
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CreateList_L(LinkList &amp;L, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">     L = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span>( i=n; i&gt;<span class="number">0</span>; --i)&#123;</span><br><span class="line">         s = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">         <span class="built_in">scanf</span>( &amp;s-&gt;data);</span><br><span class="line">         s-&gt;next = L-&gt;next; ①</span><br><span class="line">         L-&gt;next = s; ②</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾插法：  </p>
<img src="/2018/05/26/DS-linklist/tailbuile.png" title="尾插法示意图">  
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CreateList_L(LinkList &amp;L, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">     tail = L = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span>( i=n; i&gt;<span class="number">0</span>; --i)&#123;</span><br><span class="line">         s = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">         <span class="built_in">scanf</span>( &amp;s-&gt;data);</span><br><span class="line">         tail-&gt;next = s; ①</span><br><span class="line">         tail = s; ②</span><br><span class="line">     &#125;      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="链表的常见复杂操作："><a href="#链表的常见复杂操作：" class="headerlink" title="链表的常见复杂操作："></a>链表的常见复杂操作：</h3><ul>
<li>两个有序链表的合并：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa = La-&gt;next; pb = Lb-&gt;next;</span><br><span class="line">    Lc = pc = La;</span><br><span class="line">    <span class="keyword">while</span>( pa &amp;&amp; pb )&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class="line">             pc-&gt;next = pa; pc = pa; pa = pa-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">             pc-&gt;next = pb; pc = pb; pb= pb-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = pa ? pa : pb;</span><br><span class="line">    <span class="built_in">free</span>( Lb );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="一些特殊的链表："><a href="#一些特殊的链表：" class="headerlink" title="一些特殊的链表："></a>一些特殊的链表：</h3><ul>
<li>单向循环链表：</li>
<li>图示：  <img src="/2018/05/26/DS-linklist/sigrecyclelink.png" title="单向循环链表">
<img src="/2018/05/26/DS-linklist/mergerecycle.png" title="合并"></li>
<li>多重循环链表：</li>
<li>双向链表：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">     ElemType               data;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>    *<span class="title">prior</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>    *<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode,  *DuLinkList;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>双向循环链表：</p>
<h3 id="探讨："><a href="#探讨：" class="headerlink" title="探讨："></a>探讨：</h3><ul>
<li>链表作为最基础的数据结构，是对其他数据结构：如栈，树等的支撑，其他这些大部分是在链表的基础上建立的；  </li>
<li>从较底层的层面：即深入到内存，链表实现了对零散内存的有效使用，内存在为链表分配空间的时候不用大段的连续空间；</li>
<li>从较高层，即抽象的层面看，链表仅仅是一批数据的拓扑结构之一，就常见的栈，队列，树，图等等，你还可以想出其他可能有用没用的，如，立体的结构，方块，金字塔形(emm这个像堆），还有随意的，感觉想到了矩阵里面的压缩。   </li>
</ul>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul>
<li>链表的应用：如</li>
<li>在文件中，对大文件的存储，采用类似链表的结构，</li>
<li>大数相加，像两个100位的整数相加，使用链表，每个块为一位，就可以解决这个问题，数组也行</li>
<li>倒排索引结构，在操作系统中用到，我的github上放着一个本科毕业设计做的简单搜索引擎，几乎全是自己搞的（解析网页那块自己c写了状态机，觉得效果不如beatifulsoup好，后面用它了),不过想想那会还不会很有意识的去想如果让它运行在大量用户下，各种使用条件（如输入条件下，会怎么样，年轻啊~)</li>
<li>其他，当然是其他数据结构基于链表做的，多了去了</li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>code_efficandreadable</title>
    <url>/2018/05/25/code-efficandreadable/</url>
    <content><![CDATA[<h2 id="论代码的效率和可读性的权衡"><a href="#论代码的效率和可读性的权衡" class="headerlink" title="论代码的效率和可读性的权衡"></a>论代码的效率和可读性的权衡</h2><h4 id="高效代码可读性差："><a href="#高效代码可读性差：" class="headerlink" title="高效代码可读性差："></a>高效代码可读性差：</h4><p>有一些代码，占用额外内存小，即run in place，且执行的速度快，即复杂度O()低，但是可读性差，即使注释了，修改起来也容易出错，如：<br>对链表的操作：举一个leetcode的例子：(这个例子不是很典型，能说明问题即可）<br>    reverse a linklist from m to n;<br>    1-&gt;3-&gt;4-&gt;5-&gt;null and m,n(ex:2,4);<br>    return 1-&gt;5-&gt;4-&gt;2-&gt;null;<br>   上面例子一开始可以想到，头插法，或者将范围内的那一段用新的处理过的链表替换掉，即只需要处理该片段的头和尾部，当然可能还有其他方法，这里先不考虑；<br>   于是，头插法不是很复杂，但是在这里不用额外的内存时，需要频繁的改变next指针和对pre元素做临时保存，使得代码可读性差，所以可以考虑以下方案：<br>   在替换的内存小时，可以采用后者，让代码可读性高些，方便维护和（被替代~更容易被炒鱿鱼的风险哈哈)<br>   在内存小时，采用前者，爱怎么指怎么指，看不懂不管哈哈哈</p>
]]></content>
      <categories>
        <category>代码整洁</category>
      </categories>
      <tags>
        <tag>代码可读性</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpip_mtu</title>
    <url>/2018/05/20/tcpip-mtu/</url>
    <content><![CDATA[<h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍：</p>
<h3 id="理论部分："><a href="#理论部分：" class="headerlink" title="理论部分："></a>理论部分：</h3><h4 id="１、MTU-Maximum-Transmission-Unit-如何定义"><a href="#１、MTU-Maximum-Transmission-Unit-如何定义" class="headerlink" title="１、MTU(Maximum Transmission Unit)如何定义:"></a>１、MTU(Maximum Transmission Unit)如何定义:</h4><ul>
<li>指的是通信协议中的某一层上面所能通过的最大数据包大小</li>
<li>这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？  <a id="more"></a><br>　答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B&gt;1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:<br>分片：ip净载荷：MTU-IP头：1500-20=1480;<br> 3008B 需要分为3片，3008=1480,1480,48<br>总结：MTU就是MAC承载的载荷的最大值  </li>
</ul>
<h4 id="2、MTU会影响什么"><a href="#2、MTU会影响什么" class="headerlink" title="2、MTU会影响什么:"></a>2、MTU会影响什么:</h4><ul>
<li>数据包太大-&gt;分片重组-&gt;网络性能变差  </li>
<li>数据包太小-&gt;一次能传输的数据小-&gt;网速差  </li>
<li>路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191)　　</li>
</ul>
<h4 id="3、如何知道这个值呢？"><a href="#3、如何知道这个值呢？" class="headerlink" title="3、如何知道这个值呢？"></a>3、如何知道这个值呢？</h4><p>路径最大传输单元发现方法(RFC1191)　　</p>
<ul>
<li>越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。  </li>
<li>MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：<br>ping -c 3 -s 1474 -M do 192.168.0.1<br>PING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.<br>ping: local error: Message too long, mtu=1500<br>提示错误即消息太大且未设置分片</li>
</ul>
<h4 id="4-MTU大小的来源"><a href="#4-MTU大小的来源" class="headerlink" title="4 MTU大小的来源:"></a>4 MTU大小的来源:</h4><p>ref <a href="https://www.zhihu.com/question/31460305/answer/183766816" target="_blank" rel="noopener">https://www.zhihu.com/question/31460305/answer/183766816</a><br>以太网传输帧的最小值：    </p>
<ul>
<li>最早的以太网工作方式：载波多路复用/冲突检测（CSMA/D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。</li>
<li>假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。  </li>
</ul>
<p>为什么标准以太网帧长度上限为1518字节?  </p>
<ul>
<li>IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。</li>
<li>由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 byte那有效传输效率= 160 / 218 = 73%而如果以太网长度为1518，那有效传输效率= 1460 / 1518 = 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题.</li>
<li>于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。</li>
</ul>
<p>其他疑问：  </p>
<ul>
<li>最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？</li>
<li>这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到&gt; 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。</li>
<li>有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度&gt;接口MTU，怎么办？<br>丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。</li>
<li>所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？</li>
<li>我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU = MRU，但比如9000侧的数据到达1500，由于9000 &gt; MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样<h3 id="实践部分："><a href="#实践部分：" class="headerlink" title="实践部分："></a>实践部分：</h3>如何设置MTU：<br>ifconfig eth0 mtu 1460<br>如何查看mtu:<br>netstat -i</li>
</ul>
]]></content>
      <categories>
        <category>tcpip</category>
      </categories>
      <tags>
        <tag>tcpip_mac</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_debug_layout_static</title>
    <url>/2018/05/20/cpp-debug-layout-static/</url>
    <content><![CDATA[<h3 id="c-compile-time-memory-layout"><a href="#c-compile-time-memory-layout" class="headerlink" title="c compile time memory layout"></a>c compile time memory layout</h3><p>　　标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法：</p>
<p>　　概述：首先介绍几个概念：<a id="more"></a><br>　　程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候；<br>　　当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程；<br>      注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码　。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句；</p>
<p>　　本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c</p>
<p>前言：<br>一个源代码通过编译后生成一个目标文件.o它是一个elf　relocatable文件,以下.o文件指此类，elf文件为executable文件<br>.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到</p>
<pre><code>other data  ...
.comment    offset 0x000000c6.
.rodata      ...　　　//const &amp; str 常量
.data
.text
.elf header
</code></pre><p>一个elf文件的结构是这样的：可以通过readelf来看：<br>    　　　　　　　　elfheader　　　　　　　　文件头包含了平台信息：/usr/include/elf.h<br>            .text　　　　　　　　　　　　段表　各个段：应用程序也可以自己定义段，和指定变量在哪个段<br>            .data<br>            .bss<br>            ..<br>            other sections<br>            section header table　　　　<br>            string tables　　　　　　　　重定位表和字符串表<br>            symbol tables　　　　　　　　 符号表是链接的接口<br> 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂<br> 可以通过readelf -s　xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突<br>  强符号和弱符号（强引用和若引用），调试信息　－g<br> 扩展：<br> １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀；<br> 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B  i386 image.jpg image.o<br>   objdump -ht image.o<br>   可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们<br>   具体看文档<br>２）自定义段：<strong>attribute</strong>((section(“FOO”))) int global=24;<br>           <strong>attribute</strong>((section(“BAR”))) void  foo(){}  既可以把变量或函数放入该段中　段名：BAR FOO</p>
<p>正文：</p>
<h4 id="0、先从几个命令："><a href="#0、先从几个命令：" class="headerlink" title="0、先从几个命令："></a>0、先从几个命令：</h4><p>1)size filename:查看elf或.o文件中各个段大小：<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o<br>　　代码段　　　数据段　　<br>代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址<br>数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）<br>bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null</p>
<p>2)其他工具：<br> readelf -a simplest.o<br> 可以看到更清楚的段信息<br> objdump -t simplest<br> objdump -h simplest.o   替代size可以看到更多信息</p>
<p>此时显示出来的一些地址并不是装载后的地址</p>
<p>objdump -s -d xx.o:　　-s 16进制，-d反汇编　　－－－查看代码段<br>objdump -s -x -d xx.o:   –查看数据段和rodata</p>
<p>3)查看目标文件文件属性如relocatable –.o/executable –elf/share object –.so..<br> file xxx</p>
<h4 id="１、从最简单的程序开始：simplest-c"><a href="#１、从最简单的程序开始：simplest-c" class="headerlink" title="１、从最简单的程序开始：simplest.c"></a>１、从最简单的程序开始：simplest.c</h4><pre><code>int main()
{
   return 0;
}
</code></pre><p>将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件：</p>
<pre><code># 1 &quot;simplest.c&quot;
# 1 &quot;&lt;built-in&gt;&quot;
# 1 &quot;&lt;command-line&gt;&quot;
# 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4
# 1 &quot;&lt;command-line&gt;&quot; 2
# 1 &quot;simplest.c&quot;
int main()
 {
  return 0;
 }
</code></pre><p>将它进行汇编：gcc -S simplest.c<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>
<p>生成.o文件：gcc -c simplest.c<br>并通过file xx.o查看类型<br>simplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</p>
<p>通过size 查看各个段：<br>size simplest.o:  可以看到只有代码段，数据为空，bss为空，是比较纯净的</p>
<p>text       data        bss        dec        hex    filename<br>     67          0          0         67         43    simplest.o</p>
<p>接着编译成elf:gcc -o simplest simplest.c<br>file simplest<br>simplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,<br>interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=<br>56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped<br>可以看到连接器等信息</p>
<p>size simplest<br>  text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest<br>注意这里的和.o的文件大小和分段不同，</p>
<h4 id="２、加入头文件和局部变量"><a href="#２、加入头文件和局部变量" class="headerlink" title="２、加入头文件和局部变量"></a>２、加入头文件和局部变量</h4><pre><code>#include&lt;stdio.h&gt;
int main()
{
  int locala;
  int localb=3;
  return 0;
  }
</code></pre><p>进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数<br>汇编，可以看到分配３到内存中<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>
<p>　　生成.o文件：可以看到未改变data和bss,但是代码段变大<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o</p>
<p>生成elf:数据区和bss未改变，代码段也未改变？<br> text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest</p>
<h4 id="３、加入已经初始化的局部静态变量："><a href="#３、加入已经初始化的局部静态变量：" class="headerlink" title="３、加入已经初始化的局部静态变量："></a>３、加入已经初始化的局部静态变量：</h4><pre><code>int main()
{
 static int statica=3;
..
}
</code></pre><p>看生成的汇编：<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2285, @object　//新加的段<br>        .size    statica.2285, 4<br>    statica.2285:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>
<p>.o大小：在静态数据区增加了，４　１个int的长度<br> text       data        bss        dec        hex    filename<br>     74          4          0         78         4e    simplest.o</p>
<p>elf:有点费解，。。<br> text       data        bss        dec        hex    filename<br>   1099        548          4       1651        673    simplest</p>
<h4 id="４、加入已经初始化的全局变量和全局静态变量"><a href="#４、加入已经初始化的全局变量和全局静态变量" class="headerlink" title="４、加入已经初始化的全局变量和全局静态变量"></a>４、加入已经初始化的全局变量和全局静态变量</h4><pre><code>int golbala=6;
    　static long gs=12;
</code></pre><p>生成的汇编<br>        .file    “simplest.c”<br>        .globl    golbala<br>        .data<br>        .align 4<br>        .type    golbala, @object<br>        .size    golbala, 4<br>    golbala://变量名<br>        .long    6<br>        .align 8<br>        .type    gs, @object<br>        .size    gs, 8<br>    gs://变量名<br>        .quad    12<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2287, @object<br>        .size    statica.2287, 4<br>    statica.2287:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p>
<p>size : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4=20<br>      text       data        bss        dec        hex    filename<br>       74         20          0         94         5e    simplest.o</p>
<p>elf size:548–&gt;564  16<br>  text       data        bss        dec        hex    filename<br>   1099        564          4       1667        683    simplest</p>
<h4 id="5-将-int-golbala-6"><a href="#5-将-int-golbala-6" class="headerlink" title="5 将 　　int golbala=6;"></a>5 将 　　int golbala=6;</h4><pre><code>　static long gs=12;　　倒换位置！！！！！！！！！
</code></pre><p> 则对齐成：size x.o为：１６比原来小，可以用于节省内存：<br>   text       data        bss        dec        hex    filename<br>     74         16          0         90         5a    simplest.o<br>　　汇编：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2287, @object<br>    .size    statica.2287, 4<br>statica.2287:<br>    .long    3<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits<br>elf文件的也变小：但bss变大，费解。。<br> text       data        bss        dec        hex    filename<br>   1099        560          8       1667        683    simplest</p>
<h4 id="6、加入未初始化的全局变量和全局与局部静态变量"><a href="#6、加入未初始化的全局变量和全局与局部静态变量" class="headerlink" title="6、加入未初始化的全局变量和全局与局部静态变量"></a>6、加入未初始化的全局变量和全局与局部静态变量</h4><pre><code>  1 #include&lt;stdio.h&gt;
    2 static long gs=12;
    3 int golbala=6;
    4      
    5     
    6 static long gsl;
    7 int gi;
    8 int main()
    9 {   
   10      static int staticn;
11      static int statica=3;
   12      int locala;
   13      int localb=3;
   14      return 0;
   15 }
</code></pre><p>汇编没有看到什么变化：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .local    gsl<br>    .comm    gsl,8,8<br>    .comm    gi,4,4<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2290, @object<br>    .size    statica.2290, 4<br>statica.2290:<br>    .long    3<br>    .local    staticn.2289<br>    .comm    staticn.2289,4,4<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits</p>
<p>.o文件：+12 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>     74         16         12        102         66    simplest.o</p>
<p>elf:+16 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>   1099        560         24       1683        693    simplest</p>
<p>至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同</p>
<p>参考：程序员的自我修养</p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_debug_layout_dynamic</title>
    <url>/2018/05/20/cpp-debug-layout-dynamic/</url>
    <content><![CDATA[<h3 id="c执行期内存布局和调试："><a href="#c执行期内存布局和调试：" class="headerlink" title="c执行期内存布局和调试："></a>c执行期内存布局和调试：</h3><p>在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等<br>１、将目标文件装入: <a id="more"></a><br><em>１）重定位－－－　放在内存哪里<br> 2)  等待调度执行</em><br>这里可以使用gdb进行调试查看</p>
<p>一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).<br>一个进程主要包括：<br>   在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等</p>
<blockquote>
<p>栈区　　高地址到低地址<br>堆区　　低地址到高地址<br>bss<br>数据<br>代码</p>
</blockquote>
<p> 以下将从两个维度进行对一个程序被执行成进程时，内存的情况：<br> １、各种段区的内存分布<br> ２、gdb 调试程序执行时的过程。－－可能涉及到汇编<br> －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>
<h4 id="1、gdb-常用的命令和用法："><a href="#1、gdb-常用的命令和用法：" class="headerlink" title="1、gdb　常用的命令和用法："></a>1、gdb　常用的命令和用法：</h4><p>1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令<br> 2)设置断点：　<br>b 行号<br>b 函数名<br>b 行号　if 条件<br>eg:<br>break main  /  b main<br>  删除断点:delete 行号</p>
<p>3)列出代码<br>l /list</p>
<p>4)运行，start<br>  跳转到断点:c/continue   r/run<br>  until  行号　　　运行直到该行<br>5)观察变量b和地址<br>watch b  若变量值发生变化，则程序停止</p>
<p>　p/print  b  看变量值<br>　p/print &amp;b　看变量地址<br> i  locals</p>
<p> info registers 显示所有寄存器的值<br> 查看特定内存位置的值如：<br> print/x $eax   显示为16进制<br> print/t  2进制，　<br> print/d 十进制,<br>x/nyz  : n表示字段数，y为输出格式，z是字段长度</p>
<p>６）单步调试<br> n/next   /   s/step　</p>
<p> 7) 保存断点：<br> info b  查看断点信息<br> save breakpoint fig.dp 保存断点<br> 读取断点文件：　gdb hello -x fig.dp</p>
<p> 退出quit</p>
<p> <a href="http://bbs.chinaunix.net/thread-150524-1-1.html" target="_blank" rel="noopener">http://bbs.chinaunix.net/thread-150524-1-1.html</a></p>
<h4 id="2-使用kdbg"><a href="#2-使用kdbg" class="headerlink" title="2 使用kdbg"></a>2 使用kdbg</h4><p> 界面版本gdb  在gcc … -g后，用kdbg打开即可、<br> 查看程序运行时各个地址：<br>    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHW_ADR(ID,I) printf(<span class="meta-string">"the id %s \t is at adr:%8X\n"</span>,ID,&amp;I);</span></span><br><span class="line"><span class="keyword">extern</span> etext,edata,end;</span><br><span class="line"><span class="keyword">char</span> *cptr=<span class="string">"Hello World\n"</span>;</span><br><span class="line"><span class="keyword">char</span> buffer1[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showit</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">"Adr etext:%8x\tAdr edata:%8x \t Adr end :%8x \n\n"</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class="line">	SHW_ADR(<span class="string">"main"</span>,main);</span><br><span class="line">	SHW_ADR(<span class="string">"showit"</span>,showit);</span><br><span class="line">	SHW_ADR(<span class="string">"cptr"</span>,cptr);</span><br><span class="line">	SHW_ADR(<span class="string">"buffer1"</span>,buffer1);</span><br><span class="line">	SHW_ADR(<span class="string">"i"</span>,i);</span><br><span class="line">	<span class="built_in">strcpy</span>(buffer1,<span class="string">"A demonstration\n"</span>);</span><br><span class="line">	write(<span class="number">1</span>,buffer1,<span class="built_in">strlen</span>(buffer1)+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;<span class="number">1</span>;++i)</span><br><span class="line">		showit(cptr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showit</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *buffer2;</span><br><span class="line">	SHW_ADR(<span class="string">"buffer2"</span>,buffer2);</span><br><span class="line">	<span class="keyword">if</span>((buffer2=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>((<span class="keyword">unsigned</span>)(<span class="built_in">strlen</span>(p)+<span class="number">1</span>)))!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(buffer2,p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s"</span>,buffer2);</span><br><span class="line">		<span class="built_in">free</span>(buffer2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Allocation error.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;alloca.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">afunc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> etext,edata,end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bss_var;				<span class="comment">//no init globel data must be in bss</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data_var=<span class="number">42</span>;			<span class="comment">//init globel data must be in data</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHW_ADR(ID,I) printf(<span class="meta-string">"the %8s\t is at adr:%8x\n"</span>,ID,&amp;I);		<span class="comment">//the macro to printf the addr</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p,*b,*nb;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Adr etext:%8x\t Adr edata %8x\t Adr end %8x\t\n"</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\ntext Location:\n"</span>);</span><br><span class="line">	SHW_ADR(<span class="string">"main"</span>,main);			<span class="comment">//text section function</span></span><br><span class="line">	SHW_ADR(<span class="string">"afunc"</span>,afunc);			<span class="comment">//text section function</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nbss Location:\n"</span>);</span><br><span class="line">	SHW_ADR(<span class="string">"bss_var"</span>,bss_var);		<span class="comment">//bss section var</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\ndata location:\n"</span>);</span><br><span class="line">	SHW_ADR(<span class="string">"data_var"</span>,data_var);	<span class="comment">//data section var</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nStack Locations:\n"</span>);</span><br><span class="line">	afunc();</span><br><span class="line">	</span><br><span class="line">	p=(<span class="keyword">char</span> *)alloca(<span class="number">32</span>);			<span class="comment">//alloc memory from statck</span></span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		SHW_ADR(<span class="string">"start"</span>,p);</span><br><span class="line">		SHW_ADR(<span class="string">"end"</span>,p+<span class="number">31</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	b=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">32</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));	<span class="comment">//malloc memory from heap</span></span><br><span class="line">	nb=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">16</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nHeap Locations:\n"</span>);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the Heap start: %p\n"</span>,b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the Heap end:%p\n"</span>,(nb+<span class="number">16</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>)));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nb and nb in Stack\n"</span>);</span><br><span class="line">	SHW_ADR(<span class="string">"b"</span>,b);</span><br><span class="line">	SHW_ADR(<span class="string">"nb"</span>,nb);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">free</span>(nb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afunc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">long</span> level=<span class="number">0</span>;	<span class="comment">//data section static var</span></span><br><span class="line">	<span class="keyword">int</span>	 stack_var;				<span class="comment">//temp var ,in stack section</span></span><br><span class="line">	<span class="keyword">if</span>(++level==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SHW_ADR(<span class="string">"stack_var in stack section"</span>,stack_var);</span><br><span class="line">	SHW_ADR(<span class="string">"Level in data section"</span>,level);</span><br><span class="line">	afunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>c&amp;cpp</category>
      </categories>
      <tags>
        <tag>cpp_memory</tag>
      </tags>
  </entry>
  <entry>
    <title>android_jni</title>
    <url>/2018/05/20/android-jni/</url>
    <content><![CDATA[<h3 id="a-example-of-JNI-static-way"><a href="#a-example-of-JNI-static-way" class="headerlink" title="a example of JNI static way:"></a>a example of JNI static way:</h3><h4 id="first-step-write-a-middle-java-file"><a href="#first-step-write-a-middle-java-file" class="headerlink" title="first step: write a middle java file:"></a>first step: write a middle java file:</h4><p>mkdir jni<br>cd jni/<a id="more"></a><br>vim TestJni.java</p>
<pre><code>import java.util.*;
public class TestJni
{
    public native void xprint(String content);
    static
    {
        System.loadLibrary(&quot;TestJni&quot;);
    }
}
</code></pre><p>  javac TestJni.java  and make a class</p>
<p>then<br>  javah -jni TestJni  to make a .h file:</p>
<pre><code>  /* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class TestJni */

#ifndef _Included_TestJni
#define _Included_TestJni
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     TestJni
 * Method:    xprint
 * Signature: (Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_TestJni_xprint
  (JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif
</code></pre><h4 id="step-two-write-jni-file-c"><a href="#step-two-write-jni-file-c" class="headerlink" title="step two write jni file.c:"></a>step two write jni file.c:</h4><p>TestJni.c:</p>
<pre><code>#include&lt;jni.h&gt;
#include&lt;stdio.h&gt;
#include &quot;TestJni.h&quot;

JNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content)
{
    const jbyte *str=(const jbyte*)(*env)-&gt;GetStringUTFChars(env,content,JNI_FALSE);
    printf(&quot;hello--wo%s \n&quot;,str);
    (*env)-&gt;ReleaseStringUTFChars(env,content,(const char*)str);
    return;
}
</code></pre><h4 id="three-build-so-lib"><a href="#three-build-so-lib" class="headerlink" title="three build .so lib"></a>three build .so lib</h4><pre><code>cc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c
</code></pre><h4 id="four-write-a-test-hellow-java"><a href="#four-write-a-test-hellow-java" class="headerlink" title="four write a test:hellow.java"></a>four write a test:hellow.java</h4><pre><code>import java.util.*;
public class hellow
{
    public static void main(String argc[])
    { 
        new hellow();
    }
    public hellow()
    { 
       new TestJni().xprint(&quot;hi my name is keee&quot;);
    }
}
</code></pre><h4 id="question"><a href="#question" class="headerlink" title="question:"></a>question:</h4><p>如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径：</p>
<p>java -Djava.library.path=’.’ HelloWorld<br>或者输入命令：<br>export LD_LIBRARY_PATH=“HelloWorld路径”:$LD_LIBRARY_PATH   设置环境变量</p>
<p>然后再 java HelloWorld 一样OK</p>
<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html" target="_blank" rel="noopener">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br><a href="http://www.cnblogs.com/wzben/p/5733571.html" target="_blank" rel="noopener">http://www.cnblogs.com/wzben/p/5733571.html</a></p>
<h3 id="a-example-of-JNI-dynamic-way"><a href="#a-example-of-JNI-dynamic-way" class="headerlink" title="a example of JNI dynamic way:"></a>a example of JNI dynamic way:</h3><h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1:"></a>step 1:</h4><p>write a TestJni.java</p>
<pre><code>public class SimpleJni{
    static {
        System.out.println(&quot;[java] static code block,start load shared library...&quot;);
        System.loadLibrary(&quot;SimpleJni&quot;);
        System.out.println(&quot;[java]load library end...&quot;);
    }
    static native int add(int a,int b);
    public static void main(String args[])
    {
        System.out.println(&quot;[java] in main...&quot;);
        System.out.println(&quot;[java] 3+4=&quot;+SimpleJni.add(3,4));
        System.out.println(&quot;end...&quot;);
    }
}
</code></pre><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2:"></a>step 2:</h4><p>write a Jni file:</p>
<pre><code>#include &lt;jni.h&gt;
#include&lt;stdio.h&gt;
const char *classPathName=&quot;com/bt/jni/SimpleJni&quot;;

jint myadd(JNIEnv *env,jobject thiz,jint a,jint b)
{
    return a+b;
}
static JNINativeMethod methods[]={
    {&quot;add&quot;,&quot;(II)I&quot;,(void*)myadd},};
int registerNatives(JNIEnv *env)
{
    jclass clazz;

    clazz=(*env)-&gt;FindClass(env,classPathName);
    if(NULL==clazz){
       printf(&quot;[C] FindClass fail\n&quot;);
       goto failed;
    }
     if (0&gt;(*env)-&gt;RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0]))){
         printf(&quot;RegisterNatives fail.\n&quot;);
         goto failed;
     }
     return JNI_TRUE;
failed:
     return JNI_FALSE;
}


jint JNI_OnLoad(JavaVM *vm,void *reserved)
{
    JNIEnv *env=NULL;
    jint result=-1;
    void **env_p=NULL;

    printf(&quot;start register native func\n&quot;);
    env_p=(void**)&amp;env;

    if(JNI_OK!=(*vm)-&gt;GetEnv(vm,env_p,0x00010006)){
        printf(&quot;get env failed..\n&quot;);
        goto err;
    }
    if(JNI_TRUE!=registerNatives(env)){
        printf(&quot;register fail...exit....\n&quot;);
        goto err;
    }
    result=0x00010006;
err:
    return result;
}
</code></pre><h4 id="step-use"><a href="#step-use" class="headerlink" title="step use:"></a>step use:</h4><p>1.首先编写SimpleJni.java和simpel_jni.c<br>    2.编译java和c文件<br>$ java -d .  SimpleJni.java<br>$gcc -fPIC -I$JAVA_HOME/include/ -I$JAVA_HOME/include/linux/ -o libsimpleJni.so simple_jni.c</p>
<pre><code>3.执行
$java -Djava.library.path=. com.bt.jni.SimpleJni
</code></pre><h4 id="other-example"><a href="#other-example" class="headerlink" title="other example:"></a>other example:</h4><p>java file:<br>    import java.util.*;<br>    public class TestJni<br>    {<br>        public native void xprint(String content);<br>        static<br>        {<br>            System.loadLibrary(“TestJni”);<br>        }<br>        public native static String native_hello();<br>    }</p>
<p>JNI file:</p>
<pre><code>#include&lt;jni.h&gt;
#include&lt;stdio.h&gt;
//#include &quot;TestJni.h&quot;
#include&lt;iostream&gt;
using namespace std;
 void xprint(JNIEnv *env,jobject obj,jstring content)
{  
//    const jbyte *str=(const jbyte*)(env-&gt;GetStringUTFChars(env,content,JNI_FALSE));
    //printf(&quot;hello--wo%s \n&quot;,str);
//    env-&gt;ReleaseStringUTFChars(env,content,(const char*)str);
        cout&lt;&lt;&quot;here:&quot;&lt;&lt;content&lt;&lt;endl;
    return;
}
static jstring  native_hello(JNIEnv *env,jobject object)
{ 


    return (env)-&gt;NewStringUTF(&quot;keshixi&quot;);
}

static JNINativeMethod method_table[]={
    { &quot;xprint&quot;,&quot;(Ljava/lang/String;)V&quot;,(void*)xprint},
    {&quot;native_hello&quot;,&quot;()Ljava/lang/String;&quot;,(void*)native_hello}
//    {,,(void*)xprint},{,,(void*)native_hello}
};

 jint JNI_OnLoad(JavaVM *jvm,void *reserved){
    JNIEnv *env;
    if(jvm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6)!=JNI_OK){
        return -1;
    }
    jclass clz=env-&gt;FindClass(&quot;TestJni&quot;);
    if(clz==NULL)
    {
        return JNI_FALSE;
    }
    if(env-&gt;RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK){
        return JNI_VERSION_1_6;
    }
  }
</code></pre><p>####reference:<br>jni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行</p>
<p>动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子</p>
<p>另外可以作为ndk在android中使用及在android　stdio也可以直接生成so</p>
<p>一些链接：android_jni_ndk:<a href="http://www.cnblogs.com/wzben/p/5733571.html" target="_blank" rel="noopener">http://www.cnblogs.com/wzben/p/5733571.html</a><br>动态注册无运行实例：<a href="http://www.linuxidc.com/Linux/2017-02/140130.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2017-02/140130.htm</a><br>静态注册：<a href="http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html" target="_blank" rel="noopener">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br>动态注册：有实例<a href="http://www.linuxidc.com/Linux/2017-02/140129.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2017-02/140129.htm</a></p>
<p><a href="http://www.fer.unizg.hr/_download/repository/jni.pdf文档" target="_blank" rel="noopener">www.fer.unizg.hr/_download/repository/jni.pdf文档</a>    </p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title>android_adb</title>
    <url>/2018/05/20/android-adb/</url>
    <content><![CDATA[<h4 id="android-adb-command"><a href="#android-adb-command" class="headerlink" title="android adb command"></a>android adb command</h4><p>从android群英传中学习到额外的几个adb指令，是之前没接触到的：<br>adb list targets<br>adb install -r　xx.apk -r为覆盖<br>adb shell df<br><a id="more"></a><br>adb shell pm list packages -f<br>adb shell input keyevent 3　　－－模拟按键输入，这里为点击home建<br>adb shell touchscreen ..模拟滑动<br>adb shell dumpsys 监听Activity运行状态<br>adb shell screenrecord /sdcard/demo.mp4  录制　屏幕<br>adb shell am start -n 包名/包名＋类名</p>
<p>更多，见google　develop中android studio的部分<br>另在源码目录中/system/core/toolbox  和/frameworks/base/cmds为所有ADB命令和shell命令来源</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title>android_AndroidManifest</title>
    <url>/2018/05/20/android-AndroidManifest/</url>
    <content><![CDATA[<h4 id="一个典型的androidmanifest文件："><a href="#一个典型的androidmanifest文件：" class="headerlink" title="一个典型的androidmanifest文件："></a>一个典型的androidmanifest文件：</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.example.ksx.helloworld&quot;&gt;
&lt;!-- more --&gt;
    &lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;hallo&quot;//app的名字和显示在bar上的文字
        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/AppTheme&quot;&gt;
        &lt;activity android:name=&quot;.MainActivity&quot;&gt;//活动的注册
        &lt;android:label=&quot;this is hallo&quot;&gt;//会覆盖上面的
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;//声明为主活动

                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_coding</tag>
      </tags>
  </entry>
  <entry>
    <title>android_makefirst_app</title>
    <url>/2018/05/20/android-makefirst-app/</url>
    <content><![CDATA[<h3 id="install-and-make-first-app"><a href="#install-and-make-first-app" class="headerlink" title="install and make first app"></a>install and make first app</h3><p>20170608<br>今天主要是安装了android-studio环境并成功开发第一个helloworld   app 在模拟器和手机上运行，下面是整个教程：在ubuntu下</p>
<h4 id="1-安装java-jdk"><a href="#1-安装java-jdk" class="headerlink" title="1 安装java-jdk:"></a>1 安装java-jdk:<a id="more"></a></h4><p>a  先下载java-jdk:Java SE Development Kit 8 Downloads<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>下载对应系统的版本</p>
<p>b  下载到某个目录，解压到要安装的目录：如：/usr/jdk-8/</p>
<p>c   设置全局环境变量：如上述的安装目录，则将<br>export JAVA_HOME=/usr/jdk-8<br>export JRE_HOME=$JAVA_HOME/jre<br>export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib<br>export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin<br>添加到/etc/profile文件中，在末尾另起一行添加</p>
<p>d 使用source /etc/profile命令使刚才配置的信息生效</p>
<p>e 测试是否成功：java -version<br>测试,编写java文件：<br>public class test{<br>    public static void main(String[] args){<br>        System.out.println(“hello world”);<br>    }<br>}<br>保存为test.java，<br>生成字节码：javac test.java<br>运行:java test</p>
<h3 id="2-安装android-studio"><a href="#2-安装android-studio" class="headerlink" title="2 安装android-studio:"></a>2 安装android-studio:</h3><p>a 下载：在官网或者其他网站下载后<br>b 按照installion说明进行：一般是先选择要安装的目录：如/usr/android-studio<br>c　直接在终端,进入bin目录后:./studio.sh<br>d 还有其他配置．比如在任意目录都能打开软件．<br>e 其他见说明文件等</p>
<p>3 第一个app helloworld<br>在模拟器上运行<br>打开软件－－&gt;选择新建一个工程，适当选择之后-&gt;选择build-&gt;make project-&gt;点击run–<br>–&gt;会提示选择安装下载模拟器–&gt;选择合适的，最好不要是带锁的<br>－－－&gt;之后会提示成功．再选择建立一个模拟器，之后就可以了</p>
<p>注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm<br>如果不能运行x86的，可能需要安装kvm:<br>也可以使用genymotion模拟器</p>
<h4 id="4-安装kvm可选"><a href="#4-安装kvm可选" class="headerlink" title="4 安装kvm可选"></a>4 安装kvm可选</h4><p>要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？<br>那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。<br>首先要确定你的cpu满足要求，下面有几个命令可以参考：</p>
<p>$ egrep -c ‘(vmx|svm)’ /proc/cpuinfo<br>4</p>
<p>打印的值不为0即可。</p>
<p>下面安装kvm：</p>
<p>$ sudo apt-get install qemu-kvm<br>$ sudo adduser linc kvm<br>$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils<br>$ sudo adduser linc libvirtd</p>
<p>(linc为用户名，适当改）<br>检验安装是否成功：</p>
<p>$ sudo virsh -c qemu:///system list</p>
<h2 id="Id-Name-State"><a href="#Id-Name-State" class="headerlink" title=" Id    Name                           State"></a> Id    Name                           State</h2><p>运行，在有模拟器的目录中：<br>如/home/ksx/Android/Sdk/emulator/emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm</p>
<p>使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。</p>
<p>如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。</p>
<h4 id="5在手机上运行app"><a href="#5在手机上运行app" class="headerlink" title="5在手机上运行app"></a>5在手机上运行app</h4><p>首先连接手机，打开usb调试<br>还是一样，但是选择app那里不是app,而是选择Edit Configurations<br>之后选择usb　device，ok，就可以了，接着运行</p>
<h4 id="关于项目结构模式："><a href="#关于项目结构模式：" class="headerlink" title="关于项目结构模式："></a>关于项目结构模式：</h4><p>默认为android<br>设置为project可以看到整个完整的目录结构：<br>　　　　　.gradle和.idea 为自动生成<br>　　　　　app<br>　　　　　build   编译时自动生成的文件，不用太关心<br>　　　　　gradle   包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle<br>     .gitignore<br>     build.gradle<br>     gradle.properties  全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本<br>     gradlew　和gradlew.bat在命令行中执行gradle命令<br>     local.properties　　指定本机android sdk路径<br>     setting.gradle指定项目中引入的模块</p>
<pre><code>app目录下
build　　为自动生成，同上
lib   项目使用的第三方库
test 测试用例
proguard-rules.pro  代码混淆规则
</code></pre><h4 id="build-gradle-intruduce"><a href="#build-gradle-intruduce" class="headerlink" title="build gradle intruduce"></a>build gradle intruduce</h4><p>gradle  Groovy 领域语言　　DSL    摒弃了Ant 和Maven </p>
<p>在app 外有一个 build.gradle。在app中有一个build.gradle</p>
<p>在外面的　gradle 也可以构建c++等项目，<br>buildscript {<br>    repositories {<br>        jcenter()　　　//代码托管仓库　利用它可以轻松引用jcenter开源项目</p>
<pre><code>}
dependencies {
    classpath &apos;com.android.tools.build:gradle:2.3.2&apos;　　//声明构建的是android

    // NOTE: Do not place your application dependencies here; they belong
    // in the individual module build.gradle files
}
</code></pre><p>}</p>
<p>allprojects {<br>    repositories {<br>        jcenter()<br>    }<br>}</p>
<p>task clean(type: Delete) {<br>    delete rootProject.buildDir<br>}</p>
<p>app中<br>apply plugin: ‘com.android.application’　//表明为android 应用程序模块，为com.android.library表示库模块</p>
<p>android {　　　//安卓闭包<br>    compileSdkVersion 25　　　　//项目的编译版本，25为API 25,对应android 7.1<br>    buildToolsVersion “25.0.3”   //项目构建工具版本<br>    defaultConfig {<br>        applicationId “org.example.myactivity1”　　　项目包名<br>        minSdkVersion 25　　　　　//项目最低兼容的android系统版本<br>        targetSdkVersion 25　　//表明如22表示只在22测试充分，如不启动运行时权限，android６　的运行时权限就不会加，表明只在5上做充分测试<br>        versionCode 1　　　项目版本编号<br>        versionName “1.0”　　　项目版本名<br>        testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner”<br>    }<br>    buildTypes {//分debug和release版本<br>        release {<br>            minifyEnabled false　//是否混淆代码<br>            proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’//混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件<br>        }<br>    }<br>}</p>
<p>dependencies {//分本地依赖，库依赖和远程依赖<br>    compile fileTree(dir: ‘libs’, include: [‘*.jar’])　　//本地依赖声明<br>    androidTestCompile(‘com.android.support.test.espresso:espresso-core:2.2.2’, {<br>        exclude group: ‘com.android.support’, module: ‘support-annotations’<br>    })<br>    compile ‘com.android.support:appcompat-v7:25.3.1’　　//　依赖库<br>    compile ‘com.android.support.constraint:constraint-layout:1.0.2’<br>    testCompile ‘junit:junit:4.12’　　//测试用例库<br>}</p>
<p>其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title>android_howto_makeapk_cmd</title>
    <url>/2018/05/20/android-howto-makeapk-cmd/</url>
    <content><![CDATA[<h3 id="how-to-make-a-android-by-cmd"><a href="#how-to-make-a-android-by-cmd" class="headerlink" title="how to make a android by cmd :"></a>how to make a android by cmd :</h3><pre><code>在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni
</code></pre><a id="more"></a>
<h3 id="way-1-方法１"><a href="#way-1-方法１" class="headerlink" title="way 1:方法１"></a>way 1:方法１</h3><h4 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h4><pre><code>android studio 创建了一个工程，然后手动在命令行打包，进入工程里的.  或者direct use andrid create project创建
</code></pre><p>cd ~/Desktop/FirstTest/app/src/main<br>mkdir gen<br>mkdir build<br>mkdir out</p>
<p>在android工程目录下建立Makefile文件，添加如下代码：<br>    SDK=~/Android/Sdk　　　　<br>    BUILD_TOOLS=$(SDK)/build-tools/25.0.3<br>    PLATFORMS=$(SDK)/platforms/android-25<br>    aapt=$(BUILD_TOOLS)/aapt<br>    dx=$(BUILD_TOOLS)/dx<br>    aidl=$(BUILD_TOOLS)/aidl<br>    apkbuilder=$(SDK)/tools/apkbuilder2 //后面不支持apkbuilder所以<br>    adb=$(SDK)/platform-tools/adb</p>
<h4 id="资源编译，生成-R-java"><a href="#资源编译，生成-R-java" class="headerlink" title="资源编译，生成 R.java"></a>资源编译，生成 R.java</h4><pre><code>aapt_task:
    $(aapt) package \
    -f \ #如果编译出来的文件已经存在，强制覆盖
    -M  AndroidManifest.xml  \ # Mainifest.xml 的路径
    -I  $(PLATFORMS)/android.jar \ # 某个版本平台的 android.jar 的路径　#依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...
    -S  res/ \ # res 文件夹路径
    -J gen/ \ # 生成 R.java 的输出目录
    -m  #使得生成的包的目录放在 -J 参数指定的目录
</code></pre><h4 id="代码编译，生成-class"><a href="#代码编译，生成-class" class="headerlink" title="代码编译，生成 .class"></a>代码编译，生成 .class</h4><pre><code>javac_task:
    javac -source 1.7 -target 1.7 \ # 使用 jdk1.8 编译 1.7 的 .class 文件
    -encoding UTF-8 \ 
    -bootclasspath  $(PLATFORMS)/android.jar \ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...
    -d build/ \ #指定放置生成的类文件的位置
    java/thereisnospon/dextest/*.java \
    gen/thereisnospon/dextest/*.java \
</code></pre><h4 id="生成-dex"><a href="#生成-dex" class="headerlink" title="生成 .dex"></a>生成 .dex</h4><pre><code>dx_task:
    $(dx) --dex --output=build/classes.dex \
    build  
</code></pre><h4 id="资源文件初始包"><a href="#资源文件初始包" class="headerlink" title="资源文件初始包"></a>资源文件初始包</h4><pre><code>resapk_task:
    $(aapt) package -f \
    -M  AndroidManifest.xml  \
    -I  $(PLATFORMS)/android.jar \
    -S  res/ \
    -F  out/resources
</code></pre><h4 id="将-dex-文件加入到资源文件初始包中"><a href="#将-dex-文件加入到资源文件初始包中" class="headerlink" title="将.dex 文件加入到资源文件初始包中"></a>将.dex 文件加入到资源文件初始包中</h4><p>　　<br>注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行</p>
<pre><code>apk_task:    
    java -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \
      com.android.sdklib.build.ApkBuilderMain \
      Demo.apk -v -u -z src/main/out/resources\
      -f src/main/build/classes.dex -rf src
</code></pre><h4 id="签名，使用debug的签名"><a href="#签名，使用debug的签名" class="headerlink" title="签名，使用debug的签名"></a>签名，使用debug的签名</h4><pre><code>signer:
    jarsigner -verbose \
    -keystore ~/.android/debug.keystore \
    -storepass android \
    -keypass android \
    Demo.apk  androiddebugkey
</code></pre><h4 id="一次性打包"><a href="#一次性打包" class="headerlink" title="一次性打包"></a>一次性打包</h4><pre><code>pkg: 
    make apk_task
    make signer 
</code></pre><h4 id="卸载apk"><a href="#卸载apk" class="headerlink" title="卸载apk"></a>卸载apk</h4><pre><code>uninstall:
    $(adb) uninstall  thereisnospon.dextest
</code></pre><h4 id="安装apk"><a href="#安装apk" class="headerlink" title="安装apk"></a>安装apk</h4><pre><code>install: 
    $(adb) install out/app.apk
</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>run:<br>    make pkg<br>    make uninstall<br>    make install</p>
<pre><code>$(adb) shell am start -n thereisnospon.dextest/        thereisnospon.dextest.MainActivity  
</code></pre><h3 id="方法２，用gradle"><a href="#方法２，用gradle" class="headerlink" title="方法２，用gradle,"></a>方法２，用gradle,</h3><p>首先用AS 建立工程，之后在工程文件下，之星执行，gradle clean<br>gradle build<br>即生成apk文件</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_make</tag>
      </tags>
  </entry>
  <entry>
    <title>android_will_write</title>
    <url>/2018/05/20/android-will-write/</url>
    <content><![CDATA[<p>#test categories<br>this is the android categories to test </p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android_activity</tag>
      </tags>
  </entry>
  <entry>
    <title>test_article_picture</title>
    <url>/2018/05/20/test-article-picture/</url>
    <content><![CDATA[<p>##this is a test of picture with test again in 2019<br><img src="/2018/05/20/test-article-picture/example.jpg" title="This is an example image"><br>end</p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
