<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>追光者</title>
  
  <subtitle>小兴的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xdksx.github.io/"/>
  <updated>2018-06-09T11:37:00.130Z</updated>
  <id>http://xdksx.github.io/</id>
  
  <author>
    <name>小兴</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cpp_conandde</title>
    <link href="http://xdksx.github.io/2018/06/09/cpp-conandde/"/>
    <id>http://xdksx.github.io/2018/06/09/cpp-conandde/</id>
    <published>2018-06-09T03:03:35.000Z</published>
    <updated>2018-06-09T11:37:00.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-class-constructor-and-destructor"><a href="#c-class-constructor-and-destructor" class="headerlink" title="c++ class constructor and destructor"></a>c++ class constructor and destructor</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="构造函数表现"><a href="#构造函数表现" class="headerlink" title="构造函数表现"></a>构造函数表现</h4><h5 id="构造函数的作用："><a href="#构造函数的作用：" class="headerlink" title="构造函数的作用："></a>构造函数的作用：</h5><p>构造函数主要是用来初始化对象的－－－一般是成员，函数不用<br>–所以它需要在构建对象时就执行<a id="more"></a></p><h5 id="构造函数如何写："><a href="#构造函数如何写：" class="headerlink" title="构造函数如何写："></a>构造函数如何写：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:　classname(arg...):member(arg),mem2(arg),..&#123;xxx&#125;</span><br><span class="line">    classname(..)&#123;..&#125;</span><br><span class="line">```        </span><br><span class="line">##### 默认构造函数的生成规则（深入对象模型）</span><br><span class="line">+ 下面四个情况下会生成默认构造函数（编译器控制）(nontrivial <span class="keyword">default</span> constructor)  </span><br><span class="line"> + 带有<span class="keyword">default</span> constructor的member <span class="class"><span class="keyword">class</span> <span class="title">object</span>  </span></span><br><span class="line"><span class="class"> 即在类中带有对象成员，该对象成员所属的类有构造函数</span></span><br><span class="line"><span class="class">如：　</span></span><br><span class="line"><span class="class">```<span class="title">cpp</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Foo</span> &#123;</span><span class="keyword">public</span> :Foo(),Foo(<span class="keyword">int</span>)...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span><span class="keyword">public</span>:Foo foo;<span class="keyword">char</span> *str&#125;;</span><br><span class="line">                          <span class="function"><span class="keyword">void</span> <span class="title">funv</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                          </span>&#123;   Bar bar;....</span><br><span class="line">                          &#125;</span><br></pre></td></tr></table></figure><p>这种情况下若程序员没有实现构造函数，则编译器会自己生成构造函数，来调用Foo的构造函数<br>但是不初始化str,这个得由程序员来做。<br>如类似于：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Bar::Bar()&#123;</span><br><span class="line">   foo.Foo::Foo();</span><br><span class="line"> ```                  </span><br><span class="line"> 若程序员自己写了构造函数但是不包括初始化foo则，编译器会在程序眼写的构造函数中加入上述，另外若有多个对象</span><br><span class="line">则按照声明顺序进行调用他们的构造函数；</span><br><span class="line"> + 带有Default constructor 的base <span class="class"><span class="keyword">class</span>  </span></span><br><span class="line"><span class="class"> 同理，当继承的基类带有构造函数时就会加入，若程序员的构造函数没有初始化他们时就会扩展  </span></span><br><span class="line"><span class="class">//以上见例子<span class="title">class_constructor</span>.<span class="title">cpp</span>，</span></span><br><span class="line"><span class="class"> + 和<span class="title">vcirtual</span>相关<span class="title">need</span> <span class="title">to</span> <span class="title">create</span> <span class="title">vptr</span>  </span></span><br><span class="line"><span class="class">    带有一个<span class="title">virtual</span>　<span class="title">func</span>的<span class="title">class</span>  </span></span><br><span class="line"><span class="class">     1)<span class="title">class</span>　声明或继承一个<span class="title">virtua</span> <span class="title">func</span>  </span></span><br><span class="line"><span class="class">     2)<span class="title">class</span>派生自一个继承琏，其中有<span class="title">virtual</span> <span class="title">base</span> <span class="title">classes</span>       这个比较容易理解</span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class"> + 和<span class="title">virtual</span>相关 <span class="title">need</span> <span class="title">to</span> <span class="title">init</span> <span class="title">vptr</span></span></span><br><span class="line"><span class="class">   带有一个<span class="title">virtual</span>　<span class="title">base</span> <span class="title">class</span> 的<span class="title">class</span>  </span></span><br><span class="line"><span class="class">   如：</span></span><br><span class="line"><span class="class">   ```<span class="title">cpp</span></span></span><br><span class="line"><span class="class">       <span class="title">class</span> <span class="title">X</span>&#123;</span>  <span class="keyword">public</span> <span class="keyword">int</span> i;&#125;  </span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="comment">///</span></span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A,<span class="keyword">public</span> B</span><br></pre></td></tr></table></figure></p><h5 id="构造函数何时被执行"><a href="#构造函数何时被执行" class="headerlink" title="构造函数何时被执行"></a>构造函数何时被执行</h5><p>-在对象定义时若有构造函数，则会执行</p><h5 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h5><p>1:5构造函数的使用：重载，初始化式</p><h4 id="构造函数表现的原理"><a href="#构造函数表现的原理" class="headerlink" title="构造函数表现的原理"></a>构造函数表现的原理</h4><h5 id="构造函数在静态代码块中的位置和符号体现"><a href="#构造函数在静态代码块中的位置和符号体现" class="headerlink" title="构造函数在静态代码块中的位置和符号体现"></a>构造函数在静态代码块中的位置和符号体现</h5><p>如果有定义构造函数，它本身也是一个函数，放在代码段中，可以通过kdbg查看<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">origin(<span class="keyword">int</span> ax=<span class="number">3</span>,<span class="keyword">int</span> bx=<span class="number">4</span>):a(ax),b(bx)&#123;&#125;</span><br><span class="line"><span class="number">0x400bae</span> push   %rbp</span><br><span class="line"><span class="number">0x400baf</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x400bb2</span> mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line"><span class="number">0x400bb6</span> mov    %esi,<span class="number">-0xc</span>(%rbp)</span><br><span class="line"><span class="number">0x400bb9</span> mov    %edx,<span class="number">-0x10</span>(%rbp)</span><br></pre></td></tr></table></figure></p><h5 id="构造函数在动态执行时，放在哪个内存段中，如何被引用，使用"><a href="#构造函数在动态执行时，放在哪个内存段中，如何被引用，使用" class="headerlink" title="构造函数在动态执行时，放在哪个内存段中，如何被引用，使用"></a>构造函数在动态执行时，放在哪个内存段中，如何被引用，使用</h5><ul><li>动态执行时，在代码段中，通过this引用</li><li>构造函数总结：任何c++ class只有在以上四中情况下才会产生默认构造函数，且产生的默认构造函数不会去初始化成员的值<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><h4 id="拷贝的动作发生了什么"><a href="#拷贝的动作发生了什么" class="headerlink" title="拷贝的动作发生了什么"></a>拷贝的动作发生了什么</h4>拷贝的本质，为什么需要拷贝构造函数？</li><li>首先对基本的类型而言，拷贝是把值赋给另一个同类型的变量，而数租不能做=赋值拷贝</li><li>对对象而言，也是把值赋给同类型的对象，而不是共享一个指针，所以这个过程需要将对象中的成员也复制过去（复制的是当前对象在此时时成员的值　）</li><li>c++中的拷贝构造函数针对三种行为：＝　，f(T t)和　f(){T t;return t}返回对象－－这三种情况都针对左值的　　　</li><li>=:注意这个是在定义时做的，如origin or1=or2;此时会调用”拷贝构造函数”（　同or1(or2))<br>　or2=or3;此时不会调用拷贝构造函数<br>（当程序员自己写了拷贝构造函数时，默认调用该构造函数，而不会区做成员复制，所以若在其中没有做复制，可能得到不想要的值，见例子)</li></ul><h4 id="拷贝构造函数的作用和使用"><a href="#拷贝构造函数的作用和使用" class="headerlink" title="拷贝构造函数的作用和使用"></a>拷贝构造函数的作用和使用</h4><h5 id="什么情况下会生成默认的拷贝构造函数？"><a href="#什么情况下会生成默认的拷贝构造函数？" class="headerlink" title="什么情况下会生成默认的拷贝构造函数？"></a>什么情况下会生成默认的拷贝构造函数？</h5><p>类似于构造函数，在以下情形会生成默认的拷贝构造函数－</p><ul><li>当需要调用别的拷贝构造函数时，如：当类内含有一个member object而后者的class声明有一个copy　constructor时；</li><li>当类继承自一个base class而后者有拷贝构造函数</li><li>当类声明了一个或多个virtual functions时</li><li>当class 派生自一个继承　串琏，而其中有一个或多个virtual base classes 时</li></ul><h4 id="拷贝构造函数和编译器－－－汇编，转换："><a href="#拷贝构造函数和编译器－－－汇编，转换：" class="headerlink" title="拷贝构造函数和编译器－－－汇编，转换："></a>拷贝构造函数和编译器－－－汇编，转换：</h4><p>分三种情况讨论：</p><ul><li><p>初始化拷贝构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">x1</span><span class="params">(x0)</span></span>;</span><br><span class="line">X x2=x0;</span><br><span class="line">X x3=X(x0);</span><br></pre></td></tr></table></figure><p> 上述三种都是定义一个类，即定义的本质会在内存中开辟空间<br>上述三个都会执行拷贝构造函数，如何执行？<br>会被转换为：伪代码</p><pre><code>X x1;x1.X::X(x0);会调用X::X(const X&amp; xx) x2,x3也是这样，将拷贝方作为函数参数传入这样就可以解释为什么拷贝构造函数的定义是      classname (const classname &amp;obj)</code></pre></li><li>参数的初始化<br>即传入一个参数给函数：<pre><code>foo(X x)</code></pre>如：<pre><code>X xx;//,..foo(xx);则会产生一个临时的对象：</code></pre>伪代码<pre><code>X __temp0;_temp0.X::X(xx);//use copy construtor foo(__temp0)</code></pre>这里因为它是临时的，所以则定义的时候需要用引用foo(X &amp;x)//这里不是很清楚为什么用引用～！，是否后面的操作直接面向该对象，需要做实际的修改，所以。。<br>所以，为了对付临时的对象，在执行完函数后，需要调用该对象的析构函数</li><li>返回值的初始化：<br>如<pre><code>X bar(){               X xx;                //...                return xx;     }  如何做X xxx=bar();如何拷贝的？双阶段初始化：  a 增加一个额外的引用参数给函数，如void bar(X＆　_result)  b 在return 前插入一个copy constructor       void bar(X &amp;__result){                X xx;                xx.X::X();                __result.X::XX(xx);                return ;        } 所以上述会被转化为： Ｘ　xx=bar()  ---&gt;  X xx ;//注意这里不会执行默认构造函数　　bar(xx);     ex:bar().memfunc()---&gt;X __temp0;(bar(__temp0),__temp0).memfunc();     X (*pf)();pf=bar;---&gt;void (*pf)(X&amp;);pf=bar;</code></pre></li></ul><h5 id="关于上述三种情况的优化："><a href="#关于上述三种情况的优化：" class="headerlink" title="关于上述三种情况的优化："></a>关于上述三种情况的优化：</h5><p>１)在使用者层面上优化；２）在编译器层面的优化（ＮＲＶ）具体见深入模型（书）</p><h5 id="关于该不该编写copy-constructor"><a href="#关于该不该编写copy-constructor" class="headerlink" title="关于该不该编写copy  constructor:"></a>关于该不该编写copy  constructor:</h5><p>除非需要大量的memberwise 初始化操作，如传值给object以便做NRV优化，否则不需要<br>//上述情况的检验可以通过代码，或者去看编译器的生成代码～    </p><h5 id="拷贝构造函数的内存"><a href="#拷贝构造函数的内存" class="headerlink" title="拷贝构造函数的内存"></a>拷贝构造函数的内存</h5><p>放在代码段，</p><h3 id="初始化队列"><a href="#初始化队列" class="headerlink" title="初始化队列"></a>初始化队列</h3><p>即构造函数的一种形式如：X(int f):a(ax),b(bx)..{….}</p><ul><li><p>问题：什么时候用初始化列表？它和初始化赋值有什么不同？</p><pre><code>有以下四种情况需要使用初始化列表：１）当初始化一个reference member时２）当初始化一个const member时３）当调用一个base class的constructor,当它拥有一组参数时４）当调用一个member　class 的consructor，而它有一组参数时；</code></pre><p>如<br><code></code>cpp<br> class world {</p><pre><code>String _nhame;int cnt;public :world(){_nhame=0;cnt=0;}}<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时，对_nhame这个成员，需要做较多的事，如产生临时对像，调用operator=....</span></span><br><span class="line">   －－－－所以想到用初始化列表：</span><br><span class="line">```cpp </span><br><span class="line">          world::world:nhame(<span class="number">0</span>)&#123;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            这样只会调用nhame的构造函数</span><br><span class="line">            会被转换为：world::world&#123; <span class="comment">//伪代码</span></span><br><span class="line">             _nhame.String::String(<span class="number">0</span>);</span><br><span class="line">              cnt=<span class="number">0</span>;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>更具体的，初始化列表如何进行：顺序如何：如前，初始化列表最终会被转换为初始化表达式到构造函数体中，那是什么顺序呢？<br>注意这里的初始化顺序是根据成员在类中的定义（声明）顺序来的，而不是初始化列表中的顺序<br>看这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">             <span class="keyword">int</span> i; </span><br><span class="line">             <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">              X(<span class="keyword">int</span> cal):i(j)&#123;&#125;</span><br><span class="line">              ...</span><br><span class="line">              此时，因为i先初始化,再j,出错，i需要j</span><br></pre></td></tr></table></figure></li></ul><p>  —-&gt;可以改善为：X::X(int cal):j(cal){i=j;}<br>   —-为什么这样可以？<br>   因为初始化列表的内容会放到初始化体中的表达式前面，这样j就会先定义<br>        －－－－》另一个可能出错的例子：<br>        　　　X::X(int cal):i(xfoo(cal)),j(cal){}<br>        –&gt;转换为：X::X(/<em>this pointer</em>/ int cal){<br>                      i=this-&gt;xfoo(cal);<br>                      j=cal;<br>                      }<br>            这个情况在这里是对的，但是当X 继承自某个类，在xfoo是基类的函数，，则会出错this-&gt;xfoo</p><h4 id="几个问题："><a href="#几个问题：" class="headerlink" title="几个问题："></a>几个问题：</h4><ul><li>较为简单的例子见文件中的例子</li><li>当程序员定义了拷贝构造函数时，还会执行memberwise initialization吗　－－会执行拷贝构造函数<br>参考：深入c++对象模型和<a href="http://en.cppreference.com/w/cpp/language/copy_constructor" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/language/copy_constructor</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;c-class-constructor-and-destructor&quot;&gt;&lt;a href=&quot;#c-class-constructor-and-destructor&quot; class=&quot;headerlink&quot; title=&quot;c++ class constructor and destructor&quot;&gt;&lt;/a&gt;c++ class constructor and destructor&lt;/h2&gt;&lt;h3 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h3&gt;&lt;h4 id=&quot;构造函数表现&quot;&gt;&lt;a href=&quot;#构造函数表现&quot; class=&quot;headerlink&quot; title=&quot;构造函数表现&quot;&gt;&lt;/a&gt;构造函数表现&lt;/h4&gt;&lt;h5 id=&quot;构造函数的作用：&quot;&gt;&lt;a href=&quot;#构造函数的作用：&quot; class=&quot;headerlink&quot; title=&quot;构造函数的作用：&quot;&gt;&lt;/a&gt;构造函数的作用：&lt;/h5&gt;&lt;p&gt;构造函数主要是用来初始化对象的－－－一般是成员，函数不用&lt;br&gt;–所以它需要在构建对象时就执行
    
    </summary>
    
      <category term="c&amp;cpp" scheme="http://xdksx.github.io/categories/c-cpp/"/>
    
    
      <category term="cpp_class" scheme="http://xdksx.github.io/tags/cpp-class/"/>
    
  </entry>
  
  <entry>
    <title>cpp_class_memory</title>
    <link href="http://xdksx.github.io/2018/06/09/cpp-class-memory/"/>
    <id>http://xdksx.github.io/2018/06/09/cpp-class-memory/</id>
    <published>2018-06-09T02:44:41.000Z</published>
    <updated>2018-06-09T11:00:32.506Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-类内存布局："><a href="#c-类内存布局：" class="headerlink" title="c++类内存布局："></a>c++类内存布局：</h3><h4 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h4><p>下编译后的“内存布局”，此时还未分配内存，不能算是内存，只能说是文件布局<a id="more"></a></p><ul><li>two question:<br>多少内存能表现一个ob:?<br>多少内存能表现一个class?–编译期，如　int 大小为４ </li><li>静态下，编译后同C一样分为代码段等；而类的特性有些类似于struct,定义类的文件中包含了成员变量，成员函数。</li><li>类：<pre><code>非静态成员变量：存于对象中vptr指针：存于对象中vt表:vptr指向这个表，这个表在构造函数中默认隐士初始化，将对应的虚拟函数地址赋给表中的各个值（表本身with&quot;类&quot;）obj:         class:_vptr ---&gt;   table: ptr1 --&gt;virtual func1                    ptr2 --&gt;virtual func2静态变量: 存入数据段中成员函数:代码段,通过this和成员变量建立联系静态函数：　存于代码段中全局函数main函数全局变量和静态变量局部变量：栈something extra depend on compiler~</code></pre></li><li>some rules<ul><li>每个类产生一堆指向virtual func的指针，放在表格中，表称为：vtbl;   </li><li>每个obj被添加了一个指针，指向相关的tirtual table ,为vptr;</li><li>vptr的设定和重置由constructor，destructor,copy assignment运算服自动完成）　</li><li>注意每一个class所关联的type info object(用于支持runtime type identification  )也经由virtual table指出，放在vptr[0]处）</li><li>虚函数有可能被转换为：(*px-&gt;vtbl[1])(px)<pre><code>具体见深入c++模型书</code></pre></li></ul></li></ul><h4 id="多少内存能表现一个ob"><a href="#多少内存能表现一个ob" class="headerlink" title="多少内存能表现一个ob:?"></a>多少内存能表现一个ob:?</h4><ul><li>non static data members</li><li>padding</li><li>virtual—vptr<h4 id="多少内存能表现一个class"><a href="#多少内存能表现一个class" class="headerlink" title="多少内存能表现一个class?"></a>多少内存能表现一个class?</h4>见datamember_memory  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最小是１　  size  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span> &#125;;   --<span class="number">-1</span> 一个<span class="keyword">char</span> 表示这个类型  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;　　--指针大小，指针指向T    <span class="keyword">virtual</span> base <span class="class"><span class="keyword">class</span> <span class="title">subobject</span>  </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Y</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span> T&#123;&#125;;  --指针大小</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> X,<span class="keyword">public</span> Y &#123;&#125;;　--两个指针大小</span><br></pre></td></tr></table></figure></li></ul><p>more seee datamember_memory</p><h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4><p>的内存布局，即作为进程运行时，其内存是如何的；</p><ul><li>运行时，涉及类的对象模型，对象的内存部分只包含非静态成员变量和虚拟函数指针表；</li><li>可以通过gdb 或kgdb进行查看类对象的地址或者类函数的地址：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">Circle c12;</span><br><span class="line"><span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">1.2</span>,<span class="string">"red"</span>)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"getRadius:%x\n"</span>,&amp;Circle::getRadius);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x, %x\n"</span>,&amp;c12,c12);</span><br><span class="line"> <span class="keyword">void</span> *cc;</span><br><span class="line">        cc=(Circle*)(&amp;c12);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*((<span class="keyword">double</span>*)cc)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">```</span><br><span class="line">    </span><br><span class="line">所以c++的对象带来的开销在于操作多态时的vptr等效率低）</span><br><span class="line"></span><br><span class="line">一个例子</span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"A"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"B"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"C"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">6</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"D"</span>; &#125;</span><br><span class="line"><span class="number">0x400ae8</span> push   %rbp</span><br><span class="line"><span class="number">0x400ae9</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x400aec</span> mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">8</span>;&#125;</span><br><span class="line"><span class="number">0x400af8</span> push   %rbp</span><br><span class="line"><span class="number">0x400af9</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x400afc</span> mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    A aa;</span><br><span class="line">aa.getName();</span><br><span class="line">    D d;</span><br><span class="line">d.getName();</span><br><span class="line">A &amp;rBase = d;</span><br><span class="line">rBase.getName();</span><br><span class="line"><span class="number">0x400986</span> mov    <span class="number">-0x28</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x40098a</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x40098d</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x400990</span> mov    <span class="number">-0x28</span>(%rbp),%rdx</span><br><span class="line"><span class="number">0x400994</span> mov    %rdx,%rdi</span><br><span class="line"><span class="number">0x400997</span> callq  *%rax</span><br><span class="line">            rBase.getage();</span><br><span class="line"><span class="number">0x400999</span> mov    <span class="number">-0x28</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x40099d</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x4009a0</span> add    $<span class="number">0x8</span>,%rax</span><br><span class="line"><span class="number">0x4009a4</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x4009a7</span> mov    <span class="number">-0x28</span>(%rbp),%rdx</span><br><span class="line"><span class="number">0x4009ab</span> mov    %rdx,%rdi</span><br><span class="line"><span class="number">0x4009ae</span> callq  *%rax</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rBase is a "</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">D d2;</span><br><span class="line">            A &amp;rBase2 =d2;</span><br><span class="line"><span class="number">0x4009f9</span> lea    <span class="number">-0x30</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x4009fd</span> mov    %rax,<span class="number">-0x20</span>(%rbp)</span><br><span class="line">   rBase2.getName();</span><br><span class="line"><span class="number">0x400a01</span> mov    <span class="number">-0x20</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a05</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x400a08</span> mov    (%rax),%rax</span><br><span class="line"><span class="number">0x400a0b</span> mov    <span class="number">-0x20</span>(%rbp),%rdx</span><br><span class="line"><span class="number">0x400a0f</span> mov    %rdx,%rdi</span><br><span class="line"><span class="number">0x400a12</span> callq  *%rax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>something else:  </p><ul><li>成员函数也是只有一份被存于代码区中，而对象并没有指向成员函数的指针，对象只存成员和虚拟表　；那在对象.成员函数使用时，</li><li>是如何确定该函数中使用的成员是该对象的成员?<br>这里是this指针的作用<br>从汇编看，是否是成员函数在取的成员变量时，会做一些动作，这时的成员变量是在栈区；；<br>或者从调用成员函数时，是否有传入或控制函数的一些动作，让它知道从哪里取得对应的成员返回；</li><li>成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;c-类内存布局：&quot;&gt;&lt;a href=&quot;#c-类内存布局：&quot; class=&quot;headerlink&quot; title=&quot;c++类内存布局：&quot;&gt;&lt;/a&gt;c++类内存布局：&lt;/h3&gt;&lt;h4 id=&quot;静态&quot;&gt;&lt;a href=&quot;#静态&quot; class=&quot;headerlink&quot; title=&quot;静态&quot;&gt;&lt;/a&gt;静态&lt;/h4&gt;&lt;p&gt;下编译后的“内存布局”，此时还未分配内存，不能算是内存，只能说是文件布局
    
    </summary>
    
      <category term="c&amp;cpp" scheme="http://xdksx.github.io/categories/c-cpp/"/>
    
    
      <category term="cpp_memory" scheme="http://xdksx.github.io/tags/cpp-memory/"/>
    
  </entry>
  
  <entry>
    <title>cpp_this</title>
    <link href="http://xdksx.github.io/2018/06/09/cpp-this/"/>
    <id>http://xdksx.github.io/2018/06/09/cpp-this/</id>
    <published>2018-06-09T02:13:46.000Z</published>
    <updated>2018-06-09T10:38:32.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-关键字之this"><a href="#c-关键字之this" class="headerlink" title="c++关键字之this"></a>c++关键字之this</h3><h4 id="this指针是什么"><a href="#this指针是什么" class="headerlink" title="this指针是什么"></a>this指针是什么</h4><p>this是一个指向当前正在使用的对象的指针，它是一个指针；<br>成员函数通过它来使用对象的值，通过它知道要对哪个对象的成员操作<br>如：<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Simple(<span class="keyword">int</span> id)</span><br><span class="line">    &#123;</span><br><span class="line">        setID(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; m_id = id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Simple <span class="title">simple</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    simple.setID(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; simple.getID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">simple.setID(<span class="number">2</span>);---&gt;</span><br><span class="line">setID(&amp;simple, <span class="number">2</span>); <span class="comment">// note that simple has been changed from an object prefix to a function argument!</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; m_id = id; &#125;---&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(Simple* <span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">int</span> id)</span> </span>&#123; <span class="keyword">this</span>-&gt;m_id = id; &#125;</span><br></pre></td></tr></table></figure><h4 id="this指针用法"><a href="#this指针用法" class="headerlink" title="this指针用法"></a>this指针用法</h4><p>关键词 this 是一个纯右值表达式，其值是在调用成员函数时的对象地址。它能出现于下列语境：</p><ul><li>在任何非静态成员函数体内，含成员初始化列表</li><li>在非静态成员函数的声明内任何(可选) cv 限定符序列后处，包含动态异常规定(弃用)、 noexcept 规定(C++11)及尾随返回类型(C++11 起)</li><li>在默认成员初始化中 (C++11 起)</li><li>在一个对象的构造期间，若通过不直接或间接从构造函数的 this 指针获得的泛左值，访问对象的值或任何其子对象，则如此获得的对象或子对象的值是未指定的。换言之，构造函数中 this 指针不能别名使用：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">D</span> <span class="title">d</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line">D(<span class="keyword">int</span> a) : a(a), b(d.a) &#123;&#125; <span class="comment">// a(a)will change to this-&gt;a(a),but b(d.a)--&gt;this-&gt;b(d.a),and will get random value,but b(a) 或 b(this-&gt;a) 是正确的</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line">D d = D(<span class="number">1</span>);   <span class="comment">// 因为 b(d.a) 不通过 this 访问， d.b 现在是未指定的,i try in g++.find it d.b==1</span></span><br></pre></td></tr></table></figure><h4 id="this指针于内存哪里？"><a href="#this指针于内存哪里？" class="headerlink" title="this指针于内存哪里？"></a>this指针于内存哪里？</h4><p>this 指针是不占类的内存的，它是传入成员函数的参数，所以它在栈中  </p><h4 id="this-指针总是指向正在操作的对象："><a href="#this-指针总是指向正在操作的对象：" class="headerlink" title="this 指针总是指向正在操作的对象："></a>this 指针总是指向正在操作的对象：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Simple <span class="title">A</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// *this = &amp;A inside the Simple constructor</span></span><br><span class="line">    <span class="function">Simple <span class="title">B</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// *this = &amp;B inside the Simple constructor</span></span><br><span class="line">    A.setID(<span class="number">3</span>); <span class="comment">// *this = &amp;A inside member function setID</span></span><br><span class="line">    B.setID(<span class="number">4</span>); <span class="comment">// *this = &amp;B inside member function setID</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line">+ <span class="keyword">this</span>指针的连锁使用：  </span><br><span class="line">由<span class="keyword">this</span>指针理解<span class="built_in">cout</span>&lt;&lt;xxx&lt;&lt;&lt;xxx&lt;&lt;&lt;xxxxx....</span><br><span class="line">对上述的表达式，<span class="built_in">cout</span>是一个类，&lt;&lt;是该类的操作符函数，则&lt;&lt;函数返回<span class="keyword">this</span>，若返回空，则无法进行：  </span><br><span class="line">```cpp</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; userName;</span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span>) &lt;&lt; userName;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">void</span>) &lt;&lt; userName;　错误</span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span>) &lt;&lt; userName;正确</span><br><span class="line">如何写？</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Calc() &#123; m_value = <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Calc&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value += value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">sub</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value -= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">Calc&amp; <span class="title">mult</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; m_value *= value; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calc calc;</span><br><span class="line">    calc.add(<span class="number">5</span>).sub(<span class="number">3</span>).mult(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; calc.getValue() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意Calc&amp; 和return *this</p><h4 id="this指针到对象名代表的是什么"><a href="#this指针到对象名代表的是什么" class="headerlink" title="this指针到对象名代表的是什么"></a>this指针到对象名代表的是什么</h4><p>由above和以下例子：来看对象的地址等<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">set</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">set</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_i += i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">getval</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span> s;</span><br><span class="line">    s.add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.getval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//结果是２　因为函数返回的*this是一个值，它是set对象的值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span></span></span><br><span class="line"><span class="class">    5 &#123;</span>   </span><br><span class="line">    <span class="number">6</span>     <span class="keyword">int</span> m_e;</span><br><span class="line">    <span class="number">7</span>     <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="number">8</span>  <span class="keyword">public</span>:</span><br><span class="line">    <span class="number">9</span>     <span class="built_in">set</span>()</span><br><span class="line">   <span class="number">10</span>     &#123;</span><br><span class="line">   <span class="number">11</span>         m_e=<span class="number">0</span>;</span><br><span class="line">   <span class="number">12</span>         m_i=<span class="number">0</span>;</span><br><span class="line">   <span class="number">13</span>     &#125;</span><br><span class="line">   <span class="number">14</span>     <span class="function"><span class="built_in">set</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">   <span class="number">15</span>             m_i+=i;</span><br><span class="line">   <span class="number">16</span>             <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   <span class="number">17</span>     &#125;</span><br><span class="line">   <span class="number">18</span>     <span class="function"><span class="keyword">int</span> <span class="title">getval</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   <span class="number">19</span>             <span class="keyword">return</span> m_i;</span><br><span class="line">   <span class="number">20</span>     &#125;</span><br><span class="line">   <span class="number">21</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   33 </span>&#123;</span><br><span class="line">   <span class="number">34</span>         <span class="built_in">set</span> s;</span><br><span class="line">   <span class="number">35</span>         <span class="built_in">set</span> s2;</span><br><span class="line">&gt;&gt; <span class="number">36</span>         <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,s.add(<span class="number">2</span>));--输出<span class="number">0</span>,返回的是*<span class="keyword">this</span>，为s的值，m_e是其第一个成员</span><br><span class="line">&gt;&gt; <span class="number">37</span>         <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,s);－－输出<span class="number">0</span></span><br><span class="line">   <span class="number">38</span>         s2=s.add(<span class="number">2</span>);--s2被赋值了s，s此时的m_i=<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">   <span class="number">39</span>         s2.add(<span class="number">2</span>);--s2的m_i=<span class="number">6</span></span><br><span class="line">&gt;&gt; <span class="number">40</span>         <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s2);<span class="comment">//输出的是０－－－ m_e=0</span></span><br><span class="line">   <span class="number">41</span>         <span class="built_in">cout</span>&lt;&lt;s2.getval()&lt;&lt;<span class="built_in">endl</span>;-输出<span class="number">6</span>，因为</span><br><span class="line">   <span class="number">42</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">43</span> &#125;</span><br><span class="line"> 由此可以看出<span class="keyword">this</span>-&gt;object  <span class="keyword">this</span>-&gt;s</span><br><span class="line">            *<span class="keyword">this</span>==s</span><br><span class="line">            *<span class="keyword">this</span>==s的内容</span><br><span class="line">　　　　　　取对象的地址　&amp;s</span><br></pre></td></tr></table></figure></p><p>ref:<br><a href="http://zh.cppreference.com/w/cpp/language/this" target="_blank" rel="noopener">http://zh.cppreference.com/w/cpp/language/this</a><br><a href="http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/" target="_blank" rel="noopener">http://www.learncpp.com/cpp-tutorial/8-8-the-hidden-this-pointer/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;c-关键字之this&quot;&gt;&lt;a href=&quot;#c-关键字之this&quot; class=&quot;headerlink&quot; title=&quot;c++关键字之this&quot;&gt;&lt;/a&gt;c++关键字之this&lt;/h3&gt;&lt;h4 id=&quot;this指针是什么&quot;&gt;&lt;a href=&quot;#this指针是什么&quot; class=&quot;headerlink&quot; title=&quot;this指针是什么&quot;&gt;&lt;/a&gt;this指针是什么&lt;/h4&gt;&lt;p&gt;this是一个指向当前正在使用的对象的指针，它是一个指针；&lt;br&gt;成员函数通过它来使用对象的值，通过它知道要对哪个对象的成员操作&lt;br&gt;如：
    
    </summary>
    
      <category term="c&amp;cpp" scheme="http://xdksx.github.io/categories/c-cpp/"/>
    
    
      <category term="cpp_keyword" scheme="http://xdksx.github.io/tags/cpp-keyword/"/>
    
  </entry>
  
  <entry>
    <title>cpp_static</title>
    <link href="http://xdksx.github.io/2018/06/08/cpp-static/"/>
    <id>http://xdksx.github.io/2018/06/08/cpp-static/</id>
    <published>2018-06-08T14:44:43.000Z</published>
    <updated>2018-06-08T23:23:43.565Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-关键词之static"><a href="#c-关键词之static" class="headerlink" title="c++关键词之static"></a>c++关键词之static</h3><h5 id="something-share"><a href="#something-share" class="headerlink" title="something share:"></a>something share:</h5><p>其实，一开始学习c++的时候，并没有想去了解它的语法原理。虽然学c的时候，附带学了汇编，也学到了内存段，和学编译原理的时候顺带了解了它的相关词法语法处理。　　<br>现在开始从原因，历史，内存，汇编等角度去看cpp，觉得清晰了一些。虽然没有去学习g++或者其他编译器<a id="more"></a><br>如何处理c++的语法词法。这个想着以后如果有时间再研究吧。应该也是有工具去看，毕竟，g++是开源的，可以直接看源码如何处理C++</p><h4 id="static-overiew"><a href="#static-overiew" class="headerlink" title="static overiew"></a>static overiew</h4><ul><li>static在c的时候就有，因存储的地方不同于局部变量(in static mem ,not in stack)，使得在函数代码块结束后不会被销毁。从而能持续整个程序.</li><li>静态存储区(data)：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</li></ul><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><p>１、static概念和用法<br>２、static内存存储和汇编<br>３、static和类相关内容与原理  </p><h4 id="static概念："><a href="#static概念：" class="headerlink" title="static概念："></a>static概念：</h4><p>　static为静态修饰符。编译器遇到这个修饰符时将对应的变量存储在静态存储区(data)  　</p><ul><li>根据类型：static可以修饰变量和函数，修饰对象和成员函数  </li><li>根据位置：静态局部变量和全局静态变量 -存于静态数据区(data)</li></ul><h5 id="c中的static"><a href="#c中的static" class="headerlink" title="c中的static:"></a>c中的static:</h5><ul><li>修饰变量：作用域是本程序文件，局部变量默认为auto,静态变量不管局部或者全局都存储于静态数据区，使得不会因为函数调用而销毁</li><li>修饰函数：只能用于本程序文件，普通函数默认为extern ,能被其他文件引用，static则不行</li></ul><p>“ 举个例子：<br>在stat.h中声明static int getstats()函数.<br>并在stat.c中实现它，static int getstats(){return xxx;}<br>在main中或者其他文件中使用这个函数<br>编译时报错未能找到该函数（未定义该函数)<br>c++中的static当和类无关时同c” </p><h4 id="static使用和内存与汇编："><a href="#static使用和内存与汇编：" class="headerlink" title="static使用和内存与汇编："></a>static使用和内存与汇编：</h4><h5 id="static全局变量"><a href="#static全局变量" class="headerlink" title="static全局变量"></a>static全局变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> global1=<span class="number">4</span>;</span><br><span class="line">   <span class="number">12</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   13 </span>&#123;</span><br><span class="line">&gt;&gt; <span class="number">14</span>         <span class="keyword">int</span> loc1=global1;</span><br><span class="line"></span><br><span class="line">_ZL7global1:</span><br><span class="line">.<span class="keyword">long</span><span class="number">4</span></span><br><span class="line">.text</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line"></span><br><span class="line">movl_ZL7global1(%rip), %eax</span><br><span class="line">movl%eax, <span class="number">-4</span>(%rbp)</span><br><span class="line"><span class="comment">//且可以通过kdbg看到在执行期，</span></span><br><span class="line"><span class="keyword">static</span>变量的内存位置约为：</span><br><span class="line">(<span class="keyword">int</span> *) <span class="number">0x601048</span> &lt;global1&gt;　数据段地址</span><br><span class="line">局部变量的位置约为：</span><br><span class="line">(<span class="keyword">char</span> **) <span class="number">0x7ffff7a54530</span> &lt;loc1&gt;　栈地址</span><br></pre></td></tr></table></figure><h5 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   13 </span>&#123;</span><br><span class="line">   <span class="number">14</span>         <span class="keyword">static</span> <span class="keyword">int</span> locstatic1=<span class="number">5</span>;</span><br><span class="line">&gt;&gt; <span class="number">15</span>         <span class="keyword">int</span> loc1=global1;</span><br><span class="line">&gt;&gt; <span class="number">16</span>         <span class="keyword">int</span> loc2=locstatic1;</span><br><span class="line"></span><br><span class="line">movl_ZZ4mainE10locstatic1(%rip), %eax</span><br><span class="line">movl%eax, <span class="number">-4</span>(%rbp)</span><br><span class="line"></span><br><span class="line">_ZZ4mainE10locstatic1:</span><br><span class="line">.<span class="keyword">long</span><span class="number">5</span></span><br><span class="line">执行期：</span><br><span class="line">　　loca1 　(<span class="keyword">int</span> *) <span class="number">0x7fffffffd8a8</span></span><br><span class="line">　　loca2 (<span class="keyword">int</span> *) <span class="number">0x7fffffffd8ac</span></span><br><span class="line"></span><br><span class="line">  global1 (<span class="keyword">int</span> *) <span class="number">0x601048</span> &lt;global1&gt;</span><br><span class="line">  locstatic:(<span class="keyword">int</span> *) <span class="number">0x60104c</span> &lt;main::locstatic1&gt;</span><br></pre></td></tr></table></figure><h5 id="static定义的变量和函数只能在本程序文件中使用"><a href="#static定义的变量和函数只能在本程序文件中使用" class="headerlink" title="static定义的变量和函数只能在本程序文件中使用"></a>static定义的变量和函数只能在本程序文件中使用</h5><p>要知道这个的原因可能有些复杂，一时半会也说不清，得先直到函数为什么能被外部引用：存在“符号表”中，能被外部链接，静态函数不在符号表中所以不行，类似这样吧，<br>这块不太清楚，感觉是这个原因</p><h5 id="static函数："><a href="#static函数：" class="headerlink" title="static函数："></a>static函数：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">getv</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    4 </span>&#123;</span><br><span class="line">    <span class="number">5</span>         <span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="number">6</span>         a++;</span><br><span class="line">    <span class="number">7</span>         <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="number">8</span>         <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="number">9</span> &#125; </span><br><span class="line"></span><br><span class="line">.type_ZL4getvv, @function</span><br><span class="line">_ZL4getvv:</span><br><span class="line">.LFB1021:</span><br><span class="line">.cfi_startproc</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">.cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">subq$<span class="number">16</span>, %rsp</span><br><span class="line">　　　。。。。</span><br></pre></td></tr></table></figure><p>　    call    _ZL4getvv<br>从汇编代码看貌似跟普通函数没什么差别<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">运行时</span><br><span class="line">　　<span class="function"><span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">getv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="number">0x400816</span> push   %rbp</span><br><span class="line"><span class="number">0x400817</span> mov    %rsp,%rbp</span><br><span class="line"><span class="number">0x40081a</span> sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> global1=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> locstatic1=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> loc1=global1;</span><br><span class="line"><span class="keyword">int</span> loc2=locstatic1;</span><br><span class="line"><span class="comment">//cout&lt;&lt;getv()&lt;&lt;endl;</span></span><br><span class="line">    getv();</span><br><span class="line"><span class="number">0x400866</span> callq  <span class="number">0x400816</span> &lt;getv()&gt;</span><br></pre></td></tr></table></figure></p><h4 id="static和类相关"><a href="#static和类相关" class="headerlink" title="static和类相关"></a>static和类相关</h4><h5 id="static成员变量的使用"><a href="#static成员变量的使用" class="headerlink" title="static成员变量的使用"></a>static成员变量的使用</h5><p> static成员变量是类的所有对象共有的，但是只有一份，通过类也可以访问到<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value; <span class="comment">// declares the static member variable</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Something::s_value = <span class="number">1</span>; <span class="comment">// defines the static member variable (we'll discuss this section below)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// note: we're not instantiating any objects of type Something</span></span><br><span class="line"> </span><br><span class="line">    Something::s_value = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Something::s_value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_ZN9Something7s_valueE:</span><br><span class="line">.<span class="keyword">long</span><span class="number">1</span></span><br><span class="line">.text</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line"></span><br><span class="line">　　</span><br><span class="line">  Something::s_value=<span class="number">3</span>;</span><br><span class="line"><span class="number">0x40081a</span> movl   $<span class="number">0x3</span>,<span class="number">0x20083c</span>(%rip)        # <span class="number">0x601060</span> &lt;Something::s_value&gt;</span><br><span class="line">（movl_ZN9Something7s_valueE(%rip), %eax</span><br><span class="line">movl%eax, %esi</span><br><span class="line">）</span><br><span class="line">可见类似于上述的，存在内存的数据段中</span><br></pre></td></tr></table></figure><h5 id="类静态变量作用域"><a href="#类静态变量作用域" class="headerlink" title="类静态变量作用域"></a>类静态变量作用域</h5><p>静态成员在多个文件中:<br>类中的机制，可以让定义在文件中的静态成员变量能被其他文件访问；加了作用域的声明，所以可以这样用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">在stati.h</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Some</span>&#123;</span></span><br><span class="line">  <span class="number">2</span>         <span class="keyword">public</span>:</span><br><span class="line">  <span class="number">3</span>                 <span class="keyword">static</span> <span class="keyword">int</span> s_v;</span><br><span class="line">  <span class="number">4</span> &#125;;</span><br><span class="line">  <span class="number">5</span> <span class="comment">//static int s_vv;//error 错误</span></span><br><span class="line"></span><br><span class="line">在stati.cpp</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stati.h"</span></span></span><br><span class="line">  <span class="number">2</span> <span class="keyword">int</span> Some::s_v=<span class="number">4</span>;</span><br><span class="line">  <span class="number">3</span> <span class="comment">//static int s_vv=5;error</span></span><br><span class="line"></span><br><span class="line">在main</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stati.h"</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> gets= Some::s_v;</span><br><span class="line"></span><br><span class="line">other:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Whatever</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> s_value = <span class="number">4</span>; <span class="comment">// a static const int can be declared and initialized directly</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h5 id="静态成员函数的使用"><a href="#静态成员函数的使用" class="headerlink" title="静态成员函数的使用"></a>静态成员函数的使用</h5><ul><li>考虑一个问题，当静态成员被申明为private时，则无法使用它directly by class。<br>but you can用非静态成员函数操作或者用静态成员函数操作to use it  </li><li>静态成员函数也是可以用类直接调用，它没有this指针，所以不能修改和访问对象的成员； </li><li>（非静态成员func,它可以定义在类的内部或者外部，外部不用加static,这点和static成员不同，成员得在外部初始化－－因为public等定义成员时，非const不能赋值，而<br>static不能修饰构造函数（对象相关），所以只能在外部初始化)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDGenerator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_nextID; <span class="comment">// Here's the declaration for a static member</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextID</span><span class="params">()</span></span>; <span class="comment">// Here's the declaration for a static function</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Here's the definition of the static member outside the class.  Note we don't use the static keyword here.</span></span><br><span class="line"><span class="comment">// We'll start generating IDs at 1</span></span><br><span class="line"><span class="keyword">int</span> IDGenerator::s_nextID = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Here's the definition of the static function outside of the class.  Note we don't use the static keyword here.</span></span><br><span class="line"><span class="keyword">int</span> IDGenerator::getNextID() &#123; <span class="keyword">return</span> s_nextID++; &#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">0</span>; count &lt; <span class="number">5</span>; ++count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The next ID is: "</span> &lt;&lt; IDGenerator::getNextID() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;c-关键词之static&quot;&gt;&lt;a href=&quot;#c-关键词之static&quot; class=&quot;headerlink&quot; title=&quot;c++关键词之static&quot;&gt;&lt;/a&gt;c++关键词之static&lt;/h3&gt;&lt;h5 id=&quot;something-share&quot;&gt;&lt;a href=&quot;#something-share&quot; class=&quot;headerlink&quot; title=&quot;something share:&quot;&gt;&lt;/a&gt;something share:&lt;/h5&gt;&lt;p&gt;其实，一开始学习c++的时候，并没有想去了解它的语法原理。虽然学c的时候，附带学了汇编，也学到了内存段，和学编译原理的时候顺带了解了它的相关词法语法处理。　　&lt;br&gt;现在开始从原因，历史，内存，汇编等角度去看cpp，觉得清晰了一些。虽然没有去学习g++或者其他编译器
    
    </summary>
    
      <category term="c&amp;cpp" scheme="http://xdksx.github.io/categories/c-cpp/"/>
    
    
      <category term="cpp_keyword" scheme="http://xdksx.github.io/tags/cpp-keyword/"/>
    
  </entry>
  
  <entry>
    <title>cpp_const</title>
    <link href="http://xdksx.github.io/2018/06/08/cpp-const/"/>
    <id>http://xdksx.github.io/2018/06/08/cpp-const/</id>
    <published>2018-06-08T14:07:46.000Z</published>
    <updated>2018-06-08T22:42:22.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-关键词之const"><a href="#c-关键词之const" class="headerlink" title="c++关键词之const"></a>c++关键词之const</h3><h4 id="const介绍，用法，原理，注意点等"><a href="#const介绍，用法，原理，注意点等" class="headerlink" title="const介绍，用法，原理，注意点等"></a>const介绍，用法，原理，注意点等</h4><h5 id="const-介绍："><a href="#const-介绍：" class="headerlink" title="const 介绍："></a>const 介绍：</h5><p>const是用于标示不可修改的变量，对象或函数的。<br>在其前面添加const就无法在之后做修改  </p><h5 id="用法"><a href="#用法" class="headerlink" title="用法 "></a>用法 <a id="more"></a></h5><p>const总结起来有以下用法：</p><ul><li>const 修饰基本类型的变量  <ul><li>const int xx=4; const double xd=3.3;   </li><li>const int array[3]={3,4,5};</li><li>const　修饰指针和引用</li></ul></li><li>const 指针： <ul><li>const int *p=&value;<br>//无法改变指针指向的值，但是可以改变指针,<br>value可以是int value;/const int value;</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          <span class="keyword">int</span> va=<span class="number">4</span>;</span><br><span class="line">    <span class="number">6</span>         <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;va ;</span><br><span class="line">    <span class="number">7</span>         va=<span class="number">5</span>;</span><br><span class="line">&gt;&gt;  <span class="number">8</span>         *p=<span class="number">6</span>;<span class="comment">//error</span></span><br><span class="line">    <span class="number">9</span>         <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//5</span></span><br><span class="line">   <span class="number">10</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>int *const p=&value; //无法改变指针的值，但是可以改变指针指向的值</li><li>const int *const p=&value;//指针的值和指针指向的值　都不可以改变<ul><li>const 引用：</li><li>const int &amp;ref=value;</li></ul></li></ul><h5 id="const-c-amp-cpp差异"><a href="#const-c-amp-cpp差异" class="headerlink" title="const  c&amp;cpp差异"></a>const  c&amp;cpp差异</h5><ul><li>不同于CPP，c将const存入的内存中设为只读，还是在栈中，而取其值时需要从内存中获取，所以从这个点看其效率比cpp差<br>why?see follow <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    c code:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cc=<span class="number">8</span>;</span><br><span class="line"><span class="number">0x4004da</span> movl   $<span class="number">0x8</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line"><span class="keyword">int</span> ccc=cc;</span><br><span class="line"><span class="number">0x4004e1</span> mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line"><span class="number">0x4004e4</span> mov    %eax,<span class="number">-0x4</span>(%rbp)</span><br></pre></td></tr></table></figure></li></ul><h5 id="const和类"><a href="#const和类" class="headerlink" title="const和类"></a>const和类</h5><ul><li><p>const 对象 const对象不能调用非const成员函数，也不能改变成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">constobj</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span> ax;</span><br><span class="line">     <span class="keyword">int</span> bx;</span><br><span class="line">     constonj(<span class="keyword">int</span> a,<span class="keyword">int</span> b):ax(a),bx(b)&#123;&#125;;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">getax</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> ax;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">getbx</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bx;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">setax</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;ax=a;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     constobj cobj;</span><br><span class="line">     <span class="keyword">const</span> constobj ccobj;</span><br><span class="line">     ccobj.setax(<span class="number">3</span>);<span class="comment">//error</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>const 成员函数（只有成员函数能被声明为const )，它不能改变成员</p></li><li>不能在const成员函数中修改成员变量，但是可以修改其他变量。</li><li>非const对象可以调用const成员函数</li><li>一个灵活使用const成员函数的例子：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Something(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;value=<span class="string">""</span>) &#123; m_value= value; &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125; <span class="comment">// getValue() for const objects</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_value; &#125; <span class="comment">// getValue() for non-const objects</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Something something;</span><br><span class="line">something.getValue() = <span class="string">"Hi"</span>; <span class="comment">// calls non-const getValue();</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> Something something2;</span><br><span class="line">something2.getValue(); <span class="comment">// calls const getValue();</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-11中的添加的新内容"><a href="#c-11中的添加的新内容" class="headerlink" title="c++11中的添加的新内容"></a>c++11中的添加的新内容</h5><ul><li>constexp，cv限定  <h5 id="c-const内存和原理"><a href="#c-const内存和原理" class="headerlink" title="c++ const内存和原理"></a>c++ const内存和原理</h5></li><li>基本变量<br>const变量是在栈中分配内存的，但是仅限于定义的时候，之后其他地方使用这个const变量都直接是使用该值<br>从汇编中可以看到</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    const int  co1=<span class="number">3</span>;</span><br><span class="line"><span class="number">0x4008ed</span> movl   $<span class="number">0x3</span>,<span class="number">-0x14</span>(%rbp)</span><br><span class="line"> int  nor=co1;</span><br><span class="line"><span class="number">0x4008f4</span> movl   $<span class="number">0x3</span>,<span class="number">-0x10</span>(%rbp)</span><br></pre></td></tr></table></figure><p>所以无法当进行co1=4;的赋值操作时会被编译器拦截，想想，编译后会变成3=4;是不对的； </p><ul><li>这也解释了为什么一开始就要给const的变量赋值 *</li></ul><ul><li>数组:save in stack</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">3</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="number">0x4008fb</span> movl   $<span class="number">0x2</span>,<span class="number">-0x20</span>(%rbp)</span><br><span class="line"><span class="number">0x400902</span> movl   $<span class="number">0x3</span>,<span class="number">-0x1c</span>(%rbp)</span><br><span class="line"><span class="number">0x400909</span> movl   $<span class="number">0x5</span>,<span class="number">-0x18</span>(%rbp)</span><br></pre></td></tr></table></figure><ul><li>指针：<br>const指针结合，其并不像基本类型那样贴出值，而是每次还是得去内存中取值，它的限定改变值，由编译器控制报错  </li></ul><p>指针并不是像前面那样，如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;value;</span><br><span class="line">    <span class="keyword">int</span> xx=*p;<span class="comment">//被替换成值?不是的，而是去内存中先取出指针的值，再以此为地址去取值；</span></span><br><span class="line">     <span class="keyword">int</span> pv=<span class="number">4</span>;</span><br><span class="line"><span class="number">0x400a12</span> movl   $<span class="number">0x4</span>,<span class="number">-0x58</span>(%rbp)</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;pv;</span><br><span class="line"><span class="number">0x400a19</span> lea    <span class="number">-0x58</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a1d</span> mov    %rax,<span class="number">-0x40</span>(%rbp)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> px=*p;</span><br><span class="line"><span class="number">0x400a69</span> mov    <span class="number">-0x40</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a6d</span> mov    (%rax),%eax</span><br><span class="line"><span class="number">0x400a6f</span> mov    %eax,<span class="number">-0x48</span>(%rbp)</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　　   <span class="keyword">int</span> pv=<span class="number">4</span>;</span><br><span class="line"><span class="number">0x400a12</span> movl   $<span class="number">0x4</span>,<span class="number">-0x70</span>(%rbp)<span class="comment">//put 4 in mem(statck)</span></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;pv;</span><br><span class="line"><span class="number">0x400a19</span> lea    <span class="number">-0x70</span>(%rbp),%rax<span class="comment">//get its addr</span></span><br><span class="line"><span class="number">0x400a1d</span> mov    %rax,<span class="number">-0x58</span>(%rbp)<span class="comment">//addr to p</span></span><br><span class="line">         <span class="keyword">int</span> *<span class="keyword">const</span> pp=&amp;pv; </span><br><span class="line"><span class="number">0x400a21</span> lea    <span class="number">-0x70</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x400a25</span> mov    %rax,<span class="number">-0x50</span>(%rbp)<span class="comment">//adddr to pp</span></span><br><span class="line">         <span class="keyword">int</span>  *ppp=pp;</span><br><span class="line"><span class="number">0x400a29</span> mov    <span class="number">-0x50</span>(%rbp),%rax<span class="comment">//get pp num</span></span><br><span class="line"><span class="number">0x400a2d</span> mov    %rax,<span class="number">-0x48</span>(%rbp)<span class="comment">//to ppp</span></span><br></pre></td></tr></table></figure><ul><li><p>引用：<br>引用同指针，是会去内存中取值的,same to pointer</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">follow above</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref=pv;</span><br><span class="line"><span class="number">0x400aba</span> lea    <span class="number">-0x7c</span>(%rbp),%rax<span class="comment">//get pv</span></span><br><span class="line"><span class="number">0x400abe</span> mov    %rax,<span class="number">-0x38</span>(%rbp)<span class="comment">//to ref</span></span><br><span class="line"> <span class="keyword">int</span> cs=ref;</span><br><span class="line"><span class="number">0x400ac2</span> mov    <span class="number">-0x38</span>(%rbp),%rax<span class="comment">//get ref</span></span><br><span class="line"><span class="number">0x400ac6</span> mov    (%rax),%eax<span class="comment">//get *ref</span></span><br><span class="line"><span class="number">0x400ac8</span> mov    %eax,<span class="number">-0x64</span>(%rbp)<span class="comment">//to cs</span></span><br></pre></td></tr></table></figure></li><li><p>const类对象：  </p><ul><li>const对象为什么不能更改成员：<br>成员是存在对象中的，如int,char等成员，存在栈中<br>const对象的成员也是放在栈中的，它们之所以不能赋值，是在编译期间确定，更具体的细节未知；  　</li></ul></li><li>const对象为什么不能调用非const成员函数：<ul><li>一个成员函数如何被调用：   　　</li><li>其实成员函数也是全局函数，所以它能被调用，<br>　eg:    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  obj.show();---&gt;实际上被转换为：</span><br><span class="line">  show(&amp;obj)  --传递给<span class="keyword">this</span>指针：</span><br><span class="line"> 所以当：<span class="function"><span class="keyword">const</span> OB <span class="title">obj</span><span class="params">()</span></span>;</span><br><span class="line">obj.show();时，翻译为　<span class="keyword">const</span> OB *<span class="keyword">this</span>;</span><br><span class="line">在传递给OB *<span class="keyword">this</span>时会出现不能将<span class="keyword">this</span>指针</span><br><span class="line">从<span class="keyword">const</span> OB转换为OB &amp;的错误</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>可以做个实验试试</p><ul><li><p>conclude:<br>if it can use non const func ,it will change member by non const this pointer;</p></li><li><p>为什么可以调用const函数：<br>const函数：void show() const转换为：show(const OB *this);所以匹配上了，就可以调用了</p></li></ul><p>注意：有最小权限原则，非const对象可以调用const成员函数，就像可以赋值一样。非const变量可以用const赋值</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;c-关键词之const&quot;&gt;&lt;a href=&quot;#c-关键词之const&quot; class=&quot;headerlink&quot; title=&quot;c++关键词之const&quot;&gt;&lt;/a&gt;c++关键词之const&lt;/h3&gt;&lt;h4 id=&quot;const介绍，用法，原理，注意点等&quot;&gt;&lt;a href=&quot;#const介绍，用法，原理，注意点等&quot; class=&quot;headerlink&quot; title=&quot;const介绍，用法，原理，注意点等&quot;&gt;&lt;/a&gt;const介绍，用法，原理，注意点等&lt;/h4&gt;&lt;h5 id=&quot;const-介绍：&quot;&gt;&lt;a href=&quot;#const-介绍：&quot; class=&quot;headerlink&quot; title=&quot;const 介绍：&quot;&gt;&lt;/a&gt;const 介绍：&lt;/h5&gt;&lt;p&gt;const是用于标示不可修改的变量，对象或函数的。&lt;br&gt;在其前面添加const就无法在之后做修改  &lt;/p&gt;
&lt;h5 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法 &quot;&gt;&lt;/a&gt;用法
    
    </summary>
    
      <category term="c&amp;cpp" scheme="http://xdksx.github.io/categories/c-cpp/"/>
    
    
      <category term="cpp_keyword" scheme="http://xdksx.github.io/tags/cpp-keyword/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_linklist3</title>
    <link href="http://xdksx.github.io/2018/06/07/leetcode-linklist3/"/>
    <id>http://xdksx.github.io/2018/06/07/leetcode-linklist3/</id>
    <published>2018-06-07T15:33:03.000Z</published>
    <updated>2018-06-07T23:35:26.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode-linklist3"><a href="#leetcode-linklist3" class="headerlink" title="leetcode_linklist3"></a>leetcode_linklist3</h3><p>continue..</p><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.<br><a id="more"></a><br>Example 1:</p><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p><p>Example 2:</p><p>Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>Output: 2-&gt;0-&gt;1-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL<br>rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL<br>rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>/**</p><ul><li>Definition for singly-linked list.</li><li>struct ListNode {</li><li>int val;</li><li>struct ListNode *next;</li><li>};<br>*/</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">rotateRight</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">headnode</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    headnode-&gt;next=head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">sumhead</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">//compute len of list</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sumhead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        sumhead=sumhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    sum++;</span><br><span class="line">    <span class="comment">//compare k and len,or just compute the rota num</span></span><br><span class="line">    <span class="keyword">int</span> num=k%sum;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dealheadf</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;sum-num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dealheadf=dealheadf-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sumhead-&gt;next=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=dealheadf-&gt;next;</span><br><span class="line">    dealheadf-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">    head=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headnode);</span><br><span class="line">    <span class="keyword">return</span>  head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除倒数第n个元素"><a href="#移除倒数第n个元素" class="headerlink" title="移除倒数第n个元素"></a>移除倒数第n个元素</h4><p>Given a linked list, remove the n-th node from the end of list and return its head.</p><p>Example:</p><p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p><p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p><p>Note:</p><p>Given n will always be valid.</p><p>Follow up:</p><p>Could you do this in one pass?</p><p>/**</p><ul><li>Definition for singly-linked list.</li><li>struct ListNode {</li><li>int val;</li><li>struct ListNode *next;</li><li>};<br>*/</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="comment">//这个几乎没道题都要注意</span></span><br><span class="line">         <span class="keyword">return</span> head;</span><br><span class="line">     <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>&amp;&amp;n&gt;=<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">sumhead</span>=<span class="title">head</span>;</span></span><br><span class="line">     <span class="keyword">while</span>(sumhead!=<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         sum++;</span><br><span class="line">         sumhead=sumhead-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> remove=sum-n;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">removenode</span>=<span class="title">head</span>;</span></span><br><span class="line">     <span class="keyword">while</span>(remove&gt;<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         removenode=removenode-&gt;next;</span><br><span class="line">         remove--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">rmnode</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(remove==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">rmnode</span>;</span></span><br><span class="line">     rmnode=removenode-&gt;next;</span><br><span class="line">     removenode-&gt;next=removenode-&gt;next-&gt;next;</span><br><span class="line">     rmnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">     <span class="built_in">free</span>(rmnode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//删除头</span></span><br><span class="line">    &#123;</span><br><span class="line">        rmnode=removenode;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">        rmnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(rmnode);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//一开始未考虑到删除头的情况，所以加了else 部分</p><h4 id="交换元素"><a href="#交换元素" class="headerlink" title="交换元素"></a>交换元素</h4><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>Example:</p><p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p><p>Note:</p><pre><code>Your algorithm should use only constant extra space.You may not modify the values in the list&apos;s nodes, only nodes itself may be changed.</code></pre><p>/**</p><ul><li>Definition for singly-linked list.</li><li>struct ListNode {</li><li>int val;</li><li>struct ListNode *next;</li><li>};<br>*/</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">swapPairs</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">headNode</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">second</span>=<span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">first</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">curhead</span>=<span class="title">headNode</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="literal">NULL</span>)<span class="keyword">break</span>;</span><br><span class="line">        second=first-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(second!=<span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          first-&gt;next=second-&gt;next==<span class="literal">NULL</span>?<span class="literal">NULL</span>:second-&gt;next;</span><br><span class="line">          second-&gt;next=first;</span><br><span class="line">          curhead-&gt;next=second;</span><br><span class="line">          curhead=first;</span><br><span class="line">          first=first-&gt;next==<span class="literal">NULL</span>?<span class="literal">NULL</span>:first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head=headNode-&gt;next;</span><br><span class="line">    headNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headNode);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="k组反转"><a href="#k组反转" class="headerlink" title="k组反转"></a>k组反转</h4><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>Example:</p><p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>Note:</p><pre><code>Only constant extra memory is allowed.You may not alter the values in the list&apos;s nodes, only nodes itself may be changed.</code></pre><p>/**</p><ul><li>Definition for singly-linked list.</li><li>struct ListNode {</li><li>int val;</li><li>struct ListNode *next;</li><li>};<br><em>/<br>/</em><br>这道题目原想在遍历一次就解决，可是还是想不出好的方法，得遍历两次，一次计算长度，一次正真的处理；<br>在处理的过程使用头插法。注意边界条件，但因为有数量控制好些*/<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseKGroup</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">headnode</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    headnode-&gt;next=head;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">lenhead</span>=<span class="title">head</span>,*<span class="title">curhead</span>=<span class="title">headnode</span>,*<span class="title">cur</span>=<span class="title">head</span>,*<span class="title">tmp</span>=<span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(lenhead!=<span class="literal">NULL</span>)<span class="comment">//计算长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        lenhead=lenhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numofreverse=len/k;<span class="comment">//要reverse几次</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=numofreverse;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j=k;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">1</span>)<span class="comment">//每一次reverse k次，头插法</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp=curhead-&gt;next;</span><br><span class="line">            curhead-&gt;next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            curhead-&gt;next-&gt;next=tmp;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        curhead=cur;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    head=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headnode);</span><br><span class="line">    <span class="keyword">return</span> head;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>后面还有几道题，不贴了，这里简述下：  </p><ul><li>检查是否链表中存在循环</li><li>检查链表中是否存在循环并找到循环的起点</li><li>深度复制链表，链表中的每个节点存在一个指向任意节点的指针</li><li>设计一个LRU cache,即（最近使用的）</li><li><p>。。。。。</p></li><li><p>链表的套路：</p><ul><li>常使用头插法进行反转操作</li><li>使用两个指针解决循环问题，指针相遇测试是否存在循环，指针遍历减少时间</li><li>使用哈希，以空间换时间</li><li>加头节点，简化逻辑</li></ul></li><li>使用链表注意<ul><li>检查空和是否只有一个节点</li><li>释放空间，和放置取空指针，可以通过次数控制和判空</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;leetcode-linklist3&quot;&gt;&lt;a href=&quot;#leetcode-linklist3&quot; class=&quot;headerlink&quot; title=&quot;leetcode_linklist3&quot;&gt;&lt;/a&gt;leetcode_linklist3&lt;/h3&gt;&lt;p&gt;continue..&lt;/p&gt;
&lt;h4 id=&quot;反转链表&quot;&gt;&lt;a href=&quot;#反转链表&quot; class=&quot;headerlink&quot; title=&quot;反转链表&quot;&gt;&lt;/a&gt;反转链表&lt;/h4&gt;&lt;p&gt;Given a linked list, rotate the list to the right by k places, where k is non-negative.&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://xdksx.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode_linklist" scheme="http://xdksx.github.io/tags/leetcode-linklist/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_linklist2</title>
    <link href="http://xdksx.github.io/2018/06/03/leetcode-linklist2/"/>
    <id>http://xdksx.github.io/2018/06/03/leetcode-linklist2/</id>
    <published>2018-06-03T13:40:41.000Z</published>
    <updated>2018-06-03T21:57:49.826Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode——单链表2"><a href="#leetcode——单链表2" class="headerlink" title="leetcode——单链表2"></a>leetcode——单链表2</h3><h4 id="partition-list"><a href="#partition-list" class="headerlink" title="partition list"></a>partition list</h4><p>这个是快速排序中一个很重要的步骤，即比该数大于等于的放其前小的放后。在链表中，基本思路:扫描链表，比给定数字小的不处理，比给定数字大的取下并插入到末尾 <a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">You should preserve the original relative order of the nodes in each of the two partitions.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">partition</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next ==<span class="literal">NULL</span>)</span><br><span class="line">              <span class="keyword">return</span> head;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span>  <span class="title">ListNode</span>));</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;next=head;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">head1</span>=<span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">cur</span> = <span class="title">head1</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">tail</span>=<span class="title">head1</span>;</span></span><br><span class="line"><span class="keyword">int</span> lenoflist1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(tail-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tail=tail-&gt;next;</span><br><span class="line">lenoflist1++;</span><br><span class="line">&#125;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tmp</span>=<span class="title">tail</span>;</span></span><br><span class="line"><span class="keyword">while</span>(lenoflist1&gt;=<span class="number">1</span>)</span><br><span class="line">&#123; </span><br><span class="line">            lenoflist1--;</span><br><span class="line">            <span class="keyword">if</span>(tail==cur)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span>(cur-&gt;val&gt;=x)</span><br><span class="line">  &#123;</span><br><span class="line">  head1-&gt;next=cur-&gt;next;</span><br><span class="line">  cur-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">          tail-&gt;next=cur;</span><br><span class="line">  tail=tail-&gt;next;<span class="comment">//not consid at first</span></span><br><span class="line">  cur=head1-&gt;next;</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">  head1=head1-&gt;next;</span><br><span class="line">  cur=cur-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//  printf("%d : ",cur-&gt;num);</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//if(head1-&gt;next==NULL)head1-&gt;next=tmp;</span></span><br><span class="line">         head=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">   <span class="built_in">list</span>-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//此题目最终被accepted<br>//应该在函数中添加头节点而不是依靠传入的链表带头节点,一开始没有考虑到传入的链表不带链表头。。，没有考虑到一个元素的情况，这个方案最终accept</p><h4 id="链表中的子链表反转，考察头插法"><a href="#链表中的子链表反转，考察头插法" class="headerlink" title="链表中的子链表反转，考察头插法"></a>链表中的子链表反转，考察头插法</h4><ul><li>头插法在链表的反转，倒序，常被用到  </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reverse a linklist from m to n</span></span><br><span class="line"><span class="comment"> * 1-&gt;2-&gt;4-&gt;5-&gt;null and m,n(ex:2,4)</span></span><br><span class="line"><span class="comment"> * return 1-&gt;5-&gt;4-&gt;2-&gt;null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span>  *<span class="title">next</span>;</span></span><br><span class="line">&#125;Linklist;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverselinklist</span><span class="params">(Linklist *list1,<span class="keyword">int</span> m,<span class="keyword">int</span> n,Linklist **result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(list1==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">Linklist *head1,*head2,*cur,*tmp,*pre;</span><br><span class="line">cur=list1;</span><br><span class="line">head1=cur;</span><br><span class="line">pre=head1;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur=cur-&gt;next;</span><br><span class="line"><span class="keyword">for</span>(i=m;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">  pre-&gt;next=cur-&gt;next;</span><br><span class="line">  cur-&gt;next=head1;</span><br><span class="line">  head1=cur;</span><br><span class="line">  cur=pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    *result=head1;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)<span class="comment">//node1-&gt;node2-&gt;node3---1-&gt;2-&gt;3--ex:m=2,list1-&gt;1</span></span><br><span class="line">&#123;</span><br><span class="line">  head1=cur;</span><br><span class="line">          cur=cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">head2=cur;</span><br><span class="line">cur=cur-&gt;next;</span><br><span class="line">pre=head2;</span><br><span class="line"><span class="keyword">for</span>(i=m;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">   pre-&gt;next=cur-&gt;next;</span><br><span class="line">   cur-&gt;next=head1-&gt;next;</span><br><span class="line">   head1-&gt;next=cur;</span><br><span class="line">   cur=pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Linklist *list1=(Linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">Linklist *result11=list1;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">list1-&gt;num=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"4 "</span>);</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">9</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">     </span><br><span class="line">list1-&gt;next = (Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">list1 = list1-&gt;next;</span><br><span class="line">    list1-&gt;num = i*<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,i*<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   Linklist *rr=(Linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linklist));</span><br><span class="line">   Linklist **resull=&amp;rr;</span><br><span class="line">   <span class="keyword">int</span> rere=reverselinklist(result11,<span class="number">1</span>,<span class="number">9</span>,resull);</span><br><span class="line">   <span class="keyword">if</span>(rere==<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;result11!=<span class="literal">NULL</span> ;i++,result11=result11-&gt;next)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d "</span>,result11-&gt;num); </span><br><span class="line">  <span class="built_in">free</span>(list1);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;*resull!=<span class="literal">NULL</span> ;i++,*resull= (*resull)-&gt;next)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d "</span>,(*resull)-&gt;num); </span><br><span class="line">  <span class="built_in">free</span>(*resull);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//此解法未经过leetcode检验，不过应该问题不大</p><h4 id="有序链表移除重复元素"><a href="#有序链表移除重复元素" class="headerlink" title="有序链表移除重复元素"></a>有序链表移除重复元素</h4><ul><li>考察的是遍历链表删除链表中的元素，注意边缘条件控制如头部和尾部</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Given a sorted linked list, delete all duplicates such that each element appear only once.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1-&gt;1-&gt;2</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">first</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">second</span>=<span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span>=<span class="title">second</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(second!=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        tmp=second;</span><br><span class="line">        <span class="keyword">if</span>(first-&gt;val==second-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            first-&gt;next=second;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(first-&gt;val==tmp-&gt;val)</span><br><span class="line">        first-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//此方案最后被accepted</p><h4 id="删除有序链表中的有重复的node"><a href="#删除有序链表中的有重复的node" class="headerlink" title="删除有序链表中的有重复的node"></a>删除有序链表中的有重复的node</h4><ul><li>和上一道题目类似:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Given a sorted linked list, delete all duplicates such that each element appear only once.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1-&gt;1-&gt;2</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span></span><br><span class="line"><span class="comment">Output: 1-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">headnode</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    headnode-&gt;next=head;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">first</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>  *<span class="title">second</span>=<span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> numsame=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmphead</span>=<span class="title">headnode</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(second!=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(first-&gt;val==second-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">               numsame++;</span><br><span class="line">               first=first-&gt;next;</span><br><span class="line">               second=second-&gt;next;</span><br><span class="line">               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(first-&gt;val !=second-&gt;val &amp;&amp; numsame==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmphead-&gt;next=first;</span><br><span class="line">            tmphead=tmphead-&gt;next;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">            numsame=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numsame==<span class="number">0</span>)tmphead-&gt;next=first;</span><br><span class="line">    <span class="keyword">else</span> tmphead-&gt;next =<span class="literal">NULL</span>;</span><br><span class="line">    head=headnode-&gt;next;</span><br><span class="line">    headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(headnode);   </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list1</span>=(<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span>=<span class="title">list1</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">freelist1</span>=<span class="title">list1</span>;</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line"> list1-&gt;val=<span class="number">20</span>-i;</span><br><span class="line"> list1-&gt;next=(struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line"> list1=list1-&gt;next;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="number">20</span>-i);</span><br><span class="line">   &#125;</span><br><span class="line">   list1-&gt;val=<span class="number">12</span>;</span><br><span class="line">   tmp=deleteDuplicates(tmp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;tmp!=<span class="literal">NULL</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d  "</span>,tmp-&gt;val);</span><br><span class="line">   tmp=tmp-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">free</span>(freelist1);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这道题做的比较顺利，一次提交就=通过了</span><br><span class="line">注意：加头节点，由于解题的思路是两个指针的遍历，在第二个指针为空时停止，就会有尾巴为几种情况时的处理：如当尾巴为：<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span> 这两种情况时，去掉尾巴，否则<span class="number">4</span>,<span class="number">5</span>,<span class="number">6.4</span>,<span class="number">4</span>,<span class="number">5</span>时尾巴保留；见代码</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;leetcode——单链表2&quot;&gt;&lt;a href=&quot;#leetcode——单链表2&quot; class=&quot;headerlink&quot; title=&quot;leetcode——单链表2&quot;&gt;&lt;/a&gt;leetcode——单链表2&lt;/h3&gt;&lt;h4 id=&quot;partition-list&quot;&gt;&lt;a href=&quot;#partition-list&quot; class=&quot;headerlink&quot; title=&quot;partition list&quot;&gt;&lt;/a&gt;partition list&lt;/h4&gt;&lt;p&gt;这个是快速排序中一个很重要的步骤，即比该数大于等于的放其前小的放后。在链表中，基本思路:扫描链表，比给定数字小的不处理，比给定数字大的取下并插入到末尾
    
    </summary>
    
      <category term="leetcode" scheme="http://xdksx.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode_linklist" scheme="http://xdksx.github.io/tags/leetcode-linklist/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_linklist1</title>
    <link href="http://xdksx.github.io/2018/06/03/leetcode-linklist1/"/>
    <id>http://xdksx.github.io/2018/06/03/leetcode-linklist1/</id>
    <published>2018-06-03T13:37:57.000Z</published>
    <updated>2018-06-03T21:40:08.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode——单链表"><a href="#leetcode——单链表" class="headerlink" title="leetcode——单链表"></a>leetcode——单链表</h3><h4 id="两数相加："><a href="#两数相加：" class="headerlink" title="两数相加："></a>两数相加：</h4><ul><li>这道题是经一年多没刷题目之后，重新开始的第一道题，本来想着只是本地刷刷，后面开始就到leetcode提交了，毕竟写的程序还是得经过检验</li><li>所以这道题就纯粹的解答，未经检验，只是本地跑通，并且加上了自己的一些看法，比如对该题目该思路可能可以应用在哪些地方，这样算法才有了真正的意义，个人十分不赞同一些在公司呆久了的人说数据结构算法没什么用的人2333</li><li>废话不多说：  好久没写，第一道就别吐槽了，慢慢来</li><li>题目描述：  <a id="more"></a><br>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>Example<br>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.<br>注意两个数字位数可能不同，所以需要一些特殊情况要处理<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125; *linklist,listnode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是自己加的扩展，把输入的两个大数字符串转换为链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">changtolist</span><span class="params">(struct ListNode *list1,<span class="keyword">char</span> num1[],struct ListNode *list2,<span class="keyword">char</span>  num2[])</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//应该在接口内计算长度好些</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> lennum1=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(num1[lennum1]!=<span class="string">'\0'</span>)&#123;lennum1++;&#125;</span><br><span class="line">   <span class="keyword">int</span> lennum2=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(num2[lennum2]!=<span class="string">'\0'</span>)&#123;lennum2++;&#125;</span><br><span class="line"><span class="comment">//分配空间加字母转数字，无头节点</span></span><br><span class="line">   list1-&gt;num=num1[lennum1<span class="number">-1</span>]<span class="number">-48</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=lennum1<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">   &#123;</span><br><span class="line">list1-&gt;next=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">list1=list1-&gt;next;</span><br><span class="line">        list1-&gt;num=num1[i]<span class="number">-48</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   list1-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   list2-&gt;num=num2[lennum2<span class="number">-1</span>]<span class="number">-48</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=lennum2<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">   &#123;</span><br><span class="line">list2-&gt;next=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">list2=list2-&gt;next;</span><br><span class="line">list2-&gt;num=num2[i]<span class="number">-48</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   list2-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个大数相加，不用头节点的方式，麻烦一些</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add_two_num</span><span class="params">(struct ListNode *list1,struct ListNode *list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> adding = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(list1 == <span class="literal">NULL</span> || list2 == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/* while(list1!=NULL &amp;&amp; list2!=NULL)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment"> list1-&gt;num = (list1-&gt;num+list2-&gt;num+adding)%10;</span></span><br><span class="line"><span class="comment">             adding = (list1-&gt;num + list2-&gt;num+adding)/10;</span></span><br><span class="line"><span class="comment"> list1 = list1-&gt;next;</span></span><br><span class="line"><span class="comment"> list2 = list2-&gt;next;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> if(list1==NULL &amp;&amp; list2!=NULL)</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">xx</span>=<span class="title">list1</span>;</span></span><br><span class="line">      <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  sum = list1-&gt;num+list2-&gt;num+adding;</span><br><span class="line">  list1-&gt;num = sum%<span class="number">10</span>;</span><br><span class="line">      adding = sum/<span class="number">10</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;<span class="comment">//常规情况，两个同长度部分</span></span><br><span class="line"> list1 = list1-&gt;next;</span><br><span class="line"> list2 = list2-&gt;next;</span><br><span class="line"> sum= list1-&gt;num+list2-&gt;num+adding;</span><br><span class="line"> list1-&gt;num = sum %<span class="number">10</span>;</span><br><span class="line"><span class="comment">// printf("%d ",list1-&gt;num);</span></span><br><span class="line">             adding = sum/<span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(list1-&gt;next!=<span class="literal">NULL</span> &amp;&amp; list2-&gt;next!=<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(list1-&gt;next ==<span class="literal">NULL</span>&amp;&amp; list2-&gt;next==<span class="literal">NULL</span> &amp;&amp;adding!=<span class="number">0</span>)<span class="comment">//串1短于串2</span></span><br><span class="line">&#123;</span><br><span class="line">list1-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">list1-&gt;next-&gt;num= adding;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"show:%d\n"</span>,adding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(list1-&gt;next==<span class="literal">NULL</span> &amp;&amp; list2-&gt;next !=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">list1-&gt;next = list2-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(list2-&gt;next!=<span class="literal">NULL</span>&amp;&amp;adding !=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">              list2=list2-&gt;next;</span><br><span class="line">  sum= list2-&gt;num+adding;</span><br><span class="line">              list2-&gt;num=sum%<span class="number">10</span>;</span><br><span class="line">  adding = sum/<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(adding&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">list2-&gt;next=(struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">            list2-&gt;next-&gt;num=adding;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line">    ...<span class="comment">//串1长于 串2</span></span><br><span class="line">    .....</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要思考，当进位到最后时，可能1,2都结束了，但是产生高位，此时要new　listnode 完成</span></span><br><span class="line"><span class="comment">//或者剩下２，和进位，则考虑２加进位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list1</span>,*<span class="title">list2</span>;</span></span><br><span class="line">  list1 = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">  list2 = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">  list1-&gt;num=<span class="number">3</span>;</span><br><span class="line">  list2-&gt;num=<span class="number">5</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmplist1</span>=<span class="title">list1</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmplist2</span>=<span class="title">list2</span>;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">9</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">list1-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">list2-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">list1 = list1-&gt;next;</span><br><span class="line">list2 = list2-&gt;next;</span><br><span class="line">    list1-&gt;num = <span class="number">2</span>;</span><br><span class="line">list2-&gt;num= <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  list2-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">  list2-&gt;next-&gt;num=<span class="number">9</span>; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">result</span>=<span class="title">tmplist1</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">freelist1</span> = <span class="title">tmplist1</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">freelist2</span> = <span class="title">tmplist2</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++,tmplist1=tmplist1-&gt;next)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d "</span>,tmplist1-&gt;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++,tmplist2=tmplist2-&gt;next)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d "</span>,tmplist2-&gt;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  Add_two_num(freelist1,freelist2);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;result!=<span class="literal">NULL</span> ;i++,result=result-&gt;next)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d "</span>,result-&gt;num); </span><br><span class="line">  <span class="built_in">free</span>(freelist1);</span><br><span class="line">  <span class="built_in">free</span>(freelist2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">list11</span>,*<span class="title">list22</span>;</span></span><br><span class="line">  list11 = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">  list22 = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> num1[<span class="number">100</span>],num2[<span class="number">100</span>];</span><br><span class="line">  gets(num1);</span><br><span class="line">  gets(num2);</span><br><span class="line">  changtolist(list11,num1,list22,num2);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">result11</span> = <span class="title">list11</span>;</span></span><br><span class="line">  Add_two_num(list11,list22);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;result11!=<span class="literal">NULL</span> ;i++,result11=result11-&gt;next)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d "</span>,result11-&gt;num); </span><br><span class="line">  <span class="built_in">free</span>(list11);</span><br><span class="line">  <span class="built_in">free</span>(list22);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//思考，扩大这道题的应用，在大数相加的时候，增加用户输入接口:”<br>//5263565656554+5656537677834546<br>//由char读入，int/char相加，<br>——-极其丑的程序，以后不能这么搞，留个纪念<br>想贴下两年多前（大三吧，那会刷这道题通过的程序–看来最喜欢的还是c）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line"> ListNode *sum, *l4;</span><br><span class="line"> sum = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//新节点</span></span><br><span class="line"> l4 = sum;</span><br><span class="line"> <span class="keyword">int</span> sum_single, en = <span class="number">0</span>;<span class="comment">//en表示进位的标志</span></span><br><span class="line"> <span class="keyword">while</span> (l1 != <span class="literal">NULL</span>&amp;&amp;l2 != <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line"> sum-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//这里有个问题变为sum=NULL就行</span></span><br><span class="line"> sum = sum-&gt;next;</span><br><span class="line"><span class="comment">// signal = 0;</span></span><br><span class="line"> sum_single = l1-&gt;val + l2-&gt;val + en;</span><br><span class="line"> <span class="keyword">if</span> (sum_single&lt;<span class="number">10</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> sum-&gt;val = sum_single;</span><br><span class="line"> en = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (sum_single &gt;= <span class="number">10</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> sum-&gt;val = sum_single - <span class="number">10</span>;</span><br><span class="line"> en = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> l1 = l1-&gt;next;</span><br><span class="line"> l2 = l2-&gt;next;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (l1 != <span class="literal">NULL</span>&amp;&amp;l2 == <span class="literal">NULL</span>)</span><br><span class="line"> &#123; </span><br><span class="line"> sum-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"> sum = sum-&gt;next;</span><br><span class="line"> sum_single = en + l1-&gt;val;</span><br><span class="line"> <span class="keyword">if</span> (sum_single &gt;= <span class="number">10</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> sum-&gt;val = sum_single - <span class="number">10</span>;</span><br><span class="line"> en = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> sum-&gt;val = sum_single;</span><br><span class="line"> en = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> l1 = l1-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (l2 != <span class="literal">NULL</span>&amp;&amp;l1 == <span class="literal">NULL</span>)</span><br><span class="line"> &#123; </span><br><span class="line"> sum-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"> sum = sum-&gt;next;</span><br><span class="line"> sum_single = en + l2-&gt;val;</span><br><span class="line"> <span class="keyword">if</span> (sum_single &gt;= <span class="number">10</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> sum-&gt;val = sum_single - <span class="number">10</span>;</span><br><span class="line"> en = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> sum-&gt;val = sum_single;</span><br><span class="line"> en = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> l2 = l2-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>&amp;&amp;l2 == <span class="literal">NULL</span>&amp;&amp;en == <span class="number">1</span>)</span><br><span class="line"> sum-&gt;next = <span class="keyword">new</span> ListNode(en);</span><br><span class="line"><span class="comment">//if(l1==NULL&amp;&amp;l2==NULL&amp;&amp;en==0)sum = NULL;</span></span><br><span class="line"><span class="comment">/* while (l3)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment"> cout &lt;&lt; l3-&gt;val;</span></span><br><span class="line"><span class="comment"> l3 = l3-&gt;next;</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line"> <span class="keyword">return</span> l4-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Solution sou;</span></span><br><span class="line"><span class="comment">    ListNode *l1,*l2,*l3;</span></span><br><span class="line"><span class="comment">    l1=new ListNode(3);</span></span><br><span class="line"><span class="comment">    l1-&gt;next=new ListNode(7);</span></span><br><span class="line"><span class="comment">    l1-&gt;next-&gt;next=new ListNode(5);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     l2=new ListNode(7);</span></span><br><span class="line"><span class="comment">    l2-&gt;next=new ListNode(7);</span></span><br><span class="line"><span class="comment">    l2-&gt;next-&gt;next=new ListNode(5);</span></span><br><span class="line"><span class="comment">    l3=sou.addTwoNumbers(l1,l2);</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;l3-&gt;val&lt;&lt;l3-&gt;next-&gt;val&lt;&lt;l3-&gt;next-&gt;next-&gt;val;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;leetcode——单链表&quot;&gt;&lt;a href=&quot;#leetcode——单链表&quot; class=&quot;headerlink&quot; title=&quot;leetcode——单链表&quot;&gt;&lt;/a&gt;leetcode——单链表&lt;/h3&gt;&lt;h4 id=&quot;两数相加：&quot;&gt;&lt;a href=&quot;#两数相加：&quot; class=&quot;headerlink&quot; title=&quot;两数相加：&quot;&gt;&lt;/a&gt;两数相加：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;这道题是经一年多没刷题目之后，重新开始的第一道题，本来想着只是本地刷刷，后面开始就到leetcode提交了，毕竟写的程序还是得经过检验&lt;/li&gt;
&lt;li&gt;所以这道题就纯粹的解答，未经检验，只是本地跑通，并且加上了自己的一些看法，比如对该题目该思路可能可以应用在哪些地方，这样算法才有了真正的意义，个人十分不赞同一些在公司呆久了的人说数据结构算法没什么用的人2333&lt;/li&gt;
&lt;li&gt;废话不多说：  好久没写，第一道就别吐槽了，慢慢来&lt;/li&gt;
&lt;li&gt;题目描述：
    
    </summary>
    
      <category term="leetcode" scheme="http://xdksx.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode_linklist" scheme="http://xdksx.github.io/tags/leetcode-linklist/"/>
    
  </entry>
  
  <entry>
    <title>tcpip_IP</title>
    <link href="http://xdksx.github.io/2018/06/03/tcpip-IP/"/>
    <id>http://xdksx.github.io/2018/06/03/tcpip-IP/</id>
    <published>2018-06-03T11:31:27.000Z</published>
    <updated>2018-06-03T19:32:38.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IP-协议和路由"><a href="#IP-协议和路由" class="headerlink" title="IP 协议和路由"></a>IP 协议和路由</h3><h4 id="IP的作用–路由"><a href="#IP的作用–路由" class="headerlink" title="IP的作用–路由"></a>IP的作用–路由</h4><h5 id="路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作"><a href="#路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作" class="headerlink" title="路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?"></a>路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?</h5><ol><li><p>从广义上讲，路由是路线图，就像百度地图上源地址到目的地址的路线，路线有很多，故路由也很多；  <a id="more"></a><br>从网络层面讲，路由是一个数据包从源地址到目的地的传输路径，它如何被决定怎么走，即中间经过哪些路由器，选择哪一条路线等等。</p></li><li><p>一个数据包在网络上传输实例：<br>A,B连上AP进行上网，AP和外网连接，AP的下一站是D;<br>A 在构造了数据包后选择发送，要查询路由表，若该数据包发送给B,则通过路由表中的直连路由，找到B的ip,发送时不知道B的mac地址，故先做arp,得到后将数据包发给B:<br>数据包：源ip：A,源mac A ，目的IP:B,目的mac:B<br>若A在构造了数据包后，查询路由，该数据包是发送给外网，目的地址是百度ip,则无此条目，向默认路由；即发给路由器，此时若不知道mac地址会做arp;<br>数据包：源ip:A,源mac：A  ,目的ip:百度，目的mac：路由器(arp代理）<br>数据包到路由器后，将做下一步转发：<br>在路由发送的数据包：源ip:路由外网地址，源mac:路由，目的ip:百度ip.目的mac,D<br>(注意，在源ip改为路由外网地址后，此时ip唯一，源地址在传输过程中不会再改变）  </p></li><li><p>内网的路由器会将源地址改为路由器的外网地址<br>—想想像192.168.0.4这样的源地址是内网地址，如果在包的传输过程中不做处理，到达目的地如QQ的服务器，那QQ处理完要发给你，这时得到包是从192.168.0.4来的，它作为内网地址，全世界很多个，怎么决定—–所以ip首部中的源地址和目的地址必须是全球唯一的ip地址，即外网地址；</p></li><li>路由器会对ttl做减1,然后再重新做校验和–即直接加1</li><li>路由器会将数据包的mac首部，源地址改为路由的mac地址，目的地址改为默认路由（或其他导向路由）ip对应的mac地址</li></ol><h4 id="网络地址和子网"><a href="#网络地址和子网" class="headerlink" title="网络地址和子网"></a>网络地址和子网</h4><p>这里不记录太多的ip地址相关的内容，毕竟比较基础，且协议卷或者网上很多介绍</p><h5 id="网络地址简介"><a href="#网络地址简介" class="headerlink" title="网络地址简介"></a>网络地址简介</h5><p>网络地址用来在网络上代表一台设备，就像家庭地址一样，当然现在的设备，如手机可以同时拥有几个ip地址（数据网，wifi，等等，可以理解为家有多个门）<br>而现在的网络地址从32位点分十进制地址，  </p><ul><li>决定了它的数量–&gt;一个网络中的设备数量决定了它如何划分网络   </li><li>网络中的设备数量动态性，可能很少，ip地址不够用–&gt;子网出现（CIDR)  </li><li>网络地址不够用了–&gt;NAT出现，内网  </li></ul><h5 id="网段，网络范围内，由谁主导生效进行实际的网络隔离和连接"><a href="#网段，网络范围内，由谁主导生效进行实际的网络隔离和连接" class="headerlink" title="网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?"></a>网段，网络范围内，由谁主导生效进行实际的网络隔离和连接?</h5><p>—其实本质上，设备间可以通过知道mac地址相互通信，即没有网络的隔离（只要介质支持如wifi,或者有线网下设备能被连在一起)在二层上考虑的    </p><ul><li>到了三层，ip层，设备与设备之间的通信，取决于网络的大小，在同一个局域网中，设备间可以直接通信，但是不同局域网，就必须借助路由器，网络，为什么?<br>首先，考虑他们的距离，若很远，则单纯直连很难，则需要转发，转发单知道mac地址（好吧，假设一开始知道对方的mac地址），很难像现在用ip地址的方式去找到它emm感觉考虑到协议设计了。。。<br>其次，考虑相邻的不同网络，对应不同的网段，路由表规定了只能和该网络地址范围的主机直接连接，否则就要用默认路由了</li><li>考虑这样一个例子：A 在子网192.168.0.0中，地址为192.168.0.3,B在子网10.170.3.0,地址为10.170.3.2,使用wifi,他们之间相邻，此时，A向B发送ARP请求，广播帧，所以B可以接收到，接着B给A回复了响应帧，单波能收到，因为在二层传递，能接收到，不被内核过滤，此时arp表中应该多了条目；接着为了能在三层通信，在路由表中增加一条路由指示不同网段的一个地址，表示他们可以直连，接着测试看看能不能相互发送ip包，ping通，当然可能因为防火墙等；就理论而言，应该是能通的，没试过~–&gt;问题总结：IP地址网段不同的两个设备，一定不能直接通信码?<ul><li>网关地址必须是.1结尾码?<br>恩当然可以是别的地址</li><li>路由表和路由规则决定了这些<br>路由表如何决定了网络的方向，下一跳，和限制了网络范围？<h4 id="网络的拓扑结构"><a href="#网络的拓扑结构" class="headerlink" title="网络的拓扑结构:"></a>网络的拓扑结构:</h4>理论上，网络中的每台设备都能相互通信，即使是点对点通信p2p.但是这要求设备能在网络上被唯一标示，如外网ip地址；</li><li>所以常见的设备A和B的通信借助服务器如：<br>主机A<-->路由器(给主机唯一标识)<-->服务器<-->路由器<-->主机B<br>(现有的大部分通信软件等都是这样的)</--></--></--></--></li><li>而主机A可以直接和主机B通信不通过服务器吗?<br>答案是可以，我们使用的迅雷，bt,这些下载资源就是利用的各个主机的资源，其结构如何：<br>主机A<-->路由器(做NAPT等)<-->路由器<-->主机B<br>那和主机A和B如何在网络上被唯一标示，且被B知道该地址呢?路由器在其中充当什么角色，会做什么限制呢？<br>见下NAT和NAT穿透<h4 id="路由深入–NAT和NAT穿透"><a href="#路由深入–NAT和NAT穿透" class="headerlink" title="路由深入–NAT和NAT穿透"></a>路由深入–NAT和NAT穿透</h4>感谢这两篇文章把我带进门：<br><a href="https://blog.csdn.net/u012908515/article/details/53518062" target="_blank" rel="noopener">https://blog.csdn.net/u012908515/article/details/53518062</a><br><a href="https://blog.csdn.net/ustcgy/article/details/5655050" target="_blank" rel="noopener">https://blog.csdn.net/ustcgy/article/details/5655050</a><br>rfc ：nat<br><a href="https://tools.ietf.org/html/rfc1631" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1631</a><br><a href="https://tools.ietf.org/html/rfc2663" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2663</a><br>rfc：p2p<br><a href="https://tools.ietf.org/html/rfc5694" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc5694</a><h5 id="NAT的由来"><a href="#NAT的由来" class="headerlink" title="NAT的由来"></a>NAT的由来</h5></--></--></--></li><li>NAT的出现是因为ipv4的地址不够用，所以大量主机在内网使用内网地址，这样在互联网上通信的时候不能被寻找到，此时路由器将内网的设备发送的包中的ip转换为外网的ip,并记录映射在路由器中，这样就能实现主机在互联网上的正常通信，即发包和收包都能找到；</li><li>而这种方式阻碍了不同内网的主机之间的通信，即p2p;<h4 id="NAT的分类（路由器决定）"><a href="#NAT的分类（路由器决定）" class="headerlink" title="NAT的分类（路由器决定）"></a>NAT的分类（路由器决定）</h4></li><li>静态NAT:即内网的一个IP对应外网的一个IP，且一一对应，即每次分配的时候都是相同的，永久的</li><li>动态NAT：即内网的一个IP对应外网的一个IP,但是每次分配的外网IP可能不同，映射不同</li><li>NAPT:即为了使同一个外网IP能被多个内网的主机使用而出现；<br>如何区分各个主机？即路由器发包时和收包时，如收包时，如何确定该包是发给主机A还是B?即用NAPT,IP加端口号的形式来区分  </li><li>NAPT分为以下两大类：cone锥形NAT和symmetric 对称NAT</li></ul><ol><li>cone NAT的特点是对内网的主机A，和外网所有的服务器通信，都使用相同的端口号；<br>如：内网：192.168.4.5:4323–&gt;server:222.33.22.334:80<br>则经过路由器：外网ip:122.332.43.32:1234–&gt;server:22…路由器把源地址改为122.332.43.32:1234后发送<br>进过服务器2也是类似的，使用同一个端口1234<br>//这里有个疑问，即内网下相同的ip地址，不同的端口时，经过路由器转换后是否为不同端口<br>考虑在接收服务器回复的内容时:<br>222.33.22.334:80–&gt;122.332.43.32：1234此时路由器根据映射，即端口122.332.43.32：1234对应的是192.168.4.5把目的地址和端口更改为它后发送。所以为了能让包在主机内找到对应端口的程序，路由器的设置应为内网同ip不同端口，映射外网的ip+不同端口（待验证）</li></ol><ul><li>锥形NAT类型：完全锥形full cone和受限锥形( restricted cone) 以及端口受限锥形（port restricted cone)  </li></ul><ul><li>完全锥形：任何知道主机B银蛇在NAT上的外部地址和端口的主机都可以通过它发包给内部主机B,即使A在内网(在内网时通过映射的外网地址）</li><li>受限锥形：只有内部主机B向其发送过包的主机A才能对这个内部主机B发包（通过主机B映射在外部的地址端口）</li><li>端口受限：在受限锥形的基础上加了端口限制</li></ul><ol start="2"><li>对称NAT(symmetric nat):<br>会为新的session分配新的端口，即和服务器1通信时使用端口1234，接着发起新的服务器2访问时，使用端口1235等<br>如何检测类型？<a href="https://blog.csdn.net/u012908515/article/details/53518062" target="_blank" rel="noopener">https://blog.csdn.net/u012908515/article/details/53518062</a></li></ol></li></ul><h5 id="ipv6不需要NAT"><a href="#ipv6不需要NAT" class="headerlink" title="ipv6不需要NAT"></a>ipv6不需要NAT</h5><p>ipv6地址很多，有人形容世界上的每个沙子都能被定址，所以地址够用，也就不用内网，所以用来做p2p更适用，自然也就不用什么nat转换</p><h5 id="p2p网络架构和内网穿透"><a href="#p2p网络架构和内网穿透" class="headerlink" title="p2p网络架构和内网穿透"></a>p2p网络架构和内网穿透</h5><p>基于上面的napt类型介绍，可以知道内网的主机如何和外网的服务器通信，那内网的主机1如何和另一个内网的主机2直接通信?（不借助服务器）<br>答案:基于上面的限制，有几种方案：  </p><ul><li>针对full cone类型的，内网主机2只要知道内网主机1映射到外部的ip地址和端口，就可以直接发送数据包给1，且能接收；</li><li>针对受限的cone类型，内网机2像上面的方式是不行的：得满足两个条件：1是知道主机1映射到外部的ip和端口，2是主机1曾向主机2发送过请求，相当于开了个口，显然这个条件下2为服务器或者有公网ip的设备；所以针对此受限的类型，有一下场景+方案：<ul><li>场景1：主机1在nat后，打开了和服务器A通信，主机2想和1通信，主机2不在nat后；显然直接向主机1发起请求是不行的，上述条件2不满足，主机1不曾向2发起请求；  </li><li>解决方案是，借助服务器A请求主机1做一个反向连接，即向2发起请求，从而打开通道，进而2就可以跟1通信了</li><li>场景2：主机1在nat后，主机2在nat后，主机1，2均打开了和服务器A通信，主机1想直接和2通过双方映射到外网的地址端口进行通信 </li><li>解决方案：UDP打洞：假如1开始发送一个UDP信息到2的公网地址上,与此同时,他又通过A中转发送了一个邀请信息给2,请求2也给1发送一个UDP信息到1的公网地址上.这时1向2的公网IP发送的信息导致 NAT 1 打开一个处于1的私有地址和2的公网地址之间的新的通信会话,与此同时NAT 2也打开了一个处于2的私有地址和1的公网地址之间的新的通信会话.一旦这个新的UDP会话各自向对方打开了,1和2之间就可以直接通信,而无需A来牵线搭桥了.这就是所谓的打洞技术.一旦这种处于NAT之后的端对端的直连建立之后,连接的双方可以轮流担任对方的”媒人”,把对方介绍给其他的客户端,这样就极大的降低了服务器A的工作量.</li><li>场景3：主机1和2处于同一个NAT下，他们却不知道：</li><li>解决方案：综合相同内网下主机可以直接相互通信原理：在主机1发送给A的包中携带其内网地址和端口，A从而知道了1的外网端口地址和内网端口地址，相互都发给1,2，若接着1发起请求给2能收到回复说明在同一个内网，否则采用场景2的解决方案</li><li>场景4：主机1处于多层NAT下</li><li>问题：udp空闲状态下超时断开的问题：使用心跳包</li><li>扩展：tcp的打洞，同时开放tcp连接，原理类似，较复杂</li></ul></li><li>针对对称性的cone,不定因素多，不建议写</li><li>所以p2p网络即是多个内网主机1,2,3,4等之间的相互直接通信，即他们之间的下载数据可以相互共享，也就是平常说的挂种子，bt下载，也是为什么能达到那么快速的原因;当然可想这个过程和普通的cs架构区别：</li><li>p2p架构，bt模型（猜测)：首先客户端负责下载和挂种的基本功能。下载:需要向服务器取得可以获取资源的主机的nat外网地址和ip,接着服务器为其打洞，将正在挂种的客户ip等提供给该客户端，从而能下载；挂种：给服务器声明自己能提供资源，并通过心跳维持一个持续的洞；BT服务器做什么?综合客户端资源和打洞，即让下载方能方访问挂种放 。   这个过程需要考虑：下载方面对多个挂种方，如何下载文件块和组装，最多同时和几个挂种方下载等等；</li><li>回忆：之前学校的rs bt站就是这样，只是开放在学校的内网，可以说是相同nat下的不同主机???好像也不能这么说。。然后采用的原理就是上述的，记得一开始速度不是很快，但是后面15年吧，下载速度能达到10+m/s,很快的，我想可能是优化了下载多个挂种方的方案，增加了最多的下载源，或者学校的网络变优～<h5 id="Cbitterrot源码分析（待"><a href="#Cbitterrot源码分析（待" class="headerlink" title="Cbitterrot源码分析（待~)"></a>Cbitterrot源码分析（待~)</h5><a href="https://linux.cn/thread-5529-1-1.html" target="_blank" rel="noopener">https://linux.cn/thread-5529-1-1.html</a><br>对于p2p架构的软件设计，其实跟平常的cs架构很象，都需要用到socket等</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;IP-协议和路由&quot;&gt;&lt;a href=&quot;#IP-协议和路由&quot; class=&quot;headerlink&quot; title=&quot;IP 协议和路由&quot;&gt;&lt;/a&gt;IP 协议和路由&lt;/h3&gt;&lt;h4 id=&quot;IP的作用–路由&quot;&gt;&lt;a href=&quot;#IP的作用–路由&quot; class=&quot;headerlink&quot; title=&quot;IP的作用–路由&quot;&gt;&lt;/a&gt;IP的作用–路由&lt;/h4&gt;&lt;h5 id=&quot;路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作&quot;&gt;&lt;a href=&quot;#路由是什么-一个数据包如何在网络上传输-会对ip包做什么动作&quot; class=&quot;headerlink&quot; title=&quot;路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?&quot;&gt;&lt;/a&gt;路由是什么?一个数据包如何在网络上传输?会对ip包做什么动作?&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从广义上讲，路由是路线图，就像百度地图上源地址到目的地址的路线，路线有很多，故路由也很多；
    
    </summary>
    
      <category term="tcpip" scheme="http://xdksx.github.io/categories/tcpip/"/>
    
    
      <category term="tcpip_ip" scheme="http://xdksx.github.io/tags/tcpip-ip/"/>
    
  </entry>
  
  <entry>
    <title>tcpip_MAC</title>
    <link href="http://xdksx.github.io/2018/06/03/tcpip-MAC/"/>
    <id>http://xdksx.github.io/2018/06/03/tcpip-MAC/</id>
    <published>2018-06-03T04:29:48.000Z</published>
    <updated>2018-06-03T12:32:12.966Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mac数据链路层的理解"><a href="#mac数据链路层的理解" class="headerlink" title="mac数据链路层的理解"></a>mac数据链路层的理解</h3><h4 id="mac层的功能介绍"><a href="#mac层的功能介绍" class="headerlink" title="mac层的功能介绍"></a>mac层的功能介绍</h4><p>mac层在理论上赋予了较全的功能，但是其实，实际上在使用的时候，由于无噪声通道，或者一些功能交给了上层的协议，所以实际的mac功能没有理论那么全面。mac层的实现包括在驱动和固件中，所以实际的功能得看芯片和固件的支持，比如是否支持监听模式；  <a id="more"></a><br>理论上：建议书籍《数据通信与网络》<br>寻址：实际的端到端通信，都是需要先知到对方的mac地址(通过arp),才能进行实际传输的；<br>帧构建：这一层结束后就是完成了包封装，下一步传送给物理层编码发送了；<br>数据差错检查；传送控制，流量控制，差错控制，编码，校验和等等；，编码是指在原始数据mac封包后，在实际传输时进行编码（按照某个80x协议等，这个属于偏物理层的事情了）<br>实际上：数据差错检查，流量控制，差错控制等都没做，或者要看具体的厂商实现如高通，mtk等</p><h4 id="mac层的传输限制"><a href="#mac层的传输限制" class="headerlink" title="mac层的传输限制"></a>mac层的传输限制</h4><p> 考虑一个包从电脑发出去，最后一次封包根据接口不同(有线，无线),协议不同，采用的mac头也不同，如ppp协议要加其他信息；<br> –&gt;简述:接着可能发给无线路由器或者交换机，路由器会判断是wifi的mac头，接着要向以太网传输时，或者无线传输时，需要去掉mac头，并加上自己的mac头，改变mac源地址为自己，目的地址为(路由表对应)arp寻找的下一跳mac地址;若为以太网，还要转换为以太网的头类型等<br> …<br> 整个过程，从物理层角度看，是可以顺利进行的，但是实际为了效率，不接受无用的包，不发送无效的包和安全等，在驱动和固件都会有做相应的过滤处理，从而使发包收包，转发包等受到了限制，见下实验等；</p><h4 id="mac层的封包-mtu-msdu-mpdu"><a href="#mac层的封包-mtu-msdu-mpdu" class="headerlink" title="mac层的封包,mtu,msdu,mpdu"></a>mac层的封包,mtu,msdu,mpdu</h4><p>在包的封装上，有线网和无线网不同，更确切的是协议不同，其mac层封包也不同–对相同的ip包(ip头+上层数据/arp/…）带有不同的mac头：<br>例如对以太网（有线）：常见有一下四种mac头封装的帧：</p><ul><li>EthernetII:  dest addr+src addr+type+data+fcs</li><li>Ethernet 802.2:dest addr+srcaddr+len+ llc+data+fcs</li><li>Ethernet 802.3:dest addr+src addr+len+data+fcs </li><li>Ethernet SNAP:dest addr+src addr+len+llc+snap+data+fcs<br>参考：<a href="https://blog.csdn.net/xiao628945/article/details/8006022" target="_blank" rel="noopener">https://blog.csdn.net/xiao628945/article/details/8006022</a><br>针对无线网络：802.11n等，更复杂些：</li><li>802.11头+msdu(数据部分)+fcs(crc)<br>而802.11wifi无线帧分为控制帧，管理帧和数据帧，因为在无线网络中的安全性等考虑，需要扫描，关联，认证四次握手等步骤,在802.11头就包含了subtype，即数据部分是什么类型（控制，。。）<a href="https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末" target="_blank" rel="noopener">https://blog.csdn.net/suiyuan19840208/article/details/17200745或者啃spec:文末</a><br><a href="https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了" target="_blank" rel="noopener">https://blog.csdn.net/robertsong2004/article/details/42805803这篇更详细，能查到的不想记录了</a><br>这么多的封包类型，除却ip层只有一种，那在传递的过程中如何处理?即有线到无线，怎么识别?答案是在路由器，主机中进行去头和加头<br>不同厂商实现不同，在无线中，非数据帧部分：底层的实现分为full mac driver（Full Mac的Driver，一般Auth和Assoc的包直接在芯片里边处理了，Driver通过command形式告诉Firmware要连接AP的信息，Firmware处理了Assoc Response之后，report给Driver一个Event，说明连接的情况（result和AID）以及assoc相关的IE，Driver会直接调用cfg80211的接口报告给supplicant，然后处理EAPOL的握手过程，因为之后的EAPOL Data的处理会用到Assoc Response里边的IE）  而用soft mac则软件可以控制较多的事情(Soft Mac模块开源代码mac80211的WiFi芯片，会将这两种包送到Mac80211处理，mac80211处理完后调用cfg80211的接口通过nl80211(netlink)通知wpa_supplicant准备认证以及四次握手的状态机，等待处理EAPOL包，EAPOL是二层的Data包，会在Supplicant里边处理，连接加密的路由情况就是这样处理的，如果不加密，那就直接DHCP了)；扯远了。。<br>在pc等设备中，在封装到数据链路层时，封装时用的是ethernetII，到底层驱动时就被替换为对应的802.11的头了，进而发送出去，而在接收数据包的时候，底层上报上来又会把802.11格式的转换为ehternetII的形式，所以我在实验wifi的时候，用的PF_PACKET来操作数据包，加的是ethernetII的头，接收到打印出来后还是ethernetII的头<br>晒张空中包的和本地tcpdump抓到的包对比：<br>//to do</li></ul><p>当然除却mac头的不同，mtu的概念还是存在:<br>mac层在传输时一次传输一帧，这一帧即是封装了mac头的数据包，它常为[46-1500]+mac头,而mtu即是最大的传输单元，是去掉mac头的负载部分最大值，如1500<br>而在实际传输的空中包，情况又可能不同，这里看msdu 和mpdu:<br><a href="https://blog.csdn.net/zhengnice/article/details/51923132" target="_blank" rel="noopener">https://blog.csdn.net/zhengnice/article/details/51923132</a><br>这篇文章讲的很好，在理解了上述的内容后，看这篇文章里面的msdu和mpdu就能很好的理解了，spec的416页也有相关的内容</p><h5 id="mac头格式：不同协议可能不同："><a href="#mac头格式：不同协议可能不同：" class="headerlink" title="mac头格式：不同协议可能不同："></a>mac头格式：不同协议可能不同：</h5><p>常见：dest addr,src addr ,proto type; 14byte<br>见上文</p><h4 id="mac层的发包和收包限制"><a href="#mac层的发包和收包限制" class="headerlink" title="mac层的发包和收包限制"></a>mac层的发包和收包限制</h4><p>考虑一个问题，即在不考虑网络网段的情况下，两台设备在开启wifi或者连接网线的情况下，能相互直接通信吗？<br>从理论上是可以的，首先是发送，无问题，接收，可以接收；其次，接收之后解码，需要双方使用相同的编码协议等；<br>其次：实际上，需要几个条件，且有线和无线的方式不同：</p><ul><li>有线：需要双方相同的编码，直连的情况下，可以直接通信；</li><li>无线: (分为数据部分和管理部分，需要双方相同的编码)，但是仅开启wifi，只能接收小量信息的beacon帧；即wifi为了安全性，效率等(wifi本身可以接收所有数据），做了连接前的扫描，关联认证，四次握手等过程，并且对mac地址进行过滤，使不同网段的两个相邻设备不能通过直接发送接收mac层数据来交互；具体见厂商的实现，可以参考实验部分；  </li><li>所以关键看厂商怎么实现，底层的东西，他们提供接口给你，你就能操作了balalal<h5 id="普通模式，混杂模式和监听模式"><a href="#普通模式，混杂模式和监听模式" class="headerlink" title="普通模式，混杂模式和监听模式"></a>普通模式，混杂模式和监听模式</h5><h4 id="mac层的几个实验"><a href="#mac层的几个实验" class="headerlink" title="mac层的几个实验"></a>mac层的几个实验</h4>普通模式下，wifi实验，以station架构进行：<br>设备A，B,路由器C，D;  </li><li>A,B连接同一个路由器C,A,B通过PF_PACKET发送和接收mac头加任意数据，成功发送接收，即使arp表无对方的条目  </li><li>A,B都不连接wifi,只是打开wifi，此时无法发送和接收数据，厂商默认的只会发送主动扫苗和接收beacon帧，扫描的具体过程待文章写,在没有连接上时，只会发送小数据</li><li>A,B间任意设备连上路由器，同上</li><li><em>A连接路由C,B连接路由D,相互发送和接收mac头加任意数据，目的地址为对方mac，源地址为自己的mac—失败，其实一开始是怀着疑问的，从理论分析是可以的，但是还是不行，若只是在二层的话，对方怎么知道这个源mac地址是在不同网段并做过滤?难道发之前，底层进行了隐式arp？但是我发的包里面没有带ip信息啊，同时进行了广播帧的发送接收，还是失败了；应该都是出在接收的环节；也有可能是两个ap使用的协议不同导致编码方式不同从而接收失败</em></li><li>考虑到可能是两个路由器编码和使用的协议如一个是802.11n,一个是ac，等，可能导致接收不到，所以可以再尝试使用两个相同的型号的路由器；//待测试</li><li>发送方普通模式，接收方监听模式，接收方可以收到所有包，所以可以接收到</li></ul><h4 id="openwrt开源路由系统，驱动，固件"><a href="#openwrt开源路由系统，驱动，固件" class="headerlink" title="openwrt开源路由系统，驱动，固件"></a>openwrt开源路由系统，驱动，固件</h4><p>了解一下。。。<br>spec:Wireless LAN Medium Access Control<br>(MAC)<br>and Physical Layer (PHY) Specifications</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;mac数据链路层的理解&quot;&gt;&lt;a href=&quot;#mac数据链路层的理解&quot; class=&quot;headerlink&quot; title=&quot;mac数据链路层的理解&quot;&gt;&lt;/a&gt;mac数据链路层的理解&lt;/h3&gt;&lt;h4 id=&quot;mac层的功能介绍&quot;&gt;&lt;a href=&quot;#mac层的功能介绍&quot; class=&quot;headerlink&quot; title=&quot;mac层的功能介绍&quot;&gt;&lt;/a&gt;mac层的功能介绍&lt;/h4&gt;&lt;p&gt;mac层在理论上赋予了较全的功能，但是其实，实际上在使用的时候，由于无噪声通道，或者一些功能交给了上层的协议，所以实际的mac功能没有理论那么全面。mac层的实现包括在驱动和固件中，所以实际的功能得看芯片和固件的支持，比如是否支持监听模式；
    
    </summary>
    
      <category term="tcpip" scheme="http://xdksx.github.io/categories/tcpip/"/>
    
    
      <category term="tcpip_mac" scheme="http://xdksx.github.io/tags/tcpip-mac/"/>
    
  </entry>
  
  <entry>
    <title>tcpip_ARP</title>
    <link href="http://xdksx.github.io/2018/05/27/tcpip-ARP/"/>
    <id>http://xdksx.github.io/2018/05/27/tcpip-ARP/</id>
    <published>2018-05-27T16:19:57.000Z</published>
    <updated>2018-05-31T00:08:57.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h3><h4 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h4><ul><li>ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信；</li><li>在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：<br>端设备手机pc等–&gt;(交换机)路由器—&gt;下一个路由器—&gt;下一个终端设备  <a id="more"></a><br>端设备默认路由到网关–&gt;网关收到包后，将源地址改为网关的外网地址—&gt;下一个路由–&gt;….-&gt;设备地址为目的地址时，接收而不转发</li><li>考虑一个问题：在上述的网络上发送时，如pc发给路由器时，只知道它的ip地址，怎么发给它：<br>即端到端的发送：是借助设备唯一的mac地址来发送的<br>在有线网中。利用了交换机的端口和mac地址关系，转发<br>在wifi中，能接收到所有的包，但是会在驱动中将mac目的地址非本地的包丢弃，除非开启了混杂监听模式</li><li>但是路由器怎么知道设备如手机的mac地址呢？<br>通过arp协议来获取，arp是依赖mac和ip的”映射”</li><li>tcpip卷1中4.2举了一个完整的例子，可以去看<h4 id="ARP协议的交互过程"><a href="#ARP协议的交互过程" class="headerlink" title="ARP协议的交互过程"></a>ARP协议的交互过程</h4></li><li>基本的交互方式：<br>例如ping网关：<br>station  —ARP request—-&gt;   AP  ARP请求，广播帧<br>station  &lt;—ARP response —  AP  ARP应答 ,单播帧<br>通过上述的方式，station得到了AP的mac地址，之后将AP的MAC地址存在缓存中，在下次数据包等包的时候就可以将该mac地址填在mac头中，即知道了AP的地址后，包就可以顺利的被AP接收了</li><li>AP(路由器)也会主动的向station发送arp request，当它不知道station的mac地址（或缓存过期），例如，AP收到一个外网的包，要转发给对应192.168.0.4的staton,但是没有他的mac地址，或者过期了或者其他情况，则向该station发出arp请求。从而得打station的mac地址</li><li>什么时候会触发arp请求？<br>1.在ping的时候<br>2.在发送tcp，ip包的时候<br>3.在缓存过期时主动发出，这个由arp状态机中实现<h4 id="ARP代理和免费ARP"><a href="#ARP代理和免费ARP" class="headerlink" title="ARP代理和免费ARP"></a>ARP代理和免费ARP</h4></li><li>当我们通过ping百度，或者想访问百度的时候，怎么在mac头中填写目的mac地址呢？即怎么找到百度?（另一个网络)</li><li>是通过在mac头目的mac地址填写网关的mac地址实现的，借助w网关的来帮我们寻找，这个叫做ARP代理,其实欺骗了主机</li><li>tcpip卷对此有较详细解说4.6</li><li>免费ARP是用于检测是否周围有使用相同的ip地址的设备，即通过ping自己，寻找有自己的ip的主机<h4 id="ARP协议的包封装格式和抓包分析"><a href="#ARP协议的包封装格式和抓包分析" class="headerlink" title="ARP协议的包封装格式和抓包分析"></a>ARP协议的包封装格式和抓包分析</h4></li><li>分组格式：  ()为字节数<br>mac头：以太网目的地址(6) mac源地址(6) 帧类型(2)(0x0806)<br>28byte arp帧：硬件类型(2)|协议类型(2)|硬件地址长度(1)|协议地址长度(1)|op(请求或应答或rarp 2)|发送端mac地址(6)|发送端ip(4)|接收端mac地址(6)|接收端ip(4)  </li><li>请求广播帧：目的mac地址为全1，电缆上所有的以太网接口都要接收广播帧,硬件类型为1表示以太网地址，协议类型为要映射的协议地址类型0x0800,表示为ip地址，op（arp请求为1，答应为2，rarp请求为3，rarp答应为4）</li><li>arp填充：以太网帧最小值为60，mac头14，所以=46，要填充：46-28=18个字节</li><li>arp抓包，可以用wireshark,Omnipeek - Savvius,tcpdump,或者自己写一个程序来抓～<br>tcpdump : sudo tcpdump -vv arp  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> tcpdump: listening on wlp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">21.134575</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span> <span class="comment">//ap ask me</span></span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">21.135404</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span></span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">21.135413</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Reply <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> is-at <span class="number">48</span>:<span class="number">5</span>a:b6:<span class="number">6</span>e:c9:<span class="number">5f</span> (oui Unknown), length <span class="number">28</span><span class="comment">// i reply ap</span></span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">32.081916</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.106</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span> <span class="comment">//ask other</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">01</span>:<span class="number">27.149947</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.107</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span></span><br><span class="line"><span class="number">0x0000</span>:  <span class="number">0001</span> <span class="number">0800</span> <span class="number">0604</span> <span class="number">0001</span> <span class="number">206b</span> e70f <span class="number">1b</span>42 c0a8  .........k...B..</span><br><span class="line"><span class="number">0x0010</span>:  <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> c0a8 <span class="number">006b</span>            ...........k</span><br><span class="line">    </span><br><span class="line">    <span class="number">22</span>:<span class="number">04</span>:<span class="number">17.114593</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Reply <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> is-at <span class="number">48</span>:<span class="number">5</span>a:b6:<span class="number">6</span>e:c9:<span class="number">5f</span> (oui Unknown), length <span class="number">28</span></span><br><span class="line"><span class="number">0x0000</span>:  <span class="number">0001</span> <span class="number">0800</span> <span class="number">0604</span> <span class="number">0002</span> <span class="number">485</span>a b66e c95f c0a8  ........HZ.n._..</span><br><span class="line"><span class="number">0x0010</span>:  <span class="number">006</span>e <span class="number">206b</span> e70f <span class="number">1b</span>42 c0a8 <span class="number">0001</span>            .n.k...B....</span><br></pre></td></tr></table></figure><h4 id="ARP协议的常用命令和调试分析"><a href="#ARP协议的常用命令和调试分析" class="headerlink" title="ARP协议的常用命令和调试分析"></a>ARP协议的常用命令和调试分析</h4><ul><li>查看ARP缓存：即现在保存的arp映射表:  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">arp</span> <span class="selector-tag">-a</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.101</span>) <span class="selector-tag">at</span> 4<span class="selector-tag">c</span><span class="selector-pseudo">:32</span><span class="selector-pseudo">:75</span><span class="selector-pseudo">:3a</span><span class="selector-pseudo">:09</span><span class="selector-pseudo">:b3</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.1</span>) <span class="selector-tag">at</span> 20<span class="selector-pseudo">:6b</span><span class="selector-pseudo">:e7</span><span class="selector-pseudo">:0f</span><span class="selector-pseudo">:1b</span><span class="selector-pseudo">:42</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.108</span>) <span class="selector-tag">at</span> 94<span class="selector-pseudo">:d0</span><span class="selector-pseudo">:29</span><span class="selector-pseudo">:9d</span><span class="selector-pseudo">:74</span><span class="selector-pseudo">:dd</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.107</span>) <span class="selector-tag">at</span> 94<span class="selector-pseudo">:65</span><span class="selector-pseudo">:2d</span><span class="selector-pseudo">:ab</span><span class="selector-pseudo">:88</span><span class="selector-pseudo">:8b</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">arp</span> </span><br><span class="line"><span class="selector-tag">Address</span>                  <span class="selector-tag">HWtype</span>  <span class="selector-tag">HWaddress</span>           <span class="selector-tag">Flags</span> <span class="selector-tag">Mask</span>            <span class="selector-tag">Iface</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.101</span>            <span class="selector-tag">ether</span>   4<span class="selector-tag">c</span><span class="selector-pseudo">:32</span><span class="selector-pseudo">:75</span><span class="selector-pseudo">:3a</span><span class="selector-pseudo">:09</span><span class="selector-pseudo">:b3</span>   <span class="selector-tag">C</span>                     <span class="selector-tag">wlp2s0</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.1</span>              <span class="selector-tag">ether</span>   20<span class="selector-pseudo">:6b</span><span class="selector-pseudo">:e7</span><span class="selector-pseudo">:0f</span><span class="selector-pseudo">:1b</span><span class="selector-pseudo">:42</span>   <span class="selector-tag">C</span>                     <span class="selector-tag">wlp2s0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ip neigh</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span> dev wlp2s0 lladdr <span class="number">4</span>c:<span class="number">32</span>:<span class="number">75</span>:<span class="number">3</span>a:<span class="number">09</span>:b3 STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> dev wlp2s0 lladdr <span class="number">20</span>:<span class="number">6b</span>:e7:<span class="number">0f</span>:<span class="number">1b</span>:<span class="number">42</span> STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.108</span> dev wlp2s0 lladdr <span class="number">94</span>:d0:<span class="number">29</span>:<span class="number">9</span>d:<span class="number">74</span>:dd STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.107</span> dev wlp2s0 lladdr <span class="number">94</span>:<span class="number">65</span>:<span class="number">2</span>d:ab:<span class="number">88</span>:<span class="number">8b</span> STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.104</span> dev wlp2s0 lladdr e4:<span class="number">9</span>a:dc:b0:a5:<span class="number">36</span> STALE</span><br></pre></td></tr></table></figure><ul><li>arping命令：<br><a href="http://man.linuxde.net/arping" target="_blank" rel="noopener">http://man.linuxde.net/arping</a></li><li>arp 命令<br>man arp 包括删除arp表项等，有问题，找男人~<h4 id="ARP协议内核状态机"><a href="#ARP协议内核状态机" class="headerlink" title="ARP协议内核状态机"></a>ARP协议内核状态机</h4></li><li>对不存在的主机，arp请求的超时机制  </li><li>arp缓存和老化时间：<br><a href="http://www.jb51.net/LINUXjishu/65693.html：" target="_blank" rel="noopener">http://www.jb51.net/LINUXjishu/65693.html：</a><br>改变老化时间：在Linux上如果你想设置你的ARP缓存老化时间，那么执行sysctl -w net.ipv4.neigh.ethX=Y即<h4 id="ARP协议的编程"><a href="#ARP协议的编程" class="headerlink" title="ARP协议的编程"></a>ARP协议的编程</h4></li><li>在PF_PACKET中发出ARP包</li><li>直接贴例子，具体可以看博客的PF_PACKET文章：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取硬件网卡的相应信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="keyword">char</span> *name , <span class="keyword">char</span> *MAC_addr , struct in_addr * IP_addr)</span></span>;</span><br><span class="line"><span class="comment">//arp包的结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ARP_PACKET</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="comment">//以太网首部</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> dest_mac[<span class="number">6</span>]; <span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> sorce_mac[<span class="number">6</span>];<span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> type;       <span class="comment">//2字节</span></span><br><span class="line">  <span class="comment">//arp——内容</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> hw_type;   <span class="comment">//2字节：硬件地址类型     0x0001 表示mac地址</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> pro_type;  <span class="comment">//2字节：软件地址类型    0x0806 表示IPV4地址</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> hw_len;     <span class="comment">//1字节：硬件地址长度  </span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> pro_len;    <span class="comment">//1字节：软件地址长度</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> op;        <span class="comment">//2字节：操作类型           0x0001表示ARP请求；0x0002表示ARP应答</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> from_mac[<span class="number">6</span>];<span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> from_ip[<span class="number">4</span>]; <span class="comment">//4字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> to_mac[<span class="number">6</span>];  <span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> to_ip[<span class="number">4</span>];   <span class="comment">//4字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> padding[<span class="number">18</span>];<span class="comment">//18字节：填充字节，因为以太网数据最少要46字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> MAC_ADDR[<span class="number">6</span>];</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">IP_ADDR</span>;</span><span class="comment">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ARP_PACKET</span> <span class="title">arp_pk</span>=&#123;</span><span class="number">0</span>&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">eth_info</span>;</span><span class="comment">//结构体的定义//在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class="line"> <span class="comment">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class="line"> GetEthInfor(<span class="string">"wlp2s0"</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class="line">   <span class="comment">/*printf("The MAC_addr is:");</span></span><br><span class="line"><span class="comment"> for(i =0 ;i&lt;6;i++)</span></span><br><span class="line"><span class="comment">    printf("%4X",MAC_ADDR[i]); </span></span><br><span class="line"><span class="comment"> printf("\n");</span></span><br><span class="line"><span class="comment">    printf("the IP is:%s\n",inet_ntoa(IP_ADDR));*/</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//第二步：填充ARP数据包的内容</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充以太网首部的目的mac地址</span></span><br><span class="line"> &#123;</span><br><span class="line">  arp_pk.dest_mac[i]=<span class="number">0XFF</span>;      </span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充以太网首部的源mac地址</span></span><br><span class="line"> &#123;</span><br><span class="line">  arp_pk.sorce_mac[i]=MAC_ADDR[i];</span><br><span class="line"> &#125;</span><br><span class="line">   arp_pk.type = htons(<span class="number">0x0806</span>);    <span class="comment">//填充以太网首部的侦类型</span></span><br><span class="line">   arp_pk.hw_type = htons(<span class="number">0x0001</span>); <span class="comment">//填充硬件地址类型：0x0001表示的是MAC地址</span></span><br><span class="line">   arp_pk.pro_type = htons(<span class="number">0x0800</span>);<span class="comment">//填充协议地址类型：0x0800表示的是IP地址</span></span><br><span class="line">   arp_pk.hw_len = <span class="number">6</span>;              <span class="comment">//填充硬件地址长度</span></span><br><span class="line">   arp_pk.pro_len = <span class="number">4</span>;             <span class="comment">//填充协议地址长度</span></span><br><span class="line">   arp_pk.op = htons(<span class="number">0x0001</span>);      <span class="comment">//填充操作类型：0x0001表示ARP请求</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充源mac地址</span></span><br><span class="line">   &#123;</span><br><span class="line">  arp_pk.from_mac[i]=MAC_ADDR[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">in_addr_t</span> ipaddr=inet_network(inet_ntoa(IP_ADDR));</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)                 <span class="comment">//填充源IP地址</span></span><br><span class="line">   &#123;</span><br><span class="line">  arp_pk.from_ip[i]=(<span class="keyword">unsigned</span> <span class="keyword">char</span>)ipaddr&amp;<span class="number">0xFF</span>;</span><br><span class="line">   ipaddr=ipaddr&gt;&gt;<span class="number">8</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"-%d-"</span>,arp_pk.from_ip[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">/* arp_pk.from_ip[0]=192;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[1]=168;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[2]=199;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[3]=145;*/</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充欲获取的目的mac地址</span></span><br><span class="line">   &#123;</span><br><span class="line">    arp_pk.to_mac[i]=<span class="number">0X00</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   arp_pk.to_ip[<span class="number">0</span>]=<span class="number">0X0B</span>;        <span class="comment">//填充想要装换为MAC地址的IP地址。可以使用命令行参数来做</span></span><br><span class="line">   arp_pk.to_ip[<span class="number">1</span>]=<span class="number">0X40</span>;</span><br><span class="line">   arp_pk.to_ip[<span class="number">2</span>]=<span class="number">0X39</span>;</span><br><span class="line">   arp_pk.to_ip[<span class="number">3</span>]=<span class="number">0X0A</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第三步：填充sockaddr_ll eth_info结构</span></span><br><span class="line">    eth_info.sll_family = PF_PACKET;</span><br><span class="line"> eth_info.sll_ifindex = if_nametoindex(<span class="string">"wlp2s0"</span>);<span class="comment">//返回输入的接口名称的索引值</span></span><br><span class="line"> <span class="comment">//printf("number is:%d\n",eth_info.sll_family);</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第四步：创建原始套接字</span></span><br><span class="line"> fd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));  <span class="comment">//</span></span><br><span class="line"> <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"socket SOCK_RAW failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="comment">//第五步：发送ARP数据包</span></span><br><span class="line"> num = sendto(fd , &amp;arp_pk , <span class="keyword">sizeof</span>(struct ARP_PACKET) , <span class="number">0</span> ,(struct sockaddr*)(&amp;eth_info),<span class="keyword">sizeof</span>(eth_info));</span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sendto failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">        <span class="comment">//第六步：接受ARP应答</span></span><br><span class="line"> num = recvfrom(fd , &amp;arp_pk , <span class="keyword">sizeof</span>(struct ARP_PACKET) ,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"rcvfrom failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"I receive %d bytes!\n"</span>,num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the mac  is:"</span>);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%4X "</span>,arp_pk.from_mac[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"op:%d\n"</span>,arp_pk.op);</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d. "</span>,arp_pk.to_ip[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="keyword">char</span> *name ,  <span class="keyword">char</span> *MAC_addr , struct in_addr * IP_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span>  <span class="title">eth</span>;</span>  <span class="comment">//够结构用于存放最初多获取的接口信息</span></span><br><span class="line"><span class="comment">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class="line">   <span class="keyword">int</span> fd;             <span class="comment">//用于创建套接字</span></span><br><span class="line"> <span class="keyword">int</span> temp=<span class="number">0</span>;         <span class="comment">//用于验证接口调用</span></span><br><span class="line"> <span class="keyword">int</span> i=<span class="number">0</span>;            <span class="comment">//用于循环</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">strncpy</span>(eth.ifr_name,name,<span class="keyword">sizeof</span>(struct ifreq)<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class="line"> <span class="comment">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class="line">    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"socket failed!\n"</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class="line">   temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class="line"> <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="built_in">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class="number">6</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"The MAC_addr is:"</span>);</span><br><span class="line"> <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%4X"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class="line">   temp = ioctl(fd,SIOCGIFADDR,&amp;eth);</span><br><span class="line"> <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="built_in">memcpy</span>(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class="number">4</span>);</span><br><span class="line"> <span class="comment">//关闭套接口</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"got ipaddr:%s\n"</span>,inet_ntoa(*IP_addr));</span><br><span class="line"><span class="comment">/*i=0;</span></span><br><span class="line"><span class="comment">printf("get the MAC_ADDR:\n");</span></span><br><span class="line"><span class="comment">for(i;i&lt;6;i++)</span></span><br><span class="line"><span class="comment">  printf("%.2X:",MAC_addr[i]&amp;0xFF);*/</span></span><br><span class="line">   close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步填充arp数据包的时候，填充的数据和类型根据需要进行。</span></span><br><span class="line"><span class="comment">//这里的arp数据包结构体是自己定义的，也可以是利用linux的相关结构：</span></span><br><span class="line"><span class="comment">/*eg:</span></span><br><span class="line"><span class="comment">typedef struct _tagARP_PACKET&#123;    </span></span><br><span class="line"><span class="comment">    struct ether_header  eh;    ///net/ethernet.h</span></span><br><span class="line"><span class="comment">    struct ether_arp arp;    </span></span><br><span class="line"><span class="comment">&#125;ARP_PACKET_OBJ, *ARP_PACKET_HANDLE; /netinet/if_ether.h;/net/if_arp.h</span></span><br><span class="line"><span class="comment">各个字段的填充见头文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三步：填充sockaddr_ll eth_info结构,关键是填充网络接口索引值，最直接的方法是上面的函数，</span></span><br><span class="line"><span class="comment">还有另外的方法:利用ioctl函数获取struct ifreq结构的信息，该结构放置了很多网络接口的相关信息*/</span></span><br><span class="line"><span class="comment">/*  struct sockaddr_ll&#123;</span></span><br><span class="line"><span class="comment">    unsigned short sll_family; //总是 AF_PACKET </span></span><br><span class="line"><span class="comment">    unsigned short sll_protocol; // 物理层的协议 </span></span><br><span class="line"><span class="comment">    int sll_ifindex; //接口号 </span></span><br><span class="line"><span class="comment">    unsigned short sll_hatype; // 报头类型 </span></span><br><span class="line"><span class="comment">    unsigned char sll_pkttype; // 分组类型 </span></span><br><span class="line"><span class="comment">    unsigned char sll_halen; // 地址长度 </span></span><br><span class="line"><span class="comment">    unsigned char sll_addr[8]; // 物理层地址 </span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">eg:</span></span><br><span class="line"><span class="comment">*     struct sockaddr_ll peer_addr;  </span></span><br><span class="line"><span class="comment">*    memset(&amp;peer_addr, 0, sizeof(peer_addr));    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_family = AF_PACKET;    </span></span><br><span class="line"><span class="comment">        struct ifreq req;  </span></span><br><span class="line"><span class="comment">    bzero(&amp;req, sizeof(struct ifreq));  </span></span><br><span class="line"><span class="comment">        strcpy(req.ifr_name, "eth0");    </span></span><br><span class="line"><span class="comment">        if(ioctl(sockfd, SIOCGIFINDEX, &amp;req) != 0)  </span></span><br><span class="line"><span class="comment">        perror("ioctl()");    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_ifindex = req.ifr_ifindex;    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_protocol = htons(ETH_P_ARP);  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*第四步，创建套结字的时候，有以下的组合：更多见：man packet</span></span><br><span class="line"><span class="comment"> * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</span></span><br><span class="line"><span class="comment"> * 第二个参数： 2）套接字类型：</span></span><br><span class="line"><span class="comment">          SOCK_DGRAM----以太网头已经构造好了</span></span><br><span class="line"><span class="comment">          SOCK_RAW------自己构造以太头 </span></span><br><span class="line"><span class="comment">          * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字</span></span><br><span class="line"><span class="comment">          * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），</span></span><br><span class="line"><span class="comment">          * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，</span></span><br><span class="line"><span class="comment">          * 而发送时也无须用户添加头部字段。</span></span><br><span class="line"><span class="comment">   第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP</span></span><br><span class="line"><span class="comment">   * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：</span></span><br><span class="line"><span class="comment">   1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)</span></span><br><span class="line"><span class="comment">  和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)</span></span><br><span class="line"><span class="comment">    2)IEEE维护的注册以太网类型列表</span></span><br><span class="line"><span class="comment">     3）半官方的列表由IANA维护</span></span><br><span class="line"><span class="comment">      ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。</span></span><br><span class="line"><span class="comment">      0x88b5和0x88b6是保留以太网类型，供实验或私人使用。 </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">   <span class="comment">/*第五步发送和接收套接字的函数可以是read write操作套结字，也可以是上文的UDP无连接用的函数*/</span></span><br></pre></td></tr></table></figure><p>处理的时候可能需要获取网关的ip地址：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*proc方法获取网关地址*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetGateWayIP</span><span class="params">(uint8 *ip_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> inf[<span class="number">100</span>];</span><br><span class="line">      FILE *file_fd;</span><br><span class="line">      uint8 high=<span class="number">0</span>,low=<span class="number">0</span>,value;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      file_fd = fopen(<span class="string">"/proc/net/route"</span>,<span class="string">"r"</span>);</span><br><span class="line">      <span class="keyword">if</span>(file_fd==<span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"can not open /proc/net/route\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">             <span class="keyword">while</span>(!feof(file_fd))</span><br><span class="line">             &#123;</span><br><span class="line">                     <span class="built_in">memset</span>(inf,<span class="number">0</span>,<span class="keyword">sizeof</span>(inf));</span><br><span class="line">                     fgets(inf,<span class="number">100</span>,file_fd);</span><br><span class="line">                     <span class="keyword">if</span>(inf[<span class="number">5</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">6</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">7</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">8</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">9</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">10</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">11</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">12</span>]==<span class="string">'0'</span>)</span><br><span class="line">                     &#123;</span><br><span class="line">                              <span class="keyword">for</span>(i=<span class="number">20</span>;i&gt;=<span class="number">14</span>;i-=<span class="number">2</span>)</span><br><span class="line">                              &#123;</span><br><span class="line">                                         <span class="keyword">if</span>(inf[i]&gt;=<span class="number">65</span>)</span><br><span class="line">                                                 high = inf[i]<span class="number">-55</span>;</span><br><span class="line">                                         <span class="keyword">else</span></span><br><span class="line">                                                 high = inf[i]<span class="number">-48</span>;</span><br><span class="line">                                         <span class="keyword">if</span>(inf[i+<span class="number">1</span>]&gt;=<span class="number">65</span>)</span><br><span class="line">                                                 low = inf[i+<span class="number">1</span>]<span class="number">-55</span>;</span><br><span class="line">                                         <span class="keyword">else</span></span><br><span class="line">                                                 low = inf[i+<span class="number">1</span>]<span class="number">-48</span>;</span><br><span class="line">                                        value = high*<span class="number">16</span>+low;</span><br><span class="line">                                       ip_addr[<span class="number">10</span>-i/<span class="number">2</span>] = value;</span><br><span class="line">                              &#125;</span><br><span class="line">                              <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h4><ul><li>ARP包可以直接发送给对端不经过路由器，有趣<br>在一个局域网中，客户端的几乎所有的包都是发往路由器的，这归结于默认路由设置，而在无线网，网卡其实可以接收所有数据，毕竟空气介质，所以，局域网中的设备可以直接通信<br>实验：在文件全能王中开启wifi文件传输，和它在同一个局域网的sta能访问该地址，抓包，发现目的地址和源地址都为同一个局域网的不同ip,且不为路由器网关ip，证明其两个设备是可以直接通信的</li><li>再来做一个实验：通过pf_packet<br>1、在电脑A上写一个程序，mac目的地址为B,源地址为A,协议类型随机，数据随意，发送给B<br> 同时在B端进行接收，过滤掉其他mac地址，看是否可以接收到，在连接ap和不连接ap的条件下<br>2、在A和B设置静态ip地址，且不同网段，都不连接AP ,让A向B 发送ARP请求包，B接收到后回复arp响应包，接着做ping或其他操作，看是否能互相通信</li><li>编程可以参考上述程序，改一下地址什么的就可以，或者参考其他：<br><a href="http://www.freebuf.com/articles/system/5157.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/system/5157.html</a><br>这篇文章讲的很具体，个人也喜欢这个网站，emm,实验过了，还可以，can also make your own program,具体程序不贴了  </li><li>arp欺骗的基本原理：<br>在局域网中，设备A,B连接同一个路由器，他们之间可以直接相互通信，因此可以直接向对方发送arp包；<br>设备A ,B都会定期和AP交互arp请求和回复，相互知道对方的mac地址，这样，就能给ap发送请求，ap也能知道回复给谁；<br>arp欺骗的基本原理在于，如B是攻击方，则B向A发送ARP回复自己是AP ,即在ARP回复包中带上自己的mac地址，ap的ip地址；<br>同时向AP回复自己是A，即带上A的ip地址，自己的mac地址；<br>这样A就会以为B是AP，就会把请求发给B ,同时AP以为B是A，会把回复传给B,但是同时得配置B的转发功能，<br>echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardroot<br>该博文中有一处错误，见评论</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ARP-协议&quot;&gt;&lt;a href=&quot;#ARP-协议&quot; class=&quot;headerlink&quot; title=&quot;ARP 协议&quot;&gt;&lt;/a&gt;ARP 协议&lt;/h3&gt;&lt;h4 id=&quot;ARP协议的作用&quot;&gt;&lt;a href=&quot;#ARP协议的作用&quot; class=&quot;headerlink&quot; title=&quot;ARP协议的作用&quot;&gt;&lt;/a&gt;ARP协议的作用&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信；&lt;/li&gt;
&lt;li&gt;在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：&lt;br&gt;端设备手机pc等–&amp;gt;(交换机)路由器—&amp;gt;下一个路由器—&amp;gt;下一个终端设备
    
    </summary>
    
      <category term="tcpip" scheme="http://xdksx.github.io/categories/tcpip/"/>
    
    
      <category term="tcpip_mac" scheme="http://xdksx.github.io/tags/tcpip-mac/"/>
    
  </entry>
  
  <entry>
    <title>tcpip_PF_PACKET</title>
    <link href="http://xdksx.github.io/2018/05/27/tcpip-PF-PACKET/"/>
    <id>http://xdksx.github.io/2018/05/27/tcpip-PF-PACKET/</id>
    <published>2018-05-27T12:28:40.000Z</published>
    <updated>2018-05-27T20:37:03.654Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/05/27/tcpip-PF-PACKET/pf_packet.jpg" title="it just picture"><h3 id="PF-PACKET的使用："><a href="#PF-PACKET的使用：" class="headerlink" title="PF_PACKET的使用："></a>PF_PACKET的使用：</h3><h3 id="PF-PACKET简介："><a href="#PF-PACKET简介：" class="headerlink" title="PF_PACKET简介："></a>PF_PACKET简介：</h3><p>是linux下的用于发送和接收二层(mac层)的套接字：<br><a id="more"></a></p><h3 id="PF-PACKET基本使用："><a href="#PF-PACKET基本使用：" class="headerlink" title="PF_PACKET基本使用："></a>PF_PACKET基本使用：</h3><ul><li>基本的几个操作：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取硬件网卡的相应信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="keyword">char</span> *name ,  <span class="keyword">char</span> *MAC_addr , struct in_addr * IP_addr)</span><span class="comment">//传入接口名，取回mac和ip</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span>  <span class="title">eth</span>;</span>  <span class="comment">//结构用于存放最初获取的接口信息</span></span><br><span class="line">   <span class="comment">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class="line">   <span class="keyword">int</span> fd;             <span class="comment">//用于创建套接字</span></span><br><span class="line">   <span class="keyword">int</span> temp=<span class="number">0</span>;         <span class="comment">//用于验证接口调用</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;            <span class="comment">//用于循环</span></span><br><span class="line">   <span class="built_in">strncpy</span>(eth.ifr_name,name,<span class="keyword">sizeof</span>(struct ifreq)<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class="line">  <span class="comment">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class="line">    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"socket failed!\n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class="line">     temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class="line">     <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="built_in">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class="number">6</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"The MAC_addr is:"</span>);</span><br><span class="line">      <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%4X"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class="line">      temp = ioctl(fd,SIOCGIFADDR,&amp;eth);</span><br><span class="line">      <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class="number">4</span>);</span><br><span class="line">      <span class="comment">//关闭套接口</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"got ipaddr:%s\n"</span>,inet_ntoa(*IP_addr)); </span><br><span class="line">      close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取得网络接口的索引：int值,传入fd和接口名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_IfaceIndex</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* interfaceName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"><span class="keyword">if</span> (interfaceName == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line"><span class="built_in">strcpy</span>(ifr.ifr_name, interfaceName);</span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, SIOCGIFINDEX, &amp;ifr) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"RED ioctl error\n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ifr.ifr_ifindex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_Iface_promisc</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> dev_id)</span><span class="comment">//传入fd和index</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_mreq</span> <span class="title">mr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;mr,<span class="number">0</span>,<span class="keyword">sizeof</span>(mr));</span><br><span class="line">mr.mr_ifindex = dev_id;</span><br><span class="line">mr.mr_type = PACKET_MR_PROMISC;</span><br><span class="line"><span class="keyword">if</span>(setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&amp;mr,<span class="keyword">sizeof</span>(mr))==<span class="number">-1</span>)<span class="comment">//退出混杂模式使用这个：PACKET_DROP_MEMBERSHIP</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"GREEN set promisc failed! \n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> MAC_ADDR[<span class="number">6</span>];</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">IP_ADDR</span>;</span><span class="comment">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class="line"> <span class="comment">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class="line">    GetEthInfor(<span class="string">"wlp2s0"</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">     fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP));</span><br><span class="line">    <span class="keyword">int</span> index=Get_IfaceIndex(fd,<span class="string">"enp1s0"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"index:%d\n"</span>,index);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="PF-PACKET的接收："><a href="#PF-PACKET的接收：" class="headerlink" title="PF_PACKET的接收："></a>PF_PACKET的接收：</h3><p>简单说明：<br>创建套结字的时候，有以下的组合：更多见：man packet</p><ul><li>利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</li><li>第二个参数： 套接字类型：<pre><code>SOCK_DGRAM----以太网头已经构造好了SOCK_RAW------自己构造以太头 * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字* 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），* 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，* 而发送时也无须用户添加头部字段。</code></pre></li></ul><ul><li>第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP<ul><li>以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：<br>1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)<br>和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)<br>2)  IEEE维护的注册以太网类型列表<br>3）半官方的列表由IANA维护<br> ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。<br> 0x88b5和0x88b6是保留以太网类型，供实验或私人使用。<br>(若指定socket_type为SOCK_RAW则意味着原始数据包包含了链路层头部，若指定为SOCK_DGRAM则将做一些处理以剥掉链路层头部。链路层头部信息的通用格式是一个sockaddr_ll结构。protocol填入网络字节序的IEEE 802.3协议号。参见&lt;linux/if_ether.h&gt;头文件了解允许的协议。如果protocol被设置为htons(ETH_P_ALL)，则意味着接受所有协议。所有接入的协议类型为protocol的数据包将在传递给内核之前传递到PACKET套接字。)</li></ul><ul><li>收包可以使用的接口：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readnum = recvfrom(rawsock, buffer,<span class="number">2048</span>,<span class="number">0</span>, (struct sockaddr*)(&amp;eth_info),&amp;leneth_info);</span><br><span class="line"><span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);</span><br><span class="line"><span class="keyword">int</span> readnum = recvfrom(rawsock, buffer,<span class="number">2048</span>,<span class="number">0</span>, <span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>一个简单的接收包的例子：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_MAX 2048</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: create raw socket!!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf("recv buffer:%s\n",buffer);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>指定从某个接口接收数据：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">eth_info</span>;</span><span class="comment">//结构体的定义在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class="line">  eth_info.sll_family = PF_PACKET;  <span class="comment">//PF_PACKET定义在sys/types.h中</span></span><br><span class="line">  eth_info.sll_ifindex = if_nametoindex(<span class="string">"lo"</span>);<span class="comment">//返回输入的接口名称的索引值　　//次函数定义在net/if.h中</span></span><br><span class="line"> <span class="keyword">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: create raw socket!!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">if</span>(bind(rawsock,(struct sockaddr *)(&amp;eth_info),<span class="keyword">sizeof</span>(eth_info))==<span class="number">-1</span>)<span class="comment">//绑定接口，从而只接收那个接口上的数据</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"error: bind!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf("recv buffer:%s\n",buffer);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>接收后的包如何读取：以包括mac头的形式来看：粗暴的形式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rawsock;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_MAX];</span><br><span class="line">    <span class="keyword">char</span> *ethhead;</span><br><span class="line">    <span class="keyword">char</span> *iphead;</span><br><span class="line">    <span class="keyword">char</span> *tcphead;</span><br><span class="line">    <span class="keyword">char</span> *udphead;</span><br><span class="line">    <span class="keyword">char</span> *icmphead;</span><br><span class="line">    <span class="keyword">char</span> *pHead;</span><br><span class="line"> <span class="keyword">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: create raw socket!!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf("recv buffer:%s\n",buffer);</span></span><br><span class="line">         <span class="keyword">if</span>(readnum &lt; <span class="number">42</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error: Header is incomplete!!!\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//  for(j;j&lt;readnum;j++)</span></span><br><span class="line">      <span class="comment">//     printf("%.2X:",buffer[j]&amp;0xFF);</span></span><br><span class="line">        ethhead = (<span class="keyword">char</span> *)buffer;</span><br><span class="line">        pHead = ethhead;</span><br><span class="line">        <span class="keyword">int</span> ethernetmask = <span class="number">0XFF</span>;</span><br><span class="line">        framecount++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"------------------Analysis   Packet [%d]---------------------\n"</span>,framecount);</span><br><span class="line">       <span class="comment">// printf("all:-----%s\n",ethhead);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"MAC:"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;=<span class="number">11</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2X:"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;=<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2X:"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"proto: %.2x:"</span>,pHead[<span class="number">12</span>]&amp;ethernetmask);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"proto2: %.2x:\n"</span>,pHead[<span class="number">13</span>]&amp;ethernetmask);        </span><br><span class="line">        iphead = ethhead + <span class="number">14</span>;</span><br><span class="line">        pHead = iphead + <span class="number">14</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"IP:"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;=<span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">10</span>; i &lt;=<span class="number">13</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">13</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> prototype = (iphead + <span class="number">9</span>)[<span class="number">0</span>];</span><br><span class="line">     <span class="comment">//   printf("Protocol: %.2X:",prototype);</span></span><br><span class="line">        <span class="comment">//int prototype = (iphead + 9)[0];</span></span><br><span class="line">        pHead = iphead + <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Protocol: "</span>);</span><br><span class="line">        <span class="keyword">switch</span>(prototype)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_ICMP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ICMP\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_IGMP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"IGMP\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_IPIP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"IP\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_TCP :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"TCP | source port: %u | "</span>,(pHead[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">1</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"dest port: %u\n"</span>, (pHead[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">3</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_UDP :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"UDP | source port: %u | "</span>,(pHead[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">1</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"dest port: %u\n"</span>, (pHead[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">3</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_RAW :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"RAW\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Unkown\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-------------------------end-----------------------\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>收包处理的方式，也可以把指针赋给内核的结构：struct iphdr<br>如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> <span class="title">ip</span>;</span></span><br><span class="line">ip = (struct iphdr *)(buffer + <span class="keyword">sizeof</span>(struct ethhdr));</span><br></pre></td></tr></table></figure></p><p>内核提供了很多的包结构，在发包或者收包的时候可以直接使用这些结构解析或者粗暴的用字符串解析</p><h3 id="PF-PACKET发送包："><a href="#PF-PACKET发送包：" class="headerlink" title="PF_PACKET发送包："></a>PF_PACKET发送包：</h3><ul><li>发包和接收包类似：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = sendto(rawsock, buffer,<span class="number">2048</span> , <span class="number">0</span> ,(struct sockaddr*)(&amp;eth_info),<span class="keyword">sizeof</span>(eth_info));</span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sendto failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"success:%d\n"</span>,num);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/05/27/tcpip-PF-PACKET/pf_packet.jpg&quot; title=&quot;it just picture&quot;&gt;
&lt;h3 id=&quot;PF-PACKET的使用：&quot;&gt;&lt;a href=&quot;#PF-PACKET的使用：&quot; class=&quot;headerlink&quot; title=&quot;PF_PACKET的使用：&quot;&gt;&lt;/a&gt;PF_PACKET的使用：&lt;/h3&gt;&lt;h3 id=&quot;PF-PACKET简介：&quot;&gt;&lt;a href=&quot;#PF-PACKET简介：&quot; class=&quot;headerlink&quot; title=&quot;PF_PACKET简介：&quot;&gt;&lt;/a&gt;PF_PACKET简介：&lt;/h3&gt;&lt;p&gt;是linux下的用于发送和接收二层(mac层)的套接字：&lt;br&gt;
    
    </summary>
    
      <category term="tcpip" scheme="http://xdksx.github.io/categories/tcpip/"/>
    
    
      <category term="PF_PACKET" scheme="http://xdksx.github.io/tags/PF-PACKET/"/>
    
  </entry>
  
  <entry>
    <title>DS_linklist</title>
    <link href="http://xdksx.github.io/2018/05/26/DS-linklist/"/>
    <id>http://xdksx.github.io/2018/05/26/DS-linklist/</id>
    <published>2018-05-26T13:18:09.000Z</published>
    <updated>2018-05-26T23:08:24.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构之线性表："><a href="#数据结构之线性表：" class="headerlink" title="数据结构之线性表："></a>数据结构之线性表：</h2><h3 id="有序表：数组："><a href="#有序表：数组：" class="headerlink" title="有序表：数组："></a>有序表：数组：</h3><h3 id="单链表："><a href="#单链表：" class="headerlink" title="单链表："></a>单链表：</h3><p>链表定义  <a id="more"></a><br>{  </p><ul><li>数据成员:常见的基本类型或者对象类型均可  </li><li>数据关系:在链表中的块的成员在连续的内存中，块与块之间内存位置不连续  </li><li>指向块的指针：单链表只有一个next,双链表加上pre  </li></ul><p>}<br>基本运算：<br>{</p><ul><li>InitList(&amp;L);:初始化链表，在c/c++中需要做分配内存，初始化链表头和其值的操作；  </li><li>DestroyList(&amp;L); 在销毁时需要free内存  </li><li>Length(L);链表的长度是块的个数</li><li>GetElem(L,i,&amp;e); 在链表中取元素需要一个一个遍历直到下标值，若为双链表会快些。所以这里取索引值对应的值和取链表的值，效率几乎一样；  </li><li>LocateElem(L,e,compare()); 和链表中的元素做对比</li><li>InsertElem(&amp;L,i,e); 在链表中插入元素，复杂度O(1),在提供位置的时候，若不提供位置，还需要加搜索的时间</li><li>DeleteElem(&amp;L,i,&amp;e); 在链表中删除元素，复杂度O(1)<br>……  </li></ul><p>}<br>eg:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span> </span><br><span class="line">       ElemType data；<span class="comment">//数据域</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>  *<span class="title">next</span>； //指针域</span></span><br><span class="line"><span class="class">&#125; <span class="title">LNode</span>,  *<span class="title">LinkList</span>;</span></span><br><span class="line">LNode  *L;</span><br><span class="line">LinkList  L;</span><br><span class="line">L =  (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">或 L = <span class="keyword">new</span> LNode;</span><br><span class="line">L-&gt;data;</span><br><span class="line">LNode  L;</span><br><span class="line">L.date</span><br></pre></td></tr></table></figure></p><img src="/2018/05/26/DS-linklist/linklist.png" title="链表示意图">    <h3 id="链表的两种头部："><a href="#链表的两种头部：" class="headerlink" title="链表的两种头部："></a>链表的两种头部：</h3><ol><li>没有头的链表：第一个块就开始存储数据  </li><li>任何时候都有头的链表：  第一个块不存储数据，作为头节点，第二个块开始存数据  </li><li>应用：在leetcode中的ReverseLinklist中，当反转的是从1开始的时候，若使用的是没有头的，则需要额外判断处理，否则可以统一处理；  </li></ol><img src="/2018/05/26/DS-linklist/headnode.png" title="头节点示意图">  <h3 id="链表的几个常见操作："><a href="#链表的几个常见操作：" class="headerlink" title="链表的几个常见操作：　"></a>链表的几个常见操作：　</h3><ul><li><p>取第i个元素：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//查找操作</span></span><br><span class="line">    p = L-&gt;next;  </span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; j &lt; i)&#123;</span><br><span class="line">          p = p-&gt;next; </span><br><span class="line">          ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j&gt;i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入元素：在第i个位置上插入    </p><img src="/2018/05/26/DS-linklist/insert.png" title="插入示意图">    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p = L; j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (p &amp;&amp; j &lt; i<span class="number">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class="line">     <span class="keyword">if</span> (!p || j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line">  s =  (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     s-&gt;data = e;  </span><br><span class="line">  s-&gt;next = p-&gt;next;  </span><br><span class="line">  p-&gt;next = s;  </span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>删除元素:删除第i个元素:  </p><img src="/2018/05/26/DS-linklist/delete.png" title="删除示意图">  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> p = L; j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i<span class="number">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class="line">     <span class="keyword">if</span> (!(p-&gt;next) || j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line"> q = p-&gt;next;</span><br><span class="line">     e = q-&gt;data;  </span><br><span class="line"> p-&gt;next = p-&gt;next-&gt;next;  <span class="comment">//(p-&gt;next = q-&gt;next;)</span></span><br><span class="line"> <span class="built_in">free</span>(q);  </span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="链表的建立："><a href="#链表的建立：" class="headerlink" title="链表的建立："></a>链表的建立：</h3><ul><li><p>头插法：  </p><img src="/2018/05/26/DS-linklist/headbuild.png" title="头插法示意图">  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CreateList_L(LinkList &amp;L, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">     L = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span>( i=n; i&gt;<span class="number">0</span>; --i)&#123;</span><br><span class="line">         s = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">         <span class="built_in">scanf</span>( &amp;s-&gt;data);</span><br><span class="line">         s-&gt;next = L-&gt;next; ①</span><br><span class="line">         L-&gt;next = s; ②</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>尾插法：  </p><img src="/2018/05/26/DS-linklist/tailbuile.png" title="尾插法示意图">  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CreateList_L(LinkList &amp;L, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">     tail = L = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span>( i=n; i&gt;<span class="number">0</span>; --i)&#123;</span><br><span class="line">         s = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">         <span class="built_in">scanf</span>( &amp;s-&gt;data);</span><br><span class="line">         tail-&gt;next = s; ①</span><br><span class="line">         tail = s; ②</span><br><span class="line">     &#125;      &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="链表的常见复杂操作："><a href="#链表的常见复杂操作：" class="headerlink" title="链表的常见复杂操作："></a>链表的常见复杂操作：</h3><ul><li>两个有序链表的合并：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa = La-&gt;next; pb = Lb-&gt;next;</span><br><span class="line">    Lc = pc = La;</span><br><span class="line">    <span class="keyword">while</span>( pa &amp;&amp; pb )&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class="line">             pc-&gt;next = pa; pc = pa; pa = pa-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">             pc-&gt;next = pb; pc = pb; pb= pb-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = pa ? pa : pb;</span><br><span class="line">    <span class="built_in">free</span>( Lb );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="一些特殊的链表："><a href="#一些特殊的链表：" class="headerlink" title="一些特殊的链表："></a>一些特殊的链表：</h3><ul><li>单向循环链表：</li><li>图示：  <img src="/2018/05/26/DS-linklist/sigrecyclelink.png" title="单向循环链表"><img src="/2018/05/26/DS-linklist/mergerecycle.png" title="合并"></li><li>多重循环链表：</li><li>双向链表：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">     ElemType               data;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>    *<span class="title">prior</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>    *<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode,  *DuLinkList;</span><br></pre></td></tr></table></figure></li></ul><p>双向循环链表：</p><h3 id="探讨："><a href="#探讨：" class="headerlink" title="探讨："></a>探讨：</h3><ul><li>链表作为最基础的数据结构，是对其他数据结构：如栈，树等的支撑，其他这些大部分是在链表的基础上建立的；  </li><li>从较底层的层面：即深入到内存，链表实现了对零散内存的有效使用，内存在为链表分配空间的时候不用大段的连续空间；</li><li>从较高层，即抽象的层面看，链表仅仅是一批数据的拓扑结构之一，就常见的栈，队列，树，图等等，你还可以想出其他可能有用没用的，如，立体的结构，方块，金字塔形(emm这个像堆），还有随意的，感觉想到了矩阵里面的压缩。   </li></ul><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul><li>链表的应用：如</li><li>在文件中，对大文件的存储，采用类似链表的结构，</li><li>大数相加，像两个100位的整数相加，使用链表，每个块为一位，就可以解决这个问题，数组也行</li><li>倒排索引结构，在操作系统中用到，我的github上放着一个本科毕业设计做的简单搜索引擎，几乎全是自己搞的（解析网页那块自己c写了状态机，觉得效果不如beatifulsoup好，后面用它了),不过想想那会还不会很有意识的去想如果让它运行在大量用户下，各种使用条件（如输入条件下，会怎么样，年轻啊~)</li><li>其他，当然是其他数据结构基于链表做的，多了去了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据结构之线性表：&quot;&gt;&lt;a href=&quot;#数据结构之线性表：&quot; class=&quot;headerlink&quot; title=&quot;数据结构之线性表：&quot;&gt;&lt;/a&gt;数据结构之线性表：&lt;/h2&gt;&lt;h3 id=&quot;有序表：数组：&quot;&gt;&lt;a href=&quot;#有序表：数组：&quot; class=&quot;headerlink&quot; title=&quot;有序表：数组：&quot;&gt;&lt;/a&gt;有序表：数组：&lt;/h3&gt;&lt;h3 id=&quot;单链表：&quot;&gt;&lt;a href=&quot;#单链表：&quot; class=&quot;headerlink&quot; title=&quot;单链表：&quot;&gt;&lt;/a&gt;单链表：&lt;/h3&gt;&lt;p&gt;链表定义
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://xdksx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://xdksx.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>code_efficandreadable</title>
    <link href="http://xdksx.github.io/2018/05/26/code-efficandreadable/"/>
    <id>http://xdksx.github.io/2018/05/26/code-efficandreadable/</id>
    <published>2018-05-26T04:44:19.000Z</published>
    <updated>2018-05-26T22:32:47.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论代码的效率和可读性的权衡"><a href="#论代码的效率和可读性的权衡" class="headerlink" title="论代码的效率和可读性的权衡"></a>论代码的效率和可读性的权衡</h2><h4 id="高效代码可读性差："><a href="#高效代码可读性差：" class="headerlink" title="高效代码可读性差："></a>高效代码可读性差：</h4><p>有一些代码，占用额外内存小，即run in place，且执行的速度快，即复杂度O()低，但是可读性差，即使注释了，修改起来也容易出错，如：<br>对链表的操作：举一个leetcode的例子：(这个例子不是很典型，能说明问题即可）<br>    reverse a linklist from m to n;<br>    1-&gt;3-&gt;4-&gt;5-&gt;null and m,n(ex:2,4);<br>    return 1-&gt;5-&gt;4-&gt;2-&gt;null;<br>   上面例子一开始可以想到，头插法，或者将范围内的那一段用新的处理过的链表替换掉，即只需要处理该片段的头和尾部，当然可能还有其他方法，这里先不考虑；<br>   于是，头插法不是很复杂，但是在这里不用额外的内存时，需要频繁的改变next指针和对pre元素做临时保存，使得代码可读性差，所以可以考虑以下方案：<br>   在替换的内存小时，可以采用后者，让代码可读性高些，方便维护和（被替代~更容易被炒鱿鱼的风险哈哈)<br>   在内存小时，采用前者，爱怎么指怎么指，看不懂不管哈哈哈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;论代码的效率和可读性的权衡&quot;&gt;&lt;a href=&quot;#论代码的效率和可读性的权衡&quot; class=&quot;headerlink&quot; title=&quot;论代码的效率和可读性的权衡&quot;&gt;&lt;/a&gt;论代码的效率和可读性的权衡&lt;/h2&gt;&lt;h4 id=&quot;高效代码可读性差：&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="代码整洁" scheme="http://xdksx.github.io/categories/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81/"/>
    
    
      <category term="代码可读性" scheme="http://xdksx.github.io/tags/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>tcpip_mtu</title>
    <link href="http://xdksx.github.io/2018/05/20/tcpip-mtu/"/>
    <id>http://xdksx.github.io/2018/05/20/tcpip-mtu/</id>
    <published>2018-05-20T14:27:55.000Z</published>
    <updated>2018-05-20T22:40:11.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍：</p><h3 id="理论部分："><a href="#理论部分：" class="headerlink" title="理论部分："></a>理论部分：</h3><h4 id="１、MTU-Maximum-Transmission-Unit-如何定义"><a href="#１、MTU-Maximum-Transmission-Unit-如何定义" class="headerlink" title="１、MTU(Maximum Transmission Unit)如何定义:"></a>１、MTU(Maximum Transmission Unit)如何定义:</h4><ul><li>指的是通信协议中的某一层上面所能通过的最大数据包大小</li><li>这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？  <a id="more"></a><br>　答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B&gt;1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:<br>分片：ip净载荷：MTU-IP头：1500-20=1480;<br> 3008B 需要分为3片，3008=1480,1480,48<br>总结：MTU就是MAC承载的载荷的最大值  </li></ul><h4 id="2、MTU会影响什么"><a href="#2、MTU会影响什么" class="headerlink" title="2、MTU会影响什么:"></a>2、MTU会影响什么:</h4><ul><li>数据包太大-&gt;分片重组-&gt;网络性能变差  </li><li>数据包太小-&gt;一次能传输的数据小-&gt;网速差  </li><li>路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191)　　</li></ul><h4 id="3、如何知道这个值呢？"><a href="#3、如何知道这个值呢？" class="headerlink" title="3、如何知道这个值呢？"></a>3、如何知道这个值呢？</h4><p>路径最大传输单元发现方法(RFC1191)　　</p><ul><li>越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。  </li><li>MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：<br>ping -c 3 -s 1474 -M do 192.168.0.1<br>PING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.<br>ping: local error: Message too long, mtu=1500<br>提示错误即消息太大且未设置分片</li></ul><h4 id="4-MTU大小的来源"><a href="#4-MTU大小的来源" class="headerlink" title="4 MTU大小的来源:"></a>4 MTU大小的来源:</h4><p>ref <a href="https://www.zhihu.com/question/31460305/answer/183766816" target="_blank" rel="noopener">https://www.zhihu.com/question/31460305/answer/183766816</a><br>以太网传输帧的最小值：    </p><ul><li>最早的以太网工作方式：载波多路复用/冲突检测（CSMA/D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。</li><li>假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。  </li></ul><p>为什么标准以太网帧长度上限为1518字节?  </p><ul><li>IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。</li><li>由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 byte那有效传输效率= 160 / 218 = 73%而如果以太网长度为1518，那有效传输效率= 1460 / 1518 = 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题.</li><li>于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。</li></ul><p>其他疑问：  </p><ul><li>最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？</li><li>这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到&gt; 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。</li><li>有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度&gt;接口MTU，怎么办？<br>丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。</li><li>所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？</li><li>我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU = MRU，但比如9000侧的数据到达1500，由于9000 &gt; MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样<h3 id="实践部分："><a href="#实践部分：" class="headerlink" title="实践部分："></a>实践部分：</h3>如何设置MTU：<br>ifconfig eth0 mtu 1460<br>如何查看mtu:<br>netstat -i</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MTU&quot;&gt;&lt;a href=&quot;#MTU&quot; class=&quot;headerlink&quot; title=&quot;MTU&quot;&gt;&lt;/a&gt;MTU&lt;/h1&gt;&lt;p&gt;这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍：&lt;/p&gt;
&lt;h3 id=&quot;理论部分：&quot;&gt;&lt;a href=&quot;#理论部分：&quot; class=&quot;headerlink&quot; title=&quot;理论部分：&quot;&gt;&lt;/a&gt;理论部分：&lt;/h3&gt;&lt;h4 id=&quot;１、MTU-Maximum-Transmission-Unit-如何定义&quot;&gt;&lt;a href=&quot;#１、MTU-Maximum-Transmission-Unit-如何定义&quot; class=&quot;headerlink&quot; title=&quot;１、MTU(Maximum Transmission Unit)如何定义:&quot;&gt;&lt;/a&gt;１、MTU(Maximum Transmission Unit)如何定义:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;指的是通信协议中的某一层上面所能通过的最大数据包大小&lt;/li&gt;
&lt;li&gt;这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？
    
    </summary>
    
      <category term="tcpip" scheme="http://xdksx.github.io/categories/tcpip/"/>
    
    
      <category term="tcpip_mac" scheme="http://xdksx.github.io/tags/tcpip-mac/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://xdksx.github.io/2018/05/20/hello-world/"/>
    <id>http://xdksx.github.io/2018/05/20/hello-world/</id>
    <published>2018-05-20T12:26:14.469Z</published>
    <updated>2018-05-19T23:06:46.437Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cpp_debug_layout_static</title>
    <link href="http://xdksx.github.io/2018/05/20/cpp-debug-layout-static/"/>
    <id>http://xdksx.github.io/2018/05/20/cpp-debug-layout-static/</id>
    <published>2018-05-20T10:54:58.000Z</published>
    <updated>2018-05-20T20:35:59.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-compile-time-memory-layout"><a href="#c-compile-time-memory-layout" class="headerlink" title="c compile time memory layout"></a>c compile time memory layout</h3><p>　　标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法：</p><p>　　概述：首先介绍几个概念：<a id="more"></a><br>　　程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候；<br>　　当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程；<br>      注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码　。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句；</p><p>　　本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c</p><p>前言：<br>一个源代码通过编译后生成一个目标文件.o它是一个elf　relocatable文件,以下.o文件指此类，elf文件为executable文件<br>.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到</p><pre><code>other data  ....comment    offset 0x000000c6..rodata      ...　　　//const &amp; str 常量.data.text.elf header</code></pre><p>一个elf文件的结构是这样的：可以通过readelf来看：<br>    　　　　　　　　elfheader　　　　　　　　文件头包含了平台信息：/usr/include/elf.h<br>            .text　　　　　　　　　　　　段表　各个段：应用程序也可以自己定义段，和指定变量在哪个段<br>            .data<br>            .bss<br>            ..<br>            other sections<br>            section header table　　　　<br>            string tables　　　　　　　　重定位表和字符串表<br>            symbol tables　　　　　　　　 符号表是链接的接口<br> 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂<br> 可以通过readelf -s　xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突<br>  强符号和弱符号（强引用和若引用），调试信息　－g<br> 扩展：<br> １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀；<br> 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B  i386 image.jpg image.o<br>   objdump -ht image.o<br>   可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们<br>   具体看文档<br>２）自定义段：<strong>attribute</strong>((section(“FOO”))) int global=24;<br>           <strong>attribute</strong>((section(“BAR”))) void  foo(){}  既可以把变量或函数放入该段中　段名：BAR FOO</p><p>正文：</p><h4 id="0、先从几个命令："><a href="#0、先从几个命令：" class="headerlink" title="0、先从几个命令："></a>0、先从几个命令：</h4><p>1)size filename:查看elf或.o文件中各个段大小：<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o<br>　　代码段　　　数据段　　<br>代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址<br>数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）<br>bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null</p><p>2)其他工具：<br> readelf -a simplest.o<br> 可以看到更清楚的段信息<br> objdump -t simplest<br> objdump -h simplest.o   替代size可以看到更多信息</p><p>此时显示出来的一些地址并不是装载后的地址</p><p>objdump -s -d xx.o:　　-s 16进制，-d反汇编　　－－－查看代码段<br>objdump -s -x -d xx.o:   –查看数据段和rodata</p><p>3)查看目标文件文件属性如relocatable –.o/executable –elf/share object –.so..<br> file xxx</p><h4 id="１、从最简单的程序开始：simplest-c"><a href="#１、从最简单的程序开始：simplest-c" class="headerlink" title="１、从最简单的程序开始：simplest.c"></a>１、从最简单的程序开始：simplest.c</h4><pre><code>int main(){   return 0;}</code></pre><p>将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件：</p><pre><code># 1 &quot;simplest.c&quot;# 1 &quot;&lt;built-in&gt;&quot;# 1 &quot;&lt;command-line&gt;&quot;# 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4# 1 &quot;&lt;command-line&gt;&quot; 2# 1 &quot;simplest.c&quot;int main() {  return 0; }</code></pre><p>将它进行汇编：gcc -S simplest.c<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p><p>生成.o文件：gcc -c simplest.c<br>并通过file xx.o查看类型<br>simplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</p><p>通过size 查看各个段：<br>size simplest.o:  可以看到只有代码段，数据为空，bss为空，是比较纯净的</p><p>text       data        bss        dec        hex    filename<br>     67          0          0         67         43    simplest.o</p><p>接着编译成elf:gcc -o simplest simplest.c<br>file simplest<br>simplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,<br>interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=<br>56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped<br>可以看到连接器等信息</p><p>size simplest<br>  text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest<br>注意这里的和.o的文件大小和分段不同，</p><h4 id="２、加入头文件和局部变量"><a href="#２、加入头文件和局部变量" class="headerlink" title="２、加入头文件和局部变量"></a>２、加入头文件和局部变量</h4><pre><code>#include&lt;stdio.h&gt;int main(){  int locala;  int localb=3;  return 0;  }</code></pre><p>进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数<br>汇编，可以看到分配３到内存中<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p><p>　　生成.o文件：可以看到未改变data和bss,但是代码段变大<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o</p><p>生成elf:数据区和bss未改变，代码段也未改变？<br> text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest</p><h4 id="３、加入已经初始化的局部静态变量："><a href="#３、加入已经初始化的局部静态变量：" class="headerlink" title="３、加入已经初始化的局部静态变量："></a>３、加入已经初始化的局部静态变量：</h4><pre><code>int main(){ static int statica=3;..}</code></pre><p>看生成的汇编：<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2285, @object　//新加的段<br>        .size    statica.2285, 4<br>    statica.2285:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p><p>.o大小：在静态数据区增加了，４　１个int的长度<br> text       data        bss        dec        hex    filename<br>     74          4          0         78         4e    simplest.o</p><p>elf:有点费解，。。<br> text       data        bss        dec        hex    filename<br>   1099        548          4       1651        673    simplest</p><h4 id="４、加入已经初始化的全局变量和全局静态变量"><a href="#４、加入已经初始化的全局变量和全局静态变量" class="headerlink" title="４、加入已经初始化的全局变量和全局静态变量"></a>４、加入已经初始化的全局变量和全局静态变量</h4><pre><code>int golbala=6;    　static long gs=12;</code></pre><p>生成的汇编<br>        .file    “simplest.c”<br>        .globl    golbala<br>        .data<br>        .align 4<br>        .type    golbala, @object<br>        .size    golbala, 4<br>    golbala://变量名<br>        .long    6<br>        .align 8<br>        .type    gs, @object<br>        .size    gs, 8<br>    gs://变量名<br>        .quad    12<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2287, @object<br>        .size    statica.2287, 4<br>    statica.2287:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p><p>size : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4=20<br>      text       data        bss        dec        hex    filename<br>       74         20          0         94         5e    simplest.o</p><p>elf size:548–&gt;564  16<br>  text       data        bss        dec        hex    filename<br>   1099        564          4       1667        683    simplest</p><h4 id="5-将-int-golbala-6"><a href="#5-将-int-golbala-6" class="headerlink" title="5 将 　　int golbala=6;"></a>5 将 　　int golbala=6;</h4><pre><code>　static long gs=12;　　倒换位置！！！！！！！！！</code></pre><p> 则对齐成：size x.o为：１６比原来小，可以用于节省内存：<br>   text       data        bss        dec        hex    filename<br>     74         16          0         90         5a    simplest.o<br>　　汇编：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2287, @object<br>    .size    statica.2287, 4<br>statica.2287:<br>    .long    3<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits<br>elf文件的也变小：但bss变大，费解。。<br> text       data        bss        dec        hex    filename<br>   1099        560          8       1667        683    simplest</p><h4 id="6、加入未初始化的全局变量和全局与局部静态变量"><a href="#6、加入未初始化的全局变量和全局与局部静态变量" class="headerlink" title="6、加入未初始化的全局变量和全局与局部静态变量"></a>6、加入未初始化的全局变量和全局与局部静态变量</h4><pre><code>  1 #include&lt;stdio.h&gt;    2 static long gs=12;    3 int golbala=6;    4          5         6 static long gsl;    7 int gi;    8 int main()    9 {      10      static int staticn;11      static int statica=3;   12      int locala;   13      int localb=3;   14      return 0;   15 }</code></pre><p>汇编没有看到什么变化：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .local    gsl<br>    .comm    gsl,8,8<br>    .comm    gi,4,4<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2290, @object<br>    .size    statica.2290, 4<br>statica.2290:<br>    .long    3<br>    .local    staticn.2289<br>    .comm    staticn.2289,4,4<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits</p><p>.o文件：+12 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>     74         16         12        102         66    simplest.o</p><p>elf:+16 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>   1099        560         24       1683        693    simplest</p><p>至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同</p><p>参考：程序员的自我修养</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;c-compile-time-memory-layout&quot;&gt;&lt;a href=&quot;#c-compile-time-memory-layout&quot; class=&quot;headerlink&quot; title=&quot;c compile time memory layout&quot;&gt;&lt;/a&gt;c compile time memory layout&lt;/h3&gt;&lt;p&gt;　　标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法：&lt;/p&gt;
&lt;p&gt;　　概述：首先介绍几个概念：
    
    </summary>
    
      <category term="c&amp;cpp" scheme="http://xdksx.github.io/categories/c-cpp/"/>
    
    
      <category term="cpp_memory" scheme="http://xdksx.github.io/tags/cpp-memory/"/>
    
  </entry>
  
  <entry>
    <title>cpp_debug_layout_dynamic</title>
    <link href="http://xdksx.github.io/2018/05/20/cpp-debug-layout-dynamic/"/>
    <id>http://xdksx.github.io/2018/05/20/cpp-debug-layout-dynamic/</id>
    <published>2018-05-20T10:33:09.000Z</published>
    <updated>2018-05-22T00:06:55.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c执行期内存布局和调试："><a href="#c执行期内存布局和调试：" class="headerlink" title="c执行期内存布局和调试："></a>c执行期内存布局和调试：</h3><p>在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等<br>１、将目标文件装入: <a id="more"></a><br><em>１）重定位－－－　放在内存哪里<br> 2)  等待调度执行</em><br>这里可以使用gdb进行调试查看</p><p>一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).<br>一个进程主要包括：<br>   在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等</p><blockquote><p>栈区　　高地址到低地址<br>堆区　　低地址到高地址<br>bss<br>数据<br>代码</p></blockquote><p> 以下将从两个维度进行对一个程序被执行成进程时，内存的情况：<br> １、各种段区的内存分布<br> ２、gdb 调试程序执行时的过程。－－可能涉及到汇编<br> －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p><h4 id="1、gdb-常用的命令和用法："><a href="#1、gdb-常用的命令和用法：" class="headerlink" title="1、gdb　常用的命令和用法："></a>1、gdb　常用的命令和用法：</h4><p>1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令<br> 2)设置断点：　<br>b 行号<br>b 函数名<br>b 行号　if 条件<br>eg:<br>break main  /  b main<br>  删除断点:delete 行号</p><p>3)列出代码<br>l /list</p><p>4)运行，start<br>  跳转到断点:c/continue   r/run<br>  until  行号　　　运行直到该行<br>5)观察变量b和地址<br>watch b  若变量值发生变化，则程序停止</p><p>　p/print  b  看变量值<br>　p/print &amp;b　看变量地址<br> i  locals</p><p> info registers 显示所有寄存器的值<br> 查看特定内存位置的值如：<br> print/x $eax   显示为16进制<br> print/t  2进制，　<br> print/d 十进制,<br>x/nyz  : n表示字段数，y为输出格式，z是字段长度</p><p>６）单步调试<br> n/next   /   s/step　</p><p> 7) 保存断点：<br> info b  查看断点信息<br> save breakpoint fig.dp 保存断点<br> 读取断点文件：　gdb hello -x fig.dp</p><p> 退出quit</p><p> <a href="http://bbs.chinaunix.net/thread-150524-1-1.html" target="_blank" rel="noopener">http://bbs.chinaunix.net/thread-150524-1-1.html</a></p><h4 id="2-使用kdbg"><a href="#2-使用kdbg" class="headerlink" title="2 使用kdbg"></a>2 使用kdbg</h4><p> 界面版本gdb  在gcc … -g后，用kdbg打开即可、<br> 查看程序运行时各个地址：<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHW_ADR(ID,I) printf(<span class="meta-string">"the id %s \t is at adr:%8X\n"</span>,ID,&amp;I);</span></span><br><span class="line"><span class="keyword">extern</span> etext,edata,end;</span><br><span class="line"><span class="keyword">char</span> *cptr=<span class="string">"Hello World\n"</span>;</span><br><span class="line"><span class="keyword">char</span> buffer1[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showit</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Adr etext:%8x\tAdr edata:%8x \t Adr end :%8x \n\n"</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class="line">SHW_ADR(<span class="string">"main"</span>,main);</span><br><span class="line">SHW_ADR(<span class="string">"showit"</span>,showit);</span><br><span class="line">SHW_ADR(<span class="string">"cptr"</span>,cptr);</span><br><span class="line">SHW_ADR(<span class="string">"buffer1"</span>,buffer1);</span><br><span class="line">SHW_ADR(<span class="string">"i"</span>,i);</span><br><span class="line"><span class="built_in">strcpy</span>(buffer1,<span class="string">"A demonstration\n"</span>);</span><br><span class="line">write(<span class="number">1</span>,buffer1,<span class="built_in">strlen</span>(buffer1)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">1</span>;++i)</span><br><span class="line">showit(cptr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showit</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *buffer2;</span><br><span class="line">SHW_ADR(<span class="string">"buffer2"</span>,buffer2);</span><br><span class="line"><span class="keyword">if</span>((buffer2=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>((<span class="keyword">unsigned</span>)(<span class="built_in">strlen</span>(p)+<span class="number">1</span>)))!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buffer2,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,buffer2);</span><br><span class="line"><span class="built_in">free</span>(buffer2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Allocation error.\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;alloca.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">afunc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> etext,edata,end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bss_var;<span class="comment">//no init globel data must be in bss</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data_var=<span class="number">42</span>;<span class="comment">//init globel data must be in data</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHW_ADR(ID,I) printf(<span class="meta-string">"the %8s\t is at adr:%8x\n"</span>,ID,&amp;I);<span class="comment">//the macro to printf the addr</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p,*b,*nb;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Adr etext:%8x\t Adr edata %8x\t Adr end %8x\t\n"</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\ntext Location:\n"</span>);</span><br><span class="line">SHW_ADR(<span class="string">"main"</span>,main);<span class="comment">//text section function</span></span><br><span class="line">SHW_ADR(<span class="string">"afunc"</span>,afunc);<span class="comment">//text section function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nbss Location:\n"</span>);</span><br><span class="line">SHW_ADR(<span class="string">"bss_var"</span>,bss_var);<span class="comment">//bss section var</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\ndata location:\n"</span>);</span><br><span class="line">SHW_ADR(<span class="string">"data_var"</span>,data_var);<span class="comment">//data section var</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nStack Locations:\n"</span>);</span><br><span class="line">afunc();</span><br><span class="line"></span><br><span class="line">p=(<span class="keyword">char</span> *)alloca(<span class="number">32</span>);<span class="comment">//alloc memory from statck</span></span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">SHW_ADR(<span class="string">"start"</span>,p);</span><br><span class="line">SHW_ADR(<span class="string">"end"</span>,p+<span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">32</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//malloc memory from heap</span></span><br><span class="line">nb=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">16</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nHeap Locations:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the Heap start: %p\n"</span>,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the Heap end:%p\n"</span>,(nb+<span class="number">16</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nb and nb in Stack\n"</span>);</span><br><span class="line">SHW_ADR(<span class="string">"b"</span>,b);</span><br><span class="line">SHW_ADR(<span class="string">"nb"</span>,nb);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(nb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afunc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">long</span> level=<span class="number">0</span>;<span class="comment">//data section static var</span></span><br><span class="line"><span class="keyword">int</span> stack_var;<span class="comment">//temp var ,in stack section</span></span><br><span class="line"><span class="keyword">if</span>(++level==<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">SHW_ADR(<span class="string">"stack_var in stack section"</span>,stack_var);</span><br><span class="line">SHW_ADR(<span class="string">"Level in data section"</span>,level);</span><br><span class="line">afunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;c执行期内存布局和调试：&quot;&gt;&lt;a href=&quot;#c执行期内存布局和调试：&quot; class=&quot;headerlink&quot; title=&quot;c执行期内存布局和调试：&quot;&gt;&lt;/a&gt;c执行期内存布局和调试：&lt;/h3&gt;&lt;p&gt;在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等&lt;br&gt;１、将目标文件装入:
    
    </summary>
    
      <category term="c&amp;cpp" scheme="http://xdksx.github.io/categories/c-cpp/"/>
    
    
      <category term="cpp_memory" scheme="http://xdksx.github.io/tags/cpp-memory/"/>
    
  </entry>
  
  <entry>
    <title>android_jni</title>
    <link href="http://xdksx.github.io/2018/05/20/android-jni/"/>
    <id>http://xdksx.github.io/2018/05/20/android-jni/</id>
    <published>2018-05-20T09:53:27.000Z</published>
    <updated>2018-05-20T20:37:59.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="a-example-of-JNI-static-way"><a href="#a-example-of-JNI-static-way" class="headerlink" title="a example of JNI static way:"></a>a example of JNI static way:</h3><h4 id="first-step-write-a-middle-java-file"><a href="#first-step-write-a-middle-java-file" class="headerlink" title="first step: write a middle java file:"></a>first step: write a middle java file:</h4><p>mkdir jni<br>cd jni/<a id="more"></a><br>vim TestJni.java</p><pre><code>import java.util.*;public class TestJni{    public native void xprint(String content);    static    {        System.loadLibrary(&quot;TestJni&quot;);    }}</code></pre><p>  javac TestJni.java  and make a class</p><p>then<br>  javah -jni TestJni  to make a .h file:</p><pre><code>  /* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class TestJni */#ifndef _Included_TestJni#define _Included_TestJni#ifdef __cplusplusextern &quot;C&quot; {#endif/* * Class:     TestJni * Method:    xprint * Signature: (Ljava/lang/String;)V */JNIEXPORT void JNICALL Java_TestJni_xprint  (JNIEnv *, jobject, jstring);#ifdef __cplusplus}#endif#endif</code></pre><h4 id="step-two-write-jni-file-c"><a href="#step-two-write-jni-file-c" class="headerlink" title="step two write jni file.c:"></a>step two write jni file.c:</h4><p>TestJni.c:</p><pre><code>#include&lt;jni.h&gt;#include&lt;stdio.h&gt;#include &quot;TestJni.h&quot;JNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content){    const jbyte *str=(const jbyte*)(*env)-&gt;GetStringUTFChars(env,content,JNI_FALSE);    printf(&quot;hello--wo%s \n&quot;,str);    (*env)-&gt;ReleaseStringUTFChars(env,content,(const char*)str);    return;}</code></pre><h4 id="three-build-so-lib"><a href="#three-build-so-lib" class="headerlink" title="three build .so lib"></a>three build .so lib</h4><pre><code>cc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c</code></pre><h4 id="four-write-a-test-hellow-java"><a href="#four-write-a-test-hellow-java" class="headerlink" title="four write a test:hellow.java"></a>four write a test:hellow.java</h4><pre><code>import java.util.*;public class hellow{    public static void main(String argc[])    {         new hellow();    }    public hellow()    {        new TestJni().xprint(&quot;hi my name is keee&quot;);    }}</code></pre><h4 id="question"><a href="#question" class="headerlink" title="question:"></a>question:</h4><p>如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径：</p><p>java -Djava.library.path=’.’ HelloWorld<br>或者输入命令：<br>export LD_LIBRARY_PATH=“HelloWorld路径”:$LD_LIBRARY_PATH   设置环境变量</p><p>然后再 java HelloWorld 一样OK</p><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html" target="_blank" rel="noopener">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br><a href="http://www.cnblogs.com/wzben/p/5733571.html" target="_blank" rel="noopener">http://www.cnblogs.com/wzben/p/5733571.html</a></p><h3 id="a-example-of-JNI-dynamic-way"><a href="#a-example-of-JNI-dynamic-way" class="headerlink" title="a example of JNI dynamic way:"></a>a example of JNI dynamic way:</h3><h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1:"></a>step 1:</h4><p>write a TestJni.java</p><pre><code>public class SimpleJni{    static {        System.out.println(&quot;[java] static code block,start load shared library...&quot;);        System.loadLibrary(&quot;SimpleJni&quot;);        System.out.println(&quot;[java]load library end...&quot;);    }    static native int add(int a,int b);    public static void main(String args[])    {        System.out.println(&quot;[java] in main...&quot;);        System.out.println(&quot;[java] 3+4=&quot;+SimpleJni.add(3,4));        System.out.println(&quot;end...&quot;);    }}</code></pre><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2:"></a>step 2:</h4><p>write a Jni file:</p><pre><code>#include &lt;jni.h&gt;#include&lt;stdio.h&gt;const char *classPathName=&quot;com/bt/jni/SimpleJni&quot;;jint myadd(JNIEnv *env,jobject thiz,jint a,jint b){    return a+b;}static JNINativeMethod methods[]={    {&quot;add&quot;,&quot;(II)I&quot;,(void*)myadd},};int registerNatives(JNIEnv *env){    jclass clazz;    clazz=(*env)-&gt;FindClass(env,classPathName);    if(NULL==clazz){       printf(&quot;[C] FindClass fail\n&quot;);       goto failed;    }     if (0&gt;(*env)-&gt;RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0]))){         printf(&quot;RegisterNatives fail.\n&quot;);         goto failed;     }     return JNI_TRUE;failed:     return JNI_FALSE;}jint JNI_OnLoad(JavaVM *vm,void *reserved){    JNIEnv *env=NULL;    jint result=-1;    void **env_p=NULL;    printf(&quot;start register native func\n&quot;);    env_p=(void**)&amp;env;    if(JNI_OK!=(*vm)-&gt;GetEnv(vm,env_p,0x00010006)){        printf(&quot;get env failed..\n&quot;);        goto err;    }    if(JNI_TRUE!=registerNatives(env)){        printf(&quot;register fail...exit....\n&quot;);        goto err;    }    result=0x00010006;err:    return result;}</code></pre><h4 id="step-use"><a href="#step-use" class="headerlink" title="step use:"></a>step use:</h4><p>1.首先编写SimpleJni.java和simpel_jni.c<br>    2.编译java和c文件<br>$ java -d .  SimpleJni.java<br>$gcc -fPIC -I$JAVA_HOME/include/ -I$JAVA_HOME/include/linux/ -o libsimpleJni.so simple_jni.c</p><pre><code>3.执行$java -Djava.library.path=. com.bt.jni.SimpleJni</code></pre><h4 id="other-example"><a href="#other-example" class="headerlink" title="other example:"></a>other example:</h4><p>java file:<br>    import java.util.*;<br>    public class TestJni<br>    {<br>        public native void xprint(String content);<br>        static<br>        {<br>            System.loadLibrary(“TestJni”);<br>        }<br>        public native static String native_hello();<br>    }</p><p>JNI file:</p><pre><code>#include&lt;jni.h&gt;#include&lt;stdio.h&gt;//#include &quot;TestJni.h&quot;#include&lt;iostream&gt;using namespace std; void xprint(JNIEnv *env,jobject obj,jstring content){  //    const jbyte *str=(const jbyte*)(env-&gt;GetStringUTFChars(env,content,JNI_FALSE));    //printf(&quot;hello--wo%s \n&quot;,str);//    env-&gt;ReleaseStringUTFChars(env,content,(const char*)str);        cout&lt;&lt;&quot;here:&quot;&lt;&lt;content&lt;&lt;endl;    return;}static jstring  native_hello(JNIEnv *env,jobject object){     return (env)-&gt;NewStringUTF(&quot;keshixi&quot;);}static JNINativeMethod method_table[]={    { &quot;xprint&quot;,&quot;(Ljava/lang/String;)V&quot;,(void*)xprint},    {&quot;native_hello&quot;,&quot;()Ljava/lang/String;&quot;,(void*)native_hello}//    {,,(void*)xprint},{,,(void*)native_hello}}; jint JNI_OnLoad(JavaVM *jvm,void *reserved){    JNIEnv *env;    if(jvm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6)!=JNI_OK){        return -1;    }    jclass clz=env-&gt;FindClass(&quot;TestJni&quot;);    if(clz==NULL)    {        return JNI_FALSE;    }    if(env-&gt;RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK){        return JNI_VERSION_1_6;    }  }</code></pre><p>####reference:<br>jni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行</p><p>动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子</p><p>另外可以作为ndk在android中使用及在android　stdio也可以直接生成so</p><p>一些链接：android_jni_ndk:<a href="http://www.cnblogs.com/wzben/p/5733571.html" target="_blank" rel="noopener">http://www.cnblogs.com/wzben/p/5733571.html</a><br>动态注册无运行实例：<a href="http://www.linuxidc.com/Linux/2017-02/140130.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2017-02/140130.htm</a><br>静态注册：<a href="http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html" target="_blank" rel="noopener">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br>动态注册：有实例<a href="http://www.linuxidc.com/Linux/2017-02/140129.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2017-02/140129.htm</a></p><p><a href="http://www.fer.unizg.hr/_download/repository/jni.pdf文档" target="_blank" rel="noopener">www.fer.unizg.hr/_download/repository/jni.pdf文档</a>    </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;a-example-of-JNI-static-way&quot;&gt;&lt;a href=&quot;#a-example-of-JNI-static-way&quot; class=&quot;headerlink&quot; title=&quot;a example of JNI static way:&quot;&gt;&lt;/a&gt;a example of JNI static way:&lt;/h3&gt;&lt;h4 id=&quot;first-step-write-a-middle-java-file&quot;&gt;&lt;a href=&quot;#first-step-write-a-middle-java-file&quot; class=&quot;headerlink&quot; title=&quot;first step: write a middle java file:&quot;&gt;&lt;/a&gt;first step: write a middle java file:&lt;/h4&gt;&lt;p&gt;mkdir jni&lt;br&gt;cd jni/
    
    </summary>
    
      <category term="android" scheme="http://xdksx.github.io/categories/android/"/>
    
    
      <category term="android_coding" scheme="http://xdksx.github.io/tags/android-coding/"/>
    
  </entry>
  
  <entry>
    <title>android_adb</title>
    <link href="http://xdksx.github.io/2018/05/20/android-adb/"/>
    <id>http://xdksx.github.io/2018/05/20/android-adb/</id>
    <published>2018-05-20T09:50:14.000Z</published>
    <updated>2018-05-20T20:37:16.274Z</updated>
    
    <content type="html"><![CDATA[<h4 id="android-adb-command"><a href="#android-adb-command" class="headerlink" title="android adb command"></a>android adb command</h4><p>从android群英传中学习到额外的几个adb指令，是之前没接触到的：<br>adb list targets<br>adb install -r　xx.apk -r为覆盖<br>adb shell df<br><a id="more"></a><br>adb shell pm list packages -f<br>adb shell input keyevent 3　　－－模拟按键输入，这里为点击home建<br>adb shell touchscreen ..模拟滑动<br>adb shell dumpsys 监听Activity运行状态<br>adb shell screenrecord /sdcard/demo.mp4  录制　屏幕<br>adb shell am start -n 包名/包名＋类名</p><p>更多，见google　develop中android studio的部分<br>另在源码目录中/system/core/toolbox  和/frameworks/base/cmds为所有ADB命令和shell命令来源</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;android-adb-command&quot;&gt;&lt;a href=&quot;#android-adb-command&quot; class=&quot;headerlink&quot; title=&quot;android adb command&quot;&gt;&lt;/a&gt;android adb command&lt;/h4&gt;&lt;p&gt;从android群英传中学习到额外的几个adb指令，是之前没接触到的：&lt;br&gt;adb list targets&lt;br&gt;adb install -r　xx.apk -r为覆盖&lt;br&gt;adb shell df&lt;br&gt;
    
    </summary>
    
      <category term="android" scheme="http://xdksx.github.io/categories/android/"/>
    
    
      <category term="android_make" scheme="http://xdksx.github.io/tags/android-make/"/>
    
  </entry>
  
  <entry>
    <title>android_AndroidManifest</title>
    <link href="http://xdksx.github.io/2018/05/20/android-AndroidManifest/"/>
    <id>http://xdksx.github.io/2018/05/20/android-AndroidManifest/</id>
    <published>2018-05-20T09:46:34.000Z</published>
    <updated>2018-05-20T20:37:33.414Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一个典型的androidmanifest文件："><a href="#一个典型的androidmanifest文件：" class="headerlink" title="一个典型的androidmanifest文件："></a>一个典型的androidmanifest文件：</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.example.ksx.helloworld&quot;&gt;&lt;!-- more --&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;hallo&quot;//app的名字和显示在bar上的文字        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;activity android:name=&quot;.MainActivity&quot;&gt;//活动的注册        &lt;android:label=&quot;this is hallo&quot;&gt;//会覆盖上面的            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;//声明为主活动                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一个典型的androidmanifest文件：&quot;&gt;&lt;a href=&quot;#一个典型的androidmanifest文件：&quot; class=&quot;headerlink&quot; title=&quot;一个典型的androidmanifest文件：&quot;&gt;&lt;/a&gt;一个典型的androidmanif
      
    
    </summary>
    
      <category term="android" scheme="http://xdksx.github.io/categories/android/"/>
    
    
      <category term="android_coding" scheme="http://xdksx.github.io/tags/android-coding/"/>
    
  </entry>
  
  <entry>
    <title>android_makefirst_app</title>
    <link href="http://xdksx.github.io/2018/05/20/android-makefirst-app/"/>
    <id>http://xdksx.github.io/2018/05/20/android-makefirst-app/</id>
    <published>2018-05-20T09:38:24.000Z</published>
    <updated>2018-05-20T20:38:13.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="install-and-make-first-app"><a href="#install-and-make-first-app" class="headerlink" title="install and make first app"></a>install and make first app</h3><p>20170608<br>今天主要是安装了android-studio环境并成功开发第一个helloworld   app 在模拟器和手机上运行，下面是整个教程：在ubuntu下</p><h4 id="1-安装java-jdk"><a href="#1-安装java-jdk" class="headerlink" title="1 安装java-jdk:"></a>1 安装java-jdk:<a id="more"></a></h4><p>a  先下载java-jdk:Java SE Development Kit 8 Downloads<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>下载对应系统的版本</p><p>b  下载到某个目录，解压到要安装的目录：如：/usr/jdk-8/</p><p>c   设置全局环境变量：如上述的安装目录，则将<br>export JAVA_HOME=/usr/jdk-8<br>export JRE_HOME=$JAVA_HOME/jre<br>export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib<br>export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin<br>添加到/etc/profile文件中，在末尾另起一行添加</p><p>d 使用source /etc/profile命令使刚才配置的信息生效</p><p>e 测试是否成功：java -version<br>测试,编写java文件：<br>public class test{<br>    public static void main(String[] args){<br>        System.out.println(“hello world”);<br>    }<br>}<br>保存为test.java，<br>生成字节码：javac test.java<br>运行:java test</p><h3 id="2-安装android-studio"><a href="#2-安装android-studio" class="headerlink" title="2 安装android-studio:"></a>2 安装android-studio:</h3><p>a 下载：在官网或者其他网站下载后<br>b 按照installion说明进行：一般是先选择要安装的目录：如/usr/android-studio<br>c　直接在终端,进入bin目录后:./studio.sh<br>d 还有其他配置．比如在任意目录都能打开软件．<br>e 其他见说明文件等</p><p>3 第一个app helloworld<br>在模拟器上运行<br>打开软件－－&gt;选择新建一个工程，适当选择之后-&gt;选择build-&gt;make project-&gt;点击run–<br>–&gt;会提示选择安装下载模拟器–&gt;选择合适的，最好不要是带锁的<br>－－－&gt;之后会提示成功．再选择建立一个模拟器，之后就可以了</p><p>注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm<br>如果不能运行x86的，可能需要安装kvm:<br>也可以使用genymotion模拟器</p><h4 id="4-安装kvm可选"><a href="#4-安装kvm可选" class="headerlink" title="4 安装kvm可选"></a>4 安装kvm可选</h4><p>要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？<br>那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。<br>首先要确定你的cpu满足要求，下面有几个命令可以参考：</p><p>$ egrep -c ‘(vmx|svm)’ /proc/cpuinfo<br>4</p><p>打印的值不为0即可。</p><p>下面安装kvm：</p><p>$ sudo apt-get install qemu-kvm<br>$ sudo adduser linc kvm<br>$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils<br>$ sudo adduser linc libvirtd</p><p>(linc为用户名，适当改）<br>检验安装是否成功：</p><p>$ sudo virsh -c qemu:///system list</p><h2 id="Id-Name-State"><a href="#Id-Name-State" class="headerlink" title=" Id    Name                           State"></a> Id    Name                           State</h2><p>运行，在有模拟器的目录中：<br>如/home/ksx/Android/Sdk/emulator/emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm</p><p>使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。</p><p>如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。</p><h4 id="5在手机上运行app"><a href="#5在手机上运行app" class="headerlink" title="5在手机上运行app"></a>5在手机上运行app</h4><p>首先连接手机，打开usb调试<br>还是一样，但是选择app那里不是app,而是选择Edit Configurations<br>之后选择usb　device，ok，就可以了，接着运行</p><h4 id="关于项目结构模式："><a href="#关于项目结构模式：" class="headerlink" title="关于项目结构模式："></a>关于项目结构模式：</h4><p>默认为android<br>设置为project可以看到整个完整的目录结构：<br>　　　　　.gradle和.idea 为自动生成<br>　　　　　app<br>　　　　　build   编译时自动生成的文件，不用太关心<br>　　　　　gradle   包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle<br>     .gitignore<br>     build.gradle<br>     gradle.properties  全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本<br>     gradlew　和gradlew.bat在命令行中执行gradle命令<br>     local.properties　　指定本机android sdk路径<br>     setting.gradle指定项目中引入的模块</p><pre><code>app目录下build　　为自动生成，同上lib   项目使用的第三方库test 测试用例proguard-rules.pro  代码混淆规则</code></pre><h4 id="build-gradle-intruduce"><a href="#build-gradle-intruduce" class="headerlink" title="build gradle intruduce"></a>build gradle intruduce</h4><p>gradle  Groovy 领域语言　　DSL    摒弃了Ant 和Maven </p><p>在app 外有一个 build.gradle。在app中有一个build.gradle</p><p>在外面的　gradle 也可以构建c++等项目，<br>buildscript {<br>    repositories {<br>        jcenter()　　　//代码托管仓库　利用它可以轻松引用jcenter开源项目</p><pre><code>}dependencies {    classpath &apos;com.android.tools.build:gradle:2.3.2&apos;　　//声明构建的是android    // NOTE: Do not place your application dependencies here; they belong    // in the individual module build.gradle files}</code></pre><p>}</p><p>allprojects {<br>    repositories {<br>        jcenter()<br>    }<br>}</p><p>task clean(type: Delete) {<br>    delete rootProject.buildDir<br>}</p><p>app中<br>apply plugin: ‘com.android.application’　//表明为android 应用程序模块，为com.android.library表示库模块</p><p>android {　　　//安卓闭包<br>    compileSdkVersion 25　　　　//项目的编译版本，25为API 25,对应android 7.1<br>    buildToolsVersion “25.0.3”   //项目构建工具版本<br>    defaultConfig {<br>        applicationId “org.example.myactivity1”　　　项目包名<br>        minSdkVersion 25　　　　　//项目最低兼容的android系统版本<br>        targetSdkVersion 25　　//表明如22表示只在22测试充分，如不启动运行时权限，android６　的运行时权限就不会加，表明只在5上做充分测试<br>        versionCode 1　　　项目版本编号<br>        versionName “1.0”　　　项目版本名<br>        testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner”<br>    }<br>    buildTypes {//分debug和release版本<br>        release {<br>            minifyEnabled false　//是否混淆代码<br>            proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’//混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件<br>        }<br>    }<br>}</p><p>dependencies {//分本地依赖，库依赖和远程依赖<br>    compile fileTree(dir: ‘libs’, include: [‘*.jar’])　　//本地依赖声明<br>    androidTestCompile(‘com.android.support.test.espresso:espresso-core:2.2.2’, {<br>        exclude group: ‘com.android.support’, module: ‘support-annotations’<br>    })<br>    compile ‘com.android.support:appcompat-v7:25.3.1’　　//　依赖库<br>    compile ‘com.android.support.constraint:constraint-layout:1.0.2’<br>    testCompile ‘junit:junit:4.12’　　//测试用例库<br>}</p><p>其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;install-and-make-first-app&quot;&gt;&lt;a href=&quot;#install-and-make-first-app&quot; class=&quot;headerlink&quot; title=&quot;install and make first app&quot;&gt;&lt;/a&gt;install and make first app&lt;/h3&gt;&lt;p&gt;20170608&lt;br&gt;今天主要是安装了android-studio环境并成功开发第一个helloworld   app 在模拟器和手机上运行，下面是整个教程：在ubuntu下&lt;/p&gt;
&lt;h4 id=&quot;1-安装java-jdk&quot;&gt;&lt;a href=&quot;#1-安装java-jdk&quot; class=&quot;headerlink&quot; title=&quot;1 安装java-jdk:&quot;&gt;&lt;/a&gt;1 安装java-jdk:
    
    </summary>
    
      <category term="android" scheme="http://xdksx.github.io/categories/android/"/>
    
    
      <category term="android_make" scheme="http://xdksx.github.io/tags/android-make/"/>
    
  </entry>
  
  <entry>
    <title>android_howto_makeapk_cmd</title>
    <link href="http://xdksx.github.io/2018/05/20/android-howto-makeapk-cmd/"/>
    <id>http://xdksx.github.io/2018/05/20/android-howto-makeapk-cmd/</id>
    <published>2018-05-20T09:08:46.000Z</published>
    <updated>2018-05-20T20:37:45.354Z</updated>
    
    <content type="html"><![CDATA[<h3 id="how-to-make-a-android-by-cmd"><a href="#how-to-make-a-android-by-cmd" class="headerlink" title="how to make a android by cmd :"></a>how to make a android by cmd :</h3><pre><code>在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni</code></pre><a id="more"></a><h3 id="way-1-方法１"><a href="#way-1-方法１" class="headerlink" title="way 1:方法１"></a>way 1:方法１</h3><h4 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h4><pre><code>android studio 创建了一个工程，然后手动在命令行打包，进入工程里的.  或者direct use andrid create project创建</code></pre><p>cd ~/Desktop/FirstTest/app/src/main<br>mkdir gen<br>mkdir build<br>mkdir out</p><p>在android工程目录下建立Makefile文件，添加如下代码：<br>    SDK=~/Android/Sdk　　　　<br>    BUILD_TOOLS=$(SDK)/build-tools/25.0.3<br>    PLATFORMS=$(SDK)/platforms/android-25<br>    aapt=$(BUILD_TOOLS)/aapt<br>    dx=$(BUILD_TOOLS)/dx<br>    aidl=$(BUILD_TOOLS)/aidl<br>    apkbuilder=$(SDK)/tools/apkbuilder2 //后面不支持apkbuilder所以<br>    adb=$(SDK)/platform-tools/adb</p><h4 id="资源编译，生成-R-java"><a href="#资源编译，生成-R-java" class="headerlink" title="资源编译，生成 R.java"></a>资源编译，生成 R.java</h4><pre><code>aapt_task:    $(aapt) package \    -f \ #如果编译出来的文件已经存在，强制覆盖    -M  AndroidManifest.xml  \ # Mainifest.xml 的路径    -I  $(PLATFORMS)/android.jar \ # 某个版本平台的 android.jar 的路径　#依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...    -S  res/ \ # res 文件夹路径    -J gen/ \ # 生成 R.java 的输出目录    -m  #使得生成的包的目录放在 -J 参数指定的目录</code></pre><h4 id="代码编译，生成-class"><a href="#代码编译，生成-class" class="headerlink" title="代码编译，生成 .class"></a>代码编译，生成 .class</h4><pre><code>javac_task:    javac -source 1.7 -target 1.7 \ # 使用 jdk1.8 编译 1.7 的 .class 文件    -encoding UTF-8 \     -bootclasspath  $(PLATFORMS)/android.jar \ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...    -d build/ \ #指定放置生成的类文件的位置    java/thereisnospon/dextest/*.java \    gen/thereisnospon/dextest/*.java \</code></pre><h4 id="生成-dex"><a href="#生成-dex" class="headerlink" title="生成 .dex"></a>生成 .dex</h4><pre><code>dx_task:    $(dx) --dex --output=build/classes.dex \    build  </code></pre><h4 id="资源文件初始包"><a href="#资源文件初始包" class="headerlink" title="资源文件初始包"></a>资源文件初始包</h4><pre><code>resapk_task:    $(aapt) package -f \    -M  AndroidManifest.xml  \    -I  $(PLATFORMS)/android.jar \    -S  res/ \    -F  out/resources</code></pre><h4 id="将-dex-文件加入到资源文件初始包中"><a href="#将-dex-文件加入到资源文件初始包中" class="headerlink" title="将.dex 文件加入到资源文件初始包中"></a>将.dex 文件加入到资源文件初始包中</h4><p>　　<br>注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行</p><pre><code>apk_task:        java -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \      com.android.sdklib.build.ApkBuilderMain \      Demo.apk -v -u -z src/main/out/resources\      -f src/main/build/classes.dex -rf src</code></pre><h4 id="签名，使用debug的签名"><a href="#签名，使用debug的签名" class="headerlink" title="签名，使用debug的签名"></a>签名，使用debug的签名</h4><pre><code>signer:    jarsigner -verbose \    -keystore ~/.android/debug.keystore \    -storepass android \    -keypass android \    Demo.apk  androiddebugkey</code></pre><h4 id="一次性打包"><a href="#一次性打包" class="headerlink" title="一次性打包"></a>一次性打包</h4><pre><code>pkg:     make apk_task    make signer </code></pre><h4 id="卸载apk"><a href="#卸载apk" class="headerlink" title="卸载apk"></a>卸载apk</h4><pre><code>uninstall:    $(adb) uninstall  thereisnospon.dextest</code></pre><h4 id="安装apk"><a href="#安装apk" class="headerlink" title="安装apk"></a>安装apk</h4><pre><code>install:     $(adb) install out/app.apk</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>run:<br>    make pkg<br>    make uninstall<br>    make install</p><pre><code>$(adb) shell am start -n thereisnospon.dextest/        thereisnospon.dextest.MainActivity  </code></pre><h3 id="方法２，用gradle"><a href="#方法２，用gradle" class="headerlink" title="方法２，用gradle,"></a>方法２，用gradle,</h3><p>首先用AS 建立工程，之后在工程文件下，之星执行，gradle clean<br>gradle build<br>即生成apk文件</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;how-to-make-a-android-by-cmd&quot;&gt;&lt;a href=&quot;#how-to-make-a-android-by-cmd&quot; class=&quot;headerlink&quot; title=&quot;how to make a android by cmd :&quot;&gt;&lt;/a&gt;how to make a android by cmd :&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="android" scheme="http://xdksx.github.io/categories/android/"/>
    
    
      <category term="android_make" scheme="http://xdksx.github.io/tags/android-make/"/>
    
  </entry>
  
  <entry>
    <title>android_will_write</title>
    <link href="http://xdksx.github.io/2018/05/20/android-will-write/"/>
    <id>http://xdksx.github.io/2018/05/20/android-will-write/</id>
    <published>2018-05-20T08:58:26.000Z</published>
    <updated>2018-05-20T16:59:56.405Z</updated>
    
    <content type="html"><![CDATA[<p>#test categories<br>this is the android categories to test </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#test categories&lt;br&gt;this is the android categories to test &lt;/p&gt;

      
    
    </summary>
    
      <category term="android" scheme="http://xdksx.github.io/categories/android/"/>
    
    
      <category term="android_activity" scheme="http://xdksx.github.io/tags/android-activity/"/>
    
  </entry>
  
  <entry>
    <title>test_article_picture</title>
    <link href="http://xdksx.github.io/2018/05/20/test-article-picture/"/>
    <id>http://xdksx.github.io/2018/05/20/test-article-picture/</id>
    <published>2018-05-20T07:46:24.000Z</published>
    <updated>2018-05-20T15:54:54.521Z</updated>
    
    <content type="html"><![CDATA[<p>##this is a test of picture<br><img src="/2018/05/20/test-article-picture/example.jpg" title="This is an example image"><br>end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##this is a test of picture&lt;br&gt;&lt;img src=&quot;/2018/05/20/test-article-picture/example.jpg&quot; title=&quot;This is an example image&quot;&gt;&lt;br&gt;end&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="test" scheme="http://xdksx.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>ksance test article</title>
    <link href="http://xdksx.github.io/2018/05/19/ksance-test-article/"/>
    <id>http://xdksx.github.io/2018/05/19/ksance-test-article/</id>
    <published>2018-05-19T16:10:13.000Z</published>
    <updated>2018-05-20T00:57:45.225Z</updated>
    
    <content type="html"><![CDATA[<p> this is a test article by ksance </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; this is a test article by ksance &lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
