<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>追光者</title>
  
  <subtitle>小兴的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xdksx.github.io/"/>
  <updated>2018-05-28T00:22:04.171Z</updated>
  <id>http://xdksx.github.io/</id>
  
  <author>
    <name>小兴</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tcpip_ARP</title>
    <link href="http://xdksx.github.io/2018/05/27/tcpip-ARP/"/>
    <id>http://xdksx.github.io/2018/05/27/tcpip-ARP/</id>
    <published>2018-05-27T16:19:57.000Z</published>
    <updated>2018-05-28T00:22:04.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h3><h4 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h4><ul><li>ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信；</li><li>在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：<br>端设备手机pc等–&gt;(交换机)路由器—&gt;下一个路由器—&gt;下一个终端设备  <a id="more"></a><br>端设备默认路由到网关–&gt;网关收到包后，将源地址改为网关的外网地址—&gt;下一个路由将源地址改为其地址–&gt;….-&gt;设备地址为目的地址时，接收而不转发</li><li>考虑一个问题：在上述的网络上发送时，如pc发给路由器时，只知道它的ip地址，怎么发给它：<br>即端到端的发送：是借助设备唯一的mac地址来发送的<br>在有线网中。利用了交换机的端口和mac地址关系，转发<br>在wifi中，能接收到所有的包，但是会在驱动中将mac目的地址非本地的包丢弃，除非开启了混杂监听模式</li><li>但是路由器怎么知道设备如手机的mac地址呢？<br>通过arp协议来获取，arp是依赖mac和ip的”映射”</li><li>tcpip卷1中4.2举了一个完整的例子，可以去看<h4 id="ARP协议的交互过程"><a href="#ARP协议的交互过程" class="headerlink" title="ARP协议的交互过程"></a>ARP协议的交互过程</h4></li><li>基本的交互方式：<br>例如ping网关：<br>station  —ARP request—-&gt;   AP  ARP请求，广播帧<br>station  &lt;—ARP response —  AP  ARP应答 ,单播帧<br>通过上述的方式，station得到了AP的mac地址，之后将AP的MAC地址存在缓存中，在下次数据包等包的时候就可以将该mac地址填在mac头中，即知道了AP的地址后，包就可以顺利的被AP接收了</li><li>AP(路由器)也会主动的向station发送arp request，当它不知道station的mac地址（或缓存过期），例如，AP收到一个外网的包，要转发给对应192.168.0.4的staton,但是没有他的mac地址，或者过期了或者其他情况，则向该station发出arp请求。从而得打station的mac地址</li><li>什么时候会触发arp请求？<br>1.在ping的时候<br>2.在发送tcp，ip包的时候<br>3.在缓存过期时主动发出，这个由arp状态机中实现<h4 id="ARP代理和免费ARP"><a href="#ARP代理和免费ARP" class="headerlink" title="ARP代理和免费ARP"></a>ARP代理和免费ARP</h4></li><li>当我们通过ping百度，或者想访问百度的时候，怎么在mac头中填写目的mac地址呢？即怎么找到百度?（另一个网络)</li><li>是通过在mac头目的mac地址填写网关的mac地址实现的，借助w网关的来帮我们寻找，这个叫做ARP代理,其实欺骗了主机</li><li>tcpip卷对此有较详细解说4.6</li><li>免费ARP是用于检测是否周围有使用相同的ip地址的设备，即通过ping自己，寻找有自己的ip的主机<h4 id="ARP协议的包封装格式和抓包分析"><a href="#ARP协议的包封装格式和抓包分析" class="headerlink" title="ARP协议的包封装格式和抓包分析"></a>ARP协议的包封装格式和抓包分析</h4></li><li>分组格式：  ()为字节数<br>mac头：以太网目的地址(6) mac源地址(6) 帧类型(2)(0x0806)<br>28byte arp帧：硬件类型(2)|协议类型(2)|硬件地址长度(1)|协议地址长度(1)|op(请求或应答或rarp 2)|发送端mac地址(6)|发送端ip(4)|接收端mac地址(6)|接收端ip(4)  </li><li>请求广播帧：目的mac地址为全1，电缆上所有的以太网接口都要接收广播帧,硬件类型为1表示以太网地址，协议类型为要映射的协议地址类型0x0800,表示为ip地址，op（arp请求为1，答应为2，rarp请求为3，rarp答应为4）</li><li>arp填充：以太网帧最小值为60，mac头14，所以=46，要填充：46-28=18个字节</li><li>arp抓包，可以用wireshark,Omnipeek - Savvius,tcpdump,或者自己写一个程序来抓～<br>tcpdump : sudo tcpdump -vv arp  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> tcpdump: listening on wlp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">21.134575</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span> <span class="comment">//ap ask me</span></span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">21.135404</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span></span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">21.135413</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Reply <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> is-at <span class="number">48</span>:<span class="number">5</span>a:b6:<span class="number">6</span>e:c9:<span class="number">5f</span> (oui Unknown), length <span class="number">28</span><span class="comment">// i reply ap</span></span><br><span class="line"><span class="number">21</span>:<span class="number">51</span>:<span class="number">32.081916</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.106</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span> <span class="comment">//ask other</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>:<span class="number">01</span>:<span class="number">27.149947</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Request who-has <span class="number">192.168</span><span class="number">.0</span><span class="number">.107</span> tell <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>, length <span class="number">28</span></span><br><span class="line"><span class="number">0x0000</span>:  <span class="number">0001</span> <span class="number">0800</span> <span class="number">0604</span> <span class="number">0001</span> <span class="number">206b</span> e70f <span class="number">1b</span>42 c0a8  .........k...B..</span><br><span class="line"><span class="number">0x0010</span>:  <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> c0a8 <span class="number">006b</span>            ...........k</span><br><span class="line">    </span><br><span class="line">    <span class="number">22</span>:<span class="number">04</span>:<span class="number">17.114593</span> ARP, Ethernet (len <span class="number">6</span>), IPv4 (len <span class="number">4</span>), Reply <span class="number">192.168</span><span class="number">.0</span><span class="number">.110</span> is-at <span class="number">48</span>:<span class="number">5</span>a:b6:<span class="number">6</span>e:c9:<span class="number">5f</span> (oui Unknown), length <span class="number">28</span></span><br><span class="line"><span class="number">0x0000</span>:  <span class="number">0001</span> <span class="number">0800</span> <span class="number">0604</span> <span class="number">0002</span> <span class="number">485</span>a b66e c95f c0a8  ........HZ.n._..</span><br><span class="line"><span class="number">0x0010</span>:  <span class="number">006</span>e <span class="number">206b</span> e70f <span class="number">1b</span>42 c0a8 <span class="number">0001</span>            .n.k...B....</span><br></pre></td></tr></table></figure><h4 id="ARP协议的常用命令和调试分析"><a href="#ARP协议的常用命令和调试分析" class="headerlink" title="ARP协议的常用命令和调试分析"></a>ARP协议的常用命令和调试分析</h4><ul><li>查看ARP缓存：即现在保存的arp映射表:  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">arp</span> <span class="selector-tag">-a</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.101</span>) <span class="selector-tag">at</span> 4<span class="selector-tag">c</span><span class="selector-pseudo">:32</span><span class="selector-pseudo">:75</span><span class="selector-pseudo">:3a</span><span class="selector-pseudo">:09</span><span class="selector-pseudo">:b3</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.1</span>) <span class="selector-tag">at</span> 20<span class="selector-pseudo">:6b</span><span class="selector-pseudo">:e7</span><span class="selector-pseudo">:0f</span><span class="selector-pseudo">:1b</span><span class="selector-pseudo">:42</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.108</span>) <span class="selector-tag">at</span> 94<span class="selector-pseudo">:d0</span><span class="selector-pseudo">:29</span><span class="selector-pseudo">:9d</span><span class="selector-pseudo">:74</span><span class="selector-pseudo">:dd</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br><span class="line">? (192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.107</span>) <span class="selector-tag">at</span> 94<span class="selector-pseudo">:65</span><span class="selector-pseudo">:2d</span><span class="selector-pseudo">:ab</span><span class="selector-pseudo">:88</span><span class="selector-pseudo">:8b</span> <span class="selector-attr">[ether]</span> <span class="selector-tag">on</span> <span class="selector-tag">wlp2s0</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">arp</span> </span><br><span class="line"><span class="selector-tag">Address</span>                  <span class="selector-tag">HWtype</span>  <span class="selector-tag">HWaddress</span>           <span class="selector-tag">Flags</span> <span class="selector-tag">Mask</span>            <span class="selector-tag">Iface</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.101</span>            <span class="selector-tag">ether</span>   4<span class="selector-tag">c</span><span class="selector-pseudo">:32</span><span class="selector-pseudo">:75</span><span class="selector-pseudo">:3a</span><span class="selector-pseudo">:09</span><span class="selector-pseudo">:b3</span>   <span class="selector-tag">C</span>                     <span class="selector-tag">wlp2s0</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.1</span>              <span class="selector-tag">ether</span>   20<span class="selector-pseudo">:6b</span><span class="selector-pseudo">:e7</span><span class="selector-pseudo">:0f</span><span class="selector-pseudo">:1b</span><span class="selector-pseudo">:42</span>   <span class="selector-tag">C</span>                     <span class="selector-tag">wlp2s0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ip neigh</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span> dev wlp2s0 lladdr <span class="number">4</span>c:<span class="number">32</span>:<span class="number">75</span>:<span class="number">3</span>a:<span class="number">09</span>:b3 STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> dev wlp2s0 lladdr <span class="number">20</span>:<span class="number">6b</span>:e7:<span class="number">0f</span>:<span class="number">1b</span>:<span class="number">42</span> STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.108</span> dev wlp2s0 lladdr <span class="number">94</span>:d0:<span class="number">29</span>:<span class="number">9</span>d:<span class="number">74</span>:dd STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.107</span> dev wlp2s0 lladdr <span class="number">94</span>:<span class="number">65</span>:<span class="number">2</span>d:ab:<span class="number">88</span>:<span class="number">8b</span> STALE</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.104</span> dev wlp2s0 lladdr e4:<span class="number">9</span>a:dc:b0:a5:<span class="number">36</span> STALE</span><br></pre></td></tr></table></figure><ul><li>arping命令：<br><a href="http://man.linuxde.net/arping" target="_blank" rel="noopener">http://man.linuxde.net/arping</a></li><li>arp 命令<br>man arp 包括删除arp表项等，有问题，找男人~<h4 id="ARP协议内核状态机"><a href="#ARP协议内核状态机" class="headerlink" title="ARP协议内核状态机"></a>ARP协议内核状态机</h4></li><li>对不存在的主机，arp请求的超时机制  </li><li>arp缓存和老化时间：<br><a href="http://www.jb51.net/LINUXjishu/65693.html：" target="_blank" rel="noopener">http://www.jb51.net/LINUXjishu/65693.html：</a><br>改变老化时间：在Linux上如果你想设置你的ARP缓存老化时间，那么执行sysctl -w net.ipv4.neigh.ethX=Y即<h4 id="ARP协议的编程"><a href="#ARP协议的编程" class="headerlink" title="ARP协议的编程"></a>ARP协议的编程</h4></li><li>在PF_PACKET中发出ARP包</li><li>直接贴例子，具体可以看博客的PF_PACKET文章：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取硬件网卡的相应信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="keyword">char</span> *name , <span class="keyword">char</span> *MAC_addr , struct in_addr * IP_addr)</span></span>;</span><br><span class="line"><span class="comment">//arp包的结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ARP_PACKET</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="comment">//以太网首部</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> dest_mac[<span class="number">6</span>]; <span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> sorce_mac[<span class="number">6</span>];<span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> type;       <span class="comment">//2字节</span></span><br><span class="line">  <span class="comment">//arp——内容</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> hw_type;   <span class="comment">//2字节：硬件地址类型     0x0001 表示mac地址</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> pro_type;  <span class="comment">//2字节：软件地址类型    0x0806 表示IPV4地址</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> hw_len;     <span class="comment">//1字节：硬件地址长度  </span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> pro_len;    <span class="comment">//1字节：软件地址长度</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> op;        <span class="comment">//2字节：操作类型           0x0001表示ARP请求；0x0002表示ARP应答</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> from_mac[<span class="number">6</span>];<span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> from_ip[<span class="number">4</span>]; <span class="comment">//4字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> to_mac[<span class="number">6</span>];  <span class="comment">//6字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> to_ip[<span class="number">4</span>];   <span class="comment">//4字节</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> padding[<span class="number">18</span>];<span class="comment">//18字节：填充字节，因为以太网数据最少要46字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> MAC_ADDR[<span class="number">6</span>];</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">IP_ADDR</span>;</span><span class="comment">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ARP_PACKET</span> <span class="title">arp_pk</span>=&#123;</span><span class="number">0</span>&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">eth_info</span>;</span><span class="comment">//结构体的定义//在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class="line"> <span class="comment">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class="line"> GetEthInfor(<span class="string">"wlp2s0"</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class="line">   <span class="comment">/*printf("The MAC_addr is:");</span></span><br><span class="line"><span class="comment"> for(i =0 ;i&lt;6;i++)</span></span><br><span class="line"><span class="comment">    printf("%4X",MAC_ADDR[i]); </span></span><br><span class="line"><span class="comment"> printf("\n");</span></span><br><span class="line"><span class="comment">    printf("the IP is:%s\n",inet_ntoa(IP_ADDR));*/</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//第二步：填充ARP数据包的内容</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充以太网首部的目的mac地址</span></span><br><span class="line"> &#123;</span><br><span class="line">  arp_pk.dest_mac[i]=<span class="number">0XFF</span>;      </span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充以太网首部的源mac地址</span></span><br><span class="line"> &#123;</span><br><span class="line">  arp_pk.sorce_mac[i]=MAC_ADDR[i];</span><br><span class="line"> &#125;</span><br><span class="line">   arp_pk.type = htons(<span class="number">0x0806</span>);    <span class="comment">//填充以太网首部的侦类型</span></span><br><span class="line">   arp_pk.hw_type = htons(<span class="number">0x0001</span>); <span class="comment">//填充硬件地址类型：0x0001表示的是MAC地址</span></span><br><span class="line">   arp_pk.pro_type = htons(<span class="number">0x0800</span>);<span class="comment">//填充协议地址类型：0x0800表示的是IP地址</span></span><br><span class="line">   arp_pk.hw_len = <span class="number">6</span>;              <span class="comment">//填充硬件地址长度</span></span><br><span class="line">   arp_pk.pro_len = <span class="number">4</span>;             <span class="comment">//填充协议地址长度</span></span><br><span class="line">   arp_pk.op = htons(<span class="number">0x0001</span>);      <span class="comment">//填充操作类型：0x0001表示ARP请求</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充源mac地址</span></span><br><span class="line">   &#123;</span><br><span class="line">  arp_pk.from_mac[i]=MAC_ADDR[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">in_addr_t</span> ipaddr=inet_network(inet_ntoa(IP_ADDR));</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)                 <span class="comment">//填充源IP地址</span></span><br><span class="line">   &#123;</span><br><span class="line">  arp_pk.from_ip[i]=(<span class="keyword">unsigned</span> <span class="keyword">char</span>)ipaddr&amp;<span class="number">0xFF</span>;</span><br><span class="line">   ipaddr=ipaddr&gt;&gt;<span class="number">8</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"-%d-"</span>,arp_pk.from_ip[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">/* arp_pk.from_ip[0]=192;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[1]=168;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[2]=199;</span></span><br><span class="line"><span class="comment">  arp_pk.from_ip[3]=145;*/</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)                 <span class="comment">//填充欲获取的目的mac地址</span></span><br><span class="line">   &#123;</span><br><span class="line">    arp_pk.to_mac[i]=<span class="number">0X00</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   arp_pk.to_ip[<span class="number">0</span>]=<span class="number">0X0B</span>;        <span class="comment">//填充想要装换为MAC地址的IP地址。可以使用命令行参数来做</span></span><br><span class="line">   arp_pk.to_ip[<span class="number">1</span>]=<span class="number">0X40</span>;</span><br><span class="line">   arp_pk.to_ip[<span class="number">2</span>]=<span class="number">0X39</span>;</span><br><span class="line">   arp_pk.to_ip[<span class="number">3</span>]=<span class="number">0X0A</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第三步：填充sockaddr_ll eth_info结构</span></span><br><span class="line">    eth_info.sll_family = PF_PACKET;</span><br><span class="line"> eth_info.sll_ifindex = if_nametoindex(<span class="string">"wlp2s0"</span>);<span class="comment">//返回输入的接口名称的索引值</span></span><br><span class="line"> <span class="comment">//printf("number is:%d\n",eth_info.sll_family);</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//第四步：创建原始套接字</span></span><br><span class="line"> fd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));  <span class="comment">//</span></span><br><span class="line"> <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"socket SOCK_RAW failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="comment">//第五步：发送ARP数据包</span></span><br><span class="line"> num = sendto(fd , &amp;arp_pk , <span class="keyword">sizeof</span>(struct ARP_PACKET) , <span class="number">0</span> ,(struct sockaddr*)(&amp;eth_info),<span class="keyword">sizeof</span>(eth_info));</span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sendto failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">        <span class="comment">//第六步：接受ARP应答</span></span><br><span class="line"> num = recvfrom(fd , &amp;arp_pk , <span class="keyword">sizeof</span>(struct ARP_PACKET) ,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"rcvfrom failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"I receive %d bytes!\n"</span>,num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the mac  is:"</span>);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%4X "</span>,arp_pk.from_mac[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"op:%d\n"</span>,arp_pk.op);</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d. "</span>,arp_pk.to_ip[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="keyword">char</span> *name ,  <span class="keyword">char</span> *MAC_addr , struct in_addr * IP_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span>  <span class="title">eth</span>;</span>  <span class="comment">//够结构用于存放最初多获取的接口信息</span></span><br><span class="line"><span class="comment">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class="line">   <span class="keyword">int</span> fd;             <span class="comment">//用于创建套接字</span></span><br><span class="line"> <span class="keyword">int</span> temp=<span class="number">0</span>;         <span class="comment">//用于验证接口调用</span></span><br><span class="line"> <span class="keyword">int</span> i=<span class="number">0</span>;            <span class="comment">//用于循环</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">strncpy</span>(eth.ifr_name,name,<span class="keyword">sizeof</span>(struct ifreq)<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class="line"> <span class="comment">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class="line">    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"socket failed!\n"</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class="line">   temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class="line"> <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="built_in">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class="number">6</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"The MAC_addr is:"</span>);</span><br><span class="line"> <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%4X"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class="line">   temp = ioctl(fd,SIOCGIFADDR,&amp;eth);</span><br><span class="line"> <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="built_in">memcpy</span>(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class="number">4</span>);</span><br><span class="line"> <span class="comment">//关闭套接口</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"got ipaddr:%s\n"</span>,inet_ntoa(*IP_addr));</span><br><span class="line"><span class="comment">/*i=0;</span></span><br><span class="line"><span class="comment">printf("get the MAC_ADDR:\n");</span></span><br><span class="line"><span class="comment">for(i;i&lt;6;i++)</span></span><br><span class="line"><span class="comment">  printf("%.2X:",MAC_addr[i]&amp;0xFF);*/</span></span><br><span class="line">   close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步填充arp数据包的时候，填充的数据和类型根据需要进行。</span></span><br><span class="line"><span class="comment">//这里的arp数据包结构体是自己定义的，也可以是利用linux的相关结构：</span></span><br><span class="line"><span class="comment">/*eg:</span></span><br><span class="line"><span class="comment">typedef struct _tagARP_PACKET&#123;    </span></span><br><span class="line"><span class="comment">    struct ether_header  eh;    ///net/ethernet.h</span></span><br><span class="line"><span class="comment">    struct ether_arp arp;    </span></span><br><span class="line"><span class="comment">&#125;ARP_PACKET_OBJ, *ARP_PACKET_HANDLE; /netinet/if_ether.h;/net/if_arp.h</span></span><br><span class="line"><span class="comment">各个字段的填充见头文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三步：填充sockaddr_ll eth_info结构,关键是填充网络接口索引值，最直接的方法是上面的函数，</span></span><br><span class="line"><span class="comment">还有另外的方法:利用ioctl函数获取struct ifreq结构的信息，该结构放置了很多网络接口的相关信息*/</span></span><br><span class="line"><span class="comment">/*  struct sockaddr_ll&#123;</span></span><br><span class="line"><span class="comment">    unsigned short sll_family; //总是 AF_PACKET </span></span><br><span class="line"><span class="comment">    unsigned short sll_protocol; // 物理层的协议 </span></span><br><span class="line"><span class="comment">    int sll_ifindex; //接口号 </span></span><br><span class="line"><span class="comment">    unsigned short sll_hatype; // 报头类型 </span></span><br><span class="line"><span class="comment">    unsigned char sll_pkttype; // 分组类型 </span></span><br><span class="line"><span class="comment">    unsigned char sll_halen; // 地址长度 </span></span><br><span class="line"><span class="comment">    unsigned char sll_addr[8]; // 物理层地址 </span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">eg:</span></span><br><span class="line"><span class="comment">*     struct sockaddr_ll peer_addr;  </span></span><br><span class="line"><span class="comment">*    memset(&amp;peer_addr, 0, sizeof(peer_addr));    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_family = AF_PACKET;    </span></span><br><span class="line"><span class="comment">        struct ifreq req;  </span></span><br><span class="line"><span class="comment">    bzero(&amp;req, sizeof(struct ifreq));  </span></span><br><span class="line"><span class="comment">        strcpy(req.ifr_name, "eth0");    </span></span><br><span class="line"><span class="comment">        if(ioctl(sockfd, SIOCGIFINDEX, &amp;req) != 0)  </span></span><br><span class="line"><span class="comment">        perror("ioctl()");    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_ifindex = req.ifr_ifindex;    </span></span><br><span class="line"><span class="comment">        peer_addr.sll_protocol = htons(ETH_P_ARP);  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*第四步，创建套结字的时候，有以下的组合：更多见：man packet</span></span><br><span class="line"><span class="comment"> * 利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</span></span><br><span class="line"><span class="comment"> * 第二个参数： 2）套接字类型：</span></span><br><span class="line"><span class="comment">          SOCK_DGRAM----以太网头已经构造好了</span></span><br><span class="line"><span class="comment">          SOCK_RAW------自己构造以太头 </span></span><br><span class="line"><span class="comment">          * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字</span></span><br><span class="line"><span class="comment">          * 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），</span></span><br><span class="line"><span class="comment">          * 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，</span></span><br><span class="line"><span class="comment">          * 而发送时也无须用户添加头部字段。</span></span><br><span class="line"><span class="comment">   第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP</span></span><br><span class="line"><span class="comment">   * 以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：</span></span><br><span class="line"><span class="comment">   1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)</span></span><br><span class="line"><span class="comment">  和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)</span></span><br><span class="line"><span class="comment">    2)IEEE维护的注册以太网类型列表</span></span><br><span class="line"><span class="comment">     3）半官方的列表由IANA维护</span></span><br><span class="line"><span class="comment">      ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。</span></span><br><span class="line"><span class="comment">      0x88b5和0x88b6是保留以太网类型，供实验或私人使用。 </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">   <span class="comment">/*第五步发送和接收套接字的函数可以是read write操作套结字，也可以是上文的UDP无连接用的函数*/</span></span><br></pre></td></tr></table></figure><p>处理的时候可能需要获取网关的ip地址：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*proc方法获取网关地址*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetGateWayIP</span><span class="params">(uint8 *ip_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">char</span> inf[<span class="number">100</span>];</span><br><span class="line">      FILE *file_fd;</span><br><span class="line">      uint8 high=<span class="number">0</span>,low=<span class="number">0</span>,value;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      file_fd = fopen(<span class="string">"/proc/net/route"</span>,<span class="string">"r"</span>);</span><br><span class="line">      <span class="keyword">if</span>(file_fd==<span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"can not open /proc/net/route\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">             <span class="keyword">while</span>(!feof(file_fd))</span><br><span class="line">             &#123;</span><br><span class="line">                     <span class="built_in">memset</span>(inf,<span class="number">0</span>,<span class="keyword">sizeof</span>(inf));</span><br><span class="line">                     fgets(inf,<span class="number">100</span>,file_fd);</span><br><span class="line">                     <span class="keyword">if</span>(inf[<span class="number">5</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">6</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">7</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">8</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">9</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">10</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">11</span>]==<span class="string">'0'</span>&amp;&amp;inf[<span class="number">12</span>]==<span class="string">'0'</span>)</span><br><span class="line">                     &#123;</span><br><span class="line">                              <span class="keyword">for</span>(i=<span class="number">20</span>;i&gt;=<span class="number">14</span>;i-=<span class="number">2</span>)</span><br><span class="line">                              &#123;</span><br><span class="line">                                         <span class="keyword">if</span>(inf[i]&gt;=<span class="number">65</span>)</span><br><span class="line">                                                 high = inf[i]<span class="number">-55</span>;</span><br><span class="line">                                         <span class="keyword">else</span></span><br><span class="line">                                                 high = inf[i]<span class="number">-48</span>;</span><br><span class="line">                                         <span class="keyword">if</span>(inf[i+<span class="number">1</span>]&gt;=<span class="number">65</span>)</span><br><span class="line">                                                 low = inf[i+<span class="number">1</span>]<span class="number">-55</span>;</span><br><span class="line">                                         <span class="keyword">else</span></span><br><span class="line">                                                 low = inf[i+<span class="number">1</span>]<span class="number">-48</span>;</span><br><span class="line">                                        value = high*<span class="number">16</span>+low;</span><br><span class="line">                                       ip_addr[<span class="number">10</span>-i/<span class="number">2</span>] = value;</span><br><span class="line">                              &#125;</span><br><span class="line">                              <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h4><ul><li>ARP包可以直接发送给对端不经过路由器，有趣<br>在一个局域网中，客户端的几乎所有的包都是发往路由器的，这归结于默认路由设置，而在无线网，网卡其实可以接收所有数据，毕竟空气介质，所以，局域网中的设备可以直接通信<br>实验：在文件全能王中开启wifi文件传输，和它在同一个局域网的sta能访问该地址，抓包，发现目的地址和源地址都为同一个局域网的不同ip,且不为路由器网关ip，证明其两个设备是可以直接通信的</li><li>再来做一个实验：通过pf_packet<br>1、在电脑A上写一个程序，mac目的地址为B,源地址为A,协议类型随机，数据随意，发送给B<br> 同时在B端进行接收，过滤掉其他mac地址，看是否可以接收到，在连接ap和不连接ap的条件下<br>2、在A和B设置静态ip地址，且不同网段，都不连接AP ,让A向B 发送ARP请求包，B接收到后回复arp响应包，接着做ping或其他操作，看是否能互相通信</li><li>编程可以参考上述程序，改一下地址什么的就可以，或者参考其他：<br><a href="http://www.freebuf.com/articles/system/5157.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/system/5157.html</a><br>这篇文章讲的很具体，个人也喜欢这个网站，emm,实验过了，还可以，具体程序不贴了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ARP-协议&quot;&gt;&lt;a href=&quot;#ARP-协议&quot; class=&quot;headerlink&quot; title=&quot;ARP 协议&quot;&gt;&lt;/a&gt;ARP 协议&lt;/h3&gt;&lt;h4 id=&quot;ARP协议的作用&quot;&gt;&lt;a href=&quot;#ARP协议的作用&quot; class=&quot;headerlink&quot; title=&quot;ARP协议的作用&quot;&gt;&lt;/a&gt;ARP协议的作用&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ARP是一种地址解析协议，ARP的存在是为了能在端到端通信时的寻找到端地址；ARP由设备的ip地址获取到设备的mac硬件地址，从而能跟该设备通信；&lt;/li&gt;
&lt;li&gt;在网络层，有ip地址和路由作为寻路的导向，即通过封装源地址和目的地址，以及路由，一个ip包在不考虑mac层的时候大概是这样传输的：&lt;br&gt;端设备手机pc等–&amp;gt;(交换机)路由器—&amp;gt;下一个路由器—&amp;gt;下一个终端设备
    
    </summary>
    
      <category term="tcpip" scheme="http://xdksx.github.io/categories/tcpip/"/>
    
    
      <category term="tcpip_mac" scheme="http://xdksx.github.io/tags/tcpip-mac/"/>
    
  </entry>
  
  <entry>
    <title>tcpip_PF_PACKET</title>
    <link href="http://xdksx.github.io/2018/05/27/tcpip-PF-PACKET/"/>
    <id>http://xdksx.github.io/2018/05/27/tcpip-PF-PACKET/</id>
    <published>2018-05-27T12:28:40.000Z</published>
    <updated>2018-05-27T20:37:03.654Z</updated>
    
    <content type="html"><![CDATA[<img src="/2018/05/27/tcpip-PF-PACKET/pf_packet.jpg" title="it just picture"><h3 id="PF-PACKET的使用："><a href="#PF-PACKET的使用：" class="headerlink" title="PF_PACKET的使用："></a>PF_PACKET的使用：</h3><h3 id="PF-PACKET简介："><a href="#PF-PACKET简介：" class="headerlink" title="PF_PACKET简介："></a>PF_PACKET简介：</h3><p>是linux下的用于发送和接收二层(mac层)的套接字：<br><a id="more"></a></p><h3 id="PF-PACKET基本使用："><a href="#PF-PACKET基本使用：" class="headerlink" title="PF_PACKET基本使用："></a>PF_PACKET基本使用：</h3><ul><li>基本的几个操作：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取硬件网卡的相应信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEthInfor</span><span class="params">(<span class="keyword">char</span> *name ,  <span class="keyword">char</span> *MAC_addr , struct in_addr * IP_addr)</span><span class="comment">//传入接口名，取回mac和ip</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span>  <span class="title">eth</span>;</span>  <span class="comment">//结构用于存放最初获取的接口信息</span></span><br><span class="line">   <span class="comment">//该结构存放在：/net/if.h,详细字段表示在头文件中</span></span><br><span class="line">   <span class="keyword">int</span> fd;             <span class="comment">//用于创建套接字</span></span><br><span class="line">   <span class="keyword">int</span> temp=<span class="number">0</span>;         <span class="comment">//用于验证接口调用</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;            <span class="comment">//用于循环</span></span><br><span class="line">   <span class="built_in">strncpy</span>(eth.ifr_name,name,<span class="keyword">sizeof</span>(struct ifreq)<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">// fd = socket(AF_INET,SOCK_DGRAM,0);</span></span><br><span class="line">  <span class="comment">// fd=socket(AF_INET,SOCK_STREAM,0); </span></span><br><span class="line">    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"socket failed!\n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口MAC地址信息</span></span><br><span class="line">     temp = ioctl(fd,SIOCGIFHWADDR,&amp;eth);</span><br><span class="line">     <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="built_in">strncpy</span>(MAC_addr,eth.ifr_hwaddr.sa_data,<span class="number">6</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"The MAC_addr is:"</span>);</span><br><span class="line">      <span class="keyword">for</span>(i =<span class="number">0</span> ;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%4X"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)eth.ifr_hwaddr.sa_data[i]); </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//获取并且保存和打印指定的物理接口IP地址信息</span></span><br><span class="line">      temp = ioctl(fd,SIOCGIFADDR,&amp;eth);</span><br><span class="line">      <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"ioctl--get hardware addr failed!\n"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(IP_addr ,&amp;(((struct sockaddr_in *)(&amp;eth.ifr_addr))-&gt;sin_addr),<span class="number">4</span>);</span><br><span class="line">      <span class="comment">//关闭套接口</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"got ipaddr:%s\n"</span>,inet_ntoa(*IP_addr)); </span><br><span class="line">      close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取得网络接口的索引：int值,传入fd和接口名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_IfaceIndex</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* interfaceName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"><span class="keyword">if</span> (interfaceName == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line"><span class="built_in">strcpy</span>(ifr.ifr_name, interfaceName);</span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, SIOCGIFINDEX, &amp;ifr) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"RED ioctl error\n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ifr.ifr_ifindex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_Iface_promisc</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> dev_id)</span><span class="comment">//传入fd和index</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_mreq</span> <span class="title">mr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;mr,<span class="number">0</span>,<span class="keyword">sizeof</span>(mr));</span><br><span class="line">mr.mr_ifindex = dev_id;</span><br><span class="line">mr.mr_type = PACKET_MR_PROMISC;</span><br><span class="line"><span class="keyword">if</span>(setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&amp;mr,<span class="keyword">sizeof</span>(mr))==<span class="number">-1</span>)<span class="comment">//退出混杂模式使用这个：PACKET_DROP_MEMBERSHIP</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"GREEN set promisc failed! \n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> MAC_ADDR[<span class="number">6</span>];</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">IP_ADDR</span>;</span><span class="comment">//结构体的定义在/netinet/in.h用来表示一个32位的IPv4地址.</span></span><br><span class="line"> <span class="comment">//第一步：获取指定网卡的信息（MAC地址和IP地址）</span></span><br><span class="line">    GetEthInfor(<span class="string">"wlp2s0"</span>,MAC_ADDR,&amp;IP_ADDR);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">     fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP));</span><br><span class="line">    <span class="keyword">int</span> index=Get_IfaceIndex(fd,<span class="string">"enp1s0"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"index:%d\n"</span>,index);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="PF-PACKET的接收："><a href="#PF-PACKET的接收：" class="headerlink" title="PF_PACKET的接收："></a>PF_PACKET的接收：</h3><p>简单说明：<br>创建套结字的时候，有以下的组合：更多见：man packet</p><ul><li>利用AF_PACKET 套接字发送一个任意的以太网帧。针对linux.</li><li>第二个参数： 套接字类型：<pre><code>SOCK_DGRAM----以太网头已经构造好了SOCK_RAW------自己构造以太头 * 一种为SOCK_RAW,它是包含了MAC层头部信息的原始分组，当然这种类型的套接字* 在发送的时候需要自己加上一个MAC头部（其类型定义在linux/if_ether.h中，ethhdr），* 另一种是SOCK_DGRAM类型，它是已经进行了MAC层头部处理的，即收上的帧已经去掉了头部，* 而发送时也无须用户添加头部字段。</code></pre></li></ul><ul><li>第三个参数表示协议类型:链路层承载的协议IP ,ARP,RARP<ul><li>以太网帧中的以太网类型指定了它包含的负载的类型。有很多途径可以获取以太网类型：<br>1）头文件Linux/if_ether.h 定义了大多数常用的以太网类型。包括以太网协议的ETH_P_IP(0x8000)、arp的ETH_P_ARP(0x0806)<br>和IEEE 802.1Q VLAN tags的ETH_P_8021Q(0x8100)<br>2)  IEEE维护的注册以太网类型列表<br>3）半官方的列表由IANA维护<br> ETH_P_ALL允许任何在没有使用多个套接字的情况下接受所有以太网类型的报文。<br> 0x88b5和0x88b6是保留以太网类型，供实验或私人使用。<br>(若指定socket_type为SOCK_RAW则意味着原始数据包包含了链路层头部，若指定为SOCK_DGRAM则将做一些处理以剥掉链路层头部。链路层头部信息的通用格式是一个sockaddr_ll结构。protocol填入网络字节序的IEEE 802.3协议号。参见&lt;linux/if_ether.h&gt;头文件了解允许的协议。如果protocol被设置为htons(ETH_P_ALL)，则意味着接受所有协议。所有接入的协议类型为protocol的数据包将在传递给内核之前传递到PACKET套接字。)</li></ul><ul><li>收包可以使用的接口：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readnum = recvfrom(rawsock, buffer,<span class="number">2048</span>,<span class="number">0</span>, (struct sockaddr*)(&amp;eth_info),&amp;leneth_info);</span><br><span class="line"><span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);</span><br><span class="line"><span class="keyword">int</span> readnum = recvfrom(rawsock, buffer,<span class="number">2048</span>,<span class="number">0</span>, <span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>一个简单的接收包的例子：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_MAX 2048</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: create raw socket!!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf("recv buffer:%s\n",buffer);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>指定从某个接口接收数据：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">eth_info</span>;</span><span class="comment">//结构体的定义在/linux/if_packet.h中， 表示设备无关的物理层地址结构</span></span><br><span class="line">  eth_info.sll_family = PF_PACKET;  <span class="comment">//PF_PACKET定义在sys/types.h中</span></span><br><span class="line">  eth_info.sll_ifindex = if_nametoindex(<span class="string">"lo"</span>);<span class="comment">//返回输入的接口名称的索引值　　//次函数定义在net/if.h中</span></span><br><span class="line"> <span class="keyword">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: create raw socket!!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">if</span>(bind(rawsock,(struct sockaddr *)(&amp;eth_info),<span class="keyword">sizeof</span>(eth_info))==<span class="number">-1</span>)<span class="comment">//绑定接口，从而只接收那个接口上的数据</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"error: bind!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf("recv buffer:%s\n",buffer);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>接收后的包如何读取：以包括mac头的形式来看：粗暴的形式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rawsock;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_MAX];</span><br><span class="line">    <span class="keyword">char</span> *ethhead;</span><br><span class="line">    <span class="keyword">char</span> *iphead;</span><br><span class="line">    <span class="keyword">char</span> *tcphead;</span><br><span class="line">    <span class="keyword">char</span> *udphead;</span><br><span class="line">    <span class="keyword">char</span> *icmphead;</span><br><span class="line">    <span class="keyword">char</span> *pHead;</span><br><span class="line"> <span class="keyword">if</span>((rawsock=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL))) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: create raw socket!!!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">int</span> readnum = read(rawsock, buffer,<span class="number">2048</span>);<span class="comment">// can read packet</span></span><br><span class="line">        <span class="comment">//printf("recv buffer:%s\n",buffer);</span></span><br><span class="line">         <span class="keyword">if</span>(readnum &lt; <span class="number">42</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error: Header is incomplete!!!\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//  for(j;j&lt;readnum;j++)</span></span><br><span class="line">      <span class="comment">//     printf("%.2X:",buffer[j]&amp;0xFF);</span></span><br><span class="line">        ethhead = (<span class="keyword">char</span> *)buffer;</span><br><span class="line">        pHead = ethhead;</span><br><span class="line">        <span class="keyword">int</span> ethernetmask = <span class="number">0XFF</span>;</span><br><span class="line">        framecount++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"------------------Analysis   Packet [%d]---------------------\n"</span>,framecount);</span><br><span class="line">       <span class="comment">// printf("all:-----%s\n",ethhead);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"MAC:"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;=<span class="number">11</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2X:"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;=<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2X:"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"proto: %.2x:"</span>,pHead[<span class="number">12</span>]&amp;ethernetmask);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"proto2: %.2x:\n"</span>,pHead[<span class="number">13</span>]&amp;ethernetmask);        </span><br><span class="line">        iphead = ethhead + <span class="number">14</span>;</span><br><span class="line">        pHead = iphead + <span class="number">14</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"IP:"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;=<span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">10</span>; i &lt;=<span class="number">13</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,pHead[i]&amp;ethernetmask);</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">13</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> prototype = (iphead + <span class="number">9</span>)[<span class="number">0</span>];</span><br><span class="line">     <span class="comment">//   printf("Protocol: %.2X:",prototype);</span></span><br><span class="line">        <span class="comment">//int prototype = (iphead + 9)[0];</span></span><br><span class="line">        pHead = iphead + <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Protocol: "</span>);</span><br><span class="line">        <span class="keyword">switch</span>(prototype)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_ICMP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ICMP\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_IGMP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"IGMP\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_IPIP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"IP\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_TCP :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"TCP | source port: %u | "</span>,(pHead[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">1</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"dest port: %u\n"</span>, (pHead[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">3</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_UDP :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"UDP | source port: %u | "</span>,(pHead[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">1</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"dest port: %u\n"</span>, (pHead[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)&amp;<span class="number">0XFF00</span> | pHead[<span class="number">3</span>]&amp;<span class="number">0XFF</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_RAW :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"RAW\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Unkown\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-------------------------end-----------------------\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>收包处理的方式，也可以把指针赋给内核的结构：struct iphdr<br>如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> <span class="title">ip</span>;</span></span><br><span class="line">ip = (struct iphdr *)(buffer + <span class="keyword">sizeof</span>(struct ethhdr));</span><br></pre></td></tr></table></figure></p><p>内核提供了很多的包结构，在发包或者收包的时候可以直接使用这些结构解析或者粗暴的用字符串解析</p><h3 id="PF-PACKET发送包："><a href="#PF-PACKET发送包：" class="headerlink" title="PF_PACKET发送包："></a>PF_PACKET发送包：</h3><ul><li>发包和接收包类似：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = sendto(rawsock, buffer,<span class="number">2048</span> , <span class="number">0</span> ,(struct sockaddr*)(&amp;eth_info),<span class="keyword">sizeof</span>(eth_info));</span><br><span class="line"> <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sendto failed!\n"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"success:%d\n"</span>,num);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2018/05/27/tcpip-PF-PACKET/pf_packet.jpg&quot; title=&quot;it just picture&quot;&gt;
&lt;h3 id=&quot;PF-PACKET的使用：&quot;&gt;&lt;a href=&quot;#PF-PACKET的使用：&quot; class=&quot;headerlink&quot; title=&quot;PF_PACKET的使用：&quot;&gt;&lt;/a&gt;PF_PACKET的使用：&lt;/h3&gt;&lt;h3 id=&quot;PF-PACKET简介：&quot;&gt;&lt;a href=&quot;#PF-PACKET简介：&quot; class=&quot;headerlink&quot; title=&quot;PF_PACKET简介：&quot;&gt;&lt;/a&gt;PF_PACKET简介：&lt;/h3&gt;&lt;p&gt;是linux下的用于发送和接收二层(mac层)的套接字：&lt;br&gt;
    
    </summary>
    
      <category term="tcpip" scheme="http://xdksx.github.io/categories/tcpip/"/>
    
    
      <category term="PF_PACKET" scheme="http://xdksx.github.io/tags/PF-PACKET/"/>
    
  </entry>
  
  <entry>
    <title>DS_linklist</title>
    <link href="http://xdksx.github.io/2018/05/26/DS-linklist/"/>
    <id>http://xdksx.github.io/2018/05/26/DS-linklist/</id>
    <published>2018-05-26T13:18:09.000Z</published>
    <updated>2018-05-26T23:08:24.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构之线性表："><a href="#数据结构之线性表：" class="headerlink" title="数据结构之线性表："></a>数据结构之线性表：</h2><h3 id="有序表：数组："><a href="#有序表：数组：" class="headerlink" title="有序表：数组："></a>有序表：数组：</h3><h3 id="单链表："><a href="#单链表：" class="headerlink" title="单链表："></a>单链表：</h3><p>链表定义  <a id="more"></a><br>{  </p><ul><li>数据成员:常见的基本类型或者对象类型均可  </li><li>数据关系:在链表中的块的成员在连续的内存中，块与块之间内存位置不连续  </li><li>指向块的指针：单链表只有一个next,双链表加上pre  </li></ul><p>}<br>基本运算：<br>{</p><ul><li>InitList(&amp;L);:初始化链表，在c/c++中需要做分配内存，初始化链表头和其值的操作；  </li><li>DestroyList(&amp;L); 在销毁时需要free内存  </li><li>Length(L);链表的长度是块的个数</li><li>GetElem(L,i,&amp;e); 在链表中取元素需要一个一个遍历直到下标值，若为双链表会快些。所以这里取索引值对应的值和取链表的值，效率几乎一样；  </li><li>LocateElem(L,e,compare()); 和链表中的元素做对比</li><li>InsertElem(&amp;L,i,e); 在链表中插入元素，复杂度O(1),在提供位置的时候，若不提供位置，还需要加搜索的时间</li><li>DeleteElem(&amp;L,i,&amp;e); 在链表中删除元素，复杂度O(1)<br>……  </li></ul><p>}<br>eg:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span> </span><br><span class="line">       ElemType data；<span class="comment">//数据域</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>  *<span class="title">next</span>； //指针域</span></span><br><span class="line"><span class="class">&#125; <span class="title">LNode</span>,  *<span class="title">LinkList</span>;</span></span><br><span class="line">LNode  *L;</span><br><span class="line">LinkList  L;</span><br><span class="line">L =  (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">或 L = <span class="keyword">new</span> LNode;</span><br><span class="line">L-&gt;data;</span><br><span class="line">LNode  L;</span><br><span class="line">L.date</span><br></pre></td></tr></table></figure></p><img src="/2018/05/26/DS-linklist/linklist.png" title="链表示意图">    <h3 id="链表的两种头部："><a href="#链表的两种头部：" class="headerlink" title="链表的两种头部："></a>链表的两种头部：</h3><ol><li>没有头的链表：第一个块就开始存储数据  </li><li>任何时候都有头的链表：  第一个块不存储数据，作为头节点，第二个块开始存数据  </li><li>应用：在leetcode中的ReverseLinklist中，当反转的是从1开始的时候，若使用的是没有头的，则需要额外判断处理，否则可以统一处理；  </li></ol><img src="/2018/05/26/DS-linklist/headnode.png" title="头节点示意图">  <h3 id="链表的几个常见操作："><a href="#链表的几个常见操作：" class="headerlink" title="链表的几个常见操作：　"></a>链表的几个常见操作：　</h3><ul><li><p>取第i个元素：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//查找操作</span></span><br><span class="line">    p = L-&gt;next;  </span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; j &lt; i)&#123;</span><br><span class="line">          p = p-&gt;next; </span><br><span class="line">          ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j&gt;i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入元素：在第i个位置上插入    </p><img src="/2018/05/26/DS-linklist/insert.png" title="插入示意图">    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p = L; j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (p &amp;&amp; j &lt; i<span class="number">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class="line">     <span class="keyword">if</span> (!p || j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line">  s =  (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     s-&gt;data = e;  </span><br><span class="line">  s-&gt;next = p-&gt;next;  </span><br><span class="line">  p-&gt;next = s;  </span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>删除元素:删除第i个元素:  </p><img src="/2018/05/26/DS-linklist/delete.png" title="删除示意图">  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> p = L; j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i<span class="number">-1</span>) &#123; p = p-&gt;next; ++j &#125;</span><br><span class="line">     <span class="keyword">if</span> (!(p-&gt;next) || j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line"> q = p-&gt;next;</span><br><span class="line">     e = q-&gt;data;  </span><br><span class="line"> p-&gt;next = p-&gt;next-&gt;next;  <span class="comment">//(p-&gt;next = q-&gt;next;)</span></span><br><span class="line"> <span class="built_in">free</span>(q);  </span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="链表的建立："><a href="#链表的建立：" class="headerlink" title="链表的建立："></a>链表的建立：</h3><ul><li><p>头插法：  </p><img src="/2018/05/26/DS-linklist/headbuild.png" title="头插法示意图">  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CreateList_L(LinkList &amp;L, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">     L = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span>( i=n; i&gt;<span class="number">0</span>; --i)&#123;</span><br><span class="line">         s = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">         <span class="built_in">scanf</span>( &amp;s-&gt;data);</span><br><span class="line">         s-&gt;next = L-&gt;next; ①</span><br><span class="line">         L-&gt;next = s; ②</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>尾插法：  </p><img src="/2018/05/26/DS-linklist/tailbuile.png" title="尾插法示意图">  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CreateList_L(LinkList &amp;L, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">     tail = L = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">     L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span>( i=n; i&gt;<span class="number">0</span>; --i)&#123;</span><br><span class="line">         s = (LinkList) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (LNode) );</span><br><span class="line">         <span class="built_in">scanf</span>( &amp;s-&gt;data);</span><br><span class="line">         tail-&gt;next = s; ①</span><br><span class="line">         tail = s; ②</span><br><span class="line">     &#125;      &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="链表的常见复杂操作："><a href="#链表的常见复杂操作：" class="headerlink" title="链表的常见复杂操作："></a>链表的常见复杂操作：</h3><ul><li>两个有序链表的合并：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa = La-&gt;next; pb = Lb-&gt;next;</span><br><span class="line">    Lc = pc = La;</span><br><span class="line">    <span class="keyword">while</span>( pa &amp;&amp; pb )&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class="line">             pc-&gt;next = pa; pc = pa; pa = pa-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">             pc-&gt;next = pb; pc = pb; pb= pb-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = pa ? pa : pb;</span><br><span class="line">    <span class="built_in">free</span>( Lb );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="一些特殊的链表："><a href="#一些特殊的链表：" class="headerlink" title="一些特殊的链表："></a>一些特殊的链表：</h3><ul><li>单向循环链表：</li><li>图示：  <img src="/2018/05/26/DS-linklist/sigrecyclelink.png" title="单向循环链表"><img src="/2018/05/26/DS-linklist/mergerecycle.png" title="合并"></li><li>多重循环链表：</li><li>双向链表：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">     ElemType               data;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>    *<span class="title">prior</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>    *<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode,  *DuLinkList;</span><br></pre></td></tr></table></figure></li></ul><p>双向循环链表：</p><h3 id="探讨："><a href="#探讨：" class="headerlink" title="探讨："></a>探讨：</h3><ul><li>链表作为最基础的数据结构，是对其他数据结构：如栈，树等的支撑，其他这些大部分是在链表的基础上建立的；  </li><li>从较底层的层面：即深入到内存，链表实现了对零散内存的有效使用，内存在为链表分配空间的时候不用大段的连续空间；</li><li>从较高层，即抽象的层面看，链表仅仅是一批数据的拓扑结构之一，就常见的栈，队列，树，图等等，你还可以想出其他可能有用没用的，如，立体的结构，方块，金字塔形(emm这个像堆），还有随意的，感觉想到了矩阵里面的压缩。   </li></ul><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul><li>链表的应用：如</li><li>在文件中，对大文件的存储，采用类似链表的结构，</li><li>大数相加，像两个100位的整数相加，使用链表，每个块为一位，就可以解决这个问题，数组也行</li><li>倒排索引结构，在操作系统中用到，我的github上放着一个本科毕业设计做的简单搜索引擎，几乎全是自己搞的（解析网页那块自己c写了状态机，觉得效果不如beatifulsoup好，后面用它了),不过想想那会还不会很有意识的去想如果让它运行在大量用户下，各种使用条件（如输入条件下，会怎么样，年轻啊~)</li><li>其他，当然是其他数据结构基于链表做的，多了去了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据结构之线性表：&quot;&gt;&lt;a href=&quot;#数据结构之线性表：&quot; class=&quot;headerlink&quot; title=&quot;数据结构之线性表：&quot;&gt;&lt;/a&gt;数据结构之线性表：&lt;/h2&gt;&lt;h3 id=&quot;有序表：数组：&quot;&gt;&lt;a href=&quot;#有序表：数组：&quot; class=&quot;headerlink&quot; title=&quot;有序表：数组：&quot;&gt;&lt;/a&gt;有序表：数组：&lt;/h3&gt;&lt;h3 id=&quot;单链表：&quot;&gt;&lt;a href=&quot;#单链表：&quot; class=&quot;headerlink&quot; title=&quot;单链表：&quot;&gt;&lt;/a&gt;单链表：&lt;/h3&gt;&lt;p&gt;链表定义
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://xdksx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://xdksx.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>code_efficandreadable</title>
    <link href="http://xdksx.github.io/2018/05/26/code-efficandreadable/"/>
    <id>http://xdksx.github.io/2018/05/26/code-efficandreadable/</id>
    <published>2018-05-26T04:44:19.000Z</published>
    <updated>2018-05-26T22:32:47.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论代码的效率和可读性的权衡"><a href="#论代码的效率和可读性的权衡" class="headerlink" title="论代码的效率和可读性的权衡"></a>论代码的效率和可读性的权衡</h2><h4 id="高效代码可读性差："><a href="#高效代码可读性差：" class="headerlink" title="高效代码可读性差："></a>高效代码可读性差：</h4><p>有一些代码，占用额外内存小，即run in place，且执行的速度快，即复杂度O()低，但是可读性差，即使注释了，修改起来也容易出错，如：<br>对链表的操作：举一个leetcode的例子：(这个例子不是很典型，能说明问题即可）<br>    reverse a linklist from m to n;<br>    1-&gt;3-&gt;4-&gt;5-&gt;null and m,n(ex:2,4);<br>    return 1-&gt;5-&gt;4-&gt;2-&gt;null;<br>   上面例子一开始可以想到，头插法，或者将范围内的那一段用新的处理过的链表替换掉，即只需要处理该片段的头和尾部，当然可能还有其他方法，这里先不考虑；<br>   于是，头插法不是很复杂，但是在这里不用额外的内存时，需要频繁的改变next指针和对pre元素做临时保存，使得代码可读性差，所以可以考虑以下方案：<br>   在替换的内存小时，可以采用后者，让代码可读性高些，方便维护和（被替代~更容易被炒鱿鱼的风险哈哈)<br>   在内存小时，采用前者，爱怎么指怎么指，看不懂不管哈哈哈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;论代码的效率和可读性的权衡&quot;&gt;&lt;a href=&quot;#论代码的效率和可读性的权衡&quot; class=&quot;headerlink&quot; title=&quot;论代码的效率和可读性的权衡&quot;&gt;&lt;/a&gt;论代码的效率和可读性的权衡&lt;/h2&gt;&lt;h4 id=&quot;高效代码可读性差：&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="代码整洁" scheme="http://xdksx.github.io/categories/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81/"/>
    
    
      <category term="代码可读性" scheme="http://xdksx.github.io/tags/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>tcpip_mtu</title>
    <link href="http://xdksx.github.io/2018/05/20/tcpip-mtu/"/>
    <id>http://xdksx.github.io/2018/05/20/tcpip-mtu/</id>
    <published>2018-05-20T14:27:55.000Z</published>
    <updated>2018-05-20T22:40:11.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍：</p><h3 id="理论部分："><a href="#理论部分：" class="headerlink" title="理论部分："></a>理论部分：</h3><h4 id="１、MTU-Maximum-Transmission-Unit-如何定义"><a href="#１、MTU-Maximum-Transmission-Unit-如何定义" class="headerlink" title="１、MTU(Maximum Transmission Unit)如何定义:"></a>１、MTU(Maximum Transmission Unit)如何定义:</h4><ul><li>指的是通信协议中的某一层上面所能通过的最大数据包大小</li><li>这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？  <a id="more"></a><br>　答案是分片：举个例子：现在以太网的MTU为1500B，假设现从tcp层向ip层传输长度为3008B的数据报文，则该报文添加了io头后为3028B,3028B&gt;1500B，大于以太网一帧能承载的最大数据包（除了mac头),会做如下处理:<br>分片：ip净载荷：MTU-IP头：1500-20=1480;<br> 3008B 需要分为3片，3008=1480,1480,48<br>总结：MTU就是MAC承载的载荷的最大值  </li></ul><h4 id="2、MTU会影响什么"><a href="#2、MTU会影响什么" class="headerlink" title="2、MTU会影响什么:"></a>2、MTU会影响什么:</h4><ul><li>数据包太大-&gt;分片重组-&gt;网络性能变差  </li><li>数据包太小-&gt;一次能传输的数据小-&gt;网速差  </li><li>路径最大单元：在一条传输路径上能顺利传递的包是该路径上所有设备的MTU的最小值(RFC1191)　　</li></ul><h4 id="3、如何知道这个值呢？"><a href="#3、如何知道这个值呢？" class="headerlink" title="3、如何知道这个值呢？"></a>3、如何知道这个值呢？</h4><p>路径最大传输单元发现方法(RFC1191)　　</p><ul><li>越来越多设备的MTU不统一等,和封杀ICMP导致越来越不好去得到这个值。  </li><li>MTU设置太大会怎样?交换机可嫩直接丢掉这个包不回应或者路由器回复它的最大值和错误信息：<br>ping -c 3 -s 1474 -M do 192.168.0.1<br>PING 192.168.0.1 (192.168.0.1) 1474(1502) bytes of data.<br>ping: local error: Message too long, mtu=1500<br>提示错误即消息太大且未设置分片</li></ul><h4 id="4-MTU大小的来源"><a href="#4-MTU大小的来源" class="headerlink" title="4 MTU大小的来源:"></a>4 MTU大小的来源:</h4><p>ref <a href="https://www.zhihu.com/question/31460305/answer/183766816" target="_blank" rel="noopener">https://www.zhihu.com/question/31460305/answer/183766816</a><br>以太网传输帧的最小值：    </p><ul><li>最早的以太网工作方式：载波多路复用/冲突检测（CSMA/D），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。</li><li>假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs。在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，所以以太网帧的最小长度为64字节。  </li></ul><p>为什么标准以太网帧长度上限为1518字节?  </p><ul><li>IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms，这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。</li><li>由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 byte那有效传输效率= 160 / 218 = 73%而如果以太网长度为1518，那有效传输效率= 1460 / 1518 = 96%通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题.</li><li>于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。</li></ul><p>其他疑问：  </p><ul><li>最早的以太网是通过Hub或集线器来工作的，在任意时刻只能有一台主机发送，这种共享方式发送效率很低，而现代高速交换机则让每个连接交换机的主机工作在独占模式，带宽独享，可以同时收发，而且现在早已不是早期的10Mbps的带宽，而是1000M、10000M，即使发送大包也不会影响别的主机，影响的只是交换机的接收和发送队列，既然发送大包效率要比小包效率搞，而且特定的应用也有发大包的需求，比如NFS文件系统，那为什么不把接口MTU提高一些，再高一些呢？</li><li>这是一个好主意，于是网卡、交换机、路由器网络接口可以实现更大的MTU，可以达到&gt; 9000字节的大小，我们称这种远大于标准以太帧尺寸的帧为巨型帧Jumbo Frame 。于是网络接口提供可以修改MTU的配置命令，比如缺省为1500，可以修改为1508以支持QinQ，或者1512以支持802.1q Mpls label，这样既可以支持终端用户标准1500 字节IP packet，又可以避免分片。</li><li>有一点需要说明，二层交换机的接口，我们可以看成一块普通的网卡，网卡工作在数据链路层，所以分片不是它的职责，如果一个帧需要从交换机一个接口发送出去，而帧的长度&gt;接口MTU，怎么办？<br>丢弃！会发什么消息告诉源主机吧？不会的，默默地丢，当作什么都没有发生，这种情况最难以排查，如果traceroute可以看到端对端使通的，而发送数据就是会失败。</li><li>所以切记，一台交换机要保证接口MTU的一致性。如果在一个VLAN上、或整个交换机都采用同样的MTU，就不会发生上述情况。而如果入接口是9000字节，而出接口是1500，就会发生上述问题。如果一条物理链路的两端MTU不一致，则会发生什么情况，比如一侧是1500，一侧是9000，1500一侧发出来的数据肯定没有问题，但是如果从9000侧发给1500呢？数据也背默默地丢了。为什么呢？</li><li>我们来谈另外一个很少提及的词汇：MRU，最大接收单元。我们一直谈的最大传输单元MTU是关于出方向的流量处理，而MRU恰恰相反，是关于入方向的流量处理。一般情况下MTU = MRU，但比如9000侧的数据到达1500，由于9000 &gt; MRU，所以直接默默丢弃。所以在配置链路时，要确保两侧的设备MTU要匹配，无论各家厂商对MTU理解如何、实现如何，一定要保证两端匹配，即各自允许在以太网线上发送、接收的数据流，以太网帧的最大长度一样<h3 id="实践部分："><a href="#实践部分：" class="headerlink" title="实践部分："></a>实践部分：</h3>如何设置MTU：<br>ifconfig eth0 mtu 1460<br>如何查看mtu:<br>netstat -i</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MTU&quot;&gt;&lt;a href=&quot;#MTU&quot; class=&quot;headerlink&quot; title=&quot;MTU&quot;&gt;&lt;/a&gt;MTU&lt;/h1&gt;&lt;p&gt;这是一篇关于MTU的介绍文章，MTU是MAC层中数据包的最大值，下面通过这几个部分来介绍：&lt;/p&gt;
&lt;h3 id=&quot;理论部分：&quot;&gt;&lt;a href=&quot;#理论部分：&quot; class=&quot;headerlink&quot; title=&quot;理论部分：&quot;&gt;&lt;/a&gt;理论部分：&lt;/h3&gt;&lt;h4 id=&quot;１、MTU-Maximum-Transmission-Unit-如何定义&quot;&gt;&lt;a href=&quot;#１、MTU-Maximum-Transmission-Unit-如何定义&quot; class=&quot;headerlink&quot; title=&quot;１、MTU(Maximum Transmission Unit)如何定义:&quot;&gt;&lt;/a&gt;１、MTU(Maximum Transmission Unit)如何定义:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;指的是通信协议中的某一层上面所能通过的最大数据包大小&lt;/li&gt;
&lt;li&gt;这里指mac层上面能通过的IP分组的最大值；我们知道，在tcp层传输数据的时候，在未指定上层使用http协议时，可以发送任何大小的数据。数据到了ip层时，需要加上ip头然后传递到mac层去加mac头，那在这个传递的过程中，包是不是越大越好，会做什么处理？
    
    </summary>
    
      <category term="tcpip" scheme="http://xdksx.github.io/categories/tcpip/"/>
    
    
      <category term="tcpip_mac" scheme="http://xdksx.github.io/tags/tcpip-mac/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://xdksx.github.io/2018/05/20/hello-world/"/>
    <id>http://xdksx.github.io/2018/05/20/hello-world/</id>
    <published>2018-05-20T12:26:14.469Z</published>
    <updated>2018-05-19T23:06:46.437Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cpp_debug_layout_static</title>
    <link href="http://xdksx.github.io/2018/05/20/cpp-debug-layout-static/"/>
    <id>http://xdksx.github.io/2018/05/20/cpp-debug-layout-static/</id>
    <published>2018-05-20T10:54:58.000Z</published>
    <updated>2018-05-20T20:35:59.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-compile-time-memory-layout"><a href="#c-compile-time-memory-layout" class="headerlink" title="c compile time memory layout"></a>c compile time memory layout</h3><p>　　标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法：</p><p>　　概述：首先介绍几个概念：<a id="more"></a><br>　　程序从源代码编译之后，即经过预处理，编译，汇编，连接的过程后生成一个可执行程序，在linux为elf,此时程序还是静态的，没有被执行，可以说是编译期或者静态的时候；<br>　　当程序在终端被运行，此时会将pc指向main开始执行程序，并一步一步根据程序需要分配内存，栈区，堆区等等，此时为动态期；成为进程或线程；<br>      注意：c语言经过词法分析语法分析等，期间有符号表等的生成（可能存储着和struct，class和定义的类型基本类型等信息），之后生成汇编语言代码不会体现类型信息如无法在其中见到struct的定义代码，并且char定义的变量的值被转化为ASICC码　。汇编代码中体现struct的只有其变量的偏移等等；至于它如何知道，是通过符号表得到的，但是啊生成汇编后不需要符号表了。。汇编执行的过程中并无太多变量相关的内容，之后将变量的值存入某个内存位置的语句；</p><p>　　本文主要探索通过linux下的工具如size gdb等深入学习c程序静态和动态下在内存中的分布和执行情况，以进一步理解c</p><p>前言：<br>一个源代码通过编译后生成一个目标文件.o它是一个elf　relocatable文件,以下.o文件指此类，elf文件为executable文件<br>.o文件(elf)文件的结构： 通过objdump -h xx.o可以查看到</p><pre><code>other data  ....comment    offset 0x000000c6..rodata      ...　　　//const &amp; str 常量.data.text.elf header</code></pre><p>一个elf文件的结构是这样的：可以通过readelf来看：<br>    　　　　　　　　elfheader　　　　　　　　文件头包含了平台信息：/usr/include/elf.h<br>            .text　　　　　　　　　　　　段表　各个段：应用程序也可以自己定义段，和指定变量在哪个段<br>            .data<br>            .bss<br>            ..<br>            other sections<br>            section header table　　　　<br>            string tables　　　　　　　　重定位表和字符串表<br>            symbol tables　　　　　　　　 符号表是链接的接口<br> 符号表是链接的接口：符号修饰和函数有很大关系，涉及调用的，其中c的符号比较简单，c++为了冲突处理，采用了命名空间，又包含类，所以符号比较复杂<br> 可以通过readelf -s　xx.o查看；且加了签名机制，将函数名又做进一步转换（类似乱码），减少冲突<br>  强符号和弱符号（强引用和若引用），调试信息　－g<br> 扩展：<br> １）比如应用程序可以增加非系统保留字的段如：添加一个music段：当elf运行起来后可以读取这个段播放音乐；但是自定义的段名不能使用.作为前缀；<br> 如objcopy工具将图片段加入：objcopy -I binary -O elf32-i386 -B  i386 image.jpg image.o<br>   objdump -ht image.o<br>   可以看到图片在内存中的起始地址等，可以在程序中直接声明后使用他们<br>   具体看文档<br>２）自定义段：<strong>attribute</strong>((section(“FOO”))) int global=24;<br>           <strong>attribute</strong>((section(“BAR”))) void  foo(){}  既可以把变量或函数放入该段中　段名：BAR FOO</p><p>正文：</p><h4 id="0、先从几个命令："><a href="#0、先从几个命令：" class="headerlink" title="0、先从几个命令："></a>0、先从几个命令：</h4><p>1)size filename:查看elf或.o文件中各个段大小：<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o<br>　　代码段　　　数据段　　<br>代码段：只读，可共享，代码中的常量数据在编译时在代码段中分配空间，如int x=3;中的3及const 声明的常量和字符串常量 ,其他数据只引用地址<br>数据段：为全局初始化数据区和静态数据区：已经初始化的全局变量和静态变量（全局和局部）<br>bss:为初始化数据取，存放为初始化的全局变量和静态变量，但在开始执行时会被内核赋值０或null</p><p>2)其他工具：<br> readelf -a simplest.o<br> 可以看到更清楚的段信息<br> objdump -t simplest<br> objdump -h simplest.o   替代size可以看到更多信息</p><p>此时显示出来的一些地址并不是装载后的地址</p><p>objdump -s -d xx.o:　　-s 16进制，-d反汇编　　－－－查看代码段<br>objdump -s -x -d xx.o:   –查看数据段和rodata</p><p>3)查看目标文件文件属性如relocatable –.o/executable –elf/share object –.so..<br> file xxx</p><h4 id="１、从最简单的程序开始：simplest-c"><a href="#１、从最简单的程序开始：simplest-c" class="headerlink" title="１、从最简单的程序开始：simplest.c"></a>１、从最简单的程序开始：simplest.c</h4><pre><code>int main(){   return 0;}</code></pre><p>将它进行预处理：gcc -E simplest.c 可以看到没有引用到其他头文件：</p><pre><code># 1 &quot;simplest.c&quot;# 1 &quot;&lt;built-in&gt;&quot;# 1 &quot;&lt;command-line&gt;&quot;# 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4# 1 &quot;&lt;command-line&gt;&quot; 2# 1 &quot;simplest.c&quot;int main() {  return 0; }</code></pre><p>将它进行汇编：gcc -S simplest.c<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p><p>生成.o文件：gcc -c simplest.c<br>并通过file xx.o查看类型<br>simplest.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</p><p>通过size 查看各个段：<br>size simplest.o:  可以看到只有代码段，数据为空，bss为空，是比较纯净的</p><p>text       data        bss        dec        hex    filename<br>     67          0          0         67         43    simplest.o</p><p>接着编译成elf:gcc -o simplest simplest.c<br>file simplest<br>simplest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,<br>interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=<br>56beff50d6dfd6d435c9556630737121d59c1cc7, not stripped<br>可以看到连接器等信息</p><p>size simplest<br>  text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest<br>注意这里的和.o的文件大小和分段不同，</p><h4 id="２、加入头文件和局部变量"><a href="#２、加入头文件和局部变量" class="headerlink" title="２、加入头文件和局部变量"></a>２、加入头文件和局部变量</h4><pre><code>#include&lt;stdio.h&gt;int main(){  int locala;  int localb=3;  return 0;  }</code></pre><p>进行gcc -E simplest.c会看到很多导入的部分，从输出可以看到头文件的位置和引入的函数<br>汇编，可以看到分配３到内存中<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p><p>　　生成.o文件：可以看到未改变data和bss,但是代码段变大<br>  text       data        bss        dec        hex    filename<br>     74          0          0         74         4a    simplest.o</p><p>生成elf:数据区和bss未改变，代码段也未改变？<br> text       data        bss        dec        hex    filename<br>   1099        544          8       1651        673    simplest</p><h4 id="３、加入已经初始化的局部静态变量："><a href="#３、加入已经初始化的局部静态变量：" class="headerlink" title="３、加入已经初始化的局部静态变量："></a>３、加入已经初始化的局部静态变量：</h4><pre><code>int main(){ static int statica=3;..}</code></pre><p>看生成的汇编：<br>        .file    “simplest.c”<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2285, @object　//新加的段<br>        .size    statica.2285, 4<br>    statica.2285:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p><p>.o大小：在静态数据区增加了，４　１个int的长度<br> text       data        bss        dec        hex    filename<br>     74          4          0         78         4e    simplest.o</p><p>elf:有点费解，。。<br> text       data        bss        dec        hex    filename<br>   1099        548          4       1651        673    simplest</p><h4 id="４、加入已经初始化的全局变量和全局静态变量"><a href="#４、加入已经初始化的全局变量和全局静态变量" class="headerlink" title="４、加入已经初始化的全局变量和全局静态变量"></a>４、加入已经初始化的全局变量和全局静态变量</h4><pre><code>int golbala=6;    　static long gs=12;</code></pre><p>生成的汇编<br>        .file    “simplest.c”<br>        .globl    golbala<br>        .data<br>        .align 4<br>        .type    golbala, @object<br>        .size    golbala, 4<br>    golbala://变量名<br>        .long    6<br>        .align 8<br>        .type    gs, @object<br>        .size    gs, 8<br>    gs://变量名<br>        .quad    12<br>        .text<br>        .globl    main<br>        .type    main, @function<br>    main:<br>    .LFB0:<br>        .cfi_startproc<br>        pushq    %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    $3, -4(%rbp)<br>        movl    $0, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>    .LFE0:<br>        .size    main, .-main<br>        .data<br>        .align 4<br>        .type    statica.2287, @object<br>        .size    statica.2287, 4<br>    statica.2287:<br>        .long    3<br>        .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>        .section    .note.GNU-stack,””,@progbits</p><p>size : 从４变到20:一个long 和int 4+4齐（见汇编）+8（long)+4=20<br>      text       data        bss        dec        hex    filename<br>       74         20          0         94         5e    simplest.o</p><p>elf size:548–&gt;564  16<br>  text       data        bss        dec        hex    filename<br>   1099        564          4       1667        683    simplest</p><h4 id="5-将-int-golbala-6"><a href="#5-将-int-golbala-6" class="headerlink" title="5 将 　　int golbala=6;"></a>5 将 　　int golbala=6;</h4><pre><code>　static long gs=12;　　倒换位置！！！！！！！！！</code></pre><p> 则对齐成：size x.o为：１６比原来小，可以用于节省内存：<br>   text       data        bss        dec        hex    filename<br>     74         16          0         90         5a    simplest.o<br>　　汇编：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2287, @object<br>    .size    statica.2287, 4<br>statica.2287:<br>    .long    3<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits<br>elf文件的也变小：但bss变大，费解。。<br> text       data        bss        dec        hex    filename<br>   1099        560          8       1667        683    simplest</p><h4 id="6、加入未初始化的全局变量和全局与局部静态变量"><a href="#6、加入未初始化的全局变量和全局与局部静态变量" class="headerlink" title="6、加入未初始化的全局变量和全局与局部静态变量"></a>6、加入未初始化的全局变量和全局与局部静态变量</h4><pre><code>  1 #include&lt;stdio.h&gt;    2 static long gs=12;    3 int golbala=6;    4          5         6 static long gsl;    7 int gi;    8 int main()    9 {      10      static int staticn;11      static int statica=3;   12      int locala;   13      int localb=3;   14      return 0;   15 }</code></pre><p>汇编没有看到什么变化：<br>    .file    “simplest.c”<br>    .data<br>    .align 8<br>    .type    gs, @object<br>    .size    gs, 8<br>gs:<br>    .quad    12<br>    .globl    golbala<br>    .align 4<br>    .type    golbala, @object<br>    .size    golbala, 4<br>golbala:<br>    .long    6<br>    .local    gsl<br>    .comm    gsl,8,8<br>    .comm    gi,4,4<br>    .text<br>    .globl    main<br>    .type    main, @function<br>main:<br>.LFB0:<br>    .cfi_startproc<br>    pushq    %rbp<br>    .cfi_def_cfa_offset 16<br>    .cfi_offset 6, -16<br>    movq    %rsp, %rbp<br>    .cfi_def_cfa_register 6<br>    movl    $3, -4(%rbp)<br>    movl    $0, %eax<br>    popq    %rbp<br>    .cfi_def_cfa 7, 8<br>    ret<br>    .cfi_endproc<br>.LFE0:<br>    .size    main, .-main<br>    .data<br>    .align 4<br>    .type    statica.2290, @object<br>    .size    statica.2290, 4<br>statica.2290:<br>    .long    3<br>    .local    staticn.2289<br>    .comm    staticn.2289,4,4<br>    .ident    “GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609”<br>    .section    .note.GNU-stack,””,@progbits</p><p>.o文件：+12 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>     74         16         12        102         66    simplest.o</p><p>elf:+16 未包含未初始化的全局变量<br>text       data        bss        dec        hex    filename<br>   1099        560         24       1683        693    simplest</p><p>至此分析完c程序静态下各个段的大小。在执行时才会有堆和栈的出现；链接前后大小也不同</p><p>参考：程序员的自我修养</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;c-compile-time-memory-layout&quot;&gt;&lt;a href=&quot;#c-compile-time-memory-layout&quot; class=&quot;headerlink&quot; title=&quot;c compile time memory layout&quot;&gt;&lt;/a&gt;c compile time memory layout&lt;/h3&gt;&lt;p&gt;　　标题：从一个简单的程序开始，介绍几种间接或直接debug出c程序内存布局的方法：&lt;/p&gt;
&lt;p&gt;　　概述：首先介绍几个概念：
    
    </summary>
    
      <category term="c&amp;cpp" scheme="http://xdksx.github.io/categories/c-cpp/"/>
    
    
      <category term="cpp_memory" scheme="http://xdksx.github.io/tags/cpp-memory/"/>
    
  </entry>
  
  <entry>
    <title>cpp_debug_layout_dynamic</title>
    <link href="http://xdksx.github.io/2018/05/20/cpp-debug-layout-dynamic/"/>
    <id>http://xdksx.github.io/2018/05/20/cpp-debug-layout-dynamic/</id>
    <published>2018-05-20T10:33:09.000Z</published>
    <updated>2018-05-22T00:06:55.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c执行期内存布局和调试："><a href="#c执行期内存布局和调试：" class="headerlink" title="c执行期内存布局和调试："></a>c执行期内存布局和调试：</h3><p>在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等<br>１、将目标文件装入: <a id="more"></a><br><em>１）重定位－－－　放在内存哪里<br> 2)  等待调度执行</em><br>这里可以使用gdb进行调试查看</p><p>一个进程是一个运行着的程序段，一个程序有可能有多个进程在运行（程序中fork).<br>一个进程主要包括：<br>   在内存中申请的空间，代码（加载的程序段，包括代码段，数据段和bss).堆，栈，以及内核进程信息结构task_struct，打开的文件，上下文信息和挂起的信号等</p><blockquote><p>栈区　　高地址到低地址<br>堆区　　低地址到高地址<br>bss<br>数据<br>代码</p></blockquote><p> 以下将从两个维度进行对一个程序被执行成进程时，内存的情况：<br> １、各种段区的内存分布<br> ２、gdb 调试程序执行时的过程。－－可能涉及到汇编<br> －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p><h4 id="1、gdb-常用的命令和用法："><a href="#1、gdb-常用的命令和用法：" class="headerlink" title="1、gdb　常用的命令和用法："></a>1、gdb　常用的命令和用法：</h4><p>1)通过gcc 编译出带调试信息的程序：gcc -o gdbtest gdbtest.c -g 回车重复上一次命令<br> 2)设置断点：　<br>b 行号<br>b 函数名<br>b 行号　if 条件<br>eg:<br>break main  /  b main<br>  删除断点:delete 行号</p><p>3)列出代码<br>l /list</p><p>4)运行，start<br>  跳转到断点:c/continue   r/run<br>  until  行号　　　运行直到该行<br>5)观察变量b和地址<br>watch b  若变量值发生变化，则程序停止</p><p>　p/print  b  看变量值<br>　p/print &amp;b　看变量地址<br> i  locals</p><p> info registers 显示所有寄存器的值<br> 查看特定内存位置的值如：<br> print/x $eax   显示为16进制<br> print/t  2进制，　<br> print/d 十进制,<br>x/nyz  : n表示字段数，y为输出格式，z是字段长度</p><p>６）单步调试<br> n/next   /   s/step　</p><p> 7) 保存断点：<br> info b  查看断点信息<br> save breakpoint fig.dp 保存断点<br> 读取断点文件：　gdb hello -x fig.dp</p><p> 退出quit</p><p> <a href="http://bbs.chinaunix.net/thread-150524-1-1.html" target="_blank" rel="noopener">http://bbs.chinaunix.net/thread-150524-1-1.html</a></p><h4 id="2-使用kdbg"><a href="#2-使用kdbg" class="headerlink" title="2 使用kdbg"></a>2 使用kdbg</h4><p> 界面版本gdb  在gcc … -g后，用kdbg打开即可、<br> 查看程序运行时各个地址：<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHW_ADR(ID,I) printf(<span class="meta-string">"the id %s \t is at adr:%8X\n"</span>,ID,&amp;I);</span></span><br><span class="line"><span class="keyword">extern</span> etext,edata,end;</span><br><span class="line"><span class="keyword">char</span> *cptr=<span class="string">"Hello World\n"</span>;</span><br><span class="line"><span class="keyword">char</span> buffer1[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showit</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Adr etext:%8x\tAdr edata:%8x \t Adr end :%8x \n\n"</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class="line">SHW_ADR(<span class="string">"main"</span>,main);</span><br><span class="line">SHW_ADR(<span class="string">"showit"</span>,showit);</span><br><span class="line">SHW_ADR(<span class="string">"cptr"</span>,cptr);</span><br><span class="line">SHW_ADR(<span class="string">"buffer1"</span>,buffer1);</span><br><span class="line">SHW_ADR(<span class="string">"i"</span>,i);</span><br><span class="line"><span class="built_in">strcpy</span>(buffer1,<span class="string">"A demonstration\n"</span>);</span><br><span class="line">write(<span class="number">1</span>,buffer1,<span class="built_in">strlen</span>(buffer1)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">1</span>;++i)</span><br><span class="line">showit(cptr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showit</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *buffer2;</span><br><span class="line">SHW_ADR(<span class="string">"buffer2"</span>,buffer2);</span><br><span class="line"><span class="keyword">if</span>((buffer2=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>((<span class="keyword">unsigned</span>)(<span class="built_in">strlen</span>(p)+<span class="number">1</span>)))!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buffer2,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,buffer2);</span><br><span class="line"><span class="built_in">free</span>(buffer2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Allocation error.\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;alloca.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">afunc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> etext,edata,end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bss_var;<span class="comment">//no init globel data must be in bss</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data_var=<span class="number">42</span>;<span class="comment">//init globel data must be in data</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHW_ADR(ID,I) printf(<span class="meta-string">"the %8s\t is at adr:%8x\n"</span>,ID,&amp;I);<span class="comment">//the macro to printf the addr</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p,*b,*nb;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Adr etext:%8x\t Adr edata %8x\t Adr end %8x\t\n"</span>,&amp;etext,&amp;edata,&amp;end);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\ntext Location:\n"</span>);</span><br><span class="line">SHW_ADR(<span class="string">"main"</span>,main);<span class="comment">//text section function</span></span><br><span class="line">SHW_ADR(<span class="string">"afunc"</span>,afunc);<span class="comment">//text section function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nbss Location:\n"</span>);</span><br><span class="line">SHW_ADR(<span class="string">"bss_var"</span>,bss_var);<span class="comment">//bss section var</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\ndata location:\n"</span>);</span><br><span class="line">SHW_ADR(<span class="string">"data_var"</span>,data_var);<span class="comment">//data section var</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nStack Locations:\n"</span>);</span><br><span class="line">afunc();</span><br><span class="line"></span><br><span class="line">p=(<span class="keyword">char</span> *)alloca(<span class="number">32</span>);<span class="comment">//alloc memory from statck</span></span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">SHW_ADR(<span class="string">"start"</span>,p);</span><br><span class="line">SHW_ADR(<span class="string">"end"</span>,p+<span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">32</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//malloc memory from heap</span></span><br><span class="line">nb=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">16</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nHeap Locations:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the Heap start: %p\n"</span>,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the Heap end:%p\n"</span>,(nb+<span class="number">16</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nb and nb in Stack\n"</span>);</span><br><span class="line">SHW_ADR(<span class="string">"b"</span>,b);</span><br><span class="line">SHW_ADR(<span class="string">"nb"</span>,nb);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(nb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afunc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">long</span> level=<span class="number">0</span>;<span class="comment">//data section static var</span></span><br><span class="line"><span class="keyword">int</span> stack_var;<span class="comment">//temp var ,in stack section</span></span><br><span class="line"><span class="keyword">if</span>(++level==<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">SHW_ADR(<span class="string">"stack_var in stack section"</span>,stack_var);</span><br><span class="line">SHW_ADR(<span class="string">"Level in data section"</span>,level);</span><br><span class="line">afunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;c执行期内存布局和调试：&quot;&gt;&lt;a href=&quot;#c执行期内存布局和调试：&quot; class=&quot;headerlink&quot; title=&quot;c执行期内存布局和调试：&quot;&gt;&lt;/a&gt;c执行期内存布局和调试：&lt;/h3&gt;&lt;p&gt;在生成目标文件后，还没被执行时还是一个静态文件，当被执行时，可能会进行，动态链接等&lt;br&gt;１、将目标文件装入:
    
    </summary>
    
      <category term="c&amp;cpp" scheme="http://xdksx.github.io/categories/c-cpp/"/>
    
    
      <category term="cpp_memory" scheme="http://xdksx.github.io/tags/cpp-memory/"/>
    
  </entry>
  
  <entry>
    <title>android_jni</title>
    <link href="http://xdksx.github.io/2018/05/20/android-jni/"/>
    <id>http://xdksx.github.io/2018/05/20/android-jni/</id>
    <published>2018-05-20T09:53:27.000Z</published>
    <updated>2018-05-20T20:37:59.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="a-example-of-JNI-static-way"><a href="#a-example-of-JNI-static-way" class="headerlink" title="a example of JNI static way:"></a>a example of JNI static way:</h3><h4 id="first-step-write-a-middle-java-file"><a href="#first-step-write-a-middle-java-file" class="headerlink" title="first step: write a middle java file:"></a>first step: write a middle java file:</h4><p>mkdir jni<br>cd jni/<a id="more"></a><br>vim TestJni.java</p><pre><code>import java.util.*;public class TestJni{    public native void xprint(String content);    static    {        System.loadLibrary(&quot;TestJni&quot;);    }}</code></pre><p>  javac TestJni.java  and make a class</p><p>then<br>  javah -jni TestJni  to make a .h file:</p><pre><code>  /* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class TestJni */#ifndef _Included_TestJni#define _Included_TestJni#ifdef __cplusplusextern &quot;C&quot; {#endif/* * Class:     TestJni * Method:    xprint * Signature: (Ljava/lang/String;)V */JNIEXPORT void JNICALL Java_TestJni_xprint  (JNIEnv *, jobject, jstring);#ifdef __cplusplus}#endif#endif</code></pre><h4 id="step-two-write-jni-file-c"><a href="#step-two-write-jni-file-c" class="headerlink" title="step two write jni file.c:"></a>step two write jni file.c:</h4><p>TestJni.c:</p><pre><code>#include&lt;jni.h&gt;#include&lt;stdio.h&gt;#include &quot;TestJni.h&quot;JNIEXPORT void JNICALL Java_TestJni_xprint(JNIEnv *env,jobject obj,jstring content){    const jbyte *str=(const jbyte*)(*env)-&gt;GetStringUTFChars(env,content,JNI_FALSE);    printf(&quot;hello--wo%s \n&quot;,str);    (*env)-&gt;ReleaseStringUTFChars(env,content,(const char*)str);    return;}</code></pre><h4 id="three-build-so-lib"><a href="#three-build-so-lib" class="headerlink" title="three build .so lib"></a>three build .so lib</h4><pre><code>cc -I/usr/jdk-8/include/ -I/usr/jdk-8/include/linux/ -I .../jni/ -fPIC -shared -o libTestJni.so TestJni.c</code></pre><h4 id="four-write-a-test-hellow-java"><a href="#four-write-a-test-hellow-java" class="headerlink" title="four write a test:hellow.java"></a>four write a test:hellow.java</h4><pre><code>import java.util.*;public class hellow{    public static void main(String argc[])    {         new hellow();    }    public hellow()    {        new TestJni().xprint(&quot;hi my name is keee&quot;);    }}</code></pre><h4 id="question"><a href="#question" class="headerlink" title="question:"></a>question:</h4><p>如果你这步发生问题，如果这步你收到java.lang.UnsatisfiedLinkError异常，可以通过如下方式指明共享库的路径：</p><p>java -Djava.library.path=’.’ HelloWorld<br>或者输入命令：<br>export LD_LIBRARY_PATH=“HelloWorld路径”:$LD_LIBRARY_PATH   设置环境变量</p><p>然后再 java HelloWorld 一样OK</p><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html" target="_blank" rel="noopener">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br><a href="http://www.cnblogs.com/wzben/p/5733571.html" target="_blank" rel="noopener">http://www.cnblogs.com/wzben/p/5733571.html</a></p><h3 id="a-example-of-JNI-dynamic-way"><a href="#a-example-of-JNI-dynamic-way" class="headerlink" title="a example of JNI dynamic way:"></a>a example of JNI dynamic way:</h3><h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1:"></a>step 1:</h4><p>write a TestJni.java</p><pre><code>public class SimpleJni{    static {        System.out.println(&quot;[java] static code block,start load shared library...&quot;);        System.loadLibrary(&quot;SimpleJni&quot;);        System.out.println(&quot;[java]load library end...&quot;);    }    static native int add(int a,int b);    public static void main(String args[])    {        System.out.println(&quot;[java] in main...&quot;);        System.out.println(&quot;[java] 3+4=&quot;+SimpleJni.add(3,4));        System.out.println(&quot;end...&quot;);    }}</code></pre><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2:"></a>step 2:</h4><p>write a Jni file:</p><pre><code>#include &lt;jni.h&gt;#include&lt;stdio.h&gt;const char *classPathName=&quot;com/bt/jni/SimpleJni&quot;;jint myadd(JNIEnv *env,jobject thiz,jint a,jint b){    return a+b;}static JNINativeMethod methods[]={    {&quot;add&quot;,&quot;(II)I&quot;,(void*)myadd},};int registerNatives(JNIEnv *env){    jclass clazz;    clazz=(*env)-&gt;FindClass(env,classPathName);    if(NULL==clazz){       printf(&quot;[C] FindClass fail\n&quot;);       goto failed;    }     if (0&gt;(*env)-&gt;RegisterNatives(env,clazz,methods,sizeof(methods)/sizeof(methods[0]))){         printf(&quot;RegisterNatives fail.\n&quot;);         goto failed;     }     return JNI_TRUE;failed:     return JNI_FALSE;}jint JNI_OnLoad(JavaVM *vm,void *reserved){    JNIEnv *env=NULL;    jint result=-1;    void **env_p=NULL;    printf(&quot;start register native func\n&quot;);    env_p=(void**)&amp;env;    if(JNI_OK!=(*vm)-&gt;GetEnv(vm,env_p,0x00010006)){        printf(&quot;get env failed..\n&quot;);        goto err;    }    if(JNI_TRUE!=registerNatives(env)){        printf(&quot;register fail...exit....\n&quot;);        goto err;    }    result=0x00010006;err:    return result;}</code></pre><h4 id="step-use"><a href="#step-use" class="headerlink" title="step use:"></a>step use:</h4><p>1.首先编写SimpleJni.java和simpel_jni.c<br>    2.编译java和c文件<br>$ java -d .  SimpleJni.java<br>$gcc -fPIC -I$JAVA_HOME/include/ -I$JAVA_HOME/include/linux/ -o libsimpleJni.so simple_jni.c</p><pre><code>3.执行$java -Djava.library.path=. com.bt.jni.SimpleJni</code></pre><h4 id="other-example"><a href="#other-example" class="headerlink" title="other example:"></a>other example:</h4><p>java file:<br>    import java.util.*;<br>    public class TestJni<br>    {<br>        public native void xprint(String content);<br>        static<br>        {<br>            System.loadLibrary(“TestJni”);<br>        }<br>        public native static String native_hello();<br>    }</p><p>JNI file:</p><pre><code>#include&lt;jni.h&gt;#include&lt;stdio.h&gt;//#include &quot;TestJni.h&quot;#include&lt;iostream&gt;using namespace std; void xprint(JNIEnv *env,jobject obj,jstring content){  //    const jbyte *str=(const jbyte*)(env-&gt;GetStringUTFChars(env,content,JNI_FALSE));    //printf(&quot;hello--wo%s \n&quot;,str);//    env-&gt;ReleaseStringUTFChars(env,content,(const char*)str);        cout&lt;&lt;&quot;here:&quot;&lt;&lt;content&lt;&lt;endl;    return;}static jstring  native_hello(JNIEnv *env,jobject object){     return (env)-&gt;NewStringUTF(&quot;keshixi&quot;);}static JNINativeMethod method_table[]={    { &quot;xprint&quot;,&quot;(Ljava/lang/String;)V&quot;,(void*)xprint},    {&quot;native_hello&quot;,&quot;()Ljava/lang/String;&quot;,(void*)native_hello}//    {,,(void*)xprint},{,,(void*)native_hello}}; jint JNI_OnLoad(JavaVM *jvm,void *reserved){    JNIEnv *env;    if(jvm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_6)!=JNI_OK){        return -1;    }    jclass clz=env-&gt;FindClass(&quot;TestJni&quot;);    if(clz==NULL)    {        return JNI_FALSE;    }    if(env-&gt;RegisterNatives(clz,method_table,sizeof(method_table)/sizeof(method_table[0]))==JNI_OK){        return JNI_VERSION_1_6;    }  }</code></pre><p>####reference:<br>jni有两种使用方式，一种是静态注册的，依赖于头文件的。另一种是动态注册的不依赖头文件，静态的看里面文件夹的实例和博客就行</p><p>动态方式也可以参见dy文件夹下的网页教程，以及对应的两个例子</p><p>另外可以作为ndk在android中使用及在android　stdio也可以直接生成so</p><p>一些链接：android_jni_ndk:<a href="http://www.cnblogs.com/wzben/p/5733571.html" target="_blank" rel="noopener">http://www.cnblogs.com/wzben/p/5733571.html</a><br>动态注册无运行实例：<a href="http://www.linuxidc.com/Linux/2017-02/140130.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2017-02/140130.htm</a><br>静态注册：<a href="http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html" target="_blank" rel="noopener">http://www.cnblogs.com/bastard/archive/2012/05/17/2506877.html</a><br>动态注册：有实例<a href="http://www.linuxidc.com/Linux/2017-02/140129.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2017-02/140129.htm</a></p><p><a href="http://www.fer.unizg.hr/_download/repository/jni.pdf文档" target="_blank" rel="noopener">www.fer.unizg.hr/_download/repository/jni.pdf文档</a>    </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;a-example-of-JNI-static-way&quot;&gt;&lt;a href=&quot;#a-example-of-JNI-static-way&quot; class=&quot;headerlink&quot; title=&quot;a example of JNI static way:&quot;&gt;&lt;/a&gt;a example of JNI static way:&lt;/h3&gt;&lt;h4 id=&quot;first-step-write-a-middle-java-file&quot;&gt;&lt;a href=&quot;#first-step-write-a-middle-java-file&quot; class=&quot;headerlink&quot; title=&quot;first step: write a middle java file:&quot;&gt;&lt;/a&gt;first step: write a middle java file:&lt;/h4&gt;&lt;p&gt;mkdir jni&lt;br&gt;cd jni/
    
    </summary>
    
      <category term="android" scheme="http://xdksx.github.io/categories/android/"/>
    
    
      <category term="android_coding" scheme="http://xdksx.github.io/tags/android-coding/"/>
    
  </entry>
  
  <entry>
    <title>android_adb</title>
    <link href="http://xdksx.github.io/2018/05/20/android-adb/"/>
    <id>http://xdksx.github.io/2018/05/20/android-adb/</id>
    <published>2018-05-20T09:50:14.000Z</published>
    <updated>2018-05-20T20:37:16.274Z</updated>
    
    <content type="html"><![CDATA[<h4 id="android-adb-command"><a href="#android-adb-command" class="headerlink" title="android adb command"></a>android adb command</h4><p>从android群英传中学习到额外的几个adb指令，是之前没接触到的：<br>adb list targets<br>adb install -r　xx.apk -r为覆盖<br>adb shell df<br><a id="more"></a><br>adb shell pm list packages -f<br>adb shell input keyevent 3　　－－模拟按键输入，这里为点击home建<br>adb shell touchscreen ..模拟滑动<br>adb shell dumpsys 监听Activity运行状态<br>adb shell screenrecord /sdcard/demo.mp4  录制　屏幕<br>adb shell am start -n 包名/包名＋类名</p><p>更多，见google　develop中android studio的部分<br>另在源码目录中/system/core/toolbox  和/frameworks/base/cmds为所有ADB命令和shell命令来源</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;android-adb-command&quot;&gt;&lt;a href=&quot;#android-adb-command&quot; class=&quot;headerlink&quot; title=&quot;android adb command&quot;&gt;&lt;/a&gt;android adb command&lt;/h4&gt;&lt;p&gt;从android群英传中学习到额外的几个adb指令，是之前没接触到的：&lt;br&gt;adb list targets&lt;br&gt;adb install -r　xx.apk -r为覆盖&lt;br&gt;adb shell df&lt;br&gt;
    
    </summary>
    
      <category term="android" scheme="http://xdksx.github.io/categories/android/"/>
    
    
      <category term="android_make" scheme="http://xdksx.github.io/tags/android-make/"/>
    
  </entry>
  
  <entry>
    <title>android_AndroidManifest</title>
    <link href="http://xdksx.github.io/2018/05/20/android-AndroidManifest/"/>
    <id>http://xdksx.github.io/2018/05/20/android-AndroidManifest/</id>
    <published>2018-05-20T09:46:34.000Z</published>
    <updated>2018-05-20T20:37:33.414Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一个典型的androidmanifest文件："><a href="#一个典型的androidmanifest文件：" class="headerlink" title="一个典型的androidmanifest文件："></a>一个典型的androidmanifest文件：</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.example.ksx.helloworld&quot;&gt;&lt;!-- more --&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;hallo&quot;//app的名字和显示在bar上的文字        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;activity android:name=&quot;.MainActivity&quot;&gt;//活动的注册        &lt;android:label=&quot;this is hallo&quot;&gt;//会覆盖上面的            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;//声明为主活动                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一个典型的androidmanifest文件：&quot;&gt;&lt;a href=&quot;#一个典型的androidmanifest文件：&quot; class=&quot;headerlink&quot; title=&quot;一个典型的androidmanifest文件：&quot;&gt;&lt;/a&gt;一个典型的androidmanif
      
    
    </summary>
    
      <category term="android" scheme="http://xdksx.github.io/categories/android/"/>
    
    
      <category term="android_coding" scheme="http://xdksx.github.io/tags/android-coding/"/>
    
  </entry>
  
  <entry>
    <title>android_makefirst_app</title>
    <link href="http://xdksx.github.io/2018/05/20/android-makefirst-app/"/>
    <id>http://xdksx.github.io/2018/05/20/android-makefirst-app/</id>
    <published>2018-05-20T09:38:24.000Z</published>
    <updated>2018-05-20T20:38:13.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="install-and-make-first-app"><a href="#install-and-make-first-app" class="headerlink" title="install and make first app"></a>install and make first app</h3><p>20170608<br>今天主要是安装了android-studio环境并成功开发第一个helloworld   app 在模拟器和手机上运行，下面是整个教程：在ubuntu下</p><h4 id="1-安装java-jdk"><a href="#1-安装java-jdk" class="headerlink" title="1 安装java-jdk:"></a>1 安装java-jdk:<a id="more"></a></h4><p>a  先下载java-jdk:Java SE Development Kit 8 Downloads<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>下载对应系统的版本</p><p>b  下载到某个目录，解压到要安装的目录：如：/usr/jdk-8/</p><p>c   设置全局环境变量：如上述的安装目录，则将<br>export JAVA_HOME=/usr/jdk-8<br>export JRE_HOME=$JAVA_HOME/jre<br>export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib<br>export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin<br>添加到/etc/profile文件中，在末尾另起一行添加</p><p>d 使用source /etc/profile命令使刚才配置的信息生效</p><p>e 测试是否成功：java -version<br>测试,编写java文件：<br>public class test{<br>    public static void main(String[] args){<br>        System.out.println(“hello world”);<br>    }<br>}<br>保存为test.java，<br>生成字节码：javac test.java<br>运行:java test</p><h3 id="2-安装android-studio"><a href="#2-安装android-studio" class="headerlink" title="2 安装android-studio:"></a>2 安装android-studio:</h3><p>a 下载：在官网或者其他网站下载后<br>b 按照installion说明进行：一般是先选择要安装的目录：如/usr/android-studio<br>c　直接在终端,进入bin目录后:./studio.sh<br>d 还有其他配置．比如在任意目录都能打开软件．<br>e 其他见说明文件等</p><p>3 第一个app helloworld<br>在模拟器上运行<br>打开软件－－&gt;选择新建一个工程，适当选择之后-&gt;选择build-&gt;make project-&gt;点击run–<br>–&gt;会提示选择安装下载模拟器–&gt;选择合适的，最好不要是带锁的<br>－－－&gt;之后会提示成功．再选择建立一个模拟器，之后就可以了</p><p>注意有两种架构，x86的比arm的快10倍,但是，linux下需要加速kvm<br>如果不能运行x86的，可能需要安装kvm:<br>也可以使用genymotion模拟器</p><h4 id="4-安装kvm可选"><a href="#4-安装kvm可选" class="headerlink" title="4 安装kvm可选"></a>4 安装kvm可选</h4><p>要知道Android的编译环境Google首推Linux平台（64位的Ubuntu）而Mac系统排到第二位。那么在Linux平台下是如何硬件加速的呢？<br>那就是传说中的kvm（Kernel-based Virtual Machine），同样的，它需要硬件的支持，比如intel的VT和AMD的V，它是基于硬件的完全虚拟化。<br>首先要确定你的cpu满足要求，下面有几个命令可以参考：</p><p>$ egrep -c ‘(vmx|svm)’ /proc/cpuinfo<br>4</p><p>打印的值不为0即可。</p><p>下面安装kvm：</p><p>$ sudo apt-get install qemu-kvm<br>$ sudo adduser linc kvm<br>$ sudo apt-get install libvirt-bin ubuntu-vm-builder bridge-utils<br>$ sudo adduser linc libvirtd</p><p>(linc为用户名，适当改）<br>检验安装是否成功：</p><p>$ sudo virsh -c qemu:///system list</p><h2 id="Id-Name-State"><a href="#Id-Name-State" class="headerlink" title=" Id    Name                           State"></a> Id    Name                           State</h2><p>运行，在有模拟器的目录中：<br>如/home/ksx/Android/Sdk/emulator/emulator -avd Nexus_4_API_22 -qemu -m 2047 -enable-kvm</p><p>使用起来果然飞快，连打开网页的速度都令人惊奇。当然了，如果不用命令行启动，直接在Android Studio中启动x86_64架构的模拟器，速度也是很快，唯独arm架构的模拟器启动速度奇慢无比。话又说回来，既然有了比较不错的cpu，那么机器的其他配置一定差不了，这样的配置跑起模拟器来肯定要比原来强。</p><p>如果觉得用自带的模拟器不能够满足你的要求，那么可以使用第三方的模拟器Genymotion,网传开发者反应良好。</p><h4 id="5在手机上运行app"><a href="#5在手机上运行app" class="headerlink" title="5在手机上运行app"></a>5在手机上运行app</h4><p>首先连接手机，打开usb调试<br>还是一样，但是选择app那里不是app,而是选择Edit Configurations<br>之后选择usb　device，ok，就可以了，接着运行</p><h4 id="关于项目结构模式："><a href="#关于项目结构模式：" class="headerlink" title="关于项目结构模式："></a>关于项目结构模式：</h4><p>默认为android<br>设置为project可以看到整个完整的目录结构：<br>　　　　　.gradle和.idea 为自动生成<br>　　　　　app<br>　　　　　build   编译时自动生成的文件，不用太关心<br>　　　　　gradle   包含gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，会自动根据本地缓存情况来决定是否联网下载gradle<br>     .gitignore<br>     build.gradle<br>     gradle.properties  全局的gradle配置文件，这里配置的属性会影响项目中所有的的gradle编译脚本<br>     gradlew　和gradlew.bat在命令行中执行gradle命令<br>     local.properties　　指定本机android sdk路径<br>     setting.gradle指定项目中引入的模块</p><pre><code>app目录下build　　为自动生成，同上lib   项目使用的第三方库test 测试用例proguard-rules.pro  代码混淆规则</code></pre><h4 id="build-gradle-intruduce"><a href="#build-gradle-intruduce" class="headerlink" title="build gradle intruduce"></a>build gradle intruduce</h4><p>gradle  Groovy 领域语言　　DSL    摒弃了Ant 和Maven </p><p>在app 外有一个 build.gradle。在app中有一个build.gradle</p><p>在外面的　gradle 也可以构建c++等项目，<br>buildscript {<br>    repositories {<br>        jcenter()　　　//代码托管仓库　利用它可以轻松引用jcenter开源项目</p><pre><code>}dependencies {    classpath &apos;com.android.tools.build:gradle:2.3.2&apos;　　//声明构建的是android    // NOTE: Do not place your application dependencies here; they belong    // in the individual module build.gradle files}</code></pre><p>}</p><p>allprojects {<br>    repositories {<br>        jcenter()<br>    }<br>}</p><p>task clean(type: Delete) {<br>    delete rootProject.buildDir<br>}</p><p>app中<br>apply plugin: ‘com.android.application’　//表明为android 应用程序模块，为com.android.library表示库模块</p><p>android {　　　//安卓闭包<br>    compileSdkVersion 25　　　　//项目的编译版本，25为API 25,对应android 7.1<br>    buildToolsVersion “25.0.3”   //项目构建工具版本<br>    defaultConfig {<br>        applicationId “org.example.myactivity1”　　　项目包名<br>        minSdkVersion 25　　　　　//项目最低兼容的android系统版本<br>        targetSdkVersion 25　　//表明如22表示只在22测试充分，如不启动运行时权限，android６　的运行时权限就不会加，表明只在5上做充分测试<br>        versionCode 1　　　项目版本编号<br>        versionName “1.0”　　　项目版本名<br>        testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner”<br>    }<br>    buildTypes {//分debug和release版本<br>        release {<br>            minifyEnabled false　//是否混淆代码<br>            proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’//混淆时使用的规则文件，.txt为sdk文件。pro为根目录文件<br>        }<br>    }<br>}</p><p>dependencies {//分本地依赖，库依赖和远程依赖<br>    compile fileTree(dir: ‘libs’, include: [‘*.jar’])　　//本地依赖声明<br>    androidTestCompile(‘com.android.support.test.espresso:espresso-core:2.2.2’, {<br>        exclude group: ‘com.android.support’, module: ‘support-annotations’<br>    })<br>    compile ‘com.android.support:appcompat-v7:25.3.1’　　//　依赖库<br>    compile ‘com.android.support.constraint:constraint-layout:1.0.2’<br>    testCompile ‘junit:junit:4.12’　　//测试用例库<br>}</p><p>其他：分区工具：gpart,在官网上找到live usb之后下载并做成启动盘，就可以对任意的格式文件系统进行分区，在ubuntu 本地是无法对根目录扩容的，所以可以这样做来扩容</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;install-and-make-first-app&quot;&gt;&lt;a href=&quot;#install-and-make-first-app&quot; class=&quot;headerlink&quot; title=&quot;install and make first app&quot;&gt;&lt;/a&gt;install and make first app&lt;/h3&gt;&lt;p&gt;20170608&lt;br&gt;今天主要是安装了android-studio环境并成功开发第一个helloworld   app 在模拟器和手机上运行，下面是整个教程：在ubuntu下&lt;/p&gt;
&lt;h4 id=&quot;1-安装java-jdk&quot;&gt;&lt;a href=&quot;#1-安装java-jdk&quot; class=&quot;headerlink&quot; title=&quot;1 安装java-jdk:&quot;&gt;&lt;/a&gt;1 安装java-jdk:
    
    </summary>
    
      <category term="android" scheme="http://xdksx.github.io/categories/android/"/>
    
    
      <category term="android_make" scheme="http://xdksx.github.io/tags/android-make/"/>
    
  </entry>
  
  <entry>
    <title>android_howto_makeapk_cmd</title>
    <link href="http://xdksx.github.io/2018/05/20/android-howto-makeapk-cmd/"/>
    <id>http://xdksx.github.io/2018/05/20/android-howto-makeapk-cmd/</id>
    <published>2018-05-20T09:08:46.000Z</published>
    <updated>2018-05-20T20:37:45.354Z</updated>
    
    <content type="html"><![CDATA[<h3 id="how-to-make-a-android-by-cmd"><a href="#how-to-make-a-android-by-cmd" class="headerlink" title="how to make a android by cmd :"></a>how to make a android by cmd :</h3><pre><code>在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni</code></pre><a id="more"></a><h3 id="way-1-方法１"><a href="#way-1-方法１" class="headerlink" title="way 1:方法１"></a>way 1:方法１</h3><h4 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h4><pre><code>android studio 创建了一个工程，然后手动在命令行打包，进入工程里的.  或者direct use andrid create project创建</code></pre><p>cd ~/Desktop/FirstTest/app/src/main<br>mkdir gen<br>mkdir build<br>mkdir out</p><p>在android工程目录下建立Makefile文件，添加如下代码：<br>    SDK=~/Android/Sdk　　　　<br>    BUILD_TOOLS=$(SDK)/build-tools/25.0.3<br>    PLATFORMS=$(SDK)/platforms/android-25<br>    aapt=$(BUILD_TOOLS)/aapt<br>    dx=$(BUILD_TOOLS)/dx<br>    aidl=$(BUILD_TOOLS)/aidl<br>    apkbuilder=$(SDK)/tools/apkbuilder2 //后面不支持apkbuilder所以<br>    adb=$(SDK)/platform-tools/adb</p><h4 id="资源编译，生成-R-java"><a href="#资源编译，生成-R-java" class="headerlink" title="资源编译，生成 R.java"></a>资源编译，生成 R.java</h4><pre><code>aapt_task:    $(aapt) package \    -f \ #如果编译出来的文件已经存在，强制覆盖    -M  AndroidManifest.xml  \ # Mainifest.xml 的路径    -I  $(PLATFORMS)/android.jar \ # 某个版本平台的 android.jar 的路径　#依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...    -S  res/ \ # res 文件夹路径    -J gen/ \ # 生成 R.java 的输出目录    -m  #使得生成的包的目录放在 -J 参数指定的目录</code></pre><h4 id="代码编译，生成-class"><a href="#代码编译，生成-class" class="headerlink" title="代码编译，生成 .class"></a>代码编译，生成 .class</h4><pre><code>javac_task:    javac -source 1.7 -target 1.7 \ # 使用 jdk1.8 编译 1.7 的 .class 文件    -encoding UTF-8 \     -bootclasspath  $(PLATFORMS)/android.jar \ #覆盖引导类文件的位置 依赖多个文件时用:隔开如:-I xx.jar:xxx.jar:...    -d build/ \ #指定放置生成的类文件的位置    java/thereisnospon/dextest/*.java \    gen/thereisnospon/dextest/*.java \</code></pre><h4 id="生成-dex"><a href="#生成-dex" class="headerlink" title="生成 .dex"></a>生成 .dex</h4><pre><code>dx_task:    $(dx) --dex --output=build/classes.dex \    build  </code></pre><h4 id="资源文件初始包"><a href="#资源文件初始包" class="headerlink" title="资源文件初始包"></a>资源文件初始包</h4><pre><code>resapk_task:    $(aapt) package -f \    -M  AndroidManifest.xml  \    -I  $(PLATFORMS)/android.jar \    -S  res/ \    -F  out/resources</code></pre><h4 id="将-dex-文件加入到资源文件初始包中"><a href="#将-dex-文件加入到资源文件初始包中" class="headerlink" title="将.dex 文件加入到资源文件初始包中"></a>将.dex 文件加入到资源文件初始包中</h4><p>　　<br>注意这一步由于－rf xxx得在,src文件夹的母文件夹下执行</p><pre><code>apk_task:        java -cp $(SDK)/tools/lib/sdklib-25.3.2.jar \      com.android.sdklib.build.ApkBuilderMain \      Demo.apk -v -u -z src/main/out/resources\      -f src/main/build/classes.dex -rf src</code></pre><h4 id="签名，使用debug的签名"><a href="#签名，使用debug的签名" class="headerlink" title="签名，使用debug的签名"></a>签名，使用debug的签名</h4><pre><code>signer:    jarsigner -verbose \    -keystore ~/.android/debug.keystore \    -storepass android \    -keypass android \    Demo.apk  androiddebugkey</code></pre><h4 id="一次性打包"><a href="#一次性打包" class="headerlink" title="一次性打包"></a>一次性打包</h4><pre><code>pkg:     make apk_task    make signer </code></pre><h4 id="卸载apk"><a href="#卸载apk" class="headerlink" title="卸载apk"></a>卸载apk</h4><pre><code>uninstall:    $(adb) uninstall  thereisnospon.dextest</code></pre><h4 id="安装apk"><a href="#安装apk" class="headerlink" title="安装apk"></a>安装apk</h4><pre><code>install:     $(adb) install out/app.apk</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>run:<br>    make pkg<br>    make uninstall<br>    make install</p><pre><code>$(adb) shell am start -n thereisnospon.dextest/        thereisnospon.dextest.MainActivity  </code></pre><h3 id="方法２，用gradle"><a href="#方法２，用gradle" class="headerlink" title="方法２，用gradle,"></a>方法２，用gradle,</h3><p>首先用AS 建立工程，之后在工程文件下，之星执行，gradle clean<br>gradle build<br>即生成apk文件</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;how-to-make-a-android-by-cmd&quot;&gt;&lt;a href=&quot;#how-to-make-a-android-by-cmd&quot; class=&quot;headerlink&quot; title=&quot;how to make a android by cmd :&quot;&gt;&lt;/a&gt;how to make a android by cmd :&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在解压了一个APK文件之后会发现它包含的内容：签名文件夹（三个文件），res文件夹（放置资源），Dalvik,class文件,AndroidMainifest,resources.arsc,若是通过ndk开发，则还包含jni
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="android" scheme="http://xdksx.github.io/categories/android/"/>
    
    
      <category term="android_make" scheme="http://xdksx.github.io/tags/android-make/"/>
    
  </entry>
  
  <entry>
    <title>android_will_write</title>
    <link href="http://xdksx.github.io/2018/05/20/android-will-write/"/>
    <id>http://xdksx.github.io/2018/05/20/android-will-write/</id>
    <published>2018-05-20T08:58:26.000Z</published>
    <updated>2018-05-20T16:59:56.405Z</updated>
    
    <content type="html"><![CDATA[<p>#test categories<br>this is the android categories to test </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#test categories&lt;br&gt;this is the android categories to test &lt;/p&gt;

      
    
    </summary>
    
      <category term="android" scheme="http://xdksx.github.io/categories/android/"/>
    
    
      <category term="android_activity" scheme="http://xdksx.github.io/tags/android-activity/"/>
    
  </entry>
  
  <entry>
    <title>test_article_picture</title>
    <link href="http://xdksx.github.io/2018/05/20/test-article-picture/"/>
    <id>http://xdksx.github.io/2018/05/20/test-article-picture/</id>
    <published>2018-05-20T07:46:24.000Z</published>
    <updated>2018-05-20T15:54:54.521Z</updated>
    
    <content type="html"><![CDATA[<p>##this is a test of picture<br><img src="/2018/05/20/test-article-picture/example.jpg" title="This is an example image"><br>end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##this is a test of picture&lt;br&gt;&lt;img src=&quot;/2018/05/20/test-article-picture/example.jpg&quot; title=&quot;This is an example image&quot;&gt;&lt;br&gt;end&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="test" scheme="http://xdksx.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>ksance test article</title>
    <link href="http://xdksx.github.io/2018/05/19/ksance-test-article/"/>
    <id>http://xdksx.github.io/2018/05/19/ksance-test-article/</id>
    <published>2018-05-19T16:10:13.000Z</published>
    <updated>2018-05-20T00:57:45.225Z</updated>
    
    <content type="html"><![CDATA[<p> this is a test article by ksance </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; this is a test article by ksance &lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
